Project Path: arc_gmh5225_AMD-SP-Loader_1hh6yc78

Source Tree:

```txt
arc_gmh5225_AMD-SP-Loader_1hh6yc78
├── LICENSE
├── README.md
├── __init__.py
├── bn_view_abl.py
├── bn_view_bootloader.py
├── data
│   └── syscalls.json
├── plugin.json
├── psp_file.py
├── psp_types.py
└── svc_annotate.py

```

`LICENSE`:

```
MIT License

Copyright (c) 2023 Specter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# AMD-SP/PSP Loader 
Author: **dayzerosec**

_Loader for AMD-SP or PSP firmware binaries._

![](https://i.imgur.com/MH9C1hu.png)

## Description

Binary Ninja loader for AMD Secure Processor (SP) / Platform Security Processor (PSP) firmware binaries. It will try to load AGESA Bootloader (ABL) and Bootloader blobs and will setup the correct load addresses.

The ABL loader will also optionally annotate syscalls using the dictionary in [./data/syscalls.json](./data/syscalls.json).

## Installation

To install this plugin, go to Binary Ninja's plugin directory (can be found by going to Tools -> "Open Plugin Folder"), and run the following command:

```
git clone https://github.com/dayzerosec/AMD-SP-Loader
```

Note you'll probably need to restart Binary Ninja for the plugin to load.

## Usage

This loader is intended to be used with binaries extracted via [PSPTool](https://github.com/PSPReverse/PSPTool), as this loader will **not extract firmware from UEFI or perform any decompression before loading**.

Simply load an `ABL*` or `PSP_FW_BOOTLOADER_*` binary to use the loader. Your view name on the top left of the disassembly pane should have an `AMD-SP` prefix. If your particular firmware blob doesn't load and/or loads at an incorrect address, please file an issue.

## Future Work / Places for Contribution

- [ ] Currently load addresses are static, perhaps this should be reworked to dynamically determine it via parsing entrypoint instructions?
- [ ] Add loaders for other firmwares
  - [ ] SMU (xtensa)
  - [ ] Trusted OS (tOS)
  - [ ] Boot time trustlets
- [ ] Reverse and add more syscalls to the annotation dictionary
  - [ ] Update args of existing syscalls
- [ ] Improve annotations to fix-up syscalls in HLIL

## Notes

- The loaders make some assumptions on the load address and such, so its possible a particular binary differs and won't load properly (open an issue).
- Syscall annotations that are prefixed with a `_` are unofficial/guessed.

## Minimum Version

This plugin requires the following minimum version of Binary Ninja:
 * release - 3.2.3814

## Resources

- [https://github.com/PSPReverse](https://github.com/PSPReverse)
- [https://doc.coreboot.org/soc/amd/psp_integration.html](https://doc.coreboot.org/soc/amd/psp_integration.html)
- [https://github.com/sameershaik/coreboot_beagle-xM/blob/main/src/vendorcode/amd/fsp/cezanne/include/bl_uapp/bl_syscall_public.h](https://github.com/sameershaik/coreboot_beagle-xM/blob/main/src/vendorcode/amd/fsp/cezanne/include/bl_uapp/bl_syscall_public.h)

## License

This plugin is released under a [MIT](LICENSE) license.

## Thanks
- PSPReverse for previous work and awesome resources.
- Carstein (inspiration and reference for syscall annotation via [Syscaller](https://github.com/carstein/Syscaller).

```

`__init__.py`:

```py
from .bn_view_abl import ABLView
from .bn_view_bootloader import BootloaderView

ABLView.register()
BootloaderView.register()
```

`bn_view_abl.py`:

```py
'''
File:      bn_view_abl.py
Author(s): @SpecterDev
Purpose:   Implements the ABL binary view for binja
'''

import binaryninja as bn
import json
import os
from .psp_file import PSPFile
from .psp_types import *
from .svc_annotate import annotate

# Note: These came from reversing various firmwares. Some versions may differ where things are loaded in SRAM.
# TODO: There might be a better way to do this, such as parsing instructions to determine the location?
LOAD_ADDR_ABL0 = 0x15100
LOAD_ADDR_ABLN = 0x16200

class ABLView(bn.BinaryView):
    name = "AMD-SP ABL"
    long_name = "AMD-SP ABL"
    do_annotation = False

    def __init__(self, data):
        bn.BinaryView.__init__(self, parent_view=data, file_metadata=data.file)
        self.data = data
        self.psp_file = PSPFile(data)

        # Prompt the user if they want annotation if theres no existing database
        if not self.has_database:
            do_annotate = bn.get_choice_input('Do you want syscalls annotated?', 'Annotate syscalls?', ['Yes', 'No'])

            if do_annotate == 0:
                self.db = self.load_syscall_db()
                self.do_annotation = True

    def log(self, msg, error=False):
        msg = f"[AMD-SP ABL Loader] {msg}"
        if not error:
            bn.log_info(msg)
        else:
            bn.log_error(msg)

    def load_syscall_db(self):
        current_file_path = os.path.dirname(os.path.abspath(__file__))
        db_path = os.path.join(current_file_path, 'data', 'syscalls.json')
        db_file = open(db_path, 'r')
        return json.load(db_file)

    def define_header_struct(self):
        header_struct = create_header_struct_type()
        self.define_user_data_var(self.load_address, header_struct, 'psp_file_header')

    @classmethod
    def is_valid_for_data(self, data):
        self.psp_file = PSPFile(data)

        if self.psp_file.is_abl() and self.psp_file.get_abl_num() >= 0:
            return True
        return False

    def on_complete(self):
        # Define structs
        self.define_header_struct()

        # Annotate syscalls (if the user has specified to do so)
        if self.do_annotation:
            self.log("Annotating syscalls...")
            funcs = self.functions
            annotate(funcs, self.db, self)
        else:
            self.log("Skipping syscall annotation")

    def init(self):
        # PSP binaries are always armv7 (and userspace at least will likely switch to thumb2)
        self.arch = bn.Architecture["armv7"]
        self.platform = self.arch.standalone_platform

        # Load the binary. Data is mixed with code, and so it should be RWX.
        abl_num = self.psp_file.get_abl_num()
        if abl_num == 0:
            self.load_address = LOAD_ADDR_ABL0
        else:
            self.load_address = LOAD_ADDR_ABLN

        self.log("Detected AMD-SP/PSP ABL binary (abl={:d})".format(abl_num))

        # Header segment
        header_segment_offset = self.load_address
        header_segment_size   = 0x100
        self.add_auto_segment(
            header_segment_offset,
            header_segment_size,
            0,
            header_segment_size,
            bn.SegmentFlag.SegmentReadable
        )

        self.add_user_section("header", header_segment_offset, header_segment_size,
            bn.SectionSemantics.ReadOnlyDataSectionSemantics)

        # Code/data segment
        code_segment_offset = self.load_address + header_segment_size
        code_segment_size = len(self.parent_view) - 0x100

        self.add_auto_segment(
            code_segment_offset,
            code_segment_size,
            header_segment_size,
            code_segment_size,
            bn.SegmentFlag.SegmentReadable | bn.SegmentFlag.SegmentWritable | bn.SegmentFlag.SegmentExecutable
        )

        self.add_user_section("code", code_segment_offset, code_segment_size,
            bn.SectionSemantics.ReadOnlyCodeSectionSemantics)

        # Add the entrypoint, which is always immediately after the header at 0x100
        self.add_entry_point(code_segment_offset)

        self.define_auto_symbol_and_var_or_function(
            bn.Symbol(bn.SymbolType.FunctionSymbol, code_segment_offset, '_start'),
            bn.Type.function(bn.Type.void(), []),
            bn.Architecture["armv7"].standalone_platform
        )

        self.update_analysis()
        
        # Register a completion event to annotate syscalls
        bn.AnalysisCompletionEvent(self, self.on_complete)
        return True

```

`bn_view_bootloader.py`:

```py
'''
File:      bn_view_bootloader.py
Author(s): @SpecterDev
Purpose:   Implements the bootloader binary view for binja
'''

import binaryninja as bn
from .psp_file import PSPFile
from .psp_types import *

# Note: These came from reversing various firmwares. Some versions may differ where things are loaded in SRAM.
LOAD_ADDR_BOOTLOADER = 0

class BootloaderView(bn.BinaryView):
    name = "AMD-SP Bootloader"
    long_name = "AMD-SP Bootloader"

    def log(self, msg, error=False):
        msg = f"[AMD-SP Bootloader Loader] {msg}"
        if not error:
            bn.log_info(msg)
        else:
            bn.log_error(msg)

    def __init__(self, data):
        bn.BinaryView.__init__(self, parent_view=data, file_metadata=data.file)
        self.data = data
        self.psp_file = PSPFile(data)

    def define_header_struct(self):
        header_struct = create_header_struct_type()
        self.define_user_data_var(self.load_address, header_struct, 'psp_file_header')

    @classmethod
    def is_valid_for_data(self, data):
        self.psp_file = PSPFile(data)
        return self.psp_file.is_bootloader()

    def on_complete(self):
        # Define structs
        self.define_header_struct()

    def init(self):
        # PSP binaries are always armv7 (and userspace at least will likely switch to thumb2)
        self.arch = bn.Architecture["armv7"]
        self.platform = self.arch.standalone_platform

        # Load the binary. Data is mixed with code, and so it should be RWX.
        self.load_address = LOAD_ADDR_BOOTLOADER

        self.log("Detected AMD-SP/PSP Bootloader binary")

        # Header segment
        header_segment_offset = self.load_address
        header_segment_size   = 0x100
        self.add_auto_segment(
            header_segment_offset,
            header_segment_size,
            0,
            header_segment_size,
            bn.SegmentFlag.SegmentReadable
        )

        self.add_user_section("header", header_segment_offset, header_segment_size,
            bn.SectionSemantics.ReadOnlyDataSectionSemantics)

        # Code/data segment
        code_segment_offset = self.load_address + header_segment_size
        code_segment_size = len(self.parent_view) - 0x100

        self.add_auto_segment(
            code_segment_offset,
            code_segment_size,
            header_segment_size,
            code_segment_size,
            bn.SegmentFlag.SegmentReadable | bn.SegmentFlag.SegmentWritable | bn.SegmentFlag.SegmentExecutable
        )

        self.add_user_section("code", code_segment_offset, code_segment_size,
            bn.SectionSemantics.ReadOnlyCodeSectionSemantics)

        # Add the entrypoint, which is always immediately after the header at 0x100
        self.add_entry_point(code_segment_offset)

        self.define_auto_symbol_and_var_or_function(
            bn.Symbol(bn.SymbolType.FunctionSymbol, code_segment_offset, '_start'),
            bn.Type.function(bn.Type.void(), []),
            bn.Architecture["armv7"].standalone_platform
        )

        self.update_analysis()

        # Register a completion event to create structs
        bn.AnalysisCompletionEvent(self, self.on_complete)
        return True

```

`data/syscalls.json`:

```json
{
    "0":{
        "name":"SVC_EXIT",
        "args":[
            {
                "type":"uint32_t",
                "name":"status"
            }
        ]
    },
    "1":{
        "name":"_SVC_APP_INIT",
        "args":[
        ]
    },
    "2":{
        "name":"SVC_ENTER",
        "args":[
            {
                "type":"uint32_t",
                "name":"entry_type"
            },
            {
                "type":"void*",
                "name":"dest"
            },
            {
                "type":"uint32_t*",
                "name":"size"
            }
        ]
    },
    "3":{
        "name":"_SVC_SMN_MAP_EX",
        "args":[
        ]
    },
    "4":{
        "name":"_SVC_SMN_MAP",
        "args":[
        ]
    },
    "6":{
        "name":"SVC_DEBUG_PRINT",
        "args":[
            {
                "type":"const char*",
                "name":"string"
            }
        ]
    },
    "7":{
        "name":"_SVC_X86_MEM_MAP",
        "args":[
        ]
    },
    "8":{
        "name":"_SVC_X86_MEM_UNMAP",
        "args":[
        ]
    },
    "9":{
        "name":"_SVC_X86_COPY_TO_PSP",
        "args":[
        ]
    },
    "10":{
        "name":"_SVC_X86_COPY_FROM_PSP",
        "args":[
        ]
    },
    "26":{
        "name":"SVC_DEBUG_PRINT_EX",
        "args":[
            {
                "type":"uint32_t",
                "name":"dword0"
            },
            {
                "type":"uint32_t",
                "name":"dword1"
            },
            {
                "type":"uint32_t",
                "name":"dword2"
            },
            {
                "type":"uint32_t",
                "name":"dword3"
            }
        ]
    },
    "28":{
        "name":"SVC_GET_BOOT_MODE",
        "args":[
            {
                "type":"uint32_t*",
                "name":"boot_mode"
            }
        ]
    },
    "37":{
        "name":"_SVC_X86_MEM_MAP_EX",
        "args":[
        ]
    },
    "40":{
        "name":"_SVC_SMU_MSG",
        "args":[
        ]
    },
    "57":{
        "name":"_SVC_RNG",
        "args":[
        ]
    },
    "60":{
        "name":"_SVC_QUERY_SAVE_STATE_REGION",
        "args":[
        ]
    },
    "72":{
        "name":"_SVC_QUERY_SMM_REGION",
        "args":[
        ]
    },
    "96":{
        "name":"SVC_GET_SPI_INFO",
        "args":[
            {
                "type":"struct spirom_info*",
                "name":"spi_rom_info"
            }
        ]
    },
    "97":{
        "name":"SVC_MAP_SPIROM_DEVICE",
        "args":[
            {
                "type":"void*",
                "name":"spi_rom_addr"
            },
            {
                "type":"uint32_t",
                "name":"size"
            },
            {
                "type":"void**",
                "name":"spi_rom_axi_addr"
            }
        ]
    },
    "98":{
        "name":"SVC_UNMAP_SPIROM_DEVICE",
        "args":[
            {
                "type":"void*",
                "name":"spi_rom_addr"
            }
        ]
    },
    "99":{
        "name":"SVC_MAP_FCH_IO_DEVICE",
        "args":[
            {
                "type":"uint32_t",
                "name":"io_device"
            },
            {
                "type":"uint32_t",
                "name":"arg1"
            },
            {
                "type":"uint32_t",
                "name":"arg2"
            },
            {
                "type":"void**",
                "name":"io_device_axi_addr"
            }
        ]
    },
    "100":{
        "name":"SVC_UNMAP_FCH_IO_DEVICE",
        "args":[
            {
                "type":"uint32_t",
                "name":"io_device"
            },
            {
                "type":"void*",
                "name":"io_device_axi_addr"
            }
        ]
    },
    "101":{
        "name":"SVC_UPDATE_PSP_BIOS_DIR",
        "args":[
            {
                "type":"uint32_t*",
                "name":"psp_dir_offset"
            },
            {
                "type":"uint32_t*",
                "name":"bios_dir_offset"
            }
        ]
    },
    "102":{
        "name":"SVC_COPY_DATA_FROM_UAPP",
        "args":[
            {
                "type":"void*",
                "name":"address"
            },
            {
                "type":"uint32_t",
                "name":"size"
            }
        ]
    }
}

```

`plugin.json`:

```json
{
   "pluginmetadataversion": 2,
   "name": "AMD-SP/PSP Loader",
   "author": "dayzerosec",
   "type": [
      "binaryview"
   ],
   "api": [
      "python3"
   ],
   "description": "Loader for AMD-SP or PSP firmware binaries.",
   "longdescription": "# AMD-SP/PSP Loader \n\nAuthor: **SpecterDev**\n\n_Loader for AMD-SP or PSP firmware binaries._\n\n![](https://i.imgur.com/MH9C1hu.png)\n\n## Description\n\nBinary Ninja loader for AMD Secure Processor (SP) / Platform Security Processor (PSP) firmware binaries. It will try to load AGESA Bootloader (ABL) and Bootloader blobs and will setup the correct load addresses.\n\nThe ABL loader will also optionally annotate syscalls using the dictionary in `./data/syscalls.json`.\n\n## Usage\n\nThis loader is intended to be used with binaries extracted via [PSPTool](https://github.com/PSPReverse/PSPTool), as this loader will **not extract firmware from UEFI or perform any decompression before loading**.\n\nSimply load an `ABL*` or `PSP_FW_BOOTLOADER_*` binary to use the loader. Your view name on the top left of the disassembly pane should have an `AMD-SP` prefix. If your particular firmware blob doesn't load and/or loads at an incorrect address, please file an issue.\n\n## Future Work / Places for Contribution\n\n- [ ] Currently load addresses are static, perhaps this should be reworked to dynamically determine it via parsing entrypoint instructions?\n- [ ] Add loaders for other firmwares\n  - [ ] SMU (xtensa)\n  - [ ] Trusted OS (tOS)\n  - [ ] Boot time trustlets\n- [ ] Reverse and add more syscalls to the annotation dictionary\n- [ ] Improve annotations to fix-up syscalls in HLIL\n\n## Notes\n\n- The loaders make some assumptions on the load address and such, so its possible a particular binary differs and won't load properly (open an issue).\n\n## Minimum Version\n\nThis plugin requires the following minimum version of Binary Ninja:\n * release - 3.2.3814\n\n## License\n\nThis plugin is released under a MIT license.\n",
   "license": {
      "name": "MIT",
      "text": "Copyright 2023 dayzerosec\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
   },
   "platforms": [
      "Darwin",
      "Windows",
      "Linux"
   ],
   "installinstructions": {
      "Darwin": "",
      "Windows": "",
      "Linux": ""
   },
   "version": "1.0",
   "minimumbinaryninjaversion": 3814
}

```

`psp_file.py`:

```py
'''
File:      psp_file.py
Author(s): @SpecterDev, github.com/PSPReverse
Purpose:   Contains PSPFile helper class to parse AMD-SP/PSP file headers.
Note:      Much of the info here is undocumented and therefore reversed and not complete (and may not be accurate).
           A lot of it came from PSPReverse and their PSPTool. Check their repositories for more details.
'''
import struct

# PSP Magic constants + masks
PSP_MAGIC_GENERIC               = 0x24505331 # "$PS1"

# PSP Magic Variant A (seen on ABL version <= 19.7.8.30)
PSP_MAGIC_ABL_VARIANT_A         = 0x00424157 # "[N]BAW"
PSP_MAGIC_ABL_VARIANT_A_MASK    = 0xFF000000
PSP_MAGIC_ABL_VARIANT_A_SHIFT   = 24

# PSP Magic Variant B (seen on 19.8.12.0 <= ABL version <= 20.10.19.0)
PSP_MAGIC_ABL_VARIANT_B         = 0x41570042 # "AW[N]B"
PSP_MAGIC_ABL_VARIANT_B_MASK    = 0x0000FF00
PSP_MAGIC_ABL_VARIANT_B_SHIFT   = 8

# PSP Directory Entry Types
PSP_FW_BOOT_LOADER          = 0x01
PSP_FW_TRUSTED_OS           = 0x02
PSP_FW_RECOVERY_BOOT_LOADER = 0x03
PSP_FW_BOOT_TIME_TRUSTLETS  = 0x0C

def swap32(i):
    return struct.unpack("<I", struct.pack(">I", i))[0]

class PSPFile:
    '''
    Layout of the PSP file header. Contributions to unknown fields + corrections would be appreciated.

    struct psp_file_header {
        char _unk_00h[0x10];            // 0x00
        char magic[0x4];                // 0x10
        uint32_t size_signed;           // 0x14
        uint32_t is_encrypted;          // 0x18
        char _unk_1Ch[0x4];             // 0x1C
        char aes_cbc_iv[0x10];          // 0x20
        uint32_t is_signed;             // 0x30
        char _unk_34h[0x4];             // 0x34
        char signature_footprint[0x10]; // 0x38
        uint32_t is_compressed;         // 0x48
        char _unk_4Ch[0x4];             // 0x4C
        uint32_t size_uncompressed;     // 0x50
        uint32_t size_zlib;             // 0x54
        char _unk_58h[0x8];             // 0x58
        uint32_t version;               // 0x60
        char _unk_64h[0x4];             // 0x64
        uint32_t load_addr;             // 0x68
        uint32_t rom_size;              // 0x6C
        char _unk_70h[0x0C];            // 0x70
        uint32_t entry_type;            // 0x7C - matches directory table entry types
        char wrapped_ikek[0x10];        // 0x80
        char _unk_90h[0x10];            // 0x90
        uint32_t metadata;              // 0xA0
        char _unk_A4h[0x5C];            // 0xA4
    } // Size: 0x100
    '''

    def __init__(self, f):
        # 0x10-0x1C
        (self.magic, self.size_signed, self.is_encrypted) = struct.unpack("<III", f.read(0x10, 0x0C))
        self.magic = swap32(self.magic)
        
        # 0x20-0x4C
        (self.iv, self.is_signed, self.pad1, self.signature_footprint, self.is_compressed) = struct.unpack(
            "<16sI4s16sI", f.read(0x20, 0x2C))
        
        # 0x50-0x58
        (self.size_uncompressed, self.size_zlib) = struct.unpack("<II", f.read(0x50, 0x08))
        
        # 0x60-0x70
        (self.version, self.pad, self.load_addr, self.rom_size) = struct.unpack("<I4sII", f.read(0x60, 0x10))

        # 0x7C
        self.entry_type = struct.unpack("<I", f.read(0x7C, 0x04))[0]
        
        # 0x80-0x90
        self.wrapped_key = struct.unpack("<16s", f.read(0x80, 0x10))[0]

        # 0xA0-0xA4
        self.metadata = struct.unpack("<I", f.read(0xA0, 0x04))[0]
        self.metadata = swap32(self.metadata)

    def is_abl(self):
        # If the magic is an ABL magic, we can safely assume it's an ABL binary
        if (self.magic & ~PSP_MAGIC_ABL_VARIANT_A_MASK) == PSP_MAGIC_ABL_VARIANT_A:
            return True
        
        if (self.magic & ~PSP_MAGIC_ABL_VARIANT_B_MASK) == PSP_MAGIC_ABL_VARIANT_B:
            return True
        
        # If the magic is generic we need to check a few locations
        if self.magic == PSP_MAGIC_GENERIC:
            # First, check if the entry type is an ABL type
            if self.entry_type >= 0x30 and self.entry_type <= 0x37:
                return True
            
            # Fallback on metadata, if it's non-zero bytes, we can also probably assume it's an ABL binary
            if self.metadata != 0:
                return True
        
        return False

    def is_bootloader(self):
        if self.entry_type == PSP_FW_BOOT_LOADER or self.entry_type == PSP_FW_RECOVERY_BOOT_LOADER:
            return True
        return False

    def is_trusted_os(self):
        return self.entry_type == PSP_FW_TRUSTED_OS

    def is_boot_time_trustlets(self):
        return self.entry_type == PSP_FW_BOOT_TIME_TRUSTLETS

    def get_abl_num(self):
        # Sanity check
        if not self.is_abl():
            return -1

        # Get via type field
        return self.entry_type - 0x30

```

`psp_types.py`:

```py
'''
File:      psp_types.py
Author(s): @SpecterDev, github.com/PSPReverse
Purpose:   Type library for PSP stuff
Note:      Much of the info here is undocumented and therefore reversed and not complete (and may not be accurate).
           A lot of it came from PSPReverse and their PSPTool. Check their repositories for more details.
'''
import binaryninja as bn

def create_header_struct_type():
    struct_type = bn.types.StructureBuilder.create()

    struct_type.append(bn.Type.array(bn.Type.int(1), 0x10), '_unk_00h')
    struct_type.append(bn.Type.array(bn.Type.int(1), 0x4), 'magic')
    struct_type.append(bn.Type.int(4, False), 'size_signed')
    struct_type.append(bn.Type.int(4), 'is_encrypted')
    struct_type.append(bn.Type.array(bn.Type.int(1), 0x4), '_unk_1Ch')
    struct_type.append(bn.Type.array(bn.Type.int(1), 0x10), 'aes_cbc_iv')
    struct_type.append(bn.Type.int(4), 'is_signed')
    struct_type.append(bn.Type.array(bn.Type.int(1), 0x4), '_unk_34h')
    struct_type.append(bn.Type.array(bn.Type.int(1), 0x10), 'signature_footprint')
    struct_type.append(bn.Type.int(4), 'is_compressed')
    struct_type.append(bn.Type.array(bn.Type.int(1), 0x4), 'unk_4Ch')
    struct_type.append(bn.Type.int(4, False), 'size_uncompressed')
    struct_type.append(bn.Type.int(4, False), 'size_zlib')
    struct_type.append(bn.Type.array(bn.Type.int(1), 0x8), 'unk_58h')
    struct_type.append(bn.Type.int(4, False), 'version')
    struct_type.append(bn.Type.array(bn.Type.int(1), 0x4), 'unk_64h')
    struct_type.append(bn.Type.int(4, False), 'load_addr')
    struct_type.append(bn.Type.int(4, False), 'rom_size')
    struct_type.append(bn.Type.array(bn.Type.int(1), 0xC), 'unk_70h')
    struct_type.append(bn.Type.int(4, False), 'entry_type')
    struct_type.append(bn.Type.array(bn.Type.int(1), 0x10), 'wrapped_ikek')
    struct_type.append(bn.Type.array(bn.Type.int(1), 0x10), 'unk_90h')
    struct_type.append(bn.Type.int(4, False), 'metadata')
    struct_type.append(bn.Type.array(bn.Type.int(1), 0x5C), 'unk_A4h')

    return struct_type


```

`svc_annotate.py`:

```py
'''
File:      svc_annotate.py
Author(s): @SpecterDev
Purpose:   Implement svc annotation of functions post-analysis
'''
import binaryninja as bn

# Blue
HIGHLIGHT_COLOR = [0, 115, 255]

def annotate(funcs, db, bv):
    for fun in funcs:
        for bb in fun.basic_blocks:
            for txt in bb.get_disassembly_text():
                if txt.tokens[0].text == "svc":
                    # Highlight syscall lines because they're important
                    color = bn.highlight.HighlightColor(
                        red=HIGHLIGHT_COLOR[0],
                        green=HIGHLIGHT_COLOR[1],
                        blue=HIGHLIGHT_COLOR[2]
                    )

                    fun.set_auto_instr_highlight(txt.address, color)
                    svc_num = txt.tokens[-1].value

                    # Lookup svc # in the database and comment
                    if str(svc_num) in db:
                        # Get svc info
                        svc = db[str(svc_num)]
                        svc_name = svc['name']
                        svc_args = svc['args']

                        # Build up comment and set
                        comment_str = svc_name + '('

                        if len(svc['args']) > 0:
                            last_arg = svc['args'][-1]
                            for arg in svc['args']:
                                comment_str += arg['type'] + ' ' + arg['name']
                                if arg != last_arg:
                                    comment_str += ', '
                        
                        comment_str += ')'
                        bv.set_comment_at(txt.address, comment_str)
                    else:
                        if svc_num > 0 and svc_num < 255:
                            bn.log_warn(f"[AMD-SP ABL Loader] Don't have SVC #{svc_num} defined in dictionary (addr=0x{txt.address:08x}).")
```