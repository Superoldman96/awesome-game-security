Project Path: arc_gmh5225_enum_real_dirbase_w2w54qio

Source Tree:

```txt
arc_gmh5225_enum_real_dirbase_w2w54qio
├── QQ截图20230818115205.png
├── README.md
├── enum_real_dirbase
│   ├── enum_real_dirbase.inf
│   ├── enum_real_dirbase.vcxproj
│   ├── enum_real_dirbase.vcxproj.filters
│   └── main.cpp
└── enum_real_dirbase.sln

```

`README.md`:

```md
# enum_real_dirbase
![Image text](https://github.com/Rythorndoran/enum_real_dirbase/blob/master/QQ%E6%88%AA%E5%9B%BE20230818115205.png)

```

`enum_real_dirbase.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.6.33815.320
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "enum_real_dirbase", "enum_real_dirbase\enum_real_dirbase.vcxproj", "{5361CFD3-1F11-4DAC-91DA-48572399DB3E}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{5361CFD3-1F11-4DAC-91DA-48572399DB3E}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{5361CFD3-1F11-4DAC-91DA-48572399DB3E}.Debug|ARM64.Build.0 = Debug|ARM64
		{5361CFD3-1F11-4DAC-91DA-48572399DB3E}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{5361CFD3-1F11-4DAC-91DA-48572399DB3E}.Debug|x64.ActiveCfg = Debug|x64
		{5361CFD3-1F11-4DAC-91DA-48572399DB3E}.Debug|x64.Build.0 = Debug|x64
		{5361CFD3-1F11-4DAC-91DA-48572399DB3E}.Debug|x64.Deploy.0 = Debug|x64
		{5361CFD3-1F11-4DAC-91DA-48572399DB3E}.Release|ARM64.ActiveCfg = Release|ARM64
		{5361CFD3-1F11-4DAC-91DA-48572399DB3E}.Release|ARM64.Build.0 = Release|ARM64
		{5361CFD3-1F11-4DAC-91DA-48572399DB3E}.Release|ARM64.Deploy.0 = Release|ARM64
		{5361CFD3-1F11-4DAC-91DA-48572399DB3E}.Release|x64.ActiveCfg = Release|x64
		{5361CFD3-1F11-4DAC-91DA-48572399DB3E}.Release|x64.Build.0 = Release|x64
		{5361CFD3-1F11-4DAC-91DA-48572399DB3E}.Release|x64.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {8FAC03B3-F1F1-4103-AE1F-9C322740E42B}
	EndGlobalSection
EndGlobal

```

`enum_real_dirbase/enum_real_dirbase.inf`:

```inf
;
; enum_real_dirbase.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=System ; TODO: specify appropriate Class
ClassGuid={4d36e97d-e325-11ce-bfc1-08002be10318} ; TODO: specify appropriate ClassGuid
Provider=%ManufacturerName%
CatalogFile=enum_real_dirbase.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages
PnpLockdown=1

[DestinationDirs]
DefaultDestDir = 12
enum_real_dirbase_Device_CoInstaller_CopyFiles = 11

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
enum_real_dirbase.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%enum_real_dirbase.DeviceDesc%=enum_real_dirbase_Device, Root\enum_real_dirbase ; TODO: edit hw-id

[enum_real_dirbase_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
enum_real_dirbase.sys

;-------------- Service installation
[enum_real_dirbase_Device.NT.Services]
AddService = enum_real_dirbase,%SPSVCINST_ASSOCSERVICE%, enum_real_dirbase_Service_Inst

; -------------- enum_real_dirbase driver install sections
[enum_real_dirbase_Service_Inst]
DisplayName    = %enum_real_dirbase.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\enum_real_dirbase.sys

;
;--- enum_real_dirbase_Device Coinstaller installation ------
;

[enum_real_dirbase_Device.NT.CoInstallers]
AddReg=enum_real_dirbase_Device_CoInstaller_AddReg
CopyFiles=enum_real_dirbase_Device_CoInstaller_CopyFiles

[enum_real_dirbase_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[enum_real_dirbase_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[enum_real_dirbase_Device.NT.Wdf]
KmdfService =  enum_real_dirbase, enum_real_dirbase_wdfsect
[enum_real_dirbase_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
DiskName = "enum_real_dirbase Installation Disk"
enum_real_dirbase.DeviceDesc = "enum_real_dirbase Device"
enum_real_dirbase.SVCDESC = "enum_real_dirbase Service"

```

`enum_real_dirbase/enum_real_dirbase.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{5361CFD3-1F11-4DAC-91DA-48572399DB3E}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">x64</Platform>
    <RootNamespace>enum_real_dirbase</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <IncludePath>$(VC_IncludePath);$(IncludePath);$(KMDF_INC_PATH)$(KMDF_VER_PATH)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="enum_real_dirbase.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`enum_real_dirbase/enum_real_dirbase.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="enum_real_dirbase.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`enum_real_dirbase/main.cpp`:

```cpp
#include <ntifs.h>
#include <ntimage.h>
#include <stdint.h>
#include <intrin.h>
EXTERN_C NTSYSAPI CHAR *PsGetProcessImageFileName(__in uintptr_t Process);
constexpr auto cr3_pfn(uint64_t _cr3) -> uint64_t { return ((_cr3 & 0xFFFFFFFFF000) >> 12); }
constexpr auto cr3_dirbase(uint64_t _cr3) -> uint64_t { return (_cr3 & 0xFFFFFFFFF000); }

#pragma warning(push)
#pragma warning(disable:4201)
struct _MMPFN {
	uintptr_t flags;
	uintptr_t pte_address;
	uintptr_t Unused_1;
	uintptr_t Unused_2;
	uintptr_t Unused_3;
	uintptr_t Unused_4;
};
static_assert(sizeof(_MMPFN) == 0x30);

typedef union {
	struct {
		uint64_t reserved1 : 3;
		uint64_t page_level_write_through : 1;
		uint64_t page_level_cache_disable : 1;
		uint64_t reserved2 : 7;
		uint64_t address_of_page_directory : 36;
		uint64_t reserved3 : 16;
	};
	uint64_t flags;
} cr3;
static_assert(sizeof(cr3) == 0x8);

typedef union {
	struct {
		uint64_t present : 1;
		uint64_t write : 1;
		uint64_t supervisor : 1;
		uint64_t page_level_write_through : 1;
		uint64_t page_level_cache_disable : 1;
		uint64_t accessed : 1;
		uint64_t dirty : 1;
		uint64_t large_page : 1;
		uint64_t global : 1;
		uint64_t ignored_1 : 2;
		uint64_t restart : 1;
		uint64_t page_frame_number : 36;
		uint64_t reserved1 : 4;
		uint64_t ignored_2 : 7;
		uint64_t protection_key : 4;
		uint64_t execute_disable : 1;
	};

	uint64_t flags;
} pt_entry_64;
static_assert(sizeof(pt_entry_64) == 0x8);
#pragma warning(pop)

static uint64_t pte_base = 0;
static uint64_t pde_base = 0;
static uint64_t ppe_base = 0;
static uint64_t pxe_base = 0;
static uint64_t self_mapidx = 0;
static uint64_t mm_pfn_database = 0;

uint64_t get_dirbase() {
	return __readcr3() & 0xFFFFFFFFFFFFF000;
}

void *phys_to_virt(uint64_t phys) {
	PHYSICAL_ADDRESS phys_addr = { .QuadPart = (int64_t)(phys) };
	return reinterpret_cast<void *>(MmGetVirtualForPhysical(phys_addr));
}

void init_pte_base() {
	cr3 system_cr3 = { .flags = get_dirbase() };
	uint64_t dirbase_phys = system_cr3.address_of_page_directory << 12;
	pt_entry_64 *pt_entry = reinterpret_cast<pt_entry_64 *>(phys_to_virt(dirbase_phys));
	for (uint64_t idx = 0; idx < 0x200; idx++) {
		if (pt_entry[idx].page_frame_number == system_cr3.address_of_page_directory) {
			pte_base = (idx + 0x1FFFE00ui64) << 39ui64;
			pde_base = (idx << 30ui64) + pte_base;
			ppe_base = (idx << 30ui64) + pte_base + (idx << 21ui64);
			pxe_base = (idx << 12ui64) + ppe_base;
			self_mapidx = idx;
			DbgPrintEx(DPFLTR_IHVDRIVER_ID , DPFLTR_ERROR_LEVEL , "PteBase 0x%llx\n" , pte_base);
			DbgPrintEx(DPFLTR_IHVDRIVER_ID , DPFLTR_ERROR_LEVEL , "PdeBase 0x%llx\n" , pde_base);
			DbgPrintEx(DPFLTR_IHVDRIVER_ID , DPFLTR_ERROR_LEVEL , "PpeBase 0x%llx\n" , ppe_base);
			DbgPrintEx(DPFLTR_IHVDRIVER_ID , DPFLTR_ERROR_LEVEL , "PxeBase 0x%llx\n" , pxe_base);
			DbgPrintEx(DPFLTR_IHVDRIVER_ID , DPFLTR_ERROR_LEVEL , "idx 0x%llx\n" , idx);

			break;
		}
	}
}

uintptr_t get_kernel_base() {
	const auto idtbase = *reinterpret_cast<uint64_t *>(__readgsqword(0x18) + 0x38);
	const auto descriptor_0 = *reinterpret_cast<uint64_t *>(idtbase);
	const auto descriptor_1 = *reinterpret_cast<uint64_t *>(idtbase + 8);
	const auto isr_base = ((descriptor_0 >> 32) & 0xFFFF0000) + (descriptor_0 & 0xFFFF) + (descriptor_1 << 32);
	auto align_base = isr_base & 0xFFFFFFFFFFFFF000;

	for (; ; align_base -= 0x1000) {
		for (auto *search_base = reinterpret_cast<uint8_t *>(align_base); search_base < reinterpret_cast<uint8_t *>(align_base) + 0xFF9; search_base++) {
			if (search_base[0] == 0x48 &&
				search_base[1] == 0x8D &&
				search_base[2] == 0x1D &&
				search_base[6] == 0xFF) {
				const auto relative_offset = *reinterpret_cast<int *>(&search_base[3]);
				const auto address = reinterpret_cast<uint64_t>(search_base + relative_offset + 7);
				if ((address & 0xFFF) == 0) {
					if (*reinterpret_cast<uint16_t *>(address) == 0x5A4D) {
						return address;
					}
				}
			}
		}
	}
}

uintptr_t search_pattern(void *module_handle , const char *signature_value) {
	static auto in_range = [] (auto x , auto a , auto b) { return (x >= a && x <= b); };
	static auto get_bits = [] (auto  x) { return (in_range((x & (~0x20)) , 'A' , 'F') ? ((x & (~0x20)) - 'A' + 0xa) : (in_range(x , '0' , '9') ? x - '0' : 0)); };
	static auto get_byte = [] (auto  x) { return (get_bits(x[0]) << 4 | get_bits(x[1])); };

	const auto dos_headers = reinterpret_cast<PIMAGE_DOS_HEADER>(module_handle);
	const auto nt_headers = reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<uintptr_t>(module_handle) + dos_headers->e_lfanew);

	const auto range_start = reinterpret_cast<uintptr_t>(module_handle);
	const auto range_end = range_start + nt_headers->OptionalHeader.SizeOfImage;

	auto first_match = 0ui64;
	auto pat = signature_value;

	for (uintptr_t cur = range_start; cur < range_end; cur++) {
		if (*pat == '\0') {
			return first_match;
		}
		if (*(uint8_t *)pat == '\?' || *reinterpret_cast<uint8_t *>(cur) == get_byte(pat)) {
			if (!first_match)
				first_match = cur;

			if (!pat[2])
				return first_match;

			if (*(uint16_t *)pat == 16191 || *(uint8_t *)pat != '\?') {
				pat += 3;
			}
			else {
				pat += 2;
			}
		}
		else {
			pat = signature_value;
			first_match = 0;
		}
	}
	return 0u;
}

uintptr_t search_pattern(void *module_handle , const char *section , const char *signature_value) {
	static auto in_range = [] (auto x , auto a , auto b) { return (x >= a && x <= b); };
	static auto get_bits = [] (auto  x) { return (in_range((x & (~0x20)) , 'A' , 'F') ? ((x & (~0x20)) - 'A' + 0xa) : (in_range(x , '0' , '9') ? x - '0' : 0)); };
	static auto get_byte = [] (auto  x) { return (get_bits(x[0]) << 4 | get_bits(x[1])); };

	const auto dos_headers = reinterpret_cast<PIMAGE_DOS_HEADER>(module_handle);
	const auto nt_headers = reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<uintptr_t>(module_handle) + dos_headers->e_lfanew);
	const auto section_headers = reinterpret_cast<PIMAGE_SECTION_HEADER>(nt_headers + 1);

	auto range_start = 0ui64;
	auto range_end = 0ui64;
	for (auto cur_section = section_headers; cur_section < section_headers + nt_headers->FileHeader.NumberOfSections; cur_section++) {
		if (strcmp(reinterpret_cast<const char *>(cur_section->Name) , section) == 0) {
			range_start = reinterpret_cast<uintptr_t>(module_handle) + cur_section->VirtualAddress;
			range_end = range_start + cur_section->Misc.VirtualSize;
		}
	}

	if (range_start == 0)
		return 0u;

	auto first_match = 0ui64;
	auto pat = signature_value;
	for (uintptr_t cur = range_start; cur < range_end; cur++) {
		if (*pat == '\0') {
			return first_match;
		}
		if (*(uint8_t *)pat == '\?' || *reinterpret_cast<uint8_t *>(cur) == get_byte(pat)) {
			if (!first_match)
				first_match = cur;

			if (!pat[2])
				return first_match;

			if (*(uint16_t *)pat == 16191 || *(uint8_t *)pat != '\?') {
				pat += 3;
			}
			else {
				pat += 2;
			}
		}
		else {
			pat = signature_value;
			first_match = 0;
		}
	}
	return 0u;
}

uintptr_t init_mmpfn_database() {
	auto search = search_pattern(reinterpret_cast<void *>(get_kernel_base()) , ".text" , "B9 ? ? ? ? 48 8B 05 ? ? ? ? 48 89 43 18") + 5;
	auto resolved_base = search + *reinterpret_cast<int32_t *>(search + 3) + 7;
	mm_pfn_database = *reinterpret_cast<uintptr_t *>(resolved_base);
	return mm_pfn_database;
}

void enum_process_dirbase() {
	auto mem_range = MmGetPhysicalMemoryRanges();
	auto mem_range_count = 0;
	static const uint64_t cr3_ptebase = self_mapidx * 8 + pxe_base;
	DbgPrintEx(DPFLTR_IHVDRIVER_ID , DPFLTR_ERROR_LEVEL , "cr3 ptebase 0x%llx\n" , cr3_ptebase);

	for (mem_range_count = 0; mem_range_count < 200; mem_range_count++) {

		if (mem_range[mem_range_count].BaseAddress.QuadPart == 0 && mem_range[mem_range_count].NumberOfBytes.QuadPart == 0)
			break;

		auto start_pfn = mem_range[mem_range_count].BaseAddress.QuadPart >> 12;
		auto end_pfn = start_pfn + (mem_range[mem_range_count].NumberOfBytes.QuadPart >> 12);

		for (auto i = start_pfn; i < end_pfn; i++) {
			auto cur_mmpfn = reinterpret_cast<_MMPFN *>(mm_pfn_database + 0x30 * i);
			if (cur_mmpfn->flags) {
				if (cur_mmpfn->flags == 1) continue;
				if (cur_mmpfn->pte_address != cr3_ptebase) continue;
				auto decrypted_eprocess = ((cur_mmpfn->flags | 0xF000000000000000) >> 0xd) | 0xFFFF000000000000;
				auto dirbase = i << 12;
				if (MmIsAddressValid(reinterpret_cast<void *>(decrypted_eprocess))) {
					DbgPrintEx(DPFLTR_IHVDRIVER_ID , DPFLTR_ERROR_LEVEL , "Process -> 0x%llx\nProcessName -> %s\nDirBase -> 0x%llx\n\n" , decrypted_eprocess , PsGetProcessImageFileName(decrypted_eprocess) , dirbase);
				}
			}
		}


	}
}


EXTERN_C NTSTATUS DriverEntry() {
	init_pte_base();
	init_mmpfn_database();
	enum_process_dirbase();
	return STATUS_SUCCESS;
}
```