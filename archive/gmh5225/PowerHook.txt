Project Path: arc_gmh5225_PowerHook_rr981l9w

Source Tree:

```txt
arc_gmh5225_PowerHook_rr981l9w
├── PowerHook.inf
├── PowerHook.sln
├── PowerHook.vcxproj
├── PowerHook.vcxproj.filters
├── README.md
└── src
    ├── Definitions.hpp
    └── DriverEntry.cpp

```

`PowerHook.inf`:

```inf
;
; PowerHook.inf
;

[Version]
Signature   = "$WINDOWS NT$"
Class       = System ; TODO: specify appropriate Class
ClassGuid   = {4d36e97d-e325-11ce-bfc1-08002be10318} ; TODO: specify appropriate ClassGuid
Provider    = %ManufacturerName%
CatalogFile = PowerHook.cat
DriverVer   = ; TODO: set DriverVer in stampinf property pages
PnpLockdown = 1

[DestinationDirs]
DefaultDestDir = 13

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
PowerHook.sys = 1,,

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName% = Standard,NT$ARCH$.10.0...16299 ; %13% support introduced in build 16299

[Standard.NT$ARCH$.10.0...16299]
%PowerHook.DeviceDesc% = PowerHook_Device, Root\PowerHook ; TODO: edit hw-id

[PowerHook_Device.NT]
CopyFiles = File_Copy

[File_Copy]
PowerHook.sys

;-------------- Service installation
[PowerHook_Device.NT.Services]
AddService = PowerHook,%SPSVCINST_ASSOCSERVICE%, PowerHook_Service_Inst

; -------------- PowerHook driver install sections
[PowerHook_Service_Inst]
DisplayName    = %PowerHook.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %13%\PowerHook.sys

[PowerHook_Device.NT.Wdf]
KmdfService = PowerHook, PowerHook_wdfsect

[PowerHook_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE = 0x00000002
ManufacturerName = "<Your manufacturer name>" ;TODO: Replace with your manufacturer name
DiskName = "PowerHook Installation Disk"
PowerHook.DeviceDesc = "PowerHook Device"
PowerHook.SVCDESC = "PowerHook Service"

```

`PowerHook.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.13.35806.99 d17.13
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "PowerHook", "PowerHook.vcxproj", "{06AE1276-2589-D560-05A9-E030C71384E1}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{06AE1276-2589-D560-05A9-E030C71384E1}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{06AE1276-2589-D560-05A9-E030C71384E1}.Debug|ARM64.Build.0 = Debug|ARM64
		{06AE1276-2589-D560-05A9-E030C71384E1}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{06AE1276-2589-D560-05A9-E030C71384E1}.Debug|x64.ActiveCfg = Debug|x64
		{06AE1276-2589-D560-05A9-E030C71384E1}.Debug|x64.Build.0 = Debug|x64
		{06AE1276-2589-D560-05A9-E030C71384E1}.Debug|x64.Deploy.0 = Debug|x64
		{06AE1276-2589-D560-05A9-E030C71384E1}.Release|ARM64.ActiveCfg = Release|ARM64
		{06AE1276-2589-D560-05A9-E030C71384E1}.Release|ARM64.Build.0 = Release|ARM64
		{06AE1276-2589-D560-05A9-E030C71384E1}.Release|ARM64.Deploy.0 = Release|ARM64
		{06AE1276-2589-D560-05A9-E030C71384E1}.Release|x64.ActiveCfg = Release|x64
		{06AE1276-2589-D560-05A9-E030C71384E1}.Release|x64.Build.0 = Release|x64
		{06AE1276-2589-D560-05A9-E030C71384E1}.Release|x64.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {3986A1F7-00FF-4BD2-BCAE-FCEC9FD4439F}
	EndGlobalSection
EndGlobal

```

`PowerHook.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{06AE1276-2589-D560-05A9-E030C71384E1}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">x64</Platform>
    <RootNamespace>PowerHook</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="PowerHook.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="src\DriverEntry.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="src\Definitions.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`PowerHook.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="PowerHook.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="src\DriverEntry.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="src\Definitions.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`README.md`:

```md
Read the writeup [here](https://archie-osu.github.io/2025/04/13/powerhook.html).

```

`src/Definitions.hpp`:

```hpp
#pragma once
#include <ntifs.h>
using FN_IdlePreselect = NTSTATUS(*)(PVOID, PVOID);

struct _PPM_IDLE_STATES
{
	UCHAR Pad[0x268];
	FN_IdlePreselect IdlePreselect;
};

struct _PROCESSOR_POWER_STATE
{
	_PPM_IDLE_STATES* IdleStates;
};

struct _KPRCB
{
	UCHAR Pad[0x8840];
	_PROCESSOR_POWER_STATE PowerState;
};
```

`src/DriverEntry.cpp`:

```cpp
#include "Definitions.hpp"

static FN_IdlePreselect g_OriginalRoutine = nullptr;
static _KPRCB* g_ModifiedPrcb = nullptr;

void SetPowerInterceptRoutine(
	IN _KPRCB* Prcb,
	IN FN_IdlePreselect PowerInterceptRoutine,
	OPTIONAL OUT FN_IdlePreselect* OriginalRoutine
)
{
	// If the caller wants to know the original routine, save it first.
	// Hooks may want to call the original routine inside their handler.
	// 
	// If the currently running code were to be switched from the
	// processor whose Prcb is being modified, and the processor
	// became idle, not setting this first could potentially crash the OS.

	if (OriginalRoutine)
		*OriginalRoutine = Prcb->PowerState.IdleStates->IdlePreselect;

	Prcb->PowerState.IdleStates->IdlePreselect = PowerInterceptRoutine;
}

NTSTATUS HookRoutine(
	IN PVOID Rcx,
	IN PVOID Rdx
)
{
	//DbgPrintEx(
	//	0, 0, 
	//	"[HookRoutine] TID: %lu, PID: %lu, IRQL: %lu\n", 
	//	HandleToULong(PsGetCurrentThreadId()),
	//	HandleToULong(PsGetCurrentProcessId()),
	//	KeGetCurrentIrql()
	//);

	auto current_thread_id = PsGetCurrentThreadId();
	auto current_process_id = PsGetCurrentProcessId();

	// Try to get the thread
	{
		PETHREAD thread_object = nullptr;
		auto last_status = PsLookupThreadByThreadId(
			current_thread_id,
			&thread_object
		);

		DbgPrintEx(
			0, 0, 
			"TID %p => thread object at %p, last_status = %06X\n",
			current_thread_id, 
			thread_object,
			last_status
		);

		if (thread_object)
			ObDereferenceObject(thread_object);
	}
	
	// Try to get the process
	{
		PEPROCESS process_object = nullptr;
		auto last_status = PsLookupProcessByProcessId(
			current_process_id,
			&process_object
		);

		DbgPrintEx(
			0, 0, 
			"PID %p => process object at %p, last_status = %06X\n",
			current_process_id, 
			process_object, 
			last_status
		);

	}

	return g_OriginalRoutine(Rcx, Rdx);
}

void DriverUnload(
	IN PDRIVER_OBJECT DriverObject
)
{
	UNREFERENCED_PARAMETER(DriverObject);

	// Revert our change to the PRCB.
	// We don't need to know the original value, as it will most likely just be our hook.
	SetPowerInterceptRoutine(g_ModifiedPrcb, g_OriginalRoutine, nullptr);
	return;
}

EXTERN_C NTSTATUS DriverEntry(
	_In_ PDRIVER_OBJECT DriverObject,
	_In_ PUNICODE_STRING RegistryPath
)
{
	UNREFERENCED_PARAMETER(RegistryPath);
	DriverObject->DriverUnload = DriverUnload;
	
	// Save the modified PRCB, as we could be re-scheduled to 
	// a different processor at any time. This routine
	// runs at PASSIVE_LEVEL, so context switches are entirely possible.
	g_ModifiedPrcb = KeGetPcr()->CurrentPrcb;
	
	SetPowerInterceptRoutine(
		g_ModifiedPrcb,
		HookRoutine,
		&g_OriginalRoutine
	);

	return STATUS_SUCCESS;
}
```