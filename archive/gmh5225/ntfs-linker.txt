Project Path: arc_gmh5225_ntfs-linker_qzhwdedh

Source Tree:

```txt
arc_gmh5225_ntfs-linker_qzhwdedh
├── GPLv3.txt
├── LICENSE-LGPLv3.txt
├── Makefile.am
├── README.md
├── bootstrap.sh
├── configure.ac
├── doc
│   └── NTFS-linker.md
├── include
│   ├── aggregate.h
│   ├── controller.h
│   ├── file.h
│   ├── log.h
│   ├── mft.h
│   ├── progress.h
│   ├── sqlite_util.h
│   ├── unicode.h
│   ├── usn.h
│   ├── util.h
│   ├── vss.h
│   └── walkers.h
├── m4
│   ├── ax_append_compile_flags.m4
│   ├── ax_append_flag.m4
│   ├── ax_append_link_flags.m4
│   ├── ax_boost_base.m4
│   ├── ax_boost_filesystem.m4
│   ├── ax_boost_program_options.m4
│   ├── ax_boost_system.m4
│   ├── ax_check_compile_flag.m4
│   ├── ax_check_library.m4
│   ├── ax_check_link_flag.m4
│   ├── ax_cxx_compile_stdcxx_11.m4
│   └── ax_require_defined.m4
├── src
│   ├── aggregate.cpp
│   ├── controller.cpp
│   ├── log.cpp
│   ├── mft.cpp
│   ├── ntfs_linker.cpp
│   ├── progress.cpp
│   ├── sqlite_util.cpp
│   ├── usn.cpp
│   ├── util.cpp
│   ├── vss.cpp
│   └── walkers.cpp
└── test
    ├── test.cpp
    ├── test_usn.cpp
    └── test_util.cpp

```

`GPLv3.txt`:

```txt
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<http://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<http://www.gnu.org/philosophy/why-not-lgpl.html>.

```

`LICENSE-LGPLv3.txt`:

```txt
                   GNU LESSER GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.


  This version of the GNU Lesser General Public License incorporates
the terms and conditions of version 3 of the GNU General Public
License, supplemented by the additional permissions listed below.

  0. Additional Definitions.

  As used herein, "this License" refers to version 3 of the GNU Lesser
General Public License, and the "GNU GPL" refers to version 3 of the GNU
General Public License.

  "The Library" refers to a covered work governed by this License,
other than an Application or a Combined Work as defined below.

  An "Application" is any work that makes use of an interface provided
by the Library, but which is not otherwise based on the Library.
Defining a subclass of a class defined by the Library is deemed a mode
of using an interface provided by the Library.

  A "Combined Work" is a work produced by combining or linking an
Application with the Library.  The particular version of the Library
with which the Combined Work was made is also called the "Linked
Version".

  The "Minimal Corresponding Source" for a Combined Work means the
Corresponding Source for the Combined Work, excluding any source code
for portions of the Combined Work that, considered in isolation, are
based on the Application, and not on the Linked Version.

  The "Corresponding Application Code" for a Combined Work means the
object code and/or source code for the Application, including any data
and utility programs needed for reproducing the Combined Work from the
Application, but excluding the System Libraries of the Combined Work.

  1. Exception to Section 3 of the GNU GPL.

  You may convey a covered work under sections 3 and 4 of this License
without being bound by section 3 of the GNU GPL.

  2. Conveying Modified Versions.

  If you modify a copy of the Library, and, in your modifications, a
facility refers to a function or data to be supplied by an Application
that uses the facility (other than as an argument passed when the
facility is invoked), then you may convey a copy of the modified
version:

   a) under this License, provided that you make a good faith effort to
   ensure that, in the event an Application does not supply the
   function or data, the facility still operates, and performs
   whatever part of its purpose remains meaningful, or

   b) under the GNU GPL, with none of the additional permissions of
   this License applicable to that copy.

  3. Object Code Incorporating Material from Library Header Files.

  The object code form of an Application may incorporate material from
a header file that is part of the Library.  You may convey such object
code under terms of your choice, provided that, if the incorporated
material is not limited to numerical parameters, data structure
layouts and accessors, or small macros, inline functions and templates
(ten or fewer lines in length), you do both of the following:

   a) Give prominent notice with each copy of the object code that the
   Library is used in it and that the Library and its use are
   covered by this License.

   b) Accompany the object code with a copy of the GNU GPL and this license
   document.

  4. Combined Works.

  You may convey a Combined Work under terms of your choice that,
taken together, effectively do not restrict modification of the
portions of the Library contained in the Combined Work and reverse
engineering for debugging such modifications, if you also do each of
the following:

   a) Give prominent notice with each copy of the Combined Work that
   the Library is used in it and that the Library and its use are
   covered by this License.

   b) Accompany the Combined Work with a copy of the GNU GPL and this license
   document.

   c) For a Combined Work that displays copyright notices during
   execution, include the copyright notice for the Library among
   these notices, as well as a reference directing the user to the
   copies of the GNU GPL and this license document.

   d) Do one of the following:

       0) Convey the Minimal Corresponding Source under the terms of this
       License, and the Corresponding Application Code in a form
       suitable for, and under terms that permit, the user to
       recombine or relink the Application with a modified version of
       the Linked Version to produce a modified Combined Work, in the
       manner specified by section 6 of the GNU GPL for conveying
       Corresponding Source.

       1) Use a suitable shared library mechanism for linking with the
       Library.  A suitable mechanism is one that (a) uses at run time
       a copy of the Library already present on the user's computer
       system, and (b) will operate properly with a modified version
       of the Library that is interface-compatible with the Linked
       Version.

   e) Provide Installation Information, but only if you would otherwise
   be required to provide such information under section 6 of the
   GNU GPL, and only to the extent that such information is
   necessary to install and execute a modified version of the
   Combined Work produced by recombining or relinking the
   Application with a modified version of the Linked Version. (If
   you use option 4d0, the Installation Information must accompany
   the Minimal Corresponding Source and Corresponding Application
   Code. If you use option 4d1, you must provide the Installation
   Information in the manner specified by section 6 of the GNU GPL
   for conveying Corresponding Source.)

  5. Combined Libraries.

  You may place library facilities that are a work based on the
Library side by side in a single library together with other library
facilities that are not Applications and are not covered by this
License, and convey such a combined library under terms of your
choice, if you do both of the following:

   a) Accompany the combined library with a copy of the same work based
   on the Library, uncombined with any other library facilities,
   conveyed under the terms of this License.

   b) Give prominent notice with the combined library that part of it
   is a work based on the Library, and explaining where to find the
   accompanying uncombined form of the same work.

  6. Revised Versions of the GNU Lesser General Public License.

  The Free Software Foundation may publish revised and/or new versions
of the GNU Lesser General Public License from time to time. Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.

  Each version is given a distinguishing version number. If the
Library as you received it specifies that a certain numbered version
of the GNU Lesser General Public License "or any later version"
applies to it, you have the option of following the terms and
conditions either of that published version or of any later version
published by the Free Software Foundation. If the Library as you
received it does not specify a version number of the GNU Lesser
General Public License, you may choose any version of the GNU Lesser
General Public License ever published by the Free Software Foundation.

  If the Library as you received it specifies that a proxy can decide
whether future versions of the GNU Lesser General Public License shall
apply, that proxy's public statement of acceptance of any version is
permanent authorization for you to choose that version for the
Library.

```

`Makefile.am`:

```am
ACLOCAL_AMFLAGS = -I m4

AM_CPPFLAGS = -I$(srcdir)/include $(NL_CPPFLAGS)
AM_CXXFLAGS = $(NL_CXXFLAGS)
AM_LDFLAGS = $(NL_LDFLAGS)

NL_LIB = src/libntfs_linker.la
NL_LIB_INT = src/libntfs_linkerint.la

lib_LTLIBRARIES = $(NL_LIB)

#if BUILD_DLL
#src_libntfs_linker_la_SOURCES = src/lib/version.rc
#else
src_libntfs_linker_la_SOURCES =
#endif
nodist_EXTRA_src_libntfs_linker_la_SOURCES = dummy.cpp # forces C++ linking

noinst_LTLIBRARIES = $(NL_LIB_INT)

src_libntfs_linkerint_la_SOURCES = \
	src/aggregate.cpp \
	src/controller.cpp \
	src/log.cpp \
	src/mft.cpp \
	src/progress.cpp \
	src/sqlite_util.cpp \
	src/usn.cpp \
	src/util.cpp \
	src/vss.cpp \
	src/walkers.cpp

src_libntfs_linker_la_LIBADD = $(NL_LIB_INT) $(NL_LIBS)
if BUILD_DLL
src_libntfs_linker_la_LDFLAGS = $(AM_LDFLAGS) $(NL_LIB_LDFLAGS) -avoid-version
else
src_libntfs_linker_la_LDFLAGS = $(AM_LDFLAGS) $(NL_LIB_LDFLAGS)
endif

src_ntfs_linker_SOURCES = src/ntfs_linker.cpp

src_ntfs_linker_LDADD = $(NL_LIB) $(NL_LIBS)

bin_PROGRAMS = src/ntfs_linker
 
check_PROGRAMS = test/test
TESTS = $(check_PROGRAMS)
 
test_test_SOURCES = \
	test/test.cpp \
	test/test_util.cpp \
	test/test_usn.cpp

test_test_CPPFLAGS = $(AM_CPPFLAGS) $(SCOPE_CPPFLAGS)
test_test_LDADD = $(NL_LIB_INT) $(NL_LIBS) 

```

`README.md`:

```md
# [NTFS-Linker](http://strozfriedberg.github.io/ntfs-linker)
Author: Zack Weger

Copyright (c) 2015, [Stroz Friedberg, LLC](http://www.strozfriedberg.com)

Status: Alpha

License: [LGPLv3](LICENSE-LGPLv3.txt)

## Description
NTFS Linker uses the `$MFT`, `$LogFile`, and `$UsnJrnl` to generate a "linked" 
history of file system activity on an NTFS volume. `$LogFile` and `$UsnJrnl` track
changes to files and folders over time. Linking the records in these logs with 
`$MFT` allows for the construction of a timeline of activity: 
creates, moves/renames, and deletes. NTFS Linker produces records that can 
easily be filtered to review different types of activity. In addition, 
NTFS-Linker is able to run across all Volume Shadow Copies (VSCs) on a volume, 
and produce output in a unified and deduplicated manner.


## Usage
```
ntfs-linker, Copyright (c) Stroz Friedberg, LLC
Version 0.1.1
Usage: ntfs_linker ntfs-dir output [options] 
Allowed options:
  --ntfs-dir arg        If no image specified, location of root directory 
                        containing input files. Otherwise, root directory in 
                        which to dump files extracted from image. See the docs 
                        for info about ntfs-dir structure.
  --output arg          directory in which to dump output files
  --image arg           Path to image file(s)
  --overwrite           overwrite files in the output directory. Default: 
                        append
  --extra               Outputs supplemental lower-level parsed data from 
                        $UsnJrnl and $LogFile
  --help                display help and exit
  --version             display version number and exit
  ```


## Output

NTFS-Linker produces three TSV reports: events.txt, log.txt, and usn.txt.

- log.txt: contains listing of log record headers. Does not contain the
redo/undo operation data, so this report is of limited use.

- usn.txt: contains a "raw" view of `$UsnJrnl` entries in more detail than 
what events.txt provides, including all of the Reason flags.

- events.txt: contains a unified view of all file system events, as parsed from
both $UsnJrnl and $LogFile, ordered by event time from most recent to oldest 
(approximately--see below).

NTFS-Linker _also_ produces a SQLite database containing all of the above data. 
The database schema is designed for ease of querying, not full normalization.

## Installation
The source is in C++ and uses autotools for building. C++11 compiler support is
required. On a sane Unix, this should work:
```
./bootstrap.sh
./configure
make
sudo make install
```

NTFS-linker has dependencies on 
[SQLite](http://www.sqlite.org), 
[Boost](http://www.boost.org), 
[libtsk](http://www.sleuthkit.org), 
[libewf](http://github.com/libyal/libewf), 
[libbfio](http://github.com/libyal/libbfio), 
[libcerror](http://github.com/libyal/libcerror), 
and [libvshadow](http://github.com/libyal/libvshadow). The `configure` script 
should detect these dependencies on your system and warn you if any are missing.

`libewf` should be installed before building and installing `libtsk`.

Note that libvshadow must be compiled with libbfio enabled, and The Sleuthkit
must be compiled with ` --disable-multithreading` (which is only available in
version 4.3).

After installing the dependencies you may need to run:
```
sudo ldconfig
```

With sufficient wizardry, NTFS-linker can be built for Windows using mingw. For 
the impatient, prebuilt binaries can be [downloaded](https://s3.amazonaws.com/downloads.lightboxtechnologies.com/ntfs-linker/ntfs-linker-338dcc1-windows-64-static.zip).
```

`bootstrap.sh`:

```sh
#!/bin/sh

autoreconf -fi

```

`configure.ac`:

```ac
AC_PREREQ([2.69])
m4_define([ntfs_linker_version], [0.1.1])
AC_INIT([ntfs-linker], [ntfs_linker_version], [zweger@strozfriedberg.com])
 
AC_CONFIG_AUX_DIR([config])
AC_CONFIG_MACRO_DIR([m4])
AC_CONFIG_SRCDIR([src/ntfs_linker.cpp])
AC_CONFIG_HEADERS([config.h])
 
AM_INIT_AUTOMAKE([1.12 subdir-objects foreign])
LT_INIT
 
AC_PROG_CXX
AM_PROG_CC_C_O
 
AC_LANG([C++])
AX_CXX_COMPILE_STDCXX_11([noext], [mandatory])

AX_APPEND_COMPILE_FLAGS([-W -Wall -Wextra -Wnon-virtual-dtor -pedantic -pipe -O3 -g], [NL_CXXFLAGS])
AX_APPEND_LINK_FLAGS([-g -pthread], [NL_LDFLAGS])

AX_APPEND_COMPILE_FLAGS([-pthread -D__VERSION="'\"ntfs_linker_version\"'"], [NL_CPPFLAGS])

# pkg-config doesn't look in /usr/local/lib on some systems
export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig

PKG_CHECK_MODULES([BFIO], [libbfio], [AC_DEFINE([HAVE_LIBBFIO], [1], [Lets libewf, libvshadow know we have libbfio.])])
PKG_CHECK_MODULES([EWF], [libewf])
PKG_CHECK_MODULES([SQLITE], [sqlite3])
PKG_CHECK_MODULES([VSHADOW], [libvshadow])
PKG_CHECK_MODULES([CERROR], [libcerror])

# zlib is a dependency of libtsk
PKG_CHECK_MODULES([ZLIB], [zlib])

AX_CHECK_LIBRARY([TSK], [tsk/libtsk.h], [tsk],
                 [TSK_LIBS=-ltsk],
                 [AC_MSG_ERROR([Failed to find libtsk])])
AC_SUBST([TSK_LIBS])

# Check that libvshadow has bfio
AC_EGREP_CPP(yes,
             [#include <libvshadow.h>
              #ifndef LIBVSHADOW_HAVE_BFIO
              yes
              #endif
              ], AC_MSG_ERROR([libvshadow does not have libbfio.]))

# Check that libtsk doesn't have multithread
AC_EGREP_CPP(yes,
             [#include <tsk/libtsk.h>
              #ifdef TSK_MULTITHREAD_LIB
              yes 
              #endif
              ], AC_MSG_ERROR([libtsk has multithreading but should not.]))

#
# Boost
#
if test "x$with_boost" = "xno"; then
  AC_MSG_ERROR([--without-boost specified, but Boost is mandatory.])
else
  case "$host" in
  *-*-mingw*)
    # AX_BOOST_BASE doesn't find the Boost libs for mingw, we help it out
    if test "$with_boost_libdir" = ""; then
      with_boost_libdir="/usr/${host}/sys-root/mingw/lib"
      AC_MSG_WARN([--with-boost-libdir not set. We are guessing ${with_boost_libdir}.])
    fi
    ;;
  esac

  AX_BOOST_BASE([1.49.0],
    [],
    [AC_MSG_ERROR([Failed to find usable Boost headers.])])
fi

AX_BOOST_PROGRAM_OPTIONS
if test "x$ax_cv_boost_program_options" != "xyes"; then
  AC_MSG_ERROR([Failed to find Boost program_options library.])
fi

AX_BOOST_SYSTEM
if test "x$ax_cv_boost_system" != "xyes"; then
  AC_MSG_ERROR([Failed to find Boost system library.])
fi

AX_BOOST_FILESYSTEM
if test "x$ax_cv_boost_filesystem" != "xyes"; then
  AC_MSG_ERROR([Failed to find Boost filesystem library.])
fi


###############################################################################
# Scope test framework
AC_ARG_WITH([scope],
  [AS_HELP_STRING([--with-scope=ARG],
    [use Scope headers from the specified location])],
  [SCOPE_PATH="$withval"],
  [SCOPE_PATH="vendors/scope"])

if test "x$with_scope" != "xno"; then
  # test Scope without adding its path to CPPFLAGS generally
  SCOPE_CPPFLAGS="-isystem `realpath $SCOPE_PATH`"
  CPPFLAGS_saved="$CPPFLAGS"
  CPPFLAGS="$SCOPE_CPPFLAGS"
  export CPPFLAGS

  AC_CHECK_HEADERS([scope/test.h],[scope_ok="yes"])

  CPPFLAGS="$CPPFLAGS_saved"

  if test "x$scope_ok" = "xyes"; then
    AC_DEFINE(HAVE_SCOPE,1,[Define to 1 if Scope test framework is available.])
    AC_SUBST([SCOPE_CPPFLAGS])
  fi
fi

# Tell the user why not if he won't be able to compile the tests
if test "x$scope_ok" != "xyes"; then
  AC_MSG_WARN([])
  AC_MSG_WARN([You will be unable to compile and run the tests because:])
  AC_MSG_WARN([])
  if test "x$scope_ok" != "xyes"; then
    AC_MSG_WARN([  * Scope test framework is unavailable])
  fi
  AC_MSG_WARN([])
fi
###############################################################################


# Ensure that we statically link everything which is not a system lib;
# -all-static includes libstdc++ and libgcc, which are excluded by
# -static.
if test "x$enable_shared" != "xyes"; then
  CXXLD="$CXX -all-static"

  case "$host" in
  i686-*-mingw*)
    # FIXME: Really? This looks like it's just asking for trouble...
    AX_APPEND_LINK_FLAGS([-Wl,--allow-multiple-definition], [NL_LIB_LDFLAGS])
    ;;
  esac
else
  CXXLD="$CXX"

  case "$host" in
  *-*-mingw*)
    # -no-undefined is a libtool flag; adding it with AX_APPEND_LINK_FLAGS
    # will fail because that tries flags with LD. So don't do that.
    AX_APPEND_FLAG([-no-undefined], [NL_LIB_LDFLAGS])
    NL_LIB_LDFLAGS="$NL_LIB_LDFLAGS -Wl,--output-def -Wl,src/.libs/$PACKAGE.def"
#    LT_LANG([Windows Resource])
    ;;
  esac  
fi

AM_CONDITIONAL([BUILD_DLL], [test "x$enable_shared" = "xyes" && echo "$host" | grep -q mingw])

AC_SUBST([CXXLD])

AC_DEFUN([SF_APPEND], [{
  if test -n "[$]$1"; then
    if test -n "$2"; then
      AS_VAR_APPEND($1, " $2")
    fi
  else
    $1=[$]$2
  fi
}])

# collect the flags from everything which might set some
for lib in EWF VSHADOW SQLITE BFIO TSK BOOST ZLIB CERROR; do
  # fold CFLAGS into CXXFLAGS since everything here is C++
  h="${lib}_CXXFLAGS"
  t=$(eval echo \"\$${lib}_CFLAGS\")
  SF_APPEND($h, $t)

  for var in CPPFLAGS CXXFLAGS LDFLAGS LIBS; do
    h="NL_$var"
    t=$(eval echo \"\$${lib}_$var\")
    SF_APPEND($h, $t)
  done
done

# yay, inconsistent variable naming
NL_LIBS="$NL_LIBS $BOOST_PROGRAM_OPTIONS_LIB $BOOST_FILESYSTEM_LIB $BOOST_SYSTEM_LIB"

AC_SUBST([NL_CPPFLAGS])
AC_SUBST([NL_CXXFLAGS])
AC_SUBST([NL_LDFLAGS])
AC_SUBST([NL_LIBS])
AC_SUBST([NL_LIB_LDFLAGS])

AC_CONFIG_FILES([Makefile])
AC_OUTPUT

```

`doc/NTFS-linker.md`:

```md
# NTFS-Linker
Author: Zack Weger

Copyright (c) 2015, [Stroz Friedberg, LLC](http://www.strozfriedberg.com)

Status: Alpha

## Basic usage:

    C:\> ntfs-linker.exe --ntfs-dir .\journals\ --output .\parsed-output\

    C:\> ntfs-linker.exe --image MyEvidence.E01 --ntfs-dir .\journals\ --output .\parsed-output\

## Input

`ntfs-linker` operates off of a directory of input containing $UsnJrnl, 
$Logfile, and $MFT. The $UsnJrnl should be the $J alternate data stream and it 
can be clipped to avoid copying the sparse portions.

`ntfs-linker` can *also* work off of a nested directory structure like the one
below. It can process multiple volumes, and each volume can have multiple
volume shadow copy directories. If a volume has no volume shadow copies, the
intermediate `vss_base` folder can be omitted.

    INPUT
    └── volume_0
        ├── vss_0
        │   ├── $J
        │   ├── $LogFile
        │   └── $MFT
        ├── vss_1
        │   ├── $J
        │   ├── $LogFile
        │   └── $MFT
        ├── vss_2
        │   ├── $J
        │   ├── $LogFile
        │   └── $MFT
        └── vss_base
            ├── $J
            ├── $LogFile
            └── $MFT

When presented with a disk image as input, `ntfs-linker` will automatically run 
against all NTFS volumes and retrieve the respective occurrences of $UsnJrnl,
$Logfile, and $MFT. If a volume contains Volume Shadow Copies, the NTFS files
will be retrieved from each VSC and then the entire collection will be parsed.
The files will be copied out into a directory structure like the one above.

## Output

The output will look like this:

    OUTPUT
    ├── ntfs.db
    └── volume_0
        ├── events.txt
        ├── vss_0
        │   ├── logfile.txt
        │   └── usnjrnl.txt
        ├── vss_1
        │   ├── logfile.txt
        │   └── usnjrnl.txt
        ├── vss_2
        │   ├── logfile.txt
        │   └── usnjrnl.txt
        └── vss_base
            ├── logfile.txt
            └── usnjrnl.txt

`ntfs.db` is a SQLite database which contains data from all volume shadow copies
on all volumes. `events.txt` is a tab-separated report on all of the events from
a particular volume. If `--extra` is specified, then `logfile.txt` and `usnjrnl.txt`
will contain detailed information about the $LogFile and $UsnJrnl for a particular
snapshot.


## Database schema

The SQLite database created by `ntfs-linker` will have the following structure:

```
CREATE TABLE event (
    Position            int, 
    Timestamp           text, 
    EventSource         text, 
    EventType           text, 
    FileName            text, 
    Folder              text, 
    Full_Path           text, 
    MFT_Record          int, 
    Parent_MFT_Record   int, 
    USN_LSN             int, 
    Old_File_Name       text, 
    Old_Folder          text, 
    Old_Parent_ Record  int, 
    Offset              int, 
    Created             text, 
    Modified            text, 
    Comment             text, 
    Snapshot            text, 
    Volume              text
)

CREATE TABLE log (
    CurrentLSN      int, 
    PrevLSN         int, 
    UndoLSN         int, 
    ClientID        int, 
    RecordType      int, 
    RedoOP          text, 
    UndoOP          text, 
    TargetAttribute int, 
    MFTClusterIndex int, 
    Offset          int, 
    Snapshot        text, 
    Volume          text
)

CREATE TABLE usn (
    MFTRecNo        int, 
    ParRecNo        int, 
    USN             int, 
    Timestamp       text, 
    Reason          text, 
    FileName        text, 
    PossiblePath    text, 
    PossibleParPath text, 
    Offset          int, 
    Snapshot        text, 
    Volume          text
)
```

### Useful queries

The following are useful queries.

### Get all events
    SELECT *
    FROM EVENT

#### CCleaner

    SELECT *
    FROM EVENT
    WHERE filename REGEXP "^[\.zZ]+$"

#### Daily histogram

    SELECT substr(event.Timestamp, 0, 11) AS day, count(*) AS count
    FROM event
    GROUP BY day


## Understanding the output

All timestamps are in [ISO 8601 format](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations), 
i.e., YYYY-mm-dd HH:MM:SS.1234567.
Windows stores timestamps as the number of hundred nanoseconds since 1601 
(FILETIME). The routines used by NTFS-Linker to parse the time use standard 
C++ libraries, which may result in incorrect timestamps in some cases.
Specifically, if the time is _before_ 1970 or _after_ 2038, the timestamp will 
not be displayed properly.

### usn.txt
The [USN Journal reason code](https://msdn.microsoft.com/en-us/library/aa365722%28VS.85%29.aspx)
 uses a bit packing scheme for each possible 
reason. From the time a file is opened to the time it is closed, the reasons 
will be combined. This means that multiple reasons may show up for a particular 
entry, even though only one operation happens at a time. The order the reasons 
are printed is completely arbitrary and has no correlation to the order in which 
they occurred.

#### USN Journal Example:
- USN|FILE_CREATE
- USN|CLOSE|FILE_CREATE
- USN|DATA_EXTEND
- USN|DATA_EXTEND|DATA_OVERWRITE
- USN|BASIC_INFO_CHANGE|DATA_EXTEND|DATA_OVERWRITE
- USN|BASIC_INFO_CHANGE|CLOSE|DATA_EXTEND|DATA_OVERWRITE

### log.txt
$LogFile event analysis is much more complicated.  Each record contains a redo 
and undo op code, as well as redo and undo data. In the case of data write 
events, it is possible to recover the data written for resident files, or the 
file sectors on disc for non-resident files. At this time NTFS-Linker does not 
recover the data written.

### events.txt

#### Event Source
This can be `$UsnJrnl/$J`, `$LogFile`, or "`$UsnJrnl` entry in `$LogFile`". 
`$LogFile` actually contains complete `$UsnJrnl` entries.

#### File names and paths
While a file name can be extracted directly from a Log/Usn entry, the paths must
be calculated. The "folder" path is the calculated path to the parent directory,
and the "Path" column is the calculated path to the MFT record number if 
available.

```gotta come back to this and edit for clarity... maybe an example?```
NTFS-Linker tracks each record's parent over time. For events where a recordnum 
and a parent recordnum can be recovered, it's possible that, in ntfs-linker's
current conception of the file system, these records are unrelated! In this case
the "Folder" and "Full Path" columns of the event will be mismatched. Generally,
the "Folder" will represent the path to the parent folder where the event 
occurred, and "Full Path" will represent the path to the file which NTFS-Linker 
previously thought was at that record. 

#### Event Ordering
While the exact order of `$LogFile` and `$UsnJrnl` events is known, 
respectively, the combined ordering is not. They must be ordered according to 
the event timestamps. While the  timestamps for all `$UsnJrnl` events are known,
the timestamps for `$LogFile` rename, move, and delete events is not known.
Note that, due to file system tunneling, the event time for a `$LogFile` creation
event is not the `$STANDARD_INFORMATION` attribute creation time. It is the SIA
*modified* time.

NTFS-Linker performs a "zipper-merge" of these two event sequences, which preserves
the relative position of events from the same sequence. This is accomplished by
maintaining a cursor at each sequence, and choosing the next event to be the one
with the larger timestamp, when both sequences are non-increasing. Since timestamps
for `$LogFile` rename, delete, and move events are not known, they are always placed
directly after the preceding `$LogFile` creation event.

This can leave some uncertainty surrounding the exact time of an event,
but in practice there are almost always surrounding events which limit the uncertainty.
For example, the `$LogFile` events in the below snippet will almost certainly 
have occurred between 2012-04-07 21:40:26.5203196 and 2012-04-07 21:39:07.3474312.
Since identical events were found in `$UsnJrnl/$J`, we suspect these 3 files
were deleted at 2012-04-07 21:40:26.5203196.



| Timestamp                   | Source      | Event  | File         |
| --------------------------- | ----------- | ------ | ------------ |
| 2012-04-07 21:40:26.5359448 |	$LogFile    | Create | gpt00000.dom |
| 2012-04-07 21:40:26.5359448 |	$UsnJrnl/$J	| Create | gpt00000.dom |
| 2012-04-07 21:40:26.5203196 |	$LogFile    | Create | tmpgptfl.inf |
|                             | $LogFile    | Delete | tmpgptfl.inf |
|                             | $LogFile    | Delete | gpt00000.dom |
|                             | $LogFile"	| Delete | 5.tmp        |
| 2012-04-07 21:40:26.5203196 |	$UsnJrnl/$J	| Create | tmpgptfl.inf |
| 2012-04-07 21:40:26.5203196 |	$UsnJrnl/$J	| Delete | tmpgptfl.inf |
| 2012-04-07 21:40:26.5203196 |	$UsnJrnl/$J | Delete | gpt00000.dom |
| 2012-04-07 21:39:07.3474312 | $LogFile    | Create | 5.ini        |



#### Offset
The actual file offset (in decimal) to the beginning of the event record in the 
source file.

#### Created, Modified, Comment
For `$LogFile` create events, the timestamps from the Standard Information 
attribute (regardless of the faith NTFS-Linker places in them) and whether those 
timestamps match the corresponding timestamps in the File Name Attribute. If 
not, the "Comment" field will say ``. This allows for easy detection of 
timestomping.

#### `$UsnJrnl` event collapsing
`$UsnJrnl` records are combined in events.txt to display one event for each 
logical event that actually occurred. For instance, for a rename event, 
`$UsnJrnl` will contain at least two records: one containing the old name and 
one containing the new name (and probably a couple other records, for the same 
event). In contrast, `events.txt` displays this event just once. For 
the `$UsnJrnl` events embedded in `$LogFile`, this same deduplication is performed,
but only amongst other `$UsnJrnl` events embedded in `$LogFile`. Since these
embedded events are found less often, for rename and move events, it is generally
not possible to retrieve both the file name before and the file name after.

## Implementation Details

This section contains notes on the inner-workings of NTFS-Linker. Specifically,
we outline the process by which NTFS-Linker recovers events from `$LogFile`, 
`$UsnJrnl:$J`, and `$MFT`. While the structures of these files are fairly well
known, their inter-related meaning requires explanation.

### Background: Sequencing

In this document, by `sequence`, we mean some ordered collection of objects,
which could possibly repeat. Given a sequence, we can obtain a `subsequence`
by *removing* zero or more elements. For example, the following is a sequence:

    25 67 38 97 58 94 29 66 23 92 60 8 47 50 98 28 13 91 61 72

And the following are all subsequences of the above sequence:

|     | Subsequence                                                | Note                    |
| --- | ---------------------------------------------------------- | ----------------------- |
| S1  | 25 67 38 97 58 94 29 66 23 92 60 8 47 50 98 28 13 91 61 72 | zero elements removed   |
| S2  | 25 38 58 29 23 60 47 98 13 61                              | (some elements removed) |
| S3  | 25 38 47 50 72                                             | (some elements removed) |


### Changes in State
Put simply, a filesystem event implies a change in state of the filesystem. When
reporting on an event, it's often desirable to display that in the context of
the state of the filesystem. This should be done in the context of the
filesystem *at the time the event occurred*. For instance, suppose we know the
state of a filesystem at some point in time (say, from a base image) to be:

| Recordnum | Full Path      |
| --------- | -------------- |
| 10        | /foo/bar       |
| 11        | /foo/bar/a.txt |
| 12        | /foo/bar/b.txt |

Suppose that immediately prior to the filesystem being imaged, we know that
an entry with recordnum 13, parent recordnum 10 named `some_name` was deleted. 
Now suppose that just before *that*, we know an entry with recordnum 14, parent
recordnum 13, named `file.txt` was deleted. What was the full path of this
record *at the time it was deleted*? We know that it must have been
`/foo/bar/some_name/file.txt`! Thus we observe it's necessary to accumulate
changes in state of the filesystem as events are processed, in order to recover
the context of each event.


### Event Ordering
At some point we arrive at this situation: we have a sequence of events from
`$UsnJrnl` and a sequence of events from `$LogFile`. For the `$UsnJrnl` events
we know the event timestamps, but for the `$LogFile` events we have less
information. For `$LogFile` rename, move, and delete events, we are not able to
recover an event timestamp. Only for `$LogFile` create events are we able to
recover an event timestamp.

The impact is this: we know the order of events in `$UsnJrnl` and `$LogFile`
separately, and we have some idea of the times these events occurred, but we
don't know exactly how the two sequences fit together. In order to create a 
unified timeline of events, we do a standard zipper merge of the two sequences, 
but only considering the `$Logfile` create event timestamps. Events of other 
types found in `$LogFile` will always be output directly after the preceding
`$LogFile` create event.


### Volume Shadows and Processing Order
A Volume Shadow Copy represents a snapshot of a filesystem at a particular time.
Often, multiple shadow copies may be present which are close together in time
(for example, shadow copies created as a result of running system updates). In
this situation, `$UsnJrnl` and `$LogFile` may actually overlap some between the
snapshots. To deduplicate this, we defer to the older snapshot. We grab all
events from the oldest snapshot, then only the events not present in the oldest
snapshot from the next oldest, etc., until we've processed the base snapshot.

To output events, however, we need to process the Shadow Copies in the reverse
order, with the most recent events first, because the most recent events imply
a change in state of the file system. Thus we process all the events from the
base image (not including events which are found in the most recent shadow
copy!), and then the most recent shadow copy, etc. In the end we get a timeline
from the present extending into the past of unified events which are mostly in
the same order as the events occurred. _[ed: *mostly???*]_

### Extracting events from `$UsnJrnl`
When a file is created, renamed, moved, or deleted, `$UsnJrnl` will contain
multiple records for the same logical event. The records contain information
such as data being written to the file, security changes, etc. For rename and
move events the old name/parent recordnum and new name/parent recordnum will be
in separate `$UsnJrnl` records. NTFS-Linker will compress all of these records
into one logical event, depending on the event flags. This compression ends when
either the `$UsnJrnl` Record recordnum changes or a CLOSE flag is signalled.
If the flags for a group of records indicate the file was neither created,
deleted, moved, or renamed, then the records are discarded.

### Extracting events from `$LogFile`
`$LogFile` records exist at a lower-level than `$UsnJrnl`, so extracting logical
events is more complicated. A `$LogFile` record consists of a RedoOp and an
UndoOp code each possibly associated with some data.

We break apart the $LogFile records into logical
transactions ending with a record with `RedoOp=FORGET_TRANSACTION` and
`UndoOp=COMPENSATION_LOG_RECORD`. From here, we consider the sequence of OpCodes
and check if it has a subsequence which represents a particular event type. We
list the subsequences associated with each event type below:


| Event Type  | Order | RedoOp Subsequence Entry          | UndoOp Subsequence Entry          |
| ----------- | ----- | --------------------------------- | --------------------------------- |
| Create      | 1     | SET_BITS_IN_NONRESIDENT_BIT_MAP   | CLEAR_BITS_IN_NONRESIDENT_BIT_MAP |
| Create      | 2     | NOOP                              | DEALLOCATE_FILE_RECORD_SEGMENT    |
| Create      | 3     | ADD_INDEX_ENTRY\*                 | DELETE_INDEX_ENTRY\*              |
| Create      | 4     | INITIALIZE_FILE_RECORD_SEGMENT    | NOOP                              |
| Create      | 5     | FORGET TRANSACTION                | COMPENSATION_LOG_RECORD           |
| ----------- | ----- | --------------------------------- | --------------------------------- |
| Delete      | 1     | DELETE_INDEX_ENTRY\*              | ADD_INDEX_ENTRY\*                 |
| Delete      | 2     | DEALLOCATE_FILE_RECORD_SEGMENT    | INITIALIZE_FILE_RECORD_SEGMENT    |
| Delete      | 3     | CLEAR_BITS_IN_NONRESIDENT_BIT_MAP | SET_BITS_IN_NONRESIDENT_BIT_MAP   |
| Delete      | 4     | FORGET_TRANSACTION                | COMPENSATION_LOG_RECORD           |
| ----------- | ----- | --------------------------------- | --------------------------------- |
| Rename/Move | 1     | DELETE_INDEX_ENTRY\*              | ADD_INDEX_ENTRY\*                 |
| Rename/Move | 2     | DELETE_ATTRIBUTE                  | CREATE_ATTRIBUTE                  |
| Rename/Move | 3     | CREATE_ATTRIBUTE                  | DELETR_ATTRIBUTE                  |
| Rename/Move | 4     | ADD_INDEX_ENTRY\*                 | DELETE_INDEX_ENTRY\*              |
| Rename/Move | 5     | FORGET_TRANSACTION                | COMPENSATION_LOG_RECORD           |


For some of the above (RedoOp, UndoOp) pairs there is data associated with the operation
which we add to the candidate event, which we list below:


| RedoOp                          | UndoOp                            | Data Found                                              |
| ------------------------------- | --------------------------------- | ------------------------------------------------------- |
| SET_BITS_IN_NONRESIDENT_BIT_MAP | CLEAR_BITS_IN_NONRESIDENT_BIT_MAP | Recordnum                                               |
| INITIALIZE_FILE_RECORD_SEGMENT  | NOOP                              | Complete MFT entry                                      |
| DELETE_ATTRIBUTE                | CREATE_ATTRIBUTE                  | Previous file name                                      |
| CREATE_ATTRIBUTE                | DELETE_ATTRIBUTE                  | New file name                                           |
| DELETE_INDEX_ENTRY\*            | ADD_INDEX_ENTRY\*                 | File name, parent recordnum                             |
| ADD_INDEX_ENTRY\*               | DELETE_INDEX_ENTRY\*              | Recordnum, Parent recordnum, Timestamp, (new) file name |
| UPDATE_NONRESIDENT_VALUE        | NOOP                              | Embedded `$UsnJrnl` entry                               |


\***Note**: Throughout these tables, we consider ADD_INDEX_ENTRY_ALLOCATION to
be equivalent to ADD_INDEX_ENTRY_ROOT, and denote as ADD_INDEX ENTRY, and
DELETE_INDEX_ENTRY_ALLOCATION equivalent to DELETE_INDEX_ENTRY_ROOT, and 
denote as DELETE_INDEX_ENTRY.

So, the parsing strategy is to collect the above data as each record is
processed, all the while checking if the transaction has ended. If it has, 
then we mark a new event if it matches the above event type sequences. 
Regardless, the transaction data is cleared.

## Further reading

There are a number of good resources online about NTFS, $MFT, $UsnJrnl, 
$Logfile, and Volume Shadow Copies. Among them:
 - [David Cowen](http://www.hecfblog.com/) has blogged in-depth about his 
 research into NTFS linking and offers a [tool](http://www.gettriforce.com) 
 that has features beyond the scope of NTFS-linker.
   - [NTFS Triforce - A deeper look inside the artifacts](http://hackingexposedcomputerforensicsblog.blogspot.com/2013/01/ntfs-triforce-deeper-look-inside.html)
   
   - [CEIC 2013 and the public beta of the NTFS Triforce](http://hackingexposedcomputerforensicsblog.blogspot.com/2013/05/ceic-2013-and-public-beta-of-ntfs.html)
 - The [Linux-NTFS documentation](http://0cch.net/ntfsdoc/) 
 - [MSDN on the $UsnJrnl](http://www.microsoft.com/msj/0999/journal/journal.aspx)
 - Mike Wilkinson's [NTFS Cheat Sheet](http://www.writeblocked.org/resources/ntfs_cheat_sheets.pdf) 
 is a succinct reference to various NTFS structures.
 - [NTFS Log Tracker](http://forensicinsight.org/wp-content/uploads/2013/06/F-INSIGHT-NTFS-Log-TrackerEnglish.pdf)
 for details on $LogFile transactions

```

`include/aggregate.h`:

```h
/*
 * ntfs-linker
 * Copyright 2015 Stroz Friedberg, LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the license, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * A copy of the GNU Lesser General Public License is available at
 * <http://www.gnu.org/licenses/>.
 *
 * You can contact Stroz Friedberg by electronic and paper mail as follows:
 *
 * Stroz Friedberg, LLC
 * 32 Avenue of the Americas
 * 4th Floor
 * New York, NY, 10013
 * info@strozfriedberg.com
 */

#pragma once

#include "controller.h"
#include "file.h"
#include "util.h"
#include "sqlite_util.h"

#include <fstream>
#include <list>
#include <sqlite3.h>
#include <vector>
#include <string>

class Event {
public:
  Event();
  void init(sqlite3_stmt* stmt);
  void write(std::ostream& out, const std::vector<File>& records);
  void updateRecords(std::vector<File>& records);
  void insert(sqlite3_stmt* stmt, std::vector<File>& records);
  static std::string getColumnHeaders();

  int64_t Record, Parent, PreviousParent, UsnLsn, Type, Source, Offset, Id, Order;
  std::string Timestamp, Name, PreviousName, Created, Modified, Comment, Snapshot, Volume;
  bool IsAnchor, IsEmbedded;
};

void outputEvents(std::vector<File>& records, SQLiteHelper& sqliteHelper, VolumeIO& volumeIO, const VersionInfo& version);

```

`include/controller.h`:

```h
/*
 * ntfs-linker
 * Copyright 2015 Stroz Friedberg, LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the license, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * A copy of the GNU Lesser General Public License is available at
 * <http://www.gnu.org/licenses/>.
 *
 * You can contact Stroz Friedberg by electronic and paper mail as follows:
 *
 * Stroz Friedberg, LLC
 * 32 Avenue of the Americas
 * 4th Floor
 * New York, NY, 10013
 * info@strozfriedberg.com
 */

#pragma once
#include "sqlite_util.h"

#include <boost/filesystem.hpp>

#include <string>
#include <vector>
#include <fstream>
#include <memory>

namespace fs = boost::filesystem;

struct Options {
  Options() : overwrite(false), extra(false) {}
  fs::path input;
  fs::path output;
  bool overwrite;
  bool extra;
  std::vector<std::string> imgSegs;
};

struct VolumeIO;

struct SnapshotIO {
  SnapshotIO(Options& opts, VolumeIO* parent);

  VolumeIO* Parent;
  std::ifstream IMft, IUsnJrnl, ILogFile;
  std::ofstream OUsnJrnl, OLogFile;
  std::string Name;
  bool Good;
};
typedef std::shared_ptr<SnapshotIO> SnapshotIOPtr;

struct ImageIO;

struct VolumeIO {
  VolumeIO(Options& opts, ImageIO* parent);

  ImageIO* Parent;
  std::vector<SnapshotIOPtr> Snapshots;
  std::ofstream Events;
  unsigned int Count;
  std::string Name;
  bool Good;
};
typedef std::shared_ptr<VolumeIO> VolumeIOPtr;

struct ImageIO {
  ImageIO(Options& opts);
  std::vector<VolumeIOPtr> Volumes;
  SQLiteHelper SqliteHelper;
  bool Good;

  std::string getSummary();
};

void run(Options& opts);

```

`include/file.h`:

```h
/*
 * ntfs-linker
 * Copyright 2015 Stroz Friedberg, LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the license, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * A copy of the GNU Lesser General Public License is available at
 * <http://www.gnu.org/licenses/>.
 *
 * You can contact Stroz Friedberg by electronic and paper mail as follows:
 *
 * Stroz Friedberg, LLC
 * 32 Avenue of the Americas
 * 4th Floor
 * New York, NY, 10013
 * info@strozfriedberg.com
 */

#pragma once

#include <string>

/*
Represents a file. A map of record numbers to these file objects can be used to reconstruct the full path
*/
class File {
  public:
    File () :
      Name(""),
      Record(0),
      Parent(0),
      Timestamp(""),
      Valid(false) {}
    File(std::string name, unsigned int record, unsigned int parent, std::string timestamp) :
      Name(name),
      Record(record),
      Parent(parent),
      Timestamp(timestamp),
      Valid(true) {}
    std::string Name;
    unsigned int Record, Parent;
    std::string Timestamp;
    bool Valid;
};

```

`include/log.h`:

```h
/*
 * ntfs-linker
 * Copyright 2015 Stroz Friedberg, LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the license, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * A copy of the GNU Lesser General Public License is available at
 * <http://www.gnu.org/licenses/>.
 *
 * You can contact Stroz Friedberg by electronic and paper mail as follows:
 *
 * Stroz Friedberg, LLC
 * 32 Avenue of the Americas
 * 4th Floor
 * New York, NY, 10013
 * info@strozfriedberg.com
 */

#pragma once

#include "file.h"
#include "mft.h"
#include "sqlite_util.h"
#include "usn.h"

#include <iostream>
#include <string>
#include <vector>

/*
returns the meaning of the operation code
*/
std::string decodeLogFileOpCode(int op);

/*
Parses the $LogFile stream input
Writes output to designated streams
*/
void parseLog(const std::vector<File>& records, SQLiteHelper& sqliteHelper, std::istream& input, std::ostream& output, const VersionInfo& version, bool extra);

class LogRecord {
public:
  LogRecord(const VersionInfo& version) : Snapshot(version.Snapshot), Volume(version.Volume) {}

  int init(char* buffer, uint64_t offset, bool prev_has_next);
  void clearFields();
  void insert(sqlite3_stmt* stmt);
  static std::string getColumnHeaders();

  uint64_t CurrentLsn, PreviousLsn, UndoLsn, Offset;
  unsigned int ClientId, RecordType, Flags, RedoOp, UndoOp, RedoOffset, RedoLength, UndoOffset, UndoLength;
  unsigned int TargetAttribute, LcnsToFollow, RecordOffset, AttributeOffset, MftClusterIndex, TargetVcn, TargetLcn;
  unsigned int ClientDataLength;
  char* Data;
  std::string Snapshot, Volume;
};
std::ostream& operator<<(std::ostream& out, const LogRecord& rec);

class LogData {
public:
  LogData(const VersionInfo& version) : Snapshot(version.Snapshot), Volume(version.Volume), PrevUsnRecord(version, true) {}

  void clearFields();
  void processLogRecord(const std::vector<File>& records, LogRecord& rec, SQLiteHelper& sqliteHelper, uint64_t fileOffset);
  std::string toCreateString(std::vector<File>& records);
  std::string toDeleteString(std::vector<File>& records);
  std::string toRenameString(std::vector<File>& records);
  std::string toMoveString(std::vector<File>& records);
  void insertEvent(unsigned int type, sqlite3_stmt* stmt);
  bool isCreateEvent();
  bool isDeleteEvent();
  bool isRenameEvent();
  bool isMoveEvent();
  bool isTransactionOver();

  int64_t Record, Offset;
  uint64_t Lsn;
  std::string Timestamp, Created, Modified, Comment, Snapshot, Volume;
  FNAttribute Fna, PreviousFna;
  std::vector<int> RedoOps, UndoOps;

  static const std::vector<int> createRedo, createUndo, deleteRedo, deleteUndo;
  static const std::vector<int> renameRedo, renameUndo, writeRedo, writeUndo;
  UsnRecord PrevUsnRecord;
private:
  /*
  Used for $LogFile event analysis
  returns whether the transaction run represented by redo1, undo1 "matches" redo2, undo2
  Here matching means that redo2 is a subsequence of redo1, and undo2 is a subsequence of undo1
  if interchange is set, then it is considered that 0xc == 0xe and 0xd == 0xf
  */
  bool transactionRunMatch(const std::vector<int>& redo2, const std::vector<int>& undo2, bool interchange = true);
};

namespace LogOps {
    const int NOOP                              = 0x00;
    const int COMPENSATION_LOG_RECORD           = 0x01;
    const int INITIALIZE_FILE_RECORD_SEGMENT    = 0x02;
    const int DEALLOCATE_FILE_RECORD_SEGMENT    = 0x03;
    const int WRITE_END_OF_FILE_RECORD_SEGMENT  = 0x04;
    const int CREATE_ATTRIBUTE                  = 0x05;
    const int DELETE_ATTRIBUTE                  = 0x06;
    const int UPDATE_RESIDENT_VALUE             = 0x07;
    const int UPDATE_NONRESIDENT_VALUE          = 0x08;
    const int UPDATE_MAPPING_PAIRS              = 0x09;
    const int DELETE_DIRTY_CLUSTERS             = 0x0A;
    const int SET_NEW_ATTRIBUTE_SIZES           = 0x0B;
    const int ADD_INDEX_ENTRY_ROOT              = 0x0C;
    const int DELETE_INDEX_ENTRY_ROOT           = 0x0D;
    const int ADD_INDEX_ENTRY_ALLOCATION        = 0x0E;
    const int DELETE_INDEX_ENTRY_ALLOCATION     = 0x0F;
    const int SET_INDEX_ENTRY_VCN_ALLOCATION    = 0x12;
    const int UPDATE_FILE_NAME_ROOT             = 0x13;
    const int UPDATE_FILE_NAME_ALLOCATION       = 0x14;
    const int SET_BITS_IN_NONRESIDENT_BIT_MAP   = 0x15;
    const int CLEAR_BITS_IN_NONRESIDENT_BIT_MAP = 0x16;
    const int PREPARE_TRANSACTION               = 0x19;
    const int COMMIT_TRANSACTION                = 0x1A;
    const int FORGET_TRANSACTION                = 0x1B;
    const int OPEN_NONRESIDENT_ATTRIBUTE        = 0x1C;
    const int DIRTY_PAGE_TABLE_DUMP             = 0x1F;
    const int TRANSACTION_TABLE_DUMP            = 0x20;
    const int UPDATE_RECORD_DATA_ROOT           = 0x21;
}

```

`include/mft.h`:

```h
/*
 * ntfs-linker
 * Copyright 2015 Stroz Friedberg, LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the license, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * A copy of the GNU Lesser General Public License is available at
 * <http://www.gnu.org/licenses/>.
 *
 * You can contact Stroz Friedberg by electronic and paper mail as follows:
 *
 * Stroz Friedberg, LLC
 * 32 Avenue of the Americas
 * 4th Floor
 * New York, NY, 10013
 * info@strozfriedberg.com
 */

#pragma once

#include "file.h"
#include "sqlite_util.h"

#include <iostream>
#include <string>

/*
Returns the column headers used in the MFT csv file
*/
std::string getMFTColumnHeaders();

/*
Parses all the MFT records
*/
void parseMFT(std::vector<File>& records, std::istream& input);

class SIAttribute {
public:
  SIAttribute() : Created(0), Modified(0), MFTModified(0), Accessed(0),
                  Usn(0), Valid(false) {}
  SIAttribute(char* buffer);

  uint64_t Created, Modified, MFTModified, Accessed;
  uint64_t Usn;
private:
  bool Valid;
};

class FNAttribute {
public:
  FNAttribute() : Parent(0), Created(0), Modified(0), MFTModified(0), Accessed(0),
                  LogicalSize(0), PhysicalSize(0), Name(""), Valid(false), NameType(0) {}
  FNAttribute(char* buffer);
  unsigned int Parent;
  uint64_t Created, Modified, MFTModified, Accessed;
  uint64_t LogicalSize, PhysicalSize;
  std::string Name;
  bool Valid;
  int NameType;

  bool operator<(const FNAttribute& other) const;
};

class MFTRecord {
public:
  MFTRecord(char* buffer, unsigned int len=1024);
  std::string toString(std::vector<File>& records);
  void insert(sqlite3_stmt* stmt, std::vector<File>& records);
  File asFile();

  unsigned int Record;
  SIAttribute Sia;

  // There may be multiple, but we'll pick just one.
  FNAttribute Fna;

private:
  uint64_t Lsn;
  bool isDir, isAllocated;
};

```

`include/progress.h`:

```h
/*
 * ntfs-linker
 * Copyright 2015 Stroz Friedberg, LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the license, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * A copy of the GNU Lesser General Public License is available at
 * <http://www.gnu.org/licenses/>.
 *
 * You can contact Stroz Friedberg by electronic and paper mail as follows:
 *
 * Stroz Friedberg, LLC
 * 32 Avenue of the Americas
 * 4th Floor
 * New York, NY, 10013
 * info@strozfriedberg.com
 */

#pragma once

#include <cstdint>

class ProgressBar {
private:
  uint64_t done;
  uint64_t toDo;
  int last;
public:
  void addToDo(uint64_t x);
  void addDone(uint64_t x);
  void setDone(uint64_t x);
  void printProgress();
  ProgressBar(uint64_t x);
  void finish();
  void clear();
};



```

`include/sqlite_util.h`:

```h
/*
 * ntfs-linker
 * Copyright 2015 Stroz Friedberg, LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the license, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * A copy of the GNU Lesser General Public License is available at
 * <http://www.gnu.org/licenses/>.
 *
 * You can contact Stroz Friedberg by electronic and paper mail as follows:
 *
 * Stroz Friedberg, LLC
 * 32 Avenue of the Americas
 * 4th Floor
 * New York, NY, 10013
 * info@strozfriedberg.com
 */

#pragma once

#include <sqlite3.h>
#include <string>
#include <vector>

struct VersionInfo {
  VersionInfo(std::string snapshot, std::string volume) : Snapshot(snapshot), Volume(volume){}
  std::string Snapshot, Volume;
};

class SQLiteHelper {
public:
  SQLiteHelper() : UsnInsert(NULL), LogInsert(NULL),
                   EventInsert(NULL), EventUsnSelect(NULL), EventLogSelect(NULL),
                   Db(NULL) {}
  void init(std::string dbName, bool overwrite);
  void beginTransaction();
  void endTransaction();
  void close();
  void bindForSelect(const VersionInfo& version);
  void resetSelect();

  sqlite3_stmt *UsnInsert, *LogInsert, *EventInsert, *EventUsnSelect, *EventLogSelect, *EventFinalInsert;
private:
  void finalizeStatements();
  int prepareStatement(sqlite3_stmt **stmt, std::string& sql);
  void prepareStatements();
  std::string toColumnList(std::vector<std::vector<std::string>>& cols);

  static const std::vector<std::vector<std::string>> EventColumns, LogColumns, UsnColumns, EventTempColumns;

  sqlite3* Db;
};

```

`include/unicode.h`:

```h
/*
 * ntfs-linker
 * Copyright 2015 Stroz Friedberg, LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the license, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * A copy of the GNU Lesser General Public License is available at
 * <http://www.gnu.org/licenses/>.
 *
 * You can contact Stroz Friedberg by electronic and paper mail as follows:
 *
 * Stroz Friedberg, LLC
 * 32 Avenue of the Americas
 * 4th Floor
 * New York, NY, 10013
 * info@strozfriedberg.com
 */

#pragma once

typedef unsigned char byte;

template <bool LE, typename B>
size_t utf16_to_cp(const B buf, const B end, int32_t& cp) {
  if (end - buf < 2) {
    // invalid, too few bytes
    return 0;
  }

  cp = buf[LE ? 0 : 1] | (buf[LE ? 1 : 0] << 8);

  if (cp < 0xD800) {
    // direct representation
    return 2;
  }
  else if (cp < 0xDC00) {
    // found lead of UTF-16 surrogate pair
    const uint16_t lead = cp;

    if (end - buf < 4) {
      // invalid, too few bytes
      return 0;
    }

    const uint16_t trail = buf[LE ? 2 : 3] | (buf[LE ? 3 : 2] << 8);
    if (trail < 0xDC00) {
      // invalid
      return 0;
    }
    else if (trail < 0xE000) {
      // found trail of UTF-16 surrogate pair
      cp = ((lead - (0xD800 - (0x10000 >> 10))) << 10) | (trail - 0xDC00);
      return 4;
    }
    else {
      // invalid
      return 0;
    }
  }
  else if (cp < 0xE000) {
    // invalid
    return 0;
  }
  else {
    // direct representation
    return 2;
  }
}

template <typename B>
size_t cp_to_utf8(int32_t cp, B& buf) {
  if (cp < 0) {
    // too small
    return 0;
  }
  else if (cp < 0x80) {
    // one byte
    buf[0] = (byte) cp;
    return 1;
  }
  else if (cp < 0x800) {
    // two bytes
    buf[0] = 0xC0 | ((cp >> 6) & 0x1F);
    buf[1] = 0x80 | ( cp       & 0x3F);
    return 2;
  }
  else if (cp < 0xD800) {
    // three bytes
    buf[0] = 0xE0 | ((cp >> 12) & 0x0F);
    buf[1] = 0x80 | ((cp >>  6) & 0x3F);
    buf[2] = 0x80 | ( cp        & 0x3F);
    return 3;
  }
  else if (cp < 0xE000) {
    // UTF-16 surrogates, invalid
    return 0;
  }
  else if (cp < 0x10000) {
    // three bytes
    buf[0] = 0xE0 | ((cp >> 12) & 0x0F);
    buf[1] = 0x80 | ((cp >>  6) & 0x3F);
    buf[2] = 0x80 | ( cp        & 0x3F);
    return 3;
  }
  else if (cp < 0x110000) {
    // four bytes
    buf[0] = 0xF0 | ((cp >> 18) & 0x07);
    buf[1] = 0x80 | ((cp >> 12) & 0x3F);
    buf[2] = 0x80 | ((cp >>  6) & 0x3F);
    buf[3] = 0x80 | ( cp        & 0x3F);
    return 4;
  }
  else {
    // too large
    return 0;
  }
}

```

`include/usn.h`:

```h
/*
 * ntfs-linker
 * Copyright 2015 Stroz Friedberg, LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the license, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * A copy of the GNU Lesser General Public License is available at
 * <http://www.gnu.org/licenses/>.
 *
 * You can contact Stroz Friedberg by electronic and paper mail as follows:
 *
 * Stroz Friedberg, LLC
 * 32 Avenue of the Americas
 * 4th Floor
 * New York, NY, 10013
 * info@strozfriedberg.com
 */

#pragma once

#include "file.h"
#include "sqlite_util.h"

#include <iostream>
#include <string>

const unsigned int USN_BUFFER_SIZE = 65536;

std::string getUSNColumnHeaders();

std::streampos advanceStream(std::istream& stream, char* buffer, bool sparse=false);

void parseUSN(const std::vector<File>& records, SQLiteHelper& sqliteHelper, std::istream& input, std::ostream& output, const VersionInfo& version, bool extra);

int recoverPosition(const char* buffer, unsigned int offset, unsigned int usn_offset);

class UsnRecord {
public:
  UsnRecord(const VersionInfo& version, bool isEmbedded=false);
  UsnRecord(const char* buffer, uint64_t fileOffset, const VersionInfo& version, int len = -1, bool isEmbedded=false);

  std::string getReasonString();
  std::string toCreateString(const  std::vector<File> &records);
  std::string toDeleteString(const  std::vector<File> &records);
  std::string toMoveString(const    std::vector<File> &records);
  std::string toRenameString(const  std::vector<File> &records);
  std::string toString(const        std::vector<File> &records);

  void checkTypeAndInsert(sqlite3_stmt* stmt, bool strict=true);
  void update(UsnRecord rec);
  void clearFields();

  void insert(sqlite3_stmt* stmt, const std::vector<File>& records);
  void insertEvent(unsigned int type, sqlite3_stmt* stmt);

  uint64_t Reference, ParentReference, Usn, FileOffset;
  int64_t Record, Parent, PreviousParent;
  unsigned int Reason;
  std::string Name, PreviousName, Timestamp, Snapshot, Volume;
  bool IsEmbedded;
};

namespace UsnReasons {
  const unsigned int USN_BASIC_INFO_CHANGE         = 0x00008000;
  const unsigned int USN_CLOSE                     = 0x80000000;
  const unsigned int USN_COMPRESSION_CHANGE        = 0x00020000;
  const unsigned int USN_DATA_EXTEND               = 0x00000002;
  const unsigned int USN_DATA_OVERWRITE            = 0x00000001;
  const unsigned int USN_DATA_TRUNCATION           = 0x00000004;
  const unsigned int USN_EXTENDED_ATTRIBUTE_CHANGE = 0x00000400;
  const unsigned int USN_ENCRYPTION_CHANGE         = 0x00040000;
  const unsigned int USN_FILE_CREATE               = 0x00000100;
  const unsigned int USN_FILE_DELETE               = 0x00000200;
  const unsigned int USN_HARD_LINK_CHANGE          = 0x00010000;
  const unsigned int USN_INDEXABLE_CHANGE          = 0x00004000;
  const unsigned int USN_NAMED_DATA_EXTEND         = 0x00000020;
  const unsigned int USN_NAMED_DATA_OVERWRITE      = 0x00000010;
  const unsigned int USN_NAMED_DATA_TRUNCATION     = 0x00000040;
  const unsigned int USN_OBJECT_ID_CHANGE          = 0x00080000;
  const unsigned int USN_RENAME_NEW_NAME           = 0x00002000;
  const unsigned int USN_RENAME_OLD_NAME           = 0x00001000;
  const unsigned int USN_REPARSE_POINT_CHANGE      = 0x00100000;
  const unsigned int USN_SECURITY_CHANGE           = 0x00000800;
  const unsigned int USN_STREAM_CHANGE             = 0x00200000;
}

```

`include/util.h`:

```h
/*
 * ntfs-linker
 * Copyright 2015 Stroz Friedberg, LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the license, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * A copy of the GNU Lesser General Public License is available at
 * <http://www.gnu.org/licenses/>.
 *
 * You can contact Stroz Friedberg by electronic and paper mail as follows:
 *
 * Stroz Friedberg, LLC
 * 32 Avenue of the Americas
 * 4th Floor
 * New York, NY, 10013
 * info@strozfriedberg.com
 */

#pragma once

#include "file.h"
#include "sqlite_util.h"

#include <fstream>
#include <iostream>
#include <string>
#include <vector>
#include <tsk/libtsk.h>

static const std::string VERSION = __VERSION;

uint64_t hex_to_long(const char* arr, int size);

int64_t filetime_to_unixtime(int64_t t);

std::string filetime_to_iso_8601(uint64_t t);

std::string mbcatos(const char* arr, uint64_t len);

std::string getFullPath(const std::vector<File>& records, unsigned int recordNo);

void prep_ofstream(std::ofstream& out, const std::string& name, bool overwrite);

enum EventSources: unsigned int {
  SOURCE_USN = 0,
  SOURCE_LOG = 1,
  SOURCE_EMBEDDED_USN = 2,
};

enum EventTypes: unsigned int {
  TYPE_CREATE = 0,
  TYPE_DELETE = 1,
  TYPE_RENAME = 2,
  TYPE_MOVE = 3,
};

std::string toString(EventSources e);

std::string toString(EventTypes e);

std::ostream& operator<<(std::ostream& out, EventTypes e);

std::ostream& operator<<(std::ostream& out, EventSources e);

std::string pluralize(std::string name, int n);

int doFixup(char* buffer, unsigned int len, unsigned int sectorSize=512);

int ceilingDivide(int n, int m);

```

`include/vss.h`:

```h
/*
 * ntfs-linker
 * Copyright 2015 Stroz Friedberg, LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the license, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * A copy of the GNU Lesser General Public License is available at
 * <http://www.gnu.org/licenses/>.
 *
 * You can contact Stroz Friedberg by electronic and paper mail as follows:
 *
 * Stroz Friedberg, LLC
 * 32 Avenue of the Americas
 * 4th Floor
 * New York, NY, 10013
 * info@strozfriedberg.com
 */

#pragma once

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <tsk/libtsk.h>
#include <libbfio.h>
#include <libvshadow.h>

#include <memory>

static const uint64_t TVB_SHIM_TAG = 0x96c5565f;
class TskVolumeBfioShim {
  public:
    TskVolumeBfioShim(const TSK_FS_INFO* fs);

    int free(libbfio_error_t **error);
    int clone(intptr_t **destination_io_handle, libbfio_error_t **error);
    int open(int access_flags, libbfio_error_t **error);
    int close(libbfio_error_t **error);
    ssize_t read(uint8_t *buffer, size_t size, libbfio_error_t **error);
    ssize_t write(const uint8_t *buffer, size_t size, libbfio_error_t **error);
    off64_t seek_offset(off64_t offset, int whence, libbfio_error_t **error);
    int exists(libbfio_error_t **error);
    int is_open(libbfio_error_t **error);
    int get_size(size64_t *size, libbfio_error_t **error);

    const uint32_t Tag;
  private:
    const TSK_FS_INFO* Fs;
    off64_t Offset;
    size64_t Size;
};
typedef std::unique_ptr<TskVolumeBfioShim> TskVolumeBfioShimPtr;

typedef std::unique_ptr<TSK_IMG_INFO> TskImgInfoPtr;

class VShadowTskVolumeShim {
  public:
    VShadowTskVolumeShim(libvshadow_store_t* store) : Store(store) {}
    void close() {}
    void imgstat(FILE* file) { (void) file; }
    ssize_t read(TSK_OFF_T off, char* buf, size_t len);
    TSK_FS_INFO* getTskFsInfo(TSK_IMG_INFO* img);
  private:
    libvshadow_store_t* Store;
};
typedef std::unique_ptr<VShadowTskVolumeShim> VShadowTskVolumeShimPtr;

static const uint32_t IMG_VSS_INFO_TAG = 0xd70a6a3b;
struct IMG_VSS_INFO {
  IMG_VSS_INFO() : Tag(IMG_VSS_INFO_TAG) {}
  TSK_IMG_INFO img_info;
  VShadowTskVolumeShimPtr VstvShim;
  const uint32_t Tag;
};
typedef std::unique_ptr<IMG_VSS_INFO> ImgVssInfoPtr;

class VSS {
  public:
    VSS(TSK_FS_INFO* fs);
    ~VSS();
    TSK_FS_INFO* getSnapshot(uint8_t n);
    int getNumStores();
  private:
    void freeSnapshot();

    TskVolumeBfioShimPtr TvbShim;
    libbfio_handle_t* Handle;
    libvshadow_volume_t* Volume;
    int NumStores;
    libvshadow_store_t* Store;
    ImgVssInfoPtr VssInfo;
    TSK_FS_INFO* VssFs;

};

```

`include/walkers.h`:

```h
/*
 * ntfs-linker
 * Copyright 2015 Stroz Friedberg, LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the license, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * A copy of the GNU Lesser General Public License is available at
 * <http://www.gnu.org/licenses/>.
 *
 * You can contact Stroz Friedberg by electronic and paper mail as follows:
 *
 * Stroz Friedberg, LLC
 * 32 Avenue of the Americas
 * 4th Floor
 * New York, NY, 10013
 * info@strozfriedberg.com
 */

#pragma once

#include <tsk/libtsk.h>

#include <boost/filesystem.hpp>
#include <map>
#include <string>

namespace fs = boost::filesystem;

class VolumeWalker: public TskAuto {
  public:
    VolumeWalker(fs::path root) : DidItWork(false), Root(root) {}
    virtual TSK_FILTER_ENUM filterFs(TSK_FS_INFO* fs);
    virtual TSK_RETVAL_ENUM processFile(TSK_FS_FILE*, const char*) { return TSK_OK; }
    virtual uint8_t openImageUtf8(int, const char *const images[], TSK_IMG_TYPE_ENUM, unsigned int a_ssize);
    bool DidItWork;
    std::string getSummary();
  private:
    fs::path Root;
    std::map<int, int> NumCopied;
};

```

`m4/ax_append_compile_flags.m4`:

```m4
# ===========================================================================
#  http://www.gnu.org/software/autoconf-archive/ax_append_compile_flags.html
# ===========================================================================
#
# SYNOPSIS
#
#   AX_APPEND_COMPILE_FLAGS([FLAG1 FLAG2 ...], [FLAGS-VARIABLE], [EXTRA-FLAGS])
#
# DESCRIPTION
#
#   For every FLAG1, FLAG2 it is checked whether the compiler works with the
#   flag.  If it does, the flag is added FLAGS-VARIABLE
#
#   If FLAGS-VARIABLE is not specified, the current language's flags (e.g.
#   CFLAGS) is used.  During the check the flag is always added to the
#   current language's flags.
#
#   If EXTRA-FLAGS is defined, it is added to the current language's default
#   flags (e.g. CFLAGS) when the check is done.  The check is thus made with
#   the flags: "CFLAGS EXTRA-FLAGS FLAG".  This can for example be used to
#   force the compiler to issue an error when a bad flag is given.
#
#   NOTE: This macro depends on the AX_APPEND_FLAG and
#   AX_CHECK_COMPILE_FLAG. Please keep this macro in sync with
#   AX_APPEND_LINK_FLAGS.
#
# LICENSE
#
#   Copyright (c) 2011 Maarten Bosmans <mkbosmans@gmail.com>
#
#   This program is free software: you can redistribute it and/or modify it
#   under the terms of the GNU General Public License as published by the
#   Free Software Foundation, either version 3 of the License, or (at your
#   option) any later version.
#
#   This program is distributed in the hope that it will be useful, but
#   WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
#   Public License for more details.
#
#   You should have received a copy of the GNU General Public License along
#   with this program. If not, see <http://www.gnu.org/licenses/>.
#
#   As a special exception, the respective Autoconf Macro's copyright owner
#   gives unlimited permission to copy, distribute and modify the configure
#   scripts that are the output of Autoconf when processing the Macro. You
#   need not follow the terms of the GNU General Public License when using
#   or distributing such scripts, even though portions of the text of the
#   Macro appear in them. The GNU General Public License (GPL) does govern
#   all other use of the material that constitutes the Autoconf Macro.
#
#   This special exception to the GPL applies to versions of the Autoconf
#   Macro released by the Autoconf Archive. When you make and distribute a
#   modified version of the Autoconf Macro, you may extend this special
#   exception to the GPL to apply to your modified version as well.

#serial 4

AC_DEFUN([AX_APPEND_COMPILE_FLAGS],
[AX_REQUIRE_DEFINED([AX_CHECK_COMPILE_FLAG])
AX_REQUIRE_DEFINED([AX_APPEND_FLAG])
for flag in $1; do
  AX_CHECK_COMPILE_FLAG([$flag], [AX_APPEND_FLAG([$flag], [$2])], [], [$3])
done
])dnl AX_APPEND_COMPILE_FLAGS

```

`m4/ax_append_flag.m4`:

```m4
# ===========================================================================
#      http://www.gnu.org/software/autoconf-archive/ax_append_flag.html
# ===========================================================================
#
# SYNOPSIS
#
#   AX_APPEND_FLAG(FLAG, [FLAGS-VARIABLE])
#
# DESCRIPTION
#
#   FLAG is appended to the FLAGS-VARIABLE shell variable, with a space
#   added in between.
#
#   If FLAGS-VARIABLE is not specified, the current language's flags (e.g.
#   CFLAGS) is used.  FLAGS-VARIABLE is not changed if it already contains
#   FLAG.  If FLAGS-VARIABLE is unset in the shell, it is set to exactly
#   FLAG.
#
#   NOTE: Implementation based on AX_CFLAGS_GCC_OPTION.
#
# LICENSE
#
#   Copyright (c) 2008 Guido U. Draheim <guidod@gmx.de>
#   Copyright (c) 2011 Maarten Bosmans <mkbosmans@gmail.com>
#
#   This program is free software: you can redistribute it and/or modify it
#   under the terms of the GNU General Public License as published by the
#   Free Software Foundation, either version 3 of the License, or (at your
#   option) any later version.
#
#   This program is distributed in the hope that it will be useful, but
#   WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
#   Public License for more details.
#
#   You should have received a copy of the GNU General Public License along
#   with this program. If not, see <http://www.gnu.org/licenses/>.
#
#   As a special exception, the respective Autoconf Macro's copyright owner
#   gives unlimited permission to copy, distribute and modify the configure
#   scripts that are the output of Autoconf when processing the Macro. You
#   need not follow the terms of the GNU General Public License when using
#   or distributing such scripts, even though portions of the text of the
#   Macro appear in them. The GNU General Public License (GPL) does govern
#   all other use of the material that constitutes the Autoconf Macro.
#
#   This special exception to the GPL applies to versions of the Autoconf
#   Macro released by the Autoconf Archive. When you make and distribute a
#   modified version of the Autoconf Macro, you may extend this special
#   exception to the GPL to apply to your modified version as well.

#serial 6

AC_DEFUN([AX_APPEND_FLAG],
[dnl
AC_PREREQ(2.64)dnl for _AC_LANG_PREFIX and AS_VAR_SET_IF
AS_VAR_PUSHDEF([FLAGS], [m4_default($2,_AC_LANG_PREFIX[FLAGS])])
AS_VAR_SET_IF(FLAGS,[
  AS_CASE([" AS_VAR_GET(FLAGS) "],
    [*" $1 "*], [AC_RUN_LOG([: FLAGS already contains $1])],
    [
     AS_VAR_APPEND(FLAGS,[" $1"])
     AC_RUN_LOG([: FLAGS="$FLAGS"])
    ])
  ],
  [
  AS_VAR_SET(FLAGS,[$1])
  AC_RUN_LOG([: FLAGS="$FLAGS"])
  ])
AS_VAR_POPDEF([FLAGS])dnl
])dnl AX_APPEND_FLAG

```

`m4/ax_append_link_flags.m4`:

```m4
# ===========================================================================
#   http://www.gnu.org/software/autoconf-archive/ax_append_link_flags.html
# ===========================================================================
#
# SYNOPSIS
#
#   AX_APPEND_LINK_FLAGS([FLAG1 FLAG2 ...], [FLAGS-VARIABLE], [EXTRA-FLAGS])
#
# DESCRIPTION
#
#   For every FLAG1, FLAG2 it is checked whether the linker works with the
#   flag.  If it does, the flag is added FLAGS-VARIABLE
#
#   If FLAGS-VARIABLE is not specified, the linker's flags (LDFLAGS) is
#   used. During the check the flag is always added to the linker's flags.
#
#   If EXTRA-FLAGS is defined, it is added to the linker's default flags
#   when the check is done.  The check is thus made with the flags: "LDFLAGS
#   EXTRA-FLAGS FLAG".  This can for example be used to force the linker to
#   issue an error when a bad flag is given.
#
#   NOTE: This macro depends on the AX_APPEND_FLAG and AX_CHECK_LINK_FLAG.
#   Please keep this macro in sync with AX_APPEND_COMPILE_FLAGS.
#
# LICENSE
#
#   Copyright (c) 2011 Maarten Bosmans <mkbosmans@gmail.com>
#
#   This program is free software: you can redistribute it and/or modify it
#   under the terms of the GNU General Public License as published by the
#   Free Software Foundation, either version 3 of the License, or (at your
#   option) any later version.
#
#   This program is distributed in the hope that it will be useful, but
#   WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
#   Public License for more details.
#
#   You should have received a copy of the GNU General Public License along
#   with this program. If not, see <http://www.gnu.org/licenses/>.
#
#   As a special exception, the respective Autoconf Macro's copyright owner
#   gives unlimited permission to copy, distribute and modify the configure
#   scripts that are the output of Autoconf when processing the Macro. You
#   need not follow the terms of the GNU General Public License when using
#   or distributing such scripts, even though portions of the text of the
#   Macro appear in them. The GNU General Public License (GPL) does govern
#   all other use of the material that constitutes the Autoconf Macro.
#
#   This special exception to the GPL applies to versions of the Autoconf
#   Macro released by the Autoconf Archive. When you make and distribute a
#   modified version of the Autoconf Macro, you may extend this special
#   exception to the GPL to apply to your modified version as well.

#serial 4

AC_DEFUN([AX_APPEND_LINK_FLAGS],
[AX_REQUIRE_DEFINED([AX_CHECK_LINK_FLAG])
AX_REQUIRE_DEFINED([AX_APPEND_FLAG])
for flag in $1; do
  AX_CHECK_LINK_FLAG([$flag], [AX_APPEND_FLAG([$flag], [m4_default([$2], [LDFLAGS])])], [], [$3])
done
])dnl AX_APPEND_LINK_FLAGS

```

`m4/ax_boost_base.m4`:

```m4
# ===========================================================================
#       http://www.gnu.org/software/autoconf-archive/ax_boost_base.html
# ===========================================================================
#
# SYNOPSIS
#
#   AX_BOOST_BASE([MINIMUM-VERSION], [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])
#
# DESCRIPTION
#
#   Test for the Boost C++ libraries of a particular version (or newer)
#
#   If no path to the installed boost library is given the macro searchs
#   under /usr, /usr/local, /opt and /opt/local and evaluates the
#   $BOOST_ROOT environment variable. Further documentation is available at
#   <http://randspringer.de/boost/index.html>.
#
#   This macro calls:
#
#     AC_SUBST(BOOST_CPPFLAGS) / AC_SUBST(BOOST_LDFLAGS)
#
#   And sets:
#
#     HAVE_BOOST
#
# LICENSE
#
#   Copyright (c) 2008 Thomas Porschberg <thomas@randspringer.de>
#   Copyright (c) 2009 Peter Adolphs
#
#   Copying and distribution of this file, with or without modification, are
#   permitted in any medium without royalty provided the copyright notice
#   and this notice are preserved. This file is offered as-is, without any
#   warranty.

#serial 26

AC_DEFUN([AX_BOOST_BASE],
[
AC_ARG_WITH([boost],
  [AS_HELP_STRING([--with-boost@<:@=ARG@:>@],
    [use Boost library from a standard location (ARG=yes),
     from the specified location (ARG=<path>),
     or disable it (ARG=no)
     @<:@ARG=yes@:>@ ])],
    [
    if test "$withval" = "no"; then
        want_boost="no"
    elif test "$withval" = "yes"; then
        want_boost="yes"
        ac_boost_path=""
    else
        want_boost="yes"
        ac_boost_path="$withval"
    fi
    ],
    [want_boost="yes"])


AC_ARG_WITH([boost-libdir],
        AS_HELP_STRING([--with-boost-libdir=LIB_DIR],
        [Force given directory for boost libraries. Note that this will override library path detection, so use this parameter only if default library detection fails and you know exactly where your boost libraries are located.]),
        [
        if test -d "$withval"
        then
                ac_boost_lib_path="$withval"
        else
                AC_MSG_ERROR(--with-boost-libdir expected directory name)
        fi
        ],
        [ac_boost_lib_path=""]
)

if test "x$want_boost" = "xyes"; then
    boost_lib_version_req=ifelse([$1], ,1.20.0,$1)
    boost_lib_version_req_shorten=`expr $boost_lib_version_req : '\([[0-9]]*\.[[0-9]]*\)'`
    boost_lib_version_req_major=`expr $boost_lib_version_req : '\([[0-9]]*\)'`
    boost_lib_version_req_minor=`expr $boost_lib_version_req : '[[0-9]]*\.\([[0-9]]*\)'`
    boost_lib_version_req_sub_minor=`expr $boost_lib_version_req : '[[0-9]]*\.[[0-9]]*\.\([[0-9]]*\)'`
    if test "x$boost_lib_version_req_sub_minor" = "x" ; then
        boost_lib_version_req_sub_minor="0"
        fi
    WANT_BOOST_VERSION=`expr $boost_lib_version_req_major \* 100000 \+  $boost_lib_version_req_minor \* 100 \+ $boost_lib_version_req_sub_minor`
    AC_MSG_CHECKING(for boostlib >= $boost_lib_version_req)
    succeeded=no

    dnl On 64-bit systems check for system libraries in both lib64 and lib.
    dnl The former is specified by FHS, but e.g. Debian does not adhere to
    dnl this (as it rises problems for generic multi-arch support).
    dnl The last entry in the list is chosen by default when no libraries
    dnl are found, e.g. when only header-only libraries are installed!
    libsubdirs="lib"
    ax_arch=`uname -m`
    case $ax_arch in
      x86_64)
        libsubdirs="lib64 libx32 lib lib64"
        ;;
      ppc64|s390x|sparc64|aarch64|ppc64le)
        libsubdirs="lib64 lib lib64 ppc64le"
        ;;
    esac

    dnl allow for real multi-arch paths e.g. /usr/lib/x86_64-linux-gnu. Give
    dnl them priority over the other paths since, if libs are found there, they
    dnl are almost assuredly the ones desired.
    AC_REQUIRE([AC_CANONICAL_HOST])
    libsubdirs="lib/${host_cpu}-${host_os} $libsubdirs"

    case ${host_cpu} in
      i?86)
        libsubdirs="lib/i386-${host_os} $libsubdirs"
        ;;
    esac

    dnl first we check the system location for boost libraries
    dnl this location ist chosen if boost libraries are installed with the --layout=system option
    dnl or if you install boost with RPM
    if test "$ac_boost_path" != ""; then
        BOOST_CPPFLAGS="-I$ac_boost_path/include"
        for ac_boost_path_tmp in $libsubdirs; do
                if test -d "$ac_boost_path"/"$ac_boost_path_tmp" ; then
                        BOOST_LDFLAGS="-L$ac_boost_path/$ac_boost_path_tmp"
                        break
                fi
        done
    elif test "$cross_compiling" != yes; then
        for ac_boost_path_tmp in /usr /usr/local /opt /opt/local ; do
            if test -d "$ac_boost_path_tmp/include/boost" && test -r "$ac_boost_path_tmp/include/boost"; then
                for libsubdir in $libsubdirs ; do
                    if ls "$ac_boost_path_tmp/$libsubdir/libboost_"* >/dev/null 2>&1 ; then break; fi
                done
                BOOST_LDFLAGS="-L$ac_boost_path_tmp/$libsubdir"
                BOOST_CPPFLAGS="-I$ac_boost_path_tmp/include"
                break;
            fi
        done
    fi

    dnl overwrite ld flags if we have required special directory with
    dnl --with-boost-libdir parameter
    if test "$ac_boost_lib_path" != ""; then
       BOOST_LDFLAGS="-L$ac_boost_lib_path"
    fi

    CPPFLAGS_SAVED="$CPPFLAGS"
    CPPFLAGS="$CPPFLAGS $BOOST_CPPFLAGS"
    export CPPFLAGS

    LDFLAGS_SAVED="$LDFLAGS"
    LDFLAGS="$LDFLAGS $BOOST_LDFLAGS"
    export LDFLAGS

    AC_REQUIRE([AC_PROG_CXX])
    AC_LANG_PUSH(C++)
        AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
    @%:@include <boost/version.hpp>
    ]], [[
    #if BOOST_VERSION >= $WANT_BOOST_VERSION
    // Everything is okay
    #else
    #  error Boost version is too old
    #endif
    ]])],[
        AC_MSG_RESULT(yes)
    succeeded=yes
    found_system=yes
        ],[
        ])
    AC_LANG_POP([C++])



    dnl if we found no boost with system layout we search for boost libraries
    dnl built and installed without the --layout=system option or for a staged(not installed) version
    if test "x$succeeded" != "xyes"; then
        CPPFLAGS="$CPPFLAGS_SAVED"
        LDFLAGS="$LDFLAGS_SAVED"
        BOOST_CPPFLAGS=
        BOOST_LDFLAGS=
        _version=0
        if test "$ac_boost_path" != ""; then
            if test -d "$ac_boost_path" && test -r "$ac_boost_path"; then
                for i in `ls -d $ac_boost_path/include/boost-* 2>/dev/null`; do
                    _version_tmp=`echo $i | sed "s#$ac_boost_path##" | sed 's/\/include\/boost-//' | sed 's/_/./'`
                    V_CHECK=`expr $_version_tmp \> $_version`
                    if test "$V_CHECK" = "1" ; then
                        _version=$_version_tmp
                    fi
                    VERSION_UNDERSCORE=`echo $_version | sed 's/\./_/'`
                    BOOST_CPPFLAGS="-I$ac_boost_path/include/boost-$VERSION_UNDERSCORE"
                done
                dnl if nothing found search for layout used in Windows distributions
                if test -z "$BOOST_CPPFLAGS"; then
                    if test -d "$ac_boost_path/boost" && test -r "$ac_boost_path/boost"; then
                        BOOST_CPPFLAGS="-I$ac_boost_path"
                    fi
                fi
            fi
        else
            if test "$cross_compiling" != yes; then
                for ac_boost_path in /usr /usr/local /opt /opt/local ; do
                    if test -d "$ac_boost_path" && test -r "$ac_boost_path"; then
                        for i in `ls -d $ac_boost_path/include/boost-* 2>/dev/null`; do
                            _version_tmp=`echo $i | sed "s#$ac_boost_path##" | sed 's/\/include\/boost-//' | sed 's/_/./'`
                            V_CHECK=`expr $_version_tmp \> $_version`
                            if test "$V_CHECK" = "1" ; then
                                _version=$_version_tmp
                                best_path=$ac_boost_path
                            fi
                        done
                    fi
                done

                VERSION_UNDERSCORE=`echo $_version | sed 's/\./_/'`
                BOOST_CPPFLAGS="-I$best_path/include/boost-$VERSION_UNDERSCORE"
                if test "$ac_boost_lib_path" = ""; then
                    for libsubdir in $libsubdirs ; do
                        if ls "$best_path/$libsubdir/libboost_"* >/dev/null 2>&1 ; then break; fi
                    done
                    BOOST_LDFLAGS="-L$best_path/$libsubdir"
                fi
            fi

            if test "x$BOOST_ROOT" != "x"; then
                for libsubdir in $libsubdirs ; do
                    if ls "$BOOST_ROOT/stage/$libsubdir/libboost_"* >/dev/null 2>&1 ; then break; fi
                done
                if test -d "$BOOST_ROOT" && test -r "$BOOST_ROOT" && test -d "$BOOST_ROOT/stage/$libsubdir" && test -r "$BOOST_ROOT/stage/$libsubdir"; then
                    version_dir=`expr //$BOOST_ROOT : '.*/\(.*\)'`
                    stage_version=`echo $version_dir | sed 's/boost_//' | sed 's/_/./g'`
                        stage_version_shorten=`expr $stage_version : '\([[0-9]]*\.[[0-9]]*\)'`
                    V_CHECK=`expr $stage_version_shorten \>\= $_version`
                    if test "$V_CHECK" = "1" -a "$ac_boost_lib_path" = "" ; then
                        AC_MSG_NOTICE(We will use a staged boost library from $BOOST_ROOT)
                        BOOST_CPPFLAGS="-I$BOOST_ROOT"
                        BOOST_LDFLAGS="-L$BOOST_ROOT/stage/$libsubdir"
                    fi
                fi
            fi
        fi

        CPPFLAGS="$CPPFLAGS $BOOST_CPPFLAGS"
        export CPPFLAGS
        LDFLAGS="$LDFLAGS $BOOST_LDFLAGS"
        export LDFLAGS

        AC_LANG_PUSH(C++)
            AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
        @%:@include <boost/version.hpp>
        ]], [[
        #if BOOST_VERSION >= $WANT_BOOST_VERSION
        // Everything is okay
        #else
        #  error Boost version is too old
        #endif
        ]])],[
            AC_MSG_RESULT(yes)
        succeeded=yes
        found_system=yes
            ],[
            ])
        AC_LANG_POP([C++])
    fi

    if test "$succeeded" != "yes" ; then
        if test "$_version" = "0" ; then
            AC_MSG_NOTICE([[We could not detect the boost libraries (version $boost_lib_version_req_shorten or higher). If you have a staged boost library (still not installed) please specify \$BOOST_ROOT in your environment and do not give a PATH to --with-boost option.  If you are sure you have boost installed, then check your version number looking in <boost/version.hpp>. See http://randspringer.de/boost for more documentation.]])
        else
            AC_MSG_NOTICE([Your boost libraries seems to old (version $_version).])
        fi
        # execute ACTION-IF-NOT-FOUND (if present):
        ifelse([$3], , :, [$3])
    else
        AC_SUBST(BOOST_CPPFLAGS)
        AC_SUBST(BOOST_LDFLAGS)
        AC_DEFINE(HAVE_BOOST,,[define if the Boost library is available])
        # execute ACTION-IF-FOUND (if present):
        ifelse([$2], , :, [$2])
    fi

    CPPFLAGS="$CPPFLAGS_SAVED"
    LDFLAGS="$LDFLAGS_SAVED"
fi

])

```

`m4/ax_boost_filesystem.m4`:

```m4
# ===========================================================================
#    http://www.gnu.org/software/autoconf-archive/ax_boost_filesystem.html
# ===========================================================================
#
# SYNOPSIS
#
#   AX_BOOST_FILESYSTEM
#
# DESCRIPTION
#
#   Test for Filesystem library from the Boost C++ libraries. The macro
#   requires a preceding call to AX_BOOST_BASE. Further documentation is
#   available at <http://randspringer.de/boost/index.html>.
#
#   This macro calls:
#
#     AC_SUBST(BOOST_FILESYSTEM_LIB)
#
#   And sets:
#
#     HAVE_BOOST_FILESYSTEM
#
# LICENSE
#
#   Copyright (c) 2009 Thomas Porschberg <thomas@randspringer.de>
#   Copyright (c) 2009 Michael Tindal
#   Copyright (c) 2009 Roman Rybalko <libtorrent@romanr.info>
#
#   Copying and distribution of this file, with or without modification, are
#   permitted in any medium without royalty provided the copyright notice
#   and this notice are preserved. This file is offered as-is, without any
#   warranty.

#serial 26

AC_DEFUN([AX_BOOST_FILESYSTEM],
[
	AC_ARG_WITH([boost-filesystem],
	AS_HELP_STRING([--with-boost-filesystem@<:@=special-lib@:>@],
                   [use the Filesystem library from boost - it is possible to specify a certain library for the linker
                        e.g. --with-boost-filesystem=boost_filesystem-gcc-mt ]),
        [
        if test "$withval" = "no"; then
			want_boost="no"
        elif test "$withval" = "yes"; then
            want_boost="yes"
            ax_boost_user_filesystem_lib=""
        else
		    want_boost="yes"
		ax_boost_user_filesystem_lib="$withval"
		fi
        ],
        [want_boost="yes"]
	)

	if test "x$want_boost" = "xyes"; then
        AC_REQUIRE([AC_PROG_CC])
		CPPFLAGS_SAVED="$CPPFLAGS"
		CPPFLAGS="$CPPFLAGS $BOOST_CPPFLAGS"
		export CPPFLAGS

		LDFLAGS_SAVED="$LDFLAGS"
		LDFLAGS="$LDFLAGS $BOOST_LDFLAGS"
		export LDFLAGS

		LIBS_SAVED=$LIBS
		LIBS="$LIBS $BOOST_SYSTEM_LIB"
		export LIBS

        AC_CACHE_CHECK(whether the Boost::Filesystem library is available,
					   ax_cv_boost_filesystem,
        [AC_LANG_PUSH([C++])
         AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[@%:@include <boost/filesystem/path.hpp>]],
                                   [[using namespace boost::filesystem;
                                   path my_path( "foo/bar/data.txt" );
                                   return 0;]])],
					       ax_cv_boost_filesystem=yes, ax_cv_boost_filesystem=no)
         AC_LANG_POP([C++])
		])
		if test "x$ax_cv_boost_filesystem" = "xyes"; then
			AC_DEFINE(HAVE_BOOST_FILESYSTEM,,[define if the Boost::Filesystem library is available])
            BOOSTLIBDIR=`echo $BOOST_LDFLAGS | sed -e 's/@<:@^\/@:>@*//'`
            if test "x$ax_boost_user_filesystem_lib" = "x"; then
                for libextension in `ls -r $BOOSTLIBDIR/libboost_filesystem* 2>/dev/null | sed 's,.*/lib,,' | sed 's,\..*,,'` ; do
                     ax_lib=${libextension}
				    AC_CHECK_LIB($ax_lib, exit,
                                 [BOOST_FILESYSTEM_LIB="-l$ax_lib"; AC_SUBST(BOOST_FILESYSTEM_LIB) link_filesystem="yes"; break],
                                 [link_filesystem="no"])
				done
                if test "x$link_filesystem" != "xyes"; then
                for libextension in `ls -r $BOOSTLIBDIR/boost_filesystem* 2>/dev/null | sed 's,.*/,,' | sed -e 's,\..*,,'` ; do
                     ax_lib=${libextension}
				    AC_CHECK_LIB($ax_lib, exit,
                                 [BOOST_FILESYSTEM_LIB="-l$ax_lib"; AC_SUBST(BOOST_FILESYSTEM_LIB) link_filesystem="yes"; break],
                                 [link_filesystem="no"])
				done
		    fi
            else
               for ax_lib in $ax_boost_user_filesystem_lib boost_filesystem-$ax_boost_user_filesystem_lib; do
				      AC_CHECK_LIB($ax_lib, exit,
                                   [BOOST_FILESYSTEM_LIB="-l$ax_lib"; AC_SUBST(BOOST_FILESYSTEM_LIB) link_filesystem="yes"; break],
                                   [link_filesystem="no"])
                  done

            fi
            if test "x$ax_lib" = "x"; then
                AC_MSG_ERROR(Could not find a version of the library!)
            fi
			if test "x$link_filesystem" != "xyes"; then
				AC_MSG_ERROR(Could not link against $ax_lib !)
			fi
		fi

		CPPFLAGS="$CPPFLAGS_SAVED"
		LDFLAGS="$LDFLAGS_SAVED"
		LIBS="$LIBS_SAVED"
	fi
])

```

`m4/ax_boost_program_options.m4`:

```m4
# ============================================================================
#  http://www.gnu.org/software/autoconf-archive/ax_boost_program_options.html
# ============================================================================
#
# SYNOPSIS
#
#   AX_BOOST_PROGRAM_OPTIONS
#
# DESCRIPTION
#
#   Test for program options library from the Boost C++ libraries. The macro
#   requires a preceding call to AX_BOOST_BASE. Further documentation is
#   available at <http://randspringer.de/boost/index.html>.
#
#   This macro calls:
#
#     AC_SUBST(BOOST_PROGRAM_OPTIONS_LIB)
#
#   And sets:
#
#     HAVE_BOOST_PROGRAM_OPTIONS
#
# LICENSE
#
#   Copyright (c) 2009 Thomas Porschberg <thomas@randspringer.de>
#
#   Copying and distribution of this file, with or without modification, are
#   permitted in any medium without royalty provided the copyright notice
#   and this notice are preserved. This file is offered as-is, without any
#   warranty.

#serial 24

AC_DEFUN([AX_BOOST_PROGRAM_OPTIONS],
[
	AC_ARG_WITH([boost-program-options],
		AS_HELP_STRING([--with-boost-program-options@<:@=special-lib@:>@],
                       [use the program options library from boost - it is possible to specify a certain library for the linker
                        e.g. --with-boost-program-options=boost_program_options-gcc-mt-1_33_1 ]),
        [
        if test "$withval" = "no"; then
			want_boost="no"
        elif test "$withval" = "yes"; then
            want_boost="yes"
            ax_boost_user_program_options_lib=""
        else
		    want_boost="yes"
		ax_boost_user_program_options_lib="$withval"
		fi
        ],
        [want_boost="yes"]
	)

	if test "x$want_boost" = "xyes"; then
        AC_REQUIRE([AC_PROG_CC])
	    export want_boost
		CPPFLAGS_SAVED="$CPPFLAGS"
		CPPFLAGS="$CPPFLAGS $BOOST_CPPFLAGS"
		export CPPFLAGS
		LDFLAGS_SAVED="$LDFLAGS"
		LDFLAGS="$LDFLAGS $BOOST_LDFLAGS"
		export LDFLAGS
		AC_CACHE_CHECK([whether the Boost::Program_Options library is available],
					   ax_cv_boost_program_options,
					   [AC_LANG_PUSH(C++)
				AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[@%:@include <boost/program_options/errors.hpp>
                                                          ]],
                                  [[boost::program_options::error err("Error message");
                                   return 0;]])],
                           ax_cv_boost_program_options=yes, ax_cv_boost_program_options=no)
					AC_LANG_POP([C++])
		])
		if test "$ax_cv_boost_program_options" = yes; then
				AC_DEFINE(HAVE_BOOST_PROGRAM_OPTIONS,,[define if the Boost::PROGRAM_OPTIONS library is available])
                  BOOSTLIBDIR=`echo $BOOST_LDFLAGS | sed -e 's/@<:@^\/@:>@*//'`
                if test "x$ax_boost_user_program_options_lib" = "x"; then
                for libextension in `ls $BOOSTLIBDIR/libboost_program_options*.so* 2>/dev/null | sed 's,.*/,,' | sed -e 's;^lib\(boost_program_options.*\)\.so.*$;\1;'` `ls $BOOSTLIBDIR/libboost_program_options*.dylib* 2>/dev/null | sed 's,.*/,,' | sed -e 's;^lib\(boost_program_options.*\)\.dylib.*$;\1;'` `ls $BOOSTLIBDIR/libboost_program_options*.a* 2>/dev/null | sed 's,.*/,,' | sed -e 's;^lib\(boost_program_options.*\)\.a.*$;\1;'` ; do
                     ax_lib=${libextension}
				    AC_CHECK_LIB($ax_lib, exit,
                                 [BOOST_PROGRAM_OPTIONS_LIB="-l$ax_lib"; AC_SUBST(BOOST_PROGRAM_OPTIONS_LIB) link_program_options="yes"; break],
                                 [link_program_options="no"])
				done
                if test "x$link_program_options" != "xyes"; then
                for libextension in `ls $BOOSTLIBDIR/boost_program_options*.dll* 2>/dev/null | sed 's,.*/,,' | sed -e 's;^\(boost_program_options.*\)\.dll.*$;\1;'` `ls $BOOSTLIBDIR/boost_program_options*.a* 2>/dev/null | sed 's,.*/,,' | sed -e 's;^\(boost_program_options.*\)\.a.*$;\1;'` ; do
                     ax_lib=${libextension}
				    AC_CHECK_LIB($ax_lib, exit,
                                 [BOOST_PROGRAM_OPTIONS_LIB="-l$ax_lib"; AC_SUBST(BOOST_PROGRAM_OPTIONS_LIB) link_program_options="yes"; break],
                                 [link_program_options="no"])
				done
                fi
                else
                  for ax_lib in $ax_boost_user_program_options_lib boost_program_options-$ax_boost_user_program_options_lib; do
				      AC_CHECK_LIB($ax_lib, main,
                                   [BOOST_PROGRAM_OPTIONS_LIB="-l$ax_lib"; AC_SUBST(BOOST_PROGRAM_OPTIONS_LIB) link_program_options="yes"; break],
                                   [link_program_options="no"])
                  done
                fi
            if test "x$ax_lib" = "x"; then
                AC_MSG_ERROR(Could not find a version of the library!)
            fi
				if test "x$link_program_options" != "xyes"; then
					AC_MSG_ERROR([Could not link against [$ax_lib] !])
				fi
		fi
		CPPFLAGS="$CPPFLAGS_SAVED"
	LDFLAGS="$LDFLAGS_SAVED"
	fi
])

```

`m4/ax_boost_system.m4`:

```m4
# ===========================================================================
#      http://www.gnu.org/software/autoconf-archive/ax_boost_system.html
# ===========================================================================
#
# SYNOPSIS
#
#   AX_BOOST_SYSTEM
#
# DESCRIPTION
#
#   Test for System library from the Boost C++ libraries. The macro requires
#   a preceding call to AX_BOOST_BASE. Further documentation is available at
#   <http://randspringer.de/boost/index.html>.
#
#   This macro calls:
#
#     AC_SUBST(BOOST_SYSTEM_LIB)
#
#   And sets:
#
#     HAVE_BOOST_SYSTEM
#
# LICENSE
#
#   Copyright (c) 2008 Thomas Porschberg <thomas@randspringer.de>
#   Copyright (c) 2008 Michael Tindal
#   Copyright (c) 2008 Daniel Casimiro <dan.casimiro@gmail.com>
#
#   Copying and distribution of this file, with or without modification, are
#   permitted in any medium without royalty provided the copyright notice
#   and this notice are preserved. This file is offered as-is, without any
#   warranty.

#serial 17

AC_DEFUN([AX_BOOST_SYSTEM],
[
	AC_ARG_WITH([boost-system],
	AS_HELP_STRING([--with-boost-system@<:@=special-lib@:>@],
                   [use the System library from boost - it is possible to specify a certain library for the linker
                        e.g. --with-boost-system=boost_system-gcc-mt ]),
        [
        if test "$withval" = "no"; then
			want_boost="no"
        elif test "$withval" = "yes"; then
            want_boost="yes"
            ax_boost_user_system_lib=""
        else
		    want_boost="yes"
		ax_boost_user_system_lib="$withval"
		fi
        ],
        [want_boost="yes"]
	)

	if test "x$want_boost" = "xyes"; then
        AC_REQUIRE([AC_PROG_CC])
        AC_REQUIRE([AC_CANONICAL_BUILD])
		CPPFLAGS_SAVED="$CPPFLAGS"
		CPPFLAGS="$CPPFLAGS $BOOST_CPPFLAGS"
		export CPPFLAGS

		LDFLAGS_SAVED="$LDFLAGS"
		LDFLAGS="$LDFLAGS $BOOST_LDFLAGS"
		export LDFLAGS

        AC_CACHE_CHECK(whether the Boost::System library is available,
					   ax_cv_boost_system,
        [AC_LANG_PUSH([C++])
			 CXXFLAGS_SAVE=$CXXFLAGS

			 AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[@%:@include <boost/system/error_code.hpp>]],
                                   [[boost::system::system_category]])],
                   ax_cv_boost_system=yes, ax_cv_boost_system=no)
			 CXXFLAGS=$CXXFLAGS_SAVE
             AC_LANG_POP([C++])
		])
		if test "x$ax_cv_boost_system" = "xyes"; then
			AC_SUBST(BOOST_CPPFLAGS)

			AC_DEFINE(HAVE_BOOST_SYSTEM,,[define if the Boost::System library is available])
            BOOSTLIBDIR=`echo $BOOST_LDFLAGS | sed -e 's/@<:@^\/@:>@*//'`

			LDFLAGS_SAVE=$LDFLAGS
            if test "x$ax_boost_user_system_lib" = "x"; then
                for libextension in `ls -r $BOOSTLIBDIR/libboost_system* 2>/dev/null | sed 's,.*/lib,,' | sed 's,\..*,,'` ; do
                     ax_lib=${libextension}
				    AC_CHECK_LIB($ax_lib, exit,
                                 [BOOST_SYSTEM_LIB="-l$ax_lib"; AC_SUBST(BOOST_SYSTEM_LIB) link_system="yes"; break],
                                 [link_system="no"])
				done
                if test "x$link_system" != "xyes"; then
                for libextension in `ls -r $BOOSTLIBDIR/boost_system* 2>/dev/null | sed 's,.*/,,' | sed -e 's,\..*,,'` ; do
                     ax_lib=${libextension}
				    AC_CHECK_LIB($ax_lib, exit,
                                 [BOOST_SYSTEM_LIB="-l$ax_lib"; AC_SUBST(BOOST_SYSTEM_LIB) link_system="yes"; break],
                                 [link_system="no"])
				done
                fi

            else
               for ax_lib in $ax_boost_user_system_lib boost_system-$ax_boost_user_system_lib; do
				      AC_CHECK_LIB($ax_lib, exit,
                                   [BOOST_SYSTEM_LIB="-l$ax_lib"; AC_SUBST(BOOST_SYSTEM_LIB) link_system="yes"; break],
                                   [link_system="no"])
                  done

            fi
            if test "x$ax_lib" = "x"; then
                AC_MSG_ERROR(Could not find a version of the library!)
            fi
			if test "x$link_system" = "xno"; then
				AC_MSG_ERROR(Could not link against $ax_lib !)
			fi
		fi

		CPPFLAGS="$CPPFLAGS_SAVED"
	LDFLAGS="$LDFLAGS_SAVED"
	fi
])

```

`m4/ax_check_compile_flag.m4`:

```m4
# ===========================================================================
#   http://www.gnu.org/software/autoconf-archive/ax_check_compile_flag.html
# ===========================================================================
#
# SYNOPSIS
#
#   AX_CHECK_COMPILE_FLAG(FLAG, [ACTION-SUCCESS], [ACTION-FAILURE], [EXTRA-FLAGS], [INPUT])
#
# DESCRIPTION
#
#   Check whether the given FLAG works with the current language's compiler
#   or gives an error.  (Warnings, however, are ignored)
#
#   ACTION-SUCCESS/ACTION-FAILURE are shell commands to execute on
#   success/failure.
#
#   If EXTRA-FLAGS is defined, it is added to the current language's default
#   flags (e.g. CFLAGS) when the check is done.  The check is thus made with
#   the flags: "CFLAGS EXTRA-FLAGS FLAG".  This can for example be used to
#   force the compiler to issue an error when a bad flag is given.
#
#   INPUT gives an alternative input source to AC_COMPILE_IFELSE.
#
#   NOTE: Implementation based on AX_CFLAGS_GCC_OPTION. Please keep this
#   macro in sync with AX_CHECK_{PREPROC,LINK}_FLAG.
#
# LICENSE
#
#   Copyright (c) 2008 Guido U. Draheim <guidod@gmx.de>
#   Copyright (c) 2011 Maarten Bosmans <mkbosmans@gmail.com>
#
#   This program is free software: you can redistribute it and/or modify it
#   under the terms of the GNU General Public License as published by the
#   Free Software Foundation, either version 3 of the License, or (at your
#   option) any later version.
#
#   This program is distributed in the hope that it will be useful, but
#   WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
#   Public License for more details.
#
#   You should have received a copy of the GNU General Public License along
#   with this program. If not, see <http://www.gnu.org/licenses/>.
#
#   As a special exception, the respective Autoconf Macro's copyright owner
#   gives unlimited permission to copy, distribute and modify the configure
#   scripts that are the output of Autoconf when processing the Macro. You
#   need not follow the terms of the GNU General Public License when using
#   or distributing such scripts, even though portions of the text of the
#   Macro appear in them. The GNU General Public License (GPL) does govern
#   all other use of the material that constitutes the Autoconf Macro.
#
#   This special exception to the GPL applies to versions of the Autoconf
#   Macro released by the Autoconf Archive. When you make and distribute a
#   modified version of the Autoconf Macro, you may extend this special
#   exception to the GPL to apply to your modified version as well.

#serial 4

AC_DEFUN([AX_CHECK_COMPILE_FLAG],
[AC_PREREQ(2.64)dnl for _AC_LANG_PREFIX and AS_VAR_IF
AS_VAR_PUSHDEF([CACHEVAR],[ax_cv_check_[]_AC_LANG_ABBREV[]flags_$4_$1])dnl
AC_CACHE_CHECK([whether _AC_LANG compiler accepts $1], CACHEVAR, [
  ax_check_save_flags=$[]_AC_LANG_PREFIX[]FLAGS
  _AC_LANG_PREFIX[]FLAGS="$[]_AC_LANG_PREFIX[]FLAGS $4 $1"
  AC_COMPILE_IFELSE([m4_default([$5],[AC_LANG_PROGRAM()])],
    [AS_VAR_SET(CACHEVAR,[yes])],
    [AS_VAR_SET(CACHEVAR,[no])])
  _AC_LANG_PREFIX[]FLAGS=$ax_check_save_flags])
AS_VAR_IF(CACHEVAR,yes,
  [m4_default([$2], :)],
  [m4_default([$3], :)])
AS_VAR_POPDEF([CACHEVAR])dnl
])dnl AX_CHECK_COMPILE_FLAGS

```

`m4/ax_check_library.m4`:

```m4
# ===========================================================================
#     http://www.gnu.org/software/autoconf-archive/ax_check_library.html
# ===========================================================================
#
# SYNOPSIS
#
#   AX_CHECK_LIBRARY(VARIABLE-PREFIX, HEADER-FILE, LIBRARY-FILE,
#                    [ACTION-IF-FOUND], [ACTION-IF-NOT_FOUND])
#
# DESCRIPTION
#
#   Provides a generic test for a given library, similar in concept to the
#   PKG_CHECK_MODULES macro used by pkg-config.
#
#   Most simplest libraries can be checked against simply through the
#   presence of a header file and a library to link to. This macro allows to
#   wrap around the test so that it doesn't have to be recreated each time.
#
#   Rather than define --with-$LIBRARY arguments, it uses variables in the
#   same way that PKG_CHECK_MODULES does. It doesn't, though, use the same
#   names, since you shouldn't provide a value for LIBS or CFLAGS but rather
#   for LDFLAGS and CPPFLAGS, to tell the linker and compiler where to find
#   libraries and headers respectively.
#
#   If the library is find, HAVE_PREFIX is defined, and in all cases
#   PREFIX_LDFLAGS and PREFIX_CPPFLAGS are substituted.
#
#   Example:
#
#     AX_CHECK_LIBRARY([LIBEVENT], [event.h], [event], [],
#                      [AC_MSG_ERROR([Unable to find libevent])])
#
# LICENSE
#
#   Copyright (c) 2010 Diego Elio Petteno` <flameeyes@gmail.com>
#
#   This program is free software: you can redistribute it and/or modify it
#   under the terms of the GNU General Public License as published by the
#   Free Software Foundation, either version 3 of the License, or (at your
#   option) any later version.
#
#   This program is distributed in the hope that it will be useful, but
#   WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
#   Public License for more details.
#
#   You should have received a copy of the GNU General Public License along
#   with this program. If not, see <http://www.gnu.org/licenses/>.
#
#   As a special exception, the respective Autoconf Macro's copyright owner
#   gives unlimited permission to copy, distribute and modify the configure
#   scripts that are the output of Autoconf when processing the Macro. You
#   need not follow the terms of the GNU General Public License when using
#   or distributing such scripts, even though portions of the text of the
#   Macro appear in them. The GNU General Public License (GPL) does govern
#   all other use of the material that constitutes the Autoconf Macro.
#
#   This special exception to the GPL applies to versions of the Autoconf
#   Macro released by the Autoconf Archive. When you make and distribute a
#   modified version of the Autoconf Macro, you may extend this special
#   exception to the GPL to apply to your modified version as well.

#serial 4

AC_DEFUN([AX_CHECK_LIBRARY], [
  AC_ARG_VAR($1[_CPPFLAGS], [C preprocessor flags for ]$1[ headers])
  AC_ARG_VAR($1[_LDFLAGS], [linker flags for ]$1[ libraries])

  AC_CACHE_VAL(AS_TR_SH([ax_cv_have_]$1),
    [save_CPPFLAGS="$CPPFLAGS"
     save_LDFLAGS="$LDFLAGS"
     save_LIBS="$LIBS"

     AS_IF([test "x$]$1[_CPPFLAGS" != "x"],
       [CPPFLAGS="$CPPFLAGS $]$1[_CPPFLAGS"])

     AS_IF([test "x$]$1[_LDFLAGS" != "x"],
       [LDFLAGS="$LDFLAGS $]$1[_LDFLAGS"])

     AC_CHECK_HEADER($2, [
       AC_CHECK_LIB($3, [main],
         [AS_TR_SH([ax_cv_have_]$1)=yes],
         [AS_TR_SH([ax_cv_have_]$1)=no])
     ], [AS_TR_SH([ax_cv_have_]$1)=no])

     CPPFLAGS="$save_CPPFLAGS"
     LDFLAGS="$save_LDFLAGS"
     LIBS="$save_LIBS"
    ])

  AS_IF([test "$]AS_TR_SH([ax_cv_have_]$1)[" = "yes"],
    AC_DEFINE([HAVE_]$1, [1], [Define to 1 if ]$1[ is found])
    [$4],
    [$5])
])

```

`m4/ax_check_link_flag.m4`:

```m4
# ===========================================================================
#    http://www.gnu.org/software/autoconf-archive/ax_check_link_flag.html
# ===========================================================================
#
# SYNOPSIS
#
#   AX_CHECK_LINK_FLAG(FLAG, [ACTION-SUCCESS], [ACTION-FAILURE], [EXTRA-FLAGS], [INPUT])
#
# DESCRIPTION
#
#   Check whether the given FLAG works with the linker or gives an error.
#   (Warnings, however, are ignored)
#
#   ACTION-SUCCESS/ACTION-FAILURE are shell commands to execute on
#   success/failure.
#
#   If EXTRA-FLAGS is defined, it is added to the linker's default flags
#   when the check is done.  The check is thus made with the flags: "LDFLAGS
#   EXTRA-FLAGS FLAG".  This can for example be used to force the linker to
#   issue an error when a bad flag is given.
#
#   INPUT gives an alternative input source to AC_LINK_IFELSE.
#
#   NOTE: Implementation based on AX_CFLAGS_GCC_OPTION. Please keep this
#   macro in sync with AX_CHECK_{PREPROC,COMPILE}_FLAG.
#
# LICENSE
#
#   Copyright (c) 2008 Guido U. Draheim <guidod@gmx.de>
#   Copyright (c) 2011 Maarten Bosmans <mkbosmans@gmail.com>
#
#   This program is free software: you can redistribute it and/or modify it
#   under the terms of the GNU General Public License as published by the
#   Free Software Foundation, either version 3 of the License, or (at your
#   option) any later version.
#
#   This program is distributed in the hope that it will be useful, but
#   WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
#   Public License for more details.
#
#   You should have received a copy of the GNU General Public License along
#   with this program. If not, see <http://www.gnu.org/licenses/>.
#
#   As a special exception, the respective Autoconf Macro's copyright owner
#   gives unlimited permission to copy, distribute and modify the configure
#   scripts that are the output of Autoconf when processing the Macro. You
#   need not follow the terms of the GNU General Public License when using
#   or distributing such scripts, even though portions of the text of the
#   Macro appear in them. The GNU General Public License (GPL) does govern
#   all other use of the material that constitutes the Autoconf Macro.
#
#   This special exception to the GPL applies to versions of the Autoconf
#   Macro released by the Autoconf Archive. When you make and distribute a
#   modified version of the Autoconf Macro, you may extend this special
#   exception to the GPL to apply to your modified version as well.

#serial 4

AC_DEFUN([AX_CHECK_LINK_FLAG],
[AC_PREREQ(2.64)dnl for _AC_LANG_PREFIX and AS_VAR_IF
AS_VAR_PUSHDEF([CACHEVAR],[ax_cv_check_ldflags_$4_$1])dnl
AC_CACHE_CHECK([whether the linker accepts $1], CACHEVAR, [
  ax_check_save_flags=$LDFLAGS
  LDFLAGS="$LDFLAGS $4 $1"
  AC_LINK_IFELSE([m4_default([$5],[AC_LANG_PROGRAM()])],
    [AS_VAR_SET(CACHEVAR,[yes])],
    [AS_VAR_SET(CACHEVAR,[no])])
  LDFLAGS=$ax_check_save_flags])
AS_VAR_IF(CACHEVAR,yes,
  [m4_default([$2], :)],
  [m4_default([$3], :)])
AS_VAR_POPDEF([CACHEVAR])dnl
])dnl AX_CHECK_LINK_FLAGS

```

`m4/ax_cxx_compile_stdcxx_11.m4`:

```m4
# ============================================================================
#  http://www.gnu.org/software/autoconf-archive/ax_cxx_compile_stdcxx_11.html
# ============================================================================
#
# SYNOPSIS
#
#   AX_CXX_COMPILE_STDCXX_11([ext|noext],[mandatory|optional])
#
# DESCRIPTION
#
#   Check for baseline language coverage in the compiler for the C++11
#   standard; if necessary, add switches to CXXFLAGS to enable support.
#
#   The first argument, if specified, indicates whether you insist on an
#   extended mode (e.g. -std=gnu++11) or a strict conformance mode (e.g.
#   -std=c++11).  If neither is specified, you get whatever works, with
#   preference for an extended mode.
#
#   The second argument, if specified 'mandatory' or if left unspecified,
#   indicates that baseline C++11 support is required and that the macro
#   should error out if no mode with that support is found.  If specified
#   'optional', then configuration proceeds regardless, after defining
#   HAVE_CXX11 if and only if a supporting mode is found.
#
# LICENSE
#
#   Copyright (c) 2008 Benjamin Kosnik <bkoz@redhat.com>
#   Copyright (c) 2012 Zack Weinberg <zackw@panix.com>
#   Copyright (c) 2013 Roy Stogner <roystgnr@ices.utexas.edu>
#   Copyright (c) 2014, 2015 Google Inc.; contributed by Alexey Sokolov <sokolov@google.com>
#   Copyright (c) 2015 Paul Norman <penorman@mac.com>
#
#   Copying and distribution of this file, with or without modification, are
#   permitted in any medium without royalty provided the copyright notice
#   and this notice are preserved. This file is offered as-is, without any
#   warranty.

#serial 12

m4_define([_AX_CXX_COMPILE_STDCXX_11_testbody], [[
  template <typename T>
    struct check
    {
      static_assert(sizeof(int) <= sizeof(T), "not big enough");
    };

    struct Base {
    virtual void f() {}
    };
    struct Child : public Base {
    virtual void f() override {}
    };

    typedef check<check<bool>> right_angle_brackets;

    int a;
    decltype(a) b;

    typedef check<int> check_type;
    check_type c;
    check_type&& cr = static_cast<check_type&&>(c);

    auto d = a;
    auto l = [](){};
    // Prevent Clang error: unused variable 'l' [-Werror,-Wunused-variable]
    struct use_l { use_l() { l(); } };

    // http://stackoverflow.com/questions/13728184/template-aliases-and-sfinae
    // Clang 3.1 fails with headers of libstd++ 4.8.3 when using std::function because of this
    namespace test_template_alias_sfinae {
        struct foo {};

        template<typename T>
        using member = typename T::member_type;

        template<typename T>
        void func(...) {}

        template<typename T>
        void func(member<T>*) {}

        void test();

        void test() {
            func<foo>(0);
        }
    }

    // Check for C++11 attribute support
    void noret [[noreturn]] () { throw 0; }
]])

AC_DEFUN([AX_CXX_COMPILE_STDCXX_11], [dnl
  m4_if([$1], [], [],
        [$1], [ext], [],
        [$1], [noext], [],
        [m4_fatal([invalid argument `$1' to AX_CXX_COMPILE_STDCXX_11])])dnl
  m4_if([$2], [], [ax_cxx_compile_cxx11_required=true],
        [$2], [mandatory], [ax_cxx_compile_cxx11_required=true],
        [$2], [optional], [ax_cxx_compile_cxx11_required=false],
        [m4_fatal([invalid second argument `$2' to AX_CXX_COMPILE_STDCXX_11])])
  AC_LANG_PUSH([C++])dnl
  ac_success=no
  AC_CACHE_CHECK(whether $CXX supports C++11 features by default,
  ax_cv_cxx_compile_cxx11,
  [AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_11_testbody])],
    [ax_cv_cxx_compile_cxx11=yes],
    [ax_cv_cxx_compile_cxx11=no])])
  if test x$ax_cv_cxx_compile_cxx11 = xyes; then
    ac_success=yes
  fi

  m4_if([$1], [noext], [], [dnl
  if test x$ac_success = xno; then
    for switch in -std=gnu++11 -std=gnu++0x; do
      cachevar=AS_TR_SH([ax_cv_cxx_compile_cxx11_$switch])
      AC_CACHE_CHECK(whether $CXX supports C++11 features with $switch,
                     $cachevar,
        [ac_save_CXXFLAGS="$CXXFLAGS"
         CXXFLAGS="$CXXFLAGS $switch"
         AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_11_testbody])],
          [eval $cachevar=yes],
          [eval $cachevar=no])
         CXXFLAGS="$ac_save_CXXFLAGS"])
      if eval test x\$$cachevar = xyes; then
        CXXFLAGS="$CXXFLAGS $switch"
        ac_success=yes
        break
      fi
    done
  fi])

  m4_if([$1], [ext], [], [dnl
  if test x$ac_success = xno; then
    dnl HP's aCC needs +std=c++11 according to:
    dnl http://h21007.www2.hp.com/portal/download/files/unprot/aCxx/PDF_Release_Notes/769149-001.pdf
    for switch in -std=c++11 -std=c++0x +std=c++11; do
      cachevar=AS_TR_SH([ax_cv_cxx_compile_cxx11_$switch])
      AC_CACHE_CHECK(whether $CXX supports C++11 features with $switch,
                     $cachevar,
        [ac_save_CXXFLAGS="$CXXFLAGS"
         CXXFLAGS="$CXXFLAGS $switch"
         AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_11_testbody])],
          [eval $cachevar=yes],
          [eval $cachevar=no])
         CXXFLAGS="$ac_save_CXXFLAGS"])
      if eval test x\$$cachevar = xyes; then
        CXXFLAGS="$CXXFLAGS $switch"
        ac_success=yes
        break
      fi
    done
  fi])
  AC_LANG_POP([C++])
  if test x$ax_cxx_compile_cxx11_required = xtrue; then
    if test x$ac_success = xno; then
      AC_MSG_ERROR([*** A compiler with support for C++11 language features is required.])
    fi
  else
    if test x$ac_success = xno; then
      HAVE_CXX11=0
      AC_MSG_NOTICE([No compiler with C++11 support was found])
    else
      HAVE_CXX11=1
      AC_DEFINE(HAVE_CXX11,1,
                [define if the compiler supports basic C++11 syntax])
    fi

    AC_SUBST(HAVE_CXX11)
  fi
])

```

`m4/ax_require_defined.m4`:

```m4
# ===========================================================================
#    http://www.gnu.org/software/autoconf-archive/ax_require_defined.html
# ===========================================================================
#
# SYNOPSIS
#
#   AX_REQUIRE_DEFINED(MACRO)
#
# DESCRIPTION
#
#   AX_REQUIRE_DEFINED is a simple helper for making sure other macros have
#   been defined and thus are available for use.  This avoids random issues
#   where a macro isn't expanded.  Instead the configure script emits a
#   non-fatal:
#
#     ./configure: line 1673: AX_CFLAGS_WARN_ALL: command not found
#
#   It's like AC_REQUIRE except it doesn't expand the required macro.
#
#   Here's an example:
#
#     AX_REQUIRE_DEFINED([AX_CHECK_LINK_FLAG])
#
# LICENSE
#
#   Copyright (c) 2014 Mike Frysinger <vapier@gentoo.org>
#
#   Copying and distribution of this file, with or without modification, are
#   permitted in any medium without royalty provided the copyright notice
#   and this notice are preserved. This file is offered as-is, without any
#   warranty.

#serial 1

AC_DEFUN([AX_REQUIRE_DEFINED], [dnl
  m4_ifndef([$1], [m4_fatal([macro ]$1[ is not defined; is a m4 file missing?])])
])dnl AX_REQUIRE_DEFINED

```

`src/aggregate.cpp`:

```cpp
/*
 * ntfs-linker
 * Copyright 2015 Stroz Friedberg, LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the license, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * A copy of the GNU Lesser General Public License is available at
 * <http://www.gnu.org/licenses/>.
 *
 * You can contact Stroz Friedberg by electronic and paper mail as follows:
 *
 * Stroz Friedberg, LLC
 * 32 Avenue of the Americas
 * 4th Floor
 * New York, NY, 10013
 * info@strozfriedberg.com
 */

#include "aggregate.h"
#include "controller.h"
#include "file.h"
#include "util.h"
#include "sqlite_util.h"

#include <fstream>
#include <sqlite3.h>
#include <sstream>
#include <string>
#include <vector>

int writeAndStep(Event& event, sqlite3_stmt* step, sqlite3_stmt* insert, std::vector<File>& records, int order, std::ofstream& out) {
  event.Order = order;
  event.write(out, records);
  event.updateRecords(records);
  event.insert(insert, records);

  return sqlite3_step(step);
}

void outputEvents(std::vector<File>& records, SQLiteHelper& sqliteHelper, VolumeIO& volumeIO, const VersionInfo& version) {
  int u, l;
  Event usnEvent, logEvent;
  int order = volumeIO.Count;
  std::ofstream& out(volumeIO.Events);

  sqliteHelper.bindForSelect(version);
  u = sqlite3_step(sqliteHelper.EventUsnSelect);
  l = sqlite3_step(sqliteHelper.EventLogSelect);

  // Output log events until the log event is a create, so we can compare timestamps properly.
  while (l == SQLITE_ROW) {
    logEvent.init(sqliteHelper.EventLogSelect);
    if (logEvent.Type == EventTypes::TYPE_CREATE) {
      break;
    }
    logEvent.IsAnchor = false;
    l = writeAndStep(logEvent, sqliteHelper.EventLogSelect, sqliteHelper.EventFinalInsert, records, ++order, out);
  }

  while (u == SQLITE_ROW && l == SQLITE_ROW) {
    usnEvent.init(sqliteHelper.EventUsnSelect);
    logEvent.init(sqliteHelper.EventLogSelect);

    if (usnEvent.Timestamp > logEvent.Timestamp) {
      usnEvent.IsAnchor = true;
      u = writeAndStep(usnEvent, sqliteHelper.EventUsnSelect, sqliteHelper.EventFinalInsert, records, ++order, out);
    }
    else {
      logEvent.IsAnchor = true;
      l = writeAndStep(logEvent, sqliteHelper.EventLogSelect, sqliteHelper.EventFinalInsert, records, ++order, out);

      while (l == SQLITE_ROW) {
        logEvent.init(sqliteHelper.EventLogSelect);
        if (logEvent.Type == EventTypes::TYPE_CREATE) {
          break;
        }
        l = writeAndStep(logEvent, sqliteHelper.EventLogSelect, sqliteHelper.EventFinalInsert, records, ++order, out);
      }
    }
  }

  while (u == SQLITE_ROW) {
    usnEvent.init(sqliteHelper.EventUsnSelect);
    usnEvent.IsAnchor = true;
    u = writeAndStep(usnEvent, sqliteHelper.EventUsnSelect, sqliteHelper.EventFinalInsert, records, ++order, out);
  }

  while (l == SQLITE_ROW) {
    logEvent.init(sqliteHelper.EventLogSelect);
    logEvent.IsAnchor = false;
    l = writeAndStep(logEvent, sqliteHelper.EventLogSelect, sqliteHelper.EventFinalInsert, records, ++order, out);
  }

  sqliteHelper.resetSelect();
  volumeIO.Count = order;
  return;
}

std::string textToString(const unsigned char* text) {
  return text == NULL ? "" : std::string(reinterpret_cast<const char*>(text));
}

void Event::init(sqlite3_stmt* stmt) {
  int i = -1;
  Record         = sqlite3_column_int64(stmt, ++i);
  Parent         = sqlite3_column_int64(stmt, ++i);
  PreviousParent = sqlite3_column_int64(stmt, ++i);
  UsnLsn         = sqlite3_column_int64(stmt, ++i);
  Timestamp      = textToString(sqlite3_column_text(stmt, ++i));
  Name           = textToString(sqlite3_column_text(stmt, ++i));
  PreviousName   = textToString(sqlite3_column_text(stmt, ++i));
  Type           = sqlite3_column_int(stmt, ++i);
  Source         = sqlite3_column_int(stmt, ++i);
  IsEmbedded     = sqlite3_column_int(stmt, ++i);
  Offset         = sqlite3_column_int64(stmt, ++i);
  Created        = textToString(sqlite3_column_text(stmt, ++i));
  Modified       = textToString(sqlite3_column_text(stmt, ++i));
  Comment        = textToString(sqlite3_column_text(stmt, ++i));
  Snapshot       = textToString(sqlite3_column_text(stmt, ++i));
  Volume         = textToString(sqlite3_column_text(stmt, ++i));

  if (PreviousParent == Parent)
    PreviousParent = -1;
  if (PreviousName == Name)
    PreviousName = "";
  IsAnchor = false;
}

Event::Event() {
  Record = Parent = PreviousParent = UsnLsn = Type = Source = -1;
  Volume = Snapshot = Timestamp = Name = PreviousName = "";
}

std::string Event::getColumnHeaders() {
  std::stringstream ss;
  ss << "Index"             << "\t"
     << "Timestamp"         << "\t"
     << "Source"            << "\t"
     << "Type"              << "\t"
     << "File Name"         << "\t"
     << "Folder"            << "\t"
     << "Full Path"         << "\t"
     << "MFT Record"        << "\t"
     << "Parent MFT Record" << "\t"
     << "USN/LSN"           << "\t"
     << "Old File Name"     << "\t"
     << "Old Folder"        << "\t"
     << "Old Parent Record" << "\t"
     << "Offset"            << "\t"
     << "Created"           << "\t"
     << "Modified"          << "\t"
     << "Comment"           << "\t"
     << "Snapshot"          << "\t"
     << "Volume"            << std::endl;
  return ss.str();
}

void Event::write(std::ostream& out, const std::vector<File>& records) {
  out << Order                                                                         << "\t"
      << (IsAnchor ? Timestamp : "")                                                   << "\t"
      << (IsEmbedded ? EventSources::SOURCE_EMBEDDED_USN : static_cast<EventSources>(Source)) << "\t"
      << static_cast<EventTypes>(Type)                                                 << "\t"
      << Name                                                                          << "\t"
      << (Parent == -1 ? "" : getFullPath(records, Parent))                            << "\t"
      << (Record == -1 ? "" : getFullPath(records, Record))                            << "\t"
      << (Record == -1 ? "" : std::to_string(Record))                                  << "\t"
      << (Parent == -1 ? "" : std::to_string(Parent))                                  << "\t"
      << UsnLsn                                                                        << "\t"
      << PreviousName                                                                  << "\t"
      << (PreviousParent == -1 ? "" : getFullPath(records, PreviousParent))            << "\t"
      << (PreviousParent == -1 ? "" : std::to_string(PreviousParent))                  << "\t"
      << Offset                                                                        << "\t"
      << Created                                                                       << "\t"
      << Modified                                                                      << "\t"
      << Comment                                                                       << "\t"
      << Snapshot                                                                      << "\t"
      << Volume                                                                        << std::endl;
}

void bind_int_or_null(sqlite3_stmt* stmt, int i, int64_t value) {
  if (value == -1) {
    sqlite3_bind_null(stmt, i);
  }
  else {
    sqlite3_bind_int64(stmt, i, value);
  }
}

void Event::insert(sqlite3_stmt* stmt, std::vector<File>& records) {
  int i = 0;
  sqlite3_bind_int64(stmt, ++i, Order);
  sqlite3_bind_text (stmt, ++i, (IsAnchor ? Timestamp : "").c_str(), -1, SQLITE_TRANSIENT);
  sqlite3_bind_text (stmt, ++i, toString(IsEmbedded ? EventSources::SOURCE_EMBEDDED_USN : static_cast<EventSources>(Source)).c_str(), -1, SQLITE_TRANSIENT);
  sqlite3_bind_text (stmt, ++i, toString(static_cast<EventTypes>(Type)).c_str(), -1, SQLITE_TRANSIENT);
  sqlite3_bind_text (stmt, ++i, Name.c_str(), -1, SQLITE_TRANSIENT);
  sqlite3_bind_text (stmt, ++i, (Parent == -1 ? "" : getFullPath(records, Parent)).c_str(), -1, SQLITE_TRANSIENT);
  sqlite3_bind_text (stmt, ++i, (Record == -1 ? "" : getFullPath(records, Record)).c_str(), -1, SQLITE_TRANSIENT);
  bind_int_or_null  (stmt, ++i, Record);
  bind_int_or_null  (stmt, ++i, Parent);
  sqlite3_bind_int64(stmt, ++i, UsnLsn);
  sqlite3_bind_text (stmt, ++i, PreviousName.c_str(), -1, SQLITE_TRANSIENT);
  sqlite3_bind_text (stmt, ++i, (PreviousParent == -1 ? "" : getFullPath(records, PreviousParent)).c_str(), -1, SQLITE_TRANSIENT);
  bind_int_or_null  (stmt, ++i, PreviousParent);
  sqlite3_bind_int64(stmt, ++i, Offset);
  sqlite3_bind_text (stmt, ++i, Created.c_str(), -1, SQLITE_TRANSIENT);
  sqlite3_bind_text (stmt, ++i, Modified.c_str(), -1, SQLITE_TRANSIENT);
  sqlite3_bind_text (stmt, ++i, Comment.c_str(), -1, SQLITE_TRANSIENT);
  sqlite3_bind_text (stmt, ++i, Snapshot.c_str(), -1, SQLITE_TRANSIENT);
  sqlite3_bind_text (stmt, ++i, Volume.c_str(), -1, SQLITE_TRANSIENT);

  sqlite3_step(stmt);
  sqlite3_reset(stmt);
}

void Event::updateRecords(std::vector<File>& records) {
  if (static_cast<uint64_t>(Record) >= records.size())
    return;
  std::vector<File>::iterator it;
  switch(Type) {
    case EventTypes::TYPE_CREATE:
      // A file was created, so to move backwards, we should delete it
      // But let's leave it be.
      //records[Record].Valid = false;
      //records[Record] = File();
      break;
    case EventTypes::TYPE_DELETE:
      // A file was deleted, so to move backwards, create it
      if (Record >= 0)
        records[Record] = File(Name, Record, Parent, Timestamp);
      break;
    case EventTypes::TYPE_MOVE:
      // Embedded events haven't been aggregated, so before/after name not known
      if (!IsEmbedded)
        records[Record].Parent = PreviousParent;
      break;
    case EventTypes::TYPE_RENAME:
      // Embedded events haven't been aggregated, so before/after name not known
      if (!IsEmbedded && PreviousName != "")
        records[Record].Name = PreviousName;
      break;
  }
  return;
}

```

`src/controller.cpp`:

```cpp
/*
 * ntfs-linker
 * Copyright 2015 Stroz Friedberg, LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the license, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * A copy of the GNU Lesser General Public License is available at
 * <http://www.gnu.org/licenses/>.
 *
 * You can contact Stroz Friedberg by electronic and paper mail as follows:
 *
 * Stroz Friedberg, LLC
 * 32 Avenue of the Americas
 * 4th Floor
 * New York, NY, 10013
 * info@strozfriedberg.com
 */

#include "aggregate.h"
#include "controller.h"
#include "file.h"
#include "log.h"
#include "mft.h"
#include "usn.h"
#include "vss.h"
#include "walkers.h"

#include <boost/scoped_array.hpp>
#include <sstream>

SnapshotIO::SnapshotIO(Options& opts, VolumeIO* parent) : Parent(parent), Name(opts.input.string()), Good(false) {
  IMft.open((opts.input / fs::path("$MFT")).string(), std::ios::binary);
  IUsnJrnl.open((opts.input / fs::path("$UsnJrnl")).string(), std::ios::binary);
  ILogFile.open((opts.input / fs::path("$LogFile")).string(), std::ios::binary);

  if(!IMft) {
    std::cerr << "$MFT File not found in directory: " << opts.input.string() << std::endl;
    return;
  }
  if(!IUsnJrnl) {
    IUsnJrnl.open((opts.input / fs::path("$J")).string(), std::ios::binary);
    if(!IUsnJrnl) {
      std::cerr << "$UsnJrnl/$J File not found in directory: " << opts.input.string() << std::endl;
      return;
    }
  }
  if(!ILogFile) {
    std::cerr << "$LogFile File not found in directory: " << opts.input.string() << std::endl;
    return;
  }

  fs::create_directories(opts.output);
  prep_ofstream(OUsnJrnl, (opts.output / fs::path("usnjrnl.txt")).string(), opts.overwrite);
  prep_ofstream(OLogFile, (opts.output / fs::path("logfile.txt")).string(), opts.overwrite);
  Good = true;
}

VolumeIO::VolumeIO(Options& opts, ImageIO* parent) : Parent(parent), Count(0), Name(opts.input.string()), Good(false)  {
  std::vector<fs::path> snapshots;
  std::copy(fs::directory_iterator(opts.input), fs::directory_iterator(), std::back_inserter(snapshots));
  std::sort(snapshots.begin(), snapshots.end());
  for (auto& snapshot: snapshots) {
    if (fs::is_directory(snapshot)) {
      Options snapshotOpts = opts;
      snapshotOpts.input  /= snapshot.filename();
      snapshotOpts.output /= snapshot.filename();
      auto snapshot(std::make_shared<SnapshotIO>(snapshotOpts, this));
      if (snapshot->Good) {
        Snapshots.push_back(snapshot);
        Good = true;
      }
    }
  }

  if (!Good) {
    auto snapshot(std::make_shared<SnapshotIO>(opts, this));
    if (snapshot->Good) {
      Snapshots.push_back(snapshot);
      Good = true;
    }
    else {
      std::cerr << "Unable to process folder: " << opts.input << " as a volume folder. Neither this folder nor any subdirectory contain all of $MFT, $J, $LogFile" << std::endl;
      return;
    }
  }
  prep_ofstream(Events, (opts.output / fs::path("events.txt")).string(), opts.overwrite);
}

ImageIO::ImageIO(Options& opts) : Good(false) {
  std::vector<fs::path> volumes;
  std::copy(fs::directory_iterator(opts.input), fs::directory_iterator(), std::back_inserter(volumes));
  std::sort(volumes.begin(), volumes.end());
  for (auto& volume: volumes) {
    if (fs::is_directory(volume)) {
      Options volumeOpts = opts;
      volumeOpts.input /= volume.filename();
      volumeOpts.output /= volume.filename();
      auto volume(std::make_shared<VolumeIO>(volumeOpts, this));
      if (volume->Good) {
        Good = true;
        Volumes.push_back(volume);
      }
    }
  }

  if (!Good) {
    auto volume(std::make_shared<VolumeIO>(opts, this));
    if (volume->Good) {
      Good = true;
      Volumes.push_back(volume);
    }
    else {
      std::cerr << "Unable to process folder: " << opts.input << " as an image folder. Neither this folder, nor any of its subdirectories could be processed as a volume." << std::endl;
      return;
    }
  }

  std::cout << "Setting up DB Connection..." << std::endl;
  std::string dbName = (opts.output / fs::path("ntfs.db")).string();
  SqliteHelper.init(dbName, opts.overwrite);
}

std::string ImageIO::getSummary() {
  std::ostringstream ss;
  int sum = 0;
  int recordSum = 0;
  for (auto const& volume: Volumes) {
    ss << "Volume " << volume->Name << ": processed "
       << pluralize("snapshot", volume->Snapshots.size()) << ", "
       << pluralize("record", volume->Count) << ".\n";
    sum += volume->Snapshots.size();
    recordSum += volume->Count;
  }
  ss << "Total: processed " << pluralize("volume", Volumes.size()) << ", "
     << pluralize("snapshot", sum) << ", "
     << pluralize("record", recordSum) << ".";
  return ss.str();
}

void copyAllFiles(Options& opts) {
  if (opts.imgSegs.size()) {
    std::cout << "Copying files out of image..." << std::endl;
    boost::scoped_array<const char*> segments(new const char*[opts.imgSegs.size()]);
    for (unsigned int i = 0; i < opts.imgSegs.size(); ++i) {
      segments[i] = opts.imgSegs[i].c_str();
    }
    VolumeWalker walker(opts.input);
    walker.openImageUtf8(opts.imgSegs.size(), segments.get(), TSK_IMG_TYPE_DETECT, 0);
    walker.findFilesInImg();

    if (walker.DidItWork) {
      std::cout << std::endl;
      std::cout << "Copying completed successfully. Summary: " << std::endl;
      std::cout << walker.getSummary() << std::endl;
      std::cout << std::endl;
    }
    else {
      std::cerr << "Error: unable to copy out files. Terminating." << std::endl;
      exit(1);
    }

  }
}

int processStep(SnapshotIO& snapshotIO, bool extra) {
  //Set up db connection
  std::vector<File> records;
  SQLiteHelper& sqliteHelper = snapshotIO.Parent->Parent->SqliteHelper;
  std::cout << "Parsing $MFT" << std::endl;
  parseMFT(records, snapshotIO.IMft);

  std::cout << "Parsing $UsnJrnl..." << std::endl;
  parseUSN(records, sqliteHelper, snapshotIO.IUsnJrnl, snapshotIO.OUsnJrnl, VersionInfo(snapshotIO.Name, snapshotIO.Parent->Name), extra);
  std::cout << "Parsing $LogFile..." << std::endl;
  parseLog(records, sqliteHelper, snapshotIO.ILogFile, snapshotIO.OLogFile, VersionInfo(snapshotIO.Name, snapshotIO.Parent->Name), extra);
  return 0;
}

int processFinalize(SnapshotIO& snapshotIO) {
  std::vector<File> records;
  SQLiteHelper& sqliteHelper = snapshotIO.Parent->Parent->SqliteHelper;
  VolumeIO& volumeIO = *snapshotIO.Parent;

  parseMFT(records, snapshotIO.IMft);

  outputEvents(records, sqliteHelper, volumeIO, VersionInfo(snapshotIO.Name, volumeIO.Name));

  return 0;
}

void run(Options& opts) {
  copyAllFiles(opts);

  ImageIO imageIO(opts);
  if (!imageIO.Good) {
    std::cerr << "Unable to process input folder structure. Terminating." << std::endl;
    exit(1);
  }

  for (auto& volumeIO: imageIO.Volumes) {
    std::cout << "Finding events on Volume: " << volumeIO->Name << std::endl;

    imageIO.SqliteHelper.beginTransaction();
    for (auto& snapshotIO: volumeIO->Snapshots) {
      std::cout << "Parsing input files for snapshot: " << snapshotIO->Name << std::endl;
      processStep(*snapshotIO, opts.extra);
      std::cout << std::endl;
    }
    imageIO.SqliteHelper.endTransaction();
    imageIO.SqliteHelper.beginTransaction();

    std::cout << std::endl << "Generating unified events output..." << std::endl;
    volumeIO->Events << Event::getColumnHeaders();
    std::vector<SnapshotIOPtr>::reverse_iterator rIt;
    for (rIt = volumeIO->Snapshots.rbegin(); rIt != volumeIO->Snapshots.rend(); ++rIt) {
      std::cout << "Processing events from snapshot: " << (*rIt)->Name << std::endl;
      processFinalize(**rIt);
    }

    imageIO.SqliteHelper.endTransaction();
  }
  imageIO.SqliteHelper.close();
  std::cout << std::endl;
  std::cout << imageIO.getSummary() << std::endl;
  std::cout << "Process complete." << std::endl;

}

```

`src/log.cpp`:

```cpp
/*
 * ntfs-linker
 * Copyright 2015 Stroz Friedberg, LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the license, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * A copy of the GNU Lesser General Public License is available at
 * <http://www.gnu.org/licenses/>.
 *
 * You can contact Stroz Friedberg by electronic and paper mail as follows:
 *
 * Stroz Friedberg, LLC
 * 32 Avenue of the Americas
 * 4th Floor
 * New York, NY, 10013
 * info@strozfriedberg.com
 */

#include "log.h"
#include "util.h"
#include "mft.h"
#include "progress.h"
#include "sqlite_util.h"
#include "usn.h"

#include <cstring>
#include <iomanip>
#include <sstream>

/*
Decodes the LogFile Op code
*/
std::string decodeLogFileOpCode(int op) {
  switch(op) {
    case LogOps::NOOP                               : return "Noop";
    case LogOps::COMPENSATION_LOG_RECORD            : return "CompensationLogRecord";
    case LogOps::INITIALIZE_FILE_RECORD_SEGMENT     : return "InitializeFileRecordSegment";
    case LogOps::DEALLOCATE_FILE_RECORD_SEGMENT     : return "DeallocateFileRecordSegment";
    case LogOps::WRITE_END_OF_FILE_RECORD_SEGMENT   : return "WriteEndOfFileRecordSegment";
    case LogOps::CREATE_ATTRIBUTE                   : return "CreateAttribute";
    case LogOps::DELETE_ATTRIBUTE                   : return "DeleteAttribute";
    case LogOps::UPDATE_RESIDENT_VALUE              : return "UpdateResidentValue";
    case LogOps::UPDATE_NONRESIDENT_VALUE           : return "UpdateNonresidentValue";
    case LogOps::UPDATE_MAPPING_PAIRS               : return "UpdateMappingPairs";
    case LogOps::DELETE_DIRTY_CLUSTERS              : return "DeleteDirtyClusters";
    case LogOps::SET_NEW_ATTRIBUTE_SIZES            : return "SetNewAttributeSizes";
    case LogOps::ADD_INDEX_ENTRY_ROOT               : return "AddIndexEntryRoot";
    case LogOps::DELETE_INDEX_ENTRY_ROOT            : return "DeleteIndexEntryRoot";
    case LogOps::ADD_INDEX_ENTRY_ALLOCATION         : return "AddIndexEntryAllocation";
    case LogOps::DELETE_INDEX_ENTRY_ALLOCATION      : return "DeleteIndexEntryAllocation";
    case LogOps::SET_INDEX_ENTRY_VCN_ALLOCATION     : return "SetIndexEntryVCNAllocation";
    case LogOps::UPDATE_FILE_NAME_ROOT              : return "UpdateFileNameRoot";
    case LogOps::UPDATE_FILE_NAME_ALLOCATION        : return "UpdateFileNameAllocation";
    case LogOps::SET_BITS_IN_NONRESIDENT_BIT_MAP    : return "SetBitsInNonresidentBitMap";
    case LogOps::CLEAR_BITS_IN_NONRESIDENT_BIT_MAP  : return "ClearBitsInNonresidentBitMap";
    case LogOps::PREPARE_TRANSACTION                : return "PrepareTransaction";
    case LogOps::COMMIT_TRANSACTION                 : return "CommitTransaction";
    case LogOps::FORGET_TRANSACTION                 : return "ForgetTransaction";
    case LogOps::OPEN_NONRESIDENT_ATTRIBUTE         : return "OpenNonresidentAttribute";
    case LogOps::DIRTY_PAGE_TABLE_DUMP              : return "DirtyPageTableDump";
    case LogOps::TRANSACTION_TABLE_DUMP             : return "TransactionTableDump";
    case LogOps::UPDATE_RECORD_DATA_ROOT            : return "UpdateRecordDataRoot";
    default:
      return "Invalid";
  }
}

/*
Parses the $LogFile
outputs to the various streams
*/
void parseLog(const std::vector<File>& records, SQLiteHelper& sqliteHelper, std::istream& input, std::ostream& output, const VersionInfo& version, bool extra) {
  unsigned int buffer_size = 4096;
  char* buffer = new char[buffer_size];
  bool split_record = false;
  bool done = false;
  bool parseError = true;
  int records_processed = 3;
  int adjust = 0;
  bool prev_has_next = true;

  /*Skip past the junk at the beginning of the file
  The first two pages (0x0000 - 0x2000) are restart pages
  The next two pages (0x2000 - 0x4000) are buffer record pages
  in my testing I've seen very little of value here, and it doesn't follow the same format as the rest of the $LogFile
  */
  input.clear();
  input.seekg(0, std::ios::end);
  uint64_t end = input.tellg();
  ProgressBar status(end);
  uint64_t start = 0x4000;
  input.seekg(start, std::ios::beg);
  input.read(buffer, 4096);
  doFixup(buffer, 4096, 512);

  output << LogRecord::getColumnHeaders();

  LogData transactions(version);
  transactions.clearFields();

  //scan through the $LogFile one  page at a time. Each record is 4096 bytes.
  while(!input.eof() && !done) {

    status.setDone((uint64_t) input.tellg() - start);
    //check log record header
    if(hex_to_long(buffer, 4) != 0x44524352) {
      input.read(buffer, 4096);
      if (input.eof())
        break;
      doFixup(buffer, 4096, 512);
      buffer_size = 4096;
      adjust = 0;
      continue;
    }
    records_processed++;
    unsigned int update_seq_offset, update_seq_count, offset, next_record_offset;
    unsigned int length = 0;
    update_seq_offset = hex_to_long(buffer + 0x4, 2);
    update_seq_count = hex_to_long(buffer + 0x6, 2);
    offset = update_seq_offset + ceilingDivide(update_seq_count, 4) * 8;
    next_record_offset = hex_to_long(buffer + 0x18, 2);
    if(parseError) { //initialize the offset on the "first" record processed
      offset = next_record_offset;
      parseError = false;
      transactions.clearFields();
    }

    //parse log record
    while(offset + 0x30 <= buffer_size) {
      int64_t cur_offset = static_cast<long int>(input.tellg()) - buffer_size + offset - adjust;
      if (transactions.Offset == -1)
        transactions.Offset = cur_offset;
      LogRecord rec(version);
      int rtnVal = rec.init(buffer + offset, cur_offset, prev_has_next);
      prev_has_next = rec.LcnsToFollow;
      if(rtnVal == -1) {
        split_record = true;
        length = rec.ClientDataLength + 0x30;
        break;
      } else if(rtnVal < 0) {
        length = rec.ClientDataLength + 0x30;
        parseError = true;
        break;
      } else {
        length = rtnVal;
      }

      if (extra) {
        output << rec;
        rec.insert(sqliteHelper.LogInsert);
      }

      transactions.processLogRecord(records, rec, sqliteHelper, cur_offset);
      if(transactions.isTransactionOver()) {
        if(transactions.isCreateEvent()) {
          transactions.insertEvent(EventTypes::TYPE_CREATE, sqliteHelper.EventInsert);
        }
        if(transactions.isDeleteEvent()) {
          transactions.insertEvent(EventTypes::TYPE_DELETE, sqliteHelper.EventInsert);
        }
        if(transactions.isRenameEvent()) {
          transactions.insertEvent(EventTypes::TYPE_RENAME, sqliteHelper.EventInsert);
        }
        if(transactions.isMoveEvent()) {
          transactions.insertEvent(EventTypes::TYPE_MOVE, sqliteHelper.EventInsert);
        }
        transactions.clearFields();
      }
      offset += length;
    }

    /*
    If a record is left dangling across a page boundary, we can still parse the record
    The strategy is to rearrange the data like so:
    BEFORE: dangling record | RCRD header | rest of record | rest of page
    AFTER : RCRD header | dangling record | rest of record | rest of page
    We perform  a little switcheroo then return to the top of the loop
    */
    if(split_record) {
      unsigned int new_size = ceilingDivide(length - buffer_size + offset, 4032) * 4096 + buffer_size - offset;
      char* temp = new char[new_size];
      adjust = buffer_size - offset;
      input.read(temp + buffer_size - offset, 4096);
      if(input.eof()) {
        done = true;
        delete[] temp;
        break;
      }
      doFixup(temp + buffer_size - offset, 4096, 512);

      update_seq_offset = hex_to_long(temp + buffer_size - offset + 0x4, 2);
      update_seq_count = hex_to_long(temp + buffer_size - offset + 0x6, 2);
      unsigned int header_length = update_seq_offset + ceilingDivide(update_seq_count, 4) * 8;
      memmove(temp, temp + buffer_size - offset, header_length);
      memcpy(temp + header_length, buffer + offset, buffer_size - offset);
      delete[] buffer;
      buffer = temp;
      // Flag the record as not crossing the current page
      buffer[header_length + 0x28] = 0;
      buffer[header_length + 0x29] = 0;
      unsigned int write_offset = buffer_size - offset + 4096;

      /*
      In some cases, it's not that easy. Sometimes a single record spans multiple pages.
      We perform a more involved switcheroo.
      Notice that we are implicitly assuming
      that the page header is always 0x40 bytes, whereas before we perform some calculation involving
      the update sequence offset and update sequence count

      The first page header is left intact, but subsequent page headers are discarded
      BEFORE: RCRD header | record pt1 | RCRD header | record pt2 | RCRD header | record pt3 | ...
      AFTER : RCRD header | record pt1 | record pt2 | record pt3 | ...
      */
      for(unsigned int i = 1; write_offset < new_size; i++) {
        temp = new char[4096];
        input.read(temp, 4096);
        if(input.eof()) {
          done = true;
          delete[] temp;
          break;
        }
        doFixup(temp, 4096, 512);

        update_seq_offset = hex_to_long(temp + 0x4, 2);
        update_seq_count = hex_to_long(temp + 0x6, 2);
        header_length = update_seq_offset + ceilingDivide(update_seq_count, 4) * 8;
        memcpy(buffer + write_offset, temp + header_length, 4096 - header_length);
        write_offset += 4096 - header_length;
        records_processed++;
        new_size -= header_length;
        delete[] temp;
      }
      buffer_size = new_size;
      split_record = false;

    }
    else {
      /*
      If the preceding record wasn't flagged for being split across the page,
      we just read the next page. Easy.
      */
      input.read(buffer, 4096);
      if(input.eof()) {
        done = true;
        break;
      }
      doFixup(buffer, 4096, 512);
      buffer_size = 4096;

      adjust = 0;
    }

  }

  if (transactions.PrevUsnRecord.Usn != 0) {
    transactions.PrevUsnRecord.checkTypeAndInsert(sqliteHelper.EventInsert);
  }
  status.finish();
  delete [] buffer;
}

int LogRecord::init(char* buffer, uint64_t offset, bool prev_has_next) {
  Data = buffer;
  Offset = offset;
  CurrentLsn = hex_to_long(buffer, 8);
  PreviousLsn = hex_to_long(buffer + 0x8, 8);
  UndoLsn = hex_to_long(buffer + 0x10, 8);

  ClientDataLength = hex_to_long(buffer + 0x18, 4);

  ClientId = hex_to_long(buffer + 0x1C, 4);
  RecordType = hex_to_long(buffer + 0x20, 4);

  /*
  Not particularly a concern. Sometimes there is extra slack space at the end of a page.
  In which case, we read that the record type is 0 and print an error message
  (since 0 is not a valid record type).
  If these error messages are spamming error output, however, then something probably went
  horribly wrong. Most likely cause is that the parser offset became misplaced and tried to
  parse the wrong bits of the records.
  */
  if(RecordType == 0) {
    if (prev_has_next) {
      std::cerr << std::setw(60) << std::left << std::setfill(' ') << "\r";
      std::cerr << "Invalid record type: 0x" << std::hex << RecordType
                << " where valid record expected at offset 0x" << std::hex << offset
                << " in snapshot: " << Snapshot
                << " . Skipping to next page." << std::endl;
    }
    return -2;
  }

  /*
  A flag on a record means that at least part of the record is on the next page.
  We do some fancy switcheroo stuff at the bottom of the loop to compensate.
  */
  Flags = hex_to_long(buffer + 0x28, 2);
  if(Flags == 1) {
    return -1;
  }

  RedoOp = hex_to_long(buffer + 0x30, 2);
  UndoOp = hex_to_long(buffer + 0x32, 2);

  // We've run into some junk data
  if(RedoOp > 0x21 || UndoOp > 0x21) {
    std::cerr << std::setw(60) << std::left << std::setfill(' ') << "\r";
    std::cerr << "\rInvalid $LogFile op code: 0x" << std::hex << RedoOp << " 0x" << UndoOp
              << " at offset 0x" << offset << " in snapshot: " << Snapshot
              << ". Skipping to next page. " << std::endl;
    return -2;
  }
  RedoOffset = hex_to_long(buffer + 0x34, 2);
  RedoLength = hex_to_long(buffer + 0x36, 2);
  UndoOffset = hex_to_long(buffer + 0x38, 2);
  UndoLength = hex_to_long(buffer + 0x3a, 2);
  TargetAttribute = hex_to_long(buffer + 0x3c, 2);
  LcnsToFollow = hex_to_long(buffer + 0x3e, 2);

  RecordOffset = hex_to_long(buffer + 0x40, 2);
  AttributeOffset = hex_to_long(buffer + 0x42, 2);
  MftClusterIndex = hex_to_long(buffer + 0x44, 2);
  TargetVcn = hex_to_long(buffer + 0x48, 4);

  TargetLcn = hex_to_long(buffer + 0x50, 4);

  /*
  The length given by ClientDataLength is actually 0x30 less than the length of the record.
  */

  return 0x30 + ClientDataLength;

}

void LogData::processLogRecord(const std::vector<File>& records, LogRecord& rec, SQLiteHelper& sqliteHelper, uint64_t fileOffset) {
  if(Lsn == 0) {
    Lsn = rec.CurrentLsn;
  }
  RedoOps.push_back(rec.RedoOp);
  UndoOps.push_back(rec.UndoOp);

  char *redo_data = rec.Data + 0x30 + rec.RedoOffset;
  char *undo_data = rec.Data + 0x30 + rec.UndoOffset;
  //pull data from necessary opcodes to save for transaction runs
  if(rec.RedoOp == LogOps::SET_BITS_IN_NONRESIDENT_BIT_MAP && rec.UndoOp == LogOps::CLEAR_BITS_IN_NONRESIDENT_BIT_MAP) {
    if(rec.RedoLength >= 4)
      Record = hex_to_long(redo_data, 4);
  }
  else if(rec.RedoOp == LogOps::INITIALIZE_FILE_RECORD_SEGMENT && rec.UndoOp == LogOps::NOOP) {
    //parse MFT record from redo op for create time, file name, parent dir
    //need to check for possible second MFT attribute header
    MFTRecord mftRec(redo_data, rec.RedoLength);
    // Modified timestamp!
    // In case of file system tunneling (i.e., this event is really a write),
    // the Creation time is not the event time - it's the time the file was _originally_ created
    // https://support.microsoft.com/en-us/kb/299648
    Timestamp = filetime_to_iso_8601(mftRec.Sia.Modified);

    Created = filetime_to_iso_8601(mftRec.Sia.Created);
    Modified = filetime_to_iso_8601(mftRec.Sia.Modified);
    std::stringstream commentSS;
    if (Created != filetime_to_iso_8601(mftRec.Fna.Created))
      commentSS << "Creates don't match, ";
    if (Modified != filetime_to_iso_8601(mftRec.Fna.Modified))
      commentSS << "Modifies don't match";
    Comment = commentSS.str();

    if (Fna < mftRec.Fna)
      Fna = mftRec.Fna;
  }
  else if(rec.RedoOp == LogOps::DELETE_ATTRIBUTE && rec.UndoOp == LogOps::CREATE_ATTRIBUTE) {
    //get the name before
    //from file attribute with header, undo op
    uint64_t type_id = hex_to_long(undo_data, 4);
    uint64_t content_offset = hex_to_long(undo_data + 0x14, 2);
    if (type_id == 0x30) {
      FNAttribute fna(undo_data + content_offset);

      if (PreviousFna < fna)
        PreviousFna = fna;
    }
  }
  else if(rec.RedoOp == LogOps::CREATE_ATTRIBUTE && rec.UndoOp == LogOps::DELETE_ATTRIBUTE) {
    //get the name after
    //from file attribute with header, redo op
    //prev_name =

    uint64_t type_id = hex_to_long(redo_data, 4);
    uint64_t content_offset = hex_to_long(redo_data + 0x14, 2);
    if (type_id == 0x30) {
      FNAttribute fna(redo_data + content_offset);

      if (Fna < fna)
        Fna = fna;
    }
  }
  else if((rec.RedoOp == LogOps::DELETE_INDEX_ENTRY_ALLOCATION && rec.UndoOp == LogOps::ADD_INDEX_ENTRY_ALLOCATION) || (rec.RedoOp == LogOps::DELETE_INDEX_ENTRY_ROOT && rec.UndoOp == LogOps::ADD_INDEX_ENTRY_ROOT)) {
    if(rec.UndoLength > 0x42) {
      // Delete or rename
      FNAttribute fna(undo_data + 0x10);

      if (Fna < fna)
        Fna = fna;
    }

  }
  else if ((rec.RedoOp == LogOps::ADD_INDEX_ENTRY_ALLOCATION && rec.UndoOp == LogOps::DELETE_INDEX_ENTRY_ALLOCATION) || (rec.RedoOp == LogOps::ADD_INDEX_ENTRY_ROOT && rec.UndoOp == LogOps::DELETE_INDEX_ENTRY_ROOT)) {
    // Add index entry root/AddIndexEntryAllocation operation
    // See https://flatcap.org/linux-ntfs/ntfs/concepts/index_record.html
    // for additional info about Index Record structure ("The header part")
    // TODO REFACTOR MAKE THIS ITS OWN CLASS
    if (rec.RedoLength > 0x52) {
      Record = hex_to_long(redo_data, 6);
      FNAttribute fna(redo_data + 0x10);
      Timestamp = filetime_to_iso_8601(fna.Created);

      if (Fna < fna)
        Fna = fna;
    }
  }
  else if (rec.RedoOp == LogOps::UPDATE_NONRESIDENT_VALUE && rec.UndoOp == LogOps::NOOP) {
    // Embedded $UsnJrnl/$J record
    UsnRecord usnRecord(redo_data, fileOffset + 0x30 + rec.RedoOffset, VersionInfo(Snapshot, Volume), rec.RedoLength, true);
    usnRecord.insert(sqliteHelper.UsnInsert, records);
    if (PrevUsnRecord.Record != usnRecord.Record || PrevUsnRecord.Reason & UsnReasons::USN_CLOSE) {
      PrevUsnRecord.checkTypeAndInsert(sqliteHelper.EventInsert, false);
      PrevUsnRecord.clearFields();
    }
    if (PrevUsnRecord.Usn == 0)
      PrevUsnRecord = usnRecord;
    PrevUsnRecord.update(usnRecord);

  }
}

void LogData::clearFields() {
  RedoOps.clear();
  UndoOps.clear();
  Record = -1;
  Timestamp = "";
  Lsn = 0;
  Fna = FNAttribute();
  PreviousFna = FNAttribute();
  Offset = -1;
  Created = "";
  Modified = "";
  Comment = "";
}

/*
Returns whether the given transaction run (redo1, undo1) matches the
given transaction run pattern. Will attempt to find a matching entry in redo1, undo1 for each entry
in redo2, undo2 (in the same order)
if interchange is true then ADD_INDEX_ENTRY_ROOT=ADD_INDEX_ENTRY_ALLOCATION and DELETE_INDEX_ENTRY_ROOT=DELETE_INDEX_ENTRY_ALLOCATION
*/
bool LogData::transactionRunMatch(const std::vector<int>& redo2, const std::vector<int>& undo2, bool interchange) {
  unsigned int j = 0;
  std::vector<int> redo1(RedoOps);
  std::vector<int> undo1(UndoOps);
  for(unsigned int i = 0; i < redo2.size(); i++) {
    bool top = false;
    for(; j < redo1.size() && !top; j++) {

      if(interchange) {
        if(redo1[j] == LogOps::ADD_INDEX_ENTRY_ROOT)    redo1[j] = LogOps::ADD_INDEX_ENTRY_ALLOCATION;
        if(redo1[j] == LogOps::DELETE_INDEX_ENTRY_ROOT) redo1[j] = LogOps::DELETE_INDEX_ENTRY_ALLOCATION;
        if(undo1[j] == LogOps::ADD_INDEX_ENTRY_ROOT)    undo1[j] = LogOps::ADD_INDEX_ENTRY_ALLOCATION;
        if(undo1[j] == LogOps::DELETE_INDEX_ENTRY_ROOT) undo1[j] = LogOps::DELETE_INDEX_ENTRY_ALLOCATION;
      }
      if(redo2[i] == redo1[j] && undo2[i] == undo1[j])
        top = true;
    }
    if(!top)
      return false;
  }
  return true;
}

void LogData::insertEvent(unsigned int type, sqlite3_stmt* stmt) {
  int i = 0;
  sqlite3_bind_int64(stmt, ++i, Record);
  sqlite3_bind_int64(stmt, ++i, Fna.Parent);
  sqlite3_bind_int64(stmt, ++i, PreviousFna.Parent);
  sqlite3_bind_int64(stmt, ++i, Lsn);
  sqlite3_bind_text (stmt, ++i, Timestamp.c_str()   , -1, SQLITE_TRANSIENT);
  sqlite3_bind_text (stmt, ++i, Fna.Name.c_str()        , -1, SQLITE_TRANSIENT);
  sqlite3_bind_text (stmt, ++i, PreviousFna.Name.c_str(), -1, SQLITE_TRANSIENT);
  sqlite3_bind_int64(stmt, ++i, type);
  sqlite3_bind_int64(stmt, ++i, EventSources::SOURCE_LOG);
  sqlite3_bind_int64(stmt, ++i, 0);  // Not embedded
  sqlite3_bind_int64(stmt, ++i, Offset);
  sqlite3_bind_text (stmt, ++i, Created.c_str()     , -1, SQLITE_TRANSIENT);
  sqlite3_bind_text (stmt, ++i, Modified.c_str()    , -1, SQLITE_TRANSIENT);
  sqlite3_bind_text (stmt, ++i, Comment.c_str()     , -1, SQLITE_TRANSIENT);
  sqlite3_bind_text (stmt, ++i, Snapshot.c_str()    , -1, SQLITE_TRANSIENT);
  sqlite3_bind_text (stmt, ++i, Volume.c_str()      , -1, SQLITE_TRANSIENT);

  sqlite3_step(stmt);
  sqlite3_reset(stmt);
}

void LogRecord::insert(sqlite3_stmt* stmt) {
  int i = 0;
  sqlite3_bind_int64(stmt, ++i, CurrentLsn);
  sqlite3_bind_int64(stmt, ++i, PreviousLsn);
  sqlite3_bind_int64(stmt, ++i, UndoLsn);
  sqlite3_bind_int  (stmt, ++i, ClientId);
  sqlite3_bind_int  (stmt, ++i, RecordType);
  sqlite3_bind_text (stmt, ++i, decodeLogFileOpCode(RedoOp).c_str(), -1, SQLITE_TRANSIENT);
  sqlite3_bind_text (stmt, ++i, decodeLogFileOpCode(UndoOp).c_str(), -1, SQLITE_TRANSIENT);
  sqlite3_bind_int  (stmt, ++i, TargetAttribute);
  sqlite3_bind_int  (stmt, ++i, MftClusterIndex);
  sqlite3_bind_int64(stmt, ++i, Offset);
  sqlite3_bind_text (stmt, ++i, Snapshot.c_str(), -1, SQLITE_TRANSIENT);
  sqlite3_bind_text (stmt, ++i, Volume.c_str()  , -1, SQLITE_TRANSIENT);

  sqlite3_step(stmt);
  sqlite3_reset(stmt);
}

std::string LogRecord::getColumnHeaders() {
  std::stringstream ss;
  ss << "Current Lsn"       << "\t"
     << "Previous Lsn"      << "\t"
     << "Undo Lsn"          << "\t"
     << "Client ID"         << "\t"
     << "Record Type"       << "\t"
     << "Redo Op"           << "\t"
     << "Undo Op"           << "\t"
     << "Target Attribute"  << "\t"
     << "MFT Cluster Index" << "\t"
     << "Target VCN"        << "\t"
     << "Target LCN"        << "\t"
     << "Offset"            << "\t"
     << "Snapshot"          << "\t"
     << "Volume"            << std::endl;
  return ss.str();
}

std::ostream& operator<<(std::ostream& out, const LogRecord& rec) {
  out << rec.CurrentLsn                  << "\t"
      << rec.PreviousLsn                 << "\t"
      << rec.UndoLsn                     << "\t"
      << rec.ClientId                    << "\t"
      << rec.RecordType                  << "\t"
      << decodeLogFileOpCode(rec.RedoOp) << "\t"
      << decodeLogFileOpCode(rec.UndoOp) << "\t"
      << rec.TargetAttribute             << "\t"
      << rec.MftClusterIndex             << "\t"
      << rec.TargetVcn                   << "\t"
      << rec.TargetLcn                   << "\t"
      << rec.Offset                      << "\t"
      << rec.Snapshot                    << "\t"
      << rec.Volume                      << std::endl;
  return out;
}

bool LogData::isCreateEvent() {
  return transactionRunMatch(LogData::createRedo, LogData::createUndo);
}

bool LogData::isDeleteEvent() {
  return transactionRunMatch(LogData::deleteRedo, LogData::deleteUndo);
}

bool LogData::isRenameEvent() {
  return Fna.Name != PreviousFna.Name && transactionRunMatch(LogData::renameRedo, LogData::renameUndo);
}

bool LogData::isMoveEvent() {
  return Fna.Parent != PreviousFna.Parent && transactionRunMatch(LogData::renameRedo, LogData::renameUndo);
}

bool LogData::isTransactionOver() {
  return RedoOps.back() == LogOps::FORGET_TRANSACTION && UndoOps.back() == LogOps::COMPENSATION_LOG_RECORD;
}

const std::vector<int> LogData::createRedo ({LogOps::SET_BITS_IN_NONRESIDENT_BIT_MAP,
                                              LogOps::NOOP,
                                              LogOps::ADD_INDEX_ENTRY_ALLOCATION,
                                              LogOps::INITIALIZE_FILE_RECORD_SEGMENT,
                                              LogOps::FORGET_TRANSACTION});
const std::vector<int> LogData::createUndo ({LogOps::CLEAR_BITS_IN_NONRESIDENT_BIT_MAP,
                                              LogOps::DEALLOCATE_FILE_RECORD_SEGMENT,
                                              LogOps::DELETE_INDEX_ENTRY_ALLOCATION,
                                              LogOps::NOOP,
                                              LogOps::COMPENSATION_LOG_RECORD});
const std::vector<int> LogData::deleteRedo ({LogOps::DELETE_INDEX_ENTRY_ALLOCATION,
                                              LogOps::DEALLOCATE_FILE_RECORD_SEGMENT,
                                              LogOps::CLEAR_BITS_IN_NONRESIDENT_BIT_MAP,
                                              LogOps::FORGET_TRANSACTION});
const std::vector<int> LogData::deleteUndo ({LogOps::ADD_INDEX_ENTRY_ALLOCATION,
                                              LogOps::INITIALIZE_FILE_RECORD_SEGMENT,
                                              LogOps::SET_BITS_IN_NONRESIDENT_BIT_MAP,
                                              LogOps::COMPENSATION_LOG_RECORD});
const std::vector<int> LogData::renameRedo ({LogOps::DELETE_INDEX_ENTRY_ALLOCATION,
                                              LogOps::DELETE_ATTRIBUTE,
                                              LogOps::CREATE_ATTRIBUTE,
                                              LogOps::ADD_INDEX_ENTRY_ALLOCATION,
                                              LogOps::FORGET_TRANSACTION});
const std::vector<int> LogData::renameUndo ({LogOps::ADD_INDEX_ENTRY_ALLOCATION,
                                              LogOps::CREATE_ATTRIBUTE,
                                              LogOps::DELETE_ATTRIBUTE,
                                              LogOps::DELETE_INDEX_ENTRY_ALLOCATION,
                                              LogOps::COMPENSATION_LOG_RECORD});
const std::vector<int> LogData::writeRedo  ({LogOps::DELETE_ATTRIBUTE,
                                              LogOps::CREATE_ATTRIBUTE,
                                              LogOps::SET_BITS_IN_NONRESIDENT_BIT_MAP,
                                              LogOps::SET_NEW_ATTRIBUTE_SIZES,
                                              LogOps::UPDATE_MAPPING_PAIRS,
                                              LogOps::SET_NEW_ATTRIBUTE_SIZES,
                                              LogOps::FORGET_TRANSACTION});
const std::vector<int> LogData::writeUndo  ({LogOps::CREATE_ATTRIBUTE,
                                              LogOps::DELETE_ATTRIBUTE,
                                              LogOps::CLEAR_BITS_IN_NONRESIDENT_BIT_MAP,
                                              LogOps::SET_NEW_ATTRIBUTE_SIZES,
                                              LogOps::UPDATE_MAPPING_PAIRS,
                                              LogOps::SET_NEW_ATTRIBUTE_SIZES,
                                              LogOps::COMPENSATION_LOG_RECORD});

```

`src/mft.cpp`:

```cpp
/*
 * ntfs-linker
 * Copyright 2015 Stroz Friedberg, LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the license, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * A copy of the GNU Lesser General Public License is available at
 * <http://www.gnu.org/licenses/>.
 *
 * You can contact Stroz Friedberg by electronic and paper mail as follows:
 *
 * Stroz Friedberg, LLC
 * 32 Avenue of the Americas
 * 4th Floor
 * New York, NY, 10013
 * info@strozfriedberg.com
 */

#include <sstream>

#include "util.h"
#include "mft.h"
#include "file.h"
#include "progress.h"
#include "sqlite_util.h"

MFTRecord::MFTRecord(char* buffer, unsigned int len) {
  // MFT entries must begin with FILE
  if(hex_to_long(buffer, 4) != 0x454C4946) {
    return;
  }

  // Parse basic information from file record segment header
  Lsn                          = hex_to_long(buffer + 8,    8);
  Record                       = hex_to_long(buffer + 0x2c, 4);
  uint64_t allocation_flag     = hex_to_long(buffer + 0x16, 2);
  uint64_t mft_space_allocated = hex_to_long(buffer + 0x18, 4);
  uint64_t offset              = hex_to_long(buffer + 0x14, 2);

  isAllocated                  = allocation_flag & 0x1;
  isDir                        = allocation_flag & 0x2;

  // Parse the attributes
  while(offset + 0x16 <= len && offset + 0x16 <= mft_space_allocated) {

    uint64_t type_id          = hex_to_long(buffer + offset,        4);
    uint64_t attribute_length = hex_to_long(buffer + offset + 4,    4);
    uint64_t content_offset   = hex_to_long(buffer + offset + 0x14, 2);
    char* attribute_data      = buffer + offset + content_offset;

    switch(type_id) {
      case 0x10:
        Sia = SIAttribute(attribute_data);
        break;
      case 0x30:
        // Use the fna which is "largest" (based on ASCII-ness and size)
        FNAttribute fna2(attribute_data);
        if (!Fna.Valid)
          Fna = fna2;

        if (Fna < fna2) {
          Fna = fna2;
        }
        break;
    }

    //check for valid attribute length value
    if(attribute_length > 0 && attribute_length < len)
      offset += attribute_length;
    else {
      break;
    }
  }
}

SIAttribute::SIAttribute(char* buffer) {
  Created     = hex_to_long(buffer + 0x0,  8);
  Modified    = hex_to_long(buffer + 0x8,  8);
  MFTModified = hex_to_long(buffer + 0x10, 8);
  Accessed    = hex_to_long(buffer + 0x18, 8);
  Usn         = hex_to_long(buffer + 0x40, 8);
  Valid       = true;
}

FNAttribute::FNAttribute(char* buffer) {
  Parent                = hex_to_long(buffer,        6);
  Created               = hex_to_long(buffer + 0x08, 8);
  Modified              = hex_to_long(buffer + 0x10, 8);
  MFTModified           = hex_to_long(buffer + 0x18, 8);
  Accessed              = hex_to_long(buffer + 0x20, 8);
  LogicalSize           = hex_to_long(buffer + 0x28, 8);
  PhysicalSize          = hex_to_long(buffer + 0x30, 8);
  unsigned int name_len = hex_to_long(buffer + 0x40, 1);
  NameType              = hex_to_long(buffer + 0x41, 1);
  Name                  = mbcatos    (buffer + 0x42, 2*name_len);
  Valid                 = true;
}

bool compareNameTypes(int a, int b) {
  // Name type codes:
  // ref: http://www.writeblocked.org/resources/ntfs_cheat_sheets.pdf
  // 0x0: Unicode, case sensitive (best)
  // 0x1: Unicode, case insensitive
  // 0x2: DOS (8.3 ASCII, case insensitive) (worst)
  // 0x3: Win32 7 DOS (when Win32 fits in DOS space) (?)
  if (a != b && (a == 0x2 || b == 0x2)) {
    return a == 0x2? true: false;
  }
  if (a != b) {
    return a > b;
  }
  // Time to just pick one, really
  return false;
}

bool FNAttribute::operator<(const FNAttribute& other) const {
  if (!Valid)
    return true;
  return compareNameTypes(NameType, other.NameType);
}

File MFTRecord::asFile() {
  return File(Fna.Name, Record, Fna.Parent, filetime_to_iso_8601(Sia.MFTModified));
}

void parseMFT(std::vector<File>& records, std::istream& input) {
  char buffer[1024];

  int records_processed = 0;

  input.clear();
  input.seekg(0, std::ios::end);
  uint64_t end = input.tellg();
  input.seekg(0, std::ios::beg);
  ProgressBar status(end);

  //scan through the $MFT one record at a time. Each record is 1024 bytes.
  while(!input.eof()) {
    status.setDone((uint64_t) input.tellg());
    records_processed++;
    input.read(buffer, 1024);
    doFixup(buffer, 1024, 512);
    MFTRecord record(buffer);
    for(int i = record.Record - records.size(); i >= 0; i--)
      records.push_back(File());
    records[record.Record] = record.asFile();
  }

  status.finish();
}

```

`src/ntfs_linker.cpp`:

```cpp
/*
 * ntfs-linker
 * Copyright 2015 Stroz Friedberg, LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the license, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * A copy of the GNU Lesser General Public License is available at
 * <http://www.gnu.org/licenses/>.
 *
 * You can contact Stroz Friedberg by electronic and paper mail as follows:
 *
 * Stroz Friedberg, LLC
 * 32 Avenue of the Americas
 * 4th Floor
 * New York, NY, 10013
 * info@strozfriedberg.com
 */

#include "controller.h"
#include "util.h"

#include <boost/program_options.hpp>

namespace po = boost::program_options;

void printHelp(const po::options_description& desc, const po::positional_options_description& posOpts) {
  std::vector<std::string> parts;
  parts.push_back("Usage: ntfs_linker");
  for (unsigned int i = 0; i < posOpts.max_total_count(); ++i) {
    parts.push_back(posOpts.name_for_position(i));
  }
  if (desc.options().size() > 0) {
    parts.push_back("[options]");
  }
  std::stringstream ss;
  std::copy(parts.begin(), parts.end(), std::ostream_iterator<std::string>(ss, " "));
  std::cout << "ntfs-linker, Copyright (c) Stroz Friedberg, LLC" << std::endl;
  std::cout << "Version " << VERSION << std::endl;
  std::cout << ss.str() << std::endl;
  std::cout << desc << std::endl;
}

int main(int argc, char** argv) {
  Options opts;

  po::options_description desc("Allowed options");
  po::positional_options_description posOpts;
  posOpts.add("ntfs-dir", 1);
  posOpts.add("output", 1);
  desc.add_options()
    ("ntfs-dir", po::value<std::string>(), "If no image specified, location of root directory containing input files. Otherwise, root directory in which to dump files extracted from image. See the docs for info about ntfs-dir structure.")
    ("output", po::value<std::string>(), "directory in which to dump output files")
    ("image", po::value<std::vector<std::string>>(), "Path to image file(s)")
    ("overwrite", "overwrite files in the output directory. Default: append")
    ("extra", "Outputs supplemental lower-level parsed data from $UsnJrnl and $LogFile")
    ("help", "display help and exit")
    ("version", "display version number and exit");

  po::variables_map vm;
  try {
    po::store(po::command_line_parser(argc, argv).options(desc).positional(posOpts).run(), vm);
    po::notify(vm);

    opts.overwrite = vm.count("overwrite");
    opts.extra = vm.count("extra");

    if (vm.count("help")) {
      printHelp(desc, posOpts);
    }
    else if (vm.count("version")) {
        std::cout << "ntfs_linker version: " << VERSION << std::endl;
    }
    else if (vm.count("ntfs-dir") && vm.count("output")) {
      // Run
      opts.input = fs::path(vm["ntfs-dir"].as<std::string>());
      opts.output = fs::path(vm["output"].as<std::string>());
      if (vm.count("image")) {
        opts.imgSegs = vm["image"].as<std::vector<std::string>>();
      }
      run(opts);
    }
    else {
      printHelp(desc, posOpts);
      std::cerr << "Error: did not understand arguments" << std::endl;
    }
  }
  catch (std::exception& err) {
    std::cerr << "Error: " << err.what() << std::endl << std::endl;
    printHelp(desc, posOpts);
    return 1;
  }
  return 0;
}

```

`src/progress.cpp`:

```cpp
/*
 * ntfs-linker
 * Copyright 2015 Stroz Friedberg, LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the license, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * A copy of the GNU Lesser General Public License is available at
 * <http://www.gnu.org/licenses/>.
 *
 * You can contact Stroz Friedberg by electronic and paper mail as follows:
 *
 * Stroz Friedberg, LLC
 * 32 Avenue of the Americas
 * 4th Floor
 * New York, NY, 10013
 * info@strozfriedberg.com
 */

#include "progress.h"

#include <iomanip>
#include <iostream>
#include <sstream>

void ProgressBar::addToDo(uint64_t x) {
  toDo += x;
}

void ProgressBar::addDone(uint64_t x) {
  done += x;
  printProgress();
}

void ProgressBar::setDone(uint64_t x) {
  done = x;
  printProgress();
}

void ProgressBar::printProgress() {
  long double percent = (long double) done / toDo;
  const int width = 50;
  if((int) (width * percent) > last) {
    std::stringstream ss;
    ss << "\r[";
    int i;
    for(i = 0; i < (int) (width * percent); i++)
      ss << "=";
    for(; i < width; i++)
      ss << " ";
    ss << "] ";
    ss << (int) (percent * 100);
    ss << "%";
    std::cout << ss.str();
    std::cout.flush();
    last = (int) (width * percent);
  }
}

ProgressBar::ProgressBar(uint64_t x) {
  toDo = x;
  done = 0;
  last = -1;
  printProgress();
}

void ProgressBar::finish() {
  done = toDo;
  printProgress();
  clear();
}

void ProgressBar::clear() {
  std::cout << std::setw(70) << std::left << std::setfill(' ') << "\r";
  std::cout << "\r";
  std::cout.flush();
}

```

`src/sqlite_util.cpp`:

```cpp
/*
 * ntfs-linker
 * Copyright 2015 Stroz Friedberg, LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the license, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * A copy of the GNU Lesser General Public License is available at
 * <http://www.gnu.org/licenses/>.
 *
 * You can contact Stroz Friedberg by electronic and paper mail as follows:
 *
 * Stroz Friedberg, LLC
 * 32 Avenue of the Americas
 * 4th Floor
 * New York, NY, 10013
 * info@strozfriedberg.com
 */

#include "aggregate.h"
#include "sqlite_util.h"

#include <fstream>
#include <iostream>
#include <sstream>

int busyHandler(__attribute__((unused)) void* foo, __attribute__((unused)) int num) {
  char input;
  std::cerr << "Database is busy. Cannot commit transaction." << std::endl;
  std::cerr << "Close any application which may have a lock on the database." << std::endl;
  std::cerr << "Try again? (y/n): ";
  std::cin >> input;
  if(input == 'y' || input == 'Y')
    return 1;
  else
    exit(0);

}

std::string getColList(const std::vector<std::vector<std::string>>& cols, int type) {
  std::stringstream ss;
  bool isFirst = true;
  for (auto& col: cols) {
    if(!isFirst) {
      ss << ", ";
    }
    isFirst = false;
    switch(type) {
      case 0:
        ss << col[0] << " " << col[1];
        break;
      case 1:
        ss << col[0];
        break;
      case 2:
        ss << "?";
        break;
    }
  }
  return ss.str();
}

void SQLiteHelper::init(std::string dbName, bool overwrite) {
  int rc = 0;

  /*
  vacuum cleaning the db file doesn't seem to work
  Instead, I'll open the file for writing, then close it
  so that the file is truncated
  */
  if(overwrite) {
    std::ofstream file(dbName.c_str(), std::ios::trunc);
    file.close();
  }
  rc = sqlite3_open_v2(dbName.c_str(), &Db, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, NULL);
  if(rc) {
    std::cerr << "Error opening database" << std::endl;
    exit(1);
  }

  sqlite3_busy_handler(Db, &busyHandler, 0);
  beginTransaction();

  if(overwrite) {
    rc |= sqlite3_exec(Db, "drop table if exists log;", 0, 0, 0);
    rc |= sqlite3_exec(Db, "drop table if exists usn;", 0, 0, 0);
    rc |= sqlite3_exec(Db, "drop table if exists event;", 0, 0, 0);
  }
  rc |= sqlite3_exec(Db, std::string("create table if not exists log "
                                     "(" + getColList(LogColumns, 0) + ");").c_str(),
                     0, 0, 0);
  rc |= sqlite3_exec(Db, std::string("create table if not exists usn "
                                    "(" + getColList(UsnColumns, 0) + ");").c_str(),
                     0, 0, 0);
  rc |= sqlite3_exec(Db, std::string("create temporary table event_temp "
                                     "(" + getColList(EventTempColumns, 0) + ", "
                                     "UNIQUE(USN_LSN, EventSource, Volume));").c_str(),
                     0, 0, 0);
  rc |= sqlite3_exec(Db, std::string("create table if not exists event "
                                     "(" + getColList(EventColumns, 0) + ");").c_str(),
                     0, 0, 0);
  if(rc) {
    std::cerr << "SQL Error " << rc << " at " << __FILE__ << ":" << __LINE__ << std::endl;
    std::cerr << sqlite3_errmsg(Db) << std::endl;
    sqlite3_close(Db);
    exit(1);
  }
  prepareStatements();
  endTransaction();
}

void SQLiteHelper::beginTransaction() {
  int rc = sqlite3_exec(Db, "BEGIN TRANSACTION", 0, 0, 0);
  if(rc) {
    std::cerr << "SQL Error " << rc << " at " << __FILE__ << ":" << __LINE__ << std::endl;
    std::cerr << sqlite3_errmsg(Db) << std::endl;
    sqlite3_close(Db);
    exit(1);
  }
}

void SQLiteHelper::endTransaction() {
  int rc = sqlite3_exec(Db, "END TRANSACTION", 0, 0, 0);
  if(rc) {
    std::cerr << "SQL Error " << rc << " at " << __FILE__ << ":" << __LINE__ << std::endl;
    std::cerr << sqlite3_errmsg(Db) << std::endl;
    sqlite3_close(Db);
    exit(1);
  }
}

void SQLiteHelper::close() {
  finalizeStatements();
  sqlite3_close(Db);
}

int SQLiteHelper::prepareStatement(sqlite3_stmt **stmt, std::string& sql) {
  return sqlite3_prepare_v2(Db, sql.c_str(), sql.length() + 1, stmt, NULL);
}

void SQLiteHelper::bindForSelect(const VersionInfo& version) {
  sqlite3_bind_int64(EventUsnSelect, 1, EventSources::SOURCE_USN);
  sqlite3_bind_int64(EventLogSelect, 1, EventSources::SOURCE_LOG);

  sqlite3_bind_text(EventUsnSelect, 2, version.Snapshot.c_str(), -1, SQLITE_TRANSIENT);
  sqlite3_bind_text(EventLogSelect, 2, version.Snapshot.c_str(), -1, SQLITE_TRANSIENT);

  sqlite3_bind_text(EventUsnSelect, 3, version.Volume.c_str(), -1, SQLITE_TRANSIENT);
  sqlite3_bind_text(EventLogSelect, 3, version.Volume.c_str(), -1, SQLITE_TRANSIENT);
}

void SQLiteHelper::resetSelect() {
  sqlite3_reset(EventUsnSelect);
  sqlite3_reset(EventLogSelect);
}

void SQLiteHelper::prepareStatements() {
  int rc = 0;
  std::string usnInsert = "insert into usn (" + getColList(UsnColumns, 1) + ") "
                                   "values (" + getColList(UsnColumns, 2) + ");";
  std::string logInsert = "insert into log (" + getColList(LogColumns, 1) + ") "
                                   "values (" + getColList(LogColumns, 2) + ");";
  // Events are processed from the oldest to the newest, so when an event with a conflicting (USN_LSN, EventSource)
  // comes into play, it should be ignored
  std::string eventInsert = "insert or ignore into event_temp "
                            "(" + getColList(EventTempColumns, 1) + ") "
                            + "values (" + getColList(EventTempColumns, 2) + ");";
  std::string eventFinalInsert = "insert into event "
                            "(" + getColList(EventColumns, 1) + ") "
                            + "values (" + getColList(EventColumns, 2) + ");";
  std::string eventSelect = "select " + getColList(EventTempColumns, 1) + " from event_temp where EventSource=? and Snapshot=? and Volume=? order by USN_LSN desc;";

  rc |= prepareStatement(&UsnInsert, usnInsert);
  rc |= prepareStatement(&LogInsert, logInsert);
  rc |= prepareStatement(&EventInsert, eventInsert);
  rc |= prepareStatement(&EventFinalInsert, eventFinalInsert);
  rc |= prepareStatement(&EventUsnSelect, eventSelect);
  rc |= prepareStatement(&EventLogSelect, eventSelect);

  if (rc) {
    std::cerr << "SQL Error " << rc << " at " << __FILE__ << ":" << __LINE__ << std::endl;
    std::cerr << sqlite3_errmsg(Db) << std::endl;
    sqlite3_close(Db);
    exit(1);
  }
}

void SQLiteHelper::finalizeStatements() {
  sqlite3_finalize(UsnInsert);
  sqlite3_finalize(LogInsert);
  sqlite3_finalize(EventInsert);
  sqlite3_finalize(EventFinalInsert);
  sqlite3_finalize(EventUsnSelect);
  sqlite3_finalize(EventLogSelect);
}

const std::vector<std::vector<std::string>> SQLiteHelper::EventColumns = {
  { "Position", "int"},
  { "Timestamp", "text"},
  { "EventSource", "text"},
  { "EventType", "text"},
  { "FileName", "text"},
  { "Folder", "text"},
  { "FullPath", "text"},
  { "MFTRecord", "int"},
  { "ParentMFTRecord", "int"},
  { "USN_LSN", "int"},
  { "OldFileName", "text"},
  { "OldFolder", "text"},
  { "OldParentRecord", "int"},
  { "Offset", "int"},
  { "Created", "text"},
  { "Modified", "text"},
  { "Comment", "text"},
  { "Snapshot", "text"},
  { "Volume", "text"}
};

const std::vector<std::vector<std::string>> SQLiteHelper::EventTempColumns = {
  { "MFTRecord", "int"},
  { "ParentMFTRecord", "int"},
  { "OldParentRecord", "int"},
  { "USN_LSN", "int"},
  { "Timestamp", "text"},
  { "FileName", "text"},
  { "OldFileName", "text"},
  { "EventType", "int"},
  { "EventSource", "int"},
  { "IsEmbedded", "int"},
  { "Offset", "int"},
  { "Created", "text"},
  { "Modified", "text"},
  { "Comment", "text"},
  { "Snapshot", "text"},
  { "Volume", "text"}
};

const std::vector<std::vector<std::string>> SQLiteHelper::LogColumns = {
  { "CurrentLSN", "int"},
  { "PrevLSN", "int"},
  { "UndoLSN", "int"},
  { "ClientID", "int"},
  { "RecordType", "int"},
  { "RedoOP", "text"},
  { "UndoOP", "text"},
  { "TargetAttribute", "int"},
  { "MFTClusterIndex", "int"},
  { "Offset", "int"},
  { "Snapshot", "text"},
  { "Volume", "text"}
};

const std::vector<std::vector<std::string>> SQLiteHelper::UsnColumns = {
  { "MFTRecord", "int"},
  { "ParentMFTRecord", "int"},
  { "USN", "int"},
  { "Timestamp", "text"},
  { "Reason", "text"},
  { "FileName", "text"},
  { "FullPath", "text"},
  { "Folder", "text"},
  { "Offset", "int"},
  { "Snapshot", "text"},
  { "Volume", "text" }
};

```

`src/usn.cpp`:

```cpp
/*
 * ntfs-linker
 * Copyright 2015 Stroz Friedberg, LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the license, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * A copy of the GNU Lesser General Public License is available at
 * <http://www.gnu.org/licenses/>.
 *
 * You can contact Stroz Friedberg by electronic and paper mail as follows:
 *
 * Stroz Friedberg, LLC
 * 32 Avenue of the Americas
 * 4th Floor
 * New York, NY, 10013
 * info@strozfriedberg.com
 */

#include "util.h"
#include "progress.h"
#include "usn.h"

#include <cstring>
#include <memory>
#include <sqlite3.h>
#include <sstream>

/*
Returns the column names used for the Usn CSV file
*/
std::string getUSNColumnHeaders() {
  std::stringstream ss;
  ss << "MFT Record Number"    << "\t"
     << "Parent Record Number" << "\t"
     << "Usn"                  << "\t"
     << "Timestamp"            << "\t"
     << "Reason"               << "\t"
     << "Filename"             << "\t"
     << "Path"                 << "\t"
     << "Parent Path"          << "\t"
     << "File Offset"          << "\t"
     << "VSS Snapshot"         << "\t"
     << "File System Offset"            << std::endl;
  return ss.str();
}

/*
Decodes the Usn reason code
Usn uses a bit packing scheme to store reason codes.
Typically, as operations are performed on a file these reason codes are combined (|)
*/
std::string UsnRecord::getReasonString() {
  std::stringstream ss;
  ss << "USN";
  if (Reason & UsnReasons::USN_BASIC_INFO_CHANGE)         ss << "|BASIC_INFO_CHANGE";
  if (Reason & UsnReasons::USN_CLOSE)                     ss << "|CLOSE";
  if (Reason & UsnReasons::USN_COMPRESSION_CHANGE)        ss << "|COMPRESSION_CHANGE";
  if (Reason & UsnReasons::USN_DATA_EXTEND)               ss << "|DATA_EXTEND";
  if (Reason & UsnReasons::USN_DATA_OVERWRITE)            ss << "|DATA_OVERWRITE";
  if (Reason & UsnReasons::USN_DATA_TRUNCATION)           ss << "|DATA_TRUNCATION";
  if (Reason & UsnReasons::USN_EXTENDED_ATTRIBUTE_CHANGE) ss << "|EXTENDED_ATTRIBUTE_CHANGE";
  if (Reason & UsnReasons::USN_ENCRYPTION_CHANGE)         ss << "|ENCRYPTION_CHANGE";
  if (Reason & UsnReasons::USN_FILE_CREATE)               ss << "|FILE_CREATE";
  if (Reason & UsnReasons::USN_FILE_DELETE)               ss << "|FILE_DELETE";
  if (Reason & UsnReasons::USN_HARD_LINK_CHANGE)          ss << "|HARD_LINK_CHANGE";
  if (Reason & UsnReasons::USN_INDEXABLE_CHANGE)          ss << "|INDEXABLE_CHANGE";
  if (Reason & UsnReasons::USN_NAMED_DATA_EXTEND)         ss << "|NAMED_DATA_EXTEND";
  if (Reason & UsnReasons::USN_NAMED_DATA_OVERWRITE)      ss << "|NAMED_DATA_OVERWRITE";
  if (Reason & UsnReasons::USN_NAMED_DATA_TRUNCATION)     ss << "|NAMED_DATA_TRUNCATION";
  if (Reason & UsnReasons::USN_OBJECT_ID_CHANGE)          ss << "|OBJECT_ID_CHANGE";
  if (Reason & UsnReasons::USN_RENAME_NEW_NAME)           ss << "|RENAME_NEW_NAME";
  if (Reason & UsnReasons::USN_RENAME_OLD_NAME)           ss << "|RENAME_OLD_NAME";
  if (Reason & UsnReasons::USN_REPARSE_POINT_CHANGE)      ss << "|REPARSE_POINT_CHANGE";
  if (Reason & UsnReasons::USN_SECURITY_CHANGE)           ss << "|SECURITY_CHANGE";
  if (Reason & UsnReasons::USN_STREAM_CHANGE)             ss << "|STREAM_CHANGE";
  return ss.str();
}

std::streampos advanceStream(std::istream& stream, char* buffer, bool sparse) {
  /**
   * Handle sparse $J file.
   * Seeks to end, then advances backwards until an all zero block is found
   * Does NOT set the stream position to last all zero block, just somewhere near the end
   * Returns the streampos of the end
   */
  stream.clear();
  stream.seekg(0, std::ios::end);
  std::streampos end = stream.tellg();
  if (sparse) {
    bool done = false;
    while (!done) {
      stream.seekg(-(1 << 20), std::ios::cur);
      if (stream.fail()) {
        done = true;
        stream.clear();
        stream.seekg(0, std::ios::beg);
        stream.read(buffer, std::min(USN_BUFFER_SIZE, static_cast<unsigned int>(end - stream.tellg())));
      }
      else {
        stream.read(buffer, std::min(USN_BUFFER_SIZE, static_cast<unsigned int>(end - stream.tellg())));
        done = true;
        for (unsigned int i = 0; i < USN_BUFFER_SIZE && done; i++) {
          if (buffer[i] != 0)
            done = false;
        }
      }
    }
  }
  else {
    stream.seekg(0, std::ios::beg);
    stream.read(buffer, std::min(USN_BUFFER_SIZE, static_cast<unsigned int>(end - stream.tellg())));
  }
  return end;
}

/*
Parses all records found in the USN file represented by input. Uses the records map to recreate file paths
Outputs the results to several streams.
*/
void parseUSN(const std::vector<File>& records, SQLiteHelper& sqliteHelper, std::istream& input, std::ostream& output, const VersionInfo& version, bool extra) {
  std::unique_ptr<char[]> bufPtr(new char[USN_BUFFER_SIZE]);
  char* buffer = bufPtr.get();

  int records_processed = -1;

  std::streampos end = advanceStream(input, buffer, true);
  std::streampos start = input.tellg();
  ProgressBar status(end - start);

  UsnRecord prevRec(version);
  output << getUSNColumnHeaders();

  unsigned int offset = 0;
  unsigned int totalOffset = 0;
  uint64_t usn_offset = UINT64_MAX;

  //scan through the $USNJrnl one record at a time. Each record is variable length.
  bool done = false;
  while (!input.eof() && !done) {
    status.setDone((uint64_t) input.tellg() - USN_BUFFER_SIZE + offset - start);

    if (offset + 4 > USN_BUFFER_SIZE || hex_to_long(buffer + offset, 4) + offset > USN_BUFFER_SIZE) {
      // We've reached the end of the buffer. Move the record to the front,
      // then read to fill out the rest of the buffer
      memmove(buffer, buffer + offset, USN_BUFFER_SIZE - offset);
      input.read(buffer + USN_BUFFER_SIZE - offset, offset);
      totalOffset += offset;
      offset = 0;
    }

    uint64_t record_length = hex_to_long(buffer + offset, 4);

    if (record_length == 0) {
      offset += 8;
      continue;
    }
    if (record_length > USN_BUFFER_SIZE) {
      status.clear();
      std::cerr << "Encountered bad record at 0x"
                << std::hex << static_cast<int>(input.tellg()) - USN_BUFFER_SIZE + offset
                << " in snapshot: " << version.Snapshot << ".";
      int new_offset = recoverPosition(buffer, offset, usn_offset + (static_cast<int>(input.tellg()) - USN_BUFFER_SIZE + offset));
      if (new_offset >= 0) {
        std::cerr << " Recovery successful with 0x" << std::hex << new_offset - offset << " bytes skipped" << std::endl;
        offset = new_offset;
        continue;
      }
      else {
        // Try once to read another page, but no more
        input.read(buffer, USN_BUFFER_SIZE);
        totalOffset += USN_BUFFER_SIZE;
        offset = 0;
        int new_offset = recoverPosition(buffer, offset, usn_offset);
        if (new_offset >= 0) {
          std::cerr << " Recovery successful with 0x" << std::hex << new_offset - offset + USN_BUFFER_SIZE
                    << " bytes skipped" << std::endl;
          offset = new_offset;
          continue;
        }
        else {
          std::cerr << " Recovery failed. Cannot continue parsing this $UsnJrnl file." << std::endl;
          break;
        }
      }
    }
    records_processed++;

    UsnRecord rec(buffer + offset, offset + totalOffset, version);

    if (usn_offset == UINT64_MAX) {
      usn_offset = rec.Usn - (static_cast<int>(input.tellg()) - USN_BUFFER_SIZE + offset);
    }
    else if (usn_offset != rec.Usn - (static_cast<int>(input.tellg()) - USN_BUFFER_SIZE + offset) && !input.eof()) {
      std::cerr << "Inconsistent Usn value found at 0x" << std::hex << static_cast<int>(input.tellg()) - offset
                << " in snapshot << " << version.Snapshot
                << ". Update sequence number does not match the offset of the record in the file" << std::endl;
      usn_offset = rec.Usn - (static_cast<int>(input.tellg()) - USN_BUFFER_SIZE + offset);
    }

    if (extra) {
      output << rec.toString(records);
      rec.insert(sqliteHelper.UsnInsert, records);
    }

    if (prevRec.Record != rec.Record || prevRec.Reason & UsnReasons::USN_CLOSE) {
      prevRec.checkTypeAndInsert(sqliteHelper.EventInsert);
      prevRec.clearFields();
    }
    if (prevRec.Usn == 0)
      prevRec = rec;
    prevRec.update(rec);

    offset += record_length;
  }
  if (prevRec.Usn != 0) {
    prevRec.checkTypeAndInsert(sqliteHelper.EventInsert);
  }
  status.finish();
}

int recoverPosition(const char* buffer, unsigned int offset, unsigned int usn_offset) {
  // Look for the offset of the next valid USN record
  // In some instances, entire sectors are replaced with junk data
  // buffer is the current buffer, and offset is the offset within it
  // usn_offset is the offset of the _start_ of buffer in the $J stream, including the leading sparse section
  // Care should be taken that no reads are performed past buffer + USN_BUFFER_SIZE

  // The strategy is to read 8-byte longs until one is found whose value matches its own offset
  // That record may be invalid (with some of the first 0x18 bytes chopped off, so we return
  // the offset to the next record

  // Ensure offset is 8-byte aligned
  offset = 8 * ceilingDivide(offset, 8);
  bool found = false;
  while (offset < USN_BUFFER_SIZE) {
    uint64_t value = hex_to_long(buffer + offset, 8);
    if (value == offset + usn_offset - 0x18) {
     if (found)
        return offset - 0x18;
     found = true;
    }
    offset += 8;
  }
  return -1;
}

void UsnRecord::update(UsnRecord rec) {
    Reason |= rec.Reason;

    if (rec.Reason & UsnReasons::USN_RENAME_OLD_NAME) {
      PreviousName = rec.Name;
      PreviousParent = rec.Parent;
    }

    if (rec.Reason & UsnReasons::USN_RENAME_NEW_NAME) {
      Name = rec.Name;
      Parent = rec.Parent;
    }
}

UsnRecord::UsnRecord(const char* buffer, uint64_t fileOffset, const VersionInfo& version, int len, bool isEmbedded) :
  FileOffset(fileOffset),
  Snapshot(version.Snapshot),
  Volume(version.Volume),
  IsEmbedded(isEmbedded) {
  if (len < 0 || (unsigned) len >= 0x3C) {
    PreviousName                     = "";
    PreviousParent                   = -1;
    uint64_t record_length           = hex_to_long(buffer, 4);
    Record                           = hex_to_long(buffer + 0x8, 6);
    Reference                        = hex_to_long(buffer + 0x8, 8);
    Parent                           = hex_to_long(buffer + 0x10, 6);
    ParentReference                  = hex_to_long(buffer + 0x10, 8);
    Usn                              = hex_to_long(buffer + 0x18, 8);
    Timestamp                        = filetime_to_iso_8601(hex_to_long(buffer + 0x20, 8));
    Reason                           = hex_to_long(buffer + 0x28, 4);
    unsigned int name_len            = hex_to_long(buffer + 0x38, 2);
    unsigned int name_offset         = hex_to_long(buffer + 0x3A, 2);

    if (len < 0 || (unsigned) len >= record_length) {
      Name = mbcatos(buffer + name_offset, name_len);
      return;
    }
  }
  // Not a valid UsnRecord
  clearFields();
}

void UsnRecord::clearFields() {

  Name            = "";
  Reference       = 0;
  Record          = -1;
  ParentReference = 0;
  Parent          = -1;
  PreviousName    = "";
  PreviousParent  = -1;
  Reason          = 0;
  Timestamp       = "";
  Usn             = 0;
  FileOffset      = 0;
}

UsnRecord::UsnRecord(const VersionInfo& version, bool isEmbedded) : Snapshot(version.Snapshot), Volume(version.Volume), IsEmbedded(isEmbedded) {
  IsEmbedded = false;
  clearFields();
}

std::string UsnRecord::toString(const std::vector<File>& records) {
  std::stringstream ss;
  ss << Record                       << "\t"
     << Parent                       << "\t"
     << Usn                          << "\t"
     << Timestamp                    << "\t"
     << getReasonString()            << "\t"
     << Name                         << "\t"
     << getFullPath(records, Record) << "\t"
     << getFullPath(records, Parent) << "\t"
     << FileOffset                   << "\t"
     << Snapshot                     << "\t"
     << Volume                       << std::endl;
  return ss.str();
}

void UsnRecord::insertEvent(unsigned int type, sqlite3_stmt* stmt) {
  unsigned int i = 0;
  sqlite3_bind_int64(stmt, ++i, Record);
  sqlite3_bind_int64(stmt, ++i, Parent);
  sqlite3_bind_int64(stmt, ++i, PreviousParent);
  sqlite3_bind_int64(stmt, ++i, Usn);
  sqlite3_bind_text(stmt , ++i, Timestamp.c_str()   , -1, SQLITE_TRANSIENT);
  sqlite3_bind_text(stmt , ++i, Name.c_str()        , -1, SQLITE_TRANSIENT);
  sqlite3_bind_text(stmt , ++i, PreviousName.c_str(), -1, SQLITE_TRANSIENT);
  sqlite3_bind_int64(stmt, ++i, type);
  sqlite3_bind_int64(stmt, ++i, EventSources::SOURCE_USN);
  sqlite3_bind_int  (stmt, ++i, IsEmbedded);
  sqlite3_bind_int64(stmt, ++i, FileOffset);
  sqlite3_bind_text (stmt, ++i, "", -1, SQLITE_TRANSIENT);  // Created
  sqlite3_bind_text (stmt, ++i, "", -1, SQLITE_TRANSIENT);  // Modified
  sqlite3_bind_text (stmt, ++i, "", -1, SQLITE_TRANSIENT);  // Comment
  sqlite3_bind_text (stmt, ++i, Snapshot.c_str(), -1, SQLITE_TRANSIENT);
  sqlite3_bind_text (stmt, ++i, Volume.c_str(), -1, SQLITE_TRANSIENT);

  sqlite3_step(stmt);
  sqlite3_reset(stmt);
}

void UsnRecord::insert(sqlite3_stmt* stmt, const std::vector<File>& records) {
  unsigned int i = 0;
  sqlite3_bind_int64(stmt, ++i, Record);
  sqlite3_bind_int64(stmt, ++i, Parent);
  sqlite3_bind_int64(stmt, ++i, Usn);
  sqlite3_bind_text (stmt, ++i, Timestamp.c_str()                   , -1, SQLITE_TRANSIENT);
  sqlite3_bind_text (stmt, ++i, getReasonString().c_str()           , -1, SQLITE_TRANSIENT);
  sqlite3_bind_text (stmt, ++i, Name.c_str()                        , -1, SQLITE_TRANSIENT);
  sqlite3_bind_text (stmt, ++i, getFullPath(records, Record).c_str(), -1, SQLITE_TRANSIENT);
  sqlite3_bind_text (stmt, ++i, getFullPath(records, Parent).c_str(), -1, SQLITE_TRANSIENT);
  sqlite3_bind_int64(stmt, ++i, FileOffset);
  sqlite3_bind_text (stmt, ++i, Snapshot.c_str()                    , -1, SQLITE_TRANSIENT);
  sqlite3_bind_text (stmt, ++i, Volume.c_str()                      , -1, SQLITE_TRANSIENT);

  sqlite3_step(stmt);
  sqlite3_reset(stmt);
}

void UsnRecord::checkTypeAndInsert(sqlite3_stmt* stmt, bool strict) {
  if (Reason & UsnReasons::USN_FILE_CREATE)
    insertEvent(EventTypes::TYPE_CREATE, stmt);
  if (Reason & UsnReasons::USN_FILE_DELETE)
    insertEvent(EventTypes::TYPE_DELETE, stmt);
  if (PreviousName != Name
      && (Reason & (UsnReasons::USN_RENAME_NEW_NAME | UsnReasons::USN_RENAME_OLD_NAME))
      && (PreviousName != "" || !strict))
    insertEvent(EventTypes::TYPE_RENAME, stmt);
  if (Parent != PreviousParent
      && (Reason & (UsnReasons::USN_RENAME_NEW_NAME | UsnReasons::USN_RENAME_OLD_NAME))
      && (PreviousParent != -1 || !strict))
    insertEvent(EventTypes::TYPE_MOVE, stmt);
}

```

`src/util.cpp`:

```cpp
/*
 * ntfs-linker
 * Copyright 2015 Stroz Friedberg, LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the license, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * A copy of the GNU Lesser General Public License is available at
 * <http://www.gnu.org/licenses/>.
 *
 * You can contact Stroz Friedberg by electronic and paper mail as follows:
 *
 * Stroz Friedberg, LLC
 * 32 Avenue of the Americas
 * 4th Floor
 * New York, NY, 10013
 * info@strozfriedberg.com
 */

#include "file.h"
#include "unicode.h"
#include "util.h"

#include <algorithm>
#include <cstdint>
#include <cstring>
#include <ctime>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <memory>
#include <sstream>
#include <string>
#include <vector>

#include <tsk/libtsk.h>

/*
Returns the first SIZE bytes of the character array as a int64_t
If the result is too large to fit into a int64_t then overflow will occur
Reads the bytes as Little Endian
*/
uint64_t hex_to_long(const char* arr, int size) {
  uint64_t result = 0;
  for(int i = size - 1; i >= 0; i--) {
    result <<= 8;
    result +=  (unsigned char) arr[i];
  }
  return result;
}

/*
Converts filetime to unixtime
The filetime format is the number of 100 nanoseconds since 1601-01-01 (Assumed to be after the Gregorian Calendar cross-over date)
Unixtime is the number of seconds since 1970-01-01
*/
int64_t filetime_to_unixtime(int64_t t) {
  t -= 11644473600000ULL * 10000; //the number of 100 nano-seconds between 1601-01-01 and 1970-01-01
  t /= 10000000; //convert 100 nanoseconds to seconds
  return t;
}

std::wstring string_to_wstring(const std::string &str) {
  std::wstring temp(str.length(), L' ');
  copy(str.begin(), str.end(), temp.begin());
  return temp;
}

/*
Converts the filetime format used by microsoft windows files into ISO 8601 human-readable strings
The filetime format is the number of 100 nanoseconds since 1601-01-01 (Assumed to be after the Gregorian Calendar cross-over date)
Returned string format is YYYY-MM-DD HH:MM:SS 0000000 (nanoseconds)
*/
std::string filetime_to_iso_8601(uint64_t t) {
  int64_t unixtime = filetime_to_unixtime(t);
  if (unixtime > INT32_MAX) {
    return "";
  }
  time_t* time = (time_t*) &unixtime;
  struct tm* date = gmtime(time);

  char str[21];

  if (!strftime(str, 20, "%Y-%m-%d %H:%M:%S", date))
    return "";
  std::stringstream ss;
  ss << str << ".";
  ss << std::setw(7) << std::setfill('0') << (t % 10000000);
  return ss.str();
}

/*
Multi-byte character array to UTF8 string
Reads each 2 bytes of the charater array as a wide character and converts the UTF16 (??) result wstring to UTF8 string
Length of output string is len, reads len*2 bytes
*/
//std::string mbcatos(const char* arr, uint64_t len) {
//  std::vector<unsigned short> utf16;
//  for(unsigned int i = 0; i < len; i++) {
//    utf16.push_back(arr[2*i] + (arr[2*i+1]<<8));
//  }
//  std::string utf8;
//  try {
//    utf8::utf16to8(utf16.begin(), utf16.end(), std::back_inserter(utf8));
//  } catch(utf8::invalid_utf16& e) {
//    return "ERROR";
//  }
//  //delete any \t \r \n from utf8 string
//  char chars[] = "\t\r\n";
//  for(int i = 0; i < 3; i++)
//    utf8.erase(std::remove(utf8.begin(), utf8.end(), chars[i]), utf8.end());
//  return utf8;
//}

std::string mbcatos(const char* buf, uint64_t len) {
  std::unique_ptr<char[]> utf8(new char[2 * len]);
  char* utf8Buf = utf8.get();
  const char* end = buf + len;
  int32_t cp;
  while (buf < end) {
    int rtn;
    rtn = utf16_to_cp<true>(buf, end, cp);
    if (rtn == 0)
      return "ERROR";
    buf += rtn;
    rtn = cp_to_utf8(cp, utf8Buf);
    if (rtn == 0)
      return "ERROR";
    utf8Buf+= rtn;
  }
  return std::string(utf8.get(), utf8Buf);
}

/*
Uses the map of file records to construct the full file path.
If a file record is not present in the map then the empty stry "" is returned
*/
std::string getFullPath(const std::vector<File>& records, unsigned int record, std::vector<unsigned int>& stack) {
  std::stringstream ss;
  if (record >= records.size())
    return "";
  if (std::find(stack.begin(), stack.end(), record) != stack.end())
    return "CYCLICAL_HARD_LINK";
  File file(records[record]);
  if(record == file.Parent)
    return "";
  stack.push_back(record);
  ss << getFullPath(records, file.Parent, stack);
  ss << "\\" << file.Name;
  return ss.str();
}

std::string getFullPath(const std::vector<File>& records, unsigned int recordNo) {
  std::vector<unsigned int> stack;
  return getFullPath(records, recordNo, stack);
}

/*
prepares the ofstream for writing
opens the stream with whatever necessary flags, and writes any necessary start bits
*/
void prep_ofstream(std::ofstream& out, const std::string& name, bool overwrite) {
  std::ios_base::openmode mode = std::ios::out | std::ios::binary;
  if (overwrite)
    mode |= std::ios::trunc;
  else
    mode |= std::ios::app;

  out.open(name, mode);
//  unsigned char smarker[3];
//  smarker[0] = 0xEF;
//  smarker[1] = 0xBB;
//  smarker[2] = 0xBF;
//  out << smarker;
}

std::string toString(EventTypes e) {
  switch(e) {
    case EventTypes::TYPE_CREATE:
      return "Create";
    case EventTypes::TYPE_DELETE:
      return "Delete";
    case EventTypes::TYPE_MOVE:
      return "Move";
    default:
      return "Rename";
  }
}

std::string toString(EventSources e) {
  switch(e) {
    case EventSources::SOURCE_USN:
      return "$UsnJrnl/$J";
    case EventSources::SOURCE_LOG:
      return "$LogFile";
    case EventSources::SOURCE_EMBEDDED_USN:
      return "$UsnJrnl entry in $LogFile";
    default:
      return "N/A";
  }
}

std::ostream& operator<<(std::ostream& out, EventTypes e) {
  switch(e) {
    case EventTypes::TYPE_CREATE:
      return out << "Create";
    case EventTypes::TYPE_DELETE:
      return out << "Delete";
    case EventTypes::TYPE_MOVE:
      return out << "Move";
    default:
      return out << "Rename";
  }
}

std::ostream& operator<<(std::ostream& out, EventSources e) {
  switch(e) {
    case EventSources::SOURCE_USN:
      return out << "$UsnJrnl/$J";
    case EventSources::SOURCE_LOG:
      return out << "$LogFile";
    case EventSources::SOURCE_EMBEDDED_USN:
      return out << "$UsnJrnl entry in $LogFile";
    default:
      return out << "N/A";
  }
}

int doFixup(char* buffer, unsigned int len, unsigned int sectorSize) {
  // As a means of detecting sector corruption, NTFS replaces the last two bytes
  // of each sector with some magic, and stores the replaced bytes in the update
  // sequence array. Perform fixup on the buffer and return whether the sector
  // is corrupt. Only performs one record's worth of fixup, regardless of buffer
  // size, but ensures to not attempt to access outside the buffer.
  bool corrupt = false;
  if (len > 8) {
    unsigned int seqOffset = hex_to_long(buffer + 4, 2);
    unsigned int seqLen = hex_to_long(buffer + 6, 2);
    for(unsigned int i = 1; i < seqLen && 2*i + seqOffset < len && sectorSize * i <= len; i++) {
      unsigned int arrayOffset = seqOffset + 2*i;
      unsigned int dataOffset = sectorSize * i - 2;

      if (memcmp(buffer + dataOffset, buffer + seqOffset, 2) == 0) {
        // The magic number matches
        memcpy(buffer + dataOffset, buffer + arrayOffset, 2);
      }
      else {
        corrupt = true;
      }
    }
  }
  return corrupt;
}

std::string pluralize(std::string name, int n) {
  return std::to_string(n) + " " + name + (n != 1? "s" : "");
}

int ceilingDivide(int n, int m) {
  // Returns ceil(n/m), without using clunky FP arithmetic
  return (n + m - 1) / m;
}

```

`src/vss.cpp`:

```cpp
/*
 * ntfs-linker
 * Copyright 2015 Stroz Friedberg, LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the license, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * A copy of the GNU Lesser General Public License is available at
 * <http://www.gnu.org/licenses/>.
 *
 * You can contact Stroz Friedberg by electronic and paper mail as follows:
 *
 * Stroz Friedberg, LLC
 * 32 Avenue of the Americas
 * 4th Floor
 * New York, NY, 10013
 * info@strozfriedberg.com
 */

#include "vss.h"

#include <libbfio.h>
#include <libvshadow.h>
#include <tsk/libtsk.h>
#include <libcerror.h>

#include <cstring>
#include <sstream>
#include <iostream>

class VSSException : public std::exception {
  public:
    VSSException(libcerror_error_t* error) {
      char errStr[1024];
      std::ostringstream ss;
      libcerror_error_backtrace_sprint(error, errStr, 1024);
      ss << "VSS Exception: " << errStr;
      ErrStr = ss.str();
      libcerror_error_free(&error);
    }

    virtual const char* what() const throw() {
      return ErrStr.c_str();
    }

  private:
    std::string ErrStr;
};
// ==== TVB SHIM WRAPPER FUNCTIONS

TskVolumeBfioShim* getTvbShim(intptr_t *io_handle) {
  if (io_handle == NULL)
    return NULL;
  TskVolumeBfioShim* tvbShim = reinterpret_cast<TskVolumeBfioShim*>(io_handle);
  if (tvbShim->Tag != TVB_SHIM_TAG)
    return NULL;
  return tvbShim;
}

int tvb_shim_free_wrapper(intptr_t** io_handle, libbfio_error_t **error) {
  TskVolumeBfioShim* tvbShim;
  if (!(tvbShim = getTvbShim(*io_handle)))
    return -1;
  int rtnVal = tvbShim->free(error);
  if (rtnVal == -1)
    return -1;
  *io_handle = NULL;
  return rtnVal;
}

int tvb_shim_clone_wrapper(intptr_t **destination_io_handle, intptr_t *source_io_handle, libbfio_error_t **error) {
  TskVolumeBfioShim* tvbShim;
  if (!(tvbShim = getTvbShim(source_io_handle)))
    return -1;
  return tvbShim->clone(destination_io_handle, error);
}

int tvb_shim_open_wrapper(intptr_t *io_handle, int access_flags, libbfio_error_t **error) {
  TskVolumeBfioShim* tvbShim;
  if (!(tvbShim = getTvbShim(io_handle)))
    return -1;
  return tvbShim->open(access_flags, error);
}

int tvb_shim_close_wrapper(intptr_t *io_handle, libbfio_error_t **error) {
  TskVolumeBfioShim* tvbShim;
  if (!(tvbShim = getTvbShim(io_handle)))
    return -1;
  return tvbShim->close(error);
}

ssize_t tvb_shim_read_wrapper(intptr_t *io_handle, uint8_t *buffer, size_t size, libbfio_error_t **error) {
  TskVolumeBfioShim* tvbShim;
  if (!(tvbShim = getTvbShim(io_handle)))
    return -1;
  return tvbShim->read(buffer, size, error);
}

ssize_t tvb_shim_write_wrapper(intptr_t *io_handle, const uint8_t *buffer, size_t size, libbfio_error_t **error) {
  TskVolumeBfioShim* tvbShim;
  if (!(tvbShim = getTvbShim(io_handle)))
    return -1;
  return tvbShim->write(buffer, size, error);
}

off64_t tvb_shim_seek_offset_wrapper(intptr_t *io_handle, off64_t offset, int whence, libbfio_error_t **error) {
  TskVolumeBfioShim* tvbShim;
  if (!(tvbShim = getTvbShim(io_handle)))
    return -1;
  return tvbShim->seek_offset(offset, whence, error);
}

int tvb_shim_exists_wrapper(intptr_t *io_handle, libbfio_error_t **error) {
  TskVolumeBfioShim* tvbShim;
  if (!(tvbShim = getTvbShim(io_handle)))
    return -1;
  return tvbShim->exists(error);
}

int tvb_shim_is_open_wrapper(intptr_t *io_handle, libbfio_error_t **error) {
  TskVolumeBfioShim* tvbShim;
  if (!(tvbShim = getTvbShim(io_handle)))
    return -1;
  return tvbShim->is_open(error);
}

int tvb_shim_get_size_wrapper(intptr_t *io_handle, size64_t *size, libbfio_error_t **error) {
  TskVolumeBfioShim* tvbShim;
  if (!(tvbShim = getTvbShim(io_handle)))
    return -1;
  return tvbShim->get_size(size, error);
}

// VSTV SHIM WRAPPER FUNCTIONS

VShadowTskVolumeShim* getVstvShim(TSK_IMG_INFO* img_info) {
  if (img_info == NULL)
    return NULL;
  IMG_VSS_INFO* vss_info = reinterpret_cast<IMG_VSS_INFO*>(img_info);
  if (vss_info->Tag != IMG_VSS_INFO_TAG)
    return NULL;
  return vss_info->VstvShim.get();
}

void vstv_shim_close(TSK_IMG_INFO* img) {
  VShadowTskVolumeShim* vstvShim;
  if (!(vstvShim = getVstvShim(img)))
    return;
  return vstvShim->close();
}

void vstv_shim_imgstat(TSK_IMG_INFO* img, FILE* file) {
  VShadowTskVolumeShim* vstvShim;
  if (!(vstvShim = getVstvShim(img)))
    return;
  return vstvShim->imgstat(file);
}

ssize_t vstv_shim_read(TSK_IMG_INFO *img, TSK_OFF_T off, char* buf, size_t len) {
  VShadowTskVolumeShim* vstvShim;
  if (!(vstvShim = getVstvShim(img)))
    return -1;
  return vstvShim->read(off, buf, len);
}

int TskVolumeBfioShim::free(libbfio_error_t ** error) {
  (void)error;
  return 1;
}

int TskVolumeBfioShim::clone(intptr_t **destination_io_handle, libbfio_error_t **error) {
  (void)destination_io_handle;
  (void)error;
  return -1;
}

int TskVolumeBfioShim::open(int access_flags, libbfio_error_t ** error) {
  (void)error;
  (void)access_flags;
  return 1;
}

int TskVolumeBfioShim::close(libbfio_error_t ** error) {
  (void)error;
  return 0;
}

ssize_t TskVolumeBfioShim::read(uint8_t *buffer, size_t size, libbfio_error_t **error) {
  (void)error;
  ssize_t rtnVal = tsk_img_read(Fs->img_info, Fs->offset + Offset, reinterpret_cast<char*>(buffer), size);
  if (rtnVal == -1) {
    std::cerr << "TSK error: tsk_img_read: " <<tsk_error_get() << "at " << __FILE__ << ":" << __LINE__ << std::endl;
    return -1;
  }
  Offset += rtnVal;
  return rtnVal;
}

ssize_t TskVolumeBfioShim::write(const uint8_t *buffer, size_t size, libbfio_error_t **error) {
  (void)buffer;
  (void)size;
  (void)error;
  return -1;
}

off64_t TskVolumeBfioShim::seek_offset(off64_t offset, int whence, libbfio_error_t **error) {
  (void)error;
  switch(whence) {
    case 0:
      Offset = offset;
      break;
    case 1:
      Offset += offset;
      break;
    case 2:
      Offset = Size + offset;
      break;
    default:
      std::cerr << "Invalid argument to seek" << std::endl;
      return -1;
  }

  return Offset;
}

int TskVolumeBfioShim::exists(libbfio_error_t ** error) {
  (void)error;
  return 1;
}

int TskVolumeBfioShim::is_open(libbfio_error_t ** error) {
  (void)error;
  return 1;
}


int TskVolumeBfioShim::get_size(size64_t *size, libbfio_error_t ** error) {
  (void)error;
  *size = Size;
  return 1;
}

TskVolumeBfioShim::TskVolumeBfioShim(const TSK_FS_INFO* fs) : Tag(TVB_SHIM_TAG), Fs(fs) {
  Size = Fs->block_count * Fs->block_size;
}

ssize_t VShadowTskVolumeShim::read(TSK_OFF_T off, char* buf, size_t len) {
  libcerror_error_t* error = NULL;
  ssize_t rtnVal = libvshadow_store_read_buffer_at_offset(Store, buf, len, off, &error);
  if (rtnVal == -1) {
    throw VSSException(error);
  }
  return rtnVal;
}

TSK_FS_INFO* VShadowTskVolumeShim::getTskFsInfo(TSK_IMG_INFO* img) {
  memset(img, 0, sizeof(TSK_IMG_INFO));
  img->close = &vstv_shim_close;
  img->imgstat = &vstv_shim_imgstat;
  img->itype = TSK_IMG_TYPE_EXTERNAL;
  img->page_size = 2048;
  img->read = &vstv_shim_read;
  img->sector_size = 512;
  libvshadow_store_get_size(Store, reinterpret_cast<size64_t*>(&img->size), NULL);
  img->spare_size = 64;
  img->tag = TSK_IMG_INFO_TAG;

  TSK_FS_INFO* fs = tsk_fs_open_img(img, 0, TSK_FS_TYPE_NTFS);
  if (!fs) {
    std::cerr << "TSK error at " << __FILE__ << ":" << __LINE__ << ": "
              << tsk_error_get() << std::endl;
  }
  return fs;

}

VSS::VSS(TSK_FS_INFO* fs) : Handle(NULL), Volume(NULL), NumStores(0),  Store(NULL), VssFs(NULL) {
  int rtnVal;
  libcerror_error_t* error = NULL;
  TvbShim = TskVolumeBfioShimPtr(new TskVolumeBfioShim(fs));

  rtnVal = libbfio_handle_initialize(&Handle,
                                     reinterpret_cast<intptr_t*>(TvbShim.get()),
                                     &tvb_shim_free_wrapper,
                                     &tvb_shim_clone_wrapper,
                                     &tvb_shim_open_wrapper,
                                     &tvb_shim_close_wrapper,
                                     &tvb_shim_read_wrapper,
                                     &tvb_shim_write_wrapper,
                                     &tvb_shim_seek_offset_wrapper,
                                     &tvb_shim_exists_wrapper,
                                     &tvb_shim_is_open_wrapper,
                                     &tvb_shim_get_size_wrapper,
                                     LIBBFIO_FLAG_IO_HANDLE_NON_MANAGED,
                                     &error);
  if (rtnVal != 1) {
    throw VSSException(error);
  }

  rtnVal = libvshadow_volume_initialize(&Volume, &error);
  if (rtnVal != 1) {
    throw VSSException(error);
  }

  rtnVal = libvshadow_volume_open_file_io_handle(Volume, Handle, LIBVSHADOW_ACCESS_FLAG_READ, &error);
  if (rtnVal != 1) {
    throw VSSException(error);
  }
  rtnVal = libvshadow_volume_get_number_of_stores(Volume, &NumStores, &error);
  if (rtnVal != 1) {
    throw VSSException(error);
  }
}

TSK_FS_INFO* VSS::getSnapshot(uint8_t n) {
  int rtnVal;
  freeSnapshot();
  libcerror_error_t* error = NULL;

  rtnVal = libvshadow_volume_get_store(Volume, n, &Store, &error);
  if (rtnVal != 1) {
    throw VSSException(error);
  }

  VssInfo = ImgVssInfoPtr(new IMG_VSS_INFO);
  VssInfo->VstvShim = VShadowTskVolumeShimPtr(new VShadowTskVolumeShim(Store));
  VssFs = VssInfo->VstvShim->getTskFsInfo(&VssInfo->img_info);
  return VssFs;
}

void VSS::freeSnapshot() {
  int rtnVal;

  if (VssFs) {
    tsk_fs_close(VssFs);
    VssFs = NULL;
  }

  if (VssInfo) {
    tsk_img_close(&VssInfo->img_info);
    VssInfo = NULL;
  }

  if (Store) {
    libcerror_error_t* error = NULL;
    rtnVal = libvshadow_store_free(&Store, &error);
    if (rtnVal != 1)
      throw VSSException(error);
  }
}

VSS::~VSS() {
  int rtnVal;
  freeSnapshot();
  if (Volume) {
    libcerror_error_t* error = NULL;
    rtnVal = libvshadow_volume_free(&Volume, &error);
    if (rtnVal != 1)
      throw VSSException(error);
  }
  if (Handle) {
    libcerror_error_t* error = NULL;
    rtnVal = libbfio_handle_free(&Handle, &error);
    if (rtnVal != 1)
      throw VSSException(error);
  }
}

int VSS::getNumStores() {
  return NumStores;
}

```

`src/walkers.cpp`:

```cpp
/*
 * ntfs-linker
 * Copyright 2015 Stroz Friedberg, LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the license, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * A copy of the GNU Lesser General Public License is available at
 * <http://www.gnu.org/licenses/>.
 *
 * You can contact Stroz Friedberg by electronic and paper mail as follows:
 *
 * Stroz Friedberg, LLC
 * 32 Avenue of the Americas
 * 4th Floor
 * New York, NY, 10013
 * info@strozfriedberg.com
 */

#include "walkers.h"
#include "util.h"
#include "vss.h"

#include <fstream>
#include <string>
#include <iostream>
#include <iomanip>
#include <sstream>

#include <boost/filesystem.hpp>

namespace fs = boost::filesystem;


struct FileCopy{

  FileCopy(std::string in, std::string attr, std::string out) : In(in), Attr(attr), Out(out), File(NULL) {}

  std::string In, Attr, Out;
  TSK_FS_FILE* File;
};

int write_file(FileCopy& param) {
  TSK_FS_FILE* file = param.File;
  uint16_t id = 0;
  TSK_FS_ATTR_TYPE_ENUM type = TSK_FS_ATTR_TYPE_NOT_FOUND;
  TSK_OFF_T offset = 0;
  bool ads = false;
  if (!param.Attr.empty()) {
    if (!(file && file->meta && file->meta->attr && file->meta->attr->head))
      return 1;
    TSK_FS_ATTR* attr = file->meta->attr->head;
    while (attr != NULL) {
      if (attr->name && std::string(attr->name) == param.Attr) {
        id = attr->id;
        type = attr->type;
        ads = true;

        // Get the offset of the start of the second attribute run, if the _first_ run is sparse
        if (attr->nrd.run && (attr->nrd.run->flags & TSK_FS_ATTR_RUN_FLAG_SPARSE) && attr->nrd.run->next) {
          offset = attr->nrd.run->next->offset * file->fs_info->block_size;
        }
        break;
      }
      attr = attr->next;
    }
    if (!ads)
      return 1;
  }

  std::ofstream out(param.Out, std::ios::out | std::ios::binary | std::ios::trunc);
  const size_t buffer_size = 1048576;
  std::unique_ptr<char[]> buffer(new char[buffer_size]);
  while (1) {
    ssize_t bytesRead;
    if (ads) {
      bytesRead = tsk_fs_file_read_type(file, type, id, offset, buffer.get(), buffer_size, TSK_FS_FILE_READ_FLAG_NONE);
    }
    else {
      bytesRead = tsk_fs_file_read(file, offset, buffer.get(), buffer_size, TSK_FS_FILE_READ_FLAG_NONE);
    }
    if (bytesRead == -1)
      break;
    out.write(buffer.get(), bytesRead);
    offset += bytesRead;
  }
  out.close();
  return 0;
}

int copyFiles(TSK_FS_INFO* fs, fs::path dir) {
  std::vector<FileCopy> params { FileCopy("/$MFT", "", (dir / fs::path("$MFT")).string()),
                                FileCopy("/$LogFile", "", (dir / fs::path("$LogFile")).string()),
                                FileCopy("/$Extend/$UsnJrnl", "$J", (dir / fs::path("$J")).string())};
  bool hasAll = true;
  for (auto& param: params) {
    param.File = tsk_fs_file_open(fs, NULL, param.In.c_str());
    if (!param.File) {
      hasAll = false;
      std::cerr << "TSK error when opening file: " << param.In << ": " << tsk_error_get() << std::endl;
      break;
    }
  }

  if (!hasAll) {
    for (auto& param: params) {
      if (param.File) {
        tsk_fs_file_close(param.File);
      }
    }
    return 1;
  }

  fs::create_directories(dir);
  for(auto& param: params) {
      if (write_file(param)) {
        std::cerr << param.In << param.Attr << " file present, but we failed to copy it." << std::endl;
        return 1;
      }
      tsk_fs_file_close(param.File);
  }
  return 0;
}

std::string zeroPad(int i, int n) {
  int width = std::to_string(n).size();
  std::stringstream ss;
  ss << std::setfill('0') << std::setw(width) << i;
  return ss.str();
}

TSK_FILTER_ENUM VolumeWalker::filterFs(TSK_FS_INFO* fs) {
  NumCopied[fs->offset] = 0;
  if (!TSK_FS_TYPE_ISNTFS(fs->ftype)) {
    std::cout << "Skipping volume with fs offset " << fs->offset << " since it is not NTFS." << std::endl;
    return TSK_FILTER_SKIP;
  }

  fs::path dir(Root / ("volume_" + std::to_string(fs->offset)));
  std::cout << "Copying from volume " << fs->offset << ", base." << std::endl;

  // "base" has the important property that it sorts after numbers
  int rtnVal = copyFiles(fs, dir / fs::path("vss_base"));

  if (rtnVal) {
    std::cerr << "Unable to copy files out of volume with fs offset " << fs->offset << ". Skipping" << std::endl;
    return TSK_FILTER_SKIP;
  }
  NumCopied[fs->offset]++;
  DidItWork = true;

  try {
    VSS vShadowVolume(fs);
    int n = vShadowVolume.getNumStores();
    for(int i = 0; i < n; ++i) {
      std::cout << "Copying from volume " << fs->offset << ", VSC store " << i << "." << std::endl;
      TSK_FS_INFO* snapshot = vShadowVolume.getSnapshot(i);
      int rtnVal = copyFiles(snapshot, dir / fs::path("vss_" + zeroPad(i, n)));
      if (!rtnVal)
        NumCopied[fs->offset]++;
    }
  }
  catch(std::exception& err) {
    std::cerr << "=====================================================" << std::endl;
    std::cerr << "Could not read Volume Shadows from fs: " << fs->offset << ". Error: " << std::endl;
    std::cerr << err.what() << std::endl;
    std::cerr << "=====================================================" << std::endl;
    return TSK_FILTER_SKIP;
  }
  return TSK_FILTER_SKIP;
}

uint8_t VolumeWalker::openImageUtf8(int a_numImg, const char *const a_images[], TSK_IMG_TYPE_ENUM a_imgType, unsigned int a_sSize) {
  uint8_t rtnVal = TskAuto::openImageUtf8(a_numImg, a_images, a_imgType, a_sSize);
  if (rtnVal) {
    std::cerr << "TSK Error opening image." << std::endl;
    std::cerr << tsk_error_get() << std::endl;
    std::cerr << "Stopping." << std::endl;
    exit(1);
  }
  return rtnVal;
}

std::string VolumeWalker::getSummary() {
  std::ostringstream ss;
  int sum = 0;
  int count = 0;
  for (auto const& mapEntry: NumCopied) {
    sum += mapEntry.second;
    ss << "Volume " << mapEntry.first << ": ";
    if (mapEntry.second) {
      ss << "copied from " << pluralize("snapshot", mapEntry.second) << "\n";
      ++count;
    }
    else {
      ss << "no files were copied\n";
    }
  }
  ss << "Total: copied " << pluralize("volume", count) << ", "
     << pluralize("snapshot", sum) << ".";
  return ss.str();
}

```

`test/test.cpp`:

```cpp
#include <scope/testrunner.h>

#include <iostream>

int main(int argc, char** argv) {
  return scope::DefaultRun(std::cout, argc, argv) ? 0: -1;
}

```

`test/test_usn.cpp`:

```cpp
#include <scope/test.h>

#include "usn.h"
#include <sstream>

void advanceStream(bool runSparse, bool isSparse) {
  std::stringstream ss;
  static char buffer[USN_BUFFER_SIZE];

  for(unsigned int i = 0; i < 10 * USN_BUFFER_SIZE && isSparse; i++) {
    ss << "\x0000";
  }
  for(unsigned int i = 0; i < 13; i++) {
    ss << "\x00FF";
  }
  advanceStream(ss, buffer, runSparse);
  SCOPE_ASSERT(ss.good());
  SCOPE_ASSERT(!ss.fail());
  SCOPE_ASSERT(ss.tellg() <= 10 * USN_BUFFER_SIZE);
}

SCOPE_TEST(testAdvancing) {
  for(int i = 0; i < 4; i++)
    advanceStream(i&1, i&2);
}

```

`test/test_util.cpp`:

```cpp
#include <scope/test.h>
#include <cstring>

#include "util.h"

SCOPE_TEST(testUnpack) {
  SCOPE_ASSERT_EQUAL(16, hex_to_long("\x0010\x0000\x0000\x0000", 4));
  SCOPE_ASSERT_EQUAL(255, hex_to_long("\x00FF\x0000\x0000\x0000", 4));
}

SCOPE_TEST(testFixup) {
  static char buffer[4096];
  memset(buffer, 0, 4096);
  buffer[4] = 0x10;
  buffer[6] = 0x9;
  buffer[0x10] = 0x7F;
  buffer[0x11] = 0x7F;
  for (int i = 0; i < 4096; i += 512) {
    buffer[i+510] = 0x7F;
    buffer[i + 511] = 0x7F;
  }

  SCOPE_ASSERT_EQUAL(false, doFixup(buffer, 4096));

  for (int i = 0x22; i < 4096; i++) {
    SCOPE_ASSERT_EQUAL(0, buffer[i]);
  }
}

```