Project Path: arc_gmh5225_HIGU_ntcall_ydvv0suo

Source Tree:

```txt
arc_gmh5225_HIGU_ntcall_ydvv0suo
├── HIGU_ntcall.sln
├── THIRD_PARTY_LICENSE.txt
├── phnt
│   ├── ntbcd.h
│   ├── ntd3dkmt.h
│   ├── ntdbg.h
│   ├── ntexapi.h
│   ├── ntgdi.h
│   ├── ntioapi.h
│   ├── ntkeapi.h
│   ├── ntldr.h
│   ├── ntlpcapi.h
│   ├── ntmisc.h
│   ├── ntmmapi.h
│   ├── ntnls.h
│   ├── ntobapi.h
│   ├── ntpebteb.h
│   ├── ntpfapi.h
│   ├── ntpnpapi.h
│   ├── ntpoapi.h
│   ├── ntpsapi.h
│   ├── ntregapi.h
│   ├── ntrtl.h
│   ├── ntsam.h
│   ├── ntseapi.h
│   ├── ntsmss.h
│   ├── nttmapi.h
│   ├── nttp.h
│   ├── ntwow64.h
│   ├── ntxcapi.h
│   ├── ntzwapi.h
│   ├── phnt.h
│   ├── phnt_ntdef.h
│   ├── phnt_windows.h
│   ├── subprocesstag.h
│   └── winsta.h
├── readme.md
└── src
    ├── HIGU_ntcall
    │   ├── HIGU_ntcall.vcxproj
    │   ├── HIGU_ntcall.vcxproj.filters
    │   ├── cleancall
    │   │   ├── cleancall.cpp
    │   │   ├── cleancall.h
    │   │   ├── impl_cleancall_32.asm
    │   │   └── impl_cleancall_64.asm
    │   ├── higu_ntcall.h
    │   ├── ntdll_3264_thunks.h
    │   ├── ntdll_functions.cpp
    │   ├── ntdll_functions.h
    │   ├── pch.cpp
    │   ├── pch.h
    │   ├── syscall_table.cpp
    │   ├── syscall_table.h
    │   ├── syscall_table_initialize.cpp
    │   └── syscall_table_initialize.h
    ├── HIGU_ntcall_3264
    │   ├── HIGU_ntcall_3264.vcxproj
    │   ├── HIGU_ntcall_3264.vcxproj.filters
    │   ├── impl_syscall.asm
    │   ├── ntcall3264.cpp
    │   ├── ntcall_stuff.h
    │   ├── thunk64_convertors32to64.h
    │   ├── thunk64_convertors64to32.h
    │   ├── thunk64_functions.h
    │   └── thunk64_structures32.h
    ├── object_cvt64to32
    │   ├── object_cvt64to32.cpp
    │   ├── object_cvt64to32.vcxproj
    │   └── object_cvt64to32.vcxproj.filters
    └── test_app
        ├── test_app.cpp
        ├── test_app.map
        ├── test_app.vcxproj
        └── test_app.vcxproj.filters

```

`HIGU_ntcall.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31129.286
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "HIGU_ntcall", "src\HIGU_ntcall\HIGU_ntcall.vcxproj", "{933FCDD7-35EC-4902-BC6B-C19044C493CE}"
	ProjectSection(ProjectDependencies) = postProject
		{57798E33-0084-4F84-810D-E5E81B527464} = {57798E33-0084-4F84-810D-E5E81B527464}
		{AAA725B6-1AF9-45DD-BAB4-EBF15A6DB5E7} = {AAA725B6-1AF9-45DD-BAB4-EBF15A6DB5E7}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "object_cvt64to32", "src\object_cvt64to32\object_cvt64to32.vcxproj", "{AAA725B6-1AF9-45DD-BAB4-EBF15A6DB5E7}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "test_app", "src\test_app\test_app.vcxproj", "{D3BB02A9-0655-4FC0-8CC3-711CEB494619}"
	ProjectSection(ProjectDependencies) = postProject
		{933FCDD7-35EC-4902-BC6B-C19044C493CE} = {933FCDD7-35EC-4902-BC6B-C19044C493CE}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "HIGU_ntcall_3264", "src\HIGU_ntcall_3264\HIGU_ntcall_3264.vcxproj", "{57798E33-0084-4F84-810D-E5E81B527464}"
	ProjectSection(ProjectDependencies) = postProject
		{AAA725B6-1AF9-45DD-BAB4-EBF15A6DB5E7} = {AAA725B6-1AF9-45DD-BAB4-EBF15A6DB5E7}
	EndProjectSection
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "custom wow64", "custom wow64", "{DF0E3690-E61F-4DBE-91F9-27424F46C73D}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{933FCDD7-35EC-4902-BC6B-C19044C493CE}.Debug|x64.ActiveCfg = Debug|x64
		{933FCDD7-35EC-4902-BC6B-C19044C493CE}.Debug|x64.Build.0 = Debug|x64
		{933FCDD7-35EC-4902-BC6B-C19044C493CE}.Debug|x86.ActiveCfg = Debug|Win32
		{933FCDD7-35EC-4902-BC6B-C19044C493CE}.Debug|x86.Build.0 = Debug|Win32
		{933FCDD7-35EC-4902-BC6B-C19044C493CE}.Release|x64.ActiveCfg = Release|x64
		{933FCDD7-35EC-4902-BC6B-C19044C493CE}.Release|x64.Build.0 = Release|x64
		{933FCDD7-35EC-4902-BC6B-C19044C493CE}.Release|x86.ActiveCfg = Release|Win32
		{933FCDD7-35EC-4902-BC6B-C19044C493CE}.Release|x86.Build.0 = Release|Win32
		{AAA725B6-1AF9-45DD-BAB4-EBF15A6DB5E7}.Debug|x64.ActiveCfg = Debug|x64
		{AAA725B6-1AF9-45DD-BAB4-EBF15A6DB5E7}.Debug|x64.Build.0 = Debug|x64
		{AAA725B6-1AF9-45DD-BAB4-EBF15A6DB5E7}.Debug|x86.ActiveCfg = Debug|x64
		{AAA725B6-1AF9-45DD-BAB4-EBF15A6DB5E7}.Release|x64.ActiveCfg = Release|x64
		{AAA725B6-1AF9-45DD-BAB4-EBF15A6DB5E7}.Release|x86.ActiveCfg = Release|x64
		{AAA725B6-1AF9-45DD-BAB4-EBF15A6DB5E7}.Release|x86.Build.0 = Release|x64
		{D3BB02A9-0655-4FC0-8CC3-711CEB494619}.Debug|x64.ActiveCfg = Debug|x64
		{D3BB02A9-0655-4FC0-8CC3-711CEB494619}.Debug|x64.Build.0 = Debug|x64
		{D3BB02A9-0655-4FC0-8CC3-711CEB494619}.Debug|x86.ActiveCfg = Debug|Win32
		{D3BB02A9-0655-4FC0-8CC3-711CEB494619}.Debug|x86.Build.0 = Debug|Win32
		{D3BB02A9-0655-4FC0-8CC3-711CEB494619}.Release|x64.ActiveCfg = Release|x64
		{D3BB02A9-0655-4FC0-8CC3-711CEB494619}.Release|x64.Build.0 = Release|x64
		{D3BB02A9-0655-4FC0-8CC3-711CEB494619}.Release|x86.ActiveCfg = Release|Win32
		{D3BB02A9-0655-4FC0-8CC3-711CEB494619}.Release|x86.Build.0 = Release|Win32
		{57798E33-0084-4F84-810D-E5E81B527464}.Debug|x64.ActiveCfg = Debug|x64
		{57798E33-0084-4F84-810D-E5E81B527464}.Debug|x64.Build.0 = Debug|x64
		{57798E33-0084-4F84-810D-E5E81B527464}.Debug|x86.ActiveCfg = Debug|x64
		{57798E33-0084-4F84-810D-E5E81B527464}.Debug|x86.Build.0 = Debug|x64
		{57798E33-0084-4F84-810D-E5E81B527464}.Release|x64.ActiveCfg = Release|x64
		{57798E33-0084-4F84-810D-E5E81B527464}.Release|x86.ActiveCfg = Release|x64
		{57798E33-0084-4F84-810D-E5E81B527464}.Release|x86.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{AAA725B6-1AF9-45DD-BAB4-EBF15A6DB5E7} = {DF0E3690-E61F-4DBE-91F9-27424F46C73D}
		{57798E33-0084-4F84-810D-E5E81B527464} = {DF0E3690-E61F-4DBE-91F9-27424F46C73D}
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {1CF01BDA-4442-45E3-9516-EED7B625AD17}
	EndGlobalSection
EndGlobal

```

`THIRD_PARTY_LICENSE.txt`:

```txt
Process Hacker is distributed under the GNU GPL version 3, with the
following exception:

    Permission is granted to dynamically (but not statically) link this
    program with independent modules, regardless of the license terms of
    these independent modules, provided that this program is not modified
    in any way. An independent module is a module which is not derived
    from or based on this program. If you modify this program, this
    additional permission no longer applies unless authorized by the
    copyright holders.

                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<http://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<http://www.gnu.org/philosophy/why-not-lgpl.html>.
```

`phnt/ntbcd.h`:

```h
/*
 * Process Hacker -
 *   Boot Configuration Data (BCD) support functions
 *
 * This file is part of Process Hacker.
 *
 * Process Hacker is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Process Hacker is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Process Hacker.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef _NTBCD_H
#define _NTBCD_H

#ifndef PHNT_INLINE_BCD_GUIDS
// 5189B25C-5558-4BF2-BCA4-289B11BD29E2 // {badmemory}
GUID DECLSPEC_SELECTANY GUID_BAD_MEMORY_GROUP = { 0x5189B25C, 0x5558, 0x4BF2, { 0xBC, 0xA4, 0x28, 0x9B, 0x11, 0xBD, 0x29, 0xE2 } };
// 6EFB52BF-1766-41DB-A6B3-0EE5EFF72BD7 // {bootloadersettings}
GUID DECLSPEC_SELECTANY GUID_BOOT_LOADER_SETTINGS_GROUP = { 0x6EFB52BF, 0x1766, 0x41DB, { 0xA6, 0xB3, 0x0E, 0xE5, 0xEF, 0xF7, 0x2B, 0xD7 } };
// FA926493-6F1C-4193-A414-58F0B2456D1E // {current}
GUID DECLSPEC_SELECTANY GUID_CURRENT_BOOT_ENTRY = { 0xFA926493, 0x6F1C, 0x4193, { 0xA4, 0x14, 0x58, 0xF0, 0xB2, 0x45, 0x6D, 0x1E } };
// 4636856E-540F-4170-A130-A84776F4C654 // {eventsettings} {dbgsettings}
GUID DECLSPEC_SELECTANY GUID_DEBUGGER_SETTINGS_GROUP = { 0x4636856E, 0x540F, 0x4170, { 0xA1, 0x30, 0xA8, 0x47, 0x76, 0xF4, 0xC6, 0x54 } };
// 1CAE1EB7-A0DF-4D4D-9851-4860E34EF535 // {default}
GUID DECLSPEC_SELECTANY GUID_DEFAULT_BOOT_ENTRY = { 0x1CAE1EB7, 0xA0DF, 0x4D4D, { 0x98, 0x51, 0x48, 0x60, 0xE3, 0x4E, 0xF5, 0x35 } };
// 0CE4991B-E6B3-4B16-B23C-5E0D9250E5D9 // {emssettings}
GUID DECLSPEC_SELECTANY GUID_EMS_SETTINGS_GROUP = { 0x0CE4991B, 0xE6B3, 0x4B16, { 0xB2, 0x3C, 0x5E, 0x0D, 0x92, 0x50, 0xE5, 0xD9 } };
// A5A30FA2-3D06-4E9F-B5F4-A01DF9D1FCBA // {fwbootmgr}
GUID DECLSPEC_SELECTANY GUID_FIRMWARE_BOOTMGR = { 0xA5A30FA2, 0x3D06, 0x4E9F, { 0xB5, 0xF4, 0xA0, 0x1D, 0xF9, 0xD1, 0xFC, 0xBA } };
// 7EA2E1AC-2E61-4728-AAA3-896D9D0A9F0E // {globalsettings}
GUID DECLSPEC_SELECTANY GUID_GLOBAL_SETTINGS_GROUP = { 0x7EA2E1AC, 0x2E61, 0x4728, { 0xAA, 0xA3, 0x89, 0x6D, 0x9D, 0x0A, 0x9F, 0x0E } };
// 7FF607E0-4395-11DB-B0DE-0800200C9A66 // {hypervisorsettings}
GUID DECLSPEC_SELECTANY GUID_HYPERVISOR_SETTINGS_GROUP = { 0x7FF607E0, 0x4395, 0x11DB, { 0xB0, 0xDE, 0x08, 0x00, 0x20, 0x0C, 0x9A, 0x66 } };
// 313E8EED-7098-4586-A9BF-309C61F8D449 // {kerneldbgsettings}
GUID DECLSPEC_SELECTANY GUID_KERNEL_DEBUGGER_SETTINGS_GROUP = { 0x313E8EED, 0x7098, 0x4586, { 0xA9, 0xBF, 0x30, 0x9C, 0x61, 0xF8, 0xD4, 0x49 } };
// 1AFA9C49-16AB-4A5C-4A90-212802DA9460 // {resumeloadersettings}
GUID DECLSPEC_SELECTANY GUID_RESUME_LOADER_SETTINGS_GROUP = { 0x1AFA9C49, 0x16AB, 0x4A5C, { 0x4A, 0x90, 0x21, 0x28, 0x02, 0xDA, 0x94, 0x60 } };
// 9DEA862C-5CDD-4E70-ACC1-F32B344D4795 // {bootmgr}
GUID DECLSPEC_SELECTANY GUID_WINDOWS_BOOTMGR = { 0x9DEA862C, 0x5CDD, 0x4E70, { 0xAC, 0xC1, 0xF3, 0x2B, 0x34, 0x4D, 0x47, 0x95 } };
// 466F5A88-0AF2-4F76-9038-095B170DC21C // {ntldr} {legacy}
GUID DECLSPEC_SELECTANY GUID_WINDOWS_LEGACY_NTLDR = { 0x466F5A88, 0x0AF2, 0x4F76, { 0x90, 0x38, 0x09, 0x5B, 0x17, 0x0D, 0xC2, 0x1C } };
// B2721D73-1DB4-4C62-BF78-C548A880142D // {memdiag}
GUID DECLSPEC_SELECTANY GUID_WINDOWS_MEMORY_TESTER = { 0xB2721D73, 0x1DB4, 0x4C62, { 0xBF, 0x78, 0xC5, 0x48, 0xA8, 0x80, 0x14, 0x2D } };
// B012B84D-C47C-4ED5-B722-C0C42163E569
GUID DECLSPEC_SELECTANY GUID_WINDOWS_OS_TARGET_TEMPLATE_EFI = { 0xB012B84D, 0xC47C, 0x4ED5, { 0xB7, 0x22, 0xC0, 0xC4, 0x21, 0x63, 0xE5, 0x69 } };
// A1943BBC-EA85-487C-97C7-C9EDE908A38A
GUID DECLSPEC_SELECTANY GUID_WINDOWS_OS_TARGET_TEMPLATE_PCAT = { 0xA1943BBC, 0xEA85, 0x487C, { 0x97, 0xC7, 0xC9, 0xED, 0xE9, 0x08, 0xA3, 0x8A } };
// {0C334284-9A41-4DE1-99B3-A7E87E8FF07E}
GUID DECLSPEC_SELECTANY GUID_WINDOWS_RESUME_TARGET_TEMPLATE_EFI = { 0x0C334284, 0x9A41, 0x4DE1, { 0x99, 0xB3, 0xA7, 0xE8, 0x7E, 0x8F, 0xF0, 0x7E } };
// {98B02A23-0674-4CE7-BDAD-E0A15A8FF97B}
GUID DECLSPEC_SELECTANY GUID_WINDOWS_RESUME_TARGET_TEMPLATE_PCAT = { 0x98B02A23, 0x0674, 0x4CE7, { 0xBD, 0xAD, 0xE0, 0xA1, 0x5A, 0x8F, 0xF9, 0x7B } };
// A1943BBC-EA85-487C-97C7-C9EDE908A38A
GUID DECLSPEC_SELECTANY GUID_WINDOWS_SETUP_EFI = { 0x7254A080, 0x1510, 0x4E85, { 0xAC, 0x0F, 0xE7, 0xFB, 0x3D, 0x44, 0x47, 0x36 } };
// CBD971BF-B7B8-4885-951A-FA03044F5D71
GUID DECLSPEC_SELECTANY GUID_WINDOWS_SETUP_PCAT = { 0xCBD971BF, 0xB7B8, 0x4885, { 0x95, 0x1A, 0xFA, 0x03, 0x04, 0x4F, 0x5D, 0x71 } };
// AE5534E0-A924-466C-B836-758539A3EE3A // {ramdiskoptions}
GUID DECLSPEC_SELECTANY GUID_WINDOWS_SETUP_RAMDISK_OPTIONS = { 0xAE5534E0, 0xA924, 0x466C, { 0xB8, 0x36, 0x75, 0x85, 0x39, 0xA3, 0xEE, 0x3A } };
#else
NTSYSAPI GUID GUID_BAD_MEMORY_GROUP; // {badmemory}
NTSYSAPI GUID GUID_BOOT_LOADER_SETTINGS_GROUP; // {bootloadersettings}
NTSYSAPI GUID GUID_CURRENT_BOOT_ENTRY; // {current}
NTSYSAPI GUID GUID_DEBUGGER_SETTINGS_GROUP; // {eventsettings} {dbgsettings}
NTSYSAPI GUID GUID_DEFAULT_BOOT_ENTRY; // {default}
NTSYSAPI GUID GUID_EMS_SETTINGS_GROUP; // {emssettings}
NTSYSAPI GUID GUID_FIRMWARE_BOOTMGR; // {fwbootmgr}
NTSYSAPI GUID GUID_GLOBAL_SETTINGS_GROUP; // {globalsettings}
NTSYSAPI GUID GUID_HYPERVISOR_SETTINGS_GROUP; // {hypervisorsettings}
NTSYSAPI GUID GUID_KERNEL_DEBUGGER_SETTINGS_GROUP; // {kerneldbgsettings}
NTSYSAPI GUID GUID_RESUME_LOADER_SETTINGS_GROUP; // {resumeloadersettings}
NTSYSAPI GUID GUID_WINDOWS_BOOTMGR; // {bootmgr}
NTSYSAPI GUID GUID_WINDOWS_LEGACY_NTLDR; // {ntldr} {legacy}
NTSYSAPI GUID GUID_WINDOWS_MEMORY_TESTER; // {memdiag}
NTSYSAPI GUID GUID_WINDOWS_OS_TARGET_TEMPLATE_EFI;
NTSYSAPI GUID GUID_WINDOWS_OS_TARGET_TEMPLATE_PCAT;
NTSYSAPI GUID GUID_WINDOWS_RESUME_TARGET_TEMPLATE_EFI;
NTSYSAPI GUID GUID_WINDOWS_RESUME_TARGET_TEMPLATE_PCAT;
NTSYSAPI GUID GUID_WINDOWS_SETUP_EFI;
NTSYSAPI GUID GUID_WINDOWS_SETUP_PCAT;
NTSYSAPI GUID GUID_WINDOWS_SETUP_RAMDISK_OPTIONS; // {ramdiskoptions}
#endif

typedef enum _BCD_MESSAGE_TYPE
{
    BCD_MESSAGE_TYPE_NONE,
    BCD_MESSAGE_TYPE_TRACE,
    BCD_MESSAGE_TYPE_INFORMATION,
    BCD_MESSAGE_TYPE_WARNING,
    BCD_MESSAGE_TYPE_ERROR,
    BCD_MESSAGE_TYPE_MAXIMUM
} BCD_MESSAGE_TYPE;

typedef VOID (CALLBACK* BCD_MESSAGE_CALLBACK)(
    _In_ BCD_MESSAGE_TYPE type,
    _In_ PWSTR Message
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdSetLogging(
    _In_ BCD_MESSAGE_TYPE BcdLoggingLevel,
    _In_ BCD_MESSAGE_CALLBACK BcdMessageCallbackRoutine
    );

NTSYSAPI
VOID
NTAPI
BcdInitializeBcdSyncMutant(
    VOID
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdGetSystemStorePath(
    _Out_ PWSTR* BcdSystemStorePath // RtlFreeHeap(RtlProcessHeap(), 0, BcdSystemStorePath);
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdSetSystemStoreDevice(
    _In_ UNICODE_STRING SystemPartition
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdOpenSystemStore(
    _Out_ PHANDLE BcdStoreHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdOpenStoreFromFile(
    _In_ UNICODE_STRING BcdFilePath,
    _Out_ PHANDLE BcdStoreHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdCreateStore(
    _In_ UNICODE_STRING BcdFilePath,
    _Out_ PHANDLE BcdStoreHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdExportStore(
    _In_ UNICODE_STRING BcdFilePath
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdImportStore(
    _In_ UNICODE_STRING BcdFilePath
    );

typedef enum _BCD_IMPORT_FLAGS
{
    BCD_IMPORT_NONE,
    BCD_IMPORT_DELETE_FIRMWARE_OBJECTS
} BCD_IMPORT_FLAGS;

NTSYSAPI
NTSTATUS
NTAPI
BcdImportStoreWithFlags(
    _In_ UNICODE_STRING BcdFilePath,
    _In_ BCD_IMPORT_FLAGS BcdImportFlags
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdDeleteObjectReferences(
    _In_ HANDLE BcdStoreHandle,
    _In_ PGUID Identifier
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdDeleteSystemStore(
    VOID
    );

typedef enum _BCD_OPEN_FLAGS
{
    BCD_OPEN_NONE,
    BCD_OPEN_OPEN_STORE_OFFLINE,
    BCD_OPEN_SYNC_FIRMWARE_ENTRIES
} BCD_OPEN_FLAGS;

NTSYSAPI
NTSTATUS
NTAPI
BcdOpenStore(
    _In_ UNICODE_STRING BcdFilePath,
    _In_ BCD_OPEN_FLAGS BcdOpenFlags,
    _Out_ PHANDLE BcdStoreHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdCloseStore(
    _In_ HANDLE BcdStoreHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdFlushStore(
    _In_ HANDLE BcdStoreHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdForciblyUnloadStore(
    _In_ HANDLE BcdStoreHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdMarkAsSystemStore(
    _In_ HANDLE BcdStoreHandle
    );

typedef enum _BCD_OBJECT_TYPE
{
    BCD_OBJECT_TYPE_NONE,
    BCD_OBJECT_TYPE_APPLICATION,
    BCD_OBJECT_TYPE_INHERITED,
    BCD_OBJECT_TYPE_DEVICE
} BCD_OBJECT_TYPE;

typedef enum _BCD_APPLICATION_OBJECT_TYPE
{
    BCD_APPLICATION_OBJECT_NONE = 0,
    BCD_APPLICATION_OBJECT_FIRMWARE_BOOT_MANAGER = 1,
    BCD_APPLICATION_OBJECT_WINDOWS_BOOT_MANAGER = 2,
    BCD_APPLICATION_OBJECT_WINDOWS_BOOT_LOADER = 3,
    BCD_APPLICATION_OBJECT_WINDOWS_RESUME_APPLICATION = 4,
    BCD_APPLICATION_OBJECT_MEMORY_TESTER = 5,
    BCD_APPLICATION_OBJECT_LEGACY_NTLDR = 6,
    BCD_APPLICATION_OBJECT_LEGACY_SETUPLDR = 7,
    BCD_APPLICATION_OBJECT_BOOT_SECTOR = 8,
    BCD_APPLICATION_OBJECT_STARTUP_MODULE = 9,
    BCD_APPLICATION_OBJECT_GENERIC_APPLICATION = 10,
    BCD_APPLICATION_OBJECT_RESERVED = 0xFFFFF
} BCD_APPLICATION_OBJECT_TYPE;

typedef enum _BCD_APPLICATION_IMAGE_TYPE
{
    BCD_APPLICATION_IMAGE_NONE,
    BCD_APPLICATION_IMAGE_FIRMWARE_APPLICATION,
    BCD_APPLICATION_IMAGE_BOOT_APPLICATION,
    BCD_APPLICATION_IMAGE_LEGACY_LOADER,
    BCD_APPLICATION_IMAGE_REALMODE_CODE
} BCD_APPLICATION_IMAGE_TYPE;

typedef enum _BCD_INHERITED_CLASS_TYPE
{
    BCD_INHERITED_CLASS_NONE,
    BCD_INHERITED_CLASS_LIBRARY,
    BCD_INHERITED_CLASS_APPLICATION,
    BCD_INHERITED_CLASS_DEVICE
} BCD_INHERITED_CLASS_TYPE;

#define MAKE_BCD_OBJECT(ObjectType, ImageType, ApplicationType) \
    (((ULONG)(ObjectType) << 28) | \
    (((ULONG)(ImageType) & 0xF) << 20) | \
    ((ULONG)(ApplicationType) & 0xFFFFF))

#define MAKE_BCD_APPLICATION_OBJECT(ImageType, ApplicationType) \
    MAKE_BCD_OBJECT(BCD_OBJECT_TYPE_APPLICATION, (ULONG)(ImageType), (ULONG)(ApplicationType))

#define GET_BCD_OBJECT_TYPE(DataType) \
    ((BCD_OBJECT_TYPE)(((((ULONG)DataType)) >> 28) & 0xF))
#define GET_BCD_APPLICATION_IMAGE(DataType) \
    ((BCD_APPLICATION_IMAGE_TYPE)(((((ULONG)DataType)) >> 20) & 0xF))
#define GET_BCD_APPLICATION_OBJECT(DataType) \
    ((BCD_APPLICATION_OBJECT_TYPE)((((ULONG)DataType)) & 0xFFFFF))

#define BCD_OBJECT_OSLOADER_TYPE \
    MAKE_BCD_APPLICATION_OBJECT(BCD_APPLICATION_IMAGE_BOOT_APPLICATION, BCD_APPLICATION_OBJECT_WINDOWS_BOOT_LOADER);

typedef union _BCD_OBJECT_DATATYPE
{
    ULONG PackedValue;
    union
    {
        struct
        {
            ULONG Reserved : 28;
            BCD_OBJECT_TYPE ObjectType : 4;
        };
        struct
        {
            BCD_APPLICATION_OBJECT_TYPE ApplicationType : 20;
            BCD_APPLICATION_IMAGE_TYPE ImageType : 4;
            ULONG Reserved : 4;
            ULONG ObjectType : 4;
        } Application;
        struct
        {
            ULONG Value : 20;
            BCD_INHERITED_CLASS_TYPE Class : 4;
            ULONG Reserved : 4;
            ULONG ObjectType : 4;
        } Inherit;
        struct
        {
            ULONG Reserved : 28;
            ULONG ObjectType : 4;
        } Device;
    };
} BCD_OBJECT_DATATYPE, *PBCD_OBJECT_DATATYPE;

#define BCD_OBJECT_DESCRIPTION_VERSION 0x1

typedef struct _BCD_OBJECT_DESCRIPTION
{
    ULONG Version; // BCD_OBJECT_DESCRIPTION_VERSION
    ULONG Type; // BCD_OBJECT_DATATYPE
} BCD_OBJECT_DESCRIPTION, *PBCD_OBJECT_DESCRIPTION;

typedef struct _BCD_OBJECT
{
    GUID Identifer;
    PBCD_OBJECT_DESCRIPTION Description;
} BCD_OBJECT, *PBCD_OBJECT;

NTSYSAPI
NTSTATUS
NTAPI
BcdEnumerateObjects(
    _In_ HANDLE BcdStoreHandle,
    _In_ PBCD_OBJECT_DESCRIPTION BcdEnumDescriptor,
    _Out_writes_bytes_opt_(*BufferSize) PVOID Buffer, // BCD_OBJECT[]
    _Inout_ PULONG BufferSize,
    _Out_ PULONG ObjectCount
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdOpenObject(
    _In_ HANDLE BcdStoreHandle,
    _In_ PGUID Identifier,
    _Out_ PHANDLE BcdObjectHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdCreateObject(
    _In_ HANDLE BcdStoreHandle,
    _In_ PGUID Identifier,
    _In_ PBCD_OBJECT_DESCRIPTION Description,
    _Out_ PHANDLE BcdObjectHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdDeleteObject(
    _In_ HANDLE BcdObjectHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdCloseObject(
    _In_ HANDLE BcdObjectHandle
    );

typedef enum _BCD_COPY_FLAGS
{
    BCD_COPY_NONE = 0x0,
    BCD_COPY_COPY_CREATE_NEW_OBJECT_IDENTIFIER = 0x1,
    BCD_COPY_COPY_DELETE_EXISTING_OBJECT = 0x2,
    BCD_COPY_COPY_UNKNOWN_FIRMWARE_APPLICATION = 0x4,
    BCD_COPY_IGNORE_SETUP_TEMPLATE_ELEMENTS = 0x8,
    BCD_COPY_RETAIN_ELEMENT_DATA = 0x10,
    BCD_COPY_MIGRATE_ELEMENT_DATA = 0x20
} BCD_COPY_FLAGS;

NTSYSAPI
NTSTATUS
NTAPI
BcdCopyObject(
    _In_ HANDLE BcdStoreHandle,
    _In_ HANDLE BcdObjectHandle,
    _In_ BCD_COPY_FLAGS BcdCopyFlags,
    _In_ HANDLE TargetStoreHandle,
    _Out_ PHANDLE TargetHandleOut
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdCopyObjectEx(
    _In_ HANDLE BcdStoreHandle,
    _In_ HANDLE BcdObjectHandle,
    _In_ BCD_COPY_FLAGS BcdCopyFlags,
    _In_ HANDLE TargetStoreHandle,
    _In_ PGUID TargetObjectId,
    _Out_ PHANDLE TargetHandleOut
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdCopyObjects(
    _In_ HANDLE BcdStoreHandle,
    _In_ BCD_OBJECT_DESCRIPTION Characteristics,
    _In_ BCD_COPY_FLAGS BcdCopyFlags,
    _In_ HANDLE TargetStoreHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdMigrateObjectElementValues(
    _In_ HANDLE TemplateObjectHandle,
    _In_ HANDLE SourceObjectHandle,
    _In_ HANDLE TargetObjectHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdQueryObject(
    _In_ HANDLE BcdObjectHandle,
    _In_ ULONG BcdVersion, // BCD_OBJECT_DESCRIPTION_VERSION
    _Out_ BCD_OBJECT_DESCRIPTION Description,
    _Out_ PGUID Identifier
    );

typedef enum _BCD_ELEMENT_DATATYPE_FORMAT
{
    BCD_ELEMENT_DATATYPE_FORMAT_UNKNOWN,
    BCD_ELEMENT_DATATYPE_FORMAT_DEVICE, // 0x01000000
    BCD_ELEMENT_DATATYPE_FORMAT_STRING, // 0x02000000
    BCD_ELEMENT_DATATYPE_FORMAT_OBJECT, // 0x03000000 
    BCD_ELEMENT_DATATYPE_FORMAT_OBJECTLIST, // 0x04000000 
    BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, // 0x05000000
    BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, // 0x06000000
    BCD_ELEMENT_DATATYPE_FORMAT_INTEGERLIST, // 0x07000000
    BCD_ELEMENT_DATATYPE_FORMAT_BINARY // 0x08000000
} BCD_ELEMENT_DATATYPE_FORMAT;

typedef enum _BCD_ELEMENT_DATATYPE_CLASS
{
    BCD_ELEMENT_DATATYPE_CLASS_NONE,
    BCD_ELEMENT_DATATYPE_CLASS_LIBRARY,
    BCD_ELEMENT_DATATYPE_CLASS_APPLICATION,
    BCD_ELEMENT_DATATYPE_CLASS_DEVICE,
    BCD_ELEMENT_DATATYPE_CLASS_SETUPTEMPLATE,
    BCD_ELEMENT_DATATYPE_CLASS_OEM
} BCD_ELEMENT_DATATYPE_CLASS;

typedef enum _BCD_ELEMENT_DEVICE_TYPE
{
    BCD_ELEMENT_DEVICE_TYPE_NONE,
    BCD_ELEMENT_DEVICE_TYPE_BOOT_DEVICE,
    BCD_ELEMENT_DEVICE_TYPE_PARTITION,
    BCD_ELEMENT_DEVICE_TYPE_FILE,
    BCD_ELEMENT_DEVICE_TYPE_RAMDISK,
    BCD_ELEMENT_DEVICE_TYPE_UNKNOWN,
    BCD_ELEMENT_DEVICE_TYPE_QUALIFIED_PARTITION,
    BCD_ELEMENT_DEVICE_TYPE_VMBUS,
    BCD_ELEMENT_DEVICE_TYPE_LOCATE_DEVICE,
    BCD_ELEMENT_DEVICE_TYPE_URI,
    BCD_ELEMENT_DEVICE_TYPE_COMPOSITE
} BCD_ELEMENT_DEVICE_TYPE;

#define MAKE_BCDE_DATA_TYPE(Class, Format, Subtype) \
    (((((ULONG)Class) & 0xF) << 28) | ((((ULONG)Format) & 0xF) << 24) | (((ULONG)Subtype) & 0x00FFFFFF))

#define GET_BCDE_DATA_CLASS(DataType) \
    ((BCD_ELEMENT_DATATYPE_CLASS)(((((ULONG)DataType)) >> 28) & 0xF))
#define GET_BCDE_DATA_FORMAT(DataType) \
    ((BCD_ELEMENT_DATATYPE_FORMAT)(((((ULONG)DataType)) >> 24) & 0xF))
#define GET_BCDE_DATA_SUBTYPE(DataType) \
    ((ULONG)((((ULONG)DataType)) & 0x00FFFFFF))

typedef struct _BCD_ELEMENT_DATATYPE
{
    union
    {
        ULONG PackedValue;
        struct
        {
            ULONG SubType : 24;
            BCD_ELEMENT_DATATYPE_FORMAT Format : 4;
            BCD_ELEMENT_DATATYPE_CLASS Class : 4;
        };
    };
} BCD_ELEMENT_DATATYPE, *PBCD_ELEMENT_DATATYPE;

NTSYSAPI
NTSTATUS
NTAPI
BcdEnumerateElementTypes(
    _In_ HANDLE BcdObjectHandle,
    _Out_writes_bytes_opt_(*BufferSize) PVOID Buffer, // BCD_ELEMENT_DATATYPE[]
    _Inout_ PULONG BufferSize,
    _Out_ PULONG ElementCount
    );

typedef struct _BCD_ELEMENT_DEVICE_QUALIFIED_PARTITION
{
    ULONG PartitionStyle;
    ULONG Reserved;
    struct
    {
        union
        {
            ULONG DiskSignature;
            ULONG64 PartitionOffset;
        } Mbr;
        union
        {
            GUID DiskSignature;
            GUID PartitionSignature;
        } Gpt;
    };
} BCD_ELEMENT_DEVICE_QUALIFIED_PARTITION, *PBCD_ELEMENT_DEVICE_QUALIFIED_PARTITION;

typedef struct _BCD_ELEMENT_DEVICE
{
    ULONG DeviceType;
    GUID AdditionalOptions;
    struct
    {
        union
        {
            ULONG ParentOffset;
            WCHAR Path[ANYSIZE_ARRAY];
        } File;
        union
        {
            WCHAR Path[ANYSIZE_ARRAY];
        } Partition;
        union
        {
            ULONG Type;
            ULONG ParentOffset;
            ULONG ElementType;
            WCHAR Path[ANYSIZE_ARRAY];
        } Locate;
        union
        {
            GUID InterfaceInstance;
        } Vmbus;
        union
        {
            ULONG Data[ANYSIZE_ARRAY];
        } Unknown;
        BCD_ELEMENT_DEVICE_QUALIFIED_PARTITION QualifiedPartition;
    };
} BCD_ELEMENT_DEVICE, *PBCD_ELEMENT_DEVICE;

typedef struct _BCD_ELEMENT_STRING
{
    WCHAR Value[ANYSIZE_ARRAY];
} BCD_ELEMENT_STRING, *PBCD_ELEMENT_STRING;

typedef struct _BCD_ELEMENT_OBJECT
{
    GUID Object;
} BCD_ELEMENT_OBJECT, *PBCD_ELEMENT_OBJECT;

typedef struct _BCD_ELEMENT_OBJECT_LIST
{
    GUID ObjectList[ANYSIZE_ARRAY];
} BCD_ELEMENT_OBJECT_LIST, *PBCD_ELEMENT_OBJECT_LIST;

typedef struct _BCD_ELEMENT_INTEGER
{
    ULONG64 Value;
} BCD_ELEMENT_INTEGER, *PBCD_ELEMENT_INTEGER;

typedef struct _BCD_ELEMENT_INTEGER_LIST
{
    ULONG64 Value[ANYSIZE_ARRAY];
} BCD_ELEMENT_INTEGER_LIST, *PBCD_ELEMENT_INTEGER_LIST;

typedef struct _BCD_ELEMENT_BOOLEAN
{
    BOOLEAN Value;
    //BOOLEAN Pad; // sym
} BCD_ELEMENT_BOOLEAN, *PBCD_ELEMENT_BOOLEAN;

#define BCD_ELEMENT_DESCRIPTION_VERSION 0x1

typedef struct BCD_ELEMENT_DESCRIPTION
{
    ULONG Version; // BCD_ELEMENT_DESCRIPTION_VERSION
    ULONG Type;
    ULONG DataSize;
} BCD_ELEMENT_DESCRIPTION, *PBCD_ELEMENT_DESCRIPTION;

typedef struct _BCD_ELEMENT
{
    PBCD_ELEMENT_DESCRIPTION Description;
    PVOID Data;
} BCD_ELEMENT, *PBCD_ELEMENT;

NTSYSAPI
NTSTATUS
NTAPI
BcdEnumerateElements(
    _In_ HANDLE BcdObjectHandle,
    _Out_writes_bytes_opt_(*BufferSize) PVOID Buffer, // BCD_ELEMENT[]
    _Inout_ PULONG BufferSize,
    _Out_ PULONG ElementCount
    );

typedef enum _BCD_FLAGS
{
    BCD_FLAG_NONE = 0x0,
    BCD_FLAG_QUALIFIED_PARTITION = 0x1,
    BCD_FLAG_NO_DEVICE_TRANSLATION = 0x2,
    BCD_FLAG_ENUMERATE_INHERITED_OBJECTS = 0x4,
    BCD_FLAG_ENUMERATE_DEVICE_OPTIONS = 0x8,
    BCD_FLAG_OBSERVE_PRECEDENCE = 0x10,
    BCD_FLAG_DISABLE_VHD_NT_TRANSLATION = 0x20,
    BCD_FLAG_DISABLE_VHD_DEVICE_DETECTION = 0x40,
    BCD_FLAG_DISABLE_POLICY_CHECKS = 0x80
} BCD_FLAGS;

NTSYSAPI
NTSTATUS
NTAPI
BcdEnumerateElementsWithFlags(
    _In_ HANDLE BcdObjectHandle,
    _In_ BCD_FLAGS BcdFlags,
    _Out_writes_bytes_opt_(*BufferSize) PVOID Buffer, // BCD_ELEMENT[]
    _Inout_ PULONG BufferSize,
    _Out_ PULONG ElementCount
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdEnumerateAndUnpackElements(
    _In_ HANDLE BcdStoreHandle,
    _In_ HANDLE BcdObjectHandle,
    _In_ BCD_FLAGS BcdFlags,
    _Out_writes_bytes_opt_(*BufferSize) PVOID Buffer, // BCD_ELEMENT[]
    _Inout_ PULONG BufferSize,
    _Out_ PULONG ElementCount
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdGetElementData(
    _In_ HANDLE BcdObjectHandle,
    _In_ ULONG BcdElement, // BCD_ELEMENT_DATATYPE
    _Out_writes_bytes_opt_(*BufferSize) PVOID Buffer,
    _Inout_ PULONG BufferSize
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdGetElementDataWithFlags(
    _In_ HANDLE BcdObjectHandle,
    _In_ ULONG BcdElement, // BCD_ELEMENT_DATATYPE
    _In_ BCD_FLAGS BcdFlags,
    _Out_writes_bytes_opt_(*BufferSize) PVOID Buffer,
    _Inout_ PULONG BufferSize
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdSetElementData(
    _In_ HANDLE BcdObjectHandle,
    _In_ ULONG BcdElement, // BCD_ELEMENT_DATATYPE
    _In_reads_bytes_opt_(BufferSize) PVOID Buffer,
    _In_ ULONG BufferSize
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdSetElementDataWithFlags(
    _In_ HANDLE BcdObjectHandle,
    _In_ ULONG BcdElement, // BCD_ELEMENT_DATATYPE
    _In_ BCD_FLAGS BcdFlags,
    _In_reads_bytes_opt_(BufferSize) PVOID Buffer,
    _In_ ULONG BufferSize
    );

NTSYSAPI
NTSTATUS
NTAPI
BcdDeleteElement(
    _In_ HANDLE BcdObjectHandle,
    _In_ ULONG BcdElement // BCD_ELEMENT_DATATYPE
    );

// Element types

typedef enum _BcdBootMgrElementTypes
{
    /// <summary>
    /// The order in which BCD objects should be displayed.
    /// Objects are displayed using the string specified by the BcdLibraryString_Description element.
    /// </summary>
    /// <remarks>0x24000001</remarks>
    BcdBootMgrObjectList_DisplayOrder = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_OBJECTLIST, 1),
    /// <summary>
    /// List of boot environment applications the boot manager should execute.
    /// The applications are executed in the order they appear in this list.
    /// If the firmware boot manager does not support loading multiple applications, this list cannot contain more than one entry.
    /// </summary>
    /// <remarks>0x24000002</remarks>
    BcdBootMgrObjectList_BootSequence = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_OBJECTLIST, 2),
    /// <summary>
    /// The default boot environment application to load if the user does not select one.
    /// </summary>
    /// <remarks>0x23000003</remarks>
    BcdBootMgrObject_DefaultObject = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_OBJECT, 3),
    /// <summary>
    /// The maximum number of seconds a boot selection menu is to be displayed to the user.
    /// The menu is displayed until the user selects an option or the time-out expires.
    /// If this value is not specified, the boot manager waits for the user to make a selection.
    /// </summary>
    /// <remarks>0x25000004</remarks>
    BcdBootMgrInteger_Timeout = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 4),
    /// <summary>
    /// Indicates that a resume operation should be attempted during a system restart.
    /// </summary>
    /// <remarks>0x26000005</remarks>
    BcdBootMgrBoolean_AttemptResume = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 5),
    /// <summary>
    /// The resume application object.
    /// </summary>
    /// <remarks>0x23000006</remarks>
    BcdBootMgrObject_ResumeObject = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_OBJECT, 6),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x24000007</remarks>
    BcdBootMgrObjectList_StartupSequence = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_OBJECTLIST, 7),
    /// <summary>
    /// The boot manager tools display order list.
    /// </summary>
    /// <remarks>0x24000010</remarks>
    BcdBootMgrObjectList_ToolsDisplayOrder = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_OBJECTLIST, 16),
    /// <summary>
    /// Forces the display of the legacy boot menu, regardless of the number of OS entries in the BCD store and their BcdOSLoaderInteger_BootMenuPolicy.
    /// </summary>
    /// <remarks>0x26000020</remarks>
    BcdBootMgrBoolean_DisplayBootMenu = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 32),
    /// <summary>
    /// Indicates whether the display of errors should be suppressed.
    /// If this setting is enabled, the boot manager exits to the multi-OS menu on OS launch error.
    /// </summary>
    /// <remarks>0x26000021</remarks>
    BcdBootMgrBoolean_NoErrorDisplay = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 33),
    /// <summary>
    /// The device on which the boot application resides.
    /// </summary>
    /// <remarks>0x21000022</remarks>
    BcdBootMgrDevice_BcdDevice = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_DEVICE, 34),
    /// <summary>
    /// The boot application.
    /// </summary>
    /// <remarks>0x22000023</remarks>
    BcdBootMgrString_BcdFilePath = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 35),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x26000024</remarks>
    BcdBootMgrBoolean_HormEnabled = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 36),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x26000025</remarks>
    BcdBootMgrBoolean_HiberRoot = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 37),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x22000026</remarks>
    BcdBootMgrString_PasswordOverride = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 38),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x22000027</remarks>
    BcdBootMgrString_PinpassPhraseOverride = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 39),
    /// <summary>
    /// Controls whether custom actions are processed before a boot sequence.
    /// Note This value is supported starting in Windows 8 and Windows Server 2012.
    /// </summary>
    /// <remarks>0x26000028</remarks>
    BcdBootMgrBoolean_ProcessCustomActionsFirst = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 40),
    /// <summary>
    /// Custom Bootstrap Actions.
    /// </summary>
    /// <remarks>0x27000030</remarks>
    BcdBootMgrIntegerList_CustomActionsList = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGERLIST, 48),
    /// <summary>
    /// Controls whether a boot sequence persists across multiple boots.
    /// Note This value is supported starting in Windows 8 and Windows Server 2012.
    /// </summary>
    /// <remarks>0x26000031</remarks>
    BcdBootMgrBoolean_PersistBootSequence = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 49),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x26000032</remarks>
    BcdBootMgrBoolean_SkipStartupSequence = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 50),
} BcdBootMgrElementTypes;

typedef enum _BcdLibrary_FirstMegabytePolicy
{
    /// <summary>
    /// Use none of the first megabyte of memory.
    /// </summary>
    FirstMegabytePolicyUseNone,
    /// <summary>
    /// Use all of the first megabyte of memory.
    /// </summary>
    FirstMegabytePolicyUseAll,
    /// <summary>
    /// Reserved for future use.
    /// </summary>
    FirstMegabytePolicyUsePrivate
} BcdLibrary_FirstMegabytePolicy;

typedef enum _BcdLibrary_DebuggerType
{
    DebuggerSerial = 0,
    Debugger1394 = 1,
    DebuggerUsb = 2,
    DebuggerNet = 3,
    DebuggerLocal = 4
} BcdLibrary_DebuggerType;

typedef enum _BcdLibrary_DebuggerStartPolicy
{
    /// <summary>
    /// The debugger will start active.
    /// </summary>
    DebuggerStartActive,
    /// <summary>
    /// The debugger will start in the auto-enabled state.
    /// If a debugger is attached it will be used; otherwise the debugger port will be available for other applications.
    /// </summary>
    DebuggerStartAutoEnable,
    /// <summary>
    /// The debugger will not start.
    /// </summary>
    DebuggerStartDisable
} BcdLibrary_DebuggerStartPolicy;

typedef enum _BcdLibrary_ConfigAccessPolicy
{
    /// <summary>
    /// Access to PCI configuration space through the memory-mapped region is allowed.
    /// </summary>
    ConfigAccessPolicyDefault,
    /// <summary>
    /// Access to PCI configuration space through the memory-mapped region is not allowed.
    /// This setting is used for platforms that implement memory-mapped configuration space incorrectly.
    /// The CFC/CF8 access mechanism can be used to access configuration space on these platforms.
    /// </summary>
    ConfigAccessPolicyDisallowMmConfig
} BcdLibrary_ConfigAccessPolicy;

typedef enum _BcdLibrary_UxDisplayMessageType
{
    DisplayMessageTypeDefault = 0,
    DisplayMessageTypeResume = 1,
    DisplayMessageTypeHyperV = 2,
    DisplayMessageTypeRecovery = 3,
    DisplayMessageTypeStartupRepair = 4,
    DisplayMessageTypeSystemImageRecovery = 5,
    DisplayMessageTypeCommandPrompt = 6,
    DisplayMessageTypeSystemRestore = 7,
    DisplayMessageTypePushButtonReset = 8,
} BcdLibrary_UxDisplayMessageType;

typedef enum BcdLibrary_SafeBoot
{
    /// <summary>
    /// Load the drivers and services specified by name or group under the following registry key:
    /// HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SafeBoot\Minimal.
    /// </summary>
    SafemodeMinimal = 0,
    /// <summary>
    /// Load the drivers and services specified by name or group under the following registry key:
    /// HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SafeBoot\Network
    /// </summary>
    SafemodeNetwork = 1,
    /// <summary>
    /// Boot the system into a repair mode that restores the Active Directory service from backup medium.
    /// </summary>
    SafemodeDsRepair = 2
} BcdLibrary_SafeBoot;

// BcdLibraryElementTypes based on geoffchappell: https://www.geoffchappell.com/notes/windows/boot/bcd/elements.htm (dmex)
typedef enum _BcdLibraryElementTypes
{
    /// <summary>
    /// Device on which a boot environment application resides.
    /// </summary>
    /// <remarks>0x11000001</remarks>
    BcdLibraryDevice_ApplicationDevice = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_DEVICE, 1),
    /// <summary>
    /// Path to a boot environment application.
    /// </summary>
    /// <remarks>0x12000002</remarks>
    BcdLibraryString_ApplicationPath = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 2),
    /// <summary>
    /// Display name of the boot environment application.
    /// </summary>
    /// <remarks>0x12000004</remarks>
    BcdLibraryString_Description = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 4),
    /// <summary>
    /// Preferred locale, in RFC 3066 format.
    /// </summary>
    /// <remarks>0x12000005</remarks>
    BcdLibraryString_PreferredLocale = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 5),
    /// <summary>
    /// List of BCD objects from which the current object should inherit elements.
    /// </summary>
    /// <remarks>0x14000006</remarks>
    BcdLibraryObjectList_InheritedObjects = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_OBJECTLIST, 6),
    /// <summary>
    /// Maximum physical address a boot environment application should recognize. All memory above this address is ignored.
    /// </summary>
    /// <remarks>0x15000007</remarks>
    BcdLibraryInteger_TruncatePhysicalMemory = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 7),
    /// <summary>
    /// List of boot environment applications to be executed if the associated application fails. The applications are executed in the order they appear in this list.
    /// </summary>
    /// <remarks>0x14000008</remarks>
    BcdLibraryObjectList_RecoverySequence = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_OBJECTLIST, 8),
    /// <summary>
    /// Indicates whether the recovery sequence executes automatically if the boot application fails. Otherwise, the recovery sequence only runs on demand.
    /// </summary>
    /// <remarks>0x16000009</remarks>
    BcdLibraryBoolean_AutoRecoveryEnabled = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 9),
    /// <summary>
    /// List of page frame numbers describing faulty memory in the system.
    /// </summary>
    /// <remarks>0x1700000A</remarks>
    BcdLibraryIntegerList_BadMemoryList = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGERLIST, 10),
    /// <summary>
    /// If TRUE, indicates that a boot application can use memory listed in the BcdLibraryIntegerList_BadMemoryList.
    /// </summary>
    /// <remarks>0x1600000B</remarks>
    BcdLibraryBoolean_AllowBadMemoryAccess = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 11),
    /// <summary>
    /// Indicates how the first megabyte of memory is to be used. The Integer property is one of the values from the BcdLibrary_FirstMegabytePolicy enumeration.
    /// </summary>
    /// <remarks>0x1500000C</remarks>
    BcdLibraryInteger_FirstMegabytePolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 12),
    /// <summary>
    /// Relocates physical memory on certain AMD processors.
    /// This value is not used in Windows 8 or Windows Server 2012.
    /// </summary>
    /// <remarks>0x1500000D</remarks>
    BcdLibraryInteger_RelocatePhysicalMemory = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 13),
    /// <summary>
    /// Specifies a minimum physical address to use in the boot environment.
    /// </summary>
    /// <remarks>0x1500000E</remarks>
    BcdLibraryInteger_AvoidLowPhysicalMemory = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 14),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x1600000F</remarks>
    BcdLibraryBoolean_TraditionalKsegMappings = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 15),
    /// <summary>
    /// Indicates whether the boot debugger should be enabled.
    /// </summary>
    /// <remarks>0x16000010</remarks>
    BcdLibraryBoolean_DebuggerEnabled = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 16),
    /// <summary>
    /// Debugger type. The Integer property is one of the values from the BcdLibrary_DebuggerType enumeration.
    /// </summary>
    /// <remarks>0x15000011</remarks>
    BcdLibraryInteger_DebuggerType = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 17),
    /// <summary>
    /// I/O port address for the serial debugger.
    /// </summary>
    /// <remarks>0x15000012</remarks>
    BcdLibraryInteger_SerialDebuggerPortAddress = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 18),
    /// <summary>
    /// Serial port number for serial debugging.
    /// If this value is not specified, the default is specified by the DBGP ACPI table settings.
    /// </summary>
    /// <remarks>0x15000013</remarks>
    BcdLibraryInteger_SerialDebuggerPort = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 19),
    /// <summary>
    /// Baud rate for serial debugging.
    /// </summary>
    /// <remarks>0x15000014</remarks>
    BcdLibraryInteger_SerialDebuggerBaudRate = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 20),
    /// <summary>
    /// Channel number for 1394 debugging.
    /// </summary>
    /// <remarks>0x15000015</remarks>
    BcdLibraryInteger_1394DebuggerChannel = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 21),
    /// <summary>
    /// The target name for the USB debugger. The target name is arbitrary but must match between the debugger and the debug target.
    /// </summary>
    /// <remarks>0x12000016</remarks>
    BcdLibraryString_UsbDebuggerTargetName = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 22),
    /// <summary>
    /// If TRUE, the debugger will ignore user mode exceptions and only stop for kernel mode exceptions.
    /// </summary>
    /// <remarks>0x16000017</remarks>
    BcdLibraryBoolean_DebuggerIgnoreUsermodeExceptions = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 23),
    /// <summary>
    /// Indicates the debugger start policy. The Integer property is one of the values from the BcdLibrary_DebuggerStartPolicy enumeration.
    /// </summary>
    /// <remarks>0x15000018</remarks>
    BcdLibraryInteger_DebuggerStartPolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 24),
    /// <summary>
    /// Defines the PCI bus, device, and function numbers of the debugging device. For example, 1.5.0 describes the debugging device on bus 1, device 5, function 0.
    /// </summary>
    /// <remarks>0x12000019</remarks>
    BcdLibraryString_DebuggerBusParameters = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 25),
    /// <summary>
    /// Defines the host IP address for the network debugger.
    /// </summary>
    /// <remarks>0x1500001A</remarks>
    BcdLibraryInteger_DebuggerNetHostIP = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 26),
    /// <summary>
    /// Defines the network port for the network debugger.
    /// </summary>
    /// <remarks>0x1500001B</remarks>
    BcdLibraryInteger_DebuggerNetPort = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 27),
    /// <summary>
    /// Controls the use of DHCP by the network debugger. Setting this to false causes the OS to only use link-local addresses.
    /// This value is supported starting in Windows 8 and Windows Server 2012.
    /// </summary>
    /// <remarks>0x1600001C</remarks>
    BcdLibraryBoolean_DebuggerNetDhcp = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 28),
    /// <summary>
    /// Holds the key used to encrypt the network debug connection.
    /// This value is supported starting in Windows 8 and Windows Server 2012.
    /// </summary>
    /// <remarks>0x1200001D</remarks>
    BcdLibraryString_DebuggerNetKey = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 29),
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>0x1600001E</remarks>
    BcdLibraryBoolean_DebuggerNetVM = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 30),
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>0x1200001F</remarks>
    BcdLibraryString_DebuggerNetHostIpv6 = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 31),
    /// <summary>
    /// Indicates whether EMS redirection should be enabled.
    /// </summary>
    /// <remarks>0x16000020</remarks>
    BcdLibraryBoolean_EmsEnabled = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 32),
    /// <summary>
    /// COM port number for EMS redirection.
    /// </summary>
    /// <remarks>0x15000022</remarks>
    BcdLibraryInteger_EmsPort = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 34),
    /// <summary>
    /// Baud rate for EMS redirection.
    /// </summary>
    /// <remarks>0x15000023</remarks>
    BcdLibraryInteger_EmsBaudRate = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 35),
    /// <summary>
    /// String that is appended to the load options string passed to the kernel to be consumed by kernel-mode components.
    /// This is useful for communicating with kernel-mode components that are not BCD-aware.
    /// </summary>
    /// <remarks>0x12000030</remarks>
    BcdLibraryString_LoadOptionsString = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 48),
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>0x16000031</remarks>
    BcdLibraryBoolean_AttemptNonBcdStart = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 49),
    /// <summary>
    /// Indicates whether the advanced options boot menu (F8) is displayed.
    /// </summary>
    /// <remarks>0x16000040</remarks>
    BcdLibraryBoolean_DisplayAdvancedOptions = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 64),
    /// <summary>
    /// Indicates whether the boot options editor is enabled.
    /// </summary>
    /// <remarks>0x16000041</remarks>
    BcdLibraryBoolean_DisplayOptionsEdit = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 65),
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>0x15000042</remarks>
    BcdLibraryInteger_FVEKeyRingAddress = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 66),
    /// <summary>
    /// Allows a device override for the bootstat.dat log in the boot manager and winload.exe.
    /// </summary>
    /// <remarks>0x11000043</remarks>
    BcdLibraryDevice_BsdLogDevice = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_DEVICE, 67),
    /// <summary>
    /// Allows a path override for the bootstat.dat log file in the boot manager and winload.exe.
    /// </summary>
    /// <remarks>0x12000044</remarks>
    BcdLibraryString_BsdLogPath = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 68),
    /// <summary>
    /// Indicates whether graphics mode is disabled and boot applications must use text mode display.
    /// </summary>
    /// <remarks>0x16000045</remarks>
    BcdLibraryBoolean_BsdPreserveLog = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 69),
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>0x16000046</remarks>
    BcdLibraryBoolean_GraphicsModeDisabled = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 70),
    /// <summary>
    /// Indicates the access policy for PCI configuration space.
    /// </summary>
    /// <remarks>0x15000047</remarks>
    BcdLibraryInteger_ConfigAccessPolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 71),
    /// <summary>
    /// Disables integrity checks.
    /// Cannot be set when secure boot is enabled.
    /// This value is ignored by Windows 7 and Windows 8.
    /// </summary>
    /// <remarks>0x16000048</remarks>
    BcdLibraryBoolean_DisableIntegrityChecks = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 72),
    /// <summary>
    /// Indicates whether the test code signing certificate is supported.
    /// </summary>
    /// <remarks>0x16000049</remarks>
    BcdLibraryBoolean_AllowPrereleaseSignatures = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 73),
    /// <summary>
    /// Overrides the default location of the boot fonts.
    /// </summary>
    /// <remarks>0x1200004A</remarks>
    BcdLibraryString_FontPath = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 74),
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>0x1500004B</remarks>
    BcdLibraryInteger_SiPolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 75),
    /// <summary>
    /// This value (if present) should not be modified.
    /// </summary>
    /// <remarks>0x1500004C</remarks>
    BcdLibraryInteger_FveBandId = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 76),
    /// <summary>
    /// Specifies that legacy BIOS systems should use INT 16h Function 10h for console input instead of INT 16h Function 0h.
    /// </summary>
    /// <remarks>0x16000050</remarks>
    BcdLibraryBoolean_ConsoleExtendedInput = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 80),
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>0x15000051</remarks>
    BcdLibraryInteger_InitialConsoleInput = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 81),
    /// <summary>
    /// Forces a specific graphics resolution at boot.
    /// Possible values include GraphicsResolution1024x768 (0), GraphicsResolution800x600 (1), and GraphicsResolution1024x600 (2).
    /// </summary>
    /// <remarks>0x15000052</remarks>
    BcdLibraryInteger_GraphicsResolution = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 82),
    /// <summary>
    /// If enabled, specifies that boot error screens are not shown when OS launch errors occur, and the system is reset rather than exiting directly back to the firmware.
    /// </summary>
    /// <remarks>0x16000053</remarks>
    BcdLibraryBoolean_RestartOnFailure = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 83),
    /// <summary>
    /// Forces highest available graphics resolution at boot.
    /// This value can only be used on UEFI systems.
    /// This value is supported starting in Windows 8 and Windows Server 2012.
    /// </summary>
    /// <remarks>0x16000054</remarks>
    BcdLibraryBoolean_GraphicsForceHighestMode = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 84),
    /// <summary>
    /// This setting is used to differentiate between the Windows 7 and Windows 8 implementations of UEFI.
    /// Do not modify this setting.
    /// If this setting is removed from a Windows 8 installation, it will not boot.
    /// If this setting is added to a Windows 7 installation, it will not boot.
    /// </summary>
    /// <remarks>0x16000060</remarks>
    BcdLibraryBoolean_IsolatedExecutionContext = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 96),
    /// <summary>
    /// This setting disables the progress bar and default Windows logo. If a custom text string has been defined, it is also disabled by this setting.
    /// The Integer property is one of the values from the BcdLibrary_UxDisplayMessageType enumeration.
    /// </summary>
    /// <remarks>0x15000065</remarks>
    BcdLibraryInteger_BootUxDisplayMessage = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 101),
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>0x15000066</remarks>
    BcdLibraryInteger_BootUxDisplayMessageOverride = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 102),
    /// <summary>
    /// This setting disables the boot logo.
    /// </summary>
    /// <remarks>0x16000067</remarks>
    BcdLibraryBoolean_BootUxLogoDisable = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 103),
    /// <summary>
    /// This setting disables the boot status text.
    /// </summary>
    /// <remarks>0x16000068</remarks>
    BcdLibraryBoolean_BootUxTextDisable = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 104),
    /// <summary>
    /// This setting disables the boot progress bar.
    /// </summary>
    /// <remarks>0x16000069</remarks>
    BcdLibraryBoolean_BootUxProgressDisable = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 105),
    /// <summary>
    /// This setting disables the boot transition fading.
    /// </summary>
    /// <remarks>0x1600006A</remarks>
    BcdLibraryBoolean_BootUxFadeDisable = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 106),
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>0x1600006B</remarks>
    BcdLibraryBoolean_BootUxReservePoolDebug = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 107),
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>0x1600006C</remarks>
    BcdLibraryBoolean_BootUxDisable = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 108),
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>0x1500006D</remarks>
    BcdLibraryInteger_BootUxFadeFrames = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 109),
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>0x1600006E</remarks>
    BcdLibraryBoolean_BootUxDumpStats = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 110),
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>0x1600006F</remarks>
    BcdLibraryBoolean_BootUxShowStats = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 111),
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>0x16000071</remarks>
    BcdLibraryBoolean_MultiBootSystem = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 113),
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>0x16000072</remarks>
    BcdLibraryBoolean_ForceNoKeyboard = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 114),
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>0x15000073</remarks>
    BcdLibraryInteger_AliasWindowsKey = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 115),
    /// <summary>
    /// Disables the 1-minute timer that triggers shutdown on boot error screens, and the F8 menu, on UEFI systems.
    /// </summary>
    /// <remarks>0x16000074</remarks>
    BcdLibraryBoolean_BootShutdownDisabled = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 116),
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>0x15000075</remarks>
    BcdLibraryInteger_PerformanceFrequency = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 117),
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>0x15000076</remarks>
    BcdLibraryInteger_SecurebootRawPolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 118),
    /// <summary>
    /// Indicates whether or not an in-memory BCD setting passed between boot apps will trigger BitLocker recovery.
    /// This value should not be modified as it could trigger a BitLocker recovery action.
    /// </summary>
    /// <remarks>0x17000077</remarks>
    BcdLibraryIntegerList_AllowedInMemorySettings = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 119),
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>0x15000079</remarks>
    BcdLibraryInteger_BootUxBitmapTransitionTime = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 121),
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>0x1600007A</remarks>
    BcdLibraryBoolean_TwoBootImages = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 122),
    /// <summary>
    /// Force the use of FIPS cryptography checks on boot applications.
    /// BcdLibraryBoolean_ForceFipsCrypto is documented with wrong value 0x16000079
    /// </summary>
    /// <remarks>0x1600007B</remarks>
    BcdLibraryBoolean_ForceFipsCrypto = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 123),
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>0x1500007D</remarks>
    BcdLibraryInteger_BootErrorUx = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 125),
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>0x1600007E</remarks>
    BcdLibraryBoolean_AllowFlightSignatures = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 126),
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>0x1500007F</remarks>
    BcdLibraryInteger_BootMeasurementLogFormat = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 127),
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>0x15000080</remarks>
    BcdLibraryInteger_DisplayRotation = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 128),
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>0x15000081</remarks>
    BcdLibraryInteger_LogControl = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 129),
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>0x16000082</remarks>
    BcdLibraryBoolean_NoFirmwareSync = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 130),
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>0x11000084</remarks>
    BcdLibraryDevice_WindowsSystemDevice = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_DEVICE, 132),
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>0x16000087</remarks>
    BcdLibraryBoolean_NumLockOn = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 135),
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>0x12000088</remarks>
    BcdLibraryString_AdditionalCiPolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_LIBRARY, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 136),
} BcdLibraryElementTypes;

typedef enum _BcdTemplateElementTypes
{
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>0x45000001</remarks>
    BcdSetupInteger_DeviceType = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_SETUPTEMPLATE, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 1),
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>0x42000002</remarks>
    BcdSetupString_ApplicationRelativePath = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_SETUPTEMPLATE, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 2),
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>0x42000003</remarks>
    BcdSetupString_RamdiskDeviceRelativePath = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_SETUPTEMPLATE, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 3),
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>0x46000004</remarks>
    BcdSetupBoolean_OmitOsLoaderElements = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_SETUPTEMPLATE, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 4),
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>0x47000006</remarks>
    BcdSetupIntegerList_ElementsToMigrateList = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_SETUPTEMPLATE, BCD_ELEMENT_DATATYPE_FORMAT_INTEGERLIST, 6),
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>0x46000010</remarks>
    BcdSetupBoolean_RecoveryOs = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_SETUPTEMPLATE, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 16),
} BcdTemplateElementTypes;

/// <summary>
/// Specifies the no-execute page protection policies.
/// </summary>
typedef enum _BcdOSLoader_NxPolicy
{
    /// <summary>
    /// The no-execute page protection is off by default.
    /// </summary>
    NxPolicyOptIn = 0,
    /// <summary>
    /// The no-execute page protection is on by default.
    /// </summary>
    NxPolicyOptOut = 1,
    /// <summary>
    /// The no-execute page protection is always off.
    /// </summary>
    NxPolicyAlwaysOff = 2,
    /// <summary>
    /// The no-execute page protection is always on.
    /// </summary>
    NxPolicyAlwaysOn = 3
} BcdOSLoader_NxPolicy;

/// <summary>
/// Specifies the Physical Address Extension (PAE) policies.
/// </summary>
typedef enum _BcdOSLoader_PAEPolicy
{
    /// <summary>
    /// Enable PAE if hot-pluggable memory is defined above 4GB.
    /// </summary>
    PaePolicyDefault = 0,
    /// <summary>
    /// PAE is enabled.
    /// </summary>
    PaePolicyForceEnable = 1,
    /// <summary>
    /// PAE is disabled.
    /// </summary>
    PaePolicyForceDisable = 2
} BcdOSLoader_PAEPolicy;

typedef enum _BcdOSLoader_BootStatusPolicy
{
    /// <summary>
    /// Display all boot failures.
    /// </summary>
    BootStatusPolicyDisplayAllFailures = 0,
    /// <summary>
    /// Ignore all boot failures.
    /// </summary>
    BootStatusPolicyIgnoreAllFailures = 1,
    /// <summary>
    /// Ignore all shutdown failures.
    /// </summary>
    BootStatusPolicyIgnoreShutdownFailures = 2,
    /// <summary>
    /// Ignore all boot failures.
    /// </summary>
    BootStatusPolicyIgnoreBootFailures = 3,
    /// <summary>
    /// Ignore checkpoint failures.
    /// </summary>
    BootStatusPolicyIgnoreCheckpointFailures = 4,
    /// <summary>
    /// Display shutdown failures.
    /// </summary>
    BootStatusPolicyDisplayShutdownFailures = 5,
    /// <summary>
    /// Display boot failures.
    /// </summary>
    BootStatusPolicyDisplayBootFailures = 6,
    /// <summary>
    /// Display checkpoint failures.
    /// </summary>
    BootStatusPolicyDisplayCheckpointFailures = 7
} BcdOSLoaderBootStatusPolicy;

// BcdOSLoaderElementTypes based on geoffchappell: https://www.geoffchappell.com/notes/windows/boot/bcd/elements.htm (dmex)
typedef enum _BcdOSLoaderElementTypes
{
    /// <summary>
    /// The device on which the operating system resides.
    /// </summary>
    /// <remarks>0x21000001</remarks>
    BcdOSLoaderDevice_OSDevice = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_DEVICE, 1),
    /// <summary>
    /// The file path to the operating system (%SystemRoot% minus the volume).
    /// </summary>
    /// <remarks>0x22000002</remarks>
    BcdOSLoaderString_SystemRoot = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 2),
    /// <summary>
    /// The resume application associated with the operating system.
    /// </summary>
    /// <remarks>0x23000003</remarks>
    BcdOSLoaderObject_AssociatedResumeObject = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_OBJECT, 3),
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>0x26000004</remarks>
    BcdOSLoaderBoolean_StampDisks = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 4),
    /// <summary>
    /// Indicates whether the operating system loader should determine the kernel and HAL to load based on the platform features.
    /// </summary>
    /// <remarks>0x26000010</remarks>
    BcdOSLoaderBoolean_DetectKernelAndHal = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 16),
    /// <summary>
    /// The kernel to be loaded by the operating system loader. This value overrides the default kernel.
    /// </summary>
    /// <remarks>0x22000011</remarks>
    BcdOSLoaderString_KernelPath = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 17),
    /// <summary>
    /// The HAL to be loaded by the operating system loader. This value overrides the default HAL.
    /// </summary>
    /// <remarks>0x22000012</remarks>
    BcdOSLoaderString_HalPath = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 18),
    /// <summary>
    /// The transport DLL to be loaded by the operating system loader. This value overrides the default Kdcom.dll.
    /// </summary>
    /// <remarks>0x22000013</remarks>
    BcdOSLoaderString_DbgTransportPath = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 19),
    /// <summary>
    /// The no-execute page protection policy. The Integer property is one of the values from the BcdOSLoader_NxPolicy enumeration.
    /// </summary>
    /// <remarks>0x25000020</remarks>
    BcdOSLoaderInteger_NxPolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 32),
    /// <summary>
    /// The Physical Address Extension (PAE) policy. The Integer property is one of the values from the BcdOSLoader_PAEPolicy enumeration.
    /// </summary>
    /// <remarks>0x25000021</remarks>
    BcdOSLoaderInteger_PAEPolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 33),
    /// <summary>
    /// Indicates that the system should be started in Windows Preinstallation Environment (Windows PE) mode.
    /// </summary>
    /// <remarks>0x26000022</remarks>
    BcdOSLoaderBoolean_WinPEMode = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 34),
    /// <summary>
    /// Indicates that the system should not automatically reboot when it crashes.
    /// </summary>
    /// <remarks>0x26000024</remarks>
    BcdOSLoaderBoolean_DisableCrashAutoReboot = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 36),
    /// <summary>
    /// Indicates that the system should use the last-known good settings.
    /// </summary>
    /// <remarks>0x26000025</remarks>
    BcdOSLoaderBoolean_UseLastGoodSettings = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 37),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x26000026</remarks>
    BcdOSLoaderBoolean_DisableCodeIntegrityChecks = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 38),
    /// <summary>
    /// Indicates whether the test code signing certificate is supported.
    /// </summary>
    /// <remarks>0x26000027</remarks>
    BcdOSLoaderBoolean_AllowPrereleaseSignatures = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 39),
    /// <summary>
    /// Indicates whether the system should utilize the first 4GB of physical memory.
    /// This option requires 5GB of physical memory, and on x86 systems it requires PAE to be enabled.
    /// </summary>
    /// <remarks>0x26000030</remarks>
    BcdOSLoaderBoolean_NoLowMemory = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 48),
    /// <summary>
    /// The amount of memory the system should ignore.
    /// </summary>
    /// <remarks>0x25000031</remarks>
    BcdOSLoaderInteger_RemoveMemory = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 49),
    /// <summary>
    /// The amount of memory that should be utilized by the process address space, in bytes.
    /// This value should be between 2GB and 3GB.
    /// Increasing this value from the default 2GB decreases the amount of virtual address space available to the system and device drivers.
    /// </summary>
    /// <remarks>0x25000032</remarks>
    BcdOSLoaderInteger_IncreaseUserVa = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 50),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000033</remarks>
    BcdOSLoaderInteger_PerformaceDataMemory = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 51),
    /// <summary>
    /// Indicates whether the system should use the standard VGA display driver instead of a high-performance display driver.
    /// </summary>
    /// <remarks>0x26000040</remarks>
    BcdOSLoaderBoolean_UseVgaDriver = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 64),
    /// <summary>
    /// Indicates whether the system should initialize the VGA driver responsible for displaying simple graphics during the boot process.
    /// If not, there is no display is presented during the boot process.
    /// </summary>
    /// <remarks>0x26000041</remarks>
    BcdOSLoaderBoolean_DisableBootDisplay = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 65),
    /// <summary>
    /// Indicates whether the VGA driver should avoid VESA BIOS calls.
    /// Note This value is ignored by Windows 8 and Windows Server 2012.
    /// </summary>
    /// <remarks>0x26000042</remarks>
    BcdOSLoaderBoolean_DisableVesaBios = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 66),
    /// <summary>
    /// Disables the use of VGA modes in the OS.
    /// </summary>
    /// <remarks>0x26000043</remarks>
    BcdOSLoaderBoolean_DisableVgaMode = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 67),
    /// <summary>
    /// Indicates that cluster-mode APIC addressing should be utilized, and the value is the maximum number of processors per cluster.
    /// </summary>
    /// <remarks>0x25000050</remarks>
    BcdOSLoaderInteger_ClusterModeAddressing = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 80),
    /// <summary>
    /// Indicates whether to enable physical-destination mode for all APIC messages.
    /// </summary>
    /// <remarks>0x26000051</remarks>
    BcdOSLoaderBoolean_UsePhysicalDestination = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 81),
    /// <summary>
    /// The maximum number of APIC clusters that should be used by cluster-mode addressing.
    /// </summary>
    /// <remarks>0x25000052</remarks>
    BcdOSLoaderInteger_RestrictApicCluster = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 82),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x22000053</remarks>
    BcdOSLoaderString_OSLoaderTypeEVStore = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 83),
    /// <summary>
    /// Used to force legacy APIC mode, even if the processors and chipset support extended APIC mode.
    /// </summary>
    /// <remarks>0x26000054</remarks>
    BcdOSLoaderBoolean_UseLegacyApicMode = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 84),
    /// <summary>
    /// Enables the use of extended APIC mode, if supported.
    /// Zero (0) indicates default behavior, one (1) indicates that extended APIC mode is disabled, and two (2) indicates that extended APIC mode is enabled.
    /// The system defaults to using extended APIC mode if available.
    /// </summary>
    /// <remarks>0x25000055</remarks>
    BcdOSLoaderInteger_X2ApicPolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 85),
    /// <summary>
    /// Indicates whether the operating system should initialize or start non-boot processors.
    /// </summary>
    /// <remarks>0x26000060</remarks>
    BcdOSLoaderBoolean_UseBootProcessorOnly = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 96),
    /// <summary>
    /// The maximum number of processors that can be utilized by the system; all other processors are ignored.
    /// </summary>
    /// <remarks>0x25000061</remarks>
    BcdOSLoaderInteger_NumberOfProcessors = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 97),
    /// <summary>
    /// Indicates whether the system should use the maximum number of processors.
    /// </summary>
    /// <remarks>0x26000062</remarks>
    BcdOSLoaderBoolean_ForceMaximumProcessors = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 98),
    /// <summary>
    /// Indicates whether processor specific configuration flags are to be used.
    /// </summary>
    /// <remarks>0x25000063</remarks>
    BcdOSLoaderBoolean_ProcessorConfigurationFlags = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 99),
    /// <summary>
    /// Maximizes the number of groups created when assigning nodes to processor groups.
    /// </summary>
    /// <remarks>0x26000064</remarks>
    BcdOSLoaderBoolean_MaximizeGroupsCreated = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 100),
    /// <summary>
    /// This setting makes drivers group aware and can be used to determine improper group usage.
    /// </summary>
    /// <remarks>0x26000065</remarks>
    BcdOSLoaderBoolean_ForceGroupAwareness = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 101),
    /// <summary>
    /// Specifies the size of all processor groups. Must be set to a power of 2.
    /// </summary>
    /// <remarks>0x25000066</remarks>
    BcdOSLoaderInteger_GroupSize = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 102),
    /// <summary>
    /// Indicates whether the system should use I/O and IRQ resources created by the system firmware instead of using dynamically configured resources.
    /// </summary>
    /// <remarks>0x26000070</remarks>
    BcdOSLoaderInteger_UseFirmwarePciSettings = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 112),
    /// <summary>
    /// The PCI Message Signaled Interrupt (MSI) policy. Zero (0) indicates default, and one (1) indicates that MSI interrupts are disabled.
    /// </summary>
    /// <remarks>0x25000071</remarks>
    BcdOSLoaderInteger_MsiPolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 113),
    /// <summary>
    /// Undocumented. Zero (0) indicates default, and one (1) indicates that PCI Express is forcefully disabled.
    /// </summary>
    /// <remarks>0x25000072</remarks>
    BcdOSLoaderInteger_PciExpressPolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 114),
    /// <summary>
    /// The Integer property is one of the values from the BcdLibrary_SafeBoot enumeration.
    /// </summary>
    /// <remarks>0x25000080</remarks>
    BcdOSLoaderInteger_SafeBoot = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 128),
    /// <summary>
    /// Indicates whether the system should use the shell specified under the following registry key instead of the default shell:
    /// HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SafeBoot\AlternateShell.
    /// </summary>
    /// <remarks>0x26000081</remarks>
    BcdOSLoaderBoolean_SafeBootAlternateShell = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 129),
    /// <summary>
    /// Indicates whether the system should write logging information to %SystemRoot%\Ntbtlog.txt during initialization.
    /// </summary>
    /// <remarks>0x26000090</remarks>
    BcdOSLoaderBoolean_BootLogInitialization = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 144),
    /// <summary>
    /// Indicates whether the system should display verbose information.
    /// </summary>
    /// <remarks>0x26000091</remarks>
    BcdOSLoaderBoolean_VerboseObjectLoadMode = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 145),
    /// <summary>
    /// Indicates whether the kernel debugger should be enabled using the settings in the inherited debugger object.
    /// </summary>
    /// <remarks>0x260000A0</remarks>
    BcdOSLoaderBoolean_KernelDebuggerEnabled = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 160),
    /// <summary>
    /// Indicates whether the HAL should call DbgBreakPoint at the start of HalInitSystem for phase 0 initialization of the kernel.
    /// </summary>
    /// <remarks>0x260000A1</remarks>
    BcdOSLoaderBoolean_DebuggerHalBreakpoint = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 161),
    /// <summary>
    /// Forces the use of the platform clock as the system's performance counter.
    /// </summary>
    /// <remarks>0x260000A2</remarks>
    BcdOSLoaderBoolean_UsePlatformClock = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 162),
    /// <summary>
    /// Forces the OS to assume the presence of legacy PC devices like CMOS and keyboard controllers.
    /// This value should only be used for debugging.
    /// </summary>
    /// <remarks>0x260000A3</remarks>
    BcdOSLoaderBoolean_ForceLegacyPlatform = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 163),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x260000A4</remarks>
    BcdOSLoaderBoolean_UsePlatformTick = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 164),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x260000A5</remarks>
    BcdOSLoaderBoolean_DisableDynamicTick = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 165),
    /// <summary>
    /// Controls the TSC synchronization policy. Possible values include default (0), legacy (1), or enhanced (2).
    /// This value is supported starting in Windows 8 and Windows Server 2012.
    /// </summary>
    /// <remarks>0x250000A6</remarks>
    BcdOSLoaderInteger_TscSyncPolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 166),
    /// <summary>
    /// Indicates whether EMS should be enabled in the kernel.
    /// </summary>
    /// <remarks>0x260000B0</remarks>
    BcdOSLoaderBoolean_EmsEnabled = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 176),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x250000C0</remarks>
    BcdOSLoaderInteger_ForceFailure = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 192),
    /// <summary>
    /// Indicates the driver load failure policy. Zero (0) indicates that a failed driver load is fatal and the boot will not continue,
    /// one (1) indicates that the standard error control is used.
    /// </summary>
    /// <remarks>0x250000C1</remarks>
    BcdOSLoaderInteger_DriverLoadFailurePolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 193),
    /// <summary>
    /// Defines the type of boot menus the system will use. Possible values include menupolicylegacy (0) or menupolicystandard (1).
    /// The default value is menupolicylegacy (0).
    /// </summary>
    /// <remarks>0x250000C2</remarks>
    BcdOSLoaderInteger_BootMenuPolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 194),
    /// <summary>
    /// Controls whether the system boots to the legacy menu (F8 menu) on the next boot.
    /// Note This value is supported starting in Windows 8 and Windows Server 2012.
    /// </summary>
    /// <remarks>0x260000C3</remarks>
    BcdOSLoaderBoolean_AdvancedOptionsOneTime = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 195),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x260000C4</remarks>
    BcdOSLoaderBoolean_OptionsEditOneTime = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 196),
    /// <summary>
    /// The boot status policy. The Integer property is one of the values from the BcdOSLoaderBootStatusPolicy enumeration
    /// </summary>
    /// <remarks>0x250000E0</remarks>
    BcdOSLoaderInteger_BootStatusPolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 224),
    /// <summary>
    /// The OS loader removes this entry for security reasons. This option can only be triggered by using the F8 menu; a user must be physically present to trigger this option.
    /// This value is supported starting in Windows 8 and Windows Server 2012.
    /// </summary>
    /// <remarks>0x260000E1</remarks>
    BcdOSLoaderBoolean_DisableElamDrivers = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 225),
    /// <summary>
    /// Controls the hypervisor launch type. Options are HyperVisorLaunchOff (0) and HypervisorLaunchAuto (1).
    /// </summary>
    /// <remarks>0x250000F0</remarks>
    BcdOSLoaderInteger_HypervisorLaunchType = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 240),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x250000F1</remarks>
    BcdOSLoaderString_HypervisorPath = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 241),
    /// <summary>
    /// Controls whether the hypervisor debugger is enabled.
    /// </summary>
    /// <remarks>0x260000F2</remarks>
    BcdOSLoaderBoolean_HypervisorDebuggerEnabled = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 242),
    /// <summary>
    /// Controls the hypervisor debugger type. Can be set to SERIAL (0), 1394 (1), or NET (2).
    /// </summary>
    /// <remarks>0x250000F3</remarks>
    BcdOSLoaderInteger_HypervisorDebuggerType = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 243),
    /// <summary>
    /// Specifies the serial port number for serial debugging.
    /// </summary>
    /// <remarks>0x250000F4</remarks>
    BcdOSLoaderInteger_HypervisorDebuggerPortNumber = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 244),
    /// <summary>
    /// Specifies the baud rate for serial debugging.
    /// </summary>
    /// <remarks>0x250000F5</remarks>
    BcdOSLoaderInteger_HypervisorDebuggerBaudrate = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 245),
    /// <summary>
    /// Specifies the channel number for 1394 debugging.
    /// </summary>
    /// <remarks>0x250000F6</remarks>
    BcdOSLoaderInteger_HypervisorDebugger1394Channel = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 246),
    /// <summary>
    /// Values are Disabled (0), Basic (1), and Standard (2).
    /// </summary>
    /// <remarks>0x250000F7</remarks>
    BcdOSLoaderInteger_BootUxPolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 247),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x220000F8</remarks>
    BcdOSLoaderInteger_HypervisorSlatDisabled = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 248),
    /// <summary>
    /// Defines the PCI bus, device, and function numbers of the debugging device used with the hypervisor.
    /// For example, 1.5.0 describes the debugging device on bus 1, device 5, function 0.
    /// </summary>
    /// <remarks>0x220000F9</remarks>
    BcdOSLoaderString_HypervisorDebuggerBusParams = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 249),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x250000FA</remarks>
    BcdOSLoaderInteger_HypervisorNumProc = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 250),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x250000FB</remarks>
    BcdOSLoaderInteger_HypervisorRootProcPerNode = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 251),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x260000FC</remarks>
    BcdOSLoaderBoolean_HypervisorUseLargeVTlb = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 252),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x250000FD</remarks>
    BcdOSLoaderInteger_HypervisorDebuggerNetHostIp = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 253),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x250000FE</remarks>
    BcdOSLoaderInteger_HypervisorDebuggerNetHostPort = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 254),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x250000FF</remarks>
    BcdOSLoaderInteger_HypervisorDebuggerPages = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 255),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000100</remarks>
    BcdOSLoaderInteger_TpmBootEntropyPolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 256),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x22000110</remarks>
    BcdOSLoaderString_HypervisorDebuggerNetKey = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 272),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x22000112</remarks>
    BcdOSLoaderString_HypervisorProductSkuType = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 274),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x22000113</remarks>
    BcdOSLoaderInteger_HypervisorRootProc = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 275),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x26000114</remarks>
    BcdOSLoaderBoolean_HypervisorDebuggerNetDhcp = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 276),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000115</remarks>
    BcdOSLoaderInteger_HypervisorIommuPolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 277),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x26000116</remarks>
    BcdOSLoaderBoolean_HypervisorUseVApic = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 278),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x22000117</remarks>
    BcdOSLoaderString_HypervisorLoadOptions = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 279),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000118</remarks>
    BcdOSLoaderInteger_HypervisorMsrFilterPolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 280),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000119</remarks>
    BcdOSLoaderInteger_HypervisorMmioNxPolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 281),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x2500011A</remarks>
    BcdOSLoaderInteger_HypervisorSchedulerType = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 282),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x2200011B</remarks>
    BcdOSLoaderString_HypervisorRootProcNumaNodes = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 283),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x2500011C</remarks>
    BcdOSLoaderInteger_HypervisorPerfmon = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 284),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x2500011D</remarks>
    BcdOSLoaderInteger_HypervisorRootProcPerCore = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 285),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x2200011E</remarks>
    BcdOSLoaderString_HypervisorRootProcNumaNodeLps = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 286),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000120</remarks>
    BcdOSLoaderInteger_XSavePolicy = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 288),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000121</remarks>
    BcdOSLoaderInteger_XSaveAddFeature0 = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 289),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000122</remarks>
    BcdOSLoaderInteger_XSaveAddFeature1 = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 290),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000123</remarks>
    BcdOSLoaderInteger_XSaveAddFeature2 = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 291),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000124</remarks>
    BcdOSLoaderInteger_XSaveAddFeature3 = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 292),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000125</remarks>
    BcdOSLoaderInteger_XSaveAddFeature4 = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 293),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000126</remarks>
    BcdOSLoaderInteger_XSaveAddFeature5 = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 294),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000127</remarks>
    BcdOSLoaderInteger_XSaveAddFeature6 = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 295),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000128</remarks>
    BcdOSLoaderInteger_XSaveAddFeature7 = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 296),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000129</remarks>
    BcdOSLoaderInteger_XSaveRemoveFeature = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 297),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x2500012A</remarks>
    BcdOSLoaderInteger_XSaveProcessorsMask = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 298),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x2500012B</remarks>
    BcdOSLoaderInteger_XSaveDisable = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 299),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x2500012C</remarks>
    BcdOSLoaderInteger_KernelDebuggerType = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 300),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x2200012D</remarks>
    BcdOSLoaderString_KernelDebuggerBusParameters = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 301),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x2500012E</remarks>
    BcdOSLoaderInteger_KernelDebuggerPortAddress = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 302),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x2500012F</remarks>
    BcdOSLoaderInteger_KernelDebuggerPortNumber = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 303),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000130</remarks>
    BcdOSLoaderInteger_ClaimedTpmCounter = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 304),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000131</remarks>
    BcdOSLoaderInteger_KernelDebugger1394Channel = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 305),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x22000132</remarks>
    BcdOSLoaderString_KernelDebuggerUsbTargetname = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 306),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000133</remarks>
    BcdOSLoaderInteger_KernelDebuggerNetHostIp = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 307),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000134</remarks>
    BcdOSLoaderInteger_KernelDebuggerNetHostPort = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 308),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x26000135</remarks>
    BcdOSLoaderBoolean_KernelDebuggerNetDhcp = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 309),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x22000136</remarks>
    BcdOSLoaderString_KernelDebuggerNetKey = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 310),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x22000137</remarks>
    BcdOSLoaderString_IMCHiveName = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 311),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x21000138</remarks>
    BcdOSLoaderDevice_IMCDevice = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_DEVICE, 312),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000139</remarks>
    BcdOSLoaderInteger_KernelDebuggerBaudrate = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 313),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x22000140</remarks>
    BcdOSLoaderString_ManufacturingMode = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 320),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x26000141</remarks>
    BcdOSLoaderBoolean_EventLoggingEnabled = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 321),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x25000142</remarks>
    BcdOSLoaderInteger_VsmLaunchType = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 322),
    /// <summary>
    /// Undocumented. Zero (0) indicates default, one (1) indicates that disabled and two (2) indicates strict mode.
    /// </summary>
    /// <remarks>0x25000144</remarks>
    BcdOSLoaderInteger_HypervisorEnforcedCodeIntegrity = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_INTEGER, 324),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x26000145</remarks>
    BcdOSLoaderBoolean_DtraceEnabled = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN, 325),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x21000150</remarks>
    BcdOSLoaderDevice_SystemDataDevice = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_DEVICE, 336),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x21000151</remarks>
    BcdOSLoaderDevice_OsArcDevice = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_DEVICE, 337),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x21000153</remarks>
    BcdOSLoaderDevice_OsDataDevice = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_DEVICE, 339),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x21000154</remarks>
    BcdOSLoaderDevice_BspDevice = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_DEVICE, 340),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x21000155</remarks>
    BcdOSLoaderDevice_BspFilepath = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_DEVICE, 341),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x22000156</remarks>
    BcdOSLoaderString_KernelDebuggerNetHostIpv6 = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 342),
    /// <summary>
    ///
    /// </summary>
    /// <remarks>0x22000161</remarks>
    BcdOSLoaderString_HypervisorDebuggerNetHostIpv6 = MAKE_BCDE_DATA_TYPE(BCD_ELEMENT_DATATYPE_CLASS_APPLICATION, BCD_ELEMENT_DATATYPE_FORMAT_STRING, 353),
} BcdOSLoaderElementTypes;

#endif

```

`phnt/ntd3dkmt.h`:

```h
/*
 * Process Hacker -
 *   Direct3D kernel support functions
 *
 * This file is part of Process Hacker.
 *
 * Process Hacker is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Process Hacker is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Process Hacker.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef _NTD3DKMT_H
#define _NTD3DKMT_H

#define USE_D3DKMT_SINGLE_HEADER

#ifndef USE_D3DKMT_SINGLE_HEADER
#include <dxmini.h>
#include <d3dkmddi.h>

typedef D3DKMT_HANDLE *PD3DKMT_HANDLE;
#else
typedef UINT32 D3DKMT_HANDLE;
typedef D3DKMT_HANDLE *PD3DKMT_HANDLE;
#endif

typedef enum _KMTQUERYADAPTERINFOTYPE
{
    KMTQAITYPE_UMDRIVERPRIVATE,
    KMTQAITYPE_UMDRIVERNAME, // D3DKMT_UMDFILENAMEINFO
    KMTQAITYPE_UMOPENGLINFO, // D3DKMT_OPENGLINFO
    KMTQAITYPE_GETSEGMENTSIZE, // D3DKMT_SEGMENTSIZEINFO
    KMTQAITYPE_ADAPTERGUID, // GUID
    KMTQAITYPE_FLIPQUEUEINFO, // D3DKMT_FLIPQUEUEINFO
    KMTQAITYPE_ADAPTERADDRESS, // D3DKMT_ADAPTERADDRESS
    KMTQAITYPE_SETWORKINGSETINFO, // D3DKMT_WORKINGSETINFO
    KMTQAITYPE_ADAPTERREGISTRYINFO, // D3DKMT_ADAPTERREGISTRYINFO
    KMTQAITYPE_CURRENTDISPLAYMODE, // D3DKMT_CURRENTDISPLAYMODE
    KMTQAITYPE_MODELIST, // D3DKMT_DISPLAYMODE[] // 10
    KMTQAITYPE_CHECKDRIVERUPDATESTATUS,
    KMTQAITYPE_VIRTUALADDRESSINFO, // D3DKMT_VIRTUALADDRESSINFO
    KMTQAITYPE_DRIVERVERSION, // D3DKMT_DRIVERVERSION
    KMTQAITYPE_UNKNOWN,
    KMTQAITYPE_ADAPTERTYPE, // D3DKMT_ADAPTERTYPE // since WIN8
    KMTQAITYPE_OUTPUTDUPLCONTEXTSCOUNT, // D3DKMT_OUTPUTDUPLCONTEXTSCOUNT
    KMTQAITYPE_WDDM_1_2_CAPS, // D3DKMT_WDDM_1_2_CAPS
    KMTQAITYPE_UMD_DRIVER_VERSION, // D3DKMT_UMD_DRIVER_VERSION
    KMTQAITYPE_DIRECTFLIP_SUPPORT, // D3DKMT_DIRECTFLIP_SUPPORT
    KMTQAITYPE_MULTIPLANEOVERLAY_SUPPORT, // D3DKMT_MULTIPLANEOVERLAY_SUPPORT // since WDDM1_3 // 20
    KMTQAITYPE_DLIST_DRIVER_NAME, // D3DKMT_DLIST_DRIVER_NAME
    KMTQAITYPE_WDDM_1_3_CAPS, // D3DKMT_WDDM_1_3_CAPS
    KMTQAITYPE_MULTIPLANEOVERLAY_HUD_SUPPORT, // D3DKMT_MULTIPLANEOVERLAY_HUD_SUPPORT
    KMTQAITYPE_WDDM_2_0_CAPS, // D3DKMT_WDDM_2_0_CAPS // since WDDM2_0
    KMTQAITYPE_NODEMETADATA, // D3DKMT_NODEMETADATA
    KMTQAITYPE_CPDRIVERNAME, // D3DKMT_CPDRIVERNAME
    KMTQAITYPE_XBOX, // D3DKMT_XBOX
    KMTQAITYPE_INDEPENDENTFLIP_SUPPORT, // D3DKMT_INDEPENDENTFLIP_SUPPORT
    KMTQAITYPE_MIRACASTCOMPANIONDRIVERNAME, // D3DKMT_MIRACASTCOMPANIONDRIVERNAME
    KMTQAITYPE_PHYSICALADAPTERCOUNT, // D3DKMT_PHYSICAL_ADAPTER_COUNT // 30
    KMTQAITYPE_PHYSICALADAPTERDEVICEIDS, // D3DKMT_QUERY_DEVICE_IDS
    KMTQAITYPE_DRIVERCAPS_EXT, // D3DKMT_DRIVERCAPS_EXT
    KMTQAITYPE_QUERY_MIRACAST_DRIVER_TYPE, // D3DKMT_QUERY_MIRACAST_DRIVER_TYPE
    KMTQAITYPE_QUERY_GPUMMU_CAPS, // D3DKMT_QUERY_GPUMMU_CAPS
    KMTQAITYPE_QUERY_MULTIPLANEOVERLAY_DECODE_SUPPORT, // D3DKMT_MULTIPLANEOVERLAY_DECODE_SUPPORT
    KMTQAITYPE_QUERY_HW_PROTECTION_TEARDOWN_COUNT, // UINT32
    KMTQAITYPE_QUERY_ISBADDRIVERFORHWPROTECTIONDISABLED, // D3DKMT_ISBADDRIVERFORHWPROTECTIONDISABLED
    KMTQAITYPE_MULTIPLANEOVERLAY_SECONDARY_SUPPORT, // D3DKMT_MULTIPLANEOVERLAY_SECONDARY_SUPPORT
    KMTQAITYPE_INDEPENDENTFLIP_SECONDARY_SUPPORT, // D3DKMT_INDEPENDENTFLIP_SECONDARY_SUPPORT
    KMTQAITYPE_PANELFITTER_SUPPORT, // D3DKMT_PANELFITTER_SUPPORT // since WDDM2_1 // 40
    KMTQAITYPE_PHYSICALADAPTERPNPKEY, // D3DKMT_QUERY_PHYSICAL_ADAPTER_PNP_KEY // since WDDM2_2
    KMTQAITYPE_GETSEGMENTGROUPSIZE, // D3DKMT_SEGMENTGROUPSIZEINFO
    KMTQAITYPE_MPO3DDI_SUPPORT, // D3DKMT_MPO3DDI_SUPPORT
    KMTQAITYPE_HWDRM_SUPPORT, // D3DKMT_HWDRM_SUPPORT
    KMTQAITYPE_MPOKERNELCAPS_SUPPORT, // D3DKMT_MPOKERNELCAPS_SUPPORT
    KMTQAITYPE_MULTIPLANEOVERLAY_STRETCH_SUPPORT, // D3DKMT_MULTIPLANEOVERLAY_STRETCH_SUPPORT
    KMTQAITYPE_GET_DEVICE_VIDPN_OWNERSHIP_INFO, // D3DKMT_GET_DEVICE_VIDPN_OWNERSHIP_INFO
    KMTQAITYPE_QUERYREGISTRY, // D3DDDI_QUERYREGISTRY_INFO // since WDDM2_4
    KMTQAITYPE_KMD_DRIVER_VERSION, // D3DKMT_KMD_DRIVER_VERSION
    KMTQAITYPE_BLOCKLIST_KERNEL, // D3DKMT_BLOCKLIST_INFO // 50
    KMTQAITYPE_BLOCKLIST_RUNTIME, // D3DKMT_BLOCKLIST_INFO
    KMTQAITYPE_ADAPTERGUID_RENDER, // GUID
    KMTQAITYPE_ADAPTERADDRESS_RENDER, // D3DKMT_ADAPTERADDRESS
    KMTQAITYPE_ADAPTERREGISTRYINFO_RENDER, // D3DKMT_ADAPTERREGISTRYINFO
    KMTQAITYPE_CHECKDRIVERUPDATESTATUS_RENDER,
    KMTQAITYPE_DRIVERVERSION_RENDER, // D3DKMT_DRIVERVERSION
    KMTQAITYPE_ADAPTERTYPE_RENDER, // D3DKMT_ADAPTERTYPE
    KMTQAITYPE_WDDM_1_2_CAPS_RENDER, // D3DKMT_WDDM_1_2_CAPS
    KMTQAITYPE_WDDM_1_3_CAPS_RENDER, // D3DKMT_WDDM_1_3_CAPS
    KMTQAITYPE_QUERY_ADAPTER_UNIQUE_GUID, // D3DKMT_QUERY_ADAPTER_UNIQUE_GUID // 60
    KMTQAITYPE_NODEPERFDATA, // D3DKMT_NODE_PERFDATA
    KMTQAITYPE_ADAPTERPERFDATA, // D3DKMT_ADAPTER_PERFDATA
    KMTQAITYPE_ADAPTERPERFDATA_CAPS, // D3DKMT_ADAPTER_PERFDATACAPS
    KMTQUITYPE_GPUVERSION, // D3DKMT_GPUVERSION
    KMTQAITYPE_DRIVER_DESCRIPTION, // D3DKMT_DRIVER_DESCRIPTION // since WDDM2_6
    KMTQAITYPE_DRIVER_DESCRIPTION_RENDER, // D3DKMT_DRIVER_DESCRIPTION
    KMTQAITYPE_SCANOUT_CAPS, // D3DKMT_QUERY_SCANOUT_CAPS
    KMTQAITYPE_DISPLAY_UMDRIVERNAME,
    KMTQAITYPE_PARAVIRTUALIZATION_RENDER,
    KMTQAITYPE_SERVICENAME, // 70
    KMTQAITYPE_WDDM_2_7_CAPS, // D3DKMT_WDDM_2_7_CAPS // since WDDM2_7
    KMTQAITYPE_TRACKEDWORKLOAD_SUPPORT,
    KMTQAITYPE_HYBRID_DLIST_DLL_SUPPORT,
    KMTQAITYPE_DISPLAY_CAPS,
    KMTQAITYPE_WDDM_2_9_CAPS,
    KMTQAITYPE_CROSSADAPTERRESOURCE_SUPPORT,
    KMTQAITYPE_WDDM_3_0_CAPS
} KMTQUERYADAPTERINFOTYPE;

typedef enum _KMTUMDVERSION
{
    KMTUMDVERSION_DX9,
    KMTUMDVERSION_DX10,
    KMTUMDVERSION_DX11,
    KMTUMDVERSION_DX12,
    NUM_KMTUMDVERSIONS
} KMTUMDVERSION;

// The D3DKMT_UMDFILENAMEINFO structure contains the name of an OpenGL ICD that is based on the specified version of the DirectX runtime.
typedef struct _D3DKMT_UMDFILENAMEINFO
{
    _In_ KMTUMDVERSION Version; // A KMTUMDVERSION-typed value that indicates the version of the DirectX runtime to retrieve the name of an OpenGL ICD for.
    _Out_ WCHAR UmdFileName[MAX_PATH]; // A string that contains the name of the OpenGL ICD.
} D3DKMT_UMDFILENAMEINFO;

// The D3DKMT_OPENGLINFO structure describes OpenGL installable client driver (ICD) information.
typedef struct _D3DKMT_OPENGLINFO
{
    _Out_ WCHAR UmdOpenGlIcdFileName[MAX_PATH]; // An array of wide characters that contains the file name of the OpenGL ICD.
    _Out_ ULONG Version; // The version of the OpenGL ICD.
    _In_ ULONG Flags; // This member is currently unused.
} D3DKMT_OPENGLINFO;

// The D3DKMT_SEGMENTSIZEINFO structure describes the size, in bytes, of memory and aperture segments.
typedef struct _D3DKMT_SEGMENTSIZEINFO
{
    _Out_ ULONGLONG DedicatedVideoMemorySize; // The size, in bytes, of memory that is dedicated from video memory.
    _Out_ ULONGLONG DedicatedSystemMemorySize; // The size, in bytes, of memory that is dedicated from system memory.
    _Out_ ULONGLONG SharedSystemMemorySize; // The size, in bytes, of memory from system memory that can be shared by many users.
} D3DKMT_SEGMENTSIZEINFO;

// The D3DKMT_FLIPINFOFLAGS structure identifies flipping capabilities of the display miniport driver.
typedef struct _D3DKMT_FLIPINFOFLAGS 
{
    UINT32 FlipInterval : 1; // A UINT value that specifies whether the display miniport driver natively supports the scheduling of a flip command to take effect after two, three or four vertical syncs occur. 
    UINT32 Reserved : 31;
} D3DKMT_FLIPINFOFLAGS;

// The D3DKMT_FLIPQUEUEINFO structure describes information about the graphics adapter's queue of flip operations.
typedef struct _D3DKMT_FLIPQUEUEINFO 
{
    _Out_ UINT32 MaxHardwareFlipQueueLength; // The maximum number of flip operations that can be queued for hardware-flip queuing.
    _Out_ UINT32 MaxSoftwareFlipQueueLength; // The maximum number of flip operations that can be queued for software-flip queuing on hardware that supports memory mapped I/O (MMIO)-based flips.
    _Out_ D3DKMT_FLIPINFOFLAGS FlipFlags; // indicates, in bit-field flags, flipping capabilities.
} D3DKMT_FLIPQUEUEINFO;

// The D3DKMT_ADAPTERADDRESS structure describes the physical location of the graphics adapter.
typedef struct _D3DKMT_ADAPTERADDRESS 
{
    _Out_ UINT32 BusNumber; // The number of the bus that the graphics adapter's physical device is located on.
    _Out_ UINT32 DeviceNumber; // The index of the graphics adapter's physical device on the bus.
    _Out_ UINT32 FunctionNumber; // The function number of the graphics adapter on the physical device.
} D3DKMT_ADAPTERADDRESS;

typedef struct _D3DKMT_WORKINGSETFLAGS
{
    UINT32 UseDefault : 1; // A UINT value that specifies whether the display miniport driver uses the default working set.
    UINT32 Reserved : 31; // This member is reserved and should be set to zero.
} D3DKMT_WORKINGSETFLAGS;

// The D3DKMT_WORKINGSETINFO structure describes information about the graphics adapter's working set.
typedef struct _D3DKMT_WORKINGSETINFO
{
    _Out_ D3DKMT_WORKINGSETFLAGS Flags; // A D3DKMT_WORKINGSETFLAGS structure that indicates, in bit-field flags, working-set properties.
    _Out_ ULONG MinimumWorkingSetPercentile; // The minimum working-set percentile.
    _Out_ ULONG MaximumWorkingSetPercentile; // The maximum working-set percentile.
} D3DKMT_WORKINGSETINFO;

// The D3DKMT_ADAPTERREGISTRYINFO structure contains registry information about the graphics adapter.
typedef struct _D3DKMT_ADAPTERREGISTRYINFO 
{
    _Out_ WCHAR AdapterString[MAX_PATH]; // A string that contains the name of the graphics adapter.
    _Out_ WCHAR BiosString[MAX_PATH]; // A string that contains the name of the BIOS for the graphics adapter.
    _Out_ WCHAR DacType[MAX_PATH]; // A string that contains the DAC type for the graphics adapter.
    _Out_ WCHAR ChipType[MAX_PATH]; // A string that contains the chip type for the graphics adapter.
} D3DKMT_ADAPTERREGISTRYINFO;

#ifdef USE_D3DKMT_SINGLE_HEADER
#ifndef MAKEFOURCC
#define MAKEFOURCC(ch0, ch1, ch2, ch3)                              \
                ((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) |       \
                ((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24 ))
#endif

typedef enum _D3DDDIFORMAT
{
    D3DDDIFMT_UNKNOWN = 0,
    D3DDDIFMT_R8G8B8 = 20,
    D3DDDIFMT_A8R8G8B8 = 21,
    D3DDDIFMT_X8R8G8B8 = 22,
    D3DDDIFMT_R5G6B5 = 23,
    D3DDDIFMT_X1R5G5B5 = 24,
    D3DDDIFMT_A1R5G5B5 = 25,
    D3DDDIFMT_A4R4G4B4 = 26,
    D3DDDIFMT_R3G3B2 = 27,
    D3DDDIFMT_A8 = 28,
    D3DDDIFMT_A8R3G3B2 = 29,
    D3DDDIFMT_X4R4G4B4 = 30,
    D3DDDIFMT_A2B10G10R10 = 31,
    D3DDDIFMT_A8B8G8R8 = 32,
    D3DDDIFMT_X8B8G8R8 = 33,
    D3DDDIFMT_G16R16 = 34,
    D3DDDIFMT_A2R10G10B10 = 35,
    D3DDDIFMT_A16B16G16R16 = 36,
    D3DDDIFMT_A8P8 = 40,
    D3DDDIFMT_P8 = 41,
    D3DDDIFMT_L8 = 50,
    D3DDDIFMT_A8L8 = 51,
    D3DDDIFMT_A4L4 = 52,
    D3DDDIFMT_V8U8 = 60,
    D3DDDIFMT_L6V5U5 = 61,
    D3DDDIFMT_X8L8V8U8 = 62,
    D3DDDIFMT_Q8W8V8U8 = 63,
    D3DDDIFMT_V16U16 = 64,
    D3DDDIFMT_W11V11U10 = 65,
    D3DDDIFMT_A2W10V10U10 = 67,

    D3DDDIFMT_UYVY = MAKEFOURCC('U', 'Y', 'V', 'Y'),
    D3DDDIFMT_R8G8_B8G8 = MAKEFOURCC('R', 'G', 'B', 'G'),
    D3DDDIFMT_YUY2 = MAKEFOURCC('Y', 'U', 'Y', '2'),
    D3DDDIFMT_G8R8_G8B8 = MAKEFOURCC('G', 'R', 'G', 'B'),
    D3DDDIFMT_DXT1 = MAKEFOURCC('D', 'X', 'T', '1'),
    D3DDDIFMT_DXT2 = MAKEFOURCC('D', 'X', 'T', '2'),
    D3DDDIFMT_DXT3 = MAKEFOURCC('D', 'X', 'T', '3'),
    D3DDDIFMT_DXT4 = MAKEFOURCC('D', 'X', 'T', '4'),
    D3DDDIFMT_DXT5 = MAKEFOURCC('D', 'X', 'T', '5'),

    D3DDDIFMT_D16_LOCKABLE = 70,
    D3DDDIFMT_D32 = 71,
    D3DDDIFMT_D15S1 = 73,
    D3DDDIFMT_D24S8 = 75,
    D3DDDIFMT_D24X8 = 77,
    D3DDDIFMT_D24X4S4 = 79,
    D3DDDIFMT_D16 = 80,
    D3DDDIFMT_D32F_LOCKABLE = 82,
    D3DDDIFMT_D24FS8 = 83,
    D3DDDIFMT_D32_LOCKABLE = 84,
    D3DDDIFMT_S8_LOCKABLE = 85,
    D3DDDIFMT_S1D15 = 72,
    D3DDDIFMT_S8D24 = 74,
    D3DDDIFMT_X8D24 = 76,
    D3DDDIFMT_X4S4D24 = 78,
    D3DDDIFMT_L16 = 81,
    D3DDDIFMT_G8R8 = 91, // WDDM1_3
    D3DDDIFMT_R8 = 92, // WDDM1_3
    D3DDDIFMT_VERTEXDATA = 100,
    D3DDDIFMT_INDEX16 = 101,
    D3DDDIFMT_INDEX32 = 102,
    D3DDDIFMT_Q16W16V16U16 = 110,

    D3DDDIFMT_MULTI2_ARGB8 = MAKEFOURCC('M', 'E', 'T', '1'),

    // Floating point surface formats

    // s10e5 formats (16-bits per channel)
    D3DDDIFMT_R16F = 111,
    D3DDDIFMT_G16R16F = 112,
    D3DDDIFMT_A16B16G16R16F = 113,

    // IEEE s23e8 formats (32-bits per channel)
    D3DDDIFMT_R32F = 114,
    D3DDDIFMT_G32R32F = 115,
    D3DDDIFMT_A32B32G32R32F = 116,

    D3DDDIFMT_CxV8U8 = 117,

    // Monochrome 1 bit per pixel format
    D3DDDIFMT_A1 = 118,

    // 2.8 biased fixed point
    D3DDDIFMT_A2B10G10R10_XR_BIAS = 119,

    // Decode compressed buffer formats
    D3DDDIFMT_DXVACOMPBUFFER_BASE = 150,
    D3DDDIFMT_PICTUREPARAMSDATA = D3DDDIFMT_DXVACOMPBUFFER_BASE + 0,    // 150
    D3DDDIFMT_MACROBLOCKDATA = D3DDDIFMT_DXVACOMPBUFFER_BASE + 1,    // 151
    D3DDDIFMT_RESIDUALDIFFERENCEDATA = D3DDDIFMT_DXVACOMPBUFFER_BASE + 2,    // 152
    D3DDDIFMT_DEBLOCKINGDATA = D3DDDIFMT_DXVACOMPBUFFER_BASE + 3,    // 153
    D3DDDIFMT_INVERSEQUANTIZATIONDATA = D3DDDIFMT_DXVACOMPBUFFER_BASE + 4,    // 154
    D3DDDIFMT_SLICECONTROLDATA = D3DDDIFMT_DXVACOMPBUFFER_BASE + 5,    // 155
    D3DDDIFMT_BITSTREAMDATA = D3DDDIFMT_DXVACOMPBUFFER_BASE + 6,    // 156
    D3DDDIFMT_MOTIONVECTORBUFFER = D3DDDIFMT_DXVACOMPBUFFER_BASE + 7,    // 157
    D3DDDIFMT_FILMGRAINBUFFER = D3DDDIFMT_DXVACOMPBUFFER_BASE + 8,    // 158
    D3DDDIFMT_DXVA_RESERVED9 = D3DDDIFMT_DXVACOMPBUFFER_BASE + 9,    // 159
    D3DDDIFMT_DXVA_RESERVED10 = D3DDDIFMT_DXVACOMPBUFFER_BASE + 10,   // 160
    D3DDDIFMT_DXVA_RESERVED11 = D3DDDIFMT_DXVACOMPBUFFER_BASE + 11,   // 161
    D3DDDIFMT_DXVA_RESERVED12 = D3DDDIFMT_DXVACOMPBUFFER_BASE + 12,   // 162
    D3DDDIFMT_DXVA_RESERVED13 = D3DDDIFMT_DXVACOMPBUFFER_BASE + 13,   // 163
    D3DDDIFMT_DXVA_RESERVED14 = D3DDDIFMT_DXVACOMPBUFFER_BASE + 14,   // 164
    D3DDDIFMT_DXVA_RESERVED15 = D3DDDIFMT_DXVACOMPBUFFER_BASE + 15,   // 165
    D3DDDIFMT_DXVA_RESERVED16 = D3DDDIFMT_DXVACOMPBUFFER_BASE + 16,   // 166
    D3DDDIFMT_DXVA_RESERVED17 = D3DDDIFMT_DXVACOMPBUFFER_BASE + 17,   // 167
    D3DDDIFMT_DXVA_RESERVED18 = D3DDDIFMT_DXVACOMPBUFFER_BASE + 18,   // 168
    D3DDDIFMT_DXVA_RESERVED19 = D3DDDIFMT_DXVACOMPBUFFER_BASE + 19,   // 169
    D3DDDIFMT_DXVA_RESERVED20 = D3DDDIFMT_DXVACOMPBUFFER_BASE + 20,   // 170
    D3DDDIFMT_DXVA_RESERVED21 = D3DDDIFMT_DXVACOMPBUFFER_BASE + 21,   // 171
    D3DDDIFMT_DXVA_RESERVED22 = D3DDDIFMT_DXVACOMPBUFFER_BASE + 22,   // 172
    D3DDDIFMT_DXVA_RESERVED23 = D3DDDIFMT_DXVACOMPBUFFER_BASE + 23,   // 173
    D3DDDIFMT_DXVA_RESERVED24 = D3DDDIFMT_DXVACOMPBUFFER_BASE + 24,   // 174
    D3DDDIFMT_DXVA_RESERVED25 = D3DDDIFMT_DXVACOMPBUFFER_BASE + 25,   // 175
    D3DDDIFMT_DXVA_RESERVED26 = D3DDDIFMT_DXVACOMPBUFFER_BASE + 26,   // 176
    D3DDDIFMT_DXVA_RESERVED27 = D3DDDIFMT_DXVACOMPBUFFER_BASE + 27,   // 177
    D3DDDIFMT_DXVA_RESERVED28 = D3DDDIFMT_DXVACOMPBUFFER_BASE + 28,   // 178
    D3DDDIFMT_DXVA_RESERVED29 = D3DDDIFMT_DXVACOMPBUFFER_BASE + 29,   // 179
    D3DDDIFMT_DXVA_RESERVED30 = D3DDDIFMT_DXVACOMPBUFFER_BASE + 30,   // 180
    D3DDDIFMT_DXVA_RESERVED31 = D3DDDIFMT_DXVACOMPBUFFER_BASE + 31,   // 181
    D3DDDIFMT_DXVACOMPBUFFER_MAX = D3DDDIFMT_DXVA_RESERVED31,

    D3DDDIFMT_BINARYBUFFER = 199,

    D3DDDIFMT_FORCE_UINT = 0x7fffffff
} D3DDDIFORMAT;

typedef struct _D3DDDI_RATIONAL
{
    UINT32 Numerator;
    UINT32 Denominator;
} D3DDDI_RATIONAL;

typedef enum _D3DDDI_VIDEO_SIGNAL_SCANLINE_ORDERING
{
    D3DDDI_VSSLO_UNINITIALIZED = 0,
    D3DDDI_VSSLO_PROGRESSIVE = 1,
    D3DDDI_VSSLO_INTERLACED_UPPERFIELDFIRST = 2,
    D3DDDI_VSSLO_INTERLACED_LOWERFIELDFIRST = 3,
    D3DDDI_VSSLO_OTHER = 255
} D3DDDI_VIDEO_SIGNAL_SCANLINE_ORDERING;

typedef enum _D3DDDI_ROTATION
{
    D3DDDI_ROTATION_IDENTITY = 1, // No rotation.
    D3DDDI_ROTATION_90 = 2, // Rotated 90 degrees.
    D3DDDI_ROTATION_180 = 3, // Rotated 180 degrees.
    D3DDDI_ROTATION_270 = 4 // Rotated 270 degrees.
} D3DDDI_ROTATION;
#endif

typedef enum _D3DKMDT_MODE_PRUNING_REASON
{
    D3DKMDT_MPR_UNINITIALIZED = 0, // mode was pruned or is supported because of:
    D3DKMDT_MPR_ALLCAPS = 1, //   all of the monitor caps (only used to imply lack of support - for support, specific reason is always indicated)
    D3DKMDT_MPR_DESCRIPTOR_MONITOR_SOURCE_MODE = 2, //   monitor source mode in the monitor descriptor
    D3DKMDT_MPR_DESCRIPTOR_MONITOR_FREQUENCY_RANGE = 3, //   monitor frequency range in the monitor descriptor
    D3DKMDT_MPR_DESCRIPTOR_OVERRIDE_MONITOR_SOURCE_MODE = 4, //   monitor source mode in the monitor descriptor override
    D3DKMDT_MPR_DESCRIPTOR_OVERRIDE_MONITOR_FREQUENCY_RANGE = 5, //   monitor frequency range in the monitor descriptor override
    D3DKMDT_MPR_DEFAULT_PROFILE_MONITOR_SOURCE_MODE = 6, //   monitor source mode in the default monitor profile
    D3DKMDT_MPR_DRIVER_RECOMMENDED_MONITOR_SOURCE_MODE = 7, //   monitor source mode recommended by the driver
    D3DKMDT_MPR_MONITOR_FREQUENCY_RANGE_OVERRIDE = 8, //   monitor frequency range override
    D3DKMDT_MPR_CLONE_PATH_PRUNED = 9, //   Mode is pruned because other path(s) in clone cluster has(have) no mode supported by monitor
    D3DKMDT_MPR_MAXVALID = 10
} D3DKMDT_MODE_PRUNING_REASON;

// This structure takes 8 bytes.
// The unnamed UINT of size 0 forces alignment of the structure to
// make it exactly occupy 8 bytes, see MSDN docs on C++ bitfields
// for more details
typedef struct _D3DKMDT_DISPLAYMODE_FLAGS
{
    UINT32 ValidatedAgainstMonitorCaps : 1;
    UINT32 RoundedFakeMode : 1;
    UINT32 : 0;
    D3DKMDT_MODE_PRUNING_REASON ModePruningReason : 4;
    UINT32 Stereo : 1; // since WIN8
    UINT32 AdvancedScanCapable : 1;
    UINT32 PreferredTiming : 1; // since WDDM2_0
    UINT32 PhysicalModeSupported : 1;
    UINT32 Reserved : 24;
} D3DKMDT_DISPLAYMODE_FLAGS;

// The D3DKMT_DISPLAYMODE structure describes a display mode.
typedef struct _D3DKMT_DISPLAYMODE 
{
    _Out_ UINT32 Width; // The screen width of the display mode, in pixels.
    _Out_ UINT32 Height; // The screen height of the display mode, in pixels.
    _Out_ D3DDDIFORMAT Format; // A D3DDDIFORMAT-typed value that indicates the pixel format of the display mode.
    _Out_ UINT32 IntegerRefreshRate; // A UINT value that indicates the refresh rate of the display mode.
    _Out_ D3DDDI_RATIONAL RefreshRate; // A D3DDDI_RATIONAL structure that indicates the refresh rate of the display mode.
    _Out_ D3DDDI_VIDEO_SIGNAL_SCANLINE_ORDERING ScanLineOrdering; // A D3DDDI_VIDEO_SIGNAL_SCANLINE_ORDERING-typed value that indicates how scan lines are ordered in the display mode.
    _Out_ D3DDDI_ROTATION DisplayOrientation; // A D3DDDI_ROTATION-typed value that identifies the orientation of the display mode.
    _Out_ UINT32 DisplayFixedOutput; // The fixed output of the display mode.
    _Out_ D3DKMDT_DISPLAYMODE_FLAGS Flags; // A D3DKMDT_DISPLAYMODE_FLAGS structure that indicates information about the display mode.
} D3DKMT_DISPLAYMODE;

// The D3DKMT_CURRENTDISPLAYMODE structure describes the current display mode of the specified video source.
typedef struct _D3DKMT_CURRENTDISPLAYMODE
{
    _In_ UINT32 VidPnSourceId; // The zero-based identification number of the video present source in a path of a video present network (VidPN) topology that the display mode applies to.
    _Out_ D3DKMT_DISPLAYMODE DisplayMode; // A D3DKMT_DISPLAYMODE structure that represents the current display mode.
} D3DKMT_CURRENTDISPLAYMODE;

// private
typedef struct _D3DKMT_VIRTUALADDRESSFLAGS
{
    UINT32 VirtualAddressSupported : 1;
    UINT32 Reserved : 31;
} D3DKMT_VIRTUALADDRESSFLAGS;

// private
typedef struct _D3DKMT_VIRTUALADDRESSINFO
{
    D3DKMT_VIRTUALADDRESSFLAGS VirtualAddressFlags;
} D3DKMT_VIRTUALADDRESSINFO;

// The D3DKMT_DRIVERVERSION enumeration type contains values that indicate the version of the display driver model that the display miniport driver supports.
typedef enum D3DKMT_DRIVERVERSION // QAI_DRIVERVERSION
{
    KMT_DRIVERVERSION_WDDM_1_0 = 1000, // The display miniport driver supports the Windows Vista display driver model (WDDM) without Windows 7 features.
    KMT_DRIVERVERSION_WDDM_1_1_PRERELEASE = 1102, // The display miniport driver supports the Windows Vista display driver model with prereleased Windows 7 features.
    KMT_DRIVERVERSION_WDDM_1_1 = 1105, // The display miniport driver supports the Windows Vista display driver model with released Windows 7 features.
    KMT_DRIVERVERSION_WDDM_1_2 = 1200, // The display miniport driver supports the Windows Vista display driver model with released Windows 8 features. Supported starting with Windows 8.
    KMT_DRIVERVERSION_WDDM_1_3 = 1300, // The display miniport driver supports the Windows display driver model with released Windows 8.1 features. Supported starting with Windows 8.1.
    KMT_DRIVERVERSION_WDDM_2_0 = 2000, // The display miniport driver supports the Windows display driver model with released Windows 10 features. Supported starting with Windows 10.
    KMT_DRIVERVERSION_WDDM_2_1 = 2100, // 1607
    KMT_DRIVERVERSION_WDDM_2_2 = 2200, // 1703
    KMT_DRIVERVERSION_WDDM_2_3 = 2300, // 1709
    KMT_DRIVERVERSION_WDDM_2_4 = 2400, // 1803
    KMT_DRIVERVERSION_WDDM_2_5 = 2500, // 1809
    KMT_DRIVERVERSION_WDDM_2_6 = 2600, // 19H1
    KMT_DRIVERVERSION_WDDM_2_7 = 2700, // 20H1
    KMT_DRIVERVERSION_WDDM_3_0 = 3000, // 21H1
} D3DKMT_DRIVERVERSION;

// Specifies the type of display device that the graphics adapter supports.
typedef struct _D3DKMT_ADAPTERTYPE
{
    union
    {
        struct
        {
            UINT32 RenderSupported : 1;
            UINT32 DisplaySupported : 1;
            UINT32 SoftwareDevice : 1;
            UINT32 PostDevice : 1;
            UINT32 HybridDiscrete : 1; // since WDDM1_3
            UINT32 HybridIntegrated : 1;
            UINT32 IndirectDisplayDevice : 1;
            UINT32 Paravirtualized : 1; // since WDDM2_3
            UINT32 ACGSupported : 1;
            UINT32 SupportSetTimingsFromVidPn : 1;
            UINT32 Detachable : 1;
            UINT32 ComputeOnly : 1; // since WDDM2_7
            UINT32 Prototype : 1;
            UINT32 Reserved : 19;
        };
        UINT32 Value;
    };
} D3DKMT_ADAPTERTYPE;

// Specifies the number of current Desktop Duplication API (DDA) clients that are attached to a given video present network (VidPN).
typedef struct _D3DKMT_OUTPUTDUPLCONTEXTSCOUNT
{
    UINT32 VidPnSourceId; // The ID of the video present network (VidPN).
    UINT32 OutputDuplicationCount; // The number of current DDA clients that are attached to the VidPN specified by the VidPnSourceId member.
} D3DKMT_OUTPUTDUPLCONTEXTSCOUNT;

#ifdef USE_D3DKMT_SINGLE_HEADER
typedef enum _D3DKMDT_GRAPHICS_PREEMPTION_GRANULARITY
{
    D3DKMDT_GRAPHICS_PREEMPTION_NONE = 0,
    D3DKMDT_GRAPHICS_PREEMPTION_DMA_BUFFER_BOUNDARY = 100,
    D3DKMDT_GRAPHICS_PREEMPTION_PRIMITIVE_BOUNDARY = 200,
    D3DKMDT_GRAPHICS_PREEMPTION_TRIANGLE_BOUNDARY = 300,
    D3DKMDT_GRAPHICS_PREEMPTION_PIXEL_BOUNDARY = 400,
    D3DKMDT_GRAPHICS_PREEMPTION_SHADER_BOUNDARY = 500,
} D3DKMDT_GRAPHICS_PREEMPTION_GRANULARITY;

typedef enum _D3DKMDT_COMPUTE_PREEMPTION_GRANULARITY
{
    D3DKMDT_COMPUTE_PREEMPTION_NONE = 0,
    D3DKMDT_COMPUTE_PREEMPTION_DMA_BUFFER_BOUNDARY = 100,
    D3DKMDT_COMPUTE_PREEMPTION_DISPATCH_BOUNDARY = 200,
    D3DKMDT_COMPUTE_PREEMPTION_THREAD_GROUP_BOUNDARY = 300,
    D3DKMDT_COMPUTE_PREEMPTION_THREAD_BOUNDARY = 400,
    D3DKMDT_COMPUTE_PREEMPTION_SHADER_BOUNDARY = 500,
} D3DKMDT_COMPUTE_PREEMPTION_GRANULARITY;

typedef struct _D3DKMDT_PREEMPTION_CAPS
{
    D3DKMDT_GRAPHICS_PREEMPTION_GRANULARITY GraphicsPreemptionGranularity;
    D3DKMDT_COMPUTE_PREEMPTION_GRANULARITY ComputePreemptionGranularity;
} D3DKMDT_PREEMPTION_CAPS;

typedef struct _D3DKMT_WDDM_1_2_CAPS
{
    D3DKMDT_PREEMPTION_CAPS PreemptionCaps;
    union
    {
        struct
        {
            UINT32 SupportNonVGA : 1;
            UINT32 SupportSmoothRotation : 1;
            UINT32 SupportPerEngineTDR : 1;
            UINT32 SupportKernelModeCommandBuffer : 1;
            UINT32 SupportCCD : 1;
            UINT32 SupportSoftwareDeviceBitmaps : 1;
            UINT32 SupportGammaRamp : 1;
            UINT32 SupportHWCursor : 1;
            UINT32 SupportHWVSync : 1;
            UINT32 SupportSurpriseRemovalInHibernation : 1;
            UINT32 Reserved : 22;
        };
        UINT32 Value;
    };
} D3DKMT_WDDM_1_2_CAPS;
#endif

// Indicates the version number of the user-mode driver.
typedef struct _D3DKMT_UMD_DRIVER_VERSION 
{
    LARGE_INTEGER DriverVersion; // The user-mode driver version.
} D3DKMT_UMD_DRIVER_VERSION;

// Indicates whether the user-mode driver supports Direct Flip operations, in which video memory is seamlessly flipped between an application's managed primary allocations and the Desktop Window Manager (DWM) managed primary allocations.
typedef struct _D3DKMT_DIRECTFLIP_SUPPORT
{
    BOOL Supported; // If TRUE, the driver supports Direct Flip operations. Otherwise, the driver does not support Direct Flip operations.
} D3DKMT_DIRECTFLIP_SUPPORT;

typedef struct _D3DKMT_MULTIPLANEOVERLAY_SUPPORT
{
    BOOL Supported;
} D3DKMT_MULTIPLANEOVERLAY_SUPPORT;

typedef struct _D3DKMT_DLIST_DRIVER_NAME
{
    _Out_ WCHAR DListFileName[MAX_PATH]; // DList driver file name
} D3DKMT_DLIST_DRIVER_NAME;

#ifdef USE_D3DKMT_SINGLE_HEADER
typedef struct _D3DKMT_WDDM_1_3_CAPS
{
    union
    {
        struct
        {
            UINT32 SupportMiracast : 1;
            UINT32 IsHybridIntegratedGPU : 1;
            UINT32 IsHybridDiscreteGPU : 1;
            UINT32 SupportPowerManagementPStates : 1;
            UINT32 SupportVirtualModes : 1;
            UINT32 SupportCrossAdapterResource : 1;
            UINT32 Reserved : 26;
        };
        UINT32 Value;
    };
} D3DKMT_WDDM_1_3_CAPS;
#endif

typedef struct _D3DKMT_MULTIPLANEOVERLAY_HUD_SUPPORT
{
    UINT32 VidPnSourceId; // Not yet used.
    BOOL Update;
    BOOL KernelSupported;
    BOOL HudSupported;
} D3DKMT_MULTIPLANEOVERLAY_HUD_SUPPORT;

#ifdef USE_D3DKMT_SINGLE_HEADER
typedef struct _D3DKMT_WDDM_2_0_CAPS
{
    union
    {
        struct
        {
            UINT32 Support64BitAtomics : 1;
            UINT32 GpuMmuSupported : 1;
            UINT32 IoMmuSupported : 1;
            UINT32 FlipOverwriteSupported : 1; // since WDDM2_4
            UINT32 SupportContextlessPresent : 1;
            UINT32 SupportSurpriseRemoval : 1; // since WDDM2_7
            UINT32 Reserved : 26;
        };
        UINT32 Value;
    };
} D3DKMT_WDDM_2_0_CAPS;
#endif

#ifdef USE_D3DKMT_SINGLE_HEADER
#include <pshpack1.h>

#define DXGK_MAX_METADATA_NAME_LENGTH 32

typedef enum _DXGK_ENGINE_TYPE
{
    DXGK_ENGINE_TYPE_OTHER = 0, // This value is used for proprietary or unique functionality that is not exposed by typical adapters, as well as for an engine that performs work that doesn't fall under another category.
    DXGK_ENGINE_TYPE_3D = 1, // The adapter's 3-D processing engine. All adapters that are not a display-only device have one 3-D engine.
    DXGK_ENGINE_TYPE_VIDEO_DECODE = 2, // The engine that handles video decoding, including decompression of video frames from an input stream into typical YUV surfaces. The workload packets for an H.264 video codec workload test must appear on either the decode engine or the 3-D engine.
    DXGK_ENGINE_TYPE_VIDEO_ENCODE = 3, // The engine that handles video encoding, including compression of typical video frames into an encoded video format.
    DXGK_ENGINE_TYPE_VIDEO_PROCESSING = 4, // The engine that is responsible for any video processing that is done after a video input stream is decoded. Such processing can include RGB surface conversion, filtering, stretching, color correction, deinterlacing, or other steps that are required before the final image is rendered to the display screen. The workload packets for workload tests must appear on either the video processing engine or the 3-D engine.
    DXGK_ENGINE_TYPE_SCENE_ASSEMBLY = 5, // The engine that performs vertex processing of 3-D workloads as a preliminary pass prior to the remainder of the 3-D rendering. This engine also stores vertices in bins that tile-based rendering engines use.
    DXGK_ENGINE_TYPE_COPY = 6, // The engine that is a copy engine used for moving data. This engine can perform subresource updates, blitting, paging, or other similar data handling. The workload packets for calls to CopySubresourceRegion or UpdateSubResource methods of Direct3D 10 and Direct3D 11 must appear on either the copy engine or the 3-D engine.
    DXGK_ENGINE_TYPE_OVERLAY = 7, // The virtual engine that is used for synchronized flipping of overlays in Direct3D 9.
    DXGK_ENGINE_TYPE_CRYPTO,
    DXGK_ENGINE_TYPE_MAX
} DXGK_ENGINE_TYPE;

typedef struct _DXGK_NODEMETADATA_FLAGS
{
    union
    {
        struct
        {
            UINT32 ContextSchedulingSupported : 1;
            UINT32 RingBufferFenceRelease : 1;
            UINT32 SupportTrackedWorkload : 1;
            UINT32 Reserved : 13;
            UINT32 MaxInFlightHwQueueBuffers : 16;
        };
        UINT32 Value;
    };
} DXGK_NODEMETADATA_FLAGS;

typedef struct _DXGK_NODEMETADATA
{
    DXGK_ENGINE_TYPE EngineType;
    WCHAR FriendlyName[DXGK_MAX_METADATA_NAME_LENGTH];
    DXGK_NODEMETADATA_FLAGS Flags;
    BOOLEAN GpuMmuSupported;
    BOOLEAN IoMmuSupported;
} DXGK_NODEMETADATA;

typedef DXGK_NODEMETADATA DXGKARG_GETNODEMETADATA;

typedef struct _D3DKMT_NODEMETADATA
{
    _In_ UINT32 NodeOrdinalAndAdapterIndex;
    _Out_ DXGK_NODEMETADATA NodeData;
} D3DKMT_NODEMETADATA;

#include <poppack.h>
#endif

typedef struct _D3DKMT_CPDRIVERNAME
{
    WCHAR ContentProtectionFileName[MAX_PATH];
} D3DKMT_CPDRIVERNAME;

typedef struct _D3DKMT_XBOX
{
    BOOL IsXBOX;
} D3DKMT_XBOX;

typedef struct _D3DKMT_INDEPENDENTFLIP_SUPPORT
{
    BOOL Supported;
} D3DKMT_INDEPENDENTFLIP_SUPPORT;

typedef struct _D3DKMT_MIRACASTCOMPANIONDRIVERNAME
{
    WCHAR MiracastCompanionDriverName[MAX_PATH];
} D3DKMT_MIRACASTCOMPANIONDRIVERNAME;

typedef struct _D3DKMT_PHYSICAL_ADAPTER_COUNT
{
    UINT32 Count;
} D3DKMT_PHYSICAL_ADAPTER_COUNT;

typedef struct _D3DKMT_DEVICE_IDS
{
    UINT32 VendorID;
    UINT32 DeviceID;
    UINT32 SubVendorID;
    UINT32 SubSystemID;
    UINT32 RevisionID;
    UINT32 BusType;
} D3DKMT_DEVICE_IDS;

typedef struct _D3DKMT_QUERY_DEVICE_IDS
{
    _In_ UINT32 PhysicalAdapterIndex;
    _Out_ D3DKMT_DEVICE_IDS DeviceIds;
} D3DKMT_QUERY_DEVICE_IDS;

#ifdef USE_D3DKMT_SINGLE_HEADER
typedef struct _D3DKMT_DRIVERCAPS_EXT
{
    union
    {
        struct
        {
            UINT32 VirtualModeSupport : 1;
            UINT32 Reserved : 31;
        };
        UINT32 Value;
    };
} D3DKMT_DRIVERCAPS_EXT;
#endif

typedef enum _D3DKMT_MIRACAST_DRIVER_TYPE
{
    D3DKMT_MIRACAST_DRIVER_NOT_SUPPORTED = 0,
    D3DKMT_MIRACAST_DRIVER_IHV = 1,
    D3DKMT_MIRACAST_DRIVER_MS = 2,
} D3DKMT_MIRACAST_DRIVER_TYPE;

typedef struct _D3DKMT_QUERY_MIRACAST_DRIVER_TYPE
{
    D3DKMT_MIRACAST_DRIVER_TYPE MiracastDriverType;
} D3DKMT_QUERY_MIRACAST_DRIVER_TYPE;

typedef struct _D3DKMT_GPUMMU_CAPS
{
    union
    {
        struct
        {
            UINT32 ReadOnlyMemorySupported : 1;
            UINT32 NoExecuteMemorySupported : 1;
            UINT32 CacheCoherentMemorySupported : 1;
            UINT32 Reserved : 29;
        };
        UINT32 Value;
    } Flags;
    UINT32 VirtualAddressBitCount;
} D3DKMT_GPUMMU_CAPS;

typedef struct _D3DKMT_QUERY_GPUMMU_CAPS
{
    _In_ UINT32 PhysicalAdapterIndex;
    _Out_ D3DKMT_GPUMMU_CAPS Caps;
} D3DKMT_QUERY_GPUMMU_CAPS;

typedef struct _D3DKMT_MULTIPLANEOVERLAY_DECODE_SUPPORT
{
    BOOL Supported;
} D3DKMT_MULTIPLANEOVERLAY_DECODE_SUPPORT;

typedef struct _D3DKMT_ISBADDRIVERFORHWPROTECTIONDISABLED
{
    BOOL Disabled;
} D3DKMT_ISBADDRIVERFORHWPROTECTIONDISABLED;

typedef struct _D3DKMT_MULTIPLANEOVERLAY_SECONDARY_SUPPORT
{
    BOOL Supported;
} D3DKMT_MULTIPLANEOVERLAY_SECONDARY_SUPPORT;

typedef struct _D3DKMT_INDEPENDENTFLIP_SECONDARY_SUPPORT
{
    BOOL Supported;
} D3DKMT_INDEPENDENTFLIP_SECONDARY_SUPPORT;

typedef struct _D3DKMT_PANELFITTER_SUPPORT
{
    BOOL Supported;
} D3DKMT_PANELFITTER_SUPPORT;

typedef enum _D3DKMT_PNP_KEY_TYPE
{
    D3DKMT_PNP_KEY_HARDWARE = 1,
    D3DKMT_PNP_KEY_SOFTWARE = 2
} D3DKMT_PNP_KEY_TYPE;

// A structure that holds information to query the physical adapter PNP key.
typedef struct _D3DKMT_QUERY_PHYSICAL_ADAPTER_PNP_KEY
{
    _In_ UINT32 PhysicalAdapterIndex; // The physical adapter index.
    _In_ D3DKMT_PNP_KEY_TYPE PnPKeyType; // The type of the PNP key being queried.
    _Field_size_opt_(*pCchDest) WCHAR *pDest; // A WCHAR value respresenting the pDest.
    _Inout_ UINT32 *pCchDest; // A UINT value representing the pCchDest.
} D3DKMT_QUERY_PHYSICAL_ADAPTER_PNP_KEY;

// A structure that holds information about the segment group size.
typedef struct _D3DKMT_SEGMENTGROUPSIZEINFO
{
    _In_ UINT32 PhysicalAdapterIndex; // An index to the physical adapter.
    _Out_ D3DKMT_SEGMENTSIZEINFO LegacyInfo; // Legacy segment size info.
    _Out_ ULONGLONG LocalMemory; // The size of local memory.
    _Out_ ULONGLONG NonLocalMemory; // The size of non-local memory.
    _Out_ ULONGLONG NonBudgetMemory; // The size of non-budget memory.
} D3DKMT_SEGMENTGROUPSIZEINFO;

// A structure that holds the support status.
typedef struct _D3DKMT_MPO3DDI_SUPPORT
{
    BOOL Supported; // Indicates whether support exists.
} D3DKMT_MPO3DDI_SUPPORT;

typedef struct _D3DKMT_HWDRM_SUPPORT
{
    BOOLEAN Supported;
} D3DKMT_HWDRM_SUPPORT;

typedef struct _D3DKMT_MPOKERNELCAPS_SUPPORT
{
    BOOL Supported;
} D3DKMT_MPOKERNELCAPS_SUPPORT;

typedef struct _D3DKMT_MULTIPLANEOVERLAY_STRETCH_SUPPORT
{
    UINT32 VidPnSourceId;
    BOOL Update;
    BOOL Supported;
} D3DKMT_MULTIPLANEOVERLAY_STRETCH_SUPPORT;

typedef struct _D3DKMT_GET_DEVICE_VIDPN_OWNERSHIP_INFO
{
    _In_ D3DKMT_HANDLE hDevice; // Indentifies the device
    _Out_ BOOLEAN bFailedDwmAcquireVidPn; // True if Dwm Acquire VidPn failed due to another Dwm device having ownership
} D3DKMT_GET_DEVICE_VIDPN_OWNERSHIP_INFO;

#ifdef USE_D3DKMT_SINGLE_HEADER
typedef struct _D3DDDI_QUERYREGISTRY_FLAGS
{
    union
    {
        struct
        {
            UINT32 TranslatePath : 1;
            UINT32 MutableValue : 1;
            UINT32 Reserved : 30;
        };
        UINT32 Value;
    };
} D3DDDI_QUERYREGISTRY_FLAGS;

typedef enum _D3DDDI_QUERYREGISTRY_TYPE
{
    D3DDDI_QUERYREGISTRY_SERVICEKEY = 0, // HKLM\System\CurrentControlSet\Services\nvlddmkm
    D3DDDI_QUERYREGISTRY_ADAPTERKEY = 1, // HKLM\System\CurrentControlSet\Control\Class\{4d36e968-e325-11ce-bfc1-08002be10318}\0000
    D3DDDI_QUERYREGISTRY_DRIVERSTOREPATH = 2,
    D3DDDI_QUERYREGISTRY_DRIVERIMAGEPATH = 3, // REDSTONE5
    D3DDDI_QUERYREGISTRY_MAX,
} D3DDDI_QUERYREGISTRY_TYPE;

typedef enum _D3DDDI_QUERYREGISTRY_STATUS
{
    D3DDDI_QUERYREGISTRY_STATUS_SUCCESS = 0,
    D3DDDI_QUERYREGISTRY_STATUS_BUFFER_OVERFLOW = 1,
    D3DDDI_QUERYREGISTRY_STATUS_FAIL = 2,
    D3DDDI_QUERYREGISTRY_STATUS_MAX,
} D3DDDI_QUERYREGISTRY_STATUS;

// Contains information about the query registry.
// PrivateDriverSize must be sizeof(D3DDDI_QUERYREGISTRY_INFO) + (size of the the key value in bytes)
typedef struct _D3DDDI_QUERYREGISTRY_INFO
{
    _In_ D3DDDI_QUERYREGISTRY_TYPE QueryType;
    _In_ D3DDDI_QUERYREGISTRY_FLAGS QueryFlags;
    _In_ WCHAR ValueName[MAX_PATH]; // The name of the registry value.
    _In_ ULONG ValueType; // REG_XX types (https://msdn.microsoft.com/en-us/library/windows/desktop/ms724884.aspx)
    _In_ ULONG PhysicalAdapterIndex;   // The physical adapter index in a LDA chain.
    _Out_ ULONG OutputValueSize;// Number of bytes written to the output value or required in case of D3DDDI_QUERYREGISTRY_STATUS_BUFFER_OVERFLOW.
    _Out_ D3DDDI_QUERYREGISTRY_STATUS Status;
    union
    {
        _Out_ ULONG OutputDword;
        _Out_ UINT64 OutputQword;
        _Out_ WCHAR OutputString[1];
        _Out_ BYTE OutputBinary[1];
    };
} D3DDDI_QUERYREGISTRY_INFO;
#endif

// Contains the kernel mode driver version.
typedef struct _D3DKMT_KMD_DRIVER_VERSION
{
    LARGE_INTEGER DriverVersion; // The driver version.
} D3DKMT_KMD_DRIVER_VERSION;

typedef struct _D3DKMT_BLOCKLIST_INFO
{
    UINT32 Size; // The size of the block list.
    WCHAR BlockList[1]; // The block list.
} D3DKMT_BLOCKLIST_INFO;

// Used to query for a unique guid.
typedef struct _D3DKMT_QUERY_ADAPTER_UNIQUE_GUID
{
    WCHAR AdapterUniqueGUID[40];
} D3DKMT_QUERY_ADAPTER_UNIQUE_GUID;

// Represents performance data collected per engine from an adapter on an interval basis.
typedef struct _D3DKMT_NODE_PERFDATA
{
    _In_ UINT32 NodeOrdinal; // Node ordinal of the requested engine.
    _In_ UINT32 PhysicalAdapterIndex; // The physical adapter index in a LDA chain.
    _Out_ ULONGLONG Frequency; // Clock frequency of the requested engine, represented in hertz.
    _Out_ ULONGLONG MaxFrequency; // The max frequency the engine can normally reach in hertz while not overclocked.
    _Out_ ULONGLONG MaxFrequencyOC; // The max frequency the engine can reach with its current overclock in hertz.
    _Out_ ULONG Voltage; // Voltage of the engine in milli volts mV
    _Out_ ULONG VoltageMax; // The max voltage of the engine in milli volts while not overclocked.
    _Out_ ULONG VoltageMaxOC; // The max voltage of the engine while overclocked in milli volts.
    _Out_ ULONGLONG MaxTransitionLatency; // Max transition latency to change the frequency in 100 nanoseconds // REDSTONE5
} D3DKMT_NODE_PERFDATA;

// Represents performance data collected per adapter on an interval basis.
typedef struct _D3DKMT_ADAPTER_PERFDATA
{
    _In_ UINT32 PhysicalAdapterIndex; // The physical adapter index in a LDA chain.
    _Out_ ULONGLONG MemoryFrequency; // Clock frequency of the memory in hertz
    _Out_ ULONGLONG MaxMemoryFrequency; // Max clock frequency of the memory while not overclocked, represented in hertz.
    _Out_ ULONGLONG MaxMemoryFrequencyOC; // Clock frequency of the memory while overclocked in hertz.
    _Out_ ULONGLONG MemoryBandwidth; // Amount of memory transferred in bytes
    _Out_ ULONGLONG PCIEBandwidth; // Amount of memory transferred over PCI-E in bytes
    _Out_ ULONG FanRPM; // Fan rpm
    _Out_ ULONG Power; // Power draw of the adapter in tenths of a percentage
    _Out_ ULONG Temperature; // Temperature in deci-Celsius 1 = 0.1C
    _Out_ UCHAR PowerStateOverride; // Overrides dxgkrnls power view of linked adapters.
} D3DKMT_ADAPTER_PERFDATA;

// Represents data capabilities that are static and queried once per GPU during initialization.
typedef struct _D3DKMT_ADAPTER_PERFDATACAPS
{
    _In_ UINT32 PhysicalAdapterIndex; // The physical adapter index in a LDA chain.
    _Out_ ULONGLONG MaxMemoryBandwidth; // Max memory bandwidth in bytes for 1 second
    _Out_ ULONGLONG MaxPCIEBandwidth; // Max pcie bandwidth in bytes for 1 second
    _Out_ ULONG MaxFanRPM; // Max fan rpm
    _Out_ ULONG TemperatureMax; // Max temperature before damage levels
    _Out_ ULONG TemperatureWarning; // The temperature level where throttling begins.
} D3DKMT_ADAPTER_PERFDATACAPS;

#define DXGK_MAX_GPUVERSION_NAME_LENGTH 32

// Used to collect the bios version and gpu architecture name once during GPU initialization.
typedef struct _D3DKMT_GPUVERSION
{
    _In_ UINT32 PhysicalAdapterIndex; // The physical adapter index in a LDA chain.
    _Out_ WCHAR BiosVersion[DXGK_MAX_GPUVERSION_NAME_LENGTH]; // The current bios of the adapter.
    _Out_ WCHAR GpuArchitecture[DXGK_MAX_GPUVERSION_NAME_LENGTH]; // The gpu architecture of the adapter.
} D3DKMT_GPUVERSION;

// Describes the kernel mode display driver.
typedef struct _D3DKMT_DRIVER_DESCRIPTION
{
    WCHAR DriverDescription[4096]; // out: Pointer to a string of characters that represent the driver description.
} D3DKMT_DRIVER_DESCRIPTION;

typedef struct _D3DKMT_QUERY_SCANOUT_CAPS
{
    ULONG VidPnSourceId;
    UINT Caps;
} D3DKMT_QUERY_SCANOUT_CAPS;

typedef struct _D3DKMT_WDDM_2_7_CAPS
{
    union
    {
        struct
        {
            UINT32 HwSchSupported : 1;
            UINT32 HwSchEnabled : 1;
            UINT32 HwSchEnabledByDefault : 1;
            UINT32 ReseIndependentVidPnVSyncControlrved : 1;
            UINT32 Reserved : 28;
        };
        UINT32 Value;
    };
} D3DKMT_WDDM_2_7_CAPS;

// Describes the mapping of the given name of a device to a graphics adapter handle and monitor output.
typedef struct _D3DKMT_OPENADAPTERFROMDEVICENAME
{
    _In_ PWSTR DeviceName; // A Null-terminated string that contains the name of the device from which to open an adapter instance.
    _Out_ D3DKMT_HANDLE AdapterHandle; // A handle to the graphics adapter for the device that DeviceName specifies.
    _Out_ LUID AdapterLuid; // The locally unique identifier (LUID) of the graphics adapter for the device that DeviceName specifies.
} D3DKMT_OPENADAPTERFROMDEVICENAME;

// Describes the mapping of the given name of a GDI device to a graphics adapter handle and monitor output.
typedef struct _D3DKMT_OPENADAPTERFROMGDIDISPLAYNAME
{
    _In_ WCHAR DeviceName[32]; // A Unicode string that contains the name of the GDI device from which to open an adapter instance.
    _Out_ D3DKMT_HANDLE AdapterHandle; // A handle to the graphics adapter for the GDI device that DeviceName specifies.
    _Out_ LUID AdapterLuid; // The locally unique identifier (LUID) of the graphics adapter for the GDI device that DeviceName specifies. 
    _Out_ ULONG VidPnSourceId; // D3DDDI_VIDEO_PRESENT_SOURCE_ID // The zero-based identification number of the video present source.
} D3DKMT_OPENADAPTERFROMGDIDISPLAYNAME;

// Describes the mapping of a device context handle (HDC) to a graphics adapter handle and monitor output.
typedef struct _D3DKMT_OPENADAPTERFROMHDC
{
    _In_ HDC hDc; // The HDC for the graphics adapter and monitor output that are retrieved.
    _Out_ D3DKMT_HANDLE AdapterHandle; // A handle to the graphics adapter for the HDC that hDc specifies.
    _Out_ LUID AdapterLuid; // The locally unique identifier (LUID) of the graphics adapter for the HDC that hDc specifies.
    _Out_ ULONG VidPnSourceId; // D3DDDI_VIDEO_PRESENT_SOURCE_ID // The zero-based identification number of the video present source.
} D3DKMT_OPENADAPTERFROMHDC;

// Describes the mapping of the given locally unique identifier (LUID) of a device to a graphics adapter handle.
typedef struct _D3DKMT_OPENADAPTERFROMLUID
{
    _In_ LUID AdapterLuid;
    _Out_ D3DKMT_HANDLE AdapterHandle;
} D3DKMT_OPENADAPTERFROMLUID;

// Supplies configuration information about a graphics adapter.
typedef struct _D3DKMT_ADAPTERINFO
{
    D3DKMT_HANDLE AdapterHandle; // A handle to the adapter.
    LUID AdapterLuid; // A LUID that serves as an identifier for the adapter.
    ULONG NumOfSources; // The number of video present sources supported by the adapter.
    BOOL bPresentMoveRegionsPreferred; // If TRUE, the adapter prefers move regions.
} D3DKMT_ADAPTERINFO;

#define MAX_ENUM_ADAPTERS 16

// Supplies information for enumerating all graphics adapters on the system.
typedef struct _D3DKMT_ENUMADAPTERS
{
    _In_ ULONG NumAdapters; // The number of graphics adapters.
    _Out_ D3DKMT_ADAPTERINFO Adapters[MAX_ENUM_ADAPTERS]; // An array of D3DKMT_ADAPTERINFO structures that supply configuration information for each adapter.
} D3DKMT_ENUMADAPTERS;

// Supplies information for enumerating all graphics adapters on the system.
typedef struct _D3DKMT_ENUMADAPTERS2
{
    _Inout_ ULONG NumAdapters; // On input, the count of the pAdapters array buffer. On output, the number of adapters enumerated.
    _Out_ D3DKMT_ADAPTERINFO* Adapters; // Array of enumerated adapters containing NumAdapters elements.
} D3DKMT_ENUMADAPTERS2;

typedef union _D3DKMT_ENUMADAPTERS_FILTER
{
    ULONG64 IncludeComputeOnly : 1;
    ULONG64 IncludeDisplayOnly : 1;
    ULONG64 Reserved : 62;
} D3DKMT_ENUMADAPTERS_FILTER;

typedef struct _D3DKMT_ENUMADAPTERS3
{
    _In_ D3DKMT_ENUMADAPTERS_FILTER Filter;
    _Inout_ ULONG NumAdapters;
    _Out_ D3DKMT_ADAPTERINFO* Adapters;
} D3DKMT_ENUMADAPTERS3;

// The D3DKMT_CLOSEADAPTER structure specifies the graphics adapter to close.
typedef struct _D3DKMT_CLOSEADAPTER
{
    _In_ D3DKMT_HANDLE AdapterHandle; // A handle to the graphics adapter to close.
} D3DKMT_CLOSEADAPTER;

typedef struct _D3DKMT_QUERYADAPTERINFO
{
    _In_ D3DKMT_HANDLE AdapterHandle;
    _In_ KMTQUERYADAPTERINFOTYPE Type;
    _Inout_bytecount_(PrivateDriverDataSize) PVOID PrivateDriverData;
    _Out_ UINT32 PrivateDriverDataSize;
} D3DKMT_QUERYADAPTERINFO;

typedef enum _D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT
{
    D3DKMT_PreemptionAttempt = 0,
    D3DKMT_PreemptionAttemptSuccess = 1,
    D3DKMT_PreemptionAttemptMissNoCommand = 2,
    D3DKMT_PreemptionAttemptMissNotEnabled = 3,
    D3DKMT_PreemptionAttemptMissNextFence = 4,
    D3DKMT_PreemptionAttemptMissPagingCommand = 5,
    D3DKMT_PreemptionAttemptMissSplittedCommand = 6,
    D3DKMT_PreemptionAttemptMissFenceCommand= 7,
    D3DKMT_PreemptionAttemptMissRenderPendingFlip = 8,
    D3DKMT_PreemptionAttemptMissNotMakingProgress = 9,
    D3DKMT_PreemptionAttemptMissLessPriority = 10,
    D3DKMT_PreemptionAttemptMissRemainingQuantum = 11,
    D3DKMT_PreemptionAttemptMissRemainingPreemptionQuantum = 12,
    D3DKMT_PreemptionAttemptMissAlreadyPreempting = 13,
    D3DKMT_PreemptionAttemptMissGlobalBlock = 14,
    D3DKMT_PreemptionAttemptMissAlreadyRunning = 15,
    D3DKMT_PreemptionAttemptStatisticsMax
} D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT;

typedef enum _D3DKMT_QUERYSTATISTICS_DMA_PACKET_TYPE
{
    D3DKMT_ClientRenderBuffer = 0,
    D3DKMT_ClientPagingBuffer = 1,
    D3DKMT_SystemPagingBuffer = 2,
    D3DKMT_SystemPreemptionBuffer = 3,
    D3DKMT_DmaPacketTypeMax
} D3DKMT_QUERYSTATISTICS_DMA_PACKET_TYPE;

typedef enum _D3DKMT_QUERYSTATISTICS_QUEUE_PACKET_TYPE
{
    D3DKMT_RenderCommandBuffer = 0,
    D3DKMT_DeferredCommandBuffer = 1,
    D3DKMT_SystemCommandBuffer = 2,
    D3DKMT_MmIoFlipCommandBuffer = 3,
    D3DKMT_WaitCommandBuffer = 4,
    D3DKMT_SignalCommandBuffer = 5,
    D3DKMT_DeviceCommandBuffer = 6,
    D3DKMT_SoftwareCommandBuffer = 7,
    D3DKMT_QueuePacketTypeMax
} D3DKMT_QUERYSTATISTICS_QUEUE_PACKET_TYPE;

typedef enum _D3DKMT_QUERYSTATISTICS_ALLOCATION_PRIORITY_CLASS
{
    D3DKMT_AllocationPriorityClassMinimum = 0,
    D3DKMT_AllocationPriorityClassLow = 1,
    D3DKMT_AllocationPriorityClassNormal = 2,
    D3DKMT_AllocationPriorityClassHigh = 3,
    D3DKMT_AllocationPriorityClassMaximum = 4,
    D3DKMT_MaxAllocationPriorityClass
} D3DKMT_QUERYSTATISTICS_ALLOCATION_PRIORITY_CLASS;

#define D3DKMT_QUERYSTATISTICS_SEGMENT_PREFERENCE_MAX 5

typedef struct _D3DKMT_QUERYSTATISTICS_COUNTER
{
    ULONG Count;
    ULONGLONG Bytes;
} D3DKMT_QUERYSTATISTICS_COUNTER;

typedef struct _D3DKMT_QUERYSTATISTICS_DMA_PACKET_TYPE_INFORMATION
{
    ULONG PacketSubmited;
    ULONG PacketCompleted;
    ULONG PacketPreempted;
    ULONG PacketFaulted;
} D3DKMT_QUERYSTATISTICS_DMA_PACKET_TYPE_INFORMATION;

typedef struct _D3DKMT_QUERYSTATISTICS_QUEUE_PACKET_TYPE_INFORMATION
{
    ULONG PacketSubmited;
    ULONG PacketCompleted;
} D3DKMT_QUERYSTATISTICS_QUEUE_PACKET_TYPE_INFORMATION;

typedef struct _D3DKMT_QUERYSTATISTICS_PACKET_INFORMATION
{
    D3DKMT_QUERYSTATISTICS_QUEUE_PACKET_TYPE_INFORMATION QueuePacket[D3DKMT_QueuePacketTypeMax];
    D3DKMT_QUERYSTATISTICS_DMA_PACKET_TYPE_INFORMATION DmaPacket[D3DKMT_DmaPacketTypeMax];
} D3DKMT_QUERYSTATISTICS_PACKET_INFORMATION;

typedef struct _D3DKMT_QUERYSTATISTICS_PREEMPTION_INFORMATION
{
    ULONG PreemptionCounter[D3DKMT_PreemptionAttemptStatisticsMax];
} D3DKMT_QUERYSTATISTICS_PREEMPTION_INFORMATION;

typedef struct _D3DKMT_QUERYSTATISTICS_PROCESS_NODE_INFORMATION
{
    LARGE_INTEGER RunningTime; // 100ns
    ULONG ContextSwitch;
    D3DKMT_QUERYSTATISTICS_PREEMPTION_INFORMATION PreemptionStatistics;
    D3DKMT_QUERYSTATISTICS_PACKET_INFORMATION PacketStatistics;
    ULONG64 Reserved[8];
} D3DKMT_QUERYSTATISTICS_PROCESS_NODE_INFORMATION;

typedef struct _D3DKMT_QUERYSTATISTICS_NODE_INFORMATION
{
    D3DKMT_QUERYSTATISTICS_PROCESS_NODE_INFORMATION GlobalInformation; // global
    D3DKMT_QUERYSTATISTICS_PROCESS_NODE_INFORMATION SystemInformation; // system thread
    //ULONG NodeId; // Win10
    ULONG64 Reserved[8];
} D3DKMT_QUERYSTATISTICS_NODE_INFORMATION;

typedef struct _D3DKMT_QUERYSTATISTICS_PROCESS_VIDPNSOURCE_INFORMATION
{
    ULONG Frame;
    ULONG CancelledFrame;
    ULONG QueuedPresent;
    ULONG64 Reserved[8];
} D3DKMT_QUERYSTATISTICS_PROCESS_VIDPNSOURCE_INFORMATION;

typedef struct _D3DKMT_QUERYSTATISTICS_VIDPNSOURCE_INFORMATION
{
    D3DKMT_QUERYSTATISTICS_PROCESS_VIDPNSOURCE_INFORMATION GlobalInformation; // global
    D3DKMT_QUERYSTATISTICS_PROCESS_VIDPNSOURCE_INFORMATION SystemInformation; // system thread
    ULONG64 Reserved[8];
} D3DKMT_QUERYSTATISTICS_VIDPNSOURCE_INFORMATION;

typedef struct _D3DKMT_QUERYSTATISTICS_PROCESS_SEGMENT_GROUP_INFORMATION
{
    ULONG64 Budget;
    ULONG64 Requested;
    ULONG64 Usage;
    ULONG64 Demoted[5];
} D3DKMT_QUERYSTATISTICS_PROCESS_SEGMENT_GROUP_INFORMATION, *PD3DKMT_QUERYSTATISTICS_PROCESS_SEGMENT_GROUP_INFORMATION;

typedef struct _D3DKMT_QUERYSTATSTICS_REFERENCE_DMA_BUFFER
{
    ULONG NbCall;
    ULONG NbAllocationsReferenced;
    ULONG MaxNbAllocationsReferenced;
    ULONG NbNULLReference;
    ULONG NbWriteReference;
    ULONG NbRenamedAllocationsReferenced;
    ULONG NbIterationSearchingRenamedAllocation;
    ULONG NbLockedAllocationReferenced;
    ULONG NbAllocationWithValidPrepatchingInfoReferenced;
    ULONG NbAllocationWithInvalidPrepatchingInfoReferenced;
    ULONG NbDMABufferSuccessfullyPrePatched;
    ULONG NbPrimariesReferencesOverflow;
    ULONG NbAllocationWithNonPreferredResources;
    ULONG NbAllocationInsertedInMigrationTable;
} D3DKMT_QUERYSTATSTICS_REFERENCE_DMA_BUFFER;

typedef struct _D3DKMT_QUERYSTATSTICS_RENAMING
{
    ULONG NbAllocationsRenamed;
    ULONG NbAllocationsShrinked;
    ULONG NbRenamedBuffer;
    ULONG MaxRenamingListLength;
    ULONG NbFailuresDueToRenamingLimit;
    ULONG NbFailuresDueToCreateAllocation;
    ULONG NbFailuresDueToOpenAllocation;
    ULONG NbFailuresDueToLowResource;
    ULONG NbFailuresDueToNonRetiredLimit;
} D3DKMT_QUERYSTATSTICS_RENAMING;

typedef struct _D3DKMT_QUERYSTATSTICS_PREPRATION
{
    ULONG BroadcastStall;
    ULONG NbDMAPrepared;
    ULONG NbDMAPreparedLongPath;
    ULONG ImmediateHighestPreparationPass;
    D3DKMT_QUERYSTATISTICS_COUNTER AllocationsTrimmed;
} D3DKMT_QUERYSTATSTICS_PREPRATION;

typedef struct _D3DKMT_QUERYSTATSTICS_PAGING_FAULT
{
    D3DKMT_QUERYSTATISTICS_COUNTER Faults;
    D3DKMT_QUERYSTATISTICS_COUNTER FaultsFirstTimeAccess;
    D3DKMT_QUERYSTATISTICS_COUNTER FaultsReclaimed;
    D3DKMT_QUERYSTATISTICS_COUNTER FaultsMigration;
    D3DKMT_QUERYSTATISTICS_COUNTER FaultsIncorrectResource;
    D3DKMT_QUERYSTATISTICS_COUNTER FaultsLostContent;
    D3DKMT_QUERYSTATISTICS_COUNTER FaultsEvicted;
    D3DKMT_QUERYSTATISTICS_COUNTER AllocationsMEM_RESET;
    D3DKMT_QUERYSTATISTICS_COUNTER AllocationsUnresetSuccess;
    D3DKMT_QUERYSTATISTICS_COUNTER AllocationsUnresetFail;
    ULONG AllocationsUnresetSuccessRead;
    ULONG AllocationsUnresetFailRead;

    D3DKMT_QUERYSTATISTICS_COUNTER Evictions;
    D3DKMT_QUERYSTATISTICS_COUNTER EvictionsDueToPreparation;
    D3DKMT_QUERYSTATISTICS_COUNTER EvictionsDueToLock;
    D3DKMT_QUERYSTATISTICS_COUNTER EvictionsDueToClose;
    D3DKMT_QUERYSTATISTICS_COUNTER EvictionsDueToPurge;
    D3DKMT_QUERYSTATISTICS_COUNTER EvictionsDueToSuspendCPUAccess;
} D3DKMT_QUERYSTATSTICS_PAGING_FAULT;

typedef struct _D3DKMT_QUERYSTATSTICS_PAGING_TRANSFER
{
    ULONGLONG BytesFilled;
    ULONGLONG BytesDiscarded;
    ULONGLONG BytesMappedIntoAperture;
    ULONGLONG BytesUnmappedFromAperture;
    ULONGLONG BytesTransferredFromMdlToMemory;
    ULONGLONG BytesTransferredFromMemoryToMdl;
    ULONGLONG BytesTransferredFromApertureToMemory;
    ULONGLONG BytesTransferredFromMemoryToAperture;
} D3DKMT_QUERYSTATSTICS_PAGING_TRANSFER;

typedef struct _D3DKMT_QUERYSTATSTICS_SWIZZLING_RANGE
{
    ULONG NbRangesAcquired;
    ULONG NbRangesReleased;
} D3DKMT_QUERYSTATSTICS_SWIZZLING_RANGE;

typedef struct _D3DKMT_QUERYSTATSTICS_LOCKS
{
    ULONG NbLocks;
    ULONG NbLocksWaitFlag;
    ULONG NbLocksDiscardFlag;
    ULONG NbLocksNoOverwrite;
    ULONG NbLocksNoReadSync;
    ULONG NbLocksLinearization;
    ULONG NbComplexLocks;
} D3DKMT_QUERYSTATSTICS_LOCKS;

typedef struct _D3DKMT_QUERYSTATSTICS_ALLOCATIONS
{
    D3DKMT_QUERYSTATISTICS_COUNTER Created;
    D3DKMT_QUERYSTATISTICS_COUNTER Destroyed;
    D3DKMT_QUERYSTATISTICS_COUNTER Opened;
    D3DKMT_QUERYSTATISTICS_COUNTER Closed;
    D3DKMT_QUERYSTATISTICS_COUNTER MigratedSuccess;
    D3DKMT_QUERYSTATISTICS_COUNTER MigratedFail;
    D3DKMT_QUERYSTATISTICS_COUNTER MigratedAbandoned;
} D3DKMT_QUERYSTATSTICS_ALLOCATIONS;

typedef struct _D3DKMT_QUERYSTATSTICS_TERMINATIONS
{
    D3DKMT_QUERYSTATISTICS_COUNTER TerminatedShared;
    D3DKMT_QUERYSTATISTICS_COUNTER TerminatedNonShared;
    D3DKMT_QUERYSTATISTICS_COUNTER DestroyedShared;
    D3DKMT_QUERYSTATISTICS_COUNTER DestroyedNonShared;
} D3DKMT_QUERYSTATSTICS_TERMINATIONS;

typedef struct _D3DKMT_QUERYSTATISTICS_ADAPTER_INFORMATION_FLAGS
{
    ULONGLONG NumberOfMemoryGroups : 2;
    ULONGLONG SupportsDemotion : 1;
    ULONGLONG Reserved : 61;
    ULONGLONG Value;
} D3DKMT_QUERYSTATISTICS_ADAPTER_INFORMATION_FLAGS;

typedef struct _D3DKMT_QUERYSTATISTICS_ADAPTER_INFORMATION
{
    ULONG NbSegments;
    ULONG NodeCount;
    ULONG VidPnSourceCount;

    ULONG VSyncEnabled;
    ULONG TdrDetectedCount;

    LONGLONG ZeroLengthDmaBuffers;
    ULONGLONG RestartedPeriod;

    D3DKMT_QUERYSTATSTICS_REFERENCE_DMA_BUFFER ReferenceDmaBuffer;
    D3DKMT_QUERYSTATSTICS_RENAMING Renaming;
    D3DKMT_QUERYSTATSTICS_PREPRATION Preparation;
    D3DKMT_QUERYSTATSTICS_PAGING_FAULT PagingFault;
    D3DKMT_QUERYSTATSTICS_PAGING_TRANSFER PagingTransfer;
    D3DKMT_QUERYSTATSTICS_SWIZZLING_RANGE SwizzlingRange;
    D3DKMT_QUERYSTATSTICS_LOCKS Locks;
    D3DKMT_QUERYSTATSTICS_ALLOCATIONS Allocations;
    D3DKMT_QUERYSTATSTICS_TERMINATIONS Terminations;
    D3DKMT_QUERYSTATISTICS_ADAPTER_INFORMATION_FLAGS Flags;

    ULONG64 Reserved[7];
} D3DKMT_QUERYSTATISTICS_ADAPTER_INFORMATION;

typedef struct _D3DKMT_QUERYSTATISTICS_SYSTEM_MEMORY
{
    ULONGLONG BytesAllocated;
    ULONGLONG BytesReserved;
    ULONG SmallAllocationBlocks;
    ULONG LargeAllocationBlocks;
    ULONGLONG WriteCombinedBytesAllocated;
    ULONGLONG WriteCombinedBytesReserved;
    ULONGLONG CachedBytesAllocated;
    ULONGLONG CachedBytesReserved;
    ULONGLONG SectionBytesAllocated;
    ULONGLONG SectionBytesReserved;
} D3DKMT_QUERYSTATISTICS_SYSTEM_MEMORY;

typedef struct _D3DKMT_QUERYSTATISTICS_PROCESS_INFORMATION
{
    ULONG NodeCount;
    ULONG VidPnSourceCount;

    D3DKMT_QUERYSTATISTICS_SYSTEM_MEMORY SystemMemory;

    ULONG64 Reserved[8];
} D3DKMT_QUERYSTATISTICS_PROCESS_INFORMATION;

typedef struct _D3DKMT_QUERYSTATISTICS_DMA_BUFFER
{
    D3DKMT_QUERYSTATISTICS_COUNTER Size;
    ULONG AllocationListBytes;
    ULONG PatchLocationListBytes;
} D3DKMT_QUERYSTATISTICS_DMA_BUFFER;

typedef struct _D3DKMT_QUERYSTATISTICS_COMMITMENT_DATA
{
    ULONG64 TotalBytesEvictedFromProcess;
    ULONG64 BytesBySegmentPreference[D3DKMT_QUERYSTATISTICS_SEGMENT_PREFERENCE_MAX];
} D3DKMT_QUERYSTATISTICS_COMMITMENT_DATA;

typedef struct _D3DKMT_QUERYSTATISTICS_POLICY
{
    ULONGLONG PreferApertureForRead[D3DKMT_MaxAllocationPriorityClass];
    ULONGLONG PreferAperture[D3DKMT_MaxAllocationPriorityClass];
    ULONGLONG MemResetOnPaging;
    ULONGLONG RemovePagesFromWorkingSetOnPaging;
    ULONGLONG MigrationEnabled;
} D3DKMT_QUERYSTATISTICS_POLICY;

typedef struct _D3DKMT_QUERYSTATISTICS_PROCESS_INTERFERENCE_COUNTERS
{
    ULONGLONG InterferenceCount[9];
} D3DKMT_QUERYSTATISTICS_PROCESS_INTERFERENCE_COUNTERS;

typedef struct _D3DKMT_QUERYSTATISTICS_PROCESS_ADAPTER_INFORMATION
{
    ULONG NbSegments;
    ULONG NodeCount;
    ULONG VidPnSourceCount;

    ULONG VirtualMemoryUsage;

    D3DKMT_QUERYSTATISTICS_DMA_BUFFER DmaBuffer;
    D3DKMT_QUERYSTATISTICS_COMMITMENT_DATA CommitmentData;
    D3DKMT_QUERYSTATISTICS_POLICY _Policy;
    D3DKMT_QUERYSTATISTICS_PROCESS_INTERFERENCE_COUNTERS ProcessInterferenceCounters;
} D3DKMT_QUERYSTATISTICS_PROCESS_ADAPTER_INFORMATION;

typedef struct _D3DKMT_QUERYSTATISTICS_MEMORY
{
    ULONGLONG TotalBytesEvicted;
    ULONG AllocsCommitted;
    ULONG AllocsResident;
} D3DKMT_QUERYSTATISTICS_MEMORY;

typedef struct _D3DKMT_QUERYSTATISTICS_SEGMENT_INFORMATION_V1
{
    ULONG CommitLimit;
    ULONG BytesCommitted;
    ULONG BytesResident;

    D3DKMT_QUERYSTATISTICS_MEMORY Memory;

    ULONG Aperture; // boolean

    ULONGLONG TotalBytesEvictedByPriority[D3DKMT_MaxAllocationPriorityClass];

    ULONG64 SystemMemoryEndAddress;
    struct
    {
        ULONG64 PreservedDuringStandby : 1;
        ULONG64 PreservedDuringHibernate : 1;
        ULONG64 PartiallyPreservedDuringHibernate : 1;
        ULONG64 Reserved : 61;
    } PowerFlags;

    ULONG64 Reserved[7];
} D3DKMT_QUERYSTATISTICS_SEGMENT_INFORMATION_V1;

typedef struct _D3DKMT_QUERYSTATISTICS_SEGMENT_INFORMATION
{
    ULONGLONG CommitLimit;
    ULONGLONG BytesCommitted;
    ULONGLONG BytesResident;

    D3DKMT_QUERYSTATISTICS_MEMORY Memory;

    ULONG Aperture; // boolean

    ULONGLONG TotalBytesEvictedByPriority[D3DKMT_MaxAllocationPriorityClass];

    ULONG64 SystemMemoryEndAddress;
    struct
    {
        ULONG64 PreservedDuringStandby : 1;
        ULONG64 PreservedDuringHibernate : 1;
        ULONG64 PartiallyPreservedDuringHibernate : 1;
        ULONG64 Reserved : 61;
    } PowerFlags;

    ULONG64 Reserved[6];
} D3DKMT_QUERYSTATISTICS_SEGMENT_INFORMATION;

typedef struct _D3DKMT_QUERYSTATISTICS_VIDEO_MEMORY
{
    ULONG AllocsCommitted;
    D3DKMT_QUERYSTATISTICS_COUNTER AllocsResidentInP[D3DKMT_QUERYSTATISTICS_SEGMENT_PREFERENCE_MAX];
    D3DKMT_QUERYSTATISTICS_COUNTER AllocsResidentInNonPreferred;
    ULONGLONG TotalBytesEvictedDueToPreparation;
} D3DKMT_QUERYSTATISTICS_VIDEO_MEMORY;

typedef struct _D3DKMT_QUERYSTATISTICS_PROCESS_SEGMENT_POLICY
{
    ULONGLONG UseMRU;
} D3DKMT_QUERYSTATISTICS_PROCESS_SEGMENT_POLICY;

typedef struct _D3DKMT_QUERYSTATISTICS_PROCESS_SEGMENT_INFORMATION
{
    ULONGLONG BytesCommitted;
    ULONGLONG MaximumWorkingSet;
    ULONGLONG MinimumWorkingSet;

    ULONG NbReferencedAllocationEvictedInPeriod;

    D3DKMT_QUERYSTATISTICS_VIDEO_MEMORY VideoMemory;
    D3DKMT_QUERYSTATISTICS_PROCESS_SEGMENT_POLICY _Policy;

    ULONG64 Reserved[8];
} D3DKMT_QUERYSTATISTICS_PROCESS_SEGMENT_INFORMATION;

typedef enum _D3DKMT_QUERYSTATISTICS_TYPE
{
    D3DKMT_QUERYSTATISTICS_ADAPTER,
    D3DKMT_QUERYSTATISTICS_PROCESS,
    D3DKMT_QUERYSTATISTICS_PROCESS_ADAPTER,
    D3DKMT_QUERYSTATISTICS_SEGMENT,
    D3DKMT_QUERYSTATISTICS_PROCESS_SEGMENT,
    D3DKMT_QUERYSTATISTICS_NODE,
    D3DKMT_QUERYSTATISTICS_PROCESS_NODE,
    D3DKMT_QUERYSTATISTICS_VIDPNSOURCE,
    D3DKMT_QUERYSTATISTICS_PROCESS_VIDPNSOURCE,
    D3DKMT_QUERYSTATISTICS_PROCESS_SEGMENT_GROUP,
    D3DKMT_QUERYSTATISTICS_PHYSICAL_ADAPTER
} D3DKMT_QUERYSTATISTICS_TYPE;

typedef struct _D3DKMT_QUERYSTATISTICS_QUERY_SEGMENT
{
    ULONG SegmentId;
} D3DKMT_QUERYSTATISTICS_QUERY_SEGMENT;

typedef struct _D3DKMT_QUERYSTATISTICS_QUERY_NODE
{
    ULONG NodeId;
} D3DKMT_QUERYSTATISTICS_QUERY_NODE;

typedef struct _D3DKMT_QUERYSTATISTICS_QUERY_VIDPNSOURCE
{
    ULONG VidPnSourceId;
} D3DKMT_QUERYSTATISTICS_QUERY_VIDPNSOURCE;

typedef union _D3DKMT_QUERYSTATISTICS_RESULT
{
    D3DKMT_QUERYSTATISTICS_ADAPTER_INFORMATION AdapterInformation;
    // D3DKMT_QUERYSTATISTICS_PHYSICAL_ADAPTER_INFORMATION PhysAdapterInformation;
    D3DKMT_QUERYSTATISTICS_SEGMENT_INFORMATION_V1 SegmentInformationV1; // WIN7
    D3DKMT_QUERYSTATISTICS_SEGMENT_INFORMATION SegmentInformation; // WIN8
    D3DKMT_QUERYSTATISTICS_NODE_INFORMATION NodeInformation;
    D3DKMT_QUERYSTATISTICS_VIDPNSOURCE_INFORMATION VidPnSourceInformation;
    D3DKMT_QUERYSTATISTICS_PROCESS_INFORMATION ProcessInformation;
    D3DKMT_QUERYSTATISTICS_PROCESS_ADAPTER_INFORMATION ProcessAdapterInformation;
    D3DKMT_QUERYSTATISTICS_PROCESS_SEGMENT_INFORMATION ProcessSegmentInformation;
    D3DKMT_QUERYSTATISTICS_PROCESS_NODE_INFORMATION ProcessNodeInformation;
    D3DKMT_QUERYSTATISTICS_PROCESS_VIDPNSOURCE_INFORMATION ProcessVidPnSourceInformation;
    D3DKMT_QUERYSTATISTICS_PROCESS_SEGMENT_GROUP_INFORMATION ProcessSegmentGroupInformation;
} D3DKMT_QUERYSTATISTICS_RESULT;

typedef struct _D3DKMT_QUERYSTATISTICS
{
    _In_ D3DKMT_QUERYSTATISTICS_TYPE Type;
    _In_ LUID AdapterLuid;
    _In_opt_ HANDLE ProcessHandle;
    _Out_ D3DKMT_QUERYSTATISTICS_RESULT QueryResult;

    union
    {
        _In_ D3DKMT_QUERYSTATISTICS_QUERY_SEGMENT QuerySegment;
        _In_ D3DKMT_QUERYSTATISTICS_QUERY_SEGMENT QueryProcessSegment;
        _In_ D3DKMT_QUERYSTATISTICS_QUERY_NODE QueryNode;
        _In_ D3DKMT_QUERYSTATISTICS_QUERY_NODE QueryProcessNode;
        _In_ D3DKMT_QUERYSTATISTICS_QUERY_VIDPNSOURCE QueryVidPnSource;
        _In_ D3DKMT_QUERYSTATISTICS_QUERY_VIDPNSOURCE QueryProcessVidPnSource;
    };
} D3DKMT_QUERYSTATISTICS;

typedef enum _D3DKMT_MEMORY_SEGMENT_GROUP
{
    D3DKMT_MEMORY_SEGMENT_GROUP_LOCAL = 0,
    D3DKMT_MEMORY_SEGMENT_GROUP_NON_LOCAL = 1
} D3DKMT_MEMORY_SEGMENT_GROUP;

typedef struct _D3DKMT_QUERYVIDEOMEMORYINFO
{
    _In_opt_ HANDLE ProcessHandle; // A handle to a process. If NULL, the current process is used. The process handle must be opened with PROCESS_QUERY_INFORMATION privileges.
    _In_ D3DKMT_HANDLE AdapterHandle; // The adapter to query for this process
    _In_ D3DKMT_MEMORY_SEGMENT_GROUP MemorySegmentGroup; // The memory segment group to query.
    _Out_ UINT64 Budget; // Total memory the application may use
    _Out_ UINT64 CurrentUsage; // Current memory usage of the device
    _Out_ UINT64 CurrentReservation; // Current reservation of the device
    _Out_ UINT64 AvailableForReservation; // Total that the device may reserve
    _In_ UINT32 PhysicalAdapterIndex; // Zero based physical adapter index in the LDA configuration.
} D3DKMT_QUERYVIDEOMEMORYINFO;

typedef enum _D3DKMT_ESCAPETYPE
{
    D3DKMT_ESCAPE_DRIVERPRIVATE = 0,
    D3DKMT_ESCAPE_VIDMM = 1, // D3DKMT_VIDMM_ESCAPE
    D3DKMT_ESCAPE_TDRDBGCTRL = 2, // D3DKMT_TDRDBGCTRLTYPE
    D3DKMT_ESCAPE_VIDSCH = 3, // D3DKMT_VIDSCH_ESCAPE
    D3DKMT_ESCAPE_DEVICE = 4, // D3DKMT_DEVICE_ESCAPE
    D3DKMT_ESCAPE_DMM = 5, // D3DKMT_DMM_ESCAPE
    D3DKMT_ESCAPE_DEBUG_SNAPSHOT = 6, // D3DKMT_DEBUG_SNAPSHOT_ESCAPE
    // unused (7 was previously used to set driver update in-progress status, D3DKMT_ESCAPE_SETDRIVERUPDATESTATUS)
    D3DKMT_ESCAPE_DRT_TEST = 8,
    D3DKMT_ESCAPE_DIAGNOSTICS = 9, // since WIN8
    D3DKMT_ESCAPE_OUTPUTDUPL_SNAPSHOT = 10,
    D3DKMT_ESCAPE_OUTPUTDUPL_DIAGNOSTICS = 11,
    D3DKMT_ESCAPE_BDD_PNP = 12,
    D3DKMT_ESCAPE_BDD_FALLBACK = 13,
    D3DKMT_ESCAPE_ACTIVATE_SPECIFIC_DIAG = 14, // D3DKMT_ACTIVATE_SPECIFIC_DIAG_ESCAPE
    D3DKMT_ESCAPE_MODES_PRUNED_OUT = 15,
    D3DKMT_ESCAPE_WHQL_INFO = 16, // UINT32 ??
    D3DKMT_ESCAPE_BRIGHTNESS = 17,
    D3DKMT_ESCAPE_EDID_CACHE = 18,  // UINT32 ??
    D3DKMT_ESCAPE_GENERIC_ADAPTER_DIAG_INFO = 19,
    D3DKMT_ESCAPE_MIRACAST_DISPLAY_REQUEST = 20, // since WDDM1_3
    D3DKMT_ESCAPE_HISTORY_BUFFER_STATUS = 21,
    // 22 can be reused for future needs as it was never exposed for external purposes
    D3DKMT_ESCAPE_MIRACAST_ADAPTER_DIAG_INFO = 23,
    D3DKMT_ESCAPE_FORCE_BDDFALLBACK_HEADLESS = 24, // since WDDM2_0
    D3DKMT_ESCAPE_REQUEST_MACHINE_CRASH = 25, // D3DKMT_REQUEST_MACHINE_CRASH_ESCAPE
    D3DKMT_ESCAPE_HMD_GET_EDID_BASE_BLOCK = 26,
    D3DKMT_ESCAPE_SOFTGPU_ENABLE_DISABLE_HMD = 27,
    D3DKMT_ESCAPE_PROCESS_VERIFIER_OPTION = 28,
    D3DKMT_ESCAPE_ADAPTER_VERIFIER_OPTION = 29,
    D3DKMT_ESCAPE_IDD_REQUEST = 30, // since WDDM2_1
    D3DKMT_ESCAPE_DOD_SET_DIRTYRECT_MODE = 31,
    D3DKMT_ESCAPE_LOG_CODEPOINT_PACKET = 32,
    D3DKMT_ESCAPE_LOG_USERMODE_DAIG_PACKET = 33, // since WDDM2_2
    D3DKMT_ESCAPE_GET_EXTERNAL_DIAGNOSTICS = 34,
    // unused (35 previously was D3DKMT_ESCAPE_GET_PREFERRED_MODE)
    D3DKMT_ESCAPE_GET_DISPLAY_CONFIGURATIONS = 36, // since WDDM2_3
    D3DKMT_ESCAPE_QUERY_IOMMU_STATUS = 37, // since WDDM2_4
    D3DKMT_ESCAPE_CCD_DATABASE = 38, // since WDDM2_6

    D3DKMT_ESCAPE_WIN32K_START = 1024,
    D3DKMT_ESCAPE_WIN32K_HIP_DEVICE_INFO = 1024,
    D3DKMT_ESCAPE_WIN32K_QUERY_CD_ROTATION_BLOCK = 1025,
    D3DKMT_ESCAPE_WIN32K_DPI_INFO = 1026, // Use hContext for the desired hdev // since WDDM1_3
    D3DKMT_ESCAPE_WIN32K_PRESENTER_VIEW_INFO = 1027,
    D3DKMT_ESCAPE_WIN32K_SYSTEM_DPI = 1028,
    D3DKMT_ESCAPE_WIN32K_BDD_FALLBACK = 1029, // since WDDM2_0
    D3DKMT_ESCAPE_WIN32K_DDA_TEST_CTL = 1030,
    D3DKMT_ESCAPE_WIN32K_USER_DETECTED_BLACK_SCREEN = 1031,
    D3DKMT_ESCAPE_WIN32K_HMD_ENUM = 1032,
    D3DKMT_ESCAPE_WIN32K_HMD_CONTROL = 1033,
    D3DKMT_ESCAPE_WIN32K_LPMDISPLAY_CONTROL = 1034,
} D3DKMT_ESCAPETYPE;

typedef enum _D3DKMT_VIDMMESCAPETYPE
{
    D3DKMT_VIDMMESCAPETYPE_SETFAULT = 0,
    D3DKMT_VIDMMESCAPETYPE_RUN_COHERENCY_TEST = 1,
    D3DKMT_VIDMMESCAPETYPE_RUN_UNMAP_TO_DUMMY_PAGE_TEST = 2,
    D3DKMT_VIDMMESCAPETYPE_APERTURE_CORRUPTION_CHECK = 3,
    D3DKMT_VIDMMESCAPETYPE_SUSPEND_CPU_ACCESS_TEST = 4,
    D3DKMT_VIDMMESCAPETYPE_EVICT = 5,
    D3DKMT_VIDMMESCAPETYPE_EVICT_BY_NT_HANDLE = 6,
    D3DKMT_VIDMMESCAPETYPE_GET_VAD_INFO = 7,
    D3DKMT_VIDMMESCAPETYPE_SET_BUDGET = 8,
    D3DKMT_VIDMMESCAPETYPE_SUSPEND_PROCESS = 9,
    D3DKMT_VIDMMESCAPETYPE_RESUME_PROCESS = 10,
    D3DKMT_VIDMMESCAPETYPE_GET_BUDGET = 11,
    D3DKMT_VIDMMESCAPETYPE_SET_TRIM_INTERVALS = 12,
    D3DKMT_VIDMMESCAPETYPE_EVICT_BY_CRITERIA = 13,
    D3DKMT_VIDMMESCAPETYPE_WAKE = 14,
    D3DKMT_VIDMMESCAPETYPE_DEFRAG = 15,
} D3DKMT_VIDMMESCAPETYPE;

typedef struct _D3DKMT_VAD_DESC
{
    _In_ UINT32 VadIndex; // 0xFFFFFFFF to use the VAD address
    _In_ UINT64 VadAddress;
    _Out_ UINT32 NumMappedRanges;
    _Out_ UINT32 VadType; // 0 - reserved, 1 - Mapped
    _Out_ UINT64 StartAddress;
    _Out_ UINT64 EndAddress;
} D3DKMT_VAD_DESC;

typedef struct _D3DKMT_VA_RANGE_DESC
{
    _In_ UINT64 VadAddress;
    _In_ UINT32 VaRangeIndex;
    _In_ UINT32 PhysicalAdapterIndex;
    _Out_ UINT64 StartAddress;
    _Out_ UINT64 EndAddress;
    _Out_ UINT64 DriverProtection;
    _Out_ UINT32 OwnerType; // VIDMM_VAD_OWNER_TYPE
    _Out_ UINT64 pOwner;
    _Out_ UINT64 OwnerOffset;
    _Out_ UINT32 Protection; // D3DDDIGPUVIRTUALADDRESS_PROTECTION_TYPE
} D3DKMT_VA_RANGE_DESC;

typedef struct _D3DKMT_PAGE_TABLE_LEVEL_DESC
{
    UINT32 IndexBitCount;
    UINT64 IndexMask;
    UINT64 IndexShift;
    UINT64 LowerLevelsMask;
    UINT64 EntryCoverageInPages;
} D3DKMT_PAGE_TABLE_LEVEL_DESC;

#define DXGK_MAX_PAGE_TABLE_LEVEL_COUNT 6
#define DXGK_MIN_PAGE_TABLE_LEVEL_COUNT 2

typedef struct _DXGK_ESCAPE_GPUMMUCAPS
{
    BOOLEAN ReadOnlyMemorySupported;
    BOOLEAN NoExecuteMemorySupported;
    BOOLEAN ZeroInPteSupported;
    BOOLEAN CacheCoherentMemorySupported;
    BOOLEAN LargePageSupported;
    BOOLEAN DualPteSupported;
    BOOLEAN AllowNonAlignedLargePageAddress;
    UINT32 VirtualAddressBitCount;
    UINT32 PageTableLevelCount;
    D3DKMT_PAGE_TABLE_LEVEL_DESC PageTableLevelDesk[DXGK_MAX_PAGE_TABLE_LEVEL_COUNT];
} DXGK_ESCAPE_GPUMMUCAPS;

typedef struct _D3DKMT_GET_GPUMMU_CAPS
{
    UINT32 PhysicalAdapterIndex; // In
    DXGK_ESCAPE_GPUMMUCAPS GpuMmuCaps; // Out
} D3DKMT_GET_GPUMMU_CAPS;

#ifdef USE_D3DKMT_SINGLE_HEADER
typedef enum _DXGK_PTE_PAGE_SIZE
{
    DXGK_PTE_PAGE_TABLE_PAGE_4KB = 0,
    DXGK_PTE_PAGE_TABLE_PAGE_64KB = 1,
} DXGK_PTE_PAGE_SIZE;

typedef struct _DXGK_PTE
{
    union
    {
        struct
        {
            ULONGLONG Valid : 1;
            ULONGLONG Zero : 1;
            ULONGLONG CacheCoherent : 1;
            ULONGLONG ReadOnly : 1;
            ULONGLONG NoExecute : 1;
            ULONGLONG Segment : 5;
            ULONGLONG LargePage : 1;
            ULONGLONG PhysicalAdapterIndex : 6;
            ULONGLONG PageTablePageSize : 2; // DXGK_PTE_PAGE_SIZE
            ULONGLONG SystemReserved0 : 1;
            ULONGLONG Reserved : 44;
        };
        ULONGLONG Flags;
    };
    union
    {
        ULONGLONG PageAddress;      // High 52 bits of 64 bit physical address. Low 12 bits are zero.
        ULONGLONG PageTableAddress; // High 52 bits of 64 bit physical address. Low 12 bits are zero.
    };
} DXGK_PTE;
#endif

#define D3DKMT_GET_PTE_MAX 64

typedef struct _D3DKMT_GET_PTE
{
    _In_ UINT32 PhysicalAdapterIndex;
    _In_ UINT32 PageTableLevel;
    _In_ UINT32 PageTableIndex[DXGK_MAX_PAGE_TABLE_LEVEL_COUNT];
    _In_ BOOLEAN b64KBPte; // Valid only when dual PTEs are supported. Out - PT is 64KB.
    _In_ UINT32 NumPtes; // Number of PTEs to fill. Out - number of filled PTEs
    _Out_ DXGK_PTE Pte[D3DKMT_GET_PTE_MAX];
    _Out_ UINT32 NumValidEntries;
} D3DKMT_GET_PTE;

#define D3DKMT_MAX_SEGMENT_COUNT 32

typedef struct _D3DKMT_SEGMENT_CAPS
{
    UINT64 Size;
    UINT32 PageSize;
    ULONG SegmentId;
    BOOLEAN bAperture;
    BOOLEAN bReservedSysMem;
    D3DKMT_MEMORY_SEGMENT_GROUP BudgetGroup;
} D3DKMT_SEGMENT_CAPS;

typedef struct _D3DKMT_GET_SEGMENT_CAPS
{
    _In_ UINT32 PhysicalAdapterIndex;
    _Out_ UINT32 NumSegments;
    _Out_ D3DKMT_SEGMENT_CAPS SegmentCaps[D3DKMT_MAX_SEGMENT_COUNT];
} D3DKMT_GET_SEGMENT_CAPS;

typedef struct _D3DKMT_EVICTION_CRITERIA
{
    UINT64 MinimumSize;
    UINT64 MaximumSize;
    struct
    {
        union
        {
            struct
            {
                UINT32 Primary : 1;
                UINT32 Reserved : 31;
            } Flags;
            UINT32 Value;
        };
    };
} D3DKMT_EVICTION_CRITERIA;

typedef enum _D3DKMT_VAD_ESCAPE_COMMAND
{
    D3DKMT_VAD_ESCAPE_GETNUMVADS,
    D3DKMT_VAD_ESCAPE_GETVAD,
    D3DKMT_VAD_ESCAPE_GETVADRANGE,
    D3DKMT_VAD_ESCAPE_GET_PTE,
    D3DKMT_VAD_ESCAPE_GET_GPUMMU_CAPS,
    D3DKMT_VAD_ESCAPE_GET_SEGMENT_CAPS,
} D3DKMT_VAD_ESCAPE_COMMAND;

typedef enum _D3DKMT_DEFRAG_ESCAPE_OPERATION
{
    D3DKMT_DEFRAG_ESCAPE_GET_FRAGMENTATION_STATS = 0,
    D3DKMT_DEFRAG_ESCAPE_DEFRAG_UPWARD = 1,
    D3DKMT_DEFRAG_ESCAPE_DEFRAG_DOWNWARD = 2,
    D3DKMT_DEFRAG_ESCAPE_DEFRAG_PASS = 3,
    D3DKMT_DEFRAG_ESCAPE_VERIFY_TRANSFER = 4,
} D3DKMT_DEFRAG_ESCAPE_OPERATION;

typedef struct _D3DKMT_VIDMM_ESCAPE
{
    D3DKMT_VIDMMESCAPETYPE Type;
    union
    {
        struct
        {
            union
            {
                struct
                {
                    ULONG ProbeAndLock : 1;
                    ULONG SplitPoint : 1;
                    ULONG NoDemotion : 1;
                    ULONG SwizzlingAperture : 1;
                    ULONG PagingPathLockSubRange : 1;
                    ULONG PagingPathLockMinRange : 1;
                    ULONG ComplexLock : 1;
                    ULONG FailVARotation : 1;
                    ULONG NoWriteCombined : 1;
                    ULONG NoPrePatching : 1;
                    ULONG AlwaysRepatch : 1;
                    ULONG ExpectPreparationFailure : 1;
                    ULONG FailUserModeVAMapping : 1;
                    ULONG NeverDiscardOfferedAllocation : 1; // since WIN8
                    ULONG AlwaysDiscardOfferedAllocation : 1;
                    ULONG Reserved : 17;
                };
                ULONG Value;
            };
        } SetFault;
        struct
        {
            D3DKMT_HANDLE ResourceHandle;
            D3DKMT_HANDLE AllocationHandle;
            HANDLE hProcess; // 0 to evict memory for the current process, otherwise it is a process handle from OpenProcess(PROCESS_ALL_ACCESS, FALSE, ProcessId).
        } Evict;
        struct
        {
            UINT64 NtHandle; // Used by D3DKMT_VIDMMESCAPETYPE_EVICT_BY_NT_HANDLE
        } EvictByNtHandle;
        struct
        {
            union
            {
                struct 
                {
                    UINT32 NumVads;
                } GetNumVads;
                D3DKMT_VAD_DESC GetVad;
                D3DKMT_VA_RANGE_DESC GetVadRange;
                D3DKMT_GET_GPUMMU_CAPS GetGpuMmuCaps;
                D3DKMT_GET_PTE GetPte;
                D3DKMT_GET_SEGMENT_CAPS GetSegmentCaps;
            };
            _In_ D3DKMT_VAD_ESCAPE_COMMAND Command;
            _Out_ NTSTATUS Status;
        } GetVads;
        struct
        {
            ULONGLONG LocalMemoryBudget;
            ULONGLONG SystemMemoryBudget;
        } SetBudget;
        struct
        {
            HANDLE hProcess;
            BOOL bAllowWakeOnSubmission;
        } SuspendProcess;
        struct
        {
            HANDLE hProcess;
        } ResumeProcess;
        struct
        {
            UINT64 NumBytesToTrim;
        } GetBudget;
        struct
        {
            ULONG MinTrimInterval; // In 100ns units
            ULONG MaxTrimInterval; // In 100ns units
            ULONG IdleTrimInterval; // In 100ns units
        } SetTrimIntervals;
        D3DKMT_EVICTION_CRITERIA EvictByCriteria;
        struct
        {
            BOOL bFlush;
        } Wake;
        struct
        {
            D3DKMT_DEFRAG_ESCAPE_OPERATION Operation;          
            UINT32 SegmentId;
            ULONGLONG TotalCommitted;
            ULONGLONG TotalFree;
            ULONGLONG LargestGapBefore;
            ULONGLONG LargestGapAfter;
        } Defrag;
    };
} D3DKMT_VIDMM_ESCAPE;

typedef enum _D3DKMT_TDRDBGCTRLTYPE
{
    D3DKMT_TDRDBGCTRLTYPE_FORCETDR = 0, // Simulate a TDR
    D3DKMT_TDRDBGCTRLTYPE_DISABLEBREAK = 1, // Disable DebugBreak on timeout
    D3DKMT_TDRDBGCTRLTYPE_ENABLEBREAK = 2, // Enable DebugBreak on timeout
    D3DKMT_TDRDBGCTRLTYPE_UNCONDITIONAL = 3, // Disables all safety conditions (e.g. check for consecutive recoveries)
    D3DKMT_TDRDBGCTRLTYPE_VSYNCTDR = 4, // Simulate a Vsync TDR
    D3DKMT_TDRDBGCTRLTYPE_GPUTDR = 5, // Simulate a GPU TDR
    D3DKMT_TDRDBGCTRLTYPE_FORCEDODTDR = 6, // Simulate a Display Only Present TDR // since WIN8
    D3DKMT_TDRDBGCTRLTYPE_FORCEDODVSYNCTDR = 7, // Simulate a Display Only Vsync TDR
    D3DKMT_TDRDBGCTRLTYPE_ENGINETDR = 8, // Simulate an engine TDR
} D3DKMT_TDRDBGCTRLTYPE;

typedef enum _D3DKMT_VIDSCHESCAPETYPE
{
    D3DKMT_VIDSCHESCAPETYPE_PREEMPTIONCONTROL = 0, // Enable/Disable preemption
    D3DKMT_VIDSCHESCAPETYPE_SUSPENDSCHEDULER = 1, // Suspend/Resume scheduler (obsolate)
    D3DKMT_VIDSCHESCAPETYPE_TDRCONTROL = 2, // Tdr control
    D3DKMT_VIDSCHESCAPETYPE_SUSPENDRESUME = 3, // Suspend/Resume scheduler
    D3DKMT_VIDSCHESCAPETYPE_ENABLECONTEXTDELAY = 4, // Enable/Disable context delay // since WIN8
    D3DKMT_VIDSCHESCAPETYPE_CONFIGURE_TDR_LIMIT = 5, // Configure TdrLimitCount and TdrLimitTime
    D3DKMT_VIDSCHESCAPETYPE_VGPU_RESET = 6, // Trigger VGPU reset 
    D3DKMT_VIDSCHESCAPETYPE_PFN_CONTROL = 7, // Periodic frame notification control
} D3DKMT_VIDSCHESCAPETYPE;

typedef enum _D3DKMT_ESCAPE_PFN_CONTROL_COMMAND
{
    D3DKMT_ESCAPE_PFN_CONTROL_DEFAULT,
    D3DKMT_ESCAPE_PFN_CONTROL_FORCE_CPU,
    D3DKMT_ESCAPE_PFN_CONTROL_FORCE_GPU
} D3DKMT_ESCAPE_PFN_CONTROL_COMMAND;

typedef struct _D3DKMT_VIDSCH_ESCAPE
{
    D3DKMT_VIDSCHESCAPETYPE Type;
    union
    {
        BOOL PreemptionControl; // enable/disable preemption
        BOOL EnableContextDelay; // enable/disable context delay // since WIN8
        struct
        {
            ULONG TdrControl; // control tdr
            union
            {
                ULONG NodeOrdinal; // valid if TdrControl is set to D3DKMT_TDRDBGCTRLTYPE_ENGINETDR
            };
        } TdrControl2;
        BOOL SuspendScheduler; // suspend/resume scheduler (obsolate) // since Vista
        ULONG TdrControl; // control tdr
        ULONG SuspendTime; // time period to suspend.
        struct
        {
            UINT Count;
            UINT Time; // In seconds
        } TdrLimit;
        D3DKMT_ESCAPE_PFN_CONTROL_COMMAND PfnControl; // periodic frame notification control
    };
} D3DKMT_VIDSCH_ESCAPE;

typedef enum _D3DKMT_DEVICEESCAPE_TYPE
{
    D3DKMT_DEVICEESCAPE_VIDPNFROMALLOCATION = 0,
    D3DKMT_DEVICEESCAPE_RESTOREGAMMA = 1,
} D3DKMT_DEVICEESCAPE_TYPE;

typedef struct _D3DKMT_DEVICE_ESCAPE
{
    D3DKMT_DEVICEESCAPE_TYPE Type;
    union
    {
        struct
        {
            _In_ D3DKMT_HANDLE hPrimaryAllocation; // Primary allocation handle
            _Out_ UINT32 VidPnSourceId; // VidPnSoureId of primary allocation
        } VidPnFromAllocation;
    };
} D3DKMT_DEVICE_ESCAPE;

typedef enum _D3DKMT_DMMESCAPETYPE
{
    D3DKMT_DMMESCAPETYPE_UNINITIALIZED = 0,
    D3DKMT_DMMESCAPETYPE_GET_SUMMARY_INFO = 1,
    D3DKMT_DMMESCAPETYPE_GET_VIDEO_PRESENT_SOURCES_INFO = 2,
    D3DKMT_DMMESCAPETYPE_GET_VIDEO_PRESENT_TARGETS_INFO = 3,
    D3DKMT_DMMESCAPETYPE_GET_ACTIVEVIDPN_INFO = 4,
    D3DKMT_DMMESCAPETYPE_GET_MONITORS_INFO = 5,
    D3DKMT_DMMESCAPETYPE_RECENTLY_COMMITTED_VIDPNS_INFO = 6,
    D3DKMT_DMMESCAPETYPE_RECENT_MODECHANGE_REQUESTS_INFO = 7,
    D3DKMT_DMMESCAPETYPE_RECENTLY_RECOMMENDED_VIDPNS_INFO = 8,
    D3DKMT_DMMESCAPETYPE_RECENT_MONITOR_PRESENCE_EVENTS_INFO = 9,
    D3DKMT_DMMESCAPETYPE_ACTIVEVIDPN_SOURCEMODESET_INFO = 10,
    D3DKMT_DMMESCAPETYPE_ACTIVEVIDPN_COFUNCPATHMODALITY_INFO = 11,
    D3DKMT_DMMESCAPETYPE_GET_LASTCLIENTCOMMITTEDVIDPN_INFO = 12,
    D3DKMT_DMMESCAPETYPE_GET_VERSION_INFO = 13,
    D3DKMT_DMMESCAPETYPE_VIDPN_MGR_DIAGNOSTICS = 14
} D3DKMT_DMMESCAPETYPE;

typedef struct _D3DKMT_DMM_ESCAPE
{
    _In_ D3DKMT_DMMESCAPETYPE Type;
    _In_ SIZE_T ProvidedBufferSize; // actual size of Data[] array, in bytes.
    _Out_ SIZE_T MinRequiredBufferSize; // minimum required size of Data[] array to contain requested data.
    _Out_writes_bytes_(ProvidedBufferSize) UCHAR Data[1];
} D3DKMT_DMM_ESCAPE;

typedef struct _D3DKMT_DEBUG_SNAPSHOT_ESCAPE
{
    ULONG Length; // out: Actual length of the snapshot written in Buffer
    BYTE Buffer[1]; // out: Buffer to place snapshot
} D3DKMT_DEBUG_SNAPSHOT_ESCAPE;

typedef enum _D3DKMT_ACTIVATE_SPECIFIC_DIAG_TYPE
{
    D3DKMT_ACTIVATE_SPECIFIC_DIAG_TYPE_EXTRA_CCD_DATABASE_INFO = 0,
    D3DKMT_ACTIVATE_SPECIFIC_DIAG_TYPE_MODES_PRUNED = 15,
}D3DKMT_ACTIVATE_SPECIFIC_DIAG_TYPE;

typedef struct _D3DKMT_ACTIVATE_SPECIFIC_DIAG_ESCAPE
{
    D3DKMT_ACTIVATE_SPECIFIC_DIAG_TYPE Type; // The escape type that needs to be (de)activated
    BOOL Activate; // FALSE means deactivate
} D3DKMT_ACTIVATE_SPECIFIC_DIAG_ESCAPE;

typedef struct _D3DKMT_REQUEST_MACHINE_CRASH_ESCAPE
{
    ULONG_PTR Param1;
    ULONG_PTR Param2;
    ULONG_PTR Param3;
} D3DKMT_REQUEST_MACHINE_CRASH_ESCAPE;

#ifdef USE_D3DKMT_SINGLE_HEADER
typedef struct _D3DDDI_ESCAPEFLAGS
{
    union
    {
        struct
        {
            UINT32 HardwareAccess : 1;
            UINT32 DeviceStatusQuery : 1; // since WDDM1_3
            UINT32 ChangeFrameLatency : 1;
            UINT32 NoAdapterSynchronization : 1; // since WDDM2_0
            UINT32 Reserved : 1; // Used internally by DisplayOnly present // since WDDM2_2
            UINT32 VirtualMachineData : 1; // Cannot be set from user mode
            UINT32 DriverKnownEscape : 1; // Driver private data points to a well known structure
            UINT32 DriverCommonEscape : 1; // Private data points runtime defined structure
            UINT32 Reserved2 : 24;
        };
        UINT32 Value;
    };
} D3DDDI_ESCAPEFLAGS;
#endif

// The D3DKMT_ESCAPE structure describes information that is exchanged with the display miniport driver.
typedef struct _D3DKMT_ESCAPE 
{
    _In_ D3DKMT_HANDLE AdapterHandle;
    _In_opt_ D3DKMT_HANDLE DeviceHandle;
    _In_ D3DKMT_ESCAPETYPE Type;
    _In_ D3DDDI_ESCAPEFLAGS Flags;
    _Inout_ PVOID PrivateDriverData;
    _In_ UINT32 PrivateDriverDataSize;
    _In_opt_ D3DKMT_HANDLE ContextHandle;
} D3DKMT_ESCAPE;

// Function pointers

NTSYSAPI
NTSTATUS
NTAPI
D3DKMTOpenAdapterFromDeviceName(
    _Inout_ CONST D3DKMT_OPENADAPTERFROMDEVICENAME *pData
    );

NTSYSAPI
NTSTATUS
NTAPI
D3DKMTOpenAdapterFromGdiDisplayName(
    _Inout_ CONST D3DKMT_OPENADAPTERFROMGDIDISPLAYNAME *pData
    );

NTSYSAPI
NTSTATUS
NTAPI
D3DKMTOpenAdapterFromHdc(
    _Inout_ CONST D3DKMT_OPENADAPTERFROMHDC *pData
    );

NTSYSAPI
NTSTATUS
NTAPI
D3DKMTOpenAdapterFromLuid(
    _Inout_ CONST D3DKMT_OPENADAPTERFROMLUID *pAdapter
    );

NTSYSAPI
NTSTATUS
NTAPI
D3DKMTEnumAdapters(
    _Inout_ CONST D3DKMT_ENUMADAPTERS *pData
    );

NTSYSAPI
NTSTATUS
NTAPI
D3DKMTEnumAdapters2(
    _Inout_ CONST D3DKMT_ENUMADAPTERS2 *pData
    );

NTSYSAPI
NTSTATUS
NTAPI
D3DKMTEnumAdapters3(
    _Inout_ CONST D3DKMT_ENUMADAPTERS2* pData
    );

NTSYSAPI
NTSTATUS
NTAPI
D3DKMTCloseAdapter(
    _In_ CONST D3DKMT_CLOSEADAPTER *pData
    );

NTSYSAPI
NTSTATUS
NTAPI 
D3DKMTQueryAdapterInfo(
    _Inout_ CONST D3DKMT_QUERYADAPTERINFO *pData
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
D3DKMTQueryStatistics(
    _Inout_ CONST D3DKMT_QUERYSTATISTICS *pData
    );

NTSYSAPI
NTSTATUS
NTAPI
D3DKMTQueryVideoMemoryInfo(
    _Inout_ CONST D3DKMT_QUERYVIDEOMEMORYINFO *pData
    );

NTSYSAPI
NTSTATUS
NTAPI
D3DKMTEscape(
    _Inout_ CONST D3DKMT_ESCAPE *pData
    );

NTSYSAPI
NTSTATUS
NTAPI
D3DKMTSetProcessSchedulingPriorityClass(
    _In_ HANDLE, 
    _In_ enum D3DKMT_SCHEDULINGPRIORITYCLASS
    );

NTSYSAPI
NTSTATUS
NTAPI
D3DKMTGetProcessSchedulingPriorityClass(
    _In_ HANDLE, 
    _Out_ enum D3DKMT_SCHEDULINGPRIORITYCLASS*
    );

#endif

```

`phnt/ntdbg.h`:

```h
/*
 * Process Hacker -
 *   Debugger support functions
 *
 * This file is part of Process Hacker.
 *
 * Process Hacker is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Process Hacker is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Process Hacker.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef _NTDBG_H
#define _NTDBG_H

// Debugging

NTSYSAPI
VOID
NTAPI
DbgUserBreakPoint(
    VOID
    );

NTSYSAPI
VOID
NTAPI
DbgBreakPoint(
    VOID
    );

NTSYSAPI
VOID
NTAPI
DbgBreakPointWithStatus(
    _In_ ULONG Status
    );

#define DBG_STATUS_CONTROL_C 1
#define DBG_STATUS_SYSRQ 2
#define DBG_STATUS_BUGCHECK_FIRST 3
#define DBG_STATUS_BUGCHECK_SECOND 4
#define DBG_STATUS_FATAL 5
#define DBG_STATUS_DEBUG_CONTROL 6
#define DBG_STATUS_WORKER 7

NTSYSAPI
ULONG
STDAPIVCALLTYPE
DbgPrint(
    _In_z_ _Printf_format_string_ PSTR Format,
    ...
    );

NTSYSAPI
ULONG
STDAPIVCALLTYPE
DbgPrintEx(
    _In_ ULONG ComponentId,
    _In_ ULONG Level,
    _In_z_ _Printf_format_string_ PSTR Format,
    ...
    );

NTSYSAPI
ULONG
NTAPI
vDbgPrintEx(
    _In_ ULONG ComponentId,
    _In_ ULONG Level,
    _In_z_ PCH Format,
    _In_ va_list arglist
    );

NTSYSAPI
ULONG
NTAPI
vDbgPrintExWithPrefix(
    _In_z_ PCH Prefix,
    _In_ ULONG ComponentId,
    _In_ ULONG Level,
    _In_z_ PCH Format,
    _In_ va_list arglist
    );

NTSYSAPI
NTSTATUS
NTAPI
DbgQueryDebugFilterState(
    _In_ ULONG ComponentId,
    _In_ ULONG Level
    );

NTSYSAPI
NTSTATUS
NTAPI
DbgSetDebugFilterState(
    _In_ ULONG ComponentId,
    _In_ ULONG Level,
    _In_ BOOLEAN State
    );

NTSYSAPI
ULONG
NTAPI
DbgPrompt(
    _In_ PCH Prompt,
    _Out_writes_bytes_(Length) PCH Response,
    _In_ ULONG Length
    );

// Definitions

typedef struct _DBGKM_EXCEPTION
{
    EXCEPTION_RECORD ExceptionRecord;
    ULONG FirstChance;
} DBGKM_EXCEPTION, *PDBGKM_EXCEPTION;

typedef struct _DBGKM_CREATE_THREAD
{
    ULONG SubSystemKey;
    PVOID StartAddress;
} DBGKM_CREATE_THREAD, *PDBGKM_CREATE_THREAD;

typedef struct _DBGKM_CREATE_PROCESS
{
    ULONG SubSystemKey;
    HANDLE FileHandle;
    PVOID BaseOfImage;
    ULONG DebugInfoFileOffset;
    ULONG DebugInfoSize;
    DBGKM_CREATE_THREAD InitialThread;
} DBGKM_CREATE_PROCESS, *PDBGKM_CREATE_PROCESS;

typedef struct _DBGKM_EXIT_THREAD
{
    NTSTATUS ExitStatus;
} DBGKM_EXIT_THREAD, *PDBGKM_EXIT_THREAD;

typedef struct _DBGKM_EXIT_PROCESS
{
    NTSTATUS ExitStatus;
} DBGKM_EXIT_PROCESS, *PDBGKM_EXIT_PROCESS;

typedef struct _DBGKM_LOAD_DLL
{
    HANDLE FileHandle;
    PVOID BaseOfDll;
    ULONG DebugInfoFileOffset;
    ULONG DebugInfoSize;
    PVOID NamePointer;
} DBGKM_LOAD_DLL, *PDBGKM_LOAD_DLL;

typedef struct _DBGKM_UNLOAD_DLL
{
    PVOID BaseAddress;
} DBGKM_UNLOAD_DLL, *PDBGKM_UNLOAD_DLL;

typedef enum _DBG_STATE
{
    DbgIdle,
    DbgReplyPending,
    DbgCreateThreadStateChange,
    DbgCreateProcessStateChange,
    DbgExitThreadStateChange,
    DbgExitProcessStateChange,
    DbgExceptionStateChange,
    DbgBreakpointStateChange,
    DbgSingleStepStateChange,
    DbgLoadDllStateChange,
    DbgUnloadDllStateChange
} DBG_STATE, *PDBG_STATE;

typedef struct _DBGUI_CREATE_THREAD
{
    HANDLE HandleToThread;
    DBGKM_CREATE_THREAD NewThread;
} DBGUI_CREATE_THREAD, *PDBGUI_CREATE_THREAD;

typedef struct _DBGUI_CREATE_PROCESS
{
    HANDLE HandleToProcess;
    HANDLE HandleToThread;
    DBGKM_CREATE_PROCESS NewProcess;
} DBGUI_CREATE_PROCESS, *PDBGUI_CREATE_PROCESS;

typedef struct _DBGUI_WAIT_STATE_CHANGE
{
    DBG_STATE NewState;
    CLIENT_ID AppClientId;
    union
    {
        DBGKM_EXCEPTION Exception;
        DBGUI_CREATE_THREAD CreateThread;
        DBGUI_CREATE_PROCESS CreateProcessInfo;
        DBGKM_EXIT_THREAD ExitThread;
        DBGKM_EXIT_PROCESS ExitProcess;
        DBGKM_LOAD_DLL LoadDll;
        DBGKM_UNLOAD_DLL UnloadDll;
    } StateInfo;
} DBGUI_WAIT_STATE_CHANGE, *PDBGUI_WAIT_STATE_CHANGE;

#define DEBUG_READ_EVENT 0x0001
#define DEBUG_PROCESS_ASSIGN 0x0002
#define DEBUG_SET_INFORMATION 0x0004
#define DEBUG_QUERY_INFORMATION 0x0008
#define DEBUG_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
    DEBUG_READ_EVENT | DEBUG_PROCESS_ASSIGN | DEBUG_SET_INFORMATION | \
    DEBUG_QUERY_INFORMATION)

#define DEBUG_KILL_ON_CLOSE 0x1

typedef enum _DEBUGOBJECTINFOCLASS
{
    DebugObjectUnusedInformation,
    DebugObjectKillProcessOnExitInformation,
    MaxDebugObjectInfoClass
} DEBUGOBJECTINFOCLASS, *PDEBUGOBJECTINFOCLASS;

// System calls

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateDebugObject(
    _Out_ PHANDLE DebugObjectHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDebugActiveProcess(
    _In_ HANDLE ProcessHandle,
    _In_ HANDLE DebugObjectHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDebugContinue(
    _In_ HANDLE DebugObjectHandle,
    _In_ PCLIENT_ID ClientId,
    _In_ NTSTATUS ContinueStatus
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRemoveProcessDebug(
    _In_ HANDLE ProcessHandle,
    _In_ HANDLE DebugObjectHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationDebugObject(
    _In_ HANDLE DebugObjectHandle,
    _In_ DEBUGOBJECTINFOCLASS DebugObjectInformationClass,
    _In_ PVOID DebugInformation,
    _In_ ULONG DebugInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWaitForDebugEvent(
    _In_ HANDLE DebugObjectHandle,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout,
    _Out_ PDBGUI_WAIT_STATE_CHANGE WaitStateChange
    );

// Debugging UI

NTSYSAPI
NTSTATUS
NTAPI
DbgUiConnectToDbg(
    VOID
    );

NTSYSAPI
HANDLE
NTAPI
DbgUiGetThreadDebugObject(
    VOID
    );

NTSYSAPI
VOID
NTAPI
DbgUiSetThreadDebugObject(
    _In_ HANDLE DebugObject
    );

NTSYSAPI
NTSTATUS
NTAPI
DbgUiWaitStateChange(
    _Out_ PDBGUI_WAIT_STATE_CHANGE StateChange,
    _In_opt_ PLARGE_INTEGER Timeout
    );

NTSYSAPI
NTSTATUS
NTAPI
DbgUiContinue(
    _In_ PCLIENT_ID AppClientId,
    _In_ NTSTATUS ContinueStatus
    );

NTSYSAPI
NTSTATUS
NTAPI
DbgUiStopDebugging(
    _In_ HANDLE Process
    );

NTSYSAPI
NTSTATUS
NTAPI
DbgUiDebugActiveProcess(
    _In_ HANDLE Process
    );

NTSYSAPI
VOID
NTAPI
DbgUiRemoteBreakin(
    _In_ PVOID Context
    );

NTSYSAPI
NTSTATUS
NTAPI
DbgUiIssueRemoteBreakin(
    _In_ HANDLE Process
    );

NTSYSAPI
NTSTATUS
NTAPI
DbgUiConvertStateChangeStructure(
    _In_ PDBGUI_WAIT_STATE_CHANGE StateChange,
    _Out_ LPDEBUG_EVENT DebugEvent
    );

struct _EVENT_FILTER_DESCRIPTOR;

typedef VOID (NTAPI *PENABLECALLBACK)(
    _In_ LPCGUID SourceId,
    _In_ ULONG IsEnabled,
    _In_ UCHAR Level,
    _In_ ULONGLONG MatchAnyKeyword,
    _In_ ULONGLONG MatchAllKeyword,
    _In_opt_ struct _EVENT_FILTER_DESCRIPTOR *FilterData,
    _Inout_opt_ PVOID CallbackContext
    );

typedef ULONGLONG REGHANDLE, *PREGHANDLE;

NTSYSAPI
NTSTATUS
NTAPI
EtwEventRegister(
    _In_ LPCGUID ProviderId,
    _In_opt_ PENABLECALLBACK EnableCallback,
    _In_opt_ PVOID CallbackContext,
    _Out_ PREGHANDLE RegHandle
    );

#endif

```

`phnt/ntexapi.h`:

```h
/*
 * Process Hacker -
 *   Executive support library functions
 *
 * This file is part of Process Hacker.
 *
 * Process Hacker is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Process Hacker is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Process Hacker.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef _NTEXAPI_H
#define _NTEXAPI_H

#include "ntkeapi.h"

#if (PHNT_MODE != PHNT_MODE_KERNEL)

// Thread execution

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDelayExecution(
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER DelayInterval
    );

// Environment values

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySystemEnvironmentValue(
    _In_ PUNICODE_STRING VariableName,
    _Out_writes_bytes_(ValueLength) PWSTR VariableValue,
    _In_ USHORT ValueLength,
    _Out_opt_ PUSHORT ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetSystemEnvironmentValue(
    _In_ PUNICODE_STRING VariableName,
    _In_ PUNICODE_STRING VariableValue
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySystemEnvironmentValueEx(
    _In_ PUNICODE_STRING VariableName,
    _In_ LPGUID VendorGuid,
    _Out_writes_bytes_opt_(*ValueLength) PVOID Value,
    _Inout_ PULONG ValueLength,
    _Out_opt_ PULONG Attributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetSystemEnvironmentValueEx(
    _In_ PUNICODE_STRING VariableName,
    _In_ LPGUID VendorGuid,
    _In_reads_bytes_opt_(ValueLength) PVOID Value,
    _In_ ULONG ValueLength,
    _In_ ULONG Attributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtEnumerateSystemEnvironmentValuesEx(
    _In_ ULONG InformationClass,
    _Out_ PVOID Buffer,
    _Inout_ PULONG BufferLength
    );

// EFI

// private
typedef struct _BOOT_ENTRY
{
    ULONG Version;
    ULONG Length;
    ULONG Id;
    ULONG Attributes;
    ULONG FriendlyNameOffset;
    ULONG BootFilePathOffset;
    ULONG OsOptionsLength;
    UCHAR OsOptions[1];
} BOOT_ENTRY, *PBOOT_ENTRY;

// private
typedef struct _BOOT_ENTRY_LIST
{
    ULONG NextEntryOffset;
    BOOT_ENTRY BootEntry;
} BOOT_ENTRY_LIST, *PBOOT_ENTRY_LIST;

// private
typedef struct _BOOT_OPTIONS
{
    ULONG Version;
    ULONG Length;
    ULONG Timeout;
    ULONG CurrentBootEntryId;
    ULONG NextBootEntryId;
    WCHAR HeadlessRedirection[1];
} BOOT_OPTIONS, *PBOOT_OPTIONS;

// private
typedef struct _FILE_PATH
{
    ULONG Version;
    ULONG Length;
    ULONG Type;
    UCHAR FilePath[1];
} FILE_PATH, *PFILE_PATH;

// private
typedef struct _EFI_DRIVER_ENTRY
{
    ULONG Version;
    ULONG Length;
    ULONG Id;
    ULONG FriendlyNameOffset;
    ULONG DriverFilePathOffset;
} EFI_DRIVER_ENTRY, *PEFI_DRIVER_ENTRY;

// private
typedef struct _EFI_DRIVER_ENTRY_LIST
{
    ULONG NextEntryOffset;
    EFI_DRIVER_ENTRY DriverEntry;
} EFI_DRIVER_ENTRY_LIST, *PEFI_DRIVER_ENTRY_LIST;

#if (PHNT_VERSION >= PHNT_VISTA)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAddBootEntry(
    _In_ PBOOT_ENTRY BootEntry,
    _Out_opt_ PULONG Id
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeleteBootEntry(
    _In_ ULONG Id
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtModifyBootEntry(
    _In_ PBOOT_ENTRY BootEntry
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtEnumerateBootEntries(
    _Out_writes_bytes_opt_(*BufferLength) PVOID Buffer,
    _Inout_ PULONG BufferLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryBootEntryOrder(
    _Out_writes_opt_(*Count) PULONG Ids,
    _Inout_ PULONG Count
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetBootEntryOrder(
    _In_reads_(Count) PULONG Ids,
    _In_ ULONG Count
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryBootOptions(
    _Out_writes_bytes_opt_(*BootOptionsLength) PBOOT_OPTIONS BootOptions,
    _Inout_ PULONG BootOptionsLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetBootOptions(
    _In_ PBOOT_OPTIONS BootOptions,
    _In_ ULONG FieldsToChange
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtTranslateFilePath(
    _In_ PFILE_PATH InputFilePath,
    _In_ ULONG OutputType,
    _Out_writes_bytes_opt_(*OutputFilePathLength) PFILE_PATH OutputFilePath,
    _Inout_opt_ PULONG OutputFilePathLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAddDriverEntry(
    _In_ PEFI_DRIVER_ENTRY DriverEntry,
    _Out_opt_ PULONG Id
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeleteDriverEntry(
    _In_ ULONG Id
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtModifyDriverEntry(
    _In_ PEFI_DRIVER_ENTRY DriverEntry
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtEnumerateDriverEntries(
    _Out_writes_bytes_opt_(*BufferLength) PVOID Buffer,
    _Inout_ PULONG BufferLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryDriverEntryOrder(
    _Out_writes_opt_(*Count) PULONG Ids,
    _Inout_ PULONG Count
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetDriverEntryOrder(
    _In_reads_(Count) PULONG Ids,
    _In_ ULONG Count
    );

typedef enum _FILTER_BOOT_OPTION_OPERATION
{
    FilterBootOptionOperationOpenSystemStore,
    FilterBootOptionOperationSetElement,
    FilterBootOptionOperationDeleteElement,
    FilterBootOptionOperationMax
} FILTER_BOOT_OPTION_OPERATION;

#if (PHNT_VERSION >= PHNT_THRESHOLD)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtFilterBootOption(
    _In_ FILTER_BOOT_OPTION_OPERATION FilterOperation,
    _In_ ULONG ObjectType,
    _In_ ULONG ElementType,
    _In_reads_bytes_opt_(DataSize) PVOID Data,
    _In_ ULONG DataSize
    );
#endif

#endif

// Event

#ifndef EVENT_QUERY_STATE
#define EVENT_QUERY_STATE 0x0001
#endif

typedef enum _EVENT_INFORMATION_CLASS
{
    EventBasicInformation
} EVENT_INFORMATION_CLASS;

typedef struct _EVENT_BASIC_INFORMATION
{
    EVENT_TYPE EventType;
    LONG EventState;
} EVENT_BASIC_INFORMATION, *PEVENT_BASIC_INFORMATION;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateEvent(
    _Out_ PHANDLE EventHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ EVENT_TYPE EventType,
    _In_ BOOLEAN InitialState
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenEvent(
    _Out_ PHANDLE EventHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetEvent(
    _In_ HANDLE EventHandle,
    _Out_opt_ PLONG PreviousState
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetEventBoostPriority(
    _In_ HANDLE EventHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtClearEvent(
    _In_ HANDLE EventHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtResetEvent(
    _In_ HANDLE EventHandle,
    _Out_opt_ PLONG PreviousState
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPulseEvent(
    _In_ HANDLE EventHandle,
    _Out_opt_ PLONG PreviousState
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryEvent(
    _In_ HANDLE EventHandle,
    _In_ EVENT_INFORMATION_CLASS EventInformationClass,
    _Out_writes_bytes_(EventInformationLength) PVOID EventInformation,
    _In_ ULONG EventInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

// Event Pair

#define EVENT_PAIR_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateEventPair(
    _Out_ PHANDLE EventPairHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenEventPair(
    _Out_ PHANDLE EventPairHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetLowEventPair(
    _In_ HANDLE EventPairHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetHighEventPair(
    _In_ HANDLE EventPairHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWaitLowEventPair(
    _In_ HANDLE EventPairHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWaitHighEventPair(
    _In_ HANDLE EventPairHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetLowWaitHighEventPair(
    _In_ HANDLE EventPairHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetHighWaitLowEventPair(
    _In_ HANDLE EventPairHandle
    );

// Mutant

typedef enum _MUTANT_INFORMATION_CLASS
{
    MutantBasicInformation,
    MutantOwnerInformation
} MUTANT_INFORMATION_CLASS;

typedef struct _MUTANT_BASIC_INFORMATION
{
    LONG CurrentCount;
    BOOLEAN OwnedByCaller;
    BOOLEAN AbandonedState;
} MUTANT_BASIC_INFORMATION, *PMUTANT_BASIC_INFORMATION;

typedef struct _MUTANT_OWNER_INFORMATION
{
    CLIENT_ID ClientId;
} MUTANT_OWNER_INFORMATION, *PMUTANT_OWNER_INFORMATION;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateMutant(
    _Out_ PHANDLE MutantHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ BOOLEAN InitialOwner
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenMutant(
    _Out_ PHANDLE MutantHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReleaseMutant(
    _In_ HANDLE MutantHandle,
    _Out_opt_ PLONG PreviousCount
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryMutant(
    _In_ HANDLE MutantHandle,
    _In_ MUTANT_INFORMATION_CLASS MutantInformationClass,
    _Out_writes_bytes_(MutantInformationLength) PVOID MutantInformation,
    _In_ ULONG MutantInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

// Semaphore

#ifndef SEMAPHORE_QUERY_STATE
#define SEMAPHORE_QUERY_STATE 0x0001
#endif

typedef enum _SEMAPHORE_INFORMATION_CLASS
{
    SemaphoreBasicInformation
} SEMAPHORE_INFORMATION_CLASS;

typedef struct _SEMAPHORE_BASIC_INFORMATION
{
    LONG CurrentCount;
    LONG MaximumCount;
} SEMAPHORE_BASIC_INFORMATION, *PSEMAPHORE_BASIC_INFORMATION;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateSemaphore(
    _Out_ PHANDLE SemaphoreHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ LONG InitialCount,
    _In_ LONG MaximumCount
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenSemaphore(
    _Out_ PHANDLE SemaphoreHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReleaseSemaphore(
    _In_ HANDLE SemaphoreHandle,
    _In_ LONG ReleaseCount,
    _Out_opt_ PLONG PreviousCount
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySemaphore(
    _In_ HANDLE SemaphoreHandle,
    _In_ SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass,
    _Out_writes_bytes_(SemaphoreInformationLength) PVOID SemaphoreInformation,
    _In_ ULONG SemaphoreInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

// Timer

typedef enum _TIMER_INFORMATION_CLASS
{
    TimerBasicInformation
} TIMER_INFORMATION_CLASS;

typedef struct _TIMER_BASIC_INFORMATION
{
    LARGE_INTEGER RemainingTime;
    BOOLEAN TimerState;
} TIMER_BASIC_INFORMATION, *PTIMER_BASIC_INFORMATION;

typedef VOID (NTAPI *PTIMER_APC_ROUTINE)(
    _In_ PVOID TimerContext,
    _In_ ULONG TimerLowValue,
    _In_ LONG TimerHighValue
    );

typedef enum _TIMER_SET_INFORMATION_CLASS
{
    TimerSetCoalescableTimer,
    MaxTimerInfoClass
} TIMER_SET_INFORMATION_CLASS;

#if (PHNT_VERSION >= PHNT_WIN7)
struct _COUNTED_REASON_CONTEXT;

typedef struct _TIMER_SET_COALESCABLE_TIMER_INFO
{
    _In_ LARGE_INTEGER DueTime;
    _In_opt_ PTIMER_APC_ROUTINE TimerApcRoutine;
    _In_opt_ PVOID TimerContext;
    _In_opt_ struct _COUNTED_REASON_CONTEXT *WakeContext;
    _In_opt_ ULONG Period;
    _In_ ULONG TolerableDelay;
    _Out_opt_ PBOOLEAN PreviousState;
} TIMER_SET_COALESCABLE_TIMER_INFO, *PTIMER_SET_COALESCABLE_TIMER_INFO;
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateTimer(
    _Out_ PHANDLE TimerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ TIMER_TYPE TimerType
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenTimer(
    _Out_ PHANDLE TimerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetTimer(
    _In_ HANDLE TimerHandle,
    _In_ PLARGE_INTEGER DueTime,
    _In_opt_ PTIMER_APC_ROUTINE TimerApcRoutine,
    _In_opt_ PVOID TimerContext,
    _In_ BOOLEAN ResumeTimer,
    _In_opt_ LONG Period,
    _Out_opt_ PBOOLEAN PreviousState
    );

#if (PHNT_VERSION >= PHNT_WIN7)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetTimerEx(
    _In_ HANDLE TimerHandle,
    _In_ TIMER_SET_INFORMATION_CLASS TimerSetInformationClass,
    _Inout_updates_bytes_opt_(TimerSetInformationLength) PVOID TimerSetInformation,
    _In_ ULONG TimerSetInformationLength
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCancelTimer(
    _In_ HANDLE TimerHandle,
    _Out_opt_ PBOOLEAN CurrentState
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryTimer(
    _In_ HANDLE TimerHandle,
    _In_ TIMER_INFORMATION_CLASS TimerInformationClass,
    _Out_writes_bytes_(TimerInformationLength) PVOID TimerInformation,
    _In_ ULONG TimerInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

#if (PHNT_VERSION >= PHNT_WIN8)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateIRTimer(
    _Out_ PHANDLE TimerHandle,
    _In_ ACCESS_MASK DesiredAccess
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetIRTimer(
    _In_ HANDLE TimerHandle,
    _In_opt_ PLARGE_INTEGER DueTime
    );

#endif

typedef struct _T2_SET_PARAMETERS_V0
{
    ULONG Version;
    ULONG Reserved;
    LONGLONG NoWakeTolerance;
} T2_SET_PARAMETERS, *PT2_SET_PARAMETERS;

typedef PVOID PT2_CANCEL_PARAMETERS;

#if (PHNT_VERSION >= PHNT_THRESHOLD)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateTimer2(
    _Out_ PHANDLE TimerHandle,
    _In_opt_ PVOID Reserved1,
    _In_opt_ PVOID Reserved2,
    _In_ ULONG Attributes,
    _In_ ACCESS_MASK DesiredAccess
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetTimer2(
    _In_ HANDLE TimerHandle,
    _In_ PLARGE_INTEGER DueTime,
    _In_opt_ PLARGE_INTEGER Period,
    _In_ PT2_SET_PARAMETERS Parameters
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCancelTimer2(
    _In_ HANDLE TimerHandle,
    _In_ PT2_CANCEL_PARAMETERS Parameters
    );

#endif

// Profile

#define PROFILE_CONTROL 0x0001
#define PROFILE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | PROFILE_CONTROL)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateProfile(
    _Out_ PHANDLE ProfileHandle,
    _In_opt_ HANDLE Process,
    _In_ PVOID ProfileBase,
    _In_ SIZE_T ProfileSize,
    _In_ ULONG BucketSize,
    _In_reads_bytes_(BufferSize) PULONG Buffer,
    _In_ ULONG BufferSize,
    _In_ KPROFILE_SOURCE ProfileSource,
    _In_ KAFFINITY Affinity
    );

#if (PHNT_VERSION >= PHNT_WIN7)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateProfileEx(
    _Out_ PHANDLE ProfileHandle,
    _In_opt_ HANDLE Process,
    _In_ PVOID ProfileBase,
    _In_ SIZE_T ProfileSize,
    _In_ ULONG BucketSize,
    _In_reads_bytes_(BufferSize) PULONG Buffer,
    _In_ ULONG BufferSize,
    _In_ KPROFILE_SOURCE ProfileSource,
    _In_ USHORT GroupCount,
    _In_reads_(GroupCount) PGROUP_AFFINITY GroupAffinity
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtStartProfile(
    _In_ HANDLE ProfileHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtStopProfile(
    _In_ HANDLE ProfileHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryIntervalProfile(
    _In_ KPROFILE_SOURCE ProfileSource,
    _Out_ PULONG Interval
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetIntervalProfile(
    _In_ ULONG Interval,
    _In_ KPROFILE_SOURCE Source
    );

// Keyed Event

#define KEYEDEVENT_WAIT 0x0001
#define KEYEDEVENT_WAKE 0x0002
#define KEYEDEVENT_ALL_ACCESS \
    (STANDARD_RIGHTS_REQUIRED | KEYEDEVENT_WAIT | KEYEDEVENT_WAKE)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateKeyedEvent(
    _Out_ PHANDLE KeyedEventHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenKeyedEvent(
    _Out_ PHANDLE KeyedEventHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReleaseKeyedEvent(
    _In_ HANDLE KeyedEventHandle,
    _In_ PVOID KeyValue,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWaitForKeyedEvent(
    _In_ HANDLE KeyedEventHandle,
    _In_ PVOID KeyValue,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout
    );

// UMS

#if (PHNT_VERSION >= PHNT_WIN7)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtUmsThreadYield(
    _In_ PVOID SchedulerParam
    );
#endif

// WNF

// begin_private

typedef struct _WNF_STATE_NAME
{
    ULONG Data[2];
} WNF_STATE_NAME, *PWNF_STATE_NAME;

typedef const WNF_STATE_NAME *PCWNF_STATE_NAME;

typedef enum _WNF_STATE_NAME_LIFETIME
{
    WnfWellKnownStateName,
    WnfPermanentStateName,
    WnfPersistentStateName,
    WnfTemporaryStateName
} WNF_STATE_NAME_LIFETIME;

typedef enum _WNF_STATE_NAME_INFORMATION
{
    WnfInfoStateNameExist,
    WnfInfoSubscribersPresent,
    WnfInfoIsQuiescent
} WNF_STATE_NAME_INFORMATION;

typedef enum _WNF_DATA_SCOPE
{
    WnfDataScopeSystem,
    WnfDataScopeSession,
    WnfDataScopeUser,
    WnfDataScopeProcess,
    WnfDataScopeMachine // REDSTONE3
} WNF_DATA_SCOPE;

typedef struct _WNF_TYPE_ID
{
    GUID TypeId;
} WNF_TYPE_ID, *PWNF_TYPE_ID;

typedef const WNF_TYPE_ID *PCWNF_TYPE_ID;

// rev
typedef ULONG WNF_CHANGE_STAMP, *PWNF_CHANGE_STAMP;

typedef struct _WNF_DELIVERY_DESCRIPTOR
{
    ULONGLONG SubscriptionId;
    WNF_STATE_NAME StateName;
    WNF_CHANGE_STAMP ChangeStamp;
    ULONG StateDataSize;
    ULONG EventMask;
    WNF_TYPE_ID TypeId;
    ULONG StateDataOffset;
} WNF_DELIVERY_DESCRIPTOR, *PWNF_DELIVERY_DESCRIPTOR;

// end_private

#if (PHNT_VERSION >= PHNT_WIN8)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateWnfStateName(
    _Out_ PWNF_STATE_NAME StateName,
    _In_ WNF_STATE_NAME_LIFETIME NameLifetime,
    _In_ WNF_DATA_SCOPE DataScope,
    _In_ BOOLEAN PersistData,
    _In_opt_ PCWNF_TYPE_ID TypeId,
    _In_ ULONG MaximumStateSize,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeleteWnfStateName(
    _In_ PCWNF_STATE_NAME StateName
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtUpdateWnfStateData(
    _In_ PCWNF_STATE_NAME StateName,
    _In_reads_bytes_opt_(Length) const VOID *Buffer,
    _In_opt_ ULONG Length,
    _In_opt_ PCWNF_TYPE_ID TypeId,
    _In_opt_ const VOID *ExplicitScope,
    _In_ WNF_CHANGE_STAMP MatchingChangeStamp,
    _In_ LOGICAL CheckStamp
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeleteWnfStateData(
    _In_ PCWNF_STATE_NAME StateName,
    _In_opt_ const VOID *ExplicitScope
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryWnfStateData(
    _In_ PCWNF_STATE_NAME StateName,
    _In_opt_ PCWNF_TYPE_ID TypeId,
    _In_opt_ const VOID *ExplicitScope,
    _Out_ PWNF_CHANGE_STAMP ChangeStamp,
    _Out_writes_bytes_to_opt_(*BufferSize, *BufferSize) PVOID Buffer,
    _Inout_ PULONG BufferSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryWnfStateNameInformation(
    _In_ PCWNF_STATE_NAME StateName,
    _In_ WNF_STATE_NAME_INFORMATION NameInfoClass,
    _In_opt_ const VOID *ExplicitScope,
    _Out_writes_bytes_(InfoBufferSize) PVOID InfoBuffer,
    _In_ ULONG InfoBufferSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSubscribeWnfStateChange(
    _In_ PCWNF_STATE_NAME StateName,
    _In_opt_ WNF_CHANGE_STAMP ChangeStamp,
    _In_ ULONG EventMask,
    _Out_opt_ PULONG64 SubscriptionId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnsubscribeWnfStateChange(
    _In_ PCWNF_STATE_NAME StateName
    );

#endif

#if (PHNT_VERSION >= PHNT_THRESHOLD)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtGetCompleteWnfStateSubscription(
    _In_opt_ PWNF_STATE_NAME OldDescriptorStateName,
    _In_opt_ ULONG64 *OldSubscriptionId,
    _In_opt_ ULONG OldDescriptorEventMask,
    _In_opt_ ULONG OldDescriptorStatus,
    _Out_writes_bytes_(DescriptorSize) PWNF_DELIVERY_DESCRIPTOR NewDeliveryDescriptor,
    _In_ ULONG DescriptorSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetWnfProcessNotificationEvent(
    _In_ HANDLE NotificationEvent
    );

#endif

// Worker factory

// begin_rev

#define WORKER_FACTORY_RELEASE_WORKER 0x0001
#define WORKER_FACTORY_WAIT 0x0002
#define WORKER_FACTORY_SET_INFORMATION 0x0004
#define WORKER_FACTORY_QUERY_INFORMATION 0x0008
#define WORKER_FACTORY_READY_WORKER 0x0010
#define WORKER_FACTORY_SHUTDOWN 0x0020

#define WORKER_FACTORY_ALL_ACCESS ( \
    STANDARD_RIGHTS_REQUIRED | \
    WORKER_FACTORY_RELEASE_WORKER | \
    WORKER_FACTORY_WAIT | \
    WORKER_FACTORY_SET_INFORMATION | \
    WORKER_FACTORY_QUERY_INFORMATION | \
    WORKER_FACTORY_READY_WORKER | \
    WORKER_FACTORY_SHUTDOWN \
    )

// end_rev

// begin_private

typedef enum _WORKERFACTORYINFOCLASS
{
    WorkerFactoryTimeout, // q; s: LARGE_INTEGER
    WorkerFactoryRetryTimeout, // q; s: LARGE_INTEGER
    WorkerFactoryIdleTimeout, // q; s: LARGE_INTEGER
    WorkerFactoryBindingCount,
    WorkerFactoryThreadMinimum, // q; s: ULONG
    WorkerFactoryThreadMaximum, // q; s: ULONG
    WorkerFactoryPaused, // ULONG or BOOLEAN
    WorkerFactoryBasicInformation, // WORKER_FACTORY_BASIC_INFORMATION
    WorkerFactoryAdjustThreadGoal,
    WorkerFactoryCallbackType,
    WorkerFactoryStackInformation, // 10
    WorkerFactoryThreadBasePriority,
    WorkerFactoryTimeoutWaiters, // since THRESHOLD
    WorkerFactoryFlags,
    WorkerFactoryThreadSoftMaximum,
    WorkerFactoryThreadCpuSets, // since REDSTONE5
    MaxWorkerFactoryInfoClass
} WORKERFACTORYINFOCLASS, *PWORKERFACTORYINFOCLASS;

typedef struct _WORKER_FACTORY_BASIC_INFORMATION
{
    LARGE_INTEGER Timeout;
    LARGE_INTEGER RetryTimeout;
    LARGE_INTEGER IdleTimeout;
    BOOLEAN Paused;
    BOOLEAN TimerSet;
    BOOLEAN QueuedToExWorker;
    BOOLEAN MayCreate;
    BOOLEAN CreateInProgress;
    BOOLEAN InsertedIntoQueue;
    BOOLEAN Shutdown;
    ULONG BindingCount;
    ULONG ThreadMinimum;
    ULONG ThreadMaximum;
    ULONG PendingWorkerCount;
    ULONG WaitingWorkerCount;
    ULONG TotalWorkerCount;
    ULONG ReleaseCount;
    LONGLONG InfiniteWaitGoal;
    PVOID StartRoutine;
    PVOID StartParameter;
    HANDLE ProcessId;
    SIZE_T StackReserve;
    SIZE_T StackCommit;
    NTSTATUS LastThreadCreationStatus;
} WORKER_FACTORY_BASIC_INFORMATION, *PWORKER_FACTORY_BASIC_INFORMATION;

// end_private

#if (PHNT_VERSION >= PHNT_VISTA)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateWorkerFactory(
    _Out_ PHANDLE WorkerFactoryHandleReturn,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE CompletionPortHandle,
    _In_ HANDLE WorkerProcessHandle,
    _In_ PVOID StartRoutine,
    _In_opt_ PVOID StartParameter,
    _In_opt_ ULONG MaxThreadCount,
    _In_opt_ SIZE_T StackReserve,
    _In_opt_ SIZE_T StackCommit
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationWorkerFactory(
    _In_ HANDLE WorkerFactoryHandle,
    _In_ WORKERFACTORYINFOCLASS WorkerFactoryInformationClass,
    _Out_writes_bytes_(WorkerFactoryInformationLength) PVOID WorkerFactoryInformation,
    _In_ ULONG WorkerFactoryInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationWorkerFactory(
    _In_ HANDLE WorkerFactoryHandle,
    _In_ WORKERFACTORYINFOCLASS WorkerFactoryInformationClass,
    _In_reads_bytes_(WorkerFactoryInformationLength) PVOID WorkerFactoryInformation,
    _In_ ULONG WorkerFactoryInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtShutdownWorkerFactory(
    _In_ HANDLE WorkerFactoryHandle,
    _Inout_ volatile LONG *PendingWorkerCount
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReleaseWorkerFactoryWorker(
    _In_ HANDLE WorkerFactoryHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWorkerFactoryWorkerReady(
    _In_ HANDLE WorkerFactoryHandle
    );

struct _FILE_IO_COMPLETION_INFORMATION;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWaitForWorkViaWorkerFactory(
    _In_ HANDLE WorkerFactoryHandle,
    _Out_ struct _FILE_IO_COMPLETION_INFORMATION *MiniPacket
    );

#endif

// Time

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySystemTime(
    _Out_ PLARGE_INTEGER SystemTime
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetSystemTime(
    _In_opt_ PLARGE_INTEGER SystemTime,
    _Out_opt_ PLARGE_INTEGER PreviousTime
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryTimerResolution(
    _Out_ PULONG MaximumTime,
    _Out_ PULONG MinimumTime,
    _Out_ PULONG CurrentTime
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetTimerResolution(
    _In_ ULONG DesiredTime,
    _In_ BOOLEAN SetResolution,
    _Out_ PULONG ActualTime
    );

// Performance Counter

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryPerformanceCounter(
    _Out_ PLARGE_INTEGER PerformanceCounter,
    _Out_opt_ PLARGE_INTEGER PerformanceFrequency
    );

// LUIDs

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAllocateLocallyUniqueId(
    _Out_ PLUID Luid
    );

// UUIDs

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetUuidSeed(
    _In_ PCHAR Seed
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAllocateUuids(
    _Out_ PULARGE_INTEGER Time,
    _Out_ PULONG Range,
    _Out_ PULONG Sequence,
    _Out_ PCHAR Seed
    );

// System Information

#endif // (PHNT_MODE != PHNT_MODE_KERNEL)

// rev
// private
typedef enum _SYSTEM_INFORMATION_CLASS
{
    SystemBasicInformation, // q: SYSTEM_BASIC_INFORMATION
    SystemProcessorInformation, // q: SYSTEM_PROCESSOR_INFORMATION
    SystemPerformanceInformation, // q: SYSTEM_PERFORMANCE_INFORMATION
    SystemTimeOfDayInformation, // q: SYSTEM_TIMEOFDAY_INFORMATION
    SystemPathInformation, // not implemented
    SystemProcessInformation, // q: SYSTEM_PROCESS_INFORMATION
    SystemCallCountInformation, // q: SYSTEM_CALL_COUNT_INFORMATION
    SystemDeviceInformation, // q: SYSTEM_DEVICE_INFORMATION
    SystemProcessorPerformanceInformation, // q: SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION
    SystemFlagsInformation, // q: SYSTEM_FLAGS_INFORMATION
    SystemCallTimeInformation, // not implemented // SYSTEM_CALL_TIME_INFORMATION // 10
    SystemModuleInformation, // q: RTL_PROCESS_MODULES
    SystemLocksInformation, // q: RTL_PROCESS_LOCKS
    SystemStackTraceInformation, // q: RTL_PROCESS_BACKTRACES
    SystemPagedPoolInformation, // not implemented
    SystemNonPagedPoolInformation, // not implemented
    SystemHandleInformation, // q: SYSTEM_HANDLE_INFORMATION
    SystemObjectInformation, // q: SYSTEM_OBJECTTYPE_INFORMATION mixed with SYSTEM_OBJECT_INFORMATION
    SystemPageFileInformation, // q: SYSTEM_PAGEFILE_INFORMATION
    SystemVdmInstemulInformation, // q: SYSTEM_VDM_INSTEMUL_INFO
    SystemVdmBopInformation, // not implemented // 20
    SystemFileCacheInformation, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypeSystemCache)
    SystemPoolTagInformation, // q: SYSTEM_POOLTAG_INFORMATION
    SystemInterruptInformation, // q: SYSTEM_INTERRUPT_INFORMATION
    SystemDpcBehaviorInformation, // q: SYSTEM_DPC_BEHAVIOR_INFORMATION; s: SYSTEM_DPC_BEHAVIOR_INFORMATION (requires SeLoadDriverPrivilege)
    SystemFullMemoryInformation, // not implemented
    SystemLoadGdiDriverInformation, // s (kernel-mode only)
    SystemUnloadGdiDriverInformation, // s (kernel-mode only)
    SystemTimeAdjustmentInformation, // q: SYSTEM_QUERY_TIME_ADJUST_INFORMATION; s: SYSTEM_SET_TIME_ADJUST_INFORMATION (requires SeSystemtimePrivilege)
    SystemSummaryMemoryInformation, // not implemented
    SystemMirrorMemoryInformation, // s (requires license value "Kernel-MemoryMirroringSupported") (requires SeShutdownPrivilege) // 30
    SystemPerformanceTraceInformation, // q; s: (type depends on EVENT_TRACE_INFORMATION_CLASS)
    SystemObsolete0, // not implemented
    SystemExceptionInformation, // q: SYSTEM_EXCEPTION_INFORMATION
    SystemCrashDumpStateInformation, // s: SYSTEM_CRASH_DUMP_STATE_INFORMATION (requires SeDebugPrivilege)
    SystemKernelDebuggerInformation, // q: SYSTEM_KERNEL_DEBUGGER_INFORMATION
    SystemContextSwitchInformation, // q: SYSTEM_CONTEXT_SWITCH_INFORMATION
    SystemRegistryQuotaInformation, // q: SYSTEM_REGISTRY_QUOTA_INFORMATION; s (requires SeIncreaseQuotaPrivilege)
    SystemExtendServiceTableInformation, // s (requires SeLoadDriverPrivilege) // loads win32k only
    SystemPrioritySeperation, // s (requires SeTcbPrivilege)
    SystemVerifierAddDriverInformation, // s (requires SeDebugPrivilege) // 40
    SystemVerifierRemoveDriverInformation, // s (requires SeDebugPrivilege)
    SystemProcessorIdleInformation, // q: SYSTEM_PROCESSOR_IDLE_INFORMATION
    SystemLegacyDriverInformation, // q: SYSTEM_LEGACY_DRIVER_INFORMATION
    SystemCurrentTimeZoneInformation, // q; s: RTL_TIME_ZONE_INFORMATION
    SystemLookasideInformation, // q: SYSTEM_LOOKASIDE_INFORMATION
    SystemTimeSlipNotification, // s (requires SeSystemtimePrivilege)
    SystemSessionCreate, // not implemented
    SystemSessionDetach, // not implemented
    SystemSessionInformation, // not implemented (SYSTEM_SESSION_INFORMATION)
    SystemRangeStartInformation, // q: SYSTEM_RANGE_START_INFORMATION // 50
    SystemVerifierInformation, // q: SYSTEM_VERIFIER_INFORMATION; s (requires SeDebugPrivilege)
    SystemVerifierThunkExtend, // s (kernel-mode only)
    SystemSessionProcessInformation, // q: SYSTEM_SESSION_PROCESS_INFORMATION
    SystemLoadGdiDriverInSystemSpace, // s (kernel-mode only) (same as SystemLoadGdiDriverInformation)
    SystemNumaProcessorMap, // q
    SystemPrefetcherInformation, // q: PREFETCHER_INFORMATION; s: PREFETCHER_INFORMATION // PfSnQueryPrefetcherInformation
    SystemExtendedProcessInformation, // q: SYSTEM_PROCESS_INFORMATION
    SystemRecommendedSharedDataAlignment, // q
    SystemComPlusPackage, // q; s
    SystemNumaAvailableMemory, // 60
    SystemProcessorPowerInformation, // q: SYSTEM_PROCESSOR_POWER_INFORMATION
    SystemEmulationBasicInformation,
    SystemEmulationProcessorInformation,
    SystemExtendedHandleInformation, // q: SYSTEM_HANDLE_INFORMATION_EX
    SystemLostDelayedWriteInformation, // q: ULONG
    SystemBigPoolInformation, // q: SYSTEM_BIGPOOL_INFORMATION
    SystemSessionPoolTagInformation, // q: SYSTEM_SESSION_POOLTAG_INFORMATION
    SystemSessionMappedViewInformation, // q: SYSTEM_SESSION_MAPPED_VIEW_INFORMATION
    SystemHotpatchInformation, // q; s: SYSTEM_HOTPATCH_CODE_INFORMATION
    SystemObjectSecurityMode, // q: ULONG // 70
    SystemWatchdogTimerHandler, // s (kernel-mode only)
    SystemWatchdogTimerInformation, // q (kernel-mode only); s (kernel-mode only)
    SystemLogicalProcessorInformation, // q: SYSTEM_LOGICAL_PROCESSOR_INFORMATION
    SystemWow64SharedInformationObsolete, // not implemented
    SystemRegisterFirmwareTableInformationHandler, // s: SYSTEM_FIRMWARE_TABLE_HANDLER // (kernel-mode only)
    SystemFirmwareTableInformation, // SYSTEM_FIRMWARE_TABLE_INFORMATION
    SystemModuleInformationEx, // q: RTL_PROCESS_MODULE_INFORMATION_EX
    SystemVerifierTriageInformation, // not implemented
    SystemSuperfetchInformation, // q; s: SUPERFETCH_INFORMATION // PfQuerySuperfetchInformation
    SystemMemoryListInformation, // q: SYSTEM_MEMORY_LIST_INFORMATION; s: SYSTEM_MEMORY_LIST_COMMAND (requires SeProfileSingleProcessPrivilege) // 80
    SystemFileCacheInformationEx, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (same as SystemFileCacheInformation)
    SystemThreadPriorityClientIdInformation, // s: SYSTEM_THREAD_CID_PRIORITY_INFORMATION (requires SeIncreaseBasePriorityPrivilege)
    SystemProcessorIdleCycleTimeInformation, // q: SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION[]
    SystemVerifierCancellationInformation, // SYSTEM_VERIFIER_CANCELLATION_INFORMATION // name:wow64:whNT32QuerySystemVerifierCancellationInformation
    SystemProcessorPowerInformationEx, // not implemented
    SystemRefTraceInformation, // q; s: SYSTEM_REF_TRACE_INFORMATION // ObQueryRefTraceInformation
    SystemSpecialPoolInformation, // q; s: SYSTEM_SPECIAL_POOL_INFORMATION (requires SeDebugPrivilege) // MmSpecialPoolTag, then MmSpecialPoolCatchOverruns != 0
    SystemProcessIdInformation, // q: SYSTEM_PROCESS_ID_INFORMATION
    SystemErrorPortInformation, // s (requires SeTcbPrivilege)
    SystemBootEnvironmentInformation, // q: SYSTEM_BOOT_ENVIRONMENT_INFORMATION // 90
    SystemHypervisorInformation, // q; s (kernel-mode only)
    SystemVerifierInformationEx, // q; s: SYSTEM_VERIFIER_INFORMATION_EX
    SystemTimeZoneInformation, // s (requires SeTimeZonePrivilege)
    SystemImageFileExecutionOptionsInformation, // s: SYSTEM_IMAGE_FILE_EXECUTION_OPTIONS_INFORMATION (requires SeTcbPrivilege)
    SystemCoverageInformation, // q; s // name:wow64:whNT32QuerySystemCoverageInformation; ExpCovQueryInformation
    SystemPrefetchPatchInformation, // SYSTEM_PREFETCH_PATCH_INFORMATION
    SystemVerifierFaultsInformation, // s: SYSTEM_VERIFIER_FAULTS_INFORMATION (requires SeDebugPrivilege)
    SystemSystemPartitionInformation, // q: SYSTEM_SYSTEM_PARTITION_INFORMATION
    SystemSystemDiskInformation, // q: SYSTEM_SYSTEM_DISK_INFORMATION
    SystemProcessorPerformanceDistribution, // q: SYSTEM_PROCESSOR_PERFORMANCE_DISTRIBUTION // 100
    SystemNumaProximityNodeInformation,
    SystemDynamicTimeZoneInformation, // q; s (requires SeTimeZonePrivilege)
    SystemCodeIntegrityInformation, // q: SYSTEM_CODEINTEGRITY_INFORMATION // SeCodeIntegrityQueryInformation
    SystemProcessorMicrocodeUpdateInformation, // s: SYSTEM_PROCESSOR_MICROCODE_UPDATE_INFORMATION
    SystemProcessorBrandString, // q // HaliQuerySystemInformation -> HalpGetProcessorBrandString, info class 23
    SystemVirtualAddressInformation, // q: SYSTEM_VA_LIST_INFORMATION[]; s: SYSTEM_VA_LIST_INFORMATION[] (requires SeIncreaseQuotaPrivilege) // MmQuerySystemVaInformation
    SystemLogicalProcessorAndGroupInformation, // q: SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX // since WIN7 // KeQueryLogicalProcessorRelationship
    SystemProcessorCycleTimeInformation, // q: SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION[]
    SystemStoreInformation, // q; s: SYSTEM_STORE_INFORMATION // SmQueryStoreInformation
    SystemRegistryAppendString, // s: SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS // 110
    SystemAitSamplingValue, // s: ULONG (requires SeProfileSingleProcessPrivilege)
    SystemVhdBootInformation, // q: SYSTEM_VHD_BOOT_INFORMATION
    SystemCpuQuotaInformation, // q; s // PsQueryCpuQuotaInformation
    SystemNativeBasicInformation, // not implemented
    SystemErrorPortTimeouts, // SYSTEM_ERROR_PORT_TIMEOUTS
    SystemLowPriorityIoInformation, // q: SYSTEM_LOW_PRIORITY_IO_INFORMATION
    SystemTpmBootEntropyInformation, // q: TPM_BOOT_ENTROPY_NT_RESULT // ExQueryTpmBootEntropyInformation
    SystemVerifierCountersInformation, // q: SYSTEM_VERIFIER_COUNTERS_INFORMATION
    SystemPagedPoolInformationEx, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypePagedPool)
    SystemSystemPtesInformationEx, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypeSystemPtes) // 120
    SystemNodeDistanceInformation,
    SystemAcpiAuditInformation, // q: SYSTEM_ACPI_AUDIT_INFORMATION // HaliQuerySystemInformation -> HalpAuditQueryResults, info class 26
    SystemBasicPerformanceInformation, // q: SYSTEM_BASIC_PERFORMANCE_INFORMATION // name:wow64:whNtQuerySystemInformation_SystemBasicPerformanceInformation
    SystemQueryPerformanceCounterInformation, // q: SYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION // since WIN7 SP1
    SystemSessionBigPoolInformation, // q: SYSTEM_SESSION_POOLTAG_INFORMATION // since WIN8
    SystemBootGraphicsInformation, // q; s: SYSTEM_BOOT_GRAPHICS_INFORMATION (kernel-mode only)
    SystemScrubPhysicalMemoryInformation, // q; s: MEMORY_SCRUB_INFORMATION
    SystemBadPageInformation,
    SystemProcessorProfileControlArea, // q; s: SYSTEM_PROCESSOR_PROFILE_CONTROL_AREA
    SystemCombinePhysicalMemoryInformation, // s: MEMORY_COMBINE_INFORMATION, MEMORY_COMBINE_INFORMATION_EX, MEMORY_COMBINE_INFORMATION_EX2 // 130
    SystemEntropyInterruptTimingInformation,
    SystemConsoleInformation, // q: SYSTEM_CONSOLE_INFORMATION
    SystemPlatformBinaryInformation, // q: SYSTEM_PLATFORM_BINARY_INFORMATION
    SystemPolicyInformation, // SYSTEM_POLICY_INFORMATION
    SystemHypervisorProcessorCountInformation, // q: SYSTEM_HYPERVISOR_PROCESSOR_COUNT_INFORMATION
    SystemDeviceDataInformation, // q: SYSTEM_DEVICE_DATA_INFORMATION
    SystemDeviceDataEnumerationInformation, // q: SYSTEM_DEVICE_DATA_INFORMATION
    SystemMemoryTopologyInformation, // q: SYSTEM_MEMORY_TOPOLOGY_INFORMATION
    SystemMemoryChannelInformation, // q: SYSTEM_MEMORY_CHANNEL_INFORMATION
    SystemBootLogoInformation, // q: SYSTEM_BOOT_LOGO_INFORMATION // 140
    SystemProcessorPerformanceInformationEx, // q: SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION_EX // since WINBLUE
    SystemCriticalProcessErrorLogInformation,
    SystemSecureBootPolicyInformation, // q: SYSTEM_SECUREBOOT_POLICY_INFORMATION
    SystemPageFileInformationEx, // q: SYSTEM_PAGEFILE_INFORMATION_EX
    SystemSecureBootInformation, // q: SYSTEM_SECUREBOOT_INFORMATION
    SystemEntropyInterruptTimingRawInformation,
    SystemPortableWorkspaceEfiLauncherInformation, // q: SYSTEM_PORTABLE_WORKSPACE_EFI_LAUNCHER_INFORMATION
    SystemFullProcessInformation, // q: SYSTEM_PROCESS_INFORMATION with SYSTEM_PROCESS_INFORMATION_EXTENSION (requires admin)
    SystemKernelDebuggerInformationEx, // q: SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX
    SystemBootMetadataInformation, // 150
    SystemSoftRebootInformation, // q: ULONG
    SystemElamCertificateInformation, // s: SYSTEM_ELAM_CERTIFICATE_INFORMATION
    SystemOfflineDumpConfigInformation,
    SystemProcessorFeaturesInformation, // q: SYSTEM_PROCESSOR_FEATURES_INFORMATION
    SystemRegistryReconciliationInformation, // s: NULL (requires admin) (flushes registry hives)
    SystemEdidInformation,
    SystemManufacturingInformation, // q: SYSTEM_MANUFACTURING_INFORMATION // since THRESHOLD
    SystemEnergyEstimationConfigInformation, // q: SYSTEM_ENERGY_ESTIMATION_CONFIG_INFORMATION
    SystemHypervisorDetailInformation, // q: SYSTEM_HYPERVISOR_DETAIL_INFORMATION
    SystemProcessorCycleStatsInformation, // q: SYSTEM_PROCESSOR_CYCLE_STATS_INFORMATION // 160
    SystemVmGenerationCountInformation,
    SystemTrustedPlatformModuleInformation, // q: SYSTEM_TPM_INFORMATION
    SystemKernelDebuggerFlags, // SYSTEM_KERNEL_DEBUGGER_FLAGS
    SystemCodeIntegrityPolicyInformation, // q: SYSTEM_CODEINTEGRITYPOLICY_INFORMATION
    SystemIsolatedUserModeInformation, // q: SYSTEM_ISOLATED_USER_MODE_INFORMATION
    SystemHardwareSecurityTestInterfaceResultsInformation,
    SystemSingleModuleInformation, // q: SYSTEM_SINGLE_MODULE_INFORMATION
    SystemAllowedCpuSetsInformation,
    SystemVsmProtectionInformation, // q: SYSTEM_VSM_PROTECTION_INFORMATION (previously SystemDmaProtectionInformation)
    SystemInterruptCpuSetsInformation, // q: SYSTEM_INTERRUPT_CPU_SET_INFORMATION // 170
    SystemSecureBootPolicyFullInformation, // q: SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION
    SystemCodeIntegrityPolicyFullInformation,
    SystemAffinitizedInterruptProcessorInformation,
    SystemRootSiloInformation, // q: SYSTEM_ROOT_SILO_INFORMATION
    SystemCpuSetInformation, // q: SYSTEM_CPU_SET_INFORMATION // since THRESHOLD2
    SystemCpuSetTagInformation, // q: SYSTEM_CPU_SET_TAG_INFORMATION
    SystemWin32WerStartCallout,
    SystemSecureKernelProfileInformation, // q: SYSTEM_SECURE_KERNEL_HYPERGUARD_PROFILE_INFORMATION
    SystemCodeIntegrityPlatformManifestInformation, // q: SYSTEM_SECUREBOOT_PLATFORM_MANIFEST_INFORMATION // since REDSTONE
    SystemInterruptSteeringInformation, // SYSTEM_INTERRUPT_STEERING_INFORMATION_INPUT // 180
    SystemSupportedProcessorArchitectures,
    SystemMemoryUsageInformation, // q: SYSTEM_MEMORY_USAGE_INFORMATION
    SystemCodeIntegrityCertificateInformation, // q: SYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION
    SystemPhysicalMemoryInformation, // q: SYSTEM_PHYSICAL_MEMORY_INFORMATION // since REDSTONE2
    SystemControlFlowTransition,
    SystemKernelDebuggingAllowed, // s: ULONG
    SystemActivityModerationExeState, // SYSTEM_ACTIVITY_MODERATION_EXE_STATE
    SystemActivityModerationUserSettings, // SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS
    SystemCodeIntegrityPoliciesFullInformation,
    SystemCodeIntegrityUnlockInformation, // SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION // 190
    SystemIntegrityQuotaInformation,
    SystemFlushInformation, // q: SYSTEM_FLUSH_INFORMATION
    SystemProcessorIdleMaskInformation, // q: ULONG_PTR // since REDSTONE3
    SystemSecureDumpEncryptionInformation,
    SystemWriteConstraintInformation, // SYSTEM_WRITE_CONSTRAINT_INFORMATION
    SystemKernelVaShadowInformation, // SYSTEM_KERNEL_VA_SHADOW_INFORMATION
    SystemHypervisorSharedPageInformation, // SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION // since REDSTONE4
    SystemFirmwareBootPerformanceInformation,
    SystemCodeIntegrityVerificationInformation, // SYSTEM_CODEINTEGRITYVERIFICATION_INFORMATION
    SystemFirmwarePartitionInformation, // SYSTEM_FIRMWARE_PARTITION_INFORMATION // 200
    SystemSpeculationControlInformation, // SYSTEM_SPECULATION_CONTROL_INFORMATION // (CVE-2017-5715) REDSTONE3 and above.
    SystemDmaGuardPolicyInformation, // SYSTEM_DMA_GUARD_POLICY_INFORMATION
    SystemEnclaveLaunchControlInformation, // SYSTEM_ENCLAVE_LAUNCH_CONTROL_INFORMATION
    SystemWorkloadAllowedCpuSetsInformation, // SYSTEM_WORKLOAD_ALLOWED_CPU_SET_INFORMATION // since REDSTONE5
    SystemCodeIntegrityUnlockModeInformation,
    SystemLeapSecondInformation, // SYSTEM_LEAP_SECOND_INFORMATION
    SystemFlags2Information, // q: SYSTEM_FLAGS_INFORMATION
    SystemSecurityModelInformation, // SYSTEM_SECURITY_MODEL_INFORMATION // since 19H1
    SystemCodeIntegritySyntheticCacheInformation,
    SystemFeatureConfigurationInformation, // SYSTEM_FEATURE_CONFIGURATION_INFORMATION // since 20H1 // 210
    SystemFeatureConfigurationSectionInformation, // SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION
    SystemFeatureUsageSubscriptionInformation,
    SystemSecureSpeculationControlInformation, // SECURE_SPECULATION_CONTROL_INFORMATION
    // SystemSpacesBootInformation = 214,
    // SystemFwRamdiskInformation = 215,
    // SystemWheaIpmiHardwareInformation = 216,
    // SystemDifSetRuleClassInformation = 217,
    // SystemDifClearRuleClassInformation = 218,
    // SystemDifApplyPluginVerificationOnDriver = 219,
    // SystemDifRemovePluginVerificationOnDriver = 220,
    // SystemShadowStackInformation = 221, // SYSTEM_SHADOW_STACK_INFORMATION
    // SystemBuildVersionInformation = 222, // SYSTEM_BUILD_VERSION_INFORMATION
    MaxSystemInfoClass
} SYSTEM_INFORMATION_CLASS;

typedef struct _SYSTEM_BASIC_INFORMATION
{
    ULONG Reserved;
    ULONG TimerResolution;
    ULONG PageSize;
    ULONG NumberOfPhysicalPages;
    ULONG LowestPhysicalPageNumber;
    ULONG HighestPhysicalPageNumber;
    ULONG AllocationGranularity;
    ULONG_PTR MinimumUserModeAddress;
    ULONG_PTR MaximumUserModeAddress;
    ULONG_PTR ActiveProcessorsAffinityMask;
    CCHAR NumberOfProcessors;
} SYSTEM_BASIC_INFORMATION, *PSYSTEM_BASIC_INFORMATION;

typedef struct _SYSTEM_PROCESSOR_INFORMATION
{
    USHORT ProcessorArchitecture;
    USHORT ProcessorLevel;
    USHORT ProcessorRevision;
    USHORT MaximumProcessors;
    ULONG ProcessorFeatureBits;
} SYSTEM_PROCESSOR_INFORMATION, *PSYSTEM_PROCESSOR_INFORMATION;

typedef struct _SYSTEM_PERFORMANCE_INFORMATION
{
    LARGE_INTEGER IdleProcessTime;
    LARGE_INTEGER IoReadTransferCount;
    LARGE_INTEGER IoWriteTransferCount;
    LARGE_INTEGER IoOtherTransferCount;
    ULONG IoReadOperationCount;
    ULONG IoWriteOperationCount;
    ULONG IoOtherOperationCount;
    ULONG AvailablePages;
    ULONG CommittedPages;
    ULONG CommitLimit;
    ULONG PeakCommitment;
    ULONG PageFaultCount;
    ULONG CopyOnWriteCount;
    ULONG TransitionCount;
    ULONG CacheTransitionCount;
    ULONG DemandZeroCount;
    ULONG PageReadCount;
    ULONG PageReadIoCount;
    ULONG CacheReadCount;
    ULONG CacheIoCount;
    ULONG DirtyPagesWriteCount;
    ULONG DirtyWriteIoCount;
    ULONG MappedPagesWriteCount;
    ULONG MappedWriteIoCount;
    ULONG PagedPoolPages;
    ULONG NonPagedPoolPages;
    ULONG PagedPoolAllocs;
    ULONG PagedPoolFrees;
    ULONG NonPagedPoolAllocs;
    ULONG NonPagedPoolFrees;
    ULONG FreeSystemPtes;
    ULONG ResidentSystemCodePage;
    ULONG TotalSystemDriverPages;
    ULONG TotalSystemCodePages;
    ULONG NonPagedPoolLookasideHits;
    ULONG PagedPoolLookasideHits;
    ULONG AvailablePagedPoolPages;
    ULONG ResidentSystemCachePage;
    ULONG ResidentPagedPoolPage;
    ULONG ResidentSystemDriverPage;
    ULONG CcFastReadNoWait;
    ULONG CcFastReadWait;
    ULONG CcFastReadResourceMiss;
    ULONG CcFastReadNotPossible;
    ULONG CcFastMdlReadNoWait;
    ULONG CcFastMdlReadWait;
    ULONG CcFastMdlReadResourceMiss;
    ULONG CcFastMdlReadNotPossible;
    ULONG CcMapDataNoWait;
    ULONG CcMapDataWait;
    ULONG CcMapDataNoWaitMiss;
    ULONG CcMapDataWaitMiss;
    ULONG CcPinMappedDataCount;
    ULONG CcPinReadNoWait;
    ULONG CcPinReadWait;
    ULONG CcPinReadNoWaitMiss;
    ULONG CcPinReadWaitMiss;
    ULONG CcCopyReadNoWait;
    ULONG CcCopyReadWait;
    ULONG CcCopyReadNoWaitMiss;
    ULONG CcCopyReadWaitMiss;
    ULONG CcMdlReadNoWait;
    ULONG CcMdlReadWait;
    ULONG CcMdlReadNoWaitMiss;
    ULONG CcMdlReadWaitMiss;
    ULONG CcReadAheadIos;
    ULONG CcLazyWriteIos;
    ULONG CcLazyWritePages;
    ULONG CcDataFlushes;
    ULONG CcDataPages;
    ULONG ContextSwitches;
    ULONG FirstLevelTbFills;
    ULONG SecondLevelTbFills;
    ULONG SystemCalls;
    ULONGLONG CcTotalDirtyPages; // since THRESHOLD
    ULONGLONG CcDirtyPageThreshold; // since THRESHOLD
    LONGLONG ResidentAvailablePages; // since THRESHOLD
    ULONGLONG SharedCommittedPages; // since THRESHOLD
} SYSTEM_PERFORMANCE_INFORMATION, *PSYSTEM_PERFORMANCE_INFORMATION;

typedef struct _SYSTEM_TIMEOFDAY_INFORMATION
{
    LARGE_INTEGER BootTime;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER TimeZoneBias;
    ULONG TimeZoneId;
    ULONG Reserved;
    ULONGLONG BootTimeBias;
    ULONGLONG SleepTimeBias;
} SYSTEM_TIMEOFDAY_INFORMATION, *PSYSTEM_TIMEOFDAY_INFORMATION;

typedef struct _SYSTEM_THREAD_INFORMATION
{
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER CreateTime;
    ULONG WaitTime;
    PVOID StartAddress;
    CLIENT_ID ClientId;
    KPRIORITY Priority;
    LONG BasePriority;
    ULONG ContextSwitches;
    KTHREAD_STATE ThreadState;
    KWAIT_REASON WaitReason;
} SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION;

typedef struct _TEB *PTEB;

// private
typedef struct _SYSTEM_EXTENDED_THREAD_INFORMATION
{
    SYSTEM_THREAD_INFORMATION ThreadInfo;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID Win32StartAddress;
    PTEB TebBase; // since VISTA
    ULONG_PTR Reserved2;
    ULONG_PTR Reserved3;
    ULONG_PTR Reserved4;
} SYSTEM_EXTENDED_THREAD_INFORMATION, *PSYSTEM_EXTENDED_THREAD_INFORMATION;

typedef struct _SYSTEM_PROCESS_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG NumberOfThreads;
    LARGE_INTEGER WorkingSetPrivateSize; // since VISTA
    ULONG HardFaultCount; // since WIN7
    ULONG NumberOfThreadsHighWatermark; // since WIN7
    ULONGLONG CycleTime; // since WIN7
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER KernelTime;
    UNICODE_STRING ImageName;
    KPRIORITY BasePriority;
    HANDLE UniqueProcessId;
    HANDLE InheritedFromUniqueProcessId;
    ULONG HandleCount;
    ULONG SessionId;
    ULONG_PTR UniqueProcessKey; // since VISTA (requires SystemExtendedProcessInformation)
    SIZE_T PeakVirtualSize;
    SIZE_T VirtualSize;
    ULONG PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivatePageCount;
    LARGE_INTEGER ReadOperationCount;
    LARGE_INTEGER WriteOperationCount;
    LARGE_INTEGER OtherOperationCount;
    LARGE_INTEGER ReadTransferCount;
    LARGE_INTEGER WriteTransferCount;
    LARGE_INTEGER OtherTransferCount;
    SYSTEM_THREAD_INFORMATION Threads[1]; // SystemProcessInformation
    // SYSTEM_EXTENDED_THREAD_INFORMATION Threads[1]; // SystemExtendedProcessinformation
    // SYSTEM_EXTENDED_THREAD_INFORMATION + SYSTEM_PROCESS_INFORMATION_EXTENSION // SystemFullProcessInformation
} SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;

typedef struct _SYSTEM_CALL_COUNT_INFORMATION
{
    ULONG Length;
    ULONG NumberOfTables;
} SYSTEM_CALL_COUNT_INFORMATION, *PSYSTEM_CALL_COUNT_INFORMATION;

typedef struct _SYSTEM_DEVICE_INFORMATION
{
    ULONG NumberOfDisks;
    ULONG NumberOfFloppies;
    ULONG NumberOfCdRoms;
    ULONG NumberOfTapes;
    ULONG NumberOfSerialPorts;
    ULONG NumberOfParallelPorts;
} SYSTEM_DEVICE_INFORMATION, *PSYSTEM_DEVICE_INFORMATION;

typedef struct _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION
{
    LARGE_INTEGER IdleTime;
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER DpcTime;
    LARGE_INTEGER InterruptTime;
    ULONG InterruptCount;
} SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION, *PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION;

typedef struct _SYSTEM_FLAGS_INFORMATION
{
    ULONG Flags; // NtGlobalFlag
} SYSTEM_FLAGS_INFORMATION, *PSYSTEM_FLAGS_INFORMATION;

// private
typedef struct _SYSTEM_CALL_TIME_INFORMATION
{
    ULONG Length;
    ULONG TotalCalls;
    LARGE_INTEGER TimeOfCalls[1];
} SYSTEM_CALL_TIME_INFORMATION, *PSYSTEM_CALL_TIME_INFORMATION;

// private
typedef struct _RTL_PROCESS_LOCK_INFORMATION
{
    PVOID Address;
    USHORT Type;
    USHORT CreatorBackTraceIndex;
    HANDLE OwningThread;
    LONG LockCount;
    ULONG ContentionCount;
    ULONG EntryCount;
    LONG RecursionCount;
    ULONG NumberOfWaitingShared;
    ULONG NumberOfWaitingExclusive;
} RTL_PROCESS_LOCK_INFORMATION, *PRTL_PROCESS_LOCK_INFORMATION;

// private
typedef struct _RTL_PROCESS_LOCKS
{
    ULONG NumberOfLocks;
    RTL_PROCESS_LOCK_INFORMATION Locks[1];
} RTL_PROCESS_LOCKS, *PRTL_PROCESS_LOCKS;

// private
typedef struct _RTL_PROCESS_BACKTRACE_INFORMATION
{
    PCHAR SymbolicBackTrace;
    ULONG TraceCount;
    USHORT Index;
    USHORT Depth;
    PVOID BackTrace[32];
} RTL_PROCESS_BACKTRACE_INFORMATION, *PRTL_PROCESS_BACKTRACE_INFORMATION;

// private
typedef struct _RTL_PROCESS_BACKTRACES
{
    ULONG CommittedMemory;
    ULONG ReservedMemory;
    ULONG NumberOfBackTraceLookups;
    ULONG NumberOfBackTraces;
    RTL_PROCESS_BACKTRACE_INFORMATION BackTraces[1];
} RTL_PROCESS_BACKTRACES, *PRTL_PROCESS_BACKTRACES;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO
{
    USHORT UniqueProcessId;
    USHORT CreatorBackTraceIndex;
    UCHAR ObjectTypeIndex;
    UCHAR HandleAttributes;
    USHORT HandleValue;
    PVOID Object;
    ULONG GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION
{
    ULONG NumberOfHandles;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;

typedef struct _SYSTEM_OBJECTTYPE_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG NumberOfObjects;
    ULONG NumberOfHandles;
    ULONG TypeIndex;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    ULONG PoolType;
    BOOLEAN SecurityRequired;
    BOOLEAN WaitableObject;
    UNICODE_STRING TypeName;
} SYSTEM_OBJECTTYPE_INFORMATION, *PSYSTEM_OBJECTTYPE_INFORMATION;

typedef struct _SYSTEM_OBJECT_INFORMATION
{
    ULONG NextEntryOffset;
    PVOID Object;
    HANDLE CreatorUniqueProcess;
    USHORT CreatorBackTraceIndex;
    USHORT Flags;
    LONG PointerCount;
    LONG HandleCount;
    ULONG PagedPoolCharge;
    ULONG NonPagedPoolCharge;
    HANDLE ExclusiveProcessId;
    PVOID SecurityDescriptor;
    UNICODE_STRING NameInfo;
} SYSTEM_OBJECT_INFORMATION, *PSYSTEM_OBJECT_INFORMATION;

typedef struct _SYSTEM_PAGEFILE_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG TotalSize;
    ULONG TotalInUse;
    ULONG PeakUsage;
    UNICODE_STRING PageFileName;
} SYSTEM_PAGEFILE_INFORMATION, *PSYSTEM_PAGEFILE_INFORMATION;

typedef struct _SYSTEM_VDM_INSTEMUL_INFO
{
    ULONG SegmentNotPresent;
    ULONG VdmOpcode0F;
    ULONG OpcodeESPrefix;
    ULONG OpcodeCSPrefix;
    ULONG OpcodeSSPrefix;
    ULONG OpcodeDSPrefix;
    ULONG OpcodeFSPrefix;
    ULONG OpcodeGSPrefix;
    ULONG OpcodeOPER32Prefix;
    ULONG OpcodeADDR32Prefix;
    ULONG OpcodeINSB;
    ULONG OpcodeINSW;
    ULONG OpcodeOUTSB;
    ULONG OpcodeOUTSW;
    ULONG OpcodePUSHF;
    ULONG OpcodePOPF;
    ULONG OpcodeINTnn;
    ULONG OpcodeINTO;
    ULONG OpcodeIRET;
    ULONG OpcodeINBimm;
    ULONG OpcodeINWimm;
    ULONG OpcodeOUTBimm;
    ULONG OpcodeOUTWimm;
    ULONG OpcodeINB;
    ULONG OpcodeINW;
    ULONG OpcodeOUTB;
    ULONG OpcodeOUTW;
    ULONG OpcodeLOCKPrefix;
    ULONG OpcodeREPNEPrefix;
    ULONG OpcodeREPPrefix;
    ULONG OpcodeHLT;
    ULONG OpcodeCLI;
    ULONG OpcodeSTI;
    ULONG BopCount;
} SYSTEM_VDM_INSTEMUL_INFO, *PSYSTEM_VDM_INSTEMUL_INFO;

#define MM_WORKING_SET_MAX_HARD_ENABLE 0x1
#define MM_WORKING_SET_MAX_HARD_DISABLE 0x2
#define MM_WORKING_SET_MIN_HARD_ENABLE 0x4
#define MM_WORKING_SET_MIN_HARD_DISABLE 0x8

typedef struct _SYSTEM_FILECACHE_INFORMATION
{
    SIZE_T CurrentSize;
    SIZE_T PeakSize;
    ULONG PageFaultCount;
    SIZE_T MinimumWorkingSet;
    SIZE_T MaximumWorkingSet;
    SIZE_T CurrentSizeIncludingTransitionInPages;
    SIZE_T PeakSizeIncludingTransitionInPages;
    ULONG TransitionRePurposeCount;
    ULONG Flags;
} SYSTEM_FILECACHE_INFORMATION, *PSYSTEM_FILECACHE_INFORMATION;

// Can be used instead of SYSTEM_FILECACHE_INFORMATION
typedef struct _SYSTEM_BASIC_WORKING_SET_INFORMATION
{
    SIZE_T CurrentSize;
    SIZE_T PeakSize;
    ULONG PageFaultCount;
} SYSTEM_BASIC_WORKING_SET_INFORMATION, *PSYSTEM_BASIC_WORKING_SET_INFORMATION;

typedef struct _SYSTEM_POOLTAG
{
    union
    {
        UCHAR Tag[4];
        ULONG TagUlong;
    };
    ULONG PagedAllocs;
    ULONG PagedFrees;
    SIZE_T PagedUsed;
    ULONG NonPagedAllocs;
    ULONG NonPagedFrees;
    SIZE_T NonPagedUsed;
} SYSTEM_POOLTAG, *PSYSTEM_POOLTAG;

typedef struct _SYSTEM_POOLTAG_INFORMATION
{
    ULONG Count;
    SYSTEM_POOLTAG TagInfo[1];
} SYSTEM_POOLTAG_INFORMATION, *PSYSTEM_POOLTAG_INFORMATION;

typedef struct _SYSTEM_INTERRUPT_INFORMATION
{
    ULONG ContextSwitches;
    ULONG DpcCount;
    ULONG DpcRate;
    ULONG TimeIncrement;
    ULONG DpcBypassCount;
    ULONG ApcBypassCount;
} SYSTEM_INTERRUPT_INFORMATION, *PSYSTEM_INTERRUPT_INFORMATION;

typedef struct _SYSTEM_DPC_BEHAVIOR_INFORMATION
{
    ULONG Spare;
    ULONG DpcQueueDepth;
    ULONG MinimumDpcRate;
    ULONG AdjustDpcThreshold;
    ULONG IdealDpcRate;
} SYSTEM_DPC_BEHAVIOR_INFORMATION, *PSYSTEM_DPC_BEHAVIOR_INFORMATION;

typedef struct _SYSTEM_QUERY_TIME_ADJUST_INFORMATION
{
    ULONG TimeAdjustment;
    ULONG TimeIncrement;
    BOOLEAN Enable;
} SYSTEM_QUERY_TIME_ADJUST_INFORMATION, *PSYSTEM_QUERY_TIME_ADJUST_INFORMATION;

typedef struct _SYSTEM_QUERY_TIME_ADJUST_INFORMATION_PRECISE
{
    ULONGLONG TimeAdjustment;
    ULONGLONG TimeIncrement;
    BOOLEAN Enable;
} SYSTEM_QUERY_TIME_ADJUST_INFORMATION_PRECISE, *PSYSTEM_QUERY_TIME_ADJUST_INFORMATION_PRECISE;

typedef struct _SYSTEM_SET_TIME_ADJUST_INFORMATION
{
    ULONG TimeAdjustment;
    BOOLEAN Enable;
} SYSTEM_SET_TIME_ADJUST_INFORMATION, *PSYSTEM_SET_TIME_ADJUST_INFORMATION;

typedef struct _SYSTEM_SET_TIME_ADJUST_INFORMATION_PRECISE
{
    ULONGLONG TimeAdjustment;
    BOOLEAN Enable;
} SYSTEM_SET_TIME_ADJUST_INFORMATION_PRECISE, *PSYSTEM_SET_TIME_ADJUST_INFORMATION_PRECISE;

typedef enum _EVENT_TRACE_INFORMATION_CLASS
{
    EventTraceKernelVersionInformation, // EVENT_TRACE_VERSION_INFORMATION
    EventTraceGroupMaskInformation, // EVENT_TRACE_GROUPMASK_INFORMATION
    EventTracePerformanceInformation, // EVENT_TRACE_PERFORMANCE_INFORMATION
    EventTraceTimeProfileInformation, // EVENT_TRACE_TIME_PROFILE_INFORMATION
    EventTraceSessionSecurityInformation, // EVENT_TRACE_SESSION_SECURITY_INFORMATION
    EventTraceSpinlockInformation, // EVENT_TRACE_SPINLOCK_INFORMATION
    EventTraceStackTracingInformation, // EVENT_TRACE_SYSTEM_EVENT_INFORMATION
    EventTraceExecutiveResourceInformation, // EVENT_TRACE_EXECUTIVE_RESOURCE_INFORMATION
    EventTraceHeapTracingInformation, // EVENT_TRACE_HEAP_TRACING_INFORMATION
    EventTraceHeapSummaryTracingInformation, // EVENT_TRACE_HEAP_TRACING_INFORMATION
    EventTracePoolTagFilterInformation, // EVENT_TRACE_TAG_FILTER_INFORMATION
    EventTracePebsTracingInformation, // EVENT_TRACE_SYSTEM_EVENT_INFORMATION
    EventTraceProfileConfigInformation, // EVENT_TRACE_PROFILE_COUNTER_INFORMATION
    EventTraceProfileSourceListInformation, // EVENT_TRACE_PROFILE_LIST_INFORMATION
    EventTraceProfileEventListInformation, // EVENT_TRACE_SYSTEM_EVENT_INFORMATION
    EventTraceProfileCounterListInformation, // EVENT_TRACE_PROFILE_COUNTER_INFORMATION
    EventTraceStackCachingInformation, // EVENT_TRACE_STACK_CACHING_INFORMATION
    EventTraceObjectTypeFilterInformation, // EVENT_TRACE_TAG_FILTER_INFORMATION
    EventTraceSoftRestartInformation, // EVENT_TRACE_SOFT_RESTART_INFORMATION
    EventTraceLastBranchConfigurationInformation, // REDSTONE3
    EventTraceLastBranchEventListInformation,
    EventTraceProfileSourceAddInformation, // EVENT_TRACE_PROFILE_ADD_INFORMATION // REDSTONE4
    EventTraceProfileSourceRemoveInformation, // EVENT_TRACE_PROFILE_REMOVE_INFORMATION
    EventTraceProcessorTraceConfigurationInformation,
    EventTraceProcessorTraceEventListInformation,
    EventTraceCoverageSamplerInformation, // EVENT_TRACE_COVERAGE_SAMPLER_INFORMATION
    MaxEventTraceInfoClass
} EVENT_TRACE_INFORMATION_CLASS;

typedef struct _EVENT_TRACE_VERSION_INFORMATION
{
    EVENT_TRACE_INFORMATION_CLASS EventTraceInformationClass;
    ULONG EventTraceKernelVersion;
} EVENT_TRACE_VERSION_INFORMATION, *PEVENT_TRACE_VERSION_INFORMATION;

typedef struct _PERFINFO_GROUPMASK
{
    ULONG Masks[8];
} PERFINFO_GROUPMASK, *PPERFINFO_GROUPMASK;

typedef struct _EVENT_TRACE_GROUPMASK_INFORMATION
{
    EVENT_TRACE_INFORMATION_CLASS EventTraceInformationClass;
    HANDLE TraceHandle;
    PERFINFO_GROUPMASK EventTraceGroupMasks;
} EVENT_TRACE_GROUPMASK_INFORMATION, *PEVENT_TRACE_GROUPMASK_INFORMATION;

typedef struct _EVENT_TRACE_PERFORMANCE_INFORMATION
{
    EVENT_TRACE_INFORMATION_CLASS EventTraceInformationClass;
    LARGE_INTEGER LogfileBytesWritten;
} EVENT_TRACE_PERFORMANCE_INFORMATION, *PEVENT_TRACE_PERFORMANCE_INFORMATION;

typedef struct _EVENT_TRACE_TIME_PROFILE_INFORMATION
{
    EVENT_TRACE_INFORMATION_CLASS EventTraceInformationClass;
    ULONG ProfileInterval;
} EVENT_TRACE_TIME_PROFILE_INFORMATION, *PEVENT_TRACE_TIME_PROFILE_INFORMATION;

typedef struct _EVENT_TRACE_SESSION_SECURITY_INFORMATION
{
    EVENT_TRACE_INFORMATION_CLASS EventTraceInformationClass;
    ULONG SecurityInformation;
    HANDLE TraceHandle;
    UCHAR SecurityDescriptor[1];
} EVENT_TRACE_SESSION_SECURITY_INFORMATION, *PEVENT_TRACE_SESSION_SECURITY_INFORMATION;

typedef struct _EVENT_TRACE_SPINLOCK_INFORMATION
{
    EVENT_TRACE_INFORMATION_CLASS EventTraceInformationClass;
    ULONG SpinLockSpinThreshold;
    ULONG SpinLockAcquireSampleRate;
    ULONG SpinLockContentionSampleRate;
    ULONG SpinLockHoldThreshold;
} EVENT_TRACE_SPINLOCK_INFORMATION, *PEVENT_TRACE_SPINLOCK_INFORMATION;

typedef struct _EVENT_TRACE_SYSTEM_EVENT_INFORMATION
{
    EVENT_TRACE_INFORMATION_CLASS EventTraceInformationClass;
    HANDLE TraceHandle;
    ULONG HookId[1];
} EVENT_TRACE_SYSTEM_EVENT_INFORMATION, *PEVENT_TRACE_SYSTEM_EVENT_INFORMATION;

typedef struct _EVENT_TRACE_EXECUTIVE_RESOURCE_INFORMATION
{
    EVENT_TRACE_INFORMATION_CLASS EventTraceInformationClass;
    ULONG ReleaseSamplingRate;
    ULONG ContentionSamplingRate;
    ULONG NumberOfExcessiveTimeouts;
} EVENT_TRACE_EXECUTIVE_RESOURCE_INFORMATION, *PEVENT_TRACE_EXECUTIVE_RESOURCE_INFORMATION;

typedef struct _EVENT_TRACE_HEAP_TRACING_INFORMATION
{
    EVENT_TRACE_INFORMATION_CLASS EventTraceInformationClass;
    ULONG ProcessId;
} EVENT_TRACE_HEAP_TRACING_INFORMATION, *PEVENT_TRACE_HEAP_TRACING_INFORMATION;

typedef struct _EVENT_TRACE_TAG_FILTER_INFORMATION
{
    EVENT_TRACE_INFORMATION_CLASS EventTraceInformationClass;
    HANDLE TraceHandle;
    ULONG Filter[1];
} EVENT_TRACE_TAG_FILTER_INFORMATION, *PEVENT_TRACE_TAG_FILTER_INFORMATION;

typedef struct _EVENT_TRACE_PROFILE_COUNTER_INFORMATION
{
    EVENT_TRACE_INFORMATION_CLASS EventTraceInformationClass;
    HANDLE TraceHandle;
    ULONG ProfileSource[1];
} EVENT_TRACE_PROFILE_COUNTER_INFORMATION, *PEVENT_TRACE_PROFILE_COUNTER_INFORMATION;

//typedef struct _PROFILE_SOURCE_INFO
//{
//    ULONG NextEntryOffset;
//    ULONG Source;
//    ULONG MinInterval;
//    ULONG MaxInterval;
//    PVOID Reserved;
//    WCHAR Description[1];
//} PROFILE_SOURCE_INFO, *PPROFILE_SOURCE_INFO;

typedef struct _EVENT_TRACE_PROFILE_LIST_INFORMATION
{
    EVENT_TRACE_INFORMATION_CLASS EventTraceInformationClass;
    ULONG Spare;
    struct _PROFILE_SOURCE_INFO* Profile[1];
} EVENT_TRACE_PROFILE_LIST_INFORMATION, *PEVENT_TRACE_PROFILE_LIST_INFORMATION;

typedef struct _EVENT_TRACE_STACK_CACHING_INFORMATION
{
    EVENT_TRACE_INFORMATION_CLASS EventTraceInformationClass;
    HANDLE TraceHandle;
    BOOLEAN Enabled;
    UCHAR Reserved[3];
    ULONG CacheSize;
    ULONG BucketCount;
} EVENT_TRACE_STACK_CACHING_INFORMATION, *PEVENT_TRACE_STACK_CACHING_INFORMATION;

typedef struct _EVENT_TRACE_SOFT_RESTART_INFORMATION
{
    EVENT_TRACE_INFORMATION_CLASS EventTraceInformationClass;
    HANDLE TraceHandle;
    BOOLEAN PersistTraceBuffers;
    WCHAR FileName[1];
} EVENT_TRACE_SOFT_RESTART_INFORMATION, *PEVENT_TRACE_SOFT_RESTART_INFORMATION;

typedef struct _EVENT_TRACE_PROFILE_ADD_INFORMATION
{
    EVENT_TRACE_INFORMATION_CLASS EventTraceInformationClass;
    BOOLEAN PerfEvtEventSelect;
    BOOLEAN PerfEvtUnitSelect;
    ULONG PerfEvtType;
    ULONG CpuInfoHierarchy[0x3];
    ULONG InitialInterval;
    BOOLEAN AllowsHalt;
    BOOLEAN Persist;
    WCHAR ProfileSourceDescription[0x1];
} EVENT_TRACE_PROFILE_ADD_INFORMATION, *PEVENT_TRACE_PROFILE_ADD_INFORMATION;

typedef struct _EVENT_TRACE_PROFILE_REMOVE_INFORMATION
{
    EVENT_TRACE_INFORMATION_CLASS EventTraceInformationClass;
    KPROFILE_SOURCE ProfileSource;
    ULONG CpuInfoHierarchy[0x3];
} EVENT_TRACE_PROFILE_REMOVE_INFORMATION, *PEVENT_TRACE_PROFILE_REMOVE_INFORMATION;

typedef struct _EVENT_TRACE_COVERAGE_SAMPLER_INFORMATION
{
    EVENT_TRACE_INFORMATION_CLASS EventTraceInformationClass;
    BOOLEAN CoverageSamplerInformationClass;
    UCHAR MajorVersion;
    UCHAR MinorVersion;
    UCHAR Reserved;
    HANDLE SamplerHandle;
} EVENT_TRACE_COVERAGE_SAMPLER_INFORMATION, *PEVENT_TRACE_COVERAGE_SAMPLER_INFORMATION;

typedef struct _SYSTEM_EXCEPTION_INFORMATION
{
    ULONG AlignmentFixupCount;
    ULONG ExceptionDispatchCount;
    ULONG FloatingEmulationCount;
    ULONG ByteWordEmulationCount;
} SYSTEM_EXCEPTION_INFORMATION, *PSYSTEM_EXCEPTION_INFORMATION;

typedef enum _SYSTEM_CRASH_DUMP_CONFIGURATION_CLASS
{
    SystemCrashDumpDisable,
    SystemCrashDumpReconfigure,
    SystemCrashDumpInitializationComplete
} SYSTEM_CRASH_DUMP_CONFIGURATION_CLASS, *PSYSTEM_CRASH_DUMP_CONFIGURATION_CLASS;

typedef struct _SYSTEM_CRASH_DUMP_STATE_INFORMATION
{
    SYSTEM_CRASH_DUMP_CONFIGURATION_CLASS CrashDumpConfigurationClass;
} SYSTEM_CRASH_DUMP_STATE_INFORMATION, *PSYSTEM_CRASH_DUMP_STATE_INFORMATION;

typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION
{
    BOOLEAN KernelDebuggerEnabled;
    BOOLEAN KernelDebuggerNotPresent;
} SYSTEM_KERNEL_DEBUGGER_INFORMATION, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION;

typedef struct _SYSTEM_CONTEXT_SWITCH_INFORMATION
{
    ULONG ContextSwitches;
    ULONG FindAny;
    ULONG FindLast;
    ULONG FindIdeal;
    ULONG IdleAny;
    ULONG IdleCurrent;
    ULONG IdleLast;
    ULONG IdleIdeal;
    ULONG PreemptAny;
    ULONG PreemptCurrent;
    ULONG PreemptLast;
    ULONG SwitchToIdle;
} SYSTEM_CONTEXT_SWITCH_INFORMATION, *PSYSTEM_CONTEXT_SWITCH_INFORMATION;

typedef struct _SYSTEM_REGISTRY_QUOTA_INFORMATION
{
    ULONG RegistryQuotaAllowed;
    ULONG RegistryQuotaUsed;
    SIZE_T PagedPoolSize;
} SYSTEM_REGISTRY_QUOTA_INFORMATION, *PSYSTEM_REGISTRY_QUOTA_INFORMATION;

typedef struct _SYSTEM_PROCESSOR_IDLE_INFORMATION
{
    ULONGLONG IdleTime;
    ULONGLONG C1Time;
    ULONGLONG C2Time;
    ULONGLONG C3Time;
    ULONG C1Transitions;
    ULONG C2Transitions;
    ULONG C3Transitions;
    ULONG Padding;
} SYSTEM_PROCESSOR_IDLE_INFORMATION, *PSYSTEM_PROCESSOR_IDLE_INFORMATION;

typedef struct _SYSTEM_LEGACY_DRIVER_INFORMATION
{
    ULONG VetoType;
    UNICODE_STRING VetoList;
} SYSTEM_LEGACY_DRIVER_INFORMATION, *PSYSTEM_LEGACY_DRIVER_INFORMATION;

typedef struct _SYSTEM_LOOKASIDE_INFORMATION
{
    USHORT CurrentDepth;
    USHORT MaximumDepth;
    ULONG TotalAllocates;
    ULONG AllocateMisses;
    ULONG TotalFrees;
    ULONG FreeMisses;
    ULONG Type;
    ULONG Tag;
    ULONG Size;
} SYSTEM_LOOKASIDE_INFORMATION, *PSYSTEM_LOOKASIDE_INFORMATION;

// private
typedef struct _SYSTEM_RANGE_START_INFORMATION
{
    PVOID SystemRangeStart;
} SYSTEM_RANGE_START_INFORMATION, *PSYSTEM_RANGE_START_INFORMATION;

typedef struct _SYSTEM_VERIFIER_INFORMATION_LEGACY // pre-19H1
{
    ULONG NextEntryOffset;
    ULONG Level;
    UNICODE_STRING DriverName;

    ULONG RaiseIrqls;
    ULONG AcquireSpinLocks;
    ULONG SynchronizeExecutions;
    ULONG AllocationsAttempted;

    ULONG AllocationsSucceeded;
    ULONG AllocationsSucceededSpecialPool;
    ULONG AllocationsWithNoTag;
    ULONG TrimRequests;

    ULONG Trims;
    ULONG AllocationsFailed;
    ULONG AllocationsFailedDeliberately;
    ULONG Loads;

    ULONG Unloads;
    ULONG UnTrackedPool;
    ULONG CurrentPagedPoolAllocations;
    ULONG CurrentNonPagedPoolAllocations;

    ULONG PeakPagedPoolAllocations;
    ULONG PeakNonPagedPoolAllocations;

    SIZE_T PagedPoolUsageInBytes;
    SIZE_T NonPagedPoolUsageInBytes;
    SIZE_T PeakPagedPoolUsageInBytes;
    SIZE_T PeakNonPagedPoolUsageInBytes;
} SYSTEM_VERIFIER_INFORMATION_LEGACY, *PSYSTEM_VERIFIER_INFORMATION_LEGACY;

typedef struct _SYSTEM_VERIFIER_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG Level;
    ULONG RuleClasses[2];
    ULONG TriageContext;
    ULONG AreAllDriversBeingVerified;

    UNICODE_STRING DriverName;

    ULONG RaiseIrqls;
    ULONG AcquireSpinLocks;
    ULONG SynchronizeExecutions;
    ULONG AllocationsAttempted;

    ULONG AllocationsSucceeded;
    ULONG AllocationsSucceededSpecialPool;
    ULONG AllocationsWithNoTag;
    ULONG TrimRequests;

    ULONG Trims;
    ULONG AllocationsFailed;
    ULONG AllocationsFailedDeliberately;
    ULONG Loads;

    ULONG Unloads;
    ULONG UnTrackedPool;
    ULONG CurrentPagedPoolAllocations;
    ULONG CurrentNonPagedPoolAllocations;

    ULONG PeakPagedPoolAllocations;
    ULONG PeakNonPagedPoolAllocations;

    SIZE_T PagedPoolUsageInBytes;
    SIZE_T NonPagedPoolUsageInBytes;
    SIZE_T PeakPagedPoolUsageInBytes;
    SIZE_T PeakNonPagedPoolUsageInBytes;
} SYSTEM_VERIFIER_INFORMATION, *PSYSTEM_VERIFIER_INFORMATION;

typedef struct _SYSTEM_SESSION_PROCESS_INFORMATION
{
    ULONG SessionId;
    ULONG SizeOfBuf;
    PVOID Buffer;
} SYSTEM_SESSION_PROCESS_INFORMATION, *PSYSTEM_SESSION_PROCESS_INFORMATION;

typedef struct _SYSTEM_PROCESSOR_POWER_INFORMATION
{
    UCHAR CurrentFrequency;
    UCHAR ThermalLimitFrequency;
    UCHAR ConstantThrottleFrequency;
    UCHAR DegradedThrottleFrequency;
    UCHAR LastBusyFrequency;
    UCHAR LastC3Frequency;
    UCHAR LastAdjustedBusyFrequency;
    UCHAR ProcessorMinThrottle;
    UCHAR ProcessorMaxThrottle;
    ULONG NumberOfFrequencies;
    ULONG PromotionCount;
    ULONG DemotionCount;
    ULONG ErrorCount;
    ULONG RetryCount;
    ULONGLONG CurrentFrequencyTime;
    ULONGLONG CurrentProcessorTime;
    ULONGLONG CurrentProcessorIdleTime;
    ULONGLONG LastProcessorTime;
    ULONGLONG LastProcessorIdleTime;
    ULONGLONG Energy;
} SYSTEM_PROCESSOR_POWER_INFORMATION, *PSYSTEM_PROCESSOR_POWER_INFORMATION;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX
{
    PVOID Object;
    ULONG_PTR UniqueProcessId;
    ULONG_PTR HandleValue;
    ULONG GrantedAccess;
    USHORT CreatorBackTraceIndex;
    USHORT ObjectTypeIndex;
    ULONG HandleAttributes;
    ULONG Reserved;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX;

typedef struct _SYSTEM_HANDLE_INFORMATION_EX
{
    ULONG_PTR NumberOfHandles;
    ULONG_PTR Reserved;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Handles[1];
} SYSTEM_HANDLE_INFORMATION_EX, *PSYSTEM_HANDLE_INFORMATION_EX;

typedef struct _SYSTEM_BIGPOOL_ENTRY
{
    union
    {
        PVOID VirtualAddress;
        ULONG_PTR NonPaged : 1;
    };
    SIZE_T SizeInBytes;
    union
    {
        UCHAR Tag[4];
        ULONG TagUlong;
    };
} SYSTEM_BIGPOOL_ENTRY, *PSYSTEM_BIGPOOL_ENTRY;

typedef struct _SYSTEM_BIGPOOL_INFORMATION
{
    ULONG Count;
    SYSTEM_BIGPOOL_ENTRY AllocatedInfo[1];
} SYSTEM_BIGPOOL_INFORMATION, *PSYSTEM_BIGPOOL_INFORMATION;

typedef struct _SYSTEM_POOL_ENTRY
{
    BOOLEAN Allocated;
    BOOLEAN Spare0;
    USHORT AllocatorBackTraceIndex;
    ULONG Size;
    union
    {
        UCHAR Tag[4];
        ULONG TagUlong;
        PVOID ProcessChargedQuota;
    };
} SYSTEM_POOL_ENTRY, *PSYSTEM_POOL_ENTRY;

typedef struct _SYSTEM_POOL_INFORMATION
{
    SIZE_T TotalSize;
    PVOID FirstEntry;
    USHORT EntryOverhead;
    BOOLEAN PoolTagPresent;
    BOOLEAN Spare0;
    ULONG NumberOfEntries;
    SYSTEM_POOL_ENTRY Entries[1];
} SYSTEM_POOL_INFORMATION, *PSYSTEM_POOL_INFORMATION;

typedef struct _SYSTEM_SESSION_POOLTAG_INFORMATION
{
    SIZE_T NextEntryOffset;
    ULONG SessionId;
    ULONG Count;
    SYSTEM_POOLTAG TagInfo[1];
} SYSTEM_SESSION_POOLTAG_INFORMATION, *PSYSTEM_SESSION_POOLTAG_INFORMATION;

typedef struct _SYSTEM_SESSION_MAPPED_VIEW_INFORMATION
{
    SIZE_T NextEntryOffset;
    ULONG SessionId;
    ULONG ViewFailures;
    SIZE_T NumberOfBytesAvailable;
    SIZE_T NumberOfBytesAvailableContiguous;
} SYSTEM_SESSION_MAPPED_VIEW_INFORMATION, *PSYSTEM_SESSION_MAPPED_VIEW_INFORMATION;

#if (PHNT_MODE != PHNT_MODE_KERNEL)
// private
typedef enum _SYSTEM_FIRMWARE_TABLE_ACTION
{
    SystemFirmwareTableEnumerate,
    SystemFirmwareTableGet,
    SystemFirmwareTableMax
} SYSTEM_FIRMWARE_TABLE_ACTION;

// private
typedef struct _SYSTEM_FIRMWARE_TABLE_INFORMATION
{
    ULONG ProviderSignature; // (same as the GetSystemFirmwareTable function)
    SYSTEM_FIRMWARE_TABLE_ACTION Action;
    ULONG TableID;
    ULONG TableBufferLength;
    UCHAR TableBuffer[1];
} SYSTEM_FIRMWARE_TABLE_INFORMATION, *PSYSTEM_FIRMWARE_TABLE_INFORMATION;
#endif

#if (PHNT_MODE != PHNT_MODE_KERNEL)
// private
typedef NTSTATUS (__cdecl* PFNFTH)(
    _Inout_ PSYSTEM_FIRMWARE_TABLE_INFORMATION SystemFirmwareTableInfo
    );

// private
typedef struct _SYSTEM_FIRMWARE_TABLE_HANDLER
{
    ULONG ProviderSignature;
    BOOLEAN Register;
    PFNFTH FirmwareTableHandler;
    PVOID DriverObject;
} SYSTEM_FIRMWARE_TABLE_HANDLER, *PSYSTEM_FIRMWARE_TABLE_HANDLER;
#endif

// private
typedef struct _SYSTEM_MEMORY_LIST_INFORMATION
{
    ULONG_PTR ZeroPageCount;
    ULONG_PTR FreePageCount;
    ULONG_PTR ModifiedPageCount;
    ULONG_PTR ModifiedNoWritePageCount;
    ULONG_PTR BadPageCount;
    ULONG_PTR PageCountByPriority[8];
    ULONG_PTR RepurposedPagesByPriority[8];
    ULONG_PTR ModifiedPageCountPageFile;
} SYSTEM_MEMORY_LIST_INFORMATION, *PSYSTEM_MEMORY_LIST_INFORMATION;

// private
typedef enum _SYSTEM_MEMORY_LIST_COMMAND
{
    MemoryCaptureAccessedBits,
    MemoryCaptureAndResetAccessedBits,
    MemoryEmptyWorkingSets,
    MemoryFlushModifiedList,
    MemoryPurgeStandbyList,
    MemoryPurgeLowPriorityStandbyList,
    MemoryCommandMax
} SYSTEM_MEMORY_LIST_COMMAND;

// private
typedef struct _SYSTEM_THREAD_CID_PRIORITY_INFORMATION
{
    CLIENT_ID ClientId;
    KPRIORITY Priority;
} SYSTEM_THREAD_CID_PRIORITY_INFORMATION, *PSYSTEM_THREAD_CID_PRIORITY_INFORMATION;

// private
typedef struct _SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION
{
    ULONGLONG CycleTime;
} SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION, *PSYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION;

// private
typedef struct _SYSTEM_VERIFIER_ISSUE
{
    ULONGLONG IssueType;
    PVOID Address;
    ULONGLONG Parameters[2];
} SYSTEM_VERIFIER_ISSUE, *PSYSTEM_VERIFIER_ISSUE;

// private
typedef struct _SYSTEM_VERIFIER_CANCELLATION_INFORMATION
{
    ULONG CancelProbability;
    ULONG CancelThreshold;
    ULONG CompletionThreshold;
    ULONG CancellationVerifierDisabled;
    ULONG AvailableIssues;
    SYSTEM_VERIFIER_ISSUE Issues[128];
} SYSTEM_VERIFIER_CANCELLATION_INFORMATION, *PSYSTEM_VERIFIER_CANCELLATION_INFORMATION;

// private
typedef struct _SYSTEM_REF_TRACE_INFORMATION
{
    BOOLEAN TraceEnable;
    BOOLEAN TracePermanent;
    UNICODE_STRING TraceProcessName;
    UNICODE_STRING TracePoolTags;
} SYSTEM_REF_TRACE_INFORMATION, *PSYSTEM_REF_TRACE_INFORMATION;

// private
typedef struct _SYSTEM_SPECIAL_POOL_INFORMATION
{
    ULONG PoolTag;
    ULONG Flags;
} SYSTEM_SPECIAL_POOL_INFORMATION, *PSYSTEM_SPECIAL_POOL_INFORMATION;

// private
typedef struct _SYSTEM_PROCESS_ID_INFORMATION
{
    HANDLE ProcessId;
    UNICODE_STRING ImageName;
} SYSTEM_PROCESS_ID_INFORMATION, *PSYSTEM_PROCESS_ID_INFORMATION;

// private
typedef struct _SYSTEM_BOOT_ENVIRONMENT_INFORMATION
{
    GUID BootIdentifier;
    FIRMWARE_TYPE FirmwareType;
    union
    {
        ULONGLONG BootFlags;
        struct
        {
            ULONGLONG DbgMenuOsSelection : 1; // REDSTONE4
            ULONGLONG DbgHiberBoot : 1;
            ULONGLONG DbgSoftBoot : 1;
            ULONGLONG DbgMeasuredLaunch : 1;
            ULONGLONG DbgMeasuredLaunchCapable : 1; // 19H1
            ULONGLONG DbgSystemHiveReplace : 1;
            ULONGLONG DbgMeasuredLaunchSmmProtections : 1;
        };
    };
} SYSTEM_BOOT_ENVIRONMENT_INFORMATION, *PSYSTEM_BOOT_ENVIRONMENT_INFORMATION;

// private
typedef struct _SYSTEM_IMAGE_FILE_EXECUTION_OPTIONS_INFORMATION
{
    ULONG FlagsToEnable;
    ULONG FlagsToDisable;
} SYSTEM_IMAGE_FILE_EXECUTION_OPTIONS_INFORMATION, *PSYSTEM_IMAGE_FILE_EXECUTION_OPTIONS_INFORMATION;

// private
typedef struct _SYSTEM_PREFETCH_PATCH_INFORMATION
{
    ULONG PrefetchPatchCount;
} SYSTEM_PREFETCH_PATCH_INFORMATION, *PSYSTEM_PREFETCH_PATCH_INFORMATION;

// private
typedef struct _SYSTEM_VERIFIER_FAULTS_INFORMATION
{
    ULONG Probability;
    ULONG MaxProbability;
    UNICODE_STRING PoolTags;
    UNICODE_STRING Applications;
} SYSTEM_VERIFIER_FAULTS_INFORMATION, *PSYSTEM_VERIFIER_FAULTS_INFORMATION;

// private
typedef struct _SYSTEM_VERIFIER_INFORMATION_EX
{
    ULONG VerifyMode;
    ULONG OptionChanges;
    UNICODE_STRING PreviousBucketName;
    ULONG IrpCancelTimeoutMsec;
    ULONG VerifierExtensionEnabled;
#ifdef _WIN64
    ULONG Reserved[1];
#else
    ULONG Reserved[3];
#endif
} SYSTEM_VERIFIER_INFORMATION_EX, *PSYSTEM_VERIFIER_INFORMATION_EX;

// private
typedef struct _SYSTEM_SYSTEM_PARTITION_INFORMATION
{
    UNICODE_STRING SystemPartition;
} SYSTEM_SYSTEM_PARTITION_INFORMATION, *PSYSTEM_SYSTEM_PARTITION_INFORMATION;

// private
typedef struct _SYSTEM_SYSTEM_DISK_INFORMATION
{
    UNICODE_STRING SystemDisk;
} SYSTEM_SYSTEM_DISK_INFORMATION, *PSYSTEM_SYSTEM_DISK_INFORMATION;

// private (Windows 8.1 and above)
typedef struct _SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT
{
    ULONGLONG Hits;
    UCHAR PercentFrequency;
} SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT, *PSYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT;

// private (Windows 7 and Windows 8)
typedef struct _SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT_WIN8
{
    ULONG Hits;
    UCHAR PercentFrequency;
} SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT_WIN8, *PSYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT_WIN8;

// private
typedef struct _SYSTEM_PROCESSOR_PERFORMANCE_STATE_DISTRIBUTION
{
    ULONG ProcessorNumber;
    ULONG StateCount;
    SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT States[1];
} SYSTEM_PROCESSOR_PERFORMANCE_STATE_DISTRIBUTION, *PSYSTEM_PROCESSOR_PERFORMANCE_STATE_DISTRIBUTION;

// private
typedef struct _SYSTEM_PROCESSOR_PERFORMANCE_DISTRIBUTION
{
    ULONG ProcessorCount;
    ULONG Offsets[1];
} SYSTEM_PROCESSOR_PERFORMANCE_DISTRIBUTION, *PSYSTEM_PROCESSOR_PERFORMANCE_DISTRIBUTION;

#define CODEINTEGRITY_OPTION_ENABLED 0x01
#define CODEINTEGRITY_OPTION_TESTSIGN 0x02
#define CODEINTEGRITY_OPTION_UMCI_ENABLED 0x04
#define CODEINTEGRITY_OPTION_UMCI_AUDITMODE_ENABLED 0x08
#define CODEINTEGRITY_OPTION_UMCI_EXCLUSIONPATHS_ENABLED 0x10
#define CODEINTEGRITY_OPTION_TEST_BUILD 0x20
#define CODEINTEGRITY_OPTION_PREPRODUCTION_BUILD 0x40
#define CODEINTEGRITY_OPTION_DEBUGMODE_ENABLED 0x80
#define CODEINTEGRITY_OPTION_FLIGHT_BUILD 0x100
#define CODEINTEGRITY_OPTION_FLIGHTING_ENABLED 0x200
#define CODEINTEGRITY_OPTION_HVCI_KMCI_ENABLED 0x400
#define CODEINTEGRITY_OPTION_HVCI_KMCI_AUDITMODE_ENABLED 0x800
#define CODEINTEGRITY_OPTION_HVCI_KMCI_STRICTMODE_ENABLED 0x1000
#define CODEINTEGRITY_OPTION_HVCI_IUM_ENABLED 0x2000

// private
typedef struct _SYSTEM_CODEINTEGRITY_INFORMATION
{
    ULONG Length;
    ULONG CodeIntegrityOptions;
} SYSTEM_CODEINTEGRITY_INFORMATION, *PSYSTEM_CODEINTEGRITY_INFORMATION;

// private
typedef struct _SYSTEM_PROCESSOR_MICROCODE_UPDATE_INFORMATION
{
    ULONG Operation;
} SYSTEM_PROCESSOR_MICROCODE_UPDATE_INFORMATION, *PSYSTEM_PROCESSOR_MICROCODE_UPDATE_INFORMATION;

// private
typedef enum _SYSTEM_VA_TYPE
{
    SystemVaTypeAll,
    SystemVaTypeNonPagedPool,
    SystemVaTypePagedPool,
    SystemVaTypeSystemCache,
    SystemVaTypeSystemPtes,
    SystemVaTypeSessionSpace,
    SystemVaTypeMax
} SYSTEM_VA_TYPE, *PSYSTEM_VA_TYPE;

// private
typedef struct _SYSTEM_VA_LIST_INFORMATION
{
    SIZE_T VirtualSize;
    SIZE_T VirtualPeak;
    SIZE_T VirtualLimit;
    SIZE_T AllocationFailures;
} SYSTEM_VA_LIST_INFORMATION, *PSYSTEM_VA_LIST_INFORMATION;

// rev
typedef enum _SYSTEM_STORE_INFORMATION_CLASS
{
    SystemStoreCompressionInformation = 22 // q: SYSTEM_STORE_COMPRESSION_INFORMATION
} SYSTEM_STORE_INFORMATION_CLASS;

// rev
#define SYSTEM_STORE_INFORMATION_VERSION 1

// rev
typedef struct _SYSTEM_STORE_INFORMATION
{
    _In_ ULONG Version;
    _In_ SYSTEM_STORE_INFORMATION_CLASS StoreInformationClass;
    _Inout_ PVOID Data;
    _Inout_ ULONG Length;
} SYSTEM_STORE_INFORMATION, *PSYSTEM_STORE_INFORMATION;

// rev
#define SYSTEM_STORE_COMPRESSION_INFORMATION_VERSION 3

// rev
typedef struct _SYSTEM_STORE_COMPRESSION_INFORMATION
{
    ULONG Version;
    ULONG CompressionPid;
    ULONGLONG CompressionWorkingSetSize;
    ULONGLONG CompressSize;
    ULONGLONG CompressedSize;
    ULONGLONG NonCompressedSize;
} SYSTEM_STORE_COMPRESSION_INFORMATION, *PSYSTEM_STORE_COMPRESSION_INFORMATION;

// private
typedef struct _SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS
{
    HANDLE KeyHandle;
    PUNICODE_STRING ValueNamePointer;
    PULONG RequiredLengthPointer;
    PUCHAR Buffer;
    ULONG BufferLength;
    ULONG Type;
    PUCHAR AppendBuffer;
    ULONG AppendBufferLength;
    BOOLEAN CreateIfDoesntExist;
    BOOLEAN TruncateExistingValue;
} SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS, *PSYSTEM_REGISTRY_APPEND_STRING_PARAMETERS;

// msdn
typedef struct _SYSTEM_VHD_BOOT_INFORMATION
{
    BOOLEAN OsDiskIsVhd;
    ULONG OsVhdFilePathOffset;
    WCHAR OsVhdParentVolume[ANYSIZE_ARRAY];
} SYSTEM_VHD_BOOT_INFORMATION, *PSYSTEM_VHD_BOOT_INFORMATION;

// private
typedef struct _SYSTEM_ERROR_PORT_TIMEOUTS
{
    ULONG StartTimeout;
    ULONG CommTimeout;
} SYSTEM_ERROR_PORT_TIMEOUTS, *PSYSTEM_ERROR_PORT_TIMEOUTS;

// private
typedef struct _SYSTEM_LOW_PRIORITY_IO_INFORMATION
{
    ULONG LowPriReadOperations;
    ULONG LowPriWriteOperations;
    ULONG KernelBumpedToNormalOperations;
    ULONG LowPriPagingReadOperations;
    ULONG KernelPagingReadsBumpedToNormal;
    ULONG LowPriPagingWriteOperations;
    ULONG KernelPagingWritesBumpedToNormal;
    ULONG BoostedIrpCount;
    ULONG BoostedPagingIrpCount;
    ULONG BlanketBoostCount;
} SYSTEM_LOW_PRIORITY_IO_INFORMATION, *PSYSTEM_LOW_PRIORITY_IO_INFORMATION;

// symbols
typedef enum _TPM_BOOT_ENTROPY_RESULT_CODE
{
    TpmBootEntropyStructureUninitialized,
    TpmBootEntropyDisabledByPolicy,
    TpmBootEntropyNoTpmFound,
    TpmBootEntropyTpmError,
    TpmBootEntropySuccess
} TPM_BOOT_ENTROPY_RESULT_CODE;

// Contents of KeLoaderBlock->Extension->TpmBootEntropyResult (TPM_BOOT_ENTROPY_LDR_RESULT).
// EntropyData is truncated to 40 bytes.

// private
typedef struct _TPM_BOOT_ENTROPY_NT_RESULT
{
    ULONGLONG Policy;
    TPM_BOOT_ENTROPY_RESULT_CODE ResultCode;
    NTSTATUS ResultStatus;
    ULONGLONG Time;
    ULONG EntropyLength;
    UCHAR EntropyData[40];
} TPM_BOOT_ENTROPY_NT_RESULT, *PTPM_BOOT_ENTROPY_NT_RESULT;

// private
typedef struct _SYSTEM_VERIFIER_COUNTERS_INFORMATION
{
    SYSTEM_VERIFIER_INFORMATION Legacy;
    ULONG RaiseIrqls;
    ULONG AcquireSpinLocks;
    ULONG SynchronizeExecutions;
    ULONG AllocationsWithNoTag;
    ULONG AllocationsFailed;
    ULONG AllocationsFailedDeliberately;
    SIZE_T LockedBytes;
    SIZE_T PeakLockedBytes;
    SIZE_T MappedLockedBytes;
    SIZE_T PeakMappedLockedBytes;
    SIZE_T MappedIoSpaceBytes;
    SIZE_T PeakMappedIoSpaceBytes;
    SIZE_T PagesForMdlBytes;
    SIZE_T PeakPagesForMdlBytes;
    SIZE_T ContiguousMemoryBytes;
    SIZE_T PeakContiguousMemoryBytes;
    ULONG ExecutePoolTypes; // REDSTONE2
    ULONG ExecutePageProtections;
    ULONG ExecutePageMappings;
    ULONG ExecuteWriteSections;
    ULONG SectionAlignmentFailures;
    ULONG UnsupportedRelocs;
    ULONG IATInExecutableSection;
} SYSTEM_VERIFIER_COUNTERS_INFORMATION, *PSYSTEM_VERIFIER_COUNTERS_INFORMATION;

// private
typedef struct _SYSTEM_ACPI_AUDIT_INFORMATION
{
    ULONG RsdpCount;
    ULONG SameRsdt : 1;
    ULONG SlicPresent : 1;
    ULONG SlicDifferent : 1;
} SYSTEM_ACPI_AUDIT_INFORMATION, *PSYSTEM_ACPI_AUDIT_INFORMATION;

// private
typedef struct _SYSTEM_BASIC_PERFORMANCE_INFORMATION
{
    SIZE_T AvailablePages;
    SIZE_T CommittedPages;
    SIZE_T CommitLimit;
    SIZE_T PeakCommitment;
} SYSTEM_BASIC_PERFORMANCE_INFORMATION, *PSYSTEM_BASIC_PERFORMANCE_INFORMATION;

// begin_msdn

typedef struct _QUERY_PERFORMANCE_COUNTER_FLAGS
{
    union
    {
        struct
        {
            ULONG KernelTransition : 1;
            ULONG Reserved : 31;
        };
        ULONG ul;
    };
} QUERY_PERFORMANCE_COUNTER_FLAGS;

typedef struct _SYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION
{
    ULONG Version;
    QUERY_PERFORMANCE_COUNTER_FLAGS Flags;
    QUERY_PERFORMANCE_COUNTER_FLAGS ValidFlags;
} SYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION, *PSYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION;

// end_msdn

// private
typedef enum _SYSTEM_PIXEL_FORMAT
{
    SystemPixelFormatUnknown,
    SystemPixelFormatR8G8B8,
    SystemPixelFormatR8G8B8X8,
    SystemPixelFormatB8G8R8,
    SystemPixelFormatB8G8R8X8
} SYSTEM_PIXEL_FORMAT;

// private
typedef struct _SYSTEM_BOOT_GRAPHICS_INFORMATION
{
    LARGE_INTEGER FrameBuffer;
    ULONG Width;
    ULONG Height;
    ULONG PixelStride;
    ULONG Flags;
    SYSTEM_PIXEL_FORMAT Format;
    ULONG DisplayRotation;
} SYSTEM_BOOT_GRAPHICS_INFORMATION, *PSYSTEM_BOOT_GRAPHICS_INFORMATION;

// private
typedef struct _MEMORY_SCRUB_INFORMATION
{
    HANDLE Handle;
    ULONG PagesScrubbed;
} MEMORY_SCRUB_INFORMATION, *PMEMORY_SCRUB_INFORMATION;

// private
typedef struct _PEBS_DS_SAVE_AREA32
{
    ULONG BtsBufferBase;
    ULONG BtsIndex;
    ULONG BtsAbsoluteMaximum;
    ULONG BtsInterruptThreshold;
    ULONG PebsBufferBase;
    ULONG PebsIndex;
    ULONG PebsAbsoluteMaximum;
    ULONG PebsInterruptThreshold;
    ULONG PebsGpCounterReset[8];
    ULONG PebsFixedCounterReset[4];
} PEBS_DS_SAVE_AREA32, *PPEBS_DS_SAVE_AREA32;

// private
typedef struct _PEBS_DS_SAVE_AREA64
{
    ULONGLONG BtsBufferBase;
    ULONGLONG BtsIndex;
    ULONGLONG BtsAbsoluteMaximum;
    ULONGLONG BtsInterruptThreshold;
    ULONGLONG PebsBufferBase;
    ULONGLONG PebsIndex;
    ULONGLONG PebsAbsoluteMaximum;
    ULONGLONG PebsInterruptThreshold;
    ULONGLONG PebsGpCounterReset[8];
    ULONGLONG PebsFixedCounterReset[4];
} PEBS_DS_SAVE_AREA64, *PPEBS_DS_SAVE_AREA64;

// private
typedef union _PEBS_DS_SAVE_AREA
{
    PEBS_DS_SAVE_AREA32 As32Bit;
    PEBS_DS_SAVE_AREA64 As64Bit;
} PEBS_DS_SAVE_AREA, *PPEBS_DS_SAVE_AREA;

// private
typedef struct _PROCESSOR_PROFILE_CONTROL_AREA
{
    PEBS_DS_SAVE_AREA PebsDsSaveArea;
} PROCESSOR_PROFILE_CONTROL_AREA, *PPROCESSOR_PROFILE_CONTROL_AREA;

// private
typedef struct _SYSTEM_PROCESSOR_PROFILE_CONTROL_AREA
{
    PROCESSOR_PROFILE_CONTROL_AREA ProcessorProfileControlArea;
    BOOLEAN Allocate;
} SYSTEM_PROCESSOR_PROFILE_CONTROL_AREA, *PSYSTEM_PROCESSOR_PROFILE_CONTROL_AREA;

// private
typedef struct _MEMORY_COMBINE_INFORMATION
{
    HANDLE Handle;
    ULONG_PTR PagesCombined;
} MEMORY_COMBINE_INFORMATION, *PMEMORY_COMBINE_INFORMATION;

// rev
#define MEMORY_COMBINE_FLAGS_COMMON_PAGES_ONLY 0x4

// private
typedef struct _MEMORY_COMBINE_INFORMATION_EX
{
    HANDLE Handle;
    ULONG_PTR PagesCombined;
    ULONG Flags;
} MEMORY_COMBINE_INFORMATION_EX, *PMEMORY_COMBINE_INFORMATION_EX;

// private
typedef struct _MEMORY_COMBINE_INFORMATION_EX2
{
    HANDLE Handle;
    ULONG_PTR PagesCombined;
    ULONG Flags;
    HANDLE ProcessHandle;
} MEMORY_COMBINE_INFORMATION_EX2, *PMEMORY_COMBINE_INFORMATION_EX2;

// private
typedef struct _SYSTEM_CONSOLE_INFORMATION
{
    ULONG DriverLoaded : 1;
    ULONG Spare : 31;
} SYSTEM_CONSOLE_INFORMATION, *PSYSTEM_CONSOLE_INFORMATION;

// private
typedef struct _SYSTEM_PLATFORM_BINARY_INFORMATION
{
    ULONG64 PhysicalAddress;
    PVOID HandoffBuffer;
    PVOID CommandLineBuffer;
    ULONG HandoffBufferSize;
    ULONG CommandLineBufferSize;
} SYSTEM_PLATFORM_BINARY_INFORMATION, *PSYSTEM_PLATFORM_BINARY_INFORMATION;

// private
typedef struct _SYSTEM_POLICY_INFORMATION
{
    PVOID InputData;
    PVOID OutputData;
    ULONG InputDataSize;
    ULONG OutputDataSize;
    ULONG Version;
} SYSTEM_POLICY_INFORMATION, *PSYSTEM_POLICY_INFORMATION;

// private
typedef struct _SYSTEM_HYPERVISOR_PROCESSOR_COUNT_INFORMATION
{
    ULONG NumberOfLogicalProcessors;
    ULONG NumberOfCores;
} SYSTEM_HYPERVISOR_PROCESSOR_COUNT_INFORMATION, *PSYSTEM_HYPERVISOR_PROCESSOR_COUNT_INFORMATION;

// private
typedef struct _SYSTEM_DEVICE_DATA_INFORMATION
{
    UNICODE_STRING DeviceId;
    UNICODE_STRING DataName;
    ULONG DataType;
    ULONG DataBufferLength;
    PVOID DataBuffer;
} SYSTEM_DEVICE_DATA_INFORMATION, *PSYSTEM_DEVICE_DATA_INFORMATION;

// private
typedef struct _PHYSICAL_CHANNEL_RUN
{
    ULONG NodeNumber;
    ULONG ChannelNumber;
    ULONGLONG BasePage;
    ULONGLONG PageCount;
    ULONG Flags;
} PHYSICAL_CHANNEL_RUN, *PPHYSICAL_CHANNEL_RUN;

// private
typedef struct _SYSTEM_MEMORY_TOPOLOGY_INFORMATION
{
    ULONGLONG NumberOfRuns;
    ULONG NumberOfNodes;
    ULONG NumberOfChannels;
    PHYSICAL_CHANNEL_RUN Run[1];
} SYSTEM_MEMORY_TOPOLOGY_INFORMATION, *PSYSTEM_MEMORY_TOPOLOGY_INFORMATION;

// private
typedef struct _SYSTEM_MEMORY_CHANNEL_INFORMATION
{
    ULONG ChannelNumber;
    ULONG ChannelHeatIndex;
    ULONGLONG TotalPageCount;
    ULONGLONG ZeroPageCount;
    ULONGLONG FreePageCount;
    ULONGLONG StandbyPageCount;
} SYSTEM_MEMORY_CHANNEL_INFORMATION, *PSYSTEM_MEMORY_CHANNEL_INFORMATION;

// private
typedef struct _SYSTEM_BOOT_LOGO_INFORMATION
{
    ULONG Flags;
    ULONG BitmapOffset;
} SYSTEM_BOOT_LOGO_INFORMATION, *PSYSTEM_BOOT_LOGO_INFORMATION;

// private
typedef struct _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION_EX
{
    LARGE_INTEGER IdleTime;
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER DpcTime;
    LARGE_INTEGER InterruptTime;
    ULONG InterruptCount;
    ULONG Spare0;
    LARGE_INTEGER AvailableTime;
    LARGE_INTEGER Spare1;
    LARGE_INTEGER Spare2;
} SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION_EX, *PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION_EX;

// private
typedef struct _SYSTEM_SECUREBOOT_POLICY_INFORMATION
{
    GUID PolicyPublisher;
    ULONG PolicyVersion;
    ULONG PolicyOptions;
} SYSTEM_SECUREBOOT_POLICY_INFORMATION, *PSYSTEM_SECUREBOOT_POLICY_INFORMATION;

// private
typedef struct _SYSTEM_PAGEFILE_INFORMATION_EX
{
    union // HACK union declaration for convenience (dmex)
    {
        SYSTEM_PAGEFILE_INFORMATION Info;
        struct
        {
            ULONG NextEntryOffset;
            ULONG TotalSize;
            ULONG TotalInUse;
            ULONG PeakUsage;
            UNICODE_STRING PageFileName;
        };
    };

    ULONG MinimumSize;
    ULONG MaximumSize;
} SYSTEM_PAGEFILE_INFORMATION_EX, *PSYSTEM_PAGEFILE_INFORMATION_EX;

// private
typedef struct _SYSTEM_SECUREBOOT_INFORMATION
{
    BOOLEAN SecureBootEnabled;
    BOOLEAN SecureBootCapable;
} SYSTEM_SECUREBOOT_INFORMATION, *PSYSTEM_SECUREBOOT_INFORMATION;

// private
typedef struct _PROCESS_DISK_COUNTERS
{
    ULONGLONG BytesRead;
    ULONGLONG BytesWritten;
    ULONGLONG ReadOperationCount;
    ULONGLONG WriteOperationCount;
    ULONGLONG FlushOperationCount;
} PROCESS_DISK_COUNTERS, *PPROCESS_DISK_COUNTERS;

// private
typedef union _ENERGY_STATE_DURATION
{
    union
    {
        ULONGLONG Value;
        ULONG LastChangeTime;
    };

    ULONG Duration : 31;
    ULONG IsInState : 1;
} ENERGY_STATE_DURATION, *PENERGY_STATE_DURATION;

typedef struct _PROCESS_ENERGY_VALUES
{
    ULONGLONG Cycles[4][2];
    ULONGLONG DiskEnergy;
    ULONGLONG NetworkTailEnergy;
    ULONGLONG MBBTailEnergy;
    ULONGLONG NetworkTxRxBytes;
    ULONGLONG MBBTxRxBytes;
    union
    {
        ENERGY_STATE_DURATION Durations[3];
        struct
        {
            ENERGY_STATE_DURATION ForegroundDuration;
            ENERGY_STATE_DURATION DesktopVisibleDuration;
            ENERGY_STATE_DURATION PSMForegroundDuration;
        };
    };
    ULONG CompositionRendered;
    ULONG CompositionDirtyGenerated;
    ULONG CompositionDirtyPropagated;
    ULONG Reserved1;
    ULONGLONG AttributedCycles[4][2];
    ULONGLONG WorkOnBehalfCycles[4][2];
} PROCESS_ENERGY_VALUES, *PPROCESS_ENERGY_VALUES;

typedef struct _TIMELINE_BITMAP
{
    ULONGLONG Value;
    ULONG EndTime;
    ULONG Bitmap;
} TIMELINE_BITMAP, *PTIMELINE_BITMAP;

typedef struct _PROCESS_ENERGY_VALUES_EXTENSION
{
    union
    {
        TIMELINE_BITMAP Timelines[14]; // 9 for REDSTONE2, 14 for REDSTONE3/4/5
        struct
        {
            TIMELINE_BITMAP CpuTimeline;
            TIMELINE_BITMAP DiskTimeline;
            TIMELINE_BITMAP NetworkTimeline;
            TIMELINE_BITMAP MBBTimeline;
            TIMELINE_BITMAP ForegroundTimeline;
            TIMELINE_BITMAP DesktopVisibleTimeline;
            TIMELINE_BITMAP CompositionRenderedTimeline;
            TIMELINE_BITMAP CompositionDirtyGeneratedTimeline;
            TIMELINE_BITMAP CompositionDirtyPropagatedTimeline;
            TIMELINE_BITMAP InputTimeline; // REDSTONE3
            TIMELINE_BITMAP AudioInTimeline;
            TIMELINE_BITMAP AudioOutTimeline;
            TIMELINE_BITMAP DisplayRequiredTimeline;
            TIMELINE_BITMAP KeyboardInputTimeline;
        };
    };

    union // REDSTONE3
    {
        ENERGY_STATE_DURATION Durations[5];
        struct
        {
            ENERGY_STATE_DURATION InputDuration;
            ENERGY_STATE_DURATION AudioInDuration;
            ENERGY_STATE_DURATION AudioOutDuration;
            ENERGY_STATE_DURATION DisplayRequiredDuration;
            ENERGY_STATE_DURATION PSMBackgroundDuration;
        };
    };

    ULONG KeyboardInput;
    ULONG MouseInput;
} PROCESS_ENERGY_VALUES_EXTENSION, *PPROCESS_ENERGY_VALUES_EXTENSION;

typedef struct _PROCESS_EXTENDED_ENERGY_VALUES
{
    PROCESS_ENERGY_VALUES Base;
    PROCESS_ENERGY_VALUES_EXTENSION Extension;
} PROCESS_EXTENDED_ENERGY_VALUES, *PPROCESS_EXTENDED_ENERGY_VALUES;

// private
typedef enum _SYSTEM_PROCESS_CLASSIFICATION
{
    SystemProcessClassificationNormal,
    SystemProcessClassificationSystem,
    SystemProcessClassificationSecureSystem,
    SystemProcessClassificationMemCompression,
    SystemProcessClassificationRegistry, // REDSTONE4
    SystemProcessClassificationMaximum
} SYSTEM_PROCESS_CLASSIFICATION;

// private
typedef struct _SYSTEM_PROCESS_INFORMATION_EXTENSION
{
    PROCESS_DISK_COUNTERS DiskCounters;
    ULONGLONG ContextSwitches;
    union
    {
        ULONG Flags;
        struct
        {
            ULONG HasStrongId : 1;
            ULONG Classification : 4; // SYSTEM_PROCESS_CLASSIFICATION
            ULONG BackgroundActivityModerated : 1;
            ULONG Spare : 26;
        };
    };
    ULONG UserSidOffset;
    ULONG PackageFullNameOffset; // since THRESHOLD
    PROCESS_ENERGY_VALUES EnergyValues; // since THRESHOLD
    ULONG AppIdOffset; // since THRESHOLD
    SIZE_T SharedCommitCharge; // since THRESHOLD2
    ULONG JobObjectId; // since REDSTONE
    ULONG SpareUlong; // since REDSTONE
    ULONGLONG ProcessSequenceNumber;
} SYSTEM_PROCESS_INFORMATION_EXTENSION, *PSYSTEM_PROCESS_INFORMATION_EXTENSION;

// private
typedef struct _SYSTEM_PORTABLE_WORKSPACE_EFI_LAUNCHER_INFORMATION
{
    BOOLEAN EfiLauncherEnabled;
} SYSTEM_PORTABLE_WORKSPACE_EFI_LAUNCHER_INFORMATION, *PSYSTEM_PORTABLE_WORKSPACE_EFI_LAUNCHER_INFORMATION;

// private
typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX
{
    BOOLEAN DebuggerAllowed;
    BOOLEAN DebuggerEnabled;
    BOOLEAN DebuggerPresent;
} SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION_EX;

// private
typedef struct _SYSTEM_ELAM_CERTIFICATE_INFORMATION
{
    HANDLE ElamDriverFile;
} SYSTEM_ELAM_CERTIFICATE_INFORMATION, *PSYSTEM_ELAM_CERTIFICATE_INFORMATION;

// private
typedef struct _SYSTEM_PROCESSOR_FEATURES_INFORMATION
{
    ULONGLONG ProcessorFeatureBits;
    ULONGLONG Reserved[3];
} SYSTEM_PROCESSOR_FEATURES_INFORMATION, *PSYSTEM_PROCESSOR_FEATURES_INFORMATION;

// private
typedef struct _SYSTEM_MANUFACTURING_INFORMATION
{
    ULONG Options;
    UNICODE_STRING ProfileName;
} SYSTEM_MANUFACTURING_INFORMATION, *PSYSTEM_MANUFACTURING_INFORMATION;

// private
typedef struct _SYSTEM_ENERGY_ESTIMATION_CONFIG_INFORMATION
{
    BOOLEAN Enabled;
} SYSTEM_ENERGY_ESTIMATION_CONFIG_INFORMATION, *PSYSTEM_ENERGY_ESTIMATION_CONFIG_INFORMATION;

// private
typedef struct _HV_DETAILS
{
    ULONG Data[4];
} HV_DETAILS, *PHV_DETAILS;

// private
typedef struct _SYSTEM_HYPERVISOR_DETAIL_INFORMATION
{
    HV_DETAILS HvVendorAndMaxFunction;
    HV_DETAILS HypervisorInterface;
    HV_DETAILS HypervisorVersion;
    HV_DETAILS HvFeatures;
    HV_DETAILS HwFeatures;
    HV_DETAILS EnlightenmentInfo;
    HV_DETAILS ImplementationLimits;
} SYSTEM_HYPERVISOR_DETAIL_INFORMATION, *PSYSTEM_HYPERVISOR_DETAIL_INFORMATION;

// private
typedef struct _SYSTEM_PROCESSOR_CYCLE_STATS_INFORMATION
{
    ULONGLONG Cycles[4][2];
} SYSTEM_PROCESSOR_CYCLE_STATS_INFORMATION, *PSYSTEM_PROCESSOR_CYCLE_STATS_INFORMATION;

// private
typedef struct _SYSTEM_TPM_INFORMATION
{
    ULONG Flags;
} SYSTEM_TPM_INFORMATION, *PSYSTEM_TPM_INFORMATION;

// private
typedef struct _SYSTEM_VSM_PROTECTION_INFORMATION
{
    BOOLEAN DmaProtectionsAvailable;
    BOOLEAN DmaProtectionsInUse;
    BOOLEAN HardwareMbecAvailable; // REDSTONE4 (CVE-2018-3639)
} SYSTEM_VSM_PROTECTION_INFORMATION, *PSYSTEM_VSM_PROTECTION_INFORMATION;

// private
typedef struct _SYSTEM_KERNEL_DEBUGGER_FLAGS
{
    UCHAR KernelDebuggerIgnoreUmExceptions;
} SYSTEM_KERNEL_DEBUGGER_FLAGS, *PSYSTEM_KERNEL_DEBUGGER_FLAGS;

// private
typedef struct _SYSTEM_CODEINTEGRITYPOLICY_INFORMATION
{
    ULONG Options;
    ULONG HVCIOptions;
    ULONGLONG Version;
    GUID PolicyGuid;
} SYSTEM_CODEINTEGRITYPOLICY_INFORMATION, *PSYSTEM_CODEINTEGRITYPOLICY_INFORMATION;

// private
typedef struct _SYSTEM_ISOLATED_USER_MODE_INFORMATION
{
    BOOLEAN SecureKernelRunning : 1;
    BOOLEAN HvciEnabled : 1;
    BOOLEAN HvciStrictMode : 1;
    BOOLEAN DebugEnabled : 1;
    BOOLEAN FirmwarePageProtection : 1;
    BOOLEAN EncryptionKeyAvailable : 1;
    BOOLEAN SpareFlags : 2;
    BOOLEAN TrustletRunning : 1;
    BOOLEAN HvciDisableAllowed : 1;
    BOOLEAN SpareFlags2 : 6;
    BOOLEAN Spare0[6];
    ULONGLONG Spare1;
} SYSTEM_ISOLATED_USER_MODE_INFORMATION, *PSYSTEM_ISOLATED_USER_MODE_INFORMATION;

// private
typedef struct _SYSTEM_SINGLE_MODULE_INFORMATION
{
    PVOID TargetModuleAddress;
    RTL_PROCESS_MODULE_INFORMATION_EX ExInfo;
} SYSTEM_SINGLE_MODULE_INFORMATION, *PSYSTEM_SINGLE_MODULE_INFORMATION;

// private
typedef struct _SYSTEM_INTERRUPT_CPU_SET_INFORMATION
{
    ULONG Gsiv;
    USHORT Group;
    ULONGLONG CpuSets;
} SYSTEM_INTERRUPT_CPU_SET_INFORMATION, *PSYSTEM_INTERRUPT_CPU_SET_INFORMATION;

// private
typedef struct _SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION
{
    SYSTEM_SECUREBOOT_POLICY_INFORMATION PolicyInformation;
    ULONG PolicySize;
    UCHAR Policy[1];
} SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION, *PSYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION;

// private
typedef struct _SYSTEM_ROOT_SILO_INFORMATION
{
    ULONG NumberOfSilos;
    ULONG SiloIdList[1];
} SYSTEM_ROOT_SILO_INFORMATION, *PSYSTEM_ROOT_SILO_INFORMATION;

// private
typedef struct _SYSTEM_CPU_SET_TAG_INFORMATION
{
    ULONGLONG Tag;
    ULONGLONG CpuSets[1];
} SYSTEM_CPU_SET_TAG_INFORMATION, *PSYSTEM_CPU_SET_TAG_INFORMATION;

// private
typedef struct _SYSTEM_SECURE_KERNEL_HYPERGUARD_PROFILE_INFORMATION
{
    ULONG ExtentCount;
    ULONG ValidStructureSize;
    ULONG NextExtentIndex;
    ULONG ExtentRestart;
    ULONG CycleCount;
    ULONG TimeoutCount;
    ULONGLONG CycleTime;
    ULONGLONG CycleTimeMax;
    ULONGLONG ExtentTime;
    ULONG ExtentTimeIndex;
    ULONG ExtentTimeMaxIndex;
    ULONGLONG ExtentTimeMax;
    ULONGLONG HyperFlushTimeMax;
    ULONGLONG TranslateVaTimeMax;
    ULONGLONG DebugExemptionCount;
    ULONGLONG TbHitCount;
    ULONGLONG TbMissCount;
    ULONGLONG VinaPendingYield;
    ULONGLONG HashCycles;
    ULONG HistogramOffset;
    ULONG HistogramBuckets;
    ULONG HistogramShift;
    ULONG Reserved1;
    ULONGLONG PageNotPresentCount;
} SYSTEM_SECURE_KERNEL_HYPERGUARD_PROFILE_INFORMATION, *PSYSTEM_SECURE_KERNEL_HYPERGUARD_PROFILE_INFORMATION;

// private
typedef struct _SYSTEM_SECUREBOOT_PLATFORM_MANIFEST_INFORMATION
{
    ULONG PlatformManifestSize;
    UCHAR PlatformManifest[1];
} SYSTEM_SECUREBOOT_PLATFORM_MANIFEST_INFORMATION, *PSYSTEM_SECUREBOOT_PLATFORM_MANIFEST_INFORMATION;

// private
typedef struct _SYSTEM_INTERRUPT_STEERING_INFORMATION_INPUT
{
    ULONG Gsiv;
    UCHAR ControllerInterrupt;
    UCHAR EdgeInterrupt;
    UCHAR IsPrimaryInterrupt;
    GROUP_AFFINITY TargetAffinity;
} SYSTEM_INTERRUPT_STEERING_INFORMATION_INPUT, *PSYSTEM_INTERRUPT_STEERING_INFORMATION_INPUT;

// private
typedef struct _SYSTEM_MEMORY_USAGE_INFORMATION
{
    ULONGLONG TotalPhysicalBytes;
    ULONGLONG AvailableBytes;
    LONGLONG ResidentAvailableBytes;
    ULONGLONG CommittedBytes;
    ULONGLONG SharedCommittedBytes;
    ULONGLONG CommitLimitBytes;
    ULONGLONG PeakCommitmentBytes;
} SYSTEM_MEMORY_USAGE_INFORMATION, *PSYSTEM_MEMORY_USAGE_INFORMATION;

// private
typedef struct _SYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION
{
    HANDLE ImageFile;
    ULONG Type; // REDSTONE4
} SYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION, *PSYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION;

// private
typedef struct _SYSTEM_PHYSICAL_MEMORY_INFORMATION
{
    ULONGLONG TotalPhysicalBytes;
    ULONGLONG LowestPhysicalAddress;
    ULONGLONG HighestPhysicalAddress;
} SYSTEM_PHYSICAL_MEMORY_INFORMATION, *PSYSTEM_PHYSICAL_MEMORY_INFORMATION;

// private
typedef enum _SYSTEM_ACTIVITY_MODERATION_STATE
{
    SystemActivityModerationStateSystemManaged,
    SystemActivityModerationStateUserManagedAllowThrottling,
    SystemActivityModerationStateUserManagedDisableThrottling,
    MaxSystemActivityModerationState
} SYSTEM_ACTIVITY_MODERATION_STATE;

// private - REDSTONE2
typedef struct _SYSTEM_ACTIVITY_MODERATION_EXE_STATE // REDSTONE3: Renamed SYSTEM_ACTIVITY_MODERATION_INFO
{
    UNICODE_STRING ExePathNt;
    SYSTEM_ACTIVITY_MODERATION_STATE ModerationState;
} SYSTEM_ACTIVITY_MODERATION_EXE_STATE, *PSYSTEM_ACTIVITY_MODERATION_EXE_STATE;

typedef enum _SYSTEM_ACTIVITY_MODERATION_APP_TYPE
{
    SystemActivityModerationAppTypeClassic,
    SystemActivityModerationAppTypePackaged,
    MaxSystemActivityModerationAppType
} SYSTEM_ACTIVITY_MODERATION_APP_TYPE;

// private - REDSTONE3
typedef struct _SYSTEM_ACTIVITY_MODERATION_INFO
{
    UNICODE_STRING Identifier;
    SYSTEM_ACTIVITY_MODERATION_STATE ModerationState;
    SYSTEM_ACTIVITY_MODERATION_APP_TYPE AppType;
} SYSTEM_ACTIVITY_MODERATION_INFO, *PSYSTEM_ACTIVITY_MODERATION_INFO;

// private
typedef struct _SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS
{
    HANDLE UserKeyHandle;
} SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS, *PSYSTEM_ACTIVITY_MODERATION_USER_SETTINGS;

// private
typedef struct _SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION
{
    union
    {
        ULONG Flags;
        struct
        {
            ULONG Locked : 1;
            ULONG UnlockApplied : 1; // Unlockable field removed 19H1
            ULONG UnlockIdValid : 1;
            ULONG Reserved : 29;
        };
    };
    UCHAR UnlockId[32]; // REDSTONE4
} SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION, *PSYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION;

// private
typedef struct _SYSTEM_FLUSH_INFORMATION
{
    ULONG SupportedFlushMethods;
    ULONG ProcessorCacheFlushSize;
    ULONGLONG SystemFlushCapabilities;
    ULONGLONG Reserved[2];
} SYSTEM_FLUSH_INFORMATION, *PSYSTEM_FLUSH_INFORMATION;

// private
typedef struct _SYSTEM_WRITE_CONSTRAINT_INFORMATION
{
    ULONG WriteConstraintPolicy;
    ULONG Reserved;
} SYSTEM_WRITE_CONSTRAINT_INFORMATION, *PSYSTEM_WRITE_CONSTRAINT_INFORMATION;

// private
typedef struct _SYSTEM_KERNEL_VA_SHADOW_INFORMATION
{
    union
    {
        ULONG KvaShadowFlags;
        struct
        {
            ULONG KvaShadowEnabled : 1;
            ULONG KvaShadowUserGlobal : 1;
            ULONG KvaShadowPcid : 1;
            ULONG KvaShadowInvpcid : 1;
            ULONG KvaShadowRequired : 1; // REDSTONE4
            ULONG KvaShadowRequiredAvailable : 1;
            ULONG InvalidPteBit : 6;
            ULONG L1DataCacheFlushSupported : 1;
            ULONG L1TerminalFaultMitigationPresent : 1;
            ULONG Reserved : 18;
        };
    };
} SYSTEM_KERNEL_VA_SHADOW_INFORMATION, *PSYSTEM_KERNEL_VA_SHADOW_INFORMATION;

// private
typedef struct _SYSTEM_CODEINTEGRITYVERIFICATION_INFORMATION
{
    HANDLE FileHandle;
    ULONG ImageSize;
    PVOID Image;
} SYSTEM_CODEINTEGRITYVERIFICATION_INFORMATION, *PSYSTEM_CODEINTEGRITYVERIFICATION_INFORMATION;

// private
typedef struct _SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION
{
    PVOID HypervisorSharedUserVa;
} SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION, *PSYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION;

// private
typedef struct _SYSTEM_FIRMWARE_PARTITION_INFORMATION
{
    UNICODE_STRING FirmwarePartition;
} SYSTEM_FIRMWARE_PARTITION_INFORMATION, *PSYSTEM_FIRMWARE_PARTITION_INFORMATION;

// private
typedef struct _SYSTEM_SPECULATION_CONTROL_INFORMATION
{
    union
    {
        ULONG Flags;
        struct
        {
            ULONG BpbEnabled : 1;
            ULONG BpbDisabledSystemPolicy : 1;
            ULONG BpbDisabledNoHardwareSupport : 1;
            ULONG SpecCtrlEnumerated : 1;
            ULONG SpecCmdEnumerated : 1;
            ULONG IbrsPresent : 1;
            ULONG StibpPresent : 1;
            ULONG SmepPresent : 1;
            ULONG SpeculativeStoreBypassDisableAvailable : 1; // REDSTONE4 (CVE-2018-3639)
            ULONG SpeculativeStoreBypassDisableSupported : 1;
            ULONG SpeculativeStoreBypassDisabledSystemWide : 1;
            ULONG SpeculativeStoreBypassDisabledKernel : 1;
            ULONG SpeculativeStoreBypassDisableRequired : 1;
            ULONG BpbDisabledKernelToUser : 1;
            ULONG SpecCtrlRetpolineEnabled : 1;
            ULONG SpecCtrlImportOptimizationEnabled : 1;
            ULONG EnhancedIbrs : 1; // since 19H1
            ULONG HvL1tfStatusAvailable : 1;
            ULONG HvL1tfProcessorNotAffected : 1;
            ULONG HvL1tfMigitationEnabled : 1;
            ULONG HvL1tfMigitationNotEnabled_Hardware : 1;
            ULONG HvL1tfMigitationNotEnabled_LoadOption : 1;
            ULONG HvL1tfMigitationNotEnabled_CoreScheduler : 1;
            ULONG EnhancedIbrsReported : 1;
            ULONG MdsHardwareProtected : 1; // since 19H2
            ULONG MbClearEnabled : 1;
            ULONG MbClearReported : 1;
            ULONG Reserved : 5;
        };
    };
} SYSTEM_SPECULATION_CONTROL_INFORMATION, *PSYSTEM_SPECULATION_CONTROL_INFORMATION;

// private
typedef struct _SYSTEM_DMA_GUARD_POLICY_INFORMATION
{
    BOOLEAN DmaGuardPolicyEnabled;
} SYSTEM_DMA_GUARD_POLICY_INFORMATION, *PSYSTEM_DMA_GUARD_POLICY_INFORMATION;

// private
typedef struct _SYSTEM_ENCLAVE_LAUNCH_CONTROL_INFORMATION
{
    UCHAR EnclaveLaunchSigner[32];
} SYSTEM_ENCLAVE_LAUNCH_CONTROL_INFORMATION, *PSYSTEM_ENCLAVE_LAUNCH_CONTROL_INFORMATION;

// private
typedef struct _SYSTEM_WORKLOAD_ALLOWED_CPU_SET_INFORMATION
{
    ULONGLONG WorkloadClass;
    ULONGLONG CpuSets[1];
} SYSTEM_WORKLOAD_ALLOWED_CPU_SET_INFORMATION, *PSYSTEM_WORKLOAD_ALLOWED_CPU_SET_INFORMATION;

// private
typedef struct _SYSTEM_SECURITY_MODEL_INFORMATION
{
    union
    {
        ULONG SecurityModelFlags;
        struct
        {
            ULONG SModeAdminlessEnabled : 1;
            ULONG AllowDeviceOwnerProtectionDowngrade : 1;
            ULONG Reserved : 30;
        };
    };
} SYSTEM_SECURITY_MODEL_INFORMATION, *PSYSTEM_SECURITY_MODEL_INFORMATION;

// private
typedef struct _SYSTEM_FEATURE_CONFIGURATION_INFORMATION
{
    ULONGLONG ChangeStamp;
    struct _RTL_FEATURE_CONFIGURATION* Configuration; // see ntrtl.h for types
} SYSTEM_FEATURE_CONFIGURATION_INFORMATION, *PSYSTEM_FEATURE_CONFIGURATION_INFORMATION;

// private
typedef struct _SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION_ENTRY
{
    ULONGLONG ChangeStamp;
    PVOID Section;
    ULONGLONG Size;
} SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION_ENTRY, *PSYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION_ENTRY;

// private
typedef struct _SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION
{
    ULONGLONG OverallChangeStamp;
    SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION_ENTRY Descriptors[3];
} SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION, *PSYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION;

// private
typedef union _SECURE_SPECULATION_CONTROL_INFORMATION
{
    ULONG KvaShadowSupported : 1;
    ULONG KvaShadowEnabled : 1;
    ULONG KvaShadowUserGlobal : 1;
    ULONG KvaShadowPcid : 1;
    ULONG MbClearEnabled : 1;
    ULONG Reserved : 27;
} SECURE_SPECULATION_CONTROL_INFORMATION, *PSECURE_SPECULATION_CONTROL_INFORMATION;

#if (PHNT_MODE != PHNT_MODE_KERNEL)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySystemInformation(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _Out_writes_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
    _In_ ULONG SystemInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

#if (PHNT_VERSION >= PHNT_WIN7)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySystemInformationEx(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _In_reads_bytes_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
    _In_ ULONG SystemInformationLength,
    _Out_opt_ PULONG ReturnLength
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetSystemInformation(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _In_reads_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
    _In_ ULONG SystemInformationLength
    );

// SysDbg APIs

// private
typedef enum _SYSDBG_COMMAND
{
    SysDbgQueryModuleInformation,
    SysDbgQueryTraceInformation,
    SysDbgSetTracepoint,
    SysDbgSetSpecialCall,
    SysDbgClearSpecialCalls,
    SysDbgQuerySpecialCalls,
    SysDbgBreakPoint,
    SysDbgQueryVersion,
    SysDbgReadVirtual,
    SysDbgWriteVirtual,
    SysDbgReadPhysical,
    SysDbgWritePhysical,
    SysDbgReadControlSpace,
    SysDbgWriteControlSpace,
    SysDbgReadIoSpace,
    SysDbgWriteIoSpace,
    SysDbgReadMsr,
    SysDbgWriteMsr,
    SysDbgReadBusData,
    SysDbgWriteBusData,
    SysDbgCheckLowMemory,
    SysDbgEnableKernelDebugger,
    SysDbgDisableKernelDebugger,
    SysDbgGetAutoKdEnable,
    SysDbgSetAutoKdEnable,
    SysDbgGetPrintBufferSize,
    SysDbgSetPrintBufferSize,
    SysDbgGetKdUmExceptionEnable,
    SysDbgSetKdUmExceptionEnable,
    SysDbgGetTriageDump,
    SysDbgGetKdBlockEnable,
    SysDbgSetKdBlockEnable,
    SysDbgRegisterForUmBreakInfo,
    SysDbgGetUmBreakPid,
    SysDbgClearUmBreakPid,
    SysDbgGetUmAttachPid,
    SysDbgClearUmAttachPid,
    SysDbgGetLiveKernelDump
} SYSDBG_COMMAND, *PSYSDBG_COMMAND;

typedef struct _SYSDBG_VIRTUAL
{
    PVOID Address;
    PVOID Buffer;
    ULONG Request;
} SYSDBG_VIRTUAL, *PSYSDBG_VIRTUAL;

typedef struct _SYSDBG_PHYSICAL
{
    PHYSICAL_ADDRESS Address;
    PVOID Buffer;
    ULONG Request;
} SYSDBG_PHYSICAL, *PSYSDBG_PHYSICAL;

typedef struct _SYSDBG_CONTROL_SPACE
{
    ULONG64 Address;
    PVOID Buffer;
    ULONG Request;
    ULONG Processor;
} SYSDBG_CONTROL_SPACE, *PSYSDBG_CONTROL_SPACE;

enum _INTERFACE_TYPE;

typedef struct _SYSDBG_IO_SPACE
{
    ULONG64 Address;
    PVOID Buffer;
    ULONG Request;
    enum _INTERFACE_TYPE InterfaceType;
    ULONG BusNumber;
    ULONG AddressSpace;
} SYSDBG_IO_SPACE, *PSYSDBG_IO_SPACE;

typedef struct _SYSDBG_MSR
{
    ULONG Msr;
    ULONG64 Data;
} SYSDBG_MSR, *PSYSDBG_MSR;

enum _BUS_DATA_TYPE;

typedef struct _SYSDBG_BUS_DATA
{
    ULONG Address;
    PVOID Buffer;
    ULONG Request;
    enum _BUS_DATA_TYPE BusDataType;
    ULONG BusNumber;
    ULONG SlotNumber;
} SYSDBG_BUS_DATA, *PSYSDBG_BUS_DATA;

// private
typedef struct _SYSDBG_TRIAGE_DUMP
{
    ULONG Flags;
    ULONG BugCheckCode;
    ULONG_PTR BugCheckParam1;
    ULONG_PTR BugCheckParam2;
    ULONG_PTR BugCheckParam3;
    ULONG_PTR BugCheckParam4;
    ULONG ProcessHandles;
    ULONG ThreadHandles;
    PHANDLE Handles;
} SYSDBG_TRIAGE_DUMP, *PSYSDBG_TRIAGE_DUMP;

// private
typedef union _SYSDBG_LIVEDUMP_CONTROL_FLAGS
{
    struct
    {
        ULONG UseDumpStorageStack : 1;
        ULONG CompressMemoryPagesData : 1;
        ULONG IncludeUserSpaceMemoryPages : 1;
        ULONG AbortIfMemoryPressure : 1; // REDSTONE4
        ULONG Reserved : 28;
    };
    ULONG AsUlong;
} SYSDBG_LIVEDUMP_CONTROL_FLAGS, *PSYSDBG_LIVEDUMP_CONTROL_FLAGS;

// private
typedef union _SYSDBG_LIVEDUMP_CONTROL_ADDPAGES
{
    struct
    {
        ULONG HypervisorPages : 1;
        ULONG Reserved : 31;
    };
    ULONG AsUlong;
} SYSDBG_LIVEDUMP_CONTROL_ADDPAGES, *PSYSDBG_LIVEDUMP_CONTROL_ADDPAGES;

#define SYSDBG_LIVEDUMP_CONTROL_VERSION 1

// private
typedef struct _SYSDBG_LIVEDUMP_CONTROL
{
    ULONG Version;
    ULONG BugCheckCode;
    ULONG_PTR BugCheckParam1;
    ULONG_PTR BugCheckParam2;
    ULONG_PTR BugCheckParam3;
    ULONG_PTR BugCheckParam4;
    HANDLE DumpFileHandle;
    HANDLE CancelEventHandle;
    SYSDBG_LIVEDUMP_CONTROL_FLAGS Flags;
    SYSDBG_LIVEDUMP_CONTROL_ADDPAGES AddPagesControl;
} SYSDBG_LIVEDUMP_CONTROL, *PSYSDBG_LIVEDUMP_CONTROL;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSystemDebugControl(
    _In_ SYSDBG_COMMAND Command,
    _Inout_updates_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength,
    _Out_opt_ PULONG ReturnLength
    );

// Hard errors

typedef enum _HARDERROR_RESPONSE_OPTION
{
    OptionAbortRetryIgnore,
    OptionOk,
    OptionOkCancel,
    OptionRetryCancel,
    OptionYesNo,
    OptionYesNoCancel,
    OptionShutdownSystem,
    OptionOkNoWait,
    OptionCancelTryContinue
} HARDERROR_RESPONSE_OPTION;

typedef enum _HARDERROR_RESPONSE
{
    ResponseReturnToCaller,
    ResponseNotHandled,
    ResponseAbort,
    ResponseCancel,
    ResponseIgnore,
    ResponseNo,
    ResponseOk,
    ResponseRetry,
    ResponseYes,
    ResponseTryAgain,
    ResponseContinue
} HARDERROR_RESPONSE;

#define HARDERROR_OVERRIDE_ERRORMODE 0x10000000

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRaiseHardError(
    _In_ NTSTATUS ErrorStatus,
    _In_ ULONG NumberOfParameters,
    _In_ ULONG UnicodeStringParameterMask,
    _In_reads_(NumberOfParameters) PULONG_PTR Parameters,
    _In_ ULONG ValidResponseOptions,
    _Out_ PULONG Response
    );

// Kernel-user shared data

typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE
{
    StandardDesign,
    NEC98x86,
    EndAlternatives
} ALTERNATIVE_ARCHITECTURE_TYPE;

#define PROCESSOR_FEATURE_MAX 64

#define MAX_WOW64_SHARED_ENTRIES 16

#define NX_SUPPORT_POLICY_ALWAYSOFF 0
#define NX_SUPPORT_POLICY_ALWAYSON 1
#define NX_SUPPORT_POLICY_OPTIN 2
#define NX_SUPPORT_POLICY_OPTOUT 3

#include <pshpack4.h>
typedef struct _KUSER_SHARED_DATA
{
    ULONG TickCountLowDeprecated;
    ULONG TickCountMultiplier;

    volatile KSYSTEM_TIME InterruptTime;
    volatile KSYSTEM_TIME SystemTime;
    volatile KSYSTEM_TIME TimeZoneBias;

    USHORT ImageNumberLow;
    USHORT ImageNumberHigh;

    WCHAR NtSystemRoot[260];

    ULONG MaxStackTraceDepth;

    ULONG CryptoExponent;

    ULONG TimeZoneId;
    ULONG LargePageMinimum;
    ULONG AitSamplingValue;
    ULONG AppCompatFlag;
    ULONGLONG RNGSeedVersion;
    ULONG GlobalValidationRunlevel;
    LONG TimeZoneBiasStamp;

    ULONG NtBuildNumber;
    NT_PRODUCT_TYPE NtProductType;
    BOOLEAN ProductTypeIsValid;
    UCHAR Reserved0[1];
    USHORT NativeProcessorArchitecture;

    ULONG NtMajorVersion;
    ULONG NtMinorVersion;

    BOOLEAN ProcessorFeatures[PROCESSOR_FEATURE_MAX];

    ULONG Reserved1;
    ULONG Reserved3;

    volatile ULONG TimeSlip;

    ALTERNATIVE_ARCHITECTURE_TYPE AlternativeArchitecture;
    ULONG BootId;

    LARGE_INTEGER SystemExpirationDate;

    ULONG SuiteMask;

    BOOLEAN KdDebuggerEnabled;
    union
    {
        UCHAR MitigationPolicies;
        struct
        {
            UCHAR NXSupportPolicy : 2;
            UCHAR SEHValidationPolicy : 2;
            UCHAR CurDirDevicesSkippedForDlls : 2;
            UCHAR Reserved : 2;
        };
    };

    USHORT CyclesPerYield;

    volatile ULONG ActiveConsoleId;

    volatile ULONG DismountCount;

    ULONG ComPlusPackage;

    ULONG LastSystemRITEventTickCount;

    ULONG NumberOfPhysicalPages;

    BOOLEAN SafeBootMode;
    UCHAR VirtualizationFlags;
    UCHAR Reserved12[2];

    union
    {
        ULONG SharedDataFlags;
        struct
        {
            ULONG DbgErrorPortPresent : 1;
            ULONG DbgElevationEnabled : 1;
            ULONG DbgVirtEnabled : 1;
            ULONG DbgInstallerDetectEnabled : 1;
            ULONG DbgLkgEnabled : 1;
            ULONG DbgDynProcessorEnabled : 1;
            ULONG DbgConsoleBrokerEnabled : 1;
            ULONG DbgSecureBootEnabled : 1;
            ULONG DbgMultiSessionSku : 1;
            ULONG DbgMultiUsersInSessionSku : 1;
            ULONG DbgStateSeparationEnabled : 1;
            ULONG SpareBits : 21;
        };
    };
    ULONG DataFlagsPad[1];

    ULONGLONG TestRetInstruction;
    LONGLONG QpcFrequency;
    ULONG SystemCall;
    ULONG SystemCallPad0;
    ULONGLONG SystemCallPad[2];

    union
    {
        volatile KSYSTEM_TIME TickCount;
        volatile ULONG64 TickCountQuad;
        ULONG ReservedTickCountOverlay[3];
    };
    ULONG TickCountPad[1];

    ULONG Cookie;
    ULONG CookiePad[1];

    LONGLONG ConsoleSessionForegroundProcessId;
    ULONGLONG TimeUpdateLock;
    ULONGLONG BaselineSystemTimeQpc;
    ULONGLONG BaselineInterruptTimeQpc;
    ULONGLONG QpcSystemTimeIncrement;
    ULONGLONG QpcInterruptTimeIncrement;
    UCHAR QpcSystemTimeIncrementShift;
    UCHAR QpcInterruptTimeIncrementShift;

    USHORT UnparkedProcessorCount;
    ULONG EnclaveFeatureMask[4];

    ULONG TelemetryCoverageRound;

    USHORT UserModeGlobalLogger[16];
    ULONG ImageFileExecutionOptions;

    ULONG LangGenerationCount;
    ULONGLONG Reserved4;
    volatile ULONG64 InterruptTimeBias;
    volatile ULONG64 QpcBias;

    ULONG ActiveProcessorCount;
    volatile UCHAR ActiveGroupCount;
    UCHAR Reserved9;
    union
    {
        USHORT QpcData;
        struct
        {
            UCHAR QpcBypassEnabled : 1;
            UCHAR QpcShift : 1;
        };
    };

    LARGE_INTEGER TimeZoneBiasEffectiveStart;
    LARGE_INTEGER TimeZoneBiasEffectiveEnd;
    XSTATE_CONFIGURATION XState;
} KUSER_SHARED_DATA, *PKUSER_SHARED_DATA;
#include <poppack.h>

C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TickCountMultiplier) == 0x4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, InterruptTime) == 0x8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SystemTime) == 0x14);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NtSystemRoot) == 0x30);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, LargePageMinimum) == 0x244);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NtProductType) == 0x264);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NtMajorVersion) == 0x26c);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NtMinorVersion) == 0x270);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ProcessorFeatures) == 0x274);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, KdDebuggerEnabled) == 0x2d4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ActiveConsoleId) == 0x2d8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NumberOfPhysicalPages) == 0x2e8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SafeBootMode) == 0x2ec);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TickCount) == 0x320);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TickCountQuad) == 0x320);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, XState) == 0x3d8);
//C_ASSERT(sizeof(KUSER_SHARED_DATA) == 0x70C); // VS2017 has some weird issue with this.

#define USER_SHARED_DATA ((KUSER_SHARED_DATA * const)0x7ffe0000)

#if (PHNT_VERSION >= PHNT_WS03)

FORCEINLINE ULONGLONG NtGetTickCount64()
{
    ULARGE_INTEGER tickCount;

#ifdef _WIN64

    tickCount.QuadPart = USER_SHARED_DATA->TickCountQuad;

#else

    while (TRUE)
    {
        tickCount.HighPart = (ULONG)USER_SHARED_DATA->TickCount.High1Time;
        tickCount.LowPart = USER_SHARED_DATA->TickCount.LowPart;

        if (tickCount.HighPart == (ULONG)USER_SHARED_DATA->TickCount.High2Time)
            break;

        YieldProcessor();
    }

#endif

    return (UInt32x32To64(tickCount.LowPart, USER_SHARED_DATA->TickCountMultiplier) >> 24) +
        (UInt32x32To64(tickCount.HighPart, USER_SHARED_DATA->TickCountMultiplier) << 8);
}

FORCEINLINE ULONG NtGetTickCount()
{
#ifdef _WIN64

    return (ULONG)((USER_SHARED_DATA->TickCountQuad * USER_SHARED_DATA->TickCountMultiplier) >> 24);

#else

    ULARGE_INTEGER tickCount;

    while (TRUE)
    {
        tickCount.HighPart = (ULONG)USER_SHARED_DATA->TickCount.High1Time;
        tickCount.LowPart = USER_SHARED_DATA->TickCount.LowPart;

        if (tickCount.HighPart == (ULONG)USER_SHARED_DATA->TickCount.High2Time)
            break;

        YieldProcessor();
    }

    return (ULONG)((UInt32x32To64(tickCount.LowPart, USER_SHARED_DATA->TickCountMultiplier) >> 24) +
        UInt32x32To64((tickCount.HighPart << 8) & 0xffffffff, USER_SHARED_DATA->TickCountMultiplier));

#endif
}

#endif

// Locale

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryDefaultLocale(
    _In_ BOOLEAN UserProfile,
    _Out_ PLCID DefaultLocaleId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetDefaultLocale(
    _In_ BOOLEAN UserProfile,
    _In_ LCID DefaultLocaleId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInstallUILanguage(
    _Out_ LANGID *InstallUILanguageId
    );

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSCALLAPI
NTSTATUS
NTAPI
NtFlushInstallUILanguage(
    _In_ LANGID InstallUILanguage,
    _In_ ULONG SetComittedFlag
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryDefaultUILanguage(
    _Out_ LANGID *DefaultUILanguageId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetDefaultUILanguage(
    _In_ LANGID DefaultUILanguageId
    );

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSCALLAPI
NTSTATUS
NTAPI
NtIsUILanguageComitted(
    VOID
    );
#endif

// NLS

// begin_private

#if (PHNT_VERSION >= PHNT_VISTA)

#if (PHNT_VERSION >= PHNT_WIN7)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtInitializeNlsFiles(
    _Out_ PVOID *BaseAddress,
    _Out_ PLCID DefaultLocaleId,
    _Out_ PLARGE_INTEGER DefaultCasingTableSize
    );
#else
NTSYSCALLAPI
NTSTATUS
NTAPI
NtInitializeNlsFiles(
    _Out_ PVOID *BaseAddress,
    _Out_ PLCID DefaultLocaleId,
    _Out_ PLARGE_INTEGER DefaultCasingTableSize,
    _Out_opt_ PULONG CurrentNLSVersion
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtGetNlsSectionPtr(
    _In_ ULONG SectionType,
    _In_ ULONG SectionData,
    _In_ PVOID ContextData,
    _Out_ PVOID *SectionPointer,
    _Out_ PULONG SectionSize
    );

#if (PHNT_VERSION < PHNT_WIN7)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAcquireCMFViewOwnership(
    _Out_ PULONGLONG TimeStamp,
    _Out_ PBOOLEAN tokenTaken,
    _In_ BOOLEAN replaceExisting
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReleaseCMFViewOwnership(
    VOID
    );

#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtMapCMFModule(
    _In_ ULONG What,
    _In_ ULONG Index,
    _Out_opt_ PULONG CacheIndexOut,
    _Out_opt_ PULONG CacheFlagsOut,
    _Out_opt_ PULONG ViewSizeOut,
    _Out_opt_ PVOID *BaseAddress
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtGetMUIRegistryInfo(
    _In_ ULONG Flags,
    _Inout_ PULONG DataSize,
    _Out_ PVOID Data
    );

#endif

// end_private

// Global atoms

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAddAtom(
    _In_reads_bytes_opt_(Length) PWSTR AtomName,
    _In_ ULONG Length,
    _Out_opt_ PRTL_ATOM Atom
    );

#if (PHNT_VERSION >= PHNT_WIN8)

#define ATOM_FLAG_GLOBAL 0x2

// rev
NTSYSCALLAPI
NTSTATUS
NTAPI
NtAddAtomEx(
    _In_reads_bytes_opt_(Length) PWSTR AtomName,
    _In_ ULONG Length,
    _Out_opt_ PRTL_ATOM Atom,
    _In_ ULONG Flags
    );

#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFindAtom(
    _In_reads_bytes_opt_(Length) PWSTR AtomName,
    _In_ ULONG Length,
    _Out_opt_ PRTL_ATOM Atom
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeleteAtom(
    _In_ RTL_ATOM Atom
    );

typedef enum _ATOM_INFORMATION_CLASS
{
    AtomBasicInformation,
    AtomTableInformation
} ATOM_INFORMATION_CLASS;

typedef struct _ATOM_BASIC_INFORMATION
{
    USHORT UsageCount;
    USHORT Flags;
    USHORT NameLength;
    WCHAR Name[1];
} ATOM_BASIC_INFORMATION, *PATOM_BASIC_INFORMATION;

typedef struct _ATOM_TABLE_INFORMATION
{
    ULONG NumberOfAtoms;
    RTL_ATOM Atoms[1];
} ATOM_TABLE_INFORMATION, *PATOM_TABLE_INFORMATION;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationAtom(
    _In_ RTL_ATOM Atom,
    _In_ ATOM_INFORMATION_CLASS AtomInformationClass,
    _Out_writes_bytes_(AtomInformationLength) PVOID AtomInformation,
    _In_ ULONG AtomInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

// Global flags

#define FLG_STOP_ON_EXCEPTION 0x00000001 // uk
#define FLG_SHOW_LDR_SNAPS 0x00000002 // uk
#define FLG_DEBUG_INITIAL_COMMAND 0x00000004 // k
#define FLG_STOP_ON_HUNG_GUI 0x00000008 // k

#define FLG_HEAP_ENABLE_TAIL_CHECK 0x00000010 // u
#define FLG_HEAP_ENABLE_FREE_CHECK 0x00000020 // u
#define FLG_HEAP_VALIDATE_PARAMETERS 0x00000040 // u
#define FLG_HEAP_VALIDATE_ALL 0x00000080 // u

#define FLG_APPLICATION_VERIFIER 0x00000100 // u
#define FLG_POOL_ENABLE_TAGGING 0x00000400 // k
#define FLG_HEAP_ENABLE_TAGGING 0x00000800 // u

#define FLG_USER_STACK_TRACE_DB 0x00001000 // u,32
#define FLG_KERNEL_STACK_TRACE_DB 0x00002000 // k,32
#define FLG_MAINTAIN_OBJECT_TYPELIST 0x00004000 // k
#define FLG_HEAP_ENABLE_TAG_BY_DLL 0x00008000 // u

#define FLG_DISABLE_STACK_EXTENSION 0x00010000 // u
#define FLG_ENABLE_CSRDEBUG 0x00020000 // k
#define FLG_ENABLE_KDEBUG_SYMBOL_LOAD 0x00040000 // k
#define FLG_DISABLE_PAGE_KERNEL_STACKS 0x00080000 // k

#define FLG_ENABLE_SYSTEM_CRIT_BREAKS 0x00100000 // u
#define FLG_HEAP_DISABLE_COALESCING 0x00200000 // u
#define FLG_ENABLE_CLOSE_EXCEPTIONS 0x00400000 // k
#define FLG_ENABLE_EXCEPTION_LOGGING 0x00800000 // k

#define FLG_ENABLE_HANDLE_TYPE_TAGGING 0x01000000 // k
#define FLG_HEAP_PAGE_ALLOCS 0x02000000 // u
#define FLG_DEBUG_INITIAL_COMMAND_EX 0x04000000 // k
#define FLG_DISABLE_DBGPRINT 0x08000000 // k

#define FLG_CRITSEC_EVENT_CREATION 0x10000000 // u
#define FLG_LDR_TOP_DOWN 0x20000000 // u,64
#define FLG_ENABLE_HANDLE_EXCEPTIONS 0x40000000 // k
#define FLG_DISABLE_PROTDLLS 0x80000000 // u

#define FLG_VALID_BITS 0xfffffdff

#define FLG_USERMODE_VALID_BITS (FLG_STOP_ON_EXCEPTION | \
    FLG_SHOW_LDR_SNAPS | \
    FLG_HEAP_ENABLE_TAIL_CHECK | \
    FLG_HEAP_ENABLE_FREE_CHECK | \
    FLG_HEAP_VALIDATE_PARAMETERS | \
    FLG_HEAP_VALIDATE_ALL | \
    FLG_APPLICATION_VERIFIER | \
    FLG_HEAP_ENABLE_TAGGING | \
    FLG_USER_STACK_TRACE_DB | \
    FLG_HEAP_ENABLE_TAG_BY_DLL | \
    FLG_DISABLE_STACK_EXTENSION | \
    FLG_ENABLE_SYSTEM_CRIT_BREAKS | \
    FLG_HEAP_DISABLE_COALESCING | \
    FLG_DISABLE_PROTDLLS | \
    FLG_HEAP_PAGE_ALLOCS | \
    FLG_CRITSEC_EVENT_CREATION | \
    FLG_LDR_TOP_DOWN)

#define FLG_BOOTONLY_VALID_BITS (FLG_KERNEL_STACK_TRACE_DB | \
    FLG_MAINTAIN_OBJECT_TYPELIST | \
    FLG_ENABLE_CSRDEBUG | \
    FLG_DEBUG_INITIAL_COMMAND | \
    FLG_DEBUG_INITIAL_COMMAND_EX | \
    FLG_DISABLE_PAGE_KERNEL_STACKS)

#define FLG_KERNELMODE_VALID_BITS (FLG_STOP_ON_EXCEPTION | \
    FLG_SHOW_LDR_SNAPS | \
    FLG_STOP_ON_HUNG_GUI | \
    FLG_POOL_ENABLE_TAGGING | \
    FLG_ENABLE_KDEBUG_SYMBOL_LOAD | \
    FLG_ENABLE_CLOSE_EXCEPTIONS | \
    FLG_ENABLE_EXCEPTION_LOGGING | \
    FLG_ENABLE_HANDLE_TYPE_TAGGING | \
    FLG_DISABLE_DBGPRINT | \
    FLG_ENABLE_HANDLE_EXCEPTIONS)

// Licensing

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryLicenseValue(
    _In_ PUNICODE_STRING ValueName,
    _Out_opt_ PULONG Type,
    _Out_writes_bytes_to_opt_(DataSize, *ResultDataSize) PVOID Data,
    _In_ ULONG DataSize,
    _Out_ PULONG ResultDataSize
    );

// Misc.

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetDefaultHardErrorPort(
    _In_ HANDLE DefaultHardErrorPort
    );

typedef enum _SHUTDOWN_ACTION
{
    ShutdownNoReboot,
    ShutdownReboot,
    ShutdownPowerOff
} SHUTDOWN_ACTION;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtShutdownSystem(
    _In_ SHUTDOWN_ACTION Action
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDisplayString(
    _In_ PUNICODE_STRING String
    );

// Boot graphics

#if (PHNT_VERSION >= PHNT_WIN7)
// rev
NTSYSCALLAPI
NTSTATUS
NTAPI
NtDrawText(
    _In_ PUNICODE_STRING Text
    );
#endif

#endif // (PHNT_MODE != PHNT_MODE_KERNEL)

#endif

```

`phnt/ntgdi.h`:

```h
/*
 * Process Hacker -
 *   Graphics device interface support
 *
 * This file is part of Process Hacker.
 *
 * Process Hacker is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Process Hacker is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Process Hacker.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef _NTGDI_H
#define _NTGDI_H

#define GDI_MAX_HANDLE_COUNT 0x4000

#define GDI_HANDLE_INDEX_SHIFT 0
#define GDI_HANDLE_INDEX_BITS 16
#define GDI_HANDLE_INDEX_MASK 0xffff

#define GDI_HANDLE_TYPE_SHIFT 16
#define GDI_HANDLE_TYPE_BITS 5
#define GDI_HANDLE_TYPE_MASK 0x1f

#define GDI_HANDLE_ALTTYPE_SHIFT 21
#define GDI_HANDLE_ALTTYPE_BITS 2
#define GDI_HANDLE_ALTTYPE_MASK 0x3

#define GDI_HANDLE_STOCK_SHIFT 23
#define GDI_HANDLE_STOCK_BITS 1
#define GDI_HANDLE_STOCK_MASK 0x1

#define GDI_HANDLE_UNIQUE_SHIFT 24
#define GDI_HANDLE_UNIQUE_BITS 8
#define GDI_HANDLE_UNIQUE_MASK 0xff

#define GDI_HANDLE_INDEX(Handle) ((ULONG)(Handle) & GDI_HANDLE_INDEX_MASK)
#define GDI_HANDLE_TYPE(Handle) (((ULONG)(Handle) >> GDI_HANDLE_TYPE_SHIFT) & GDI_HANDLE_TYPE_MASK)
#define GDI_HANDLE_ALTTYPE(Handle) (((ULONG)(Handle) >> GDI_HANDLE_ALTTYPE_SHIFT) & GDI_HANDLE_ALTTYPE_MASK)
#define GDI_HANDLE_STOCK(Handle) (((ULONG)(Handle) >> GDI_HANDLE_STOCK_SHIFT)) & GDI_HANDLE_STOCK_MASK)

#define GDI_MAKE_HANDLE(Index, Unique) ((ULONG)(((ULONG)(Unique) << GDI_HANDLE_INDEX_BITS) | (ULONG)(Index)))

// GDI server-side types

#define GDI_DEF_TYPE 0 // invalid handle
#define GDI_DC_TYPE 1
#define GDI_DD_DIRECTDRAW_TYPE 2
#define GDI_DD_SURFACE_TYPE 3
#define GDI_RGN_TYPE 4
#define GDI_SURF_TYPE 5
#define GDI_CLIENTOBJ_TYPE 6
#define GDI_PATH_TYPE 7
#define GDI_PAL_TYPE 8
#define GDI_ICMLCS_TYPE 9
#define GDI_LFONT_TYPE 10
#define GDI_RFONT_TYPE 11
#define GDI_PFE_TYPE 12
#define GDI_PFT_TYPE 13
#define GDI_ICMCXF_TYPE 14
#define GDI_ICMDLL_TYPE 15
#define GDI_BRUSH_TYPE 16
#define GDI_PFF_TYPE 17 // unused
#define GDI_CACHE_TYPE 18 // unused
#define GDI_SPACE_TYPE 19
#define GDI_DBRUSH_TYPE 20 // unused
#define GDI_META_TYPE 21
#define GDI_EFSTATE_TYPE 22
#define GDI_BMFD_TYPE 23 // unused
#define GDI_VTFD_TYPE 24 // unused
#define GDI_TTFD_TYPE 25 // unused
#define GDI_RC_TYPE 26 // unused
#define GDI_TEMP_TYPE 27 // unused
#define GDI_DRVOBJ_TYPE 28
#define GDI_DCIOBJ_TYPE 29 // unused
#define GDI_SPOOL_TYPE 30

// GDI client-side types

#define GDI_CLIENT_TYPE_FROM_HANDLE(Handle) ((ULONG)(Handle) & ((GDI_HANDLE_ALTTYPE_MASK << GDI_HANDLE_ALTTYPE_SHIFT) | \
    (GDI_HANDLE_TYPE_MASK << GDI_HANDLE_TYPE_SHIFT)))
#define GDI_CLIENT_TYPE_FROM_UNIQUE(Unique) GDI_CLIENT_TYPE_FROM_HANDLE((ULONG)(Unique) << 16)

#define GDI_ALTTYPE_1 (1 << GDI_HANDLE_ALTTYPE_SHIFT)
#define GDI_ALTTYPE_2 (2 << GDI_HANDLE_ALTTYPE_SHIFT)
#define GDI_ALTTYPE_3 (3 << GDI_HANDLE_ALTTYPE_SHIFT)

#define GDI_CLIENT_BITMAP_TYPE (GDI_SURF_TYPE << GDI_HANDLE_TYPE_SHIFT)
#define GDI_CLIENT_BRUSH_TYPE (GDI_BRUSH_TYPE << GDI_HANDLE_TYPE_SHIFT)
#define GDI_CLIENT_CLIENTOBJ_TYPE (GDI_CLIENTOBJ_TYPE << GDI_HANDLE_TYPE_SHIFT)
#define GDI_CLIENT_DC_TYPE (GDI_DC_TYPE << GDI_HANDLE_TYPE_SHIFT)
#define GDI_CLIENT_FONT_TYPE (GDI_LFONT_TYPE << GDI_HANDLE_TYPE_SHIFT)
#define GDI_CLIENT_PALETTE_TYPE (GDI_PAL_TYPE << GDI_HANDLE_TYPE_SHIFT)
#define GDI_CLIENT_REGION_TYPE (GDI_RGN_TYPE << GDI_HANDLE_TYPE_SHIFT)

#define GDI_CLIENT_ALTDC_TYPE (GDI_CLIENT_DC_TYPE | GDI_ALTTYPE_1)
#define GDI_CLIENT_DIBSECTION_TYPE (GDI_CLIENT_BITMAP_TYPE | GDI_ALTTYPE_1)
#define GDI_CLIENT_EXTPEN_TYPE (GDI_CLIENT_BRUSH_TYPE | GDI_ALTTYPE_2)
#define GDI_CLIENT_METADC16_TYPE (GDI_CLIENT_CLIENTOBJ_TYPE | GDI_ALTTYPE_3)
#define GDI_CLIENT_METAFILE_TYPE (GDI_CLIENT_CLIENTOBJ_TYPE | GDI_ALTTYPE_2)
#define GDI_CLIENT_METAFILE16_TYPE (GDI_CLIENT_CLIENTOBJ_TYPE | GDI_ALTTYPE_1)
#define GDI_CLIENT_PEN_TYPE (GDI_CLIENT_BRUSH_TYPE | GDI_ALTTYPE_1)

typedef struct _GDI_HANDLE_ENTRY
{
    union
    {
        PVOID Object;
        PVOID NextFree;
    };
    union
    {
        struct
        {
            USHORT ProcessId;
            USHORT Lock : 1;
            USHORT Count : 15;
        };
        ULONG Value;
    } Owner;
    USHORT Unique;
    UCHAR Type;
    UCHAR Flags;
    PVOID UserPointer;
} GDI_HANDLE_ENTRY, *PGDI_HANDLE_ENTRY;

typedef struct _GDI_SHARED_MEMORY
{
    GDI_HANDLE_ENTRY Handles[GDI_MAX_HANDLE_COUNT];
} GDI_SHARED_MEMORY, *PGDI_SHARED_MEMORY;

#endif

```

`phnt/ntioapi.h`:

```h
/*
 * Process Hacker -
 *   File management support
 *
 * This file is part of Process Hacker.
 *
 * Process Hacker is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Process Hacker is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Process Hacker.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef _NTIOAPI_H
#define _NTIOAPI_H

// Create disposition

#define FILE_SUPERSEDE 0x00000000
#define FILE_OPEN 0x00000001
#define FILE_CREATE 0x00000002
#define FILE_OPEN_IF 0x00000003
#define FILE_OVERWRITE 0x00000004
#define FILE_OVERWRITE_IF 0x00000005
#define FILE_MAXIMUM_DISPOSITION 0x00000005

// Create/open flags

#define FILE_DIRECTORY_FILE 0x00000001
#define FILE_WRITE_THROUGH 0x00000002
#define FILE_SEQUENTIAL_ONLY 0x00000004
#define FILE_NO_INTERMEDIATE_BUFFERING 0x00000008

#define FILE_SYNCHRONOUS_IO_ALERT 0x00000010
#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020
#define FILE_NON_DIRECTORY_FILE 0x00000040
#define FILE_CREATE_TREE_CONNECTION 0x00000080

#define FILE_COMPLETE_IF_OPLOCKED 0x00000100
#define FILE_NO_EA_KNOWLEDGE 0x00000200
#define FILE_OPEN_FOR_RECOVERY 0x00000400
#define FILE_RANDOM_ACCESS 0x00000800

#define FILE_DELETE_ON_CLOSE 0x00001000
#define FILE_OPEN_BY_FILE_ID 0x00002000
#define FILE_OPEN_FOR_BACKUP_INTENT 0x00004000
#define FILE_NO_COMPRESSION 0x00008000
#if (PHNT_VERSION >= PHNT_WIN7)
#define FILE_OPEN_REQUIRING_OPLOCK 0x00010000
#define FILE_DISALLOW_EXCLUSIVE 0x00020000
#endif
#if (PHNT_VERSION >= PHNT_WIN8)
#define FILE_SESSION_AWARE 0x00040000
#endif

#define FILE_RESERVE_OPFILTER 0x00100000
#define FILE_OPEN_REPARSE_POINT 0x00200000
#define FILE_OPEN_NO_RECALL 0x00400000
#define FILE_OPEN_FOR_FREE_SPACE_QUERY 0x00800000

#define FILE_COPY_STRUCTURED_STORAGE 0x00000041
#define FILE_STRUCTURED_STORAGE 0x00000441

// I/O status information values for NtCreateFile/NtOpenFile

#define FILE_SUPERSEDED 0x00000000
#define FILE_OPENED 0x00000001
#define FILE_CREATED 0x00000002
#define FILE_OVERWRITTEN 0x00000003
#define FILE_EXISTS 0x00000004
#define FILE_DOES_NOT_EXIST 0x00000005

// Special ByteOffset parameters

#define FILE_WRITE_TO_END_OF_FILE 0xffffffff
#define FILE_USE_FILE_POINTER_POSITION 0xfffffffe

// Alignment requirement values

#define FILE_BYTE_ALIGNMENT 0x00000000
#define FILE_WORD_ALIGNMENT 0x00000001
#define FILE_LONG_ALIGNMENT 0x00000003
#define FILE_QUAD_ALIGNMENT 0x00000007
#define FILE_OCTA_ALIGNMENT 0x0000000f
#define FILE_32_BYTE_ALIGNMENT 0x0000001f
#define FILE_64_BYTE_ALIGNMENT 0x0000003f
#define FILE_128_BYTE_ALIGNMENT 0x0000007f
#define FILE_256_BYTE_ALIGNMENT 0x000000ff
#define FILE_512_BYTE_ALIGNMENT 0x000001ff

// Maximum length of a filename string

#define MAXIMUM_FILENAME_LENGTH 256

// Extended attributes

#define FILE_NEED_EA 0x00000080

#define FILE_EA_TYPE_BINARY 0xfffe
#define FILE_EA_TYPE_ASCII 0xfffd
#define FILE_EA_TYPE_BITMAP 0xfffb
#define FILE_EA_TYPE_METAFILE 0xfffa
#define FILE_EA_TYPE_ICON 0xfff9
#define FILE_EA_TYPE_EA 0xffee
#define FILE_EA_TYPE_MVMT 0xffdf
#define FILE_EA_TYPE_MVST 0xffde
#define FILE_EA_TYPE_ASN1 0xffdd
#define FILE_EA_TYPE_FAMILY_IDS 0xff01

// Device characteristics

#define FILE_REMOVABLE_MEDIA 0x00000001
#define FILE_READ_ONLY_DEVICE 0x00000002
#define FILE_FLOPPY_DISKETTE 0x00000004
#define FILE_WRITE_ONCE_MEDIA 0x00000008
#define FILE_REMOTE_DEVICE 0x00000010
#define FILE_DEVICE_IS_MOUNTED 0x00000020
#define FILE_VIRTUAL_VOLUME 0x00000040
#define FILE_AUTOGENERATED_DEVICE_NAME 0x00000080
#define FILE_DEVICE_SECURE_OPEN 0x00000100
#define FILE_CHARACTERISTIC_PNP_DEVICE 0x00000800
#define FILE_CHARACTERISTIC_TS_DEVICE 0x00001000
#define FILE_CHARACTERISTIC_WEBDAV_DEVICE 0x00002000
#define FILE_CHARACTERISTIC_CSV 0x00010000
#define FILE_DEVICE_ALLOW_APPCONTAINER_TRAVERSAL 0x00020000
#define FILE_PORTABLE_DEVICE 0x00040000

// Named pipe values

// NamedPipeType for NtCreateNamedPipeFile
#define FILE_PIPE_BYTE_STREAM_TYPE 0x00000000
#define FILE_PIPE_MESSAGE_TYPE 0x00000001
#define FILE_PIPE_ACCEPT_REMOTE_CLIENTS 0x00000000
#define FILE_PIPE_REJECT_REMOTE_CLIENTS 0x00000002
#define FILE_PIPE_TYPE_VALID_MASK 0x00000003

// CompletionMode for NtCreateNamedPipeFile
#define FILE_PIPE_QUEUE_OPERATION 0x00000000
#define FILE_PIPE_COMPLETE_OPERATION 0x00000001

// ReadMode for NtCreateNamedPipeFile
#define FILE_PIPE_BYTE_STREAM_MODE 0x00000000
#define FILE_PIPE_MESSAGE_MODE 0x00000001

// NamedPipeConfiguration for NtQueryInformationFile
#define FILE_PIPE_INBOUND 0x00000000
#define FILE_PIPE_OUTBOUND 0x00000001
#define FILE_PIPE_FULL_DUPLEX 0x00000002

// NamedPipeState for NtQueryInformationFile
#define FILE_PIPE_DISCONNECTED_STATE 0x00000001
#define FILE_PIPE_LISTENING_STATE 0x00000002
#define FILE_PIPE_CONNECTED_STATE 0x00000003
#define FILE_PIPE_CLOSING_STATE 0x00000004

// NamedPipeEnd for NtQueryInformationFile
#define FILE_PIPE_CLIENT_END 0x00000000
#define FILE_PIPE_SERVER_END 0x00000001

// Mailslot values

#define MAILSLOT_SIZE_AUTO 0

typedef struct _IO_STATUS_BLOCK
{
    union
    {
        NTSTATUS Status;
        PVOID Pointer;
    };
    ULONG_PTR Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

typedef VOID (NTAPI *PIO_APC_ROUTINE)(
    _In_ PVOID ApcContext,
    _In_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG Reserved
    );

// private
typedef struct _FILE_IO_COMPLETION_INFORMATION
{
    PVOID KeyContext;
    PVOID ApcContext;
    IO_STATUS_BLOCK IoStatusBlock;
} FILE_IO_COMPLETION_INFORMATION, *PFILE_IO_COMPLETION_INFORMATION;

typedef enum _FILE_INFORMATION_CLASS
{
    FileDirectoryInformation = 1, // FILE_DIRECTORY_INFORMATION
    FileFullDirectoryInformation, // FILE_FULL_DIR_INFORMATION
    FileBothDirectoryInformation, // FILE_BOTH_DIR_INFORMATION
    FileBasicInformation, // FILE_BASIC_INFORMATION
    FileStandardInformation, // FILE_STANDARD_INFORMATION
    FileInternalInformation, // FILE_INTERNAL_INFORMATION
    FileEaInformation, // FILE_EA_INFORMATION
    FileAccessInformation, // FILE_ACCESS_INFORMATION
    FileNameInformation, // FILE_NAME_INFORMATION
    FileRenameInformation, // FILE_RENAME_INFORMATION // 10
    FileLinkInformation, // FILE_LINK_INFORMATION
    FileNamesInformation, // FILE_NAMES_INFORMATION
    FileDispositionInformation, // FILE_DISPOSITION_INFORMATION
    FilePositionInformation, // FILE_POSITION_INFORMATION
    FileFullEaInformation, // FILE_FULL_EA_INFORMATION
    FileModeInformation, // FILE_MODE_INFORMATION
    FileAlignmentInformation, // FILE_ALIGNMENT_INFORMATION
    FileAllInformation, // FILE_ALL_INFORMATION
    FileAllocationInformation, // FILE_ALLOCATION_INFORMATION
    FileEndOfFileInformation, // FILE_END_OF_FILE_INFORMATION // 20
    FileAlternateNameInformation, // FILE_NAME_INFORMATION
    FileStreamInformation, // FILE_STREAM_INFORMATION
    FilePipeInformation, // FILE_PIPE_INFORMATION
    FilePipeLocalInformation, // FILE_PIPE_LOCAL_INFORMATION
    FilePipeRemoteInformation, // FILE_PIPE_REMOTE_INFORMATION
    FileMailslotQueryInformation, // FILE_MAILSLOT_QUERY_INFORMATION
    FileMailslotSetInformation, // FILE_MAILSLOT_SET_INFORMATION
    FileCompressionInformation, // FILE_COMPRESSION_INFORMATION
    FileObjectIdInformation, // FILE_OBJECTID_INFORMATION
    FileCompletionInformation, // FILE_COMPLETION_INFORMATION // 30
    FileMoveClusterInformation, // FILE_MOVE_CLUSTER_INFORMATION
    FileQuotaInformation, // FILE_QUOTA_INFORMATION
    FileReparsePointInformation, // FILE_REPARSE_POINT_INFORMATION
    FileNetworkOpenInformation, // FILE_NETWORK_OPEN_INFORMATION
    FileAttributeTagInformation, // FILE_ATTRIBUTE_TAG_INFORMATION
    FileTrackingInformation, // FILE_TRACKING_INFORMATION
    FileIdBothDirectoryInformation, // FILE_ID_BOTH_DIR_INFORMATION
    FileIdFullDirectoryInformation, // FILE_ID_FULL_DIR_INFORMATION
    FileValidDataLengthInformation, // FILE_VALID_DATA_LENGTH_INFORMATION
    FileShortNameInformation, // FILE_NAME_INFORMATION // 40
    FileIoCompletionNotificationInformation, // FILE_IO_COMPLETION_NOTIFICATION_INFORMATION // since VISTA
    FileIoStatusBlockRangeInformation, // FILE_IOSTATUSBLOCK_RANGE_INFORMATION
    FileIoPriorityHintInformation, // FILE_IO_PRIORITY_HINT_INFORMATION
    FileSfioReserveInformation, // FILE_SFIO_RESERVE_INFORMATION
    FileSfioVolumeInformation, // FILE_SFIO_VOLUME_INFORMATION
    FileHardLinkInformation, // FILE_LINKS_INFORMATION
    FileProcessIdsUsingFileInformation, // FILE_PROCESS_IDS_USING_FILE_INFORMATION
    FileNormalizedNameInformation, // FILE_NAME_INFORMATION
    FileNetworkPhysicalNameInformation, // FILE_NETWORK_PHYSICAL_NAME_INFORMATION
    FileIdGlobalTxDirectoryInformation, // FILE_ID_GLOBAL_TX_DIR_INFORMATION // since WIN7 // 50
    FileIsRemoteDeviceInformation, // FILE_IS_REMOTE_DEVICE_INFORMATION
    FileUnusedInformation,
    FileNumaNodeInformation, // FILE_NUMA_NODE_INFORMATION
    FileStandardLinkInformation, // FILE_STANDARD_LINK_INFORMATION
    FileRemoteProtocolInformation, // FILE_REMOTE_PROTOCOL_INFORMATION
    FileRenameInformationBypassAccessCheck, // (kernel-mode only); FILE_RENAME_INFORMATION // since WIN8
    FileLinkInformationBypassAccessCheck, // (kernel-mode only); FILE_LINK_INFORMATION
    FileVolumeNameInformation, // FILE_VOLUME_NAME_INFORMATION
    FileIdInformation, // FILE_ID_INFORMATION
    FileIdExtdDirectoryInformation, // FILE_ID_EXTD_DIR_INFORMATION // 60
    FileReplaceCompletionInformation, // FILE_COMPLETION_INFORMATION // since WINBLUE
    FileHardLinkFullIdInformation, // FILE_LINK_ENTRY_FULL_ID_INFORMATION
    FileIdExtdBothDirectoryInformation, // FILE_ID_EXTD_BOTH_DIR_INFORMATION // since THRESHOLD
    FileDispositionInformationEx, // FILE_DISPOSITION_INFO_EX // since REDSTONE
    FileRenameInformationEx, // FILE_RENAME_INFORMATION_EX
    FileRenameInformationExBypassAccessCheck, // (kernel-mode only); FILE_RENAME_INFORMATION_EX
    FileDesiredStorageClassInformation, // FILE_DESIRED_STORAGE_CLASS_INFORMATION // since REDSTONE2
    FileStatInformation, // FILE_STAT_INFORMATION
    FileMemoryPartitionInformation, // FILE_MEMORY_PARTITION_INFORMATION // since REDSTONE3
    FileStatLxInformation, // FILE_STAT_LX_INFORMATION // since REDSTONE4 // 70
    FileCaseSensitiveInformation, // FILE_CASE_SENSITIVE_INFORMATION
    FileLinkInformationEx, // FILE_LINK_INFORMATION_EX // since REDSTONE5
    FileLinkInformationExBypassAccessCheck, // (kernel-mode only); FILE_LINK_INFORMATION_EX
    FileStorageReserveIdInformation, // FILE_SET_STORAGE_RESERVE_ID_INFORMATION
    FileCaseSensitiveInformationForceAccessCheck, // FILE_CASE_SENSITIVE_INFORMATION
    FileMaximumInformation
} FILE_INFORMATION_CLASS, *PFILE_INFORMATION_CLASS;

// NtQueryInformationFile/NtSetInformationFile types

typedef struct _FILE_BASIC_INFORMATION
{
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    ULONG FileAttributes;
} FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;

typedef struct _FILE_STANDARD_INFORMATION
{
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG NumberOfLinks;
    BOOLEAN DeletePending;
    BOOLEAN Directory;
} FILE_STANDARD_INFORMATION, *PFILE_STANDARD_INFORMATION;

typedef struct _FILE_STANDARD_INFORMATION_EX
{
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG NumberOfLinks;
    BOOLEAN DeletePending;
    BOOLEAN Directory;
    BOOLEAN AlternateStream;
    BOOLEAN MetadataAttribute;
} FILE_STANDARD_INFORMATION_EX, *PFILE_STANDARD_INFORMATION_EX;

typedef struct _FILE_INTERNAL_INFORMATION
{
    LARGE_INTEGER IndexNumber;
} FILE_INTERNAL_INFORMATION, *PFILE_INTERNAL_INFORMATION;

typedef struct _FILE_EA_INFORMATION
{
    ULONG EaSize;
} FILE_EA_INFORMATION, *PFILE_EA_INFORMATION;

typedef struct _FILE_ACCESS_INFORMATION
{
    ACCESS_MASK AccessFlags;
} FILE_ACCESS_INFORMATION, *PFILE_ACCESS_INFORMATION;

typedef struct _FILE_POSITION_INFORMATION
{
    LARGE_INTEGER CurrentByteOffset;
} FILE_POSITION_INFORMATION, *PFILE_POSITION_INFORMATION;

typedef struct _FILE_MODE_INFORMATION
{
    ULONG Mode;
} FILE_MODE_INFORMATION, *PFILE_MODE_INFORMATION;

typedef struct _FILE_ALIGNMENT_INFORMATION
{
    ULONG AlignmentRequirement;
} FILE_ALIGNMENT_INFORMATION, *PFILE_ALIGNMENT_INFORMATION;

typedef struct _FILE_NAME_INFORMATION
{
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_NAME_INFORMATION, *PFILE_NAME_INFORMATION;

typedef struct _FILE_ALL_INFORMATION
{
    FILE_BASIC_INFORMATION BasicInformation;
    FILE_STANDARD_INFORMATION StandardInformation;
    FILE_INTERNAL_INFORMATION InternalInformation;
    FILE_EA_INFORMATION EaInformation;
    FILE_ACCESS_INFORMATION AccessInformation;
    FILE_POSITION_INFORMATION PositionInformation;
    FILE_MODE_INFORMATION ModeInformation;
    FILE_ALIGNMENT_INFORMATION AlignmentInformation;
    FILE_NAME_INFORMATION NameInformation;
} FILE_ALL_INFORMATION, *PFILE_ALL_INFORMATION;

typedef struct _FILE_NETWORK_OPEN_INFORMATION
{
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG FileAttributes;
} FILE_NETWORK_OPEN_INFORMATION, *PFILE_NETWORK_OPEN_INFORMATION;

typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION
{
    ULONG FileAttributes;
    ULONG ReparseTag;
} FILE_ATTRIBUTE_TAG_INFORMATION, *PFILE_ATTRIBUTE_TAG_INFORMATION;

typedef struct _FILE_ALLOCATION_INFORMATION
{
    LARGE_INTEGER AllocationSize;
} FILE_ALLOCATION_INFORMATION, *PFILE_ALLOCATION_INFORMATION;

typedef struct _FILE_COMPRESSION_INFORMATION
{
    LARGE_INTEGER CompressedFileSize;
    USHORT CompressionFormat;
    UCHAR CompressionUnitShift;
    UCHAR ChunkShift;
    UCHAR ClusterShift;
    UCHAR Reserved[3];
} FILE_COMPRESSION_INFORMATION, *PFILE_COMPRESSION_INFORMATION;

typedef struct _FILE_DISPOSITION_INFORMATION
{
    BOOLEAN DeleteFile;
} FILE_DISPOSITION_INFORMATION, *PFILE_DISPOSITION_INFORMATION;

typedef struct _FILE_END_OF_FILE_INFORMATION
{
    LARGE_INTEGER EndOfFile;
} FILE_END_OF_FILE_INFORMATION, *PFILE_END_OF_FILE_INFORMATION;

typedef struct _FILE_VALID_DATA_LENGTH_INFORMATION
{
    LARGE_INTEGER ValidDataLength;
} FILE_VALID_DATA_LENGTH_INFORMATION, *PFILE_VALID_DATA_LENGTH_INFORMATION;

typedef struct _FILE_LINK_INFORMATION
{
    BOOLEAN ReplaceIfExists;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_LINK_INFORMATION, *PFILE_LINK_INFORMATION;

#if (PHNT_VERSION >= PHNT_REDSTONE5)
#define FILE_LINK_REPLACE_IF_EXISTS 0x00000001
#define FILE_LINK_POSIX_SEMANTICS 0x00000002
#define FILE_LINK_SUPPRESS_STORAGE_RESERVE_INHERITANCE 0x00000008
#define FILE_LINK_NO_INCREASE_AVAILABLE_SPACE 0x00000010
#define FILE_LINK_NO_DECREASE_AVAILABLE_SPACE 0x00000020
#define FILE_LINK_PRESERVE_AVAILABLE_SPACE 0x00000030
#define FILE_LINK_IGNORE_READONLY_ATTRIBUTE 0x00000040
#endif

#if (PHNT_VERSION >= PHNT_19H1)
#define FILE_LINK_FORCE_RESIZE_TARGET_SR 0x00000080
#define FILE_LINK_FORCE_RESIZE_SOURCE_SR 0x00000100
#define FILE_LINK_FORCE_RESIZE_SR 0x00000180
#endif

typedef struct _FILE_LINK_INFORMATION_EX
{
    ULONG Flags;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_LINK_INFORMATION_EX, *PFILE_LINK_INFORMATION_EX;

typedef struct _FILE_MOVE_CLUSTER_INFORMATION
{
    ULONG ClusterCount;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_MOVE_CLUSTER_INFORMATION, *PFILE_MOVE_CLUSTER_INFORMATION;

typedef struct _FILE_RENAME_INFORMATION
{
    BOOLEAN ReplaceIfExists;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_RENAME_INFORMATION, *PFILE_RENAME_INFORMATION;

#if (PHNT_VERSION >= PHNT_REDSTONE)
#define FILE_RENAME_REPLACE_IF_EXISTS 0x00000001
#define FILE_RENAME_POSIX_SEMANTICS 0x00000002
#endif

#if (PHNT_VERSION >= PHNT_REDSTONE3)
#define FILE_RENAME_SUPPRESS_PIN_STATE_INHERITANCE 0x00000004
#endif

#if (PHNT_VERSION >= PHNT_REDSTONE5)
#define FILE_RENAME_SUPPRESS_STORAGE_RESERVE_INHERITANCE 0x00000008
#define FILE_RENAME_NO_INCREASE_AVAILABLE_SPACE 0x00000010
#define FILE_RENAME_NO_DECREASE_AVAILABLE_SPACE 0x00000020
#define FILE_RENAME_PRESERVE_AVAILABLE_SPACE 0x00000030
#define FILE_RENAME_IGNORE_READONLY_ATTRIBUTE 0x00000040
#endif

#if (_WIN32_WINNT >= PHNT_19H1)
#define FILE_RENAME_FORCE_RESIZE_TARGET_SR 0x00000080
#define FILE_RENAME_FORCE_RESIZE_SOURCE_SR 0x00000100
#define FILE_RENAME_FORCE_RESIZE_SR 0x00000180
#endif

typedef struct _FILE_RENAME_INFORMATION_EX
{
    ULONG Flags;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_RENAME_INFORMATION_EX, *PFILE_RENAME_INFORMATION_EX;

typedef struct _FILE_STREAM_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG StreamNameLength;
    LARGE_INTEGER StreamSize;
    LARGE_INTEGER StreamAllocationSize;
    WCHAR StreamName[1];
} FILE_STREAM_INFORMATION, *PFILE_STREAM_INFORMATION;

typedef struct _FILE_TRACKING_INFORMATION
{
    HANDLE DestinationFile;
    ULONG ObjectInformationLength;
    CHAR ObjectInformation[1];
} FILE_TRACKING_INFORMATION, *PFILE_TRACKING_INFORMATION;

typedef struct _FILE_COMPLETION_INFORMATION
{
    HANDLE Port;
    PVOID Key;
} FILE_COMPLETION_INFORMATION, *PFILE_COMPLETION_INFORMATION;

typedef struct _FILE_PIPE_INFORMATION
{
     ULONG ReadMode;
     ULONG CompletionMode;
} FILE_PIPE_INFORMATION, *PFILE_PIPE_INFORMATION;

typedef struct _FILE_PIPE_LOCAL_INFORMATION
{
     ULONG NamedPipeType;
     ULONG NamedPipeConfiguration;
     ULONG MaximumInstances;
     ULONG CurrentInstances;
     ULONG InboundQuota;
     ULONG ReadDataAvailable;
     ULONG OutboundQuota;
     ULONG WriteQuotaAvailable;
     ULONG NamedPipeState;
     ULONG NamedPipeEnd;
} FILE_PIPE_LOCAL_INFORMATION, *PFILE_PIPE_LOCAL_INFORMATION;

typedef struct _FILE_PIPE_REMOTE_INFORMATION
{
     LARGE_INTEGER CollectDataTime;
     ULONG MaximumCollectionCount;
} FILE_PIPE_REMOTE_INFORMATION, *PFILE_PIPE_REMOTE_INFORMATION;

typedef struct _FILE_MAILSLOT_QUERY_INFORMATION
{
    ULONG MaximumMessageSize;
    ULONG MailslotQuota;
    ULONG NextMessageSize;
    ULONG MessagesAvailable;
    LARGE_INTEGER ReadTimeout;
} FILE_MAILSLOT_QUERY_INFORMATION, *PFILE_MAILSLOT_QUERY_INFORMATION;

typedef struct _FILE_MAILSLOT_SET_INFORMATION
{
    PLARGE_INTEGER ReadTimeout;
} FILE_MAILSLOT_SET_INFORMATION, *PFILE_MAILSLOT_SET_INFORMATION;

typedef struct _FILE_REPARSE_POINT_INFORMATION
{
    LONGLONG FileReference;
    ULONG Tag;
} FILE_REPARSE_POINT_INFORMATION, *PFILE_REPARSE_POINT_INFORMATION;

typedef struct _FILE_LINK_ENTRY_INFORMATION
{
    ULONG NextEntryOffset;
    LONGLONG ParentFileId; // LARGE_INTEGER
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_LINK_ENTRY_INFORMATION, *PFILE_LINK_ENTRY_INFORMATION;

typedef struct _FILE_LINKS_INFORMATION
{
    ULONG BytesNeeded;
    ULONG EntriesReturned;
    FILE_LINK_ENTRY_INFORMATION Entry;
} FILE_LINKS_INFORMATION, *PFILE_LINKS_INFORMATION;

typedef struct _FILE_NETWORK_PHYSICAL_NAME_INFORMATION
{
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_NETWORK_PHYSICAL_NAME_INFORMATION, *PFILE_NETWORK_PHYSICAL_NAME_INFORMATION;

typedef struct _FILE_STANDARD_LINK_INFORMATION
{
    ULONG NumberOfAccessibleLinks;
    ULONG TotalNumberOfLinks;
    BOOLEAN DeletePending;
    BOOLEAN Directory;
} FILE_STANDARD_LINK_INFORMATION, *PFILE_STANDARD_LINK_INFORMATION;

typedef struct _FILE_SFIO_RESERVE_INFORMATION
{
    ULONG RequestsPerPeriod;
    ULONG Period;
    BOOLEAN RetryFailures;
    BOOLEAN Discardable;
    ULONG RequestSize;
    ULONG NumOutstandingRequests;
} FILE_SFIO_RESERVE_INFORMATION, *PFILE_SFIO_RESERVE_INFORMATION;

typedef struct _FILE_SFIO_VOLUME_INFORMATION
{
    ULONG MaximumRequestsPerPeriod;
    ULONG MinimumPeriod;
    ULONG MinimumTransferSize;
} FILE_SFIO_VOLUME_INFORMATION, *PFILE_SFIO_VOLUME_INFORMATION;

typedef enum _IO_PRIORITY_HINT
{
    IoPriorityVeryLow = 0, // Defragging, content indexing and other background I/Os.
    IoPriorityLow, // Prefetching for applications.
    IoPriorityNormal, // Normal I/Os.
    IoPriorityHigh, // Used by filesystems for checkpoint I/O.
    IoPriorityCritical, // Used by memory manager. Not available for applications.
    MaxIoPriorityTypes
} IO_PRIORITY_HINT;

typedef struct _FILE_IO_PRIORITY_HINT_INFORMATION
{
    IO_PRIORITY_HINT PriorityHint;
} FILE_IO_PRIORITY_HINT_INFORMATION, *PFILE_IO_PRIORITY_HINT_INFORMATION;

typedef struct _FILE_IO_PRIORITY_HINT_INFORMATION_EX
{
    IO_PRIORITY_HINT PriorityHint;
    BOOLEAN BoostOutstanding;
} FILE_IO_PRIORITY_HINT_INFORMATION_EX, *PFILE_IO_PRIORITY_HINT_INFORMATION_EX;

#define FILE_SKIP_COMPLETION_PORT_ON_SUCCESS 0x1
#define FILE_SKIP_SET_EVENT_ON_HANDLE 0x2
#define FILE_SKIP_SET_USER_EVENT_ON_FAST_IO 0x4

typedef struct _FILE_IO_COMPLETION_NOTIFICATION_INFORMATION
{
    ULONG Flags;
} FILE_IO_COMPLETION_NOTIFICATION_INFORMATION, *PFILE_IO_COMPLETION_NOTIFICATION_INFORMATION;

typedef struct _FILE_PROCESS_IDS_USING_FILE_INFORMATION
{
    ULONG NumberOfProcessIdsInList;
    ULONG_PTR ProcessIdList[1];
} FILE_PROCESS_IDS_USING_FILE_INFORMATION, *PFILE_PROCESS_IDS_USING_FILE_INFORMATION;

typedef struct _FILE_IS_REMOTE_DEVICE_INFORMATION
{
    BOOLEAN IsRemote;
} FILE_IS_REMOTE_DEVICE_INFORMATION, *PFILE_IS_REMOTE_DEVICE_INFORMATION;

typedef struct _FILE_NUMA_NODE_INFORMATION
{
    USHORT NodeNumber;
} FILE_NUMA_NODE_INFORMATION, *PFILE_NUMA_NODE_INFORMATION;

typedef struct _FILE_IOSTATUSBLOCK_RANGE_INFORMATION
{
    PUCHAR IoStatusBlockRange;
    ULONG Length;
} FILE_IOSTATUSBLOCK_RANGE_INFORMATION, *PFILE_IOSTATUSBLOCK_RANGE_INFORMATION;

typedef struct _FILE_REMOTE_PROTOCOL_INFORMATION
{
    USHORT StructureVersion; // 1
    USHORT StructureSize;

    ULONG Protocol; // WNNC_NET_*

    USHORT ProtocolMajorVersion;
    USHORT ProtocolMinorVersion;
    USHORT ProtocolRevision;

    USHORT Reserved;

    // Generic information

    ULONG Flags;

    struct
    {
        ULONG Reserved[8];
    } GenericReserved;

    // Specific information

#if (PHNT_VERSION < PHNT_WIN8)
    struct
    {
        ULONG Reserved[16];
    } ProtocolSpecificReserved;
#else
    union
    {
        struct
        {
            struct
            {
                ULONG Capabilities;
            } Server;
            struct
            {
                ULONG Capabilities;
                ULONG CachingFlags;
            } Share;
        } Smb2;
        ULONG Reserved[16];
    } ProtocolSpecific;
#endif
} FILE_REMOTE_PROTOCOL_INFORMATION, *PFILE_REMOTE_PROTOCOL_INFORMATION;

#define CHECKSUM_ENFORCEMENT_OFF 0x00000001

typedef struct _FILE_INTEGRITY_STREAM_INFORMATION
{
    USHORT ChecksumAlgorithm;
    UCHAR ChecksumChunkShift;
    UCHAR ClusterShift;
    ULONG Flags;
} FILE_INTEGRITY_STREAM_INFORMATION, *PFILE_INTEGRITY_STREAM_INFORMATION;

typedef struct _FILE_VOLUME_NAME_INFORMATION
{
    ULONG DeviceNameLength;
    WCHAR DeviceName[1];
} FILE_VOLUME_NAME_INFORMATION, *PFILE_VOLUME_NAME_INFORMATION;

typedef struct _FILE_ID_INFORMATION
{
    ULONGLONG VolumeSerialNumber;
    FILE_ID_128 FileId;
} FILE_ID_INFORMATION, *PFILE_ID_INFORMATION;

typedef struct _FILE_ID_EXTD_DIR_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    ULONG ReparsePointTag;
    FILE_ID_128 FileId;
    WCHAR FileName[1];
} FILE_ID_EXTD_DIR_INFORMATION, *PFILE_ID_EXTD_DIR_INFORMATION;

typedef struct _FILE_LINK_ENTRY_FULL_ID_INFORMATION
{
    ULONG NextEntryOffset;
    FILE_ID_128 ParentFileId;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_LINK_ENTRY_FULL_ID_INFORMATION, *PFILE_LINK_ENTRY_FULL_ID_INFORMATION;

typedef struct _FILE_ID_EXTD_BOTH_DIR_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    ULONG ReparsePointTag;
    FILE_ID_128 FileId;
    CCHAR ShortNameLength;
    WCHAR ShortName[12];
    WCHAR FileName[1];
} FILE_ID_EXTD_BOTH_DIR_INFORMATION, *PFILE_ID_EXTD_BOTH_DIR_INFORMATION;

// private
typedef struct _FILE_STAT_INFORMATION
{
    LARGE_INTEGER FileId;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG FileAttributes;
    ULONG ReparseTag;
    ULONG NumberOfLinks;
    ULONG EffectiveAccess;
} FILE_STAT_INFORMATION, *PFILE_STAT_INFORMATION;

// private
typedef struct _FILE_MEMORY_PARTITION_INFORMATION
{
    HANDLE OwnerPartitionHandle;
    union
    {
        struct
        {
            UCHAR NoCrossPartitionAccess;
            UCHAR Spare[3];
        };
        ULONG AllFlags;
    } Flags;
} FILE_MEMORY_PARTITION_INFORMATION, *PFILE_MEMORY_PARTITION_INFORMATION;

// private
typedef struct _FILE_STAT_LX_INFORMATION
{
    LARGE_INTEGER FileId;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG FileAttributes;
    ULONG ReparseTag;
    ULONG NumberOfLinks;
    ULONG EffectiveAccess;
    ULONG LxFlags;
    ULONG LxUid;
    ULONG LxGid;
    ULONG LxMode;
    ULONG LxDeviceIdMajor;
    ULONG LxDeviceIdMinor;
} FILE_STAT_LX_INFORMATION, *PFILE_STAT_LX_INFORMATION;

// private
typedef struct _FILE_CASE_SENSITIVE_INFORMATION
{
    ULONG Flags;
} FILE_CASE_SENSITIVE_INFORMATION, *PFILE_CASE_SENSITIVE_INFORMATION;

// NtQueryDirectoryFile types

typedef struct _FILE_DIRECTORY_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_DIRECTORY_INFORMATION, *PFILE_DIRECTORY_INFORMATION;

typedef struct _FILE_FULL_DIR_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    WCHAR FileName[1];
} FILE_FULL_DIR_INFORMATION, *PFILE_FULL_DIR_INFORMATION;

typedef struct _FILE_ID_FULL_DIR_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    LARGE_INTEGER FileId;
    WCHAR FileName[1];
} FILE_ID_FULL_DIR_INFORMATION, *PFILE_ID_FULL_DIR_INFORMATION;

typedef struct _FILE_BOTH_DIR_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    CCHAR ShortNameLength;
    WCHAR ShortName[12];
    WCHAR FileName[1];
} FILE_BOTH_DIR_INFORMATION, *PFILE_BOTH_DIR_INFORMATION;

typedef struct _FILE_ID_BOTH_DIR_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    CCHAR ShortNameLength;
    WCHAR ShortName[12];
    LARGE_INTEGER FileId;
    WCHAR FileName[1];
} FILE_ID_BOTH_DIR_INFORMATION, *PFILE_ID_BOTH_DIR_INFORMATION;

typedef struct _FILE_NAMES_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG FileIndex;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_NAMES_INFORMATION, *PFILE_NAMES_INFORMATION;

typedef struct _FILE_ID_GLOBAL_TX_DIR_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    LARGE_INTEGER FileId;
    GUID LockingTransactionId;
    ULONG TxInfoFlags;
    WCHAR FileName[1];
} FILE_ID_GLOBAL_TX_DIR_INFORMATION, *PFILE_ID_GLOBAL_TX_DIR_INFORMATION;

#define FILE_ID_GLOBAL_TX_DIR_INFO_FLAG_WRITELOCKED 0x00000001
#define FILE_ID_GLOBAL_TX_DIR_INFO_FLAG_VISIBLE_TO_TX 0x00000002
#define FILE_ID_GLOBAL_TX_DIR_INFO_FLAG_VISIBLE_OUTSIDE_TX 0x00000004

typedef struct _FILE_OBJECTID_INFORMATION
{
    LONGLONG FileReference;
    UCHAR ObjectId[16]; // GUID
    union
    {
        struct
        {
            UCHAR BirthVolumeId[16];
            UCHAR BirthObjectId[16];
            UCHAR DomainId[16];
        };
        UCHAR ExtendedInfo[48];
    };
} FILE_OBJECTID_INFORMATION, *PFILE_OBJECTID_INFORMATION;

// NtQueryEaFile/NtSetEaFile types

typedef struct _FILE_FULL_EA_INFORMATION
{
    ULONG NextEntryOffset;
    UCHAR Flags;
    UCHAR EaNameLength;
    USHORT EaValueLength;
    CHAR EaName[1];
} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;

typedef struct _FILE_GET_EA_INFORMATION
{
    ULONG NextEntryOffset;
    UCHAR EaNameLength;
    CHAR EaName[1];
} FILE_GET_EA_INFORMATION, *PFILE_GET_EA_INFORMATION;

// NtQueryQuotaInformationFile/NtSetQuotaInformationFile types

typedef struct _FILE_GET_QUOTA_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG SidLength;
    SID Sid;
} FILE_GET_QUOTA_INFORMATION, *PFILE_GET_QUOTA_INFORMATION;

typedef struct _FILE_QUOTA_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG SidLength;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER QuotaUsed;
    LARGE_INTEGER QuotaThreshold;
    LARGE_INTEGER QuotaLimit;
    SID Sid;
} FILE_QUOTA_INFORMATION, *PFILE_QUOTA_INFORMATION;

typedef enum _FSINFOCLASS
{
    FileFsVolumeInformation = 1, // FILE_FS_VOLUME_INFORMATION
    FileFsLabelInformation, // FILE_FS_LABEL_INFORMATION
    FileFsSizeInformation, // FILE_FS_SIZE_INFORMATION
    FileFsDeviceInformation, // FILE_FS_DEVICE_INFORMATION
    FileFsAttributeInformation, // FILE_FS_ATTRIBUTE_INFORMATION
    FileFsControlInformation, // FILE_FS_CONTROL_INFORMATION
    FileFsFullSizeInformation, // FILE_FS_FULL_SIZE_INFORMATION
    FileFsObjectIdInformation, // FILE_FS_OBJECTID_INFORMATION
    FileFsDriverPathInformation, // FILE_FS_DRIVER_PATH_INFORMATION
    FileFsVolumeFlagsInformation, // FILE_FS_VOLUME_FLAGS_INFORMATION // 10
    FileFsSectorSizeInformation, // FILE_FS_SECTOR_SIZE_INFORMATION // since WIN8
    FileFsDataCopyInformation, // FILE_FS_DATA_COPY_INFORMATION
    FileFsMetadataSizeInformation, // FILE_FS_METADATA_SIZE_INFORMATION // since THRESHOLD
    FileFsFullSizeInformationEx, // FILE_FS_FULL_SIZE_INFORMATION_EX // since REDSTONE5
    FileFsMaximumInformation
} FSINFOCLASS, *PFSINFOCLASS;

// NtQueryVolumeInformation/NtSetVolumeInformation types

// private
typedef struct _FILE_FS_VOLUME_INFORMATION
{
    LARGE_INTEGER VolumeCreationTime;
    ULONG VolumeSerialNumber;
    ULONG VolumeLabelLength;
    BOOLEAN SupportsObjects;
    WCHAR VolumeLabel[1];
} FILE_FS_VOLUME_INFORMATION, *PFILE_FS_VOLUME_INFORMATION;

// private
typedef struct _FILE_FS_LABEL_INFORMATION
{
    ULONG VolumeLabelLength;
    WCHAR VolumeLabel[1];
} FILE_FS_LABEL_INFORMATION, * PFILE_FS_LABEL_INFORMATION;

// private
typedef struct _FILE_FS_SIZE_INFORMATION
{
    LARGE_INTEGER TotalAllocationUnits;
    LARGE_INTEGER AvailableAllocationUnits;
    ULONG SectorsPerAllocationUnit;
    ULONG BytesPerSector;
} FILE_FS_SIZE_INFORMATION, *PFILE_FS_SIZE_INFORMATION;

// private
typedef struct _FILE_FS_CONTROL_INFORMATION
{
    LARGE_INTEGER FreeSpaceStartFiltering;
    LARGE_INTEGER FreeSpaceThreshold;
    LARGE_INTEGER FreeSpaceStopFiltering;
    LARGE_INTEGER DefaultQuotaThreshold;
    LARGE_INTEGER DefaultQuotaLimit;
    ULONG FileSystemControlFlags;
} FILE_FS_CONTROL_INFORMATION, *PFILE_FS_CONTROL_INFORMATION;

// private
typedef struct _FILE_FS_FULL_SIZE_INFORMATION
{
    LARGE_INTEGER TotalAllocationUnits;
    LARGE_INTEGER CallerAvailableAllocationUnits;
    LARGE_INTEGER ActualAvailableAllocationUnits;
    ULONG SectorsPerAllocationUnit;
    ULONG BytesPerSector;
} FILE_FS_FULL_SIZE_INFORMATION, *PFILE_FS_FULL_SIZE_INFORMATION;

// private
typedef struct _FILE_FS_OBJECTID_INFORMATION
{
    UCHAR ObjectId[16];
    UCHAR ExtendedInfo[48];
} FILE_FS_OBJECTID_INFORMATION, *PFILE_FS_OBJECTID_INFORMATION;

// private
typedef struct _FILE_FS_DEVICE_INFORMATION
{
    DEVICE_TYPE DeviceType;
    ULONG Characteristics;
} FILE_FS_DEVICE_INFORMATION, *PFILE_FS_DEVICE_INFORMATION;

// private
typedef struct _FILE_FS_ATTRIBUTE_INFORMATION
{
    ULONG FileSystemAttributes;
    LONG MaximumComponentNameLength;
    ULONG FileSystemNameLength;
    WCHAR FileSystemName[1];
} FILE_FS_ATTRIBUTE_INFORMATION, *PFILE_FS_ATTRIBUTE_INFORMATION;

// private
typedef struct _FILE_FS_DRIVER_PATH_INFORMATION
{
    BOOLEAN DriverInPath;
    ULONG DriverNameLength;
    WCHAR DriverName[1];
} FILE_FS_DRIVER_PATH_INFORMATION, *PFILE_FS_DRIVER_PATH_INFORMATION;

// private
typedef struct _FILE_FS_VOLUME_FLAGS_INFORMATION
{
    ULONG Flags;
} FILE_FS_VOLUME_FLAGS_INFORMATION, *PFILE_FS_VOLUME_FLAGS_INFORMATION;

#define SSINFO_FLAGS_ALIGNED_DEVICE 0x00000001
#define SSINFO_FLAGS_PARTITION_ALIGNED_ON_DEVICE 0x00000002

// If set for Sector and Partition fields, alignment is not known.
#define SSINFO_OFFSET_UNKNOWN 0xffffffff

typedef struct _FILE_FS_SECTOR_SIZE_INFORMATION
{
    ULONG LogicalBytesPerSector;
    ULONG PhysicalBytesPerSectorForAtomicity;
    ULONG PhysicalBytesPerSectorForPerformance;
    ULONG FileSystemEffectivePhysicalBytesPerSectorForAtomicity;
    ULONG Flags;
    ULONG ByteOffsetForSectorAlignment;
    ULONG ByteOffsetForPartitionAlignment;
} FILE_FS_SECTOR_SIZE_INFORMATION, *PFILE_FS_SECTOR_SIZE_INFORMATION;

// private
typedef struct _FILE_FS_DATA_COPY_INFORMATION
{
    ULONG NumberOfCopies;
} FILE_FS_DATA_COPY_INFORMATION, *PFILE_FS_DATA_COPY_INFORMATION;

// private
typedef struct _FILE_FS_METADATA_SIZE_INFORMATION
{
    LARGE_INTEGER TotalMetadataAllocationUnits;
    ULONG SectorsPerAllocationUnit;
    ULONG BytesPerSector;
} FILE_FS_METADATA_SIZE_INFORMATION, *PFILE_FS_METADATA_SIZE_INFORMATION;

// private
typedef struct _FILE_FS_FULL_SIZE_INFORMATION_EX
{
    ULONGLONG ActualTotalAllocationUnits;
    ULONGLONG ActualAvailableAllocationUnits;
    ULONGLONG ActualPoolUnavailableAllocationUnits;
    ULONGLONG CallerTotalAllocationUnits;
    ULONGLONG CallerAvailableAllocationUnits;
    ULONGLONG CallerPoolUnavailableAllocationUnits;
    ULONGLONG UsedAllocationUnits;
    ULONGLONG TotalReservedAllocationUnits;
    ULONGLONG VolumeStorageReserveAllocationUnits;
    ULONGLONG AvailableCommittedAllocationUnits;
    ULONGLONG PoolAvailableAllocationUnits;
    ULONG SectorsPerAllocationUnit;
    ULONG BytesPerSector;
} FILE_FS_FULL_SIZE_INFORMATION_EX, *PFILE_FS_FULL_SIZE_INFORMATION_EX;

// System calls

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateFile(
    _Out_ PHANDLE FileHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_opt_ PLARGE_INTEGER AllocationSize,
    _In_ ULONG FileAttributes,
    _In_ ULONG ShareAccess,
    _In_ ULONG CreateDisposition,
    _In_ ULONG CreateOptions,
    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,
    _In_ ULONG EaLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateNamedPipeFile(
    _Out_ PHANDLE FileHandle,
    _In_ ULONG DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG ShareAccess,
    _In_ ULONG CreateDisposition,
    _In_ ULONG CreateOptions,
    _In_ ULONG NamedPipeType,
    _In_ ULONG ReadMode,
    _In_ ULONG CompletionMode,
    _In_ ULONG MaximumInstances,
    _In_ ULONG InboundQuota,
    _In_ ULONG OutboundQuota,
    _In_opt_ PLARGE_INTEGER DefaultTimeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateMailslotFile(
    _Out_ PHANDLE FileHandle,
    _In_ ULONG DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG CreateOptions,
    _In_ ULONG MailslotQuota,
    _In_ ULONG MaximumMessageSize,
    _In_ PLARGE_INTEGER ReadTimeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenFile(
    _Out_ PHANDLE FileHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG ShareAccess,
    _In_ ULONG OpenOptions
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeleteFile(
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFlushBuffersFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock
    );

#define FLUSH_FLAGS_FILE_DATA_ONLY 0x00000001
#define FLUSH_FLAGS_NO_SYNC 0x00000002
#define FLUSH_FLAGS_FILE_DATA_SYNC_ONLY 0x00000004 // REDSTONE1

#if (PHNT_VERSION >= PHNT_WIN8)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtFlushBuffersFileEx(
    _In_ HANDLE FileHandle,
    _In_ ULONG Flags,
    _In_reads_bytes_(ParametersSize) PVOID Parameters,
    _In_ ULONG ParametersSize,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass
    );

#if (PHNT_VERSION >= PHNT_REDSTONE2)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationByName(
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_reads_bytes_(Length) PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryDirectoryFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_opt_ PUNICODE_STRING FileName,
    _In_ BOOLEAN RestartScan
    );

#if (PHNT_VERSION >= PHNT_REDSTONE3)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryDirectoryFileEx(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_ PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass,
    _In_ ULONG QueryFlags,
    _In_opt_ PUNICODE_STRING FileName
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryEaFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_reads_bytes_opt_(EaListLength) PVOID EaList,
    _In_ ULONG EaListLength,
    _In_opt_ PULONG EaIndex,
    _In_ BOOLEAN RestartScan
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetEaFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_reads_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryQuotaInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_reads_bytes_opt_(SidListLength) PVOID SidList,
    _In_ ULONG SidListLength,
    _In_opt_ PSID StartSid,
    _In_ BOOLEAN RestartScan
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetQuotaInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_reads_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryVolumeInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID FsInformation,
    _In_ ULONG Length,
    _In_ FSINFOCLASS FsInformationClass
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetVolumeInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_reads_bytes_(Length) PVOID FsInformation,
    _In_ ULONG Length,
    _In_ FSINFOCLASS FsInformationClass
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCancelIoFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock
    );

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCancelIoFileEx(
    _In_ HANDLE FileHandle,
    _In_opt_ PIO_STATUS_BLOCK IoRequestToCancel,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCancelSynchronousIoFile(
    _In_ HANDLE ThreadHandle,
    _In_opt_ PIO_STATUS_BLOCK IoRequestToCancel,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeviceIoControlFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG IoControlCode,
    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFsControlFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG FsControlCode,
    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReadFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWriteFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_reads_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReadFileScatter(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PFILE_SEGMENT_ELEMENT SegmentArray,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWriteFileGather(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PFILE_SEGMENT_ELEMENT SegmentArray,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtLockFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PLARGE_INTEGER ByteOffset,
    _In_ PLARGE_INTEGER Length,
    _In_ ULONG Key,
    _In_ BOOLEAN FailImmediately,
    _In_ BOOLEAN ExclusiveLock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnlockFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PLARGE_INTEGER ByteOffset,
    _In_ PLARGE_INTEGER Length,
    _In_ ULONG Key
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryAttributesFile(
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PFILE_BASIC_INFORMATION FileInformation
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryFullAttributesFile(
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PFILE_NETWORK_OPEN_INFORMATION FileInformation
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtNotifyChangeDirectoryFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer, // FILE_NOTIFY_INFORMATION
    _In_ ULONG Length,
    _In_ ULONG CompletionFilter,
    _In_ BOOLEAN WatchTree
    );

// private
typedef enum _DIRECTORY_NOTIFY_INFORMATION_CLASS
{
    DirectoryNotifyInformation, // FILE_NOTIFY_INFORMATION
    DirectoryNotifyExtendedInformation // FILE_NOTIFY_EXTENDED_INFORMATION
} DIRECTORY_NOTIFY_INFORMATION_CLASS, *PDIRECTORY_NOTIFY_INFORMATION_CLASS;

#if (PHNT_VERSION >= PHNT_REDSTONE3)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtNotifyChangeDirectoryFileEx(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_ ULONG CompletionFilter,
    _In_ BOOLEAN WatchTree,
    _In_opt_ DIRECTORY_NOTIFY_INFORMATION_CLASS DirectoryNotifyInformationClass
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtLoadDriver(
    _In_ PUNICODE_STRING DriverServiceName
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnloadDriver(
    _In_ PUNICODE_STRING DriverServiceName
    );

// I/O completion port

#ifndef IO_COMPLETION_QUERY_STATE
#define IO_COMPLETION_QUERY_STATE 0x0001
#endif

typedef enum _IO_COMPLETION_INFORMATION_CLASS
{
    IoCompletionBasicInformation
} IO_COMPLETION_INFORMATION_CLASS;

typedef struct _IO_COMPLETION_BASIC_INFORMATION
{
    LONG Depth;
} IO_COMPLETION_BASIC_INFORMATION, *PIO_COMPLETION_BASIC_INFORMATION;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateIoCompletion(
    _Out_ PHANDLE IoCompletionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ ULONG Count
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenIoCompletion(
    _Out_ PHANDLE IoCompletionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryIoCompletion(
    _In_ HANDLE IoCompletionHandle,
    _In_ IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass,
    _Out_writes_bytes_(IoCompletionInformationLength) PVOID IoCompletionInformation,
    _In_ ULONG IoCompletionInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetIoCompletion(
    _In_ HANDLE IoCompletionHandle,
    _In_opt_ PVOID KeyContext,
    _In_opt_ PVOID ApcContext,
    _In_ NTSTATUS IoStatus,
    _In_ ULONG_PTR IoStatusInformation
    );

#if (PHNT_VERSION >= PHNT_WIN7)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetIoCompletionEx(
    _In_ HANDLE IoCompletionHandle,
    _In_ HANDLE IoCompletionPacketHandle,
    _In_opt_ PVOID KeyContext,
    _In_opt_ PVOID ApcContext,
    _In_ NTSTATUS IoStatus,
    _In_ ULONG_PTR IoStatusInformation
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRemoveIoCompletion(
    _In_ HANDLE IoCompletionHandle,
    _Out_ PVOID *KeyContext,
    _Out_ PVOID *ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_opt_ PLARGE_INTEGER Timeout
    );

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtRemoveIoCompletionEx(
    _In_ HANDLE IoCompletionHandle,
    _Out_writes_to_(Count, *NumEntriesRemoved) PFILE_IO_COMPLETION_INFORMATION IoCompletionInformation,
    _In_ ULONG Count,
    _Out_ PULONG NumEntriesRemoved,
    _In_opt_ PLARGE_INTEGER Timeout,
    _In_ BOOLEAN Alertable
    );
#endif

// Wait completion packet

#if (PHNT_VERSION >= PHNT_WIN8)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateWaitCompletionPacket(
    _Out_ PHANDLE WaitCompletionPacketHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAssociateWaitCompletionPacket(
    _In_ HANDLE WaitCompletionPacketHandle,
    _In_ HANDLE IoCompletionHandle,
    _In_ HANDLE TargetObjectHandle,
    _In_opt_ PVOID KeyContext,
    _In_opt_ PVOID ApcContext,
    _In_ NTSTATUS IoStatus,
    _In_ ULONG_PTR IoStatusInformation,
    _Out_opt_ PBOOLEAN AlreadySignaled
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCancelWaitCompletionPacket(
    _In_ HANDLE WaitCompletionPacketHandle,
    _In_ BOOLEAN RemoveSignaledPacket
    );

#endif

// Sessions

typedef enum _IO_SESSION_EVENT
{
    IoSessionEventIgnore,
    IoSessionEventCreated,
    IoSessionEventTerminated,
    IoSessionEventConnected,
    IoSessionEventDisconnected,
    IoSessionEventLogon,
    IoSessionEventLogoff,
    IoSessionEventMax
} IO_SESSION_EVENT;

typedef enum _IO_SESSION_STATE
{
    IoSessionStateCreated,
    IoSessionStateInitialized,
    IoSessionStateConnected,
    IoSessionStateDisconnected,
    IoSessionStateDisconnectedLoggedOn,
    IoSessionStateLoggedOn,
    IoSessionStateLoggedOff,
    IoSessionStateTerminated,
    IoSessionStateMax
} IO_SESSION_STATE;


// Sessions

#if (PHNT_MODE != PHNT_MODE_KERNEL)

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenSession(
    _Out_ PHANDLE SessionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );
#endif

#endif

#if (PHNT_VERSION >= PHNT_WIN7)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtNotifyChangeSession(
    _In_ HANDLE SessionHandle,
    _In_ ULONG ChangeSequenceNumber,
    _In_ PLARGE_INTEGER ChangeTimeStamp,
    _In_ IO_SESSION_EVENT Event,
    _In_ IO_SESSION_STATE NewState,
    _In_ IO_SESSION_STATE PreviousState,
    _In_reads_bytes_opt_(PayloadSize) PVOID Payload,
    _In_ ULONG PayloadSize
    );
#endif

// Other types

typedef enum _INTERFACE_TYPE
{
    InterfaceTypeUndefined = -1,
    Internal,
    Isa,
    Eisa,
    MicroChannel,
    TurboChannel,
    PCIBus,
    VMEBus,
    NuBus,
    PCMCIABus,
    CBus,
    MPIBus,
    MPSABus,
    ProcessorInternal,
    InternalPowerBus,
    PNPISABus,
    PNPBus,
    Vmcs,
    MaximumInterfaceType
} INTERFACE_TYPE, *PINTERFACE_TYPE;

typedef enum _DMA_WIDTH
{
    Width8Bits,
    Width16Bits,
    Width32Bits,
    MaximumDmaWidth
} DMA_WIDTH, *PDMA_WIDTH;

typedef enum _DMA_SPEED
{
    Compatible,
    TypeA,
    TypeB,
    TypeC,
    TypeF,
    MaximumDmaSpeed
} DMA_SPEED, *PDMA_SPEED;

typedef enum _BUS_DATA_TYPE
{
    ConfigurationSpaceUndefined = -1,
    Cmos,
    EisaConfiguration,
    Pos,
    CbusConfiguration,
    PCIConfiguration,
    VMEConfiguration,
    NuBusConfiguration,
    PCMCIAConfiguration,
    MPIConfiguration,
    MPSAConfiguration,
    PNPISAConfiguration,
    SgiInternalConfiguration,
    MaximumBusDataType
} BUS_DATA_TYPE, *PBUS_DATA_TYPE;

// Control structures

// Reparse structure for FSCTL_SET_REPARSE_POINT, FSCTL_GET_REPARSE_POINT, FSCTL_DELETE_REPARSE_POINT

#define SYMLINK_FLAG_RELATIVE 1

typedef struct _REPARSE_DATA_BUFFER
{
    ULONG ReparseTag;
    USHORT ReparseDataLength;
    USHORT Reserved;
    union
    {
        struct
        {
            USHORT SubstituteNameOffset;
            USHORT SubstituteNameLength;
            USHORT PrintNameOffset;
            USHORT PrintNameLength;
            ULONG Flags;
            WCHAR PathBuffer[1];
        } SymbolicLinkReparseBuffer;
        struct
        {
            USHORT SubstituteNameOffset;
            USHORT SubstituteNameLength;
            USHORT PrintNameOffset;
            USHORT PrintNameLength;
            WCHAR PathBuffer[1];
        } MountPointReparseBuffer;
        struct
        {
            UCHAR DataBuffer[1];
        } GenericReparseBuffer;
    };
} REPARSE_DATA_BUFFER, *PREPARSE_DATA_BUFFER;

// Named pipe FS control definitions

#define DEVICE_NAMED_PIPE L"\\Device\\NamedPipe\\"

#define FSCTL_PIPE_ASSIGN_EVENT             CTL_CODE(FILE_DEVICE_NAMED_PIPE, 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_DISCONNECT               CTL_CODE(FILE_DEVICE_NAMED_PIPE, 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_LISTEN                   CTL_CODE(FILE_DEVICE_NAMED_PIPE, 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_PEEK                     CTL_CODE(FILE_DEVICE_NAMED_PIPE, 3, METHOD_BUFFERED, FILE_READ_DATA)
#define FSCTL_PIPE_QUERY_EVENT              CTL_CODE(FILE_DEVICE_NAMED_PIPE, 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_TRANSCEIVE               CTL_CODE(FILE_DEVICE_NAMED_PIPE, 5, METHOD_NEITHER,  FILE_READ_DATA | FILE_WRITE_DATA)
#define FSCTL_PIPE_WAIT                     CTL_CODE(FILE_DEVICE_NAMED_PIPE, 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_IMPERSONATE              CTL_CODE(FILE_DEVICE_NAMED_PIPE, 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_SET_CLIENT_PROCESS       CTL_CODE(FILE_DEVICE_NAMED_PIPE, 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_QUERY_CLIENT_PROCESS     CTL_CODE(FILE_DEVICE_NAMED_PIPE, 9, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_GET_PIPE_ATTRIBUTE       CTL_CODE(FILE_DEVICE_NAMED_PIPE, 10, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_SET_PIPE_ATTRIBUTE       CTL_CODE(FILE_DEVICE_NAMED_PIPE, 11, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_GET_CONNECTION_ATTRIBUTE CTL_CODE(FILE_DEVICE_NAMED_PIPE, 12, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_SET_CONNECTION_ATTRIBUTE CTL_CODE(FILE_DEVICE_NAMED_PIPE, 13, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_GET_HANDLE_ATTRIBUTE     CTL_CODE(FILE_DEVICE_NAMED_PIPE, 14, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_SET_HANDLE_ATTRIBUTE     CTL_CODE(FILE_DEVICE_NAMED_PIPE, 15, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_FLUSH                    CTL_CODE(FILE_DEVICE_NAMED_PIPE, 16, METHOD_BUFFERED, FILE_WRITE_DATA)

#define FSCTL_PIPE_INTERNAL_READ            CTL_CODE(FILE_DEVICE_NAMED_PIPE, 2045, METHOD_BUFFERED, FILE_READ_DATA)
#define FSCTL_PIPE_INTERNAL_WRITE           CTL_CODE(FILE_DEVICE_NAMED_PIPE, 2046, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_PIPE_INTERNAL_TRANSCEIVE      CTL_CODE(FILE_DEVICE_NAMED_PIPE, 2047, METHOD_NEITHER, FILE_READ_DATA | FILE_WRITE_DATA)
#define FSCTL_PIPE_INTERNAL_READ_OVFLOW     CTL_CODE(FILE_DEVICE_NAMED_PIPE, 2048, METHOD_BUFFERED, FILE_READ_DATA)

// Flags for query event

#define FILE_PIPE_READ_DATA 0x00000000
#define FILE_PIPE_WRITE_SPACE 0x00000001

// Input for FSCTL_PIPE_ASSIGN_EVENT
typedef struct _FILE_PIPE_ASSIGN_EVENT_BUFFER
{
    HANDLE EventHandle;
    ULONG KeyValue;
} FILE_PIPE_ASSIGN_EVENT_BUFFER, *PFILE_PIPE_ASSIGN_EVENT_BUFFER;

// Output for FILE_PIPE_PEEK_BUFFER
typedef struct _FILE_PIPE_PEEK_BUFFER
{
    ULONG NamedPipeState;
    ULONG ReadDataAvailable;
    ULONG NumberOfMessages;
    ULONG MessageLength;
    CHAR Data[1];
} FILE_PIPE_PEEK_BUFFER, *PFILE_PIPE_PEEK_BUFFER;

// Output for FSCTL_PIPE_QUERY_EVENT
typedef struct _FILE_PIPE_EVENT_BUFFER
{
    ULONG NamedPipeState;
    ULONG EntryType;
    ULONG ByteCount;
    ULONG KeyValue;
    ULONG NumberRequests;
} FILE_PIPE_EVENT_BUFFER, *PFILE_PIPE_EVENT_BUFFER;

// Input for FSCTL_PIPE_WAIT
typedef struct _FILE_PIPE_WAIT_FOR_BUFFER
{
    LARGE_INTEGER Timeout;
    ULONG NameLength;
    BOOLEAN TimeoutSpecified;
    WCHAR Name[1];
} FILE_PIPE_WAIT_FOR_BUFFER, *PFILE_PIPE_WAIT_FOR_BUFFER;

// Input for FSCTL_PIPE_SET_CLIENT_PROCESS, Output for FSCTL_PIPE_QUERY_CLIENT_PROCESS
typedef struct _FILE_PIPE_CLIENT_PROCESS_BUFFER
{
#if !defined(BUILD_WOW6432)
    PVOID ClientSession;
    PVOID ClientProcess;
#else
    ULONGLONG ClientSession;
    ULONGLONG ClientProcess;
#endif
} FILE_PIPE_CLIENT_PROCESS_BUFFER, *PFILE_PIPE_CLIENT_PROCESS_BUFFER;

#define FILE_PIPE_COMPUTER_NAME_LENGTH 15

// Input for FSCTL_PIPE_SET_CLIENT_PROCESS, Output for FSCTL_PIPE_QUERY_CLIENT_PROCESS
typedef struct _FILE_PIPE_CLIENT_PROCESS_BUFFER_EX
{
#if !defined(BUILD_WOW6432)
    PVOID ClientSession;
    PVOID ClientProcess;
#else
    ULONGLONG ClientSession;
    ULONGLONG ClientProcess;
#endif
    USHORT ClientComputerNameLength; // in bytes
    WCHAR ClientComputerBuffer[FILE_PIPE_COMPUTER_NAME_LENGTH + 1]; // null-terminated
} FILE_PIPE_CLIENT_PROCESS_BUFFER_EX, *PFILE_PIPE_CLIENT_PROCESS_BUFFER_EX;

// Mailslot FS control definitions

#define MAILSLOT_CLASS_FIRSTCLASS 1
#define MAILSLOT_CLASS_SECONDCLASS 2

#define FSCTL_MAILSLOT_PEEK             CTL_CODE(FILE_DEVICE_MAILSLOT, 0, METHOD_NEITHER, FILE_READ_DATA)

// Output for FSCTL_MAILSLOT_PEEK
typedef struct _FILE_MAILSLOT_PEEK_BUFFER
{
    ULONG ReadDataAvailable;
    ULONG NumberOfMessages;
    ULONG MessageLength;
} FILE_MAILSLOT_PEEK_BUFFER, *PFILE_MAILSLOT_PEEK_BUFFER;

// Mount manager FS control definitions

#define MOUNTMGR_DEVICE_NAME L"\\Device\\MountPointManager"
#define MOUNTMGRCONTROLTYPE 0x0000006D // 'm'
#define MOUNTDEVCONTROLTYPE 0x0000004D // 'M'

#define IOCTL_MOUNTMGR_CREATE_POINT                 CTL_CODE(MOUNTMGRCONTROLTYPE, 0, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_DELETE_POINTS                CTL_CODE(MOUNTMGRCONTROLTYPE, 1, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_QUERY_POINTS                 CTL_CODE(MOUNTMGRCONTROLTYPE, 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MOUNTMGR_DELETE_POINTS_DBONLY         CTL_CODE(MOUNTMGRCONTROLTYPE, 3, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_NEXT_DRIVE_LETTER            CTL_CODE(MOUNTMGRCONTROLTYPE, 4, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_AUTO_DL_ASSIGNMENTS          CTL_CODE(MOUNTMGRCONTROLTYPE, 5, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_CREATED   CTL_CODE(MOUNTMGRCONTROLTYPE, 6, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_DELETED   CTL_CODE(MOUNTMGRCONTROLTYPE, 7, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_CHANGE_NOTIFY                CTL_CODE(MOUNTMGRCONTROLTYPE, 8, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_MOUNTMGR_KEEP_LINKS_WHEN_OFFLINE      CTL_CODE(MOUNTMGRCONTROLTYPE, 9, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_CHECK_UNPROCESSED_VOLUMES    CTL_CODE(MOUNTMGRCONTROLTYPE, 10, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION  CTL_CODE(MOUNTMGRCONTROLTYPE, 11, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATH        CTL_CODE(MOUNTMGRCONTROLTYPE, 12, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATHS       CTL_CODE(MOUNTMGRCONTROLTYPE, 13, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_MOUNTDEV_QUERY_DEVICE_NAME            CTL_CODE(MOUNTDEVCONTROLTYPE, 2, METHOD_BUFFERED, FILE_ANY_ACCESS)

// Input structure for IOCTL_MOUNTMGR_CREATE_POINT.
typedef struct _MOUNTMGR_CREATE_POINT_INPUT
{
    USHORT SymbolicLinkNameOffset;
    USHORT SymbolicLinkNameLength;
    USHORT DeviceNameOffset;
    USHORT DeviceNameLength;
} MOUNTMGR_CREATE_POINT_INPUT, *PMOUNTMGR_CREATE_POINT_INPUT;

// Input structure for IOCTL_MOUNTMGR_DELETE_POINTS, IOCTL_MOUNTMGR_QUERY_POINTS, and IOCTL_MOUNTMGR_DELETE_POINTS_DBONLY.
typedef struct _MOUNTMGR_MOUNT_POINT
{
    ULONG SymbolicLinkNameOffset;
    USHORT SymbolicLinkNameLength;
    USHORT Reserved1;
    ULONG UniqueIdOffset;
    USHORT UniqueIdLength;
    USHORT Reserved2;
    ULONG DeviceNameOffset;
    USHORT DeviceNameLength;
    USHORT Reserved3;
} MOUNTMGR_MOUNT_POINT, * PMOUNTMGR_MOUNT_POINT;

// Output structure for IOCTL_MOUNTMGR_DELETE_POINTS, IOCTL_MOUNTMGR_QUERY_POINTS, and IOCTL_MOUNTMGR_DELETE_POINTS_DBONLY.
typedef struct _MOUNTMGR_MOUNT_POINTS
{
    ULONG Size;
    ULONG NumberOfMountPoints;
    MOUNTMGR_MOUNT_POINT MountPoints[1];
} MOUNTMGR_MOUNT_POINTS, *PMOUNTMGR_MOUNT_POINTS;

// Input structure for IOCTL_MOUNTMGR_NEXT_DRIVE_LETTER.
typedef struct _MOUNTMGR_DRIVE_LETTER_TARGET
{
    USHORT DeviceNameLength;
    WCHAR DeviceName[1];
} MOUNTMGR_DRIVE_LETTER_TARGET, *PMOUNTMGR_DRIVE_LETTER_TARGET;

// Output structure for IOCTL_MOUNTMGR_NEXT_DRIVE_LETTER.
typedef struct _MOUNTMGR_DRIVE_LETTER_INFORMATION
{
    BOOLEAN DriveLetterWasAssigned;
    UCHAR CurrentDriveLetter;
} MOUNTMGR_DRIVE_LETTER_INFORMATION, *PMOUNTMGR_DRIVE_LETTER_INFORMATION;

// Input structure for IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_CREATED and
// IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_DELETED.
typedef struct _MOUNTMGR_VOLUME_MOUNT_POINT
{
    USHORT SourceVolumeNameOffset;
    USHORT SourceVolumeNameLength;
    USHORT TargetVolumeNameOffset;
    USHORT TargetVolumeNameLength;
} MOUNTMGR_VOLUME_MOUNT_POINT, *PMOUNTMGR_VOLUME_MOUNT_POINT;

// Input structure for IOCTL_MOUNTMGR_CHANGE_NOTIFY.
// Output structure for IOCTL_MOUNTMGR_CHANGE_NOTIFY.
typedef struct _MOUNTMGR_CHANGE_NOTIFY_INFO
{
    ULONG EpicNumber;
} MOUNTMGR_CHANGE_NOTIFY_INFO, *PMOUNTMGR_CHANGE_NOTIFY_INFO;

// Input structure for IOCTL_MOUNTMGR_KEEP_LINKS_WHEN_OFFLINE,
// IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION,
// IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATH, and
// IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATHS.
// IOCTL_MOUNTMGR_PREPARE_VOLUME_DELETE
// IOCTL_MOUNTMGR_CANCEL_VOLUME_DELETE
typedef struct _MOUNTMGR_TARGET_NAME
{
    USHORT DeviceNameLength;
    WCHAR DeviceName[1];
} MOUNTMGR_TARGET_NAME, * PMOUNTMGR_TARGET_NAME;

// Macro that defines what a "drive letter" mount point is.  This macro can
// be used to scan the result from QUERY_POINTS to discover which mount points
// are find "drive letter" mount points.
#define MOUNTMGR_IS_DRIVE_LETTER(s) ( \
    (s)->Length == 28 && \
    (s)->Buffer[0] == '\\' && \
    (s)->Buffer[1] == 'D' && \
    (s)->Buffer[2] == 'o' && \
    (s)->Buffer[3] == 's' && \
    (s)->Buffer[4] == 'D' && \
    (s)->Buffer[5] == 'e' && \
    (s)->Buffer[6] == 'v' && \
    (s)->Buffer[7] == 'i' && \
    (s)->Buffer[8] == 'c' && \
    (s)->Buffer[9] == 'e' && \
    (s)->Buffer[10] == 's' && \
    (s)->Buffer[11] == '\\' && \
    (s)->Buffer[12] >= 'A' && \
    (s)->Buffer[12] <= 'Z' && \
    (s)->Buffer[13] == ':')

// Macro that defines what a "volume name" mount point is.  This macro can
// be used to scan the result from QUERY_POINTS to discover which mount points
// are "volume name" mount points.
#define MOUNTMGR_IS_VOLUME_NAME(s) ( \
     ((s)->Length == 96 || ((s)->Length == 98 && (s)->Buffer[48] == '\\')) && \
     (s)->Buffer[0] == '\\' && \
     ((s)->Buffer[1] == '?' || (s)->Buffer[1] == '\\') && \
     (s)->Buffer[2] == '?' && \
     (s)->Buffer[3] == '\\' && \
     (s)->Buffer[4] == 'V' && \
     (s)->Buffer[5] == 'o' && \
     (s)->Buffer[6] == 'l' && \
     (s)->Buffer[7] == 'u' && \
     (s)->Buffer[8] == 'm' && \
     (s)->Buffer[9] == 'e' && \
     (s)->Buffer[10] == '{' && \
     (s)->Buffer[19] == '-' && \
     (s)->Buffer[24] == '-' && \
     (s)->Buffer[29] == '-' && \
     (s)->Buffer[34] == '-' && \
     (s)->Buffer[47] == '}')

// Output structure for IOCTL_MOUNTDEV_QUERY_DEVICE_NAME.
typedef struct _MOUNTDEV_NAME
{
    USHORT NameLength;
    WCHAR Name[1];
} MOUNTDEV_NAME, * PMOUNTDEV_NAME;

// Output structure for IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATH and IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATHS.
typedef struct _MOUNTMGR_VOLUME_PATHS
{
    ULONG MultiSzLength;
    WCHAR MultiSz[1];
} MOUNTMGR_VOLUME_PATHS, *PMOUNTMGR_VOLUME_PATHS;

#define MOUNTMGR_IS_DOS_VOLUME_NAME(s) ( \
     MOUNTMGR_IS_VOLUME_NAME(s) && \
     (s)->Length == 96 && \
     (s)->Buffer[1] == '\\')

#define MOUNTMGR_IS_DOS_VOLUME_NAME_WB(s) ( \
     MOUNTMGR_IS_VOLUME_NAME(s) && \
     (s)->Length == 98 && \
     (s)->Buffer[1] == '\\')

#define MOUNTMGR_IS_NT_VOLUME_NAME(s) ( \
     MOUNTMGR_IS_VOLUME_NAME(s) && \
     (s)->Length == 96 && \
     (s)->Buffer[1] == '?')

#define MOUNTMGR_IS_NT_VOLUME_NAME_WB(s) ( \
     MOUNTMGR_IS_VOLUME_NAME(s) && \
     (s)->Length == 98 && \
     (s)->Buffer[1] == '?')

#endif

```

`phnt/ntkeapi.h`:

```h
#ifndef _NTKEAPI_H
#define _NTKEAPI_H

#if (PHNT_MODE != PHNT_MODE_KERNEL)
#define LOW_PRIORITY 0 // Lowest thread priority level
#define LOW_REALTIME_PRIORITY 16 // Lowest realtime priority level
#define HIGH_PRIORITY 31 // Highest thread priority level
#define MAXIMUM_PRIORITY 32 // Number of thread priority levels
#endif

typedef enum _KTHREAD_STATE
{
    Initialized,
    Ready,
    Running,
    Standby,
    Terminated,
    Waiting,
    Transition,
    DeferredReady,
    GateWaitObsolete,
    WaitingForProcessInSwap,
    MaximumThreadState
} KTHREAD_STATE, *PKTHREAD_STATE;

// private
typedef enum _KHETERO_CPU_POLICY
{
    KHeteroCpuPolicyAll,
    KHeteroCpuPolicyLarge,
    KHeteroCpuPolicyLargeOrIdle,
    KHeteroCpuPolicySmall,
    KHeteroCpuPolicySmallOrIdle,
    KHeteroCpuPolicyDynamic,
    KHeteroCpuPolicyStaticMax,
    KHeteroCpuPolicyBiasedSmall,
    KHeteroCpuPolicyBiasedLarge,
    KHeteroCpuPolicyDefault,
    KHeteroCpuPolicyMax
} KHETERO_CPU_POLICY, *PKHETERO_CPU_POLICY;

#if (PHNT_MODE != PHNT_MODE_KERNEL)

typedef enum _KWAIT_REASON
{
    Executive,
    FreePage,
    PageIn,
    PoolAllocation,
    DelayExecution,
    Suspended,
    UserRequest,
    WrExecutive,
    WrFreePage,
    WrPageIn,
    WrPoolAllocation,
    WrDelayExecution,
    WrSuspended,
    WrUserRequest,
    WrEventPair,
    WrQueue,
    WrLpcReceive,
    WrLpcReply,
    WrVirtualMemory,
    WrPageOut,
    WrRendezvous,
    WrKeyedEvent,
    WrTerminated,
    WrProcessInSwap,
    WrCpuRateControl,
    WrCalloutStack,
    WrKernel,
    WrResource,
    WrPushLock,
    WrMutex,
    WrQuantumEnd,
    WrDispatchInt,
    WrPreempted,
    WrYieldExecution,
    WrFastMutex,
    WrGuardedMutex,
    WrRundown,
    WrAlertByThreadId,
    WrDeferredPreempt,
    MaximumWaitReason
} KWAIT_REASON, *PKWAIT_REASON;

typedef enum _KPROFILE_SOURCE
{
    ProfileTime,
    ProfileAlignmentFixup,
    ProfileTotalIssues,
    ProfilePipelineDry,
    ProfileLoadInstructions,
    ProfilePipelineFrozen,
    ProfileBranchInstructions,
    ProfileTotalNonissues,
    ProfileDcacheMisses,
    ProfileIcacheMisses,
    ProfileCacheMisses,
    ProfileBranchMispredictions,
    ProfileStoreInstructions,
    ProfileFpInstructions,
    ProfileIntegerInstructions,
    Profile2Issue,
    Profile3Issue,
    Profile4Issue,
    ProfileSpecialInstructions,
    ProfileTotalCycles,
    ProfileIcacheIssues,
    ProfileDcacheAccesses,
    ProfileMemoryBarrierCycles,
    ProfileLoadLinkedIssues,
    ProfileMaximum
} KPROFILE_SOURCE;

#endif

#if (PHNT_MODE != PHNT_MODE_KERNEL)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCallbackReturn(
    _In_reads_bytes_opt_(OutputLength) PVOID OutputBuffer,
    _In_ ULONG OutputLength,
    _In_ NTSTATUS Status
    );

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
VOID
NTAPI
NtFlushProcessWriteBuffers(
    VOID
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryDebugFilterState(
    _In_ ULONG ComponentId,
    _In_ ULONG Level
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetDebugFilterState(
    _In_ ULONG ComponentId,
    _In_ ULONG Level,
    _In_ BOOLEAN State
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtYieldExecution(
    VOID
    );

#endif

#endif

```

`phnt/ntldr.h`:

```h
/*
 * Process Hacker -
 *   Loader support functions
 *
 * This file is part of Process Hacker.
 *
 * Process Hacker is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Process Hacker is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Process Hacker.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef _NTLDR_H
#define _NTLDR_H

#if (PHNT_MODE != PHNT_MODE_KERNEL)

// DLLs

typedef BOOLEAN (NTAPI *PLDR_INIT_ROUTINE)(
    _In_ PVOID DllHandle,
    _In_ ULONG Reason,
    _In_opt_ PVOID Context
    );

// symbols
typedef struct _LDR_SERVICE_TAG_RECORD
{
    struct _LDR_SERVICE_TAG_RECORD *Next;
    ULONG ServiceTag;
} LDR_SERVICE_TAG_RECORD, *PLDR_SERVICE_TAG_RECORD;

// symbols
typedef struct _LDRP_CSLIST
{
    PSINGLE_LIST_ENTRY Tail;
} LDRP_CSLIST, *PLDRP_CSLIST;

// symbols
typedef enum _LDR_DDAG_STATE
{
    LdrModulesMerged = -5,
    LdrModulesInitError = -4,
    LdrModulesSnapError = -3,
    LdrModulesUnloaded = -2,
    LdrModulesUnloading = -1,
    LdrModulesPlaceHolder = 0,
    LdrModulesMapping = 1,
    LdrModulesMapped = 2,
    LdrModulesWaitingForDependencies = 3,
    LdrModulesSnapping = 4,
    LdrModulesSnapped = 5,
    LdrModulesCondensed = 6,
    LdrModulesReadyToInit = 7,
    LdrModulesInitializing = 8,
    LdrModulesReadyToRun = 9
} LDR_DDAG_STATE;

// symbols
typedef struct _LDR_DDAG_NODE
{
    LIST_ENTRY Modules;
    PLDR_SERVICE_TAG_RECORD ServiceTagList;
    ULONG LoadCount;
    ULONG LoadWhileUnloadingCount;
    ULONG LowestLink;
    union
    {
        LDRP_CSLIST Dependencies;
        SINGLE_LIST_ENTRY RemovalLink;
    };
    LDRP_CSLIST IncomingDependencies;
    LDR_DDAG_STATE State;
    SINGLE_LIST_ENTRY CondenseLink;
    ULONG PreorderNumber;
} LDR_DDAG_NODE, *PLDR_DDAG_NODE;

// rev
typedef struct _LDR_DEPENDENCY_RECORD
{
    SINGLE_LIST_ENTRY DependencyLink;
    PLDR_DDAG_NODE DependencyNode;
    SINGLE_LIST_ENTRY IncomingDependencyLink;
    PLDR_DDAG_NODE IncomingDependencyNode;
} LDR_DEPENDENCY_RECORD, *PLDR_DEPENDENCY_RECORD;

// symbols
typedef enum _LDR_DLL_LOAD_REASON
{
    LoadReasonStaticDependency,
    LoadReasonStaticForwarderDependency,
    LoadReasonDynamicForwarderDependency,
    LoadReasonDelayloadDependency,
    LoadReasonDynamicLoad,
    LoadReasonAsImageLoad,
    LoadReasonAsDataLoad,
    LoadReasonEnclavePrimary, // REDSTONE3
    LoadReasonEnclaveDependency,
    LoadReasonUnknown = -1
} LDR_DLL_LOAD_REASON, *PLDR_DLL_LOAD_REASON;

#define LDRP_PACKAGED_BINARY 0x00000001
#define LDRP_STATIC_LINK 0x00000002
#define LDRP_IMAGE_DLL 0x00000004
#define LDRP_LOAD_IN_PROGRESS 0x00001000
#define LDRP_UNLOAD_IN_PROGRESS 0x00002000
#define LDRP_ENTRY_PROCESSED 0x00004000
#define LDRP_ENTRY_INSERTED 0x00008000
#define LDRP_CURRENT_LOAD 0x00010000
#define LDRP_FAILED_BUILTIN_LOAD 0x00020000
#define LDRP_DONT_CALL_FOR_THREADS 0x00040000
#define LDRP_PROCESS_ATTACH_CALLED 0x00080000
#define LDRP_DEBUG_SYMBOLS_LOADED 0x00100000
#define LDRP_IMAGE_NOT_AT_BASE 0x00200000 // Vista and below
#define LDRP_COR_IMAGE 0x00400000
#define LDRP_DONT_RELOCATE 0x00800000 // LDR_COR_OWNS_UNMAP
#define LDRP_SYSTEM_MAPPED 0x01000000
#define LDRP_IMAGE_VERIFYING 0x02000000
#define LDRP_DRIVER_DEPENDENT_DLL 0x04000000
#define LDRP_ENTRY_NATIVE 0x08000000
#define LDRP_REDIRECTED 0x10000000
#define LDRP_NON_PAGED_DEBUG_INFO 0x20000000
#define LDRP_MM_LOADED 0x40000000
#define LDRP_COMPAT_DATABASE_PROCESSED 0x80000000

#define LDR_DATA_TABLE_ENTRY_SIZE_WINXP FIELD_OFFSET(LDR_DATA_TABLE_ENTRY, DdagNode)
#define LDR_DATA_TABLE_ENTRY_SIZE_WIN7 FIELD_OFFSET(LDR_DATA_TABLE_ENTRY, BaseNameHashValue)
#define LDR_DATA_TABLE_ENTRY_SIZE_WIN8 FIELD_OFFSET(LDR_DATA_TABLE_ENTRY, ImplicitPathOptions)
#define LDR_DATA_TABLE_ENTRY_SIZE_WIN10 sizeof(LDR_DATA_TABLE_ENTRY)

// symbols
typedef struct _LDR_DATA_TABLE_ENTRY
{
    LIST_ENTRY InLoadOrderLinks;
    LIST_ENTRY InMemoryOrderLinks;
    union
    {
        LIST_ENTRY InInitializationOrderLinks;
        LIST_ENTRY InProgressLinks;
    };
    PVOID DllBase;
    PLDR_INIT_ROUTINE EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    union
    {
        UCHAR FlagGroup[4];
        ULONG Flags;
        struct
        {
            ULONG PackagedBinary : 1;
            ULONG MarkedForRemoval : 1;
            ULONG ImageDll : 1;
            ULONG LoadNotificationsSent : 1;
            ULONG TelemetryEntryProcessed : 1;
            ULONG ProcessStaticImport : 1;
            ULONG InLegacyLists : 1;
            ULONG InIndexes : 1;
            ULONG ShimDll : 1;
            ULONG InExceptionTable : 1;
            ULONG ReservedFlags1 : 2;
            ULONG LoadInProgress : 1;
            ULONG LoadConfigProcessed : 1;
            ULONG EntryProcessed : 1;
            ULONG ProtectDelayLoad : 1;
            ULONG ReservedFlags3 : 2;
            ULONG DontCallForThreads : 1;
            ULONG ProcessAttachCalled : 1;
            ULONG ProcessAttachFailed : 1;
            ULONG CorDeferredValidate : 1;
            ULONG CorImage : 1;
            ULONG DontRelocate : 1;
            ULONG CorILOnly : 1;
            ULONG ChpeImage : 1;
            ULONG ReservedFlags5 : 2;
            ULONG Redirected : 1;
            ULONG ReservedFlags6 : 2;
            ULONG CompatDatabaseProcessed : 1;
        };
    };
    USHORT ObsoleteLoadCount;
    USHORT TlsIndex;
    LIST_ENTRY HashLinks;
    ULONG TimeDateStamp;
    struct _ACTIVATION_CONTEXT *EntryPointActivationContext;
    PVOID Lock; // RtlAcquireSRWLockExclusive
    PLDR_DDAG_NODE DdagNode;
    LIST_ENTRY NodeModuleLink;
    struct _LDRP_LOAD_CONTEXT *LoadContext;
    PVOID ParentDllBase;
    PVOID SwitchBackContext;
    RTL_BALANCED_NODE BaseAddressIndexNode;
    RTL_BALANCED_NODE MappingInfoIndexNode;
    ULONG_PTR OriginalBase;
    LARGE_INTEGER LoadTime;
    ULONG BaseNameHashValue;
    LDR_DLL_LOAD_REASON LoadReason;
    ULONG ImplicitPathOptions;
    ULONG ReferenceCount;
    ULONG DependentLoadFlags;
    UCHAR SigningLevel; // since REDSTONE2
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;

#define LDR_IS_DATAFILE(DllHandle) (((ULONG_PTR)(DllHandle)) & (ULONG_PTR)1)
#define LDR_IS_IMAGEMAPPING(DllHandle) (((ULONG_PTR)(DllHandle)) & (ULONG_PTR)2)
#define LDR_IS_RESOURCE(DllHandle) (LDR_IS_IMAGEMAPPING(DllHandle) || LDR_IS_DATAFILE(DllHandle))

NTSYSAPI
NTSTATUS
NTAPI
LdrLoadDll(
    _In_opt_ PWSTR DllPath,
    _In_opt_ PULONG DllCharacteristics,
    _In_ PUNICODE_STRING DllName,
    _Out_ PVOID *DllHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
LdrUnloadDll(
    _In_ PVOID DllHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllHandle(
    _In_opt_ PWSTR DllPath,
    _In_opt_ PULONG DllCharacteristics,
    _In_ PUNICODE_STRING DllName,
    _Out_ PVOID *DllHandle
    );

#define LDR_GET_DLL_HANDLE_EX_UNCHANGED_REFCOUNT 0x00000001
#define LDR_GET_DLL_HANDLE_EX_PIN 0x00000002

NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllHandleEx(
    _In_ ULONG Flags,
    _In_opt_ PWSTR DllPath,
    _In_opt_ PULONG DllCharacteristics,
    _In_ PUNICODE_STRING DllName,
    _Out_opt_ PVOID *DllHandle
    );

#if (PHNT_VERSION >= PHNT_WIN7)
// rev
NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllHandleByMapping(
    _In_ PVOID BaseAddress,
    _Out_ PVOID *DllHandle
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN7)
// rev
NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllHandleByName(
    _In_opt_ PUNICODE_STRING BaseDllName,
    _In_opt_ PUNICODE_STRING FullDllName,
    _Out_ PVOID *DllHandle
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN8)
// rev
NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllFullName(
    _In_ PVOID DllHandle,
    _Out_ PUNICODE_STRING FullDllName
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllDirectory(
    _Out_ PUNICODE_STRING DllDirectory
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
LdrSetDllDirectory(
    _In_ PUNICODE_STRING DllDirectory
    );
#endif

#define LDR_ADDREF_DLL_PIN 0x00000001

NTSYSAPI
NTSTATUS
NTAPI
LdrAddRefDll(
    _In_ ULONG Flags,
    _In_ PVOID DllHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
LdrGetProcedureAddress(
    _In_ PVOID DllHandle,
    _In_opt_ PANSI_STRING ProcedureName,
    _In_opt_ ULONG ProcedureNumber,
    _Out_ PVOID *ProcedureAddress
    );

// rev
#define LDR_GET_PROCEDURE_ADDRESS_DONT_RECORD_FORWARDER 0x00000001

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
NTSTATUS
NTAPI
LdrGetProcedureAddressEx(
    _In_ PVOID DllHandle,
    _In_opt_ PANSI_STRING ProcedureName,
    _In_opt_ ULONG ProcedureNumber,
    _Out_ PVOID *ProcedureAddress,
    _In_ ULONG Flags
    );
#endif

NTSYSAPI
NTSTATUS
NTAPI
LdrGetKnownDllSectionHandle(
    _In_ PCWSTR DllName,
    _In_ BOOLEAN KnownDlls32,
    _Out_ PHANDLE Section
    );

#if (PHNT_VERSION >= PHNT_THRESHOLD)
// rev
NTSYSAPI
NTSTATUS
NTAPI
LdrGetProcedureAddressForCaller(
    _In_ PVOID DllHandle,
    _In_opt_ PANSI_STRING ProcedureName,
    _In_opt_ ULONG ProcedureNumber,
    _Out_ PVOID *ProcedureAddress,
    _In_ ULONG Flags,
    _In_ PVOID *Callback
    );
#endif

#define LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS 0x00000001
#define LDR_LOCK_LOADER_LOCK_FLAG_TRY_ONLY 0x00000002

#define LDR_LOCK_LOADER_LOCK_DISPOSITION_INVALID 0
#define LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_ACQUIRED 1
#define LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_NOT_ACQUIRED 2

NTSYSAPI
NTSTATUS
NTAPI
LdrLockLoaderLock(
    _In_ ULONG Flags,
    _Out_opt_ ULONG *Disposition,
    _Out_ PVOID *Cookie
    );

#define LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS 0x00000001

NTSYSAPI
NTSTATUS
NTAPI
LdrUnlockLoaderLock(
    _In_ ULONG Flags,
    _Inout_ PVOID Cookie
    );

NTSYSAPI
NTSTATUS
NTAPI
LdrRelocateImage(
    _In_ PVOID NewBase,
    _In_ PSTR LoaderName,
    _In_ NTSTATUS Success,
    _In_ NTSTATUS Conflict,
    _In_ NTSTATUS Invalid
    );

NTSYSAPI
NTSTATUS
NTAPI
LdrRelocateImageWithBias(
    _In_ PVOID NewBase,
    _In_ LONGLONG Bias,
    _In_ PSTR LoaderName,
    _In_ NTSTATUS Success,
    _In_ NTSTATUS Conflict,
    _In_ NTSTATUS Invalid
    );

NTSYSAPI
PIMAGE_BASE_RELOCATION
NTAPI
LdrProcessRelocationBlock(
    _In_ ULONG_PTR VA,
    _In_ ULONG SizeOfBlock,
    _In_ PUSHORT NextOffset,
    _In_ LONG_PTR Diff
    );

NTSYSAPI
BOOLEAN
NTAPI
LdrVerifyMappedImageMatchesChecksum(
    _In_ PVOID BaseAddress,
    _In_ SIZE_T NumberOfBytes,
    _In_ ULONG FileLength
    );

typedef VOID (NTAPI *PLDR_IMPORT_MODULE_CALLBACK)(
    _In_ PVOID Parameter,
    _In_ PSTR ModuleName
    );

NTSYSAPI
NTSTATUS
NTAPI
LdrVerifyImageMatchesChecksum(
    _In_ HANDLE ImageFileHandle,
    _In_opt_ PLDR_IMPORT_MODULE_CALLBACK ImportCallbackRoutine,
    _In_ PVOID ImportCallbackParameter,
    _Out_opt_ PUSHORT ImageCharacteristics
    );

// private
typedef struct _LDR_IMPORT_CALLBACK_INFO
{
    PLDR_IMPORT_MODULE_CALLBACK ImportCallbackRoutine;
    PVOID ImportCallbackParameter;
} LDR_IMPORT_CALLBACK_INFO, *PLDR_IMPORT_CALLBACK_INFO;

// private
typedef struct _LDR_SECTION_INFO
{
    HANDLE SectionHandle;
    ACCESS_MASK DesiredAccess;
    POBJECT_ATTRIBUTES ObjA;
    ULONG SectionPageProtection;
    ULONG AllocationAttributes;
} LDR_SECTION_INFO, *PLDR_SECTION_INFO;

// private
typedef struct _LDR_VERIFY_IMAGE_INFO
{
    ULONG Size;
    ULONG Flags;
    LDR_IMPORT_CALLBACK_INFO CallbackInfo;
    LDR_SECTION_INFO SectionInfo;
    USHORT ImageCharacteristics;
} LDR_VERIFY_IMAGE_INFO, *PLDR_VERIFY_IMAGE_INFO;

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
NTSTATUS
NTAPI
LdrVerifyImageMatchesChecksumEx(
    _In_ HANDLE ImageFileHandle,
    _Inout_ PLDR_VERIFY_IMAGE_INFO VerifyInfo
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
NTSTATUS
NTAPI
LdrQueryModuleServiceTags(
    _In_ PVOID DllHandle,
    _Out_writes_(*BufferSize) PULONG ServiceTagBuffer,
    _Inout_ PULONG BufferSize
    );
#endif

// begin_msdn:"DLL Load Notification"

#define LDR_DLL_NOTIFICATION_REASON_LOADED 1
#define LDR_DLL_NOTIFICATION_REASON_UNLOADED 2

typedef struct _LDR_DLL_LOADED_NOTIFICATION_DATA
{
    ULONG Flags;
    PUNICODE_STRING FullDllName;
    PUNICODE_STRING BaseDllName;
    PVOID DllBase;
    ULONG SizeOfImage;
} LDR_DLL_LOADED_NOTIFICATION_DATA, *PLDR_DLL_LOADED_NOTIFICATION_DATA;

typedef struct _LDR_DLL_UNLOADED_NOTIFICATION_DATA
{
    ULONG Flags;
    PCUNICODE_STRING FullDllName;
    PCUNICODE_STRING BaseDllName;
    PVOID DllBase;
    ULONG SizeOfImage;
} LDR_DLL_UNLOADED_NOTIFICATION_DATA, *PLDR_DLL_UNLOADED_NOTIFICATION_DATA;

typedef union _LDR_DLL_NOTIFICATION_DATA
{
    LDR_DLL_LOADED_NOTIFICATION_DATA Loaded;
    LDR_DLL_UNLOADED_NOTIFICATION_DATA Unloaded;
} LDR_DLL_NOTIFICATION_DATA, *PLDR_DLL_NOTIFICATION_DATA;

typedef VOID (NTAPI *PLDR_DLL_NOTIFICATION_FUNCTION)(
    _In_ ULONG NotificationReason,
    _In_ PLDR_DLL_NOTIFICATION_DATA NotificationData,
    _In_opt_ PVOID Context
    );

#if (PHNT_VERSION >= PHNT_VISTA)

NTSYSAPI
NTSTATUS
NTAPI
LdrRegisterDllNotification(
    _In_ ULONG Flags,
    _In_ PLDR_DLL_NOTIFICATION_FUNCTION NotificationFunction,
    _In_ PVOID Context,
    _Out_ PVOID *Cookie
    );

NTSYSAPI
NTSTATUS
NTAPI
LdrUnregisterDllNotification(
    _In_ PVOID Cookie
    );

#endif

// end_msdn

// rev
NTSYSAPI
PUNICODE_STRING
NTAPI
LdrStandardizeSystemPath(
    _In_ PUNICODE_STRING SystemPath
    );

// private
typedef struct _PS_MITIGATION_OPTIONS_MAP
{
    ULONG_PTR Map[2];
} PS_MITIGATION_OPTIONS_MAP, *PPS_MITIGATION_OPTIONS_MAP;

// private
typedef struct _PS_MITIGATION_AUDIT_OPTIONS_MAP
{
    ULONG_PTR Map[2];
} PS_MITIGATION_AUDIT_OPTIONS_MAP, *PPS_MITIGATION_AUDIT_OPTIONS_MAP;

// private
typedef struct _PS_SYSTEM_DLL_INIT_BLOCK
{
    ULONG Size;
    ULONG_PTR SystemDllWowRelocation;
    ULONG_PTR SystemDllNativeRelocation;
    ULONG_PTR Wow64SharedInformation[16];
    ULONG RngData;
    union
    {
        ULONG Flags;
        struct
        {
            ULONG CfgOverride : 1;
            ULONG Reserved : 31;
        };
    };
    PS_MITIGATION_OPTIONS_MAP MitigationOptionsMap;
    ULONG_PTR CfgBitMap;
    ULONG_PTR CfgBitMapSize;
    ULONG_PTR Wow64CfgBitMap;
    ULONG_PTR Wow64CfgBitMapSize;
    PS_MITIGATION_AUDIT_OPTIONS_MAP MitigationAuditOptionsMap; // REDSTONE3
} PS_SYSTEM_DLL_INIT_BLOCK, *PPS_SYSTEM_DLL_INIT_BLOCK;

#if (PHNT_VERSION >= PHNT_THRESHOLD)
// rev
NTSYSAPI
PPS_SYSTEM_DLL_INIT_BLOCK
NTAPI
LdrSystemDllInitBlock(
    VOID
    );
#endif

// Load as data table

#if (PHNT_VERSION >= PHNT_VISTA)

// private
NTSYSAPI
NTSTATUS
NTAPI
LdrAddLoadAsDataTable(
    _In_ PVOID Module,
    _In_ PWSTR FilePath,
    _In_ SIZE_T Size,
    _In_ HANDLE Handle
    );

// private
NTSYSAPI
NTSTATUS
NTAPI
LdrRemoveLoadAsDataTable(
    _In_ PVOID InitModule,
    _Out_opt_ PVOID *BaseModule,
    _Out_opt_ PSIZE_T Size,
    _In_ ULONG Flags
    );

// private
NTSYSAPI
NTSTATUS
NTAPI
LdrGetFileNameFromLoadAsDataTable(
    _In_ PVOID Module,
    _Out_ PVOID *pFileNamePrt
    );

#endif

NTSYSAPI
NTSTATUS 
NTAPI 
LdrDisableThreadCalloutsForDll(
    _In_ PVOID DllImageBase
    );
    
// Resources

NTSYSAPI
NTSTATUS
NTAPI
LdrAccessResource(
    _In_ PVOID DllHandle,
    _In_ PIMAGE_RESOURCE_DATA_ENTRY ResourceDataEntry,
    _Out_opt_ PVOID *ResourceBuffer,
    _Out_opt_ ULONG *ResourceLength
    );

typedef struct _LDR_RESOURCE_INFO
{
    ULONG_PTR Type;
    ULONG_PTR Name;
    ULONG_PTR Language;
} LDR_RESOURCE_INFO, *PLDR_RESOURCE_INFO;

#define RESOURCE_TYPE_LEVEL 0
#define RESOURCE_NAME_LEVEL 1
#define RESOURCE_LANGUAGE_LEVEL 2
#define RESOURCE_DATA_LEVEL 3

NTSYSAPI
NTSTATUS
NTAPI
LdrFindResource_U(
    _In_ PVOID DllHandle,
    _In_ PLDR_RESOURCE_INFO ResourceInfo,
    _In_ ULONG Level,
    _Out_ PIMAGE_RESOURCE_DATA_ENTRY *ResourceDataEntry
    );

NTSYSAPI
NTSTATUS
NTAPI
LdrFindResourceDirectory_U(
    _In_ PVOID DllHandle,
    _In_ PLDR_RESOURCE_INFO ResourceInfo,
    _In_ ULONG Level,
    _Out_ PIMAGE_RESOURCE_DIRECTORY *ResourceDirectory
    );

// private 
typedef struct _LDR_ENUM_RESOURCE_ENTRY
{
    union
    {
        ULONG_PTR NameOrId;
        PIMAGE_RESOURCE_DIRECTORY_STRING Name;
        struct
        {
            USHORT Id;
            USHORT NameIsPresent;
        };
    } Path[3];
    PVOID Data;
    ULONG Size;
    ULONG Reserved;
} LDR_ENUM_RESOURCE_ENTRY, *PLDR_ENUM_RESOURCE_ENTRY;

#define NAME_FROM_RESOURCE_ENTRY(RootDirectory, Entry) \
    ((Entry)->NameIsString ? (ULONG_PTR)PTR_ADD_OFFSET((RootDirectory), (Entry)->NameOffset) : (Entry)->Id)

NTSYSAPI
NTSTATUS
NTAPI
LdrEnumResources(
    _In_ PVOID DllHandle,
    _In_ PLDR_RESOURCE_INFO ResourceInfo,
    _In_ ULONG Level,
    _Inout_ ULONG *ResourceCount,
    _Out_writes_to_opt_(*ResourceCount, *ResourceCount) PLDR_ENUM_RESOURCE_ENTRY Resources
    );

NTSYSAPI
NTSTATUS
NTAPI
LdrFindEntryForAddress(
    _In_ PVOID DllHandle,
    _Out_ PLDR_DATA_TABLE_ENTRY *Entry
    );

#endif // (PHNT_MODE != PHNT_MODE_KERNEL)

// Module information

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
    HANDLE Section;
    PVOID MappedBase;
    PVOID ImageBase;
    ULONG ImageSize;
    ULONG Flags;
    USHORT LoadOrderIndex;
    USHORT InitOrderIndex;
    USHORT LoadCount;
    USHORT OffsetToFileName;
    UCHAR FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
    ULONG NumberOfModules;
    RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;

// private
typedef struct _RTL_PROCESS_MODULE_INFORMATION_EX
{
    USHORT NextOffset;
    RTL_PROCESS_MODULE_INFORMATION BaseInfo;
    ULONG ImageChecksum;
    ULONG TimeDateStamp;
    PVOID DefaultBase;
} RTL_PROCESS_MODULE_INFORMATION_EX, *PRTL_PROCESS_MODULE_INFORMATION_EX;

#if (PHNT_MODE != PHNT_MODE_KERNEL)

NTSYSAPI
NTSTATUS
NTAPI
LdrQueryProcessModuleInformation(
    _In_opt_ PRTL_PROCESS_MODULES ModuleInformation,
    _In_opt_ ULONG Size,
    _Out_ PULONG ReturnedSize
    );

typedef VOID (NTAPI *PLDR_ENUM_CALLBACK)(
    _In_ PLDR_DATA_TABLE_ENTRY ModuleInformation, 
    _In_ PVOID Parameter, 
    _Out_ BOOLEAN *Stop
    );

NTSYSAPI
NTSTATUS
NTAPI
LdrEnumerateLoadedModules(
    _In_ BOOLEAN ReservedFlag,
    _In_ PLDR_ENUM_CALLBACK EnumProc,
    _In_ PVOID Context
    );

NTSYSAPI
NTSTATUS
NTAPI
LdrOpenImageFileOptionsKey(
    _In_ PUNICODE_STRING SubKey,
    _In_ BOOLEAN Wow64,
    _Out_ PHANDLE NewKeyHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
LdrQueryImageFileKeyOption(
    _In_ HANDLE KeyHandle,
    _In_ PCWSTR ValueName,
    _In_ ULONG Type,
    _Out_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG ReturnedLength
    );

NTSYSAPI
NTSTATUS
NTAPI
LdrQueryImageFileExecutionOptions(
    _In_ PUNICODE_STRING SubKey,
    _In_ PCWSTR ValueName,
    _In_ ULONG ValueSize,
    _Out_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG ReturnedLength
    );

NTSYSAPI
NTSTATUS
NTAPI
LdrQueryImageFileExecutionOptionsEx(
    _In_ PUNICODE_STRING SubKey,
    _In_ PCWSTR ValueName,
    _In_ ULONG Type,
    _Out_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG ReturnedLength,
    _In_ BOOLEAN Wow64
    );

// private
typedef struct _DELAYLOAD_PROC_DESCRIPTOR
{
    ULONG ImportDescribedByName;
    union
    {
        PCSTR Name;
        ULONG Ordinal;
    } Description;
} DELAYLOAD_PROC_DESCRIPTOR, *PDELAYLOAD_PROC_DESCRIPTOR;

// private
typedef struct _DELAYLOAD_INFO
{
    ULONG Size;
    PCIMAGE_DELAYLOAD_DESCRIPTOR DelayloadDescriptor;
    PIMAGE_THUNK_DATA ThunkAddress;
    PCSTR TargetDllName;
    DELAYLOAD_PROC_DESCRIPTOR TargetApiDescriptor;
    PVOID TargetModuleBase;
    PVOID Unused;
    ULONG LastError;
} DELAYLOAD_INFO, *PDELAYLOAD_INFO;

// private
typedef PVOID (NTAPI *PDELAYLOAD_FAILURE_DLL_CALLBACK)(
    _In_ ULONG NotificationReason,
    _In_ PDELAYLOAD_INFO DelayloadInfo
    );

// rev
typedef PVOID (NTAPI *PDELAYLOAD_FAILURE_SYSTEM_ROUTINE)(
    _In_ PCSTR DllName,
    _In_ PCSTR ProcName
    );

// rev
NTSYSAPI
PVOID
NTAPI
LdrResolveDelayLoadedAPI(
    _In_ PVOID ParentModuleBase,
    _In_ PCIMAGE_DELAYLOAD_DESCRIPTOR DelayloadDescriptor,
    _In_opt_ PDELAYLOAD_FAILURE_DLL_CALLBACK FailureDllHook,
    _In_opt_ PDELAYLOAD_FAILURE_SYSTEM_ROUTINE FailureSystemHook, // kernel32.DelayLoadFailureHook
    _Out_ PIMAGE_THUNK_DATA ThunkAddress,
    _Reserved_ ULONG Flags
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
LdrResolveDelayLoadsFromDll(
    _In_ PVOID ParentBase,
    _In_ PCSTR TargetDllName,
    _Reserved_ ULONG Flags
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
LdrSetDefaultDllDirectories(
    _In_ ULONG DirectoryFlags
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
LdrShutdownProcess(
    VOID
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
LdrShutdownThread(
    VOID
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
LdrSetImplicitPathOptions(
    _In_ ULONG ImplicitPathOptions
    );

// rev
NTSYSAPI
BOOLEAN
NTAPI
LdrControlFlowGuardEnforced(
    VOID
    );

#if (PHNT_VERSION >= PHNT_19H1)
// rev
NTSYSAPI
BOOLEAN
NTAPI
LdrIsModuleSxsRedirected(
    _In_ PVOID DllHandle
    );
#endif

#endif // (PHNT_MODE != PHNT_MODE_KERNEL)

#endif

```

`phnt/ntlpcapi.h`:

```h
#ifndef _NTLPCAPI_H
#define _NTLPCAPI_H

// Local Inter-process Communication

#define PORT_CONNECT 0x0001
#define PORT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x1)

typedef struct _PORT_MESSAGE
{
    union
    {
        struct
        {
            CSHORT DataLength;
            CSHORT TotalLength;
        } s1;
        ULONG Length;
    } u1;
    union
    {
        struct
        {
            CSHORT Type;
            CSHORT DataInfoOffset;
        } s2;
        ULONG ZeroInit;
    } u2;
    union
    {
        CLIENT_ID ClientId;
        double DoNotUseThisField;
    };
    ULONG MessageId;
    union
    {
        SIZE_T ClientViewSize; // only valid for LPC_CONNECTION_REQUEST messages
        ULONG CallbackId; // only valid for LPC_REQUEST messages
    };
} PORT_MESSAGE, *PPORT_MESSAGE;

typedef struct _PORT_DATA_ENTRY
{
    PVOID Base;
    ULONG Size;
} PORT_DATA_ENTRY, *PPORT_DATA_ENTRY;

typedef struct _PORT_DATA_INFORMATION
{
    ULONG CountDataEntries;
    PORT_DATA_ENTRY DataEntries[1];
} PORT_DATA_INFORMATION, *PPORT_DATA_INFORMATION;

#define LPC_REQUEST 1
#define LPC_REPLY 2
#define LPC_DATAGRAM 3
#define LPC_LOST_REPLY 4
#define LPC_PORT_CLOSED 5
#define LPC_CLIENT_DIED 6
#define LPC_EXCEPTION 7
#define LPC_DEBUG_EVENT 8
#define LPC_ERROR_EVENT 9
#define LPC_CONNECTION_REQUEST 10

#define LPC_KERNELMODE_MESSAGE (CSHORT)0x8000
#define LPC_NO_IMPERSONATE (CSHORT)0x4000

#define PORT_VALID_OBJECT_ATTRIBUTES OBJ_CASE_INSENSITIVE

#ifdef _WIN64
#define PORT_MAXIMUM_MESSAGE_LENGTH 512
#else
#define PORT_MAXIMUM_MESSAGE_LENGTH 256
#endif

#define LPC_MAX_CONNECTION_INFO_SIZE (16 * sizeof(ULONG_PTR))

#define PORT_TOTAL_MAXIMUM_MESSAGE_LENGTH \
    ((PORT_MAXIMUM_MESSAGE_LENGTH + sizeof(PORT_MESSAGE) + LPC_MAX_CONNECTION_INFO_SIZE + 0xf) & ~0xf)

typedef struct _LPC_CLIENT_DIED_MSG
{
    PORT_MESSAGE PortMsg;
    LARGE_INTEGER CreateTime;
} LPC_CLIENT_DIED_MSG, *PLPC_CLIENT_DIED_MSG;

typedef struct _PORT_VIEW
{
    ULONG Length;
    HANDLE SectionHandle;
    ULONG SectionOffset;
    SIZE_T ViewSize;
    PVOID ViewBase;
    PVOID ViewRemoteBase;
} PORT_VIEW, *PPORT_VIEW;

typedef struct _REMOTE_PORT_VIEW
{
    ULONG Length;
    SIZE_T ViewSize;
    PVOID ViewBase;
} REMOTE_PORT_VIEW, *PREMOTE_PORT_VIEW;

// WOW64 definitions

// Except in a small number of special cases, WOW64 programs using the LPC APIs must use the 64-bit versions of the
// PORT_MESSAGE, PORT_VIEW and REMOTE_PORT_VIEW data structures. Note that we take a different approach than the
// official NT headers, which produce 64-bit versions in a 32-bit environment when USE_LPC6432 is defined.

typedef struct _PORT_MESSAGE64
{
    union
    {
        struct
        {
            CSHORT DataLength;
            CSHORT TotalLength;
        } s1;
        ULONG Length;
    } u1;
    union
    {
        struct
        {
            CSHORT Type;
            CSHORT DataInfoOffset;
        } s2;
        ULONG ZeroInit;
    } u2;
    union
    {
        CLIENT_ID64 ClientId;
        double DoNotUseThisField;
    };
    ULONG MessageId;
    union
    {
        ULONGLONG ClientViewSize; // only valid for LPC_CONNECTION_REQUEST messages
        ULONG CallbackId; // only valid for LPC_REQUEST messages
    };
} PORT_MESSAGE64, *PPORT_MESSAGE64;

typedef struct _LPC_CLIENT_DIED_MSG64
{
    PORT_MESSAGE64 PortMsg;
    LARGE_INTEGER CreateTime;
} LPC_CLIENT_DIED_MSG64, *PLPC_CLIENT_DIED_MSG64;

typedef struct _PORT_VIEW64
{
    ULONG Length;
    ULONGLONG SectionHandle;
    ULONG SectionOffset;
    ULONGLONG ViewSize;
    ULONGLONG ViewBase;
    ULONGLONG ViewRemoteBase;
} PORT_VIEW64, *PPORT_VIEW64;

typedef struct _REMOTE_PORT_VIEW64
{
    ULONG Length;
    ULONGLONG ViewSize;
    ULONGLONG ViewBase;
} REMOTE_PORT_VIEW64, *PREMOTE_PORT_VIEW64;

// Port creation

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreatePort(
    _Out_ PHANDLE PortHandle,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG MaxConnectionInfoLength,
    _In_ ULONG MaxMessageLength,
    _In_opt_ ULONG MaxPoolUsage
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateWaitablePort(
    _Out_ PHANDLE PortHandle,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG MaxConnectionInfoLength,
    _In_ ULONG MaxMessageLength,
    _In_opt_ ULONG MaxPoolUsage
    );

// Port connection (client)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtConnectPort(
    _Out_ PHANDLE PortHandle,
    _In_ PUNICODE_STRING PortName,
    _In_ PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    _Inout_opt_ PPORT_VIEW ClientView,
    _Inout_opt_ PREMOTE_PORT_VIEW ServerView,
    _Out_opt_ PULONG MaxMessageLength,
    _Inout_updates_bytes_to_opt_(*ConnectionInformationLength, *ConnectionInformationLength) PVOID ConnectionInformation,
    _Inout_opt_ PULONG ConnectionInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSecureConnectPort(
    _Out_ PHANDLE PortHandle,
    _In_ PUNICODE_STRING PortName,
    _In_ PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    _Inout_opt_ PPORT_VIEW ClientView,
    _In_opt_ PSID RequiredServerSid,
    _Inout_opt_ PREMOTE_PORT_VIEW ServerView,
    _Out_opt_ PULONG MaxMessageLength,
    _Inout_updates_bytes_to_opt_(*ConnectionInformationLength, *ConnectionInformationLength) PVOID ConnectionInformation,
    _Inout_opt_ PULONG ConnectionInformationLength
    );

// Port connection (server)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtListenPort(
    _In_ HANDLE PortHandle,
    _Out_ PPORT_MESSAGE ConnectionRequest
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAcceptConnectPort(
    _Out_ PHANDLE PortHandle,
    _In_opt_ PVOID PortContext,
    _In_ PPORT_MESSAGE ConnectionRequest,
    _In_ BOOLEAN AcceptConnection,
    _Inout_opt_ PPORT_VIEW ServerView,
    _Out_opt_ PREMOTE_PORT_VIEW ClientView
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCompleteConnectPort(
    _In_ HANDLE PortHandle
    );

// General

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRequestPort(
    _In_ HANDLE PortHandle,
    _In_reads_bytes_(RequestMessage->u1.s1.TotalLength) PPORT_MESSAGE RequestMessage
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRequestWaitReplyPort(
    _In_ HANDLE PortHandle,
    _In_reads_bytes_(RequestMessage->u1.s1.TotalLength) PPORT_MESSAGE RequestMessage,
    _Out_ PPORT_MESSAGE ReplyMessage
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReplyPort(
    _In_ HANDLE PortHandle,
    _In_reads_bytes_(ReplyMessage->u1.s1.TotalLength) PPORT_MESSAGE ReplyMessage
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReplyWaitReplyPort(
    _In_ HANDLE PortHandle,
    _Inout_ PPORT_MESSAGE ReplyMessage
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReplyWaitReceivePort(
    _In_ HANDLE PortHandle,
    _Out_opt_ PVOID *PortContext,
    _In_reads_bytes_opt_(ReplyMessage->u1.s1.TotalLength) PPORT_MESSAGE ReplyMessage,
    _Out_ PPORT_MESSAGE ReceiveMessage
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReplyWaitReceivePortEx(
    _In_ HANDLE PortHandle,
    _Out_opt_ PVOID *PortContext,
    _In_reads_bytes_opt_(ReplyMessage->u1.s1.TotalLength) PPORT_MESSAGE ReplyMessage,
    _Out_ PPORT_MESSAGE ReceiveMessage,
    _In_opt_ PLARGE_INTEGER Timeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtImpersonateClientOfPort(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE Message
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReadRequestData(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE Message,
    _In_ ULONG DataEntryIndex,
    _Out_writes_bytes_to_(BufferSize, *NumberOfBytesRead) PVOID Buffer,
    _In_ SIZE_T BufferSize,
    _Out_opt_ PSIZE_T NumberOfBytesRead
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWriteRequestData(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE Message,
    _In_ ULONG DataEntryIndex,
    _In_reads_bytes_(BufferSize) PVOID Buffer,
    _In_ SIZE_T BufferSize,
    _Out_opt_ PSIZE_T NumberOfBytesWritten
    );

typedef enum _PORT_INFORMATION_CLASS
{
    PortBasicInformation,
    PortDumpInformation
} PORT_INFORMATION_CLASS;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationPort(
    _In_ HANDLE PortHandle,
    _In_ PORT_INFORMATION_CLASS PortInformationClass,
    _Out_writes_bytes_to_(Length, *ReturnLength) PVOID PortInformation,
    _In_ ULONG Length,
    _Out_opt_ PULONG ReturnLength
    );

// Asynchronous Local Inter-process Communication

// rev
typedef HANDLE ALPC_HANDLE, *PALPC_HANDLE;

#define ALPC_PORFLG_ALLOW_LPC_REQUESTS 0x20000 // rev
#define ALPC_PORFLG_WAITABLE_PORT 0x40000 // dbg
#define ALPC_PORFLG_SYSTEM_PROCESS 0x100000 // dbg

// symbols
typedef struct _ALPC_PORT_ATTRIBUTES
{
    ULONG Flags;
    SECURITY_QUALITY_OF_SERVICE SecurityQos;
    SIZE_T MaxMessageLength;
    SIZE_T MemoryBandwidth;
    SIZE_T MaxPoolUsage;
    SIZE_T MaxSectionSize;
    SIZE_T MaxViewSize;
    SIZE_T MaxTotalSectionSize;
    ULONG DupObjectTypes;
#ifdef _WIN64
    ULONG Reserved;
#endif
} ALPC_PORT_ATTRIBUTES, *PALPC_PORT_ATTRIBUTES;

// begin_rev
#define ALPC_MESSAGE_SECURITY_ATTRIBUTE 0x80000000
#define ALPC_MESSAGE_VIEW_ATTRIBUTE 0x40000000
#define ALPC_MESSAGE_CONTEXT_ATTRIBUTE 0x20000000
#define ALPC_MESSAGE_HANDLE_ATTRIBUTE 0x10000000
// end_rev

// symbols
typedef struct _ALPC_MESSAGE_ATTRIBUTES
{
    ULONG AllocatedAttributes;
    ULONG ValidAttributes;
} ALPC_MESSAGE_ATTRIBUTES, *PALPC_MESSAGE_ATTRIBUTES;

// symbols
typedef struct _ALPC_COMPLETION_LIST_STATE
{
    union
    {
        struct
        {
            ULONG64 Head : 24;
            ULONG64 Tail : 24;
            ULONG64 ActiveThreadCount : 16;
        } s1;
        ULONG64 Value;
    } u1;
} ALPC_COMPLETION_LIST_STATE, *PALPC_COMPLETION_LIST_STATE;

#define ALPC_COMPLETION_LIST_BUFFER_GRANULARITY_MASK 0x3f // dbg

// symbols
typedef struct DECLSPEC_ALIGN(128) _ALPC_COMPLETION_LIST_HEADER
{
    ULONG64 StartMagic;

    ULONG TotalSize;
    ULONG ListOffset;
    ULONG ListSize;
    ULONG BitmapOffset;
    ULONG BitmapSize;
    ULONG DataOffset;
    ULONG DataSize;
    ULONG AttributeFlags;
    ULONG AttributeSize;

    DECLSPEC_ALIGN(128) ALPC_COMPLETION_LIST_STATE State;
    ULONG LastMessageId;
    ULONG LastCallbackId;
    DECLSPEC_ALIGN(128) ULONG PostCount;
    DECLSPEC_ALIGN(128) ULONG ReturnCount;
    DECLSPEC_ALIGN(128) ULONG LogSequenceNumber;
    DECLSPEC_ALIGN(128) RTL_SRWLOCK UserLock;

    ULONG64 EndMagic;
} ALPC_COMPLETION_LIST_HEADER, *PALPC_COMPLETION_LIST_HEADER;

// private
typedef struct _ALPC_CONTEXT_ATTR
{
    PVOID PortContext;
    PVOID MessageContext;
    ULONG Sequence;
    ULONG MessageId;
    ULONG CallbackId;
} ALPC_CONTEXT_ATTR, *PALPC_CONTEXT_ATTR;

// begin_rev
#define ALPC_HANDLEFLG_DUPLICATE_SAME_ACCESS 0x10000
#define ALPC_HANDLEFLG_DUPLICATE_SAME_ATTRIBUTES 0x20000
#define ALPC_HANDLEFLG_DUPLICATE_INHERIT 0x80000
// end_rev

// private
typedef struct _ALPC_HANDLE_ATTR32
{
    ULONG Flags;
    ULONG Reserved0;
    ULONG SameAccess;
    ULONG SameAttributes;
    ULONG Indirect;
    ULONG Inherit;
    ULONG Reserved1;
    ULONG Handle;
    ULONG ObjectType; // ObjectTypeCode, not ObjectTypeIndex
    ULONG DesiredAccess;
    ULONG GrantedAccess;
} ALPC_HANDLE_ATTR32, *PALPC_HANDLE_ATTR32;

// private
typedef struct _ALPC_HANDLE_ATTR
{
    ULONG Flags;
    ULONG Reserved0;
    ULONG SameAccess;
    ULONG SameAttributes;
    ULONG Indirect;
    ULONG Inherit;
    ULONG Reserved1;
    HANDLE Handle;
    PALPC_HANDLE_ATTR32 HandleAttrArray;
    ULONG ObjectType; // ObjectTypeCode, not ObjectTypeIndex
    ULONG HandleCount;
    ACCESS_MASK DesiredAccess;
    ACCESS_MASK GrantedAccess;
} ALPC_HANDLE_ATTR, *PALPC_HANDLE_ATTR;

#define ALPC_SECFLG_CREATE_HANDLE 0x20000 // dbg
#define ALPC_SECFLG_NOSECTIONHANDLE 0x40000
// private
typedef struct _ALPC_SECURITY_ATTR
{
    ULONG Flags;
    PSECURITY_QUALITY_OF_SERVICE QoS;
    ALPC_HANDLE ContextHandle; // dbg
} ALPC_SECURITY_ATTR, *PALPC_SECURITY_ATTR;

// begin_rev
#define ALPC_VIEWFLG_NOT_SECURE 0x40000
// end_rev

// private
typedef struct _ALPC_DATA_VIEW_ATTR
{
    ULONG Flags;
    ALPC_HANDLE SectionHandle;
    PVOID ViewBase; // must be zero on input
    SIZE_T ViewSize;
} ALPC_DATA_VIEW_ATTR, *PALPC_DATA_VIEW_ATTR;

// private
typedef enum _ALPC_PORT_INFORMATION_CLASS
{
    AlpcBasicInformation, // q: out ALPC_BASIC_INFORMATION
    AlpcPortInformation, // s: in ALPC_PORT_ATTRIBUTES
    AlpcAssociateCompletionPortInformation, // s: in ALPC_PORT_ASSOCIATE_COMPLETION_PORT
    AlpcConnectedSIDInformation, // q: in SID
    AlpcServerInformation, // q: inout ALPC_SERVER_INFORMATION
    AlpcMessageZoneInformation, // s: in ALPC_PORT_MESSAGE_ZONE_INFORMATION
    AlpcRegisterCompletionListInformation, // s: in ALPC_PORT_COMPLETION_LIST_INFORMATION
    AlpcUnregisterCompletionListInformation, // s: VOID
    AlpcAdjustCompletionListConcurrencyCountInformation, // s: in ULONG
    AlpcRegisterCallbackInformation, // kernel-mode only
    AlpcCompletionListRundownInformation, // s: VOID
    AlpcWaitForPortReferences
} ALPC_PORT_INFORMATION_CLASS;

// private
typedef struct _ALPC_BASIC_INFORMATION
{
    ULONG Flags;
    ULONG SequenceNo;
    PVOID PortContext;
} ALPC_BASIC_INFORMATION, *PALPC_BASIC_INFORMATION;

// private
typedef struct _ALPC_PORT_ASSOCIATE_COMPLETION_PORT
{
    PVOID CompletionKey;
    HANDLE CompletionPort;
} ALPC_PORT_ASSOCIATE_COMPLETION_PORT, *PALPC_PORT_ASSOCIATE_COMPLETION_PORT;

// private
typedef struct _ALPC_SERVER_INFORMATION
{
    union
    {
        struct
        {
            HANDLE ThreadHandle;
        } In;
        struct
        {
            BOOLEAN ThreadBlocked;
            HANDLE ConnectedProcessId;
            UNICODE_STRING ConnectionPortName;
        } Out;
    };
} ALPC_SERVER_INFORMATION, *PALPC_SERVER_INFORMATION;

// private
typedef struct _ALPC_PORT_MESSAGE_ZONE_INFORMATION
{
    PVOID Buffer;
    ULONG Size;
} ALPC_PORT_MESSAGE_ZONE_INFORMATION, *PALPC_PORT_MESSAGE_ZONE_INFORMATION;

// private
typedef struct _ALPC_PORT_COMPLETION_LIST_INFORMATION
{
    PVOID Buffer; // PALPC_COMPLETION_LIST_HEADER
    ULONG Size;
    ULONG ConcurrencyCount;
    ULONG AttributeFlags;
} ALPC_PORT_COMPLETION_LIST_INFORMATION, *PALPC_PORT_COMPLETION_LIST_INFORMATION;

// private
typedef enum _ALPC_MESSAGE_INFORMATION_CLASS
{
    AlpcMessageSidInformation, // q: out SID
    AlpcMessageTokenModifiedIdInformation,  // q: out LUID
    AlpcMessageDirectStatusInformation,
    AlpcMessageHandleInformation, // ALPC_MESSAGE_HANDLE_INFORMATION
    MaxAlpcMessageInfoClass
} ALPC_MESSAGE_INFORMATION_CLASS, *PALPC_MESSAGE_INFORMATION_CLASS;

typedef struct _ALPC_MESSAGE_HANDLE_INFORMATION
{
    ULONG Index;
    ULONG Flags;
    ULONG Handle;
    ULONG ObjectType;
    ACCESS_MASK GrantedAccess;
} ALPC_MESSAGE_HANDLE_INFORMATION, *PALPC_MESSAGE_HANDLE_INFORMATION;

// begin_private

#if (PHNT_VERSION >= PHNT_VISTA)

// System calls

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcCreatePort(
    _Out_ PHANDLE PortHandle,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PALPC_PORT_ATTRIBUTES PortAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcDisconnectPort(
    _In_ HANDLE PortHandle,
    _In_ ULONG Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcQueryInformation(
    _In_opt_ HANDLE PortHandle,
    _In_ ALPC_PORT_INFORMATION_CLASS PortInformationClass,
    _Inout_updates_bytes_to_(Length, *ReturnLength) PVOID PortInformation,
    _In_ ULONG Length,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcSetInformation(
    _In_ HANDLE PortHandle,
    _In_ ALPC_PORT_INFORMATION_CLASS PortInformationClass,
    _In_reads_bytes_opt_(Length) PVOID PortInformation,
    _In_ ULONG Length
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcCreatePortSection(
    _In_ HANDLE PortHandle,
    _In_ ULONG Flags,
    _In_opt_ HANDLE SectionHandle,
    _In_ SIZE_T SectionSize,
    _Out_ PALPC_HANDLE AlpcSectionHandle,
    _Out_ PSIZE_T ActualSectionSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcDeletePortSection(
    _In_ HANDLE PortHandle,
    _Reserved_ ULONG Flags,
    _In_ ALPC_HANDLE SectionHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcCreateResourceReserve(
    _In_ HANDLE PortHandle,
    _Reserved_ ULONG Flags,
    _In_ SIZE_T MessageSize,
    _Out_ PALPC_HANDLE ResourceId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcDeleteResourceReserve(
    _In_ HANDLE PortHandle,
    _Reserved_ ULONG Flags,
    _In_ ALPC_HANDLE ResourceId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcCreateSectionView(
    _In_ HANDLE PortHandle,
    _Reserved_ ULONG Flags,
    _Inout_ PALPC_DATA_VIEW_ATTR ViewAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcDeleteSectionView(
    _In_ HANDLE PortHandle,
    _Reserved_ ULONG Flags,
    _In_ PVOID ViewBase
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcCreateSecurityContext(
    _In_ HANDLE PortHandle,
    _Reserved_ ULONG Flags,
    _Inout_ PALPC_SECURITY_ATTR SecurityAttribute
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcDeleteSecurityContext(
    _In_ HANDLE PortHandle,
    _Reserved_ ULONG Flags,
    _In_ ALPC_HANDLE ContextHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcRevokeSecurityContext(
    _In_ HANDLE PortHandle,
    _Reserved_ ULONG Flags,
    _In_ ALPC_HANDLE ContextHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcQueryInformationMessage(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE PortMessage,
    _In_ ALPC_MESSAGE_INFORMATION_CLASS MessageInformationClass,
    _Out_writes_bytes_to_opt_(Length, *ReturnLength) PVOID MessageInformation,
    _In_ ULONG Length,
    _Out_opt_ PULONG ReturnLength
    );

#define ALPC_MSGFLG_REPLY_MESSAGE 0x1
#define ALPC_MSGFLG_LPC_MODE 0x2 // ?
#define ALPC_MSGFLG_RELEASE_MESSAGE 0x10000 // dbg
#define ALPC_MSGFLG_SYNC_REQUEST 0x20000 // dbg
#define ALPC_MSGFLG_WAIT_USER_MODE 0x100000
#define ALPC_MSGFLG_WAIT_ALERTABLE 0x200000
#define ALPC_MSGFLG_WOW64_CALL 0x80000000 // dbg

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcConnectPort(
    _Out_ PHANDLE PortHandle,
    _In_ PUNICODE_STRING PortName,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PALPC_PORT_ATTRIBUTES PortAttributes,
    _In_ ULONG Flags,
    _In_opt_ PSID RequiredServerSid,
    _Inout_updates_bytes_to_opt_(*BufferLength, *BufferLength) PPORT_MESSAGE ConnectionMessage,
    _Inout_opt_ PULONG BufferLength,
    _Inout_opt_ PALPC_MESSAGE_ATTRIBUTES OutMessageAttributes,
    _Inout_opt_ PALPC_MESSAGE_ATTRIBUTES InMessageAttributes,
    _In_opt_ PLARGE_INTEGER Timeout
    );

#if (PHNT_VERSION >= PHNT_WIN8)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcConnectPortEx(
    _Out_ PHANDLE PortHandle,
    _In_ POBJECT_ATTRIBUTES ConnectionPortObjectAttributes,
    _In_opt_ POBJECT_ATTRIBUTES ClientPortObjectAttributes,
    _In_opt_ PALPC_PORT_ATTRIBUTES PortAttributes,
    _In_ ULONG Flags,
    _In_opt_ PSECURITY_DESCRIPTOR ServerSecurityRequirements,
    _Inout_updates_bytes_to_opt_(*BufferLength, *BufferLength) PPORT_MESSAGE ConnectionMessage,
    _Inout_opt_ PSIZE_T BufferLength,
    _Inout_opt_ PALPC_MESSAGE_ATTRIBUTES OutMessageAttributes,
    _Inout_opt_ PALPC_MESSAGE_ATTRIBUTES InMessageAttributes,
    _In_opt_ PLARGE_INTEGER Timeout
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcAcceptConnectPort(
    _Out_ PHANDLE PortHandle,
    _In_ HANDLE ConnectionPortHandle,
    _In_ ULONG Flags,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PALPC_PORT_ATTRIBUTES PortAttributes,
    _In_opt_ PVOID PortContext,
    _In_reads_bytes_(ConnectionRequest->u1.s1.TotalLength) PPORT_MESSAGE ConnectionRequest,
    _Inout_opt_ PALPC_MESSAGE_ATTRIBUTES ConnectionMessageAttributes,
    _In_ BOOLEAN AcceptConnection
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcSendWaitReceivePort(
    _In_ HANDLE PortHandle,
    _In_ ULONG Flags,
    _In_reads_bytes_opt_(SendMessage->u1.s1.TotalLength) PPORT_MESSAGE SendMessage,
    _Inout_opt_ PALPC_MESSAGE_ATTRIBUTES SendMessageAttributes,
    _Out_writes_bytes_to_opt_(*BufferLength, *BufferLength) PPORT_MESSAGE ReceiveMessage,
    _Inout_opt_ PSIZE_T BufferLength,
    _Inout_opt_ PALPC_MESSAGE_ATTRIBUTES ReceiveMessageAttributes,
    _In_opt_ PLARGE_INTEGER Timeout
    );

#define ALPC_CANCELFLG_TRY_CANCEL 0x1 // dbg
#define ALPC_CANCELFLG_NO_CONTEXT_CHECK 0x8
#define ALPC_CANCELFLGP_FLUSH 0x10000 // dbg

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcCancelMessage(
    _In_ HANDLE PortHandle,
    _In_ ULONG Flags,
    _In_ PALPC_CONTEXT_ATTR MessageContext
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcImpersonateClientOfPort(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE Message,
    _In_ PVOID Flags
    );

#if (PHNT_VERSION >= PHNT_THRESHOLD)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcImpersonateClientContainerOfPort(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE Message,
    _In_ ULONG Flags
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcOpenSenderProcess(
    _Out_ PHANDLE ProcessHandle,
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE PortMessage,
    _In_ ULONG Flags,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlpcOpenSenderThread(
    _Out_ PHANDLE ThreadHandle,
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE PortMessage,
    _In_ ULONG Flags,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

// Support functions

NTSYSAPI
ULONG
NTAPI
AlpcMaxAllowedMessageLength(
    VOID
    );

NTSYSAPI
ULONG
NTAPI
AlpcGetHeaderSize(
    _In_ ULONG Flags
    );

#define ALPC_ATTRFLG_ALLOCATEDATTR 0x20000000
#define ALPC_ATTRFLG_VALIDATTR 0x40000000
#define ALPC_ATTRFLG_KEEPRUNNINGATTR 0x60000000

NTSYSAPI
NTSTATUS
NTAPI
AlpcInitializeMessageAttribute(
    _In_ ULONG AttributeFlags,
    _Out_opt_ PALPC_MESSAGE_ATTRIBUTES Buffer,
    _In_ ULONG BufferSize,
    _Out_ PULONG RequiredBufferSize
    );

NTSYSAPI
PVOID
NTAPI
AlpcGetMessageAttribute(
    _In_ PALPC_MESSAGE_ATTRIBUTES Buffer,
    _In_ ULONG AttributeFlag
    );

NTSYSAPI
NTSTATUS
NTAPI
AlpcRegisterCompletionList(
    _In_ HANDLE PortHandle,
    _Out_ PALPC_COMPLETION_LIST_HEADER Buffer,
    _In_ ULONG Size,
    _In_ ULONG ConcurrencyCount,
    _In_ ULONG AttributeFlags
    );

NTSYSAPI
NTSTATUS
NTAPI
AlpcUnregisterCompletionList(
    _In_ HANDLE PortHandle
    );

#if (PHNT_VERSION >= PHNT_WIN7)
// rev
NTSYSAPI
NTSTATUS
NTAPI
AlpcRundownCompletionList(
    _In_ HANDLE PortHandle
    );
#endif

NTSYSAPI
NTSTATUS
NTAPI
AlpcAdjustCompletionListConcurrencyCount(
    _In_ HANDLE PortHandle,
    _In_ ULONG ConcurrencyCount
    );

NTSYSAPI
BOOLEAN
NTAPI
AlpcRegisterCompletionListWorkerThread(
    _Inout_ PVOID CompletionList
    );

NTSYSAPI
BOOLEAN
NTAPI
AlpcUnregisterCompletionListWorkerThread(
    _Inout_ PVOID CompletionList
    );

NTSYSAPI
VOID
NTAPI
AlpcGetCompletionListLastMessageInformation(
    _In_ PVOID CompletionList,
    _Out_ PULONG LastMessageId,
    _Out_ PULONG LastCallbackId
    );

NTSYSAPI
ULONG
NTAPI
AlpcGetOutstandingCompletionListMessageCount(
    _In_ PVOID CompletionList
    );

NTSYSAPI
PPORT_MESSAGE
NTAPI
AlpcGetMessageFromCompletionList(
    _In_ PVOID CompletionList,
    _Out_opt_ PALPC_MESSAGE_ATTRIBUTES *MessageAttributes
    );

NTSYSAPI
VOID
NTAPI
AlpcFreeCompletionListMessage(
    _Inout_ PVOID CompletionList,
    _In_ PPORT_MESSAGE Message
    );

NTSYSAPI
PALPC_MESSAGE_ATTRIBUTES
NTAPI
AlpcGetCompletionListMessageAttributes(
    _In_ PVOID CompletionList,
    _In_ PPORT_MESSAGE Message
    );

#endif

// end_private

#endif

```

`phnt/ntmisc.h`:

```h
#ifndef _NTMISC_H
#define _NTMISC_H

// Filter manager

#define FLT_PORT_CONNECT 0x0001
#define FLT_PORT_ALL_ACCESS (FLT_PORT_CONNECT | STANDARD_RIGHTS_ALL)

// VDM

typedef enum _VDMSERVICECLASS
{
    VdmStartExecution,
    VdmQueueInterrupt,
    VdmDelayInterrupt,
    VdmInitialize,
    VdmFeatures,
    VdmSetInt21Handler,
    VdmQueryDir,
    VdmPrinterDirectIoOpen,
    VdmPrinterDirectIoClose,
    VdmPrinterInitialize,
    VdmSetLdtEntries,
    VdmSetProcessLdtInfo,
    VdmAdlibEmulation,
    VdmPMCliControl,
    VdmQueryVdmProcess
} VDMSERVICECLASS, *PVDMSERVICECLASS;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtVdmControl(
    _In_ VDMSERVICECLASS Service,
    _Inout_ PVOID ServiceData
    );

// WMI/ETW

NTSYSCALLAPI
NTSTATUS
NTAPI
NtTraceEvent(
    _In_ HANDLE TraceHandle,
    _In_ ULONG Flags,
    _In_ ULONG FieldSize,
    _In_ PVOID Fields
    );

typedef enum _TRACE_CONTROL_INFORMATION_CLASS
{
    TraceControlStartLogger = 1,
    TraceControlStopLogger = 2,
    TraceControlQueryLogger = 3,
    TraceControlUpdateLogger = 4,
    TraceControlFlushLogger = 5,
    TraceControlIncrementLoggerFile = 6,

    TraceControlRealtimeConnect = 11,
    TraceControlWdiDispatchControl = 13,
    TraceControlRealtimeDisconnectConsumerByHandle = 14,

    TraceControlReceiveNotification = 16,
    TraceControlEnableGuid = 17,
    TraceControlSendReplyDataBlock = 18,
    TraceControlReceiveReplyDataBlock = 19,
    TraceControlWdiUpdateSem = 20,
    TraceControlGetTraceGuidList = 21,
    TraceControlGetTraceGuidInfo = 22,
    TraceControlEnumerateTraceGuids = 23,

    TraceControlQueryReferenceTime = 25,
    TraceControlTrackProviderBinary = 26,
    TraceControlAddNotificationEvent = 27,
    TraceControlUpdateDisallowList = 28,

    TraceControlUseDescriptorTypeUm = 31,
    TraceControlGetTraceGroupList = 32,
    TraceControlGetTraceGroupInfo = 33,
    TraceControlTraceSetDisallowList= 34,
    TraceControlSetCompressionSettings = 35,
    TraceControlGetCompressionSettings= 36,
    TraceControlUpdatePeriodicCaptureState = 37,
    TraceControlGetPrivateSessionTraceHandle = 38,
    TraceControlRegisterPrivateSession = 39,
    TraceControlQuerySessionDemuxObject = 40,
    TraceControlSetProviderBinaryTracking = 41,
    TraceControlMaxLoggers = 42,
    TraceControlMaxPmcCounter = 43
} TRACE_CONTROL_INFORMATION_CLASS;

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtTraceControl(
    _In_ TRACE_CONTROL_INFORMATION_CLASS TraceInformationClass,
    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(TraceInformationLength) PVOID TraceInformation,
    _In_ ULONG TraceInformationLength,
    _Out_ PULONG ReturnLength
    );
#endif

#endif

```

`phnt/ntmmapi.h`:

```h
#ifndef _NTMMAPI_H
#define _NTMMAPI_H

#if (PHNT_MODE == PHNT_MODE_KERNEL)

// Protection constants

#define PAGE_NOACCESS 0x01
#define PAGE_READONLY 0x02
#define PAGE_READWRITE 0x04
#define PAGE_WRITECOPY 0x08
#define PAGE_EXECUTE 0x10
#define PAGE_EXECUTE_READ 0x20
#define PAGE_EXECUTE_READWRITE 0x40
#define PAGE_EXECUTE_WRITECOPY 0x80
#define PAGE_GUARD 0x100
#define PAGE_NOCACHE 0x200
#define PAGE_WRITECOMBINE 0x400

#define PAGE_REVERT_TO_FILE_MAP     0x80000000
#define PAGE_ENCLAVE_THREAD_CONTROL 0x80000000
#define PAGE_TARGETS_NO_UPDATE      0x40000000
#define PAGE_TARGETS_INVALID        0x40000000
#define PAGE_ENCLAVE_UNVALIDATED    0x20000000

// Region and section constants
#if (PHNT_MODE != PHNT_MODE_KERNEL)
#define MEM_COMMIT 0x1000
#define MEM_RESERVE 0x2000
#define MEM_DECOMMIT 0x4000
#define MEM_RELEASE 0x8000
#define MEM_FREE 0x10000
#define MEM_PRIVATE 0x20000
#define MEM_MAPPED 0x40000
#define MEM_RESET 0x80000
#define MEM_TOP_DOWN 0x100000
#endif
#define MEM_WRITE_WATCH 0x200000
#define MEM_PHYSICAL 0x400000
#define MEM_ROTATE 0x800000
#define MEM_DIFFERENT_IMAGE_BASE_OK 0x800000
#if (PHNT_MODE != PHNT_MODE_KERNEL)
#define MEM_RESET_UNDO 0x1000000
#endif
#define MEM_LARGE_PAGES 0x20000000
#define MEM_4MB_PAGES 0x80000000

#if (PHNT_MODE != PHNT_MODE_KERNEL)
#define SEC_FILE 0x800000
#endif
#define SEC_IMAGE 0x1000000
#define SEC_PROTECTED_IMAGE 0x2000000
#if (PHNT_MODE != PHNT_MODE_KERNEL)
#define SEC_RESERVE 0x4000000
#define SEC_COMMIT 0x8000000
#endif
#define SEC_NOCACHE 0x10000000
#define SEC_WRITECOMBINE 0x40000000
#define SEC_LARGE_PAGES 0x80000000
#define SEC_IMAGE_NO_EXECUTE (SEC_IMAGE | SEC_NOCACHE)
#define MEM_IMAGE SEC_IMAGE

#endif

#if (PHNT_MODE != PHNT_MODE_KERNEL)
// private
typedef enum _MEMORY_INFORMATION_CLASS
{
    MemoryBasicInformation, // MEMORY_BASIC_INFORMATION
    MemoryWorkingSetInformation, // MEMORY_WORKING_SET_INFORMATION
    MemoryMappedFilenameInformation, // UNICODE_STRING
    MemoryRegionInformation, // MEMORY_REGION_INFORMATION
    MemoryWorkingSetExInformation, // MEMORY_WORKING_SET_EX_INFORMATION
    MemorySharedCommitInformation, // MEMORY_SHARED_COMMIT_INFORMATION
    MemoryImageInformation, // MEMORY_IMAGE_INFORMATION
    MemoryRegionInformationEx,
    MemoryPrivilegedBasicInformation,
    MemoryEnclaveImageInformation, // MEMORY_ENCLAVE_IMAGE_INFORMATION // since REDSTONE3
    MemoryBasicInformationCapped
} MEMORY_INFORMATION_CLASS;
#else
#define MemoryBasicInformation 0x0
#define MemoryWorkingSetInformation 0x1
#define MemoryMappedFilenameInformation 0x2
#define MemoryRegionInformation 0x3
#define MemoryWorkingSetExInformation 0x4
#define MemorySharedCommitInformation 0x5
#define MemoryImageInformation 0x6
#define MemoryRegionInformationEx 0x7
#define MemoryPrivilegedBasicInformation 0x8
#define MemoryEnclaveImageInformation 0x9
#define MemoryBasicInformationCapped 0xA
#endif

typedef struct _MEMORY_WORKING_SET_BLOCK
{
    ULONG_PTR Protection : 5;
    ULONG_PTR ShareCount : 3;
    ULONG_PTR Shared : 1;
    ULONG_PTR Node : 3;
#ifdef _WIN64
    ULONG_PTR VirtualPage : 52;
#else
    ULONG VirtualPage : 20;
#endif
} MEMORY_WORKING_SET_BLOCK, *PMEMORY_WORKING_SET_BLOCK;

typedef struct _MEMORY_WORKING_SET_INFORMATION
{
    ULONG_PTR NumberOfEntries;
    MEMORY_WORKING_SET_BLOCK WorkingSetInfo[1];
} MEMORY_WORKING_SET_INFORMATION, *PMEMORY_WORKING_SET_INFORMATION;

// private
typedef struct _MEMORY_REGION_INFORMATION
{
    PVOID AllocationBase;
    ULONG AllocationProtect;
    union
    {
        ULONG RegionType;
        struct
        {
            ULONG Private : 1;
            ULONG MappedDataFile : 1;
            ULONG MappedImage : 1;
            ULONG MappedPageFile : 1;
            ULONG MappedPhysical : 1;
            ULONG DirectMapped : 1;
            ULONG SoftwareEnclave : 1; // REDSTONE3
            ULONG PageSize64K : 1;
            ULONG PlaceholderReservation : 1; // REDSTONE4
            ULONG Reserved : 23;
        };
    };
    SIZE_T RegionSize;
    SIZE_T CommitSize;
    ULONG_PTR PartitionId; // 19H1
} MEMORY_REGION_INFORMATION, *PMEMORY_REGION_INFORMATION;

// private 
typedef enum _MEMORY_WORKING_SET_EX_LOCATION
{
    MemoryLocationInvalid,
    MemoryLocationResident,
    MemoryLocationPagefile,
    MemoryLocationReserved
} MEMORY_WORKING_SET_EX_LOCATION;

// private
typedef struct _MEMORY_WORKING_SET_EX_BLOCK
{
    union
    {
        struct
        {
            ULONG_PTR Valid : 1;
            ULONG_PTR ShareCount : 3;
            ULONG_PTR Win32Protection : 11;
            ULONG_PTR Shared : 1;
            ULONG_PTR Node : 6;
            ULONG_PTR Locked : 1;
            ULONG_PTR LargePage : 1;
            ULONG_PTR Priority : 3;
            ULONG_PTR Reserved : 3;
            ULONG_PTR SharedOriginal : 1;
            ULONG_PTR Bad : 1;
            ULONG_PTR Win32GraphicsProtection : 4; // 19H1
#ifdef _WIN64
            ULONG_PTR ReservedUlong : 28;
#endif
        };
        struct
        {
            ULONG_PTR Valid : 1;
            ULONG_PTR Reserved0 : 14;
            ULONG_PTR Shared : 1;
            ULONG_PTR Reserved1 : 5;
            ULONG_PTR PageTable : 1;
            ULONG_PTR Location : 2;
            ULONG_PTR Priority : 3;
            ULONG_PTR ModifiedList : 1;
            ULONG_PTR Reserved2 : 2;
            ULONG_PTR SharedOriginal : 1;
            ULONG_PTR Bad : 1;
#ifdef _WIN64
            ULONG_PTR ReservedUlong : 32;
#endif
        } Invalid;
    };
} MEMORY_WORKING_SET_EX_BLOCK, *PMEMORY_WORKING_SET_EX_BLOCK;

// private
typedef struct _MEMORY_WORKING_SET_EX_INFORMATION
{
    PVOID VirtualAddress;
    union
    {
        MEMORY_WORKING_SET_EX_BLOCK VirtualAttributes;
        ULONG_PTR Long;
    } u1;
} MEMORY_WORKING_SET_EX_INFORMATION, *PMEMORY_WORKING_SET_EX_INFORMATION;

// private
typedef struct _MEMORY_SHARED_COMMIT_INFORMATION
{
    SIZE_T CommitSize;
} MEMORY_SHARED_COMMIT_INFORMATION, *PMEMORY_SHARED_COMMIT_INFORMATION;

// private
typedef struct _MEMORY_IMAGE_INFORMATION
{
    PVOID ImageBase;
    SIZE_T SizeOfImage;
    union
    {
        ULONG ImageFlags;
        struct
        {
            ULONG ImagePartialMap : 1;
            ULONG ImageNotExecutable : 1;
            ULONG ImageSigningLevel : 4; // REDSTONE3
            ULONG Reserved : 26;
        };
    };
} MEMORY_IMAGE_INFORMATION, *PMEMORY_IMAGE_INFORMATION;

// private
typedef struct _MEMORY_ENCLAVE_IMAGE_INFORMATION
{
    MEMORY_IMAGE_INFORMATION ImageInfo;
    UCHAR UniqueID[32];
    UCHAR AuthorID[32];
} MEMORY_ENCLAVE_IMAGE_INFORMATION, *PMEMORY_ENCLAVE_IMAGE_INFORMATION;

#define MMPFNLIST_ZERO 0
#define MMPFNLIST_FREE 1
#define MMPFNLIST_STANDBY 2
#define MMPFNLIST_MODIFIED 3
#define MMPFNLIST_MODIFIEDNOWRITE 4
#define MMPFNLIST_BAD 5
#define MMPFNLIST_ACTIVE 6
#define MMPFNLIST_TRANSITION 7

//typedef enum _MMLISTS
//{
//    ZeroedPageList = 0,
//    FreePageList = 1,
//    StandbyPageList = 2,
//    ModifiedPageList = 3,
//    ModifiedNoWritePageList = 4,
//    BadPageList = 5,
//    ActiveAndValid = 6,
//    TransitionPage = 7
//} MMLISTS;

#define MMPFNUSE_PROCESSPRIVATE 0
#define MMPFNUSE_FILE 1
#define MMPFNUSE_PAGEFILEMAPPED 2
#define MMPFNUSE_PAGETABLE 3
#define MMPFNUSE_PAGEDPOOL 4
#define MMPFNUSE_NONPAGEDPOOL 5
#define MMPFNUSE_SYSTEMPTE 6
#define MMPFNUSE_SESSIONPRIVATE 7
#define MMPFNUSE_METAFILE 8
#define MMPFNUSE_AWEPAGE 9
#define MMPFNUSE_DRIVERLOCKPAGE 10
#define MMPFNUSE_KERNELSTACK 11

//typedef enum _MMPFNUSE
//{
//    ProcessPrivatePage,
//    MemoryMappedFilePage,
//    PageFileMappedPage,
//    PageTablePage,
//    PagedPoolPage,
//    NonPagedPoolPage,
//    SystemPTEPage,
//    SessionPrivatePage,
//    MetafilePage,
//    AWEPage,
//    DriverLockedPage,
//    KernelStackPage
//} MMPFNUSE;

// private
typedef struct _MEMORY_FRAME_INFORMATION
{
    ULONGLONG UseDescription : 4; // MMPFNUSE_*
    ULONGLONG ListDescription : 3; // MMPFNLIST_*
    ULONGLONG Cold : 1; // 19H1
    ULONGLONG Pinned : 1; // 1 - pinned, 0 - not pinned
    ULONGLONG DontUse : 48; // *_INFORMATION overlay
    ULONGLONG Priority : 3; // rev
    ULONGLONG Reserved : 4; // reserved for future expansion
} MEMORY_FRAME_INFORMATION;

// private
typedef struct _FILEOFFSET_INFORMATION
{
    ULONGLONG DontUse : 9; // MEMORY_FRAME_INFORMATION overlay
    ULONGLONG Offset : 48; // mapped files
    ULONGLONG Reserved : 7; // reserved for future expansion
} FILEOFFSET_INFORMATION;

// private
typedef struct _PAGEDIR_INFORMATION
{
    ULONGLONG DontUse : 9; // MEMORY_FRAME_INFORMATION overlay
    ULONGLONG PageDirectoryBase : 48; // private pages
    ULONGLONG Reserved : 7; // reserved for future expansion
} PAGEDIR_INFORMATION;

// private
typedef struct _UNIQUE_PROCESS_INFORMATION
{
    ULONGLONG DontUse : 9; // MEMORY_FRAME_INFORMATION overlay
    ULONGLONG UniqueProcessKey : 48; // ProcessId
    ULONGLONG Reserved  : 7; // reserved for future expansion
} UNIQUE_PROCESS_INFORMATION, *PUNIQUE_PROCESS_INFORMATION;

// private
typedef struct _MMPFN_IDENTITY
{
    union
    {
        MEMORY_FRAME_INFORMATION e1; // all
        FILEOFFSET_INFORMATION e2; // mapped files
        PAGEDIR_INFORMATION e3; // private pages
        UNIQUE_PROCESS_INFORMATION e4; // owning process
    } u1;
    ULONG_PTR PageFrameIndex; // all
    union
    {
        struct
        {
            ULONG_PTR Image : 1;
            ULONG_PTR Mismatch : 1;
        } e1;
        struct
        {
            ULONG_PTR CombinedPage;
        } e2;
        ULONG_PTR FileObject; // mapped files
        ULONG_PTR UniqueFileObjectKey;
        ULONG_PTR ProtoPteAddress;
        ULONG_PTR VirtualAddress;  // everything else
    } u2;
} MMPFN_IDENTITY, *PMMPFN_IDENTITY;

typedef struct _MMPFN_MEMSNAP_INFORMATION
{
    ULONG_PTR InitialPageFrameIndex;
    ULONG_PTR Count;
} MMPFN_MEMSNAP_INFORMATION, *PMMPFN_MEMSNAP_INFORMATION;

typedef enum _SECTION_INFORMATION_CLASS
{
    SectionBasicInformation, // q; SECTION_BASIC_INFORMATION
    SectionImageInformation, // q; SECTION_IMAGE_INFORMATION
    SectionRelocationInformation, // name:wow64:whNtQuerySection_SectionRelocationInformation
    SectionOriginalBaseInformation, // PVOID BaseAddress
    SectionInternalImageInformation, // SECTION_INTERNAL_IMAGE_INFORMATION // since REDSTONE2
    MaxSectionInfoClass
} SECTION_INFORMATION_CLASS;

typedef struct _SECTION_BASIC_INFORMATION
{
    PVOID BaseAddress;
    ULONG AllocationAttributes;
    LARGE_INTEGER MaximumSize;
} SECTION_BASIC_INFORMATION, *PSECTION_BASIC_INFORMATION;

// symbols
typedef struct _SECTION_IMAGE_INFORMATION
{
    PVOID TransferAddress;
    ULONG ZeroBits;
    SIZE_T MaximumStackSize;
    SIZE_T CommittedStackSize;
    ULONG SubSystemType;
    union
    {
        struct
        {
            USHORT SubSystemMinorVersion;
            USHORT SubSystemMajorVersion;
        };
        ULONG SubSystemVersion;
    };
    union
    {
        struct
        {
            USHORT MajorOperatingSystemVersion;
            USHORT MinorOperatingSystemVersion;
        };
        ULONG OperatingSystemVersion;
    };
    USHORT ImageCharacteristics;
    USHORT DllCharacteristics;
    USHORT Machine;
    BOOLEAN ImageContainsCode;
    union
    {
        UCHAR ImageFlags;
        struct
        {
            UCHAR ComPlusNativeReady : 1;
            UCHAR ComPlusILOnly : 1;
            UCHAR ImageDynamicallyRelocated : 1;
            UCHAR ImageMappedFlat : 1;
            UCHAR BaseBelow4gb : 1;
            UCHAR ComPlusPrefer32bit : 1;
            UCHAR Reserved : 2;
        };
    };
    ULONG LoaderFlags;
    ULONG ImageFileSize;
    ULONG CheckSum;
} SECTION_IMAGE_INFORMATION, *PSECTION_IMAGE_INFORMATION;

// symbols
typedef struct _SECTION_INTERNAL_IMAGE_INFORMATION
{
    SECTION_IMAGE_INFORMATION SectionInformation;
    union
    {
        ULONG ExtendedFlags;
        struct
        {
            ULONG ImageExportSuppressionEnabled : 1;
            ULONG Reserved : 31;
        };
    };
} SECTION_INTERNAL_IMAGE_INFORMATION, *PSECTION_INTERNAL_IMAGE_INFORMATION;

#if (PHNT_MODE != PHNT_MODE_KERNEL)
typedef enum _SECTION_INHERIT
{
    ViewShare = 1,
    ViewUnmap = 2
} SECTION_INHERIT;
#endif

#define SEC_BASED 0x200000
#define SEC_NO_CHANGE 0x400000
#define SEC_GLOBAL 0x20000000

#define MEM_EXECUTE_OPTION_DISABLE 0x1
#define MEM_EXECUTE_OPTION_ENABLE 0x2
#define MEM_EXECUTE_OPTION_DISABLE_THUNK_EMULATION 0x4
#define MEM_EXECUTE_OPTION_PERMANENT 0x8
#define MEM_EXECUTE_OPTION_EXECUTE_DISPATCH_ENABLE 0x10
#define MEM_EXECUTE_OPTION_IMAGE_DISPATCH_ENABLE 0x20
#define MEM_EXECUTE_OPTION_VALID_FLAGS 0x3f

// Virtual memory

#if (PHNT_MODE != PHNT_MODE_KERNEL)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAllocateVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ _At_(*BaseAddress, _Readable_bytes_(*RegionSize) _Writable_bytes_(*RegionSize) _Post_readable_byte_size_(*RegionSize)) PVOID *BaseAddress,
    _In_ ULONG_PTR ZeroBits,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG AllocationType,
    _In_ ULONG Protect
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFreeVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG FreeType
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReadVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _Out_writes_bytes_(BufferSize) PVOID Buffer,
    _In_ SIZE_T BufferSize,
    _Out_opt_ PSIZE_T NumberOfBytesRead
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWriteVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _In_reads_bytes_(BufferSize) PVOID Buffer,
    _In_ SIZE_T BufferSize,
    _Out_opt_ PSIZE_T NumberOfBytesWritten
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtProtectVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG NewProtect,
    _Out_ PULONG OldProtect
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _In_ MEMORY_INFORMATION_CLASS MemoryInformationClass,
    _Out_writes_bytes_(MemoryInformationLength) PVOID MemoryInformation,
    _In_ SIZE_T MemoryInformationLength,
    _Out_opt_ PSIZE_T ReturnLength
    );

#endif

// begin_private
#if (PHNT_MODE != PHNT_MODE_KERNEL)
typedef enum _VIRTUAL_MEMORY_INFORMATION_CLASS
{
    VmPrefetchInformation, // ULONG
    VmPagePriorityInformation,
    VmCfgCallTargetInformation, // CFG_CALL_TARGET_LIST_INFORMATION // REDSTONE2
    VmPageDirtyStateInformation, // REDSTONE3
    VmImageHotPatchInformation // 19H1
} VIRTUAL_MEMORY_INFORMATION_CLASS;

typedef struct _MEMORY_RANGE_ENTRY
{
    PVOID VirtualAddress;
    SIZE_T NumberOfBytes;
} MEMORY_RANGE_ENTRY, *PMEMORY_RANGE_ENTRY;

typedef struct _CFG_CALL_TARGET_LIST_INFORMATION
{
    ULONG NumberOfEntries;
    ULONG Reserved;
    PULONG NumberOfEntriesProcessed;
    PCFG_CALL_TARGET_INFO CallTargetInfo;
    PVOID Section; // since REDSTONE5
    ULONGLONG FileOffset;
} CFG_CALL_TARGET_LIST_INFORMATION, *PCFG_CALL_TARGET_LIST_INFORMATION;
#endif
// end_private

#if (PHNT_MODE != PHNT_MODE_KERNEL)

#if (PHNT_VERSION >= PHNT_THRESHOLD)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_ VIRTUAL_MEMORY_INFORMATION_CLASS VmInformationClass,
    _In_ ULONG_PTR NumberOfEntries,
    _In_reads_ (NumberOfEntries) PMEMORY_RANGE_ENTRY VirtualAddresses,
    _In_reads_bytes_ (VmInformationLength) PVOID VmInformation,
    _In_ ULONG VmInformationLength
    );

#endif

#define MAP_PROCESS 1
#define MAP_SYSTEM 2

NTSYSCALLAPI
NTSTATUS
NTAPI
NtLockVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG MapType
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnlockVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG MapType
    );

#endif

// Sections

#if (PHNT_MODE != PHNT_MODE_KERNEL)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateSection(
    _Out_ PHANDLE SectionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PLARGE_INTEGER MaximumSize,
    _In_ ULONG SectionPageProtection,
    _In_ ULONG AllocationAttributes,
    _In_opt_ HANDLE FileHandle
    );

#if (PHNT_VERSION >= PHNT_REDSTONE5)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateSectionEx(
    _Out_ PHANDLE SectionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PLARGE_INTEGER MaximumSize,
    _In_ ULONG SectionPageProtection,
    _In_ ULONG AllocationAttributes,
    _In_opt_ HANDLE FileHandle,
    _Inout_updates_opt_(ExtendedParameterCount) PMEM_EXTENDED_PARAMETER ExtendedParameters,
    _In_ ULONG ExtendedParameterCount
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenSection(
    _Out_ PHANDLE SectionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtMapViewOfSection(
    _In_ HANDLE SectionHandle,
    _In_ HANDLE ProcessHandle,
    _Inout_ _At_(*BaseAddress, _Readable_bytes_(*ViewSize) _Writable_bytes_(*ViewSize) _Post_readable_byte_size_(*ViewSize)) PVOID *BaseAddress,
    _In_ ULONG_PTR ZeroBits,
    _In_ SIZE_T CommitSize,
    _Inout_opt_ PLARGE_INTEGER SectionOffset,
    _Inout_ PSIZE_T ViewSize,
    _In_ SECTION_INHERIT InheritDisposition,
    _In_ ULONG AllocationType,
    _In_ ULONG Win32Protect
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnmapViewOfSection(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress
    );

#if (PHNT_VERSION >= PHNT_WIN8)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnmapViewOfSectionEx(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _In_ ULONG Flags
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtExtendSection(
    _In_ HANDLE SectionHandle,
    _Inout_ PLARGE_INTEGER NewSectionSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySection(
    _In_ HANDLE SectionHandle,
    _In_ SECTION_INFORMATION_CLASS SectionInformationClass,
    _Out_writes_bytes_(SectionInformationLength) PVOID SectionInformation,
    _In_ SIZE_T SectionInformationLength,
    _Out_opt_ PSIZE_T ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAreMappedFilesTheSame(
    _In_ PVOID File1MappedAsAnImage,
    _In_ PVOID File2MappedAsFile
    );

#endif

// Partitions

#ifndef MEMORY_PARTITION_QUERY_ACCESS
#define MEMORY_PARTITION_QUERY_ACCESS 0x0001
#define MEMORY_PARTITION_MODIFY_ACCESS 0x0002
#define MEMORY_PARTITION_ALL_ACCESS \
    (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
     MEMORY_PARTITION_QUERY_ACCESS | MEMORY_PARTITION_MODIFY_ACCESS)
#endif

// private
typedef enum _MEMORY_PARTITION_INFORMATION_CLASS
{
    SystemMemoryPartitionInformation, // q: MEMORY_PARTITION_CONFIGURATION_INFORMATION
    SystemMemoryPartitionMoveMemory, // s: MEMORY_PARTITION_TRANSFER_INFORMATION
    SystemMemoryPartitionAddPagefile, // s: MEMORY_PARTITION_PAGEFILE_INFORMATION
    SystemMemoryPartitionCombineMemory, // q; s: MEMORY_PARTITION_PAGE_COMBINE_INFORMATION
    SystemMemoryPartitionInitialAddMemory, // q; s: MEMORY_PARTITION_INITIAL_ADD_INFORMATION
    SystemMemoryPartitionGetMemoryEvents, // MEMORY_PARTITION_MEMORY_EVENTS_INFORMATION // since REDSTONE2
    SystemMemoryPartitionMax
} MEMORY_PARTITION_INFORMATION_CLASS;

// private
typedef struct _MEMORY_PARTITION_CONFIGURATION_INFORMATION
{
    ULONG Flags;
    ULONG NumaNode;
    ULONG Channel;
    ULONG NumberOfNumaNodes;
    ULONG_PTR ResidentAvailablePages;
    ULONG_PTR CommittedPages;
    ULONG_PTR CommitLimit;
    ULONG_PTR PeakCommitment;
    ULONG_PTR TotalNumberOfPages;
    ULONG_PTR AvailablePages;
    ULONG_PTR ZeroPages;
    ULONG_PTR FreePages;
    ULONG_PTR StandbyPages;
    ULONG_PTR StandbyPageCountByPriority[8]; // since REDSTONE2
    ULONG_PTR RepurposedPagesByPriority[8];
    ULONG_PTR MaximumCommitLimit;
    ULONG_PTR DonatedPagesToPartitions;
    ULONG PartitionId; // since REDSTONE3
} MEMORY_PARTITION_CONFIGURATION_INFORMATION, *PMEMORY_PARTITION_CONFIGURATION_INFORMATION;

// private
typedef struct _MEMORY_PARTITION_TRANSFER_INFORMATION
{
    ULONG_PTR NumberOfPages;
    ULONG NumaNode;
    ULONG Flags;
} MEMORY_PARTITION_TRANSFER_INFORMATION, *PMEMORY_PARTITION_TRANSFER_INFORMATION;

// private
typedef struct _MEMORY_PARTITION_PAGEFILE_INFORMATION
{
    UNICODE_STRING PageFileName;
    LARGE_INTEGER MinimumSize;
    LARGE_INTEGER MaximumSize;
    ULONG Flags;
} MEMORY_PARTITION_PAGEFILE_INFORMATION, *PMEMORY_PARTITION_PAGEFILE_INFORMATION;

// private
typedef struct _MEMORY_PARTITION_PAGE_COMBINE_INFORMATION
{
    HANDLE StopHandle;
    ULONG Flags;
    ULONG_PTR TotalNumberOfPages;
} MEMORY_PARTITION_PAGE_COMBINE_INFORMATION, *PMEMORY_PARTITION_PAGE_COMBINE_INFORMATION;

// private
typedef struct _MEMORY_PARTITION_PAGE_RANGE
{
    ULONG_PTR StartPage;
    ULONG_PTR NumberOfPages;
} MEMORY_PARTITION_PAGE_RANGE, *PMEMORY_PARTITION_PAGE_RANGE;

// private
typedef struct _MEMORY_PARTITION_INITIAL_ADD_INFORMATION
{
    ULONG Flags;
    ULONG NumberOfRanges;
    ULONG_PTR NumberOfPagesAdded;
    MEMORY_PARTITION_PAGE_RANGE PartitionRanges[1];
} MEMORY_PARTITION_INITIAL_ADD_INFORMATION, *PMEMORY_PARTITION_INITIAL_ADD_INFORMATION;

// private
typedef struct _MEMORY_PARTITION_MEMORY_EVENTS_INFORMATION
{
    union
    {    
        struct
        {
            ULONG CommitEvents : 1;
            ULONG Spare : 31;
        };
        ULONG AllFlags;
    } Flags;
    
    ULONG HandleAttributes;
    ULONG DesiredAccess;
    HANDLE LowCommitCondition; // \KernelObjects\LowCommitCondition
    HANDLE HighCommitCondition; // \KernelObjects\HighCommitCondition
    HANDLE MaximumCommitCondition; // \KernelObjects\MaximumCommitCondition
} MEMORY_PARTITION_MEMORY_EVENTS_INFORMATION, *PMEMORY_PARTITION_MEMORY_EVENTS_INFORMATION;

#if (PHNT_MODE != PHNT_MODE_KERNEL)

#if (PHNT_VERSION >= PHNT_THRESHOLD)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreatePartition(
    _Out_ PHANDLE PartitionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG PreferredNode
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenPartition(
    _Out_ PHANDLE PartitionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtManagePartition(
    _In_ MEMORY_PARTITION_INFORMATION_CLASS PartitionInformationClass,
    _In_ PVOID PartitionInformation,
    _In_ ULONG PartitionInformationLength
    );

#endif

#endif

// User physical pages

#if (PHNT_MODE != PHNT_MODE_KERNEL)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtMapUserPhysicalPages(
    _In_ PVOID VirtualAddress,
    _In_ ULONG_PTR NumberOfPages,
    _In_reads_opt_(NumberOfPages) PULONG_PTR UserPfnArray
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtMapUserPhysicalPagesScatter(
    _In_reads_(NumberOfPages) PVOID *VirtualAddresses,
    _In_ ULONG_PTR NumberOfPages,
    _In_reads_opt_(NumberOfPages) PULONG_PTR UserPfnArray
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAllocateUserPhysicalPages(
    _In_ HANDLE ProcessHandle,
    _Inout_ PULONG_PTR NumberOfPages,
    _Out_writes_(*NumberOfPages) PULONG_PTR UserPfnArray
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFreeUserPhysicalPages(
    _In_ HANDLE ProcessHandle,
    _Inout_ PULONG_PTR NumberOfPages,
    _In_reads_(*NumberOfPages) PULONG_PTR UserPfnArray
    );

#endif

// Misc.

#if (PHNT_MODE != PHNT_MODE_KERNEL)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtGetWriteWatch(
    _In_ HANDLE ProcessHandle,
    _In_ ULONG Flags,
    _In_ PVOID BaseAddress,
    _In_ SIZE_T RegionSize,
    _Out_writes_(*EntriesInUserAddressArray) PVOID *UserAddressArray,
    _Inout_ PULONG_PTR EntriesInUserAddressArray,
    _Out_ PULONG Granularity
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtResetWriteWatch(
    _In_ HANDLE ProcessHandle,
    _In_ PVOID BaseAddress,
    _In_ SIZE_T RegionSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreatePagingFile(
    _In_ PUNICODE_STRING PageFileName,
    _In_ PLARGE_INTEGER MinimumSize,
    _In_ PLARGE_INTEGER MaximumSize,
    _In_ ULONG Priority
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFlushInstructionCache(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _In_ SIZE_T Length
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFlushWriteBuffer(
    VOID
    );

#endif

// Enclave support

NTSYSAPI
NTSTATUS
NTAPI
NtCreateEnclave(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID* BaseAddress,
    _In_ ULONG_PTR ZeroBits,
    _In_ SIZE_T Size,
    _In_ SIZE_T InitialCommitment,
    _In_ ULONG EnclaveType,
    _In_reads_bytes_(EnclaveInformationLength) PVOID EnclaveInformation,
    _In_ ULONG EnclaveInformationLength,
    _Out_opt_ PULONG EnclaveError
    );

NTSYSAPI
NTSTATUS
NTAPI
NtLoadEnclaveData(
    _In_ HANDLE ProcessHandle,
    _In_ PVOID BaseAddress,
    _In_reads_bytes_(BufferSize) PVOID Buffer,
    _In_ SIZE_T BufferSize,
    _In_ ULONG Protect,
    _In_reads_bytes_(PageInformationLength) PVOID PageInformation,
    _In_ ULONG PageInformationLength,
    _Out_opt_ PSIZE_T NumberOfBytesWritten,
    _Out_opt_ PULONG EnclaveError
    );

NTSYSAPI
NTSTATUS
NTAPI
NtInitializeEnclave(
    _In_ HANDLE ProcessHandle,
    _In_ PVOID BaseAddress,
    _In_reads_bytes_(EnclaveInformationLength) PVOID EnclaveInformation,
    _In_ ULONG EnclaveInformationLength,
    _Out_opt_ PULONG EnclaveError
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
NtTerminateEnclave(
    _In_ PVOID BaseAddress,
    _In_ BOOLEAN WaitForThread
    );

#if (PHNT_MODE != PHNT_MODE_KERNEL)
// rev
NTSYSAPI
NTSTATUS
NTAPI
NtCallEnclave(
    _In_ PENCLAVE_ROUTINE Routine,
    _In_ PVOID Parameter,
    _In_ BOOLEAN WaitForThread,
    _Out_opt_ PVOID *ReturnValue
    );
#endif

#endif

```

`phnt/ntnls.h`:

```h
/*
 * Process Hacker -
 *   National Language Support functions
 *
 * This file is part of Process Hacker.
 *
 * Process Hacker is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Process Hacker is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Process Hacker.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef _NTNLS_H
#define _NTNLS_H

#define MAXIMUM_LEADBYTES 12

typedef struct _CPTABLEINFO
{
    USHORT CodePage;
    USHORT MaximumCharacterSize;
    USHORT DefaultChar;
    USHORT UniDefaultChar;
    USHORT TransDefaultChar;
    USHORT TransUniDefaultChar;
    USHORT DBCSCodePage;
    UCHAR LeadByte[MAXIMUM_LEADBYTES];
    PUSHORT MultiByteTable;
    PVOID WideCharTable;
    PUSHORT DBCSRanges;
    PUSHORT DBCSOffsets;
} CPTABLEINFO, *PCPTABLEINFO;

typedef struct _NLSTABLEINFO
{
    CPTABLEINFO OemTableInfo;
    CPTABLEINFO AnsiTableInfo;
    PUSHORT UpperCaseTable;
    PUSHORT LowerCaseTable;
} NLSTABLEINFO, *PNLSTABLEINFO;

#if (PHNT_MODE != PHNT_MODE_KERNEL)
//NTSYSAPI USHORT NlsAnsiCodePage;
//NTSYSAPI BOOLEAN NlsMbCodePageTag;
//NTSYSAPI BOOLEAN NlsMbOemCodePageTag;
#endif

#endif

```

`phnt/ntobapi.h`:

```h
#ifndef _NTOBAPI_H
#define _NTOBAPI_H

#if (PHNT_MODE != PHNT_MODE_KERNEL)
#define OBJECT_TYPE_CREATE 0x0001
#define OBJECT_TYPE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0x1)
#endif

#if (PHNT_MODE != PHNT_MODE_KERNEL)
#define DIRECTORY_QUERY 0x0001
#define DIRECTORY_TRAVERSE 0x0002
#define DIRECTORY_CREATE_OBJECT 0x0004
#define DIRECTORY_CREATE_SUBDIRECTORY 0x0008
#define DIRECTORY_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0xf)
#endif

#if (PHNT_MODE != PHNT_MODE_KERNEL)
#define SYMBOLIC_LINK_QUERY 0x0001
#define SYMBOLIC_LINK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0x1)
#endif

#define OBJ_PROTECT_CLOSE 0x00000001
#ifndef OBJ_INHERIT
#define OBJ_INHERIT 0x00000002
#endif
#define OBJ_AUDIT_OBJECT_CLOSE 0x00000004

#if (PHNT_MODE != PHNT_MODE_KERNEL)
typedef enum _OBJECT_INFORMATION_CLASS
{
    ObjectBasicInformation, // OBJECT_BASIC_INFORMATION
    ObjectNameInformation, // OBJECT_NAME_INFORMATION
    ObjectTypeInformation, // OBJECT_TYPE_INFORMATION
    ObjectTypesInformation, // OBJECT_TYPES_INFORMATION
    ObjectHandleFlagInformation, // OBJECT_HANDLE_FLAG_INFORMATION
    ObjectSessionInformation,
    ObjectSessionObjectInformation,
    MaxObjectInfoClass
} OBJECT_INFORMATION_CLASS;
#else
#define ObjectBasicInformation 0
#define ObjectNameInformation 1
#define ObjectTypesInformation 3
#define ObjectHandleFlagInformation 4
#define ObjectSessionInformation 5
#define ObjectSessionObjectInformation 6
#endif

typedef struct _OBJECT_BASIC_INFORMATION
{
    ULONG Attributes;
    ACCESS_MASK GrantedAccess;
    ULONG HandleCount;
    ULONG PointerCount;
    ULONG PagedPoolCharge;
    ULONG NonPagedPoolCharge;
    ULONG Reserved[3];
    ULONG NameInfoSize;
    ULONG TypeInfoSize;
    ULONG SecurityDescriptorSize;
    LARGE_INTEGER CreationTime;
} OBJECT_BASIC_INFORMATION, *POBJECT_BASIC_INFORMATION;

#if (PHNT_MODE != PHNT_MODE_KERNEL)
typedef struct _OBJECT_NAME_INFORMATION
{
    UNICODE_STRING Name;
} OBJECT_NAME_INFORMATION, *POBJECT_NAME_INFORMATION;
#endif

typedef struct _OBJECT_TYPE_INFORMATION
{
    UNICODE_STRING TypeName;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG TotalPagedPoolUsage;
    ULONG TotalNonPagedPoolUsage;
    ULONG TotalNamePoolUsage;
    ULONG TotalHandleTableUsage;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    ULONG HighWaterPagedPoolUsage;
    ULONG HighWaterNonPagedPoolUsage;
    ULONG HighWaterNamePoolUsage;
    ULONG HighWaterHandleTableUsage;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    BOOLEAN SecurityRequired;
    BOOLEAN MaintainHandleCount;
    UCHAR TypeIndex; // since WINBLUE
    CHAR ReservedByte;
    ULONG PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
} OBJECT_TYPE_INFORMATION, *POBJECT_TYPE_INFORMATION;

typedef struct _OBJECT_TYPES_INFORMATION
{
    ULONG NumberOfTypes;
} OBJECT_TYPES_INFORMATION, *POBJECT_TYPES_INFORMATION;

typedef struct _OBJECT_HANDLE_FLAG_INFORMATION
{
    BOOLEAN Inherit;
    BOOLEAN ProtectFromClose;
} OBJECT_HANDLE_FLAG_INFORMATION, *POBJECT_HANDLE_FLAG_INFORMATION;

// Objects, handles

#if (PHNT_MODE != PHNT_MODE_KERNEL)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryObject(
    _In_opt_ HANDLE Handle,
    _In_ OBJECT_INFORMATION_CLASS ObjectInformationClass,
    _Out_writes_bytes_opt_(ObjectInformationLength) PVOID ObjectInformation,
    _In_ ULONG ObjectInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationObject(
    _In_ HANDLE Handle,
    _In_ OBJECT_INFORMATION_CLASS ObjectInformationClass,
    _In_reads_bytes_(ObjectInformationLength) PVOID ObjectInformation,
    _In_ ULONG ObjectInformationLength
    );

#define DUPLICATE_CLOSE_SOURCE 0x00000001
#define DUPLICATE_SAME_ACCESS 0x00000002
#define DUPLICATE_SAME_ATTRIBUTES 0x00000004

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDuplicateObject(
    _In_ HANDLE SourceProcessHandle,
    _In_ HANDLE SourceHandle,
    _In_opt_ HANDLE TargetProcessHandle,
    _Out_opt_ PHANDLE TargetHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _In_ ULONG Options
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtMakeTemporaryObject(
    _In_ HANDLE Handle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtMakePermanentObject(
    _In_ HANDLE Handle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSignalAndWaitForSingleObject(
    _In_ HANDLE SignalHandle,
    _In_ HANDLE WaitHandle,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWaitForSingleObject(
    _In_ HANDLE Handle,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWaitForMultipleObjects(
    _In_ ULONG Count,
    _In_reads_(Count) HANDLE Handles[],
    _In_ WAIT_TYPE WaitType,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout
    );

#if (PHNT_VERSION >= PHNT_WS03)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtWaitForMultipleObjects32(
    _In_ ULONG Count,
    _In_reads_(Count) LONG Handles[],
    _In_ WAIT_TYPE WaitType,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetSecurityObject(
    _In_ HANDLE Handle,
    _In_ SECURITY_INFORMATION SecurityInformation,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySecurityObject(
    _In_ HANDLE Handle,
    _In_ SECURITY_INFORMATION SecurityInformation,
    _Out_writes_bytes_opt_(Length) PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ ULONG Length,
    _Out_ PULONG LengthNeeded
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtClose(
    _In_ _Post_ptr_invalid_ HANDLE Handle
    );

#if (PHNT_VERSION >= PHNT_THRESHOLD)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCompareObjects(
    _In_ HANDLE FirstObjectHandle,
    _In_ HANDLE SecondObjectHandle
    );
#endif

#endif

// Directory objects

#if (PHNT_MODE != PHNT_MODE_KERNEL)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateDirectoryObject(
    _Out_ PHANDLE DirectoryHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

#if (PHNT_VERSION >= PHNT_WIN8)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateDirectoryObjectEx(
    _Out_ PHANDLE DirectoryHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ShadowDirectoryHandle,
    _In_ ULONG Flags
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenDirectoryObject(
    _Out_ PHANDLE DirectoryHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

typedef struct _OBJECT_DIRECTORY_INFORMATION
{
    UNICODE_STRING Name;
    UNICODE_STRING TypeName;
} OBJECT_DIRECTORY_INFORMATION, *POBJECT_DIRECTORY_INFORMATION;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryDirectoryObject(
    _In_ HANDLE DirectoryHandle,
    _Out_writes_bytes_opt_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_ BOOLEAN RestartScan,
    _Inout_ PULONG Context,
    _Out_opt_ PULONG ReturnLength
    );

#endif

// Private namespaces

#if (PHNT_MODE != PHNT_MODE_KERNEL)

#if (PHNT_VERSION >= PHNT_VISTA)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreatePrivateNamespace(
    _Out_ PHANDLE NamespaceHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ PVOID BoundaryDescriptor
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenPrivateNamespace(
    _Out_ PHANDLE NamespaceHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ PVOID BoundaryDescriptor
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeletePrivateNamespace(
    _In_ HANDLE NamespaceHandle
    );

#endif

#endif

// Symbolic links

#if (PHNT_MODE != PHNT_MODE_KERNEL)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateSymbolicLinkObject(
    _Out_ PHANDLE LinkHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ PUNICODE_STRING LinkTarget
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenSymbolicLinkObject(
    _Out_ PHANDLE LinkHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySymbolicLinkObject(
    _In_ HANDLE LinkHandle,
    _Inout_ PUNICODE_STRING LinkTarget,
    _Out_opt_ PULONG ReturnedLength
    );

#endif

#endif

```

`phnt/ntpebteb.h`:

```h
#ifndef _NTPEBTEB_H
#define _NTPEBTEB_H

typedef struct _RTL_USER_PROCESS_PARAMETERS *PRTL_USER_PROCESS_PARAMETERS;
typedef struct _RTL_CRITICAL_SECTION *PRTL_CRITICAL_SECTION;

// private
typedef struct _ACTIVATION_CONTEXT_STACK
{
    struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME* ActiveFrame;
    LIST_ENTRY FrameListCache;
    ULONG Flags;
    ULONG NextCookieSequenceNumber;
    ULONG StackId;
} ACTIVATION_CONTEXT_STACK, *PACTIVATION_CONTEXT_STACK;

// private
typedef struct _API_SET_NAMESPACE
{
    ULONG Version;
    ULONG Size;
    ULONG Flags;
    ULONG Count;
    ULONG EntryOffset;
    ULONG HashOffset;
    ULONG HashFactor;
} API_SET_NAMESPACE, *PAPI_SET_NAMESPACE;

// private
typedef struct _API_SET_HASH_ENTRY
{
    ULONG Hash;
    ULONG Index;
} API_SET_HASH_ENTRY, *PAPI_SET_HASH_ENTRY;

// private
typedef struct _API_SET_NAMESPACE_ENTRY
{
    ULONG Flags;
    ULONG NameOffset;
    ULONG NameLength;
    ULONG HashedLength;
    ULONG ValueOffset;
    ULONG ValueCount;
} API_SET_NAMESPACE_ENTRY, *PAPI_SET_NAMESPACE_ENTRY;

// private
typedef struct _API_SET_VALUE_ENTRY 
{
    ULONG Flags;
    ULONG NameOffset;
    ULONG NameLength;
    ULONG ValueOffset;
    ULONG ValueLength;
} API_SET_VALUE_ENTRY, *PAPI_SET_VALUE_ENTRY;

// symbols
typedef struct _PEB
{
    BOOLEAN InheritedAddressSpace;
    BOOLEAN ReadImageFileExecOptions;
    BOOLEAN BeingDebugged;
    union
    {
        BOOLEAN BitField;
        struct
        {
            BOOLEAN ImageUsesLargePages : 1;
            BOOLEAN IsProtectedProcess : 1;
            BOOLEAN IsImageDynamicallyRelocated : 1;
            BOOLEAN SkipPatchingUser32Forwarders : 1;
            BOOLEAN IsPackagedProcess : 1;
            BOOLEAN IsAppContainer : 1;
            BOOLEAN IsProtectedProcessLight : 1;
            BOOLEAN IsLongPathAwareProcess : 1;
        };
    };

    HANDLE Mutant;

    PVOID ImageBaseAddress;
    PPEB_LDR_DATA Ldr;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    PVOID SubSystemData;
    PVOID ProcessHeap;
    PRTL_CRITICAL_SECTION FastPebLock;
    PVOID IFEOKey;
    PSLIST_HEADER AtlThunkSListPtr;
    union
    {
        ULONG CrossProcessFlags;
        struct
        {
            ULONG ProcessInJob : 1;
            ULONG ProcessInitializing : 1;
            ULONG ProcessUsingVEH : 1;
            ULONG ProcessUsingVCH : 1;
            ULONG ProcessUsingFTH : 1;
            ULONG ProcessPreviouslyThrottled : 1;
            ULONG ProcessCurrentlyThrottled : 1;
            ULONG ProcessImagesHotPatched : 1; // REDSTONE5
            ULONG ReservedBits0 : 24;
        };
    };
    union
    {
        PVOID KernelCallbackTable;
        PVOID UserSharedInfoPtr;
    };
    ULONG SystemReserved;
    ULONG AtlThunkSListPtr32;
    PAPI_SET_NAMESPACE ApiSetMap;
    ULONG TlsExpansionCounter;
    PVOID TlsBitmap;
    ULONG TlsBitmapBits[2];
    
    PVOID ReadOnlySharedMemoryBase; 
    PVOID SharedData; // HotpatchInformation
    PVOID *ReadOnlyStaticServerData;
    
    PVOID AnsiCodePageData; // PCPTABLEINFO
    PVOID OemCodePageData; // PCPTABLEINFO
    PVOID UnicodeCaseTableData; // PNLSTABLEINFO

    ULONG NumberOfProcessors;
    ULONG NtGlobalFlag;

    ULARGE_INTEGER CriticalSectionTimeout;
    SIZE_T HeapSegmentReserve;
    SIZE_T HeapSegmentCommit;
    SIZE_T HeapDeCommitTotalFreeThreshold;
    SIZE_T HeapDeCommitFreeBlockThreshold;

    ULONG NumberOfHeaps;
    ULONG MaximumNumberOfHeaps;
    PVOID *ProcessHeaps; // PHEAP

    PVOID GdiSharedHandleTable;
    PVOID ProcessStarterHelper;
    ULONG GdiDCAttributeList;

    PRTL_CRITICAL_SECTION LoaderLock;

    ULONG OSMajorVersion;
    ULONG OSMinorVersion;
    USHORT OSBuildNumber;
    USHORT OSCSDVersion;
    ULONG OSPlatformId;
    ULONG ImageSubsystem;
    ULONG ImageSubsystemMajorVersion;
    ULONG ImageSubsystemMinorVersion;
    ULONG_PTR ActiveProcessAffinityMask;
    GDI_HANDLE_BUFFER GdiHandleBuffer;
    PVOID PostProcessInitRoutine;

    PVOID TlsExpansionBitmap;
    ULONG TlsExpansionBitmapBits[32];

    ULONG SessionId;

    ULARGE_INTEGER AppCompatFlags;
    ULARGE_INTEGER AppCompatFlagsUser;
    PVOID pShimData;
    PVOID AppCompatInfo; // APPCOMPAT_EXE_DATA

    UNICODE_STRING CSDVersion;

    PVOID ActivationContextData; // ACTIVATION_CONTEXT_DATA
    PVOID ProcessAssemblyStorageMap; // ASSEMBLY_STORAGE_MAP
    PVOID SystemDefaultActivationContextData; // ACTIVATION_CONTEXT_DATA
    PVOID SystemAssemblyStorageMap; // ASSEMBLY_STORAGE_MAP

    SIZE_T MinimumStackCommit;

    PVOID SparePointers[4]; // 19H1 (previously FlsCallback to FlsHighIndex)
    ULONG SpareUlongs[5]; // 19H1
    //PVOID* FlsCallback;
    //LIST_ENTRY FlsListHead;
    //PVOID FlsBitmap;
    //ULONG FlsBitmapBits[FLS_MAXIMUM_AVAILABLE / (sizeof(ULONG) * 8)];
    //ULONG FlsHighIndex;

    PVOID WerRegistrationData;
    PVOID WerShipAssertPtr;
    PVOID pUnused; // pContextData
    PVOID pImageHeaderHash;
    union
    {
        ULONG TracingFlags;
        struct
        {
            ULONG HeapTracingEnabled : 1;
            ULONG CritSecTracingEnabled : 1;
            ULONG LibLoaderTracingEnabled : 1;
            ULONG SpareTracingBits : 29;
        };
    };
    ULONGLONG CsrServerReadOnlySharedMemoryBase;
    PRTL_CRITICAL_SECTION TppWorkerpListLock;
    LIST_ENTRY TppWorkerpList;
    PVOID WaitOnAddressHashTable[128];
    PVOID TelemetryCoverageHeader; // REDSTONE3
    ULONG CloudFileFlags;
    ULONG CloudFileDiagFlags; // REDSTONE4
    CHAR PlaceholderCompatibilityMode;
    CHAR PlaceholderCompatibilityModeReserved[7];
    struct _LEAP_SECOND_DATA *LeapSecondData; // REDSTONE5
    union
    {
        ULONG LeapSecondFlags;
        struct
        {
            ULONG SixtySecondEnabled : 1;
            ULONG Reserved : 31;
        };
    };
    ULONG NtGlobalFlag2;
} PEB, *PPEB;

#ifdef _WIN64
C_ASSERT(FIELD_OFFSET(PEB, SessionId) == 0x2C0);
//C_ASSERT(sizeof(PEB) == 0x7B0); // REDSTONE3
//C_ASSERT(sizeof(PEB) == 0x7B8); // REDSTONE4
C_ASSERT(sizeof(PEB) == 0x7C8); // REDSTONE5 // 19H1
#else
C_ASSERT(FIELD_OFFSET(PEB, SessionId) == 0x1D4);
//C_ASSERT(sizeof(PEB) == 0x468); // REDSTONE3
//C_ASSERT(sizeof(PEB) == 0x470); // REDSTONE4
C_ASSERT(sizeof(PEB) == 0x480); // REDSTONE5 // 19H1
#endif

#define GDI_BATCH_BUFFER_SIZE 310

typedef struct _GDI_TEB_BATCH
{
    ULONG Offset;
    ULONG_PTR HDC;
    ULONG Buffer[GDI_BATCH_BUFFER_SIZE];
} GDI_TEB_BATCH, *PGDI_TEB_BATCH;

typedef struct _TEB_ACTIVE_FRAME_CONTEXT
{
    ULONG Flags;
    PSTR FrameName;
} TEB_ACTIVE_FRAME_CONTEXT, *PTEB_ACTIVE_FRAME_CONTEXT;

typedef struct _TEB_ACTIVE_FRAME
{
    ULONG Flags;
    struct _TEB_ACTIVE_FRAME *Previous;
    PTEB_ACTIVE_FRAME_CONTEXT Context;
} TEB_ACTIVE_FRAME, *PTEB_ACTIVE_FRAME;

typedef struct _TEB
{
    NT_TIB NtTib;

    PVOID EnvironmentPointer;
    CLIENT_ID ClientId;
    PVOID ActiveRpcHandle;
    PVOID ThreadLocalStoragePointer;
    PPEB ProcessEnvironmentBlock;

    ULONG LastErrorValue;
    ULONG CountOfOwnedCriticalSections;
    PVOID CsrClientThread;
    PVOID Win32ThreadInfo;
    ULONG User32Reserved[26];
    ULONG UserReserved[5];
    PVOID WOW32Reserved;
    LCID CurrentLocale;
    ULONG FpSoftwareStatusRegister;
    PVOID ReservedForDebuggerInstrumentation[16];
#ifdef _WIN64
    PVOID SystemReserved1[30];
#else
    PVOID SystemReserved1[26];
#endif
    
    CHAR PlaceholderCompatibilityMode;
    CHAR PlaceholderReserved[11];
    ULONG ProxiedProcessId;
    ACTIVATION_CONTEXT_STACK ActivationStack;
    
    UCHAR WorkingOnBehalfTicket[8];
    NTSTATUS ExceptionCode;

    PACTIVATION_CONTEXT_STACK ActivationContextStackPointer;
    ULONG_PTR InstrumentationCallbackSp;
    ULONG_PTR InstrumentationCallbackPreviousPc;
    ULONG_PTR InstrumentationCallbackPreviousSp;
#ifdef _WIN64
    ULONG TxFsContext;
#endif

    BOOLEAN InstrumentationCallbackDisabled;
#ifndef _WIN64
    UCHAR SpareBytes[23];
    ULONG TxFsContext;
#endif
    GDI_TEB_BATCH GdiTebBatch;
    CLIENT_ID RealClientId;
    HANDLE GdiCachedProcessHandle;
    ULONG GdiClientPID;
    ULONG GdiClientTID;
    PVOID GdiThreadLocalInfo;
    ULONG_PTR Win32ClientInfo[62];
    PVOID glDispatchTable[233];
    ULONG_PTR glReserved1[29];
    PVOID glReserved2;
    PVOID glSectionInfo;
    PVOID glSection;
    PVOID glTable;
    PVOID glCurrentRC;
    PVOID glContext;

    NTSTATUS LastStatusValue;
    UNICODE_STRING StaticUnicodeString;
    WCHAR StaticUnicodeBuffer[261];

    PVOID DeallocationStack;
    PVOID TlsSlots[64];
    LIST_ENTRY TlsLinks;

    PVOID Vdm;
    PVOID ReservedForNtRpc;
    PVOID DbgSsReserved[2];

    ULONG HardErrorMode;
#ifdef _WIN64
    PVOID Instrumentation[11];
#else
    PVOID Instrumentation[9];
#endif
    GUID ActivityId;

    PVOID SubProcessTag;
    PVOID PerflibData;
    PVOID EtwTraceData;
    PVOID WinSockData;
    ULONG GdiBatchCount;

    union
    {
        PROCESSOR_NUMBER CurrentIdealProcessor;
        ULONG IdealProcessorValue;
        struct
        {
            UCHAR ReservedPad0;
            UCHAR ReservedPad1;
            UCHAR ReservedPad2;
            UCHAR IdealProcessor;
        };
    };

    ULONG GuaranteedStackBytes;
    PVOID ReservedForPerf;
    PVOID ReservedForOle;
    ULONG WaitingOnLoaderLock;
    PVOID SavedPriorityState;
    ULONG_PTR ReservedForCodeCoverage;
    PVOID ThreadPoolData;
    PVOID *TlsExpansionSlots;
#ifdef _WIN64
    PVOID DeallocationBStore;
    PVOID BStoreLimit;
#endif
    ULONG MuiGeneration;
    ULONG IsImpersonating;
    PVOID NlsCache;
    PVOID pShimData;
    USHORT HeapVirtualAffinity;
    USHORT LowFragHeapDataSlot;
    HANDLE CurrentTransactionHandle;
    PTEB_ACTIVE_FRAME ActiveFrame;
    PVOID FlsData;

    PVOID PreferredLanguages;
    PVOID UserPrefLanguages;
    PVOID MergedPrefLanguages;
    ULONG MuiImpersonation;

    union
    {
        USHORT CrossTebFlags;
        USHORT SpareCrossTebBits : 16;
    };
    union
    {
        USHORT SameTebFlags;
        struct
        {
            USHORT SafeThunkCall : 1;
            USHORT InDebugPrint : 1;
            USHORT HasFiberData : 1;
            USHORT SkipThreadAttach : 1;
            USHORT WerInShipAssertCode : 1;
            USHORT RanProcessInit : 1;
            USHORT ClonedThread : 1;
            USHORT SuppressDebugMsg : 1;
            USHORT DisableUserStackWalk : 1;
            USHORT RtlExceptionAttached : 1;
            USHORT InitialThread : 1;
            USHORT SessionAware : 1;
            USHORT LoadOwner : 1;
            USHORT LoaderWorker : 1;
            USHORT SkipLoaderInit : 1;
            USHORT SpareSameTebBits : 1;
        };
    };

    PVOID TxnScopeEnterCallback;
    PVOID TxnScopeExitCallback;
    PVOID TxnScopeContext;
    ULONG LockCount;
    LONG WowTebOffset;
    PVOID ResourceRetValue;
    PVOID ReservedForWdf;
    ULONGLONG ReservedForCrt;
    GUID EffectiveContainerId;
} TEB, *PTEB;

#endif

```

`phnt/ntpfapi.h`:

```h
#ifndef _NTPFAPI_H
#define _NTPFAPI_H

// begin_private

// Prefetch

typedef enum _PF_BOOT_PHASE_ID
{
    PfKernelInitPhase = 0,
    PfBootDriverInitPhase = 90,
    PfSystemDriverInitPhase = 120,
    PfSessionManagerInitPhase = 150,
    PfSMRegistryInitPhase = 180,
    PfVideoInitPhase = 210,
    PfPostVideoInitPhase = 240,
    PfBootAcceptedRegistryInitPhase = 270,
    PfUserShellReadyPhase = 300,
    PfMaxBootPhaseId = 900
} PF_BOOT_PHASE_ID;

typedef enum _PF_ENABLE_STATUS
{
    PfSvNotSpecified,
    PfSvEnabled,
    PfSvDisabled,
    PfSvMaxEnableStatus
} PF_ENABLE_STATUS;

typedef struct _PF_TRACE_LIMITS
{
    ULONG MaxNumPages;
    ULONG MaxNumSections;
    LONGLONG TimerPeriod;
} PF_TRACE_LIMITS, *PPF_TRACE_LIMITS;

typedef struct _PF_SYSTEM_PREFETCH_PARAMETERS
{
    PF_ENABLE_STATUS EnableStatus[2];
    PF_TRACE_LIMITS TraceLimits[2];
    ULONG MaxNumActiveTraces;
    ULONG MaxNumSavedTraces;
    WCHAR RootDirPath[32];
    WCHAR HostingApplicationList[128];
} PF_SYSTEM_PREFETCH_PARAMETERS, *PPF_SYSTEM_PREFETCH_PARAMETERS;

#define PF_BOOT_CONTROL_VERSION 1

typedef struct _PF_BOOT_CONTROL
{
    ULONG Version;
    ULONG DisableBootPrefetching;
} PF_BOOT_CONTROL, *PPF_BOOT_CONTROL;

typedef enum _PREFETCHER_INFORMATION_CLASS
{
    PrefetcherRetrieveTrace = 1, // q: CHAR[]
    PrefetcherSystemParameters, // q: PF_SYSTEM_PREFETCH_PARAMETERS
    PrefetcherBootPhase, // s: PF_BOOT_PHASE_ID
    PrefetcherRetrieveBootLoaderTrace, // q: CHAR[]
    PrefetcherBootControl // s: PF_BOOT_CONTROL
} PREFETCHER_INFORMATION_CLASS;

#define PREFETCHER_INFORMATION_VERSION 23 // rev
#define PREFETCHER_INFORMATION_MAGIC ('kuhC') // rev

typedef struct _PREFETCHER_INFORMATION
{
    ULONG Version;
    ULONG Magic;
    PREFETCHER_INFORMATION_CLASS PrefetcherInformationClass;
    PVOID PrefetcherInformation;
    ULONG PrefetcherInformationLength;
} PREFETCHER_INFORMATION, *PPREFETCHER_INFORMATION;

// Superfetch

typedef struct _PF_SYSTEM_SUPERFETCH_PARAMETERS
{
    ULONG EnabledComponents;
    ULONG BootID;
    ULONG SavedSectInfoTracesMax;
    ULONG SavedPageAccessTracesMax;
    ULONG ScenarioPrefetchTimeoutStandby;
    ULONG ScenarioPrefetchTimeoutHibernate;
} PF_SYSTEM_SUPERFETCH_PARAMETERS, *PPF_SYSTEM_SUPERFETCH_PARAMETERS;

#define PF_PFN_PRIO_REQUEST_VERSION 1
#define PF_PFN_PRIO_REQUEST_QUERY_MEMORY_LIST 0x1
#define PF_PFN_PRIO_REQUEST_VALID_FLAGS 0x1

typedef struct _PF_PFN_PRIO_REQUEST
{
    ULONG Version;
    ULONG RequestFlags;
    ULONG_PTR PfnCount;
    SYSTEM_MEMORY_LIST_INFORMATION MemInfo;
    MMPFN_IDENTITY PageData[256];
} PF_PFN_PRIO_REQUEST, *PPF_PFN_PRIO_REQUEST;

typedef enum _PFS_PRIVATE_PAGE_SOURCE_TYPE
{
    PfsPrivateSourceKernel,
    PfsPrivateSourceSession,
    PfsPrivateSourceProcess,
    PfsPrivateSourceMax
} PFS_PRIVATE_PAGE_SOURCE_TYPE;

typedef struct _PFS_PRIVATE_PAGE_SOURCE
{
    PFS_PRIVATE_PAGE_SOURCE_TYPE Type;
    union
    {
        ULONG SessionId;
        ULONG ProcessId;
    };
    ULONG ImagePathHash;
    ULONG_PTR UniqueProcessHash;
} PFS_PRIVATE_PAGE_SOURCE, *PPFS_PRIVATE_PAGE_SOURCE;

typedef struct _PF_PRIVSOURCE_INFO
{
    PFS_PRIVATE_PAGE_SOURCE DbInfo;
    PVOID EProcess;
    SIZE_T WsPrivatePages;
    SIZE_T TotalPrivatePages;
    ULONG SessionID;
    CHAR ImageName[16];
    union {
        ULONG_PTR WsSwapPages;                 // process only PF_PRIVSOURCE_QUERY_WS_SWAP_PAGES.
        ULONG_PTR SessionPagedPoolPages;       // session only.
        ULONG_PTR StoreSizePages;              // process only PF_PRIVSOURCE_QUERY_STORE_INFO.
    };
    ULONG_PTR WsTotalPages;         // process/session only.
    ULONG DeepFreezeTimeMs;         // process only.
    ULONG ModernApp : 1;            // process only.
    ULONG DeepFrozen : 1;           // process only. If set, DeepFreezeTimeMs contains the time at which the freeze occurred
    ULONG Foreground : 1;           // process only.
    ULONG PerProcessStore : 1;      // process only.
    ULONG Spare : 28;
} PF_PRIVSOURCE_INFO, *PPF_PRIVSOURCE_INFO;

#define PF_PRIVSOURCE_QUERY_REQUEST_VERSION 8

typedef struct _PF_PRIVSOURCE_QUERY_REQUEST
{
    ULONG Version;
    ULONG Flags;
    ULONG InfoCount;
    PF_PRIVSOURCE_INFO InfoArray[1];
} PF_PRIVSOURCE_QUERY_REQUEST, *PPF_PRIVSOURCE_QUERY_REQUEST;

typedef enum _PF_PHASED_SCENARIO_TYPE
{
    PfScenarioTypeNone,
    PfScenarioTypeStandby,
    PfScenarioTypeHibernate,
    PfScenarioTypeFUS,
    PfScenarioTypeMax
} PF_PHASED_SCENARIO_TYPE;

#define PF_SCENARIO_PHASE_INFO_VERSION 4

typedef struct _PF_SCENARIO_PHASE_INFO
{
    ULONG Version;
    PF_PHASED_SCENARIO_TYPE ScenType;
    ULONG PhaseId;
    ULONG SequenceNumber;
    ULONG Flags;
    ULONG FUSUserId;
} PF_SCENARIO_PHASE_INFO, *PPF_SCENARIO_PHASE_INFO;

typedef struct _PF_MEMORY_LIST_NODE
{
    ULONGLONG Node : 8;
    ULONGLONG Spare : 56;
    ULONGLONG StandbyLowPageCount;
    ULONGLONG StandbyMediumPageCount;
    ULONGLONG StandbyHighPageCount;
    ULONGLONG FreePageCount;
    ULONGLONG ModifiedPageCount;
} PF_MEMORY_LIST_NODE, *PPF_MEMORY_LIST_NODE;

#define PF_MEMORY_LIST_INFO_VERSION 1

typedef struct _PF_MEMORY_LIST_INFO
{
    ULONG Version;
    ULONG Size;
    ULONG NodeCount;
    PF_MEMORY_LIST_NODE Nodes[1];
} PF_MEMORY_LIST_INFO, *PPF_MEMORY_LIST_INFO;

typedef struct _PF_PHYSICAL_MEMORY_RANGE
{
    ULONG_PTR BasePfn;
    ULONG_PTR PageCount;
} PF_PHYSICAL_MEMORY_RANGE, *PPF_PHYSICAL_MEMORY_RANGE;

#define PF_PHYSICAL_MEMORY_RANGE_INFO_V1_VERSION 1

typedef struct _PF_PHYSICAL_MEMORY_RANGE_INFO_V1
{
    ULONG Version;
    ULONG RangeCount;
    PF_PHYSICAL_MEMORY_RANGE Ranges[1];
} PF_PHYSICAL_MEMORY_RANGE_INFO_V1, *PPF_PHYSICAL_MEMORY_RANGE_INFO_V1;

#define PF_PHYSICAL_MEMORY_RANGE_INFO_V2_VERSION 2

typedef struct _PF_PHYSICAL_MEMORY_RANGE_INFO_V2
{
    ULONG Version;
    ULONG Flags;
    ULONG RangeCount;
    PF_PHYSICAL_MEMORY_RANGE Ranges[ANYSIZE_ARRAY];
} PF_PHYSICAL_MEMORY_RANGE_INFO_V2, *PPF_PHYSICAL_MEMORY_RANGE_INFO_V2;

// begin_rev

#define PF_REPURPOSED_BY_PREFETCH_INFO_VERSION 1

typedef struct _PF_REPURPOSED_BY_PREFETCH_INFO
{
    ULONG Version;
    ULONG RepurposedByPrefetch;
} PF_REPURPOSED_BY_PREFETCH_INFO, *PPF_REPURPOSED_BY_PREFETCH_INFO;

// end_rev

typedef enum _SUPERFETCH_INFORMATION_CLASS
{
    SuperfetchRetrieveTrace = 1, // q: CHAR[]
    SuperfetchSystemParameters, // q: PF_SYSTEM_SUPERFETCH_PARAMETERS
    SuperfetchLogEvent,
    SuperfetchGenerateTrace,
    SuperfetchPrefetch,
    SuperfetchPfnQuery, // q: PF_PFN_PRIO_REQUEST
    SuperfetchPfnSetPriority,
    SuperfetchPrivSourceQuery, // q: PF_PRIVSOURCE_QUERY_REQUEST
    SuperfetchSequenceNumberQuery, // q: ULONG
    SuperfetchScenarioPhase, // 10
    SuperfetchWorkerPriority,
    SuperfetchScenarioQuery, // q: PF_SCENARIO_PHASE_INFO
    SuperfetchScenarioPrefetch,
    SuperfetchRobustnessControl,
    SuperfetchTimeControl,
    SuperfetchMemoryListQuery, // q: PF_MEMORY_LIST_INFO
    SuperfetchMemoryRangesQuery, // q: PF_PHYSICAL_MEMORY_RANGE_INFO
    SuperfetchTracingControl,
    SuperfetchTrimWhileAgingControl,
    SuperfetchRepurposedByPrefetch, // q: PF_REPURPOSED_BY_PREFETCH_INFO // rev
    SuperfetchInformationMax
} SUPERFETCH_INFORMATION_CLASS;

#define SUPERFETCH_INFORMATION_VERSION 45 // rev
#define SUPERFETCH_INFORMATION_MAGIC ('kuhC') // rev

typedef struct _SUPERFETCH_INFORMATION
{
    _In_ ULONG Version;
    _In_ ULONG Magic;
    _In_ SUPERFETCH_INFORMATION_CLASS InfoClass;
    _Inout_ PVOID Data;
    _Inout_ ULONG Length;
} SUPERFETCH_INFORMATION, *PSUPERFETCH_INFORMATION;

// end_private

#endif

```

`phnt/ntpnpapi.h`:

```h
#ifndef _NTPNPAPI_H
#define _NTPNPAPI_H

typedef enum _PLUGPLAY_EVENT_CATEGORY
{
    HardwareProfileChangeEvent,
    TargetDeviceChangeEvent,
    DeviceClassChangeEvent,
    CustomDeviceEvent,
    DeviceInstallEvent,
    DeviceArrivalEvent,
    PowerEvent,
    VetoEvent,
    BlockedDriverEvent,
    InvalidIDEvent,
    MaxPlugEventCategory
} PLUGPLAY_EVENT_CATEGORY, *PPLUGPLAY_EVENT_CATEGORY;

typedef struct _PLUGPLAY_EVENT_BLOCK
{
    GUID EventGuid;
    PLUGPLAY_EVENT_CATEGORY EventCategory;
    PULONG Result;
    ULONG Flags;
    ULONG TotalSize;
    PVOID DeviceObject;

    union
    {
        struct
        {
            GUID ClassGuid;
            WCHAR SymbolicLinkName[1];
        } DeviceClass;
        struct
        {
            WCHAR DeviceIds[1];
        } TargetDevice;
        struct
        {
            WCHAR DeviceId[1];
        } InstallDevice;
        struct
        {
            PVOID NotificationStructure;
            WCHAR DeviceIds[1];
        } CustomNotification;
        struct
        {
            PVOID Notification;
        } ProfileNotification;
        struct
        {
            ULONG NotificationCode;
            ULONG NotificationData;
        } PowerNotification;
        struct
        {
            PNP_VETO_TYPE VetoType;
            WCHAR DeviceIdVetoNameBuffer[1]; // DeviceId<null>VetoName<null><null>
        } VetoNotification;
        struct
        {
            GUID BlockedDriverGuid;
        } BlockedDriverNotification;
        struct
        {
            WCHAR ParentId[1];
        } InvalidIDNotification;
    } u;
} PLUGPLAY_EVENT_BLOCK, *PPLUGPLAY_EVENT_BLOCK;

typedef enum _PLUGPLAY_CONTROL_CLASS
{
    PlugPlayControlEnumerateDevice,
    PlugPlayControlRegisterNewDevice,
    PlugPlayControlDeregisterDevice,
    PlugPlayControlInitializeDevice,
    PlugPlayControlStartDevice,
    PlugPlayControlUnlockDevice,
    PlugPlayControlQueryAndRemoveDevice,
    PlugPlayControlUserResponse,
    PlugPlayControlGenerateLegacyDevice,
    PlugPlayControlGetInterfaceDeviceList,
    PlugPlayControlProperty,
    PlugPlayControlDeviceClassAssociation,
    PlugPlayControlGetRelatedDevice,
    PlugPlayControlGetInterfaceDeviceAlias,
    PlugPlayControlDeviceStatus,
    PlugPlayControlGetDeviceDepth,
    PlugPlayControlQueryDeviceRelations,
    PlugPlayControlTargetDeviceRelation,
    PlugPlayControlQueryConflictList,
    PlugPlayControlRetrieveDock,
    PlugPlayControlResetDevice,
    PlugPlayControlHaltDevice,
    PlugPlayControlGetBlockedDriverList,
    PlugPlayControlGetDeviceInterfaceEnabled,
    MaxPlugPlayControl
} PLUGPLAY_CONTROL_CLASS, *PPLUGPLAY_CONTROL_CLASS;

#if (PHNT_VERSION < PHNT_WIN8)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtGetPlugPlayEvent(
    _In_ HANDLE EventHandle,
    _In_opt_ PVOID Context,
    _Out_writes_bytes_(EventBufferSize) PPLUGPLAY_EVENT_BLOCK EventBlock,
    _In_ ULONG EventBufferSize
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPlugPlayControl(
    _In_ PLUGPLAY_CONTROL_CLASS PnPControlClass,
    _Inout_updates_bytes_(PnPControlDataLength) PVOID PnPControlData,
    _In_ ULONG PnPControlDataLength
    );

#if (PHNT_VERSION >= PHNT_WIN7)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSerializeBoot(
    VOID
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtEnableLastKnownGood(
    VOID
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDisableLastKnownGood(
    VOID
    );

#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtReplacePartitionUnit(
    _In_ PUNICODE_STRING TargetInstancePath,
    _In_ PUNICODE_STRING SpareInstancePath,
    _In_ ULONG Flags
    );
#endif

#endif

```

`phnt/ntpoapi.h`:

```h
#ifndef _NTPOAPI_H
#define _NTPOAPI_H

typedef union _POWER_STATE
{
    SYSTEM_POWER_STATE SystemState;
    DEVICE_POWER_STATE DeviceState;
} POWER_STATE, *PPOWER_STATE;

typedef enum _POWER_STATE_TYPE
{
    SystemPowerState = 0,
    DevicePowerState
} POWER_STATE_TYPE, *PPOWER_STATE_TYPE;

#if (PHNT_VERSION >= PHNT_VISTA)
// wdm
typedef struct _SYSTEM_POWER_STATE_CONTEXT
{
    union
    {
        struct
        {
            ULONG Reserved1 : 8;
            ULONG TargetSystemState : 4;
            ULONG EffectiveSystemState : 4;
            ULONG CurrentSystemState : 4;
            ULONG IgnoreHibernationPath : 1;
            ULONG PseudoTransition : 1;
            ULONG Reserved2 : 10;
        };
        ULONG ContextAsUlong;
    };
} SYSTEM_POWER_STATE_CONTEXT, *PSYSTEM_POWER_STATE_CONTEXT;
#endif

#if (PHNT_VERSION >= PHNT_WIN7)
/** \cond NEVER */ // disable doxygen warning
// wdm
typedef struct _COUNTED_REASON_CONTEXT
{
    ULONG Version;
    ULONG Flags;
    union
    {
        struct
        {
            UNICODE_STRING ResourceFileName;
            USHORT ResourceReasonId;
            ULONG StringCount;
            PUNICODE_STRING _Field_size_(StringCount) ReasonStrings;
        };
        UNICODE_STRING SimpleString;
    };
} COUNTED_REASON_CONTEXT, *PCOUNTED_REASON_CONTEXT;
/** \endcond */
#endif

typedef enum _POWER_STATE_HANDLER_TYPE
{
    PowerStateSleeping1 = 0,
    PowerStateSleeping2 = 1,
    PowerStateSleeping3 = 2,
    PowerStateSleeping4 = 3,
    PowerStateShutdownOff = 4,
    PowerStateShutdownReset = 5,
    PowerStateSleeping4Firmware = 6,
    PowerStateMaximum = 7
} POWER_STATE_HANDLER_TYPE, *PPOWER_STATE_HANDLER_TYPE;

typedef NTSTATUS (NTAPI *PENTER_STATE_SYSTEM_HANDLER)(
    _In_ PVOID SystemContext
    );

typedef NTSTATUS (NTAPI *PENTER_STATE_HANDLER)(
    _In_ PVOID Context,
    _In_opt_ PENTER_STATE_SYSTEM_HANDLER SystemHandler,
    _In_ PVOID SystemContext,
    _In_ LONG NumberProcessors,
    _In_ volatile PLONG Number
    );

typedef struct _POWER_STATE_HANDLER
{
    POWER_STATE_HANDLER_TYPE Type;
    BOOLEAN RtcWake;
    UCHAR Spare[3];
    PENTER_STATE_HANDLER Handler;
    PVOID Context;
} POWER_STATE_HANDLER, *PPOWER_STATE_HANDLER;

typedef NTSTATUS (NTAPI *PENTER_STATE_NOTIFY_HANDLER)(
    _In_ POWER_STATE_HANDLER_TYPE State,
    _In_ PVOID Context,
    _In_ BOOLEAN Entering
    );

typedef struct _POWER_STATE_NOTIFY_HANDLER
{
    PENTER_STATE_NOTIFY_HANDLER Handler;
    PVOID Context;
} POWER_STATE_NOTIFY_HANDLER, *PPOWER_STATE_NOTIFY_HANDLER;

typedef struct _PROCESSOR_POWER_INFORMATION
{
    ULONG Number;
    ULONG MaxMhz;
    ULONG CurrentMhz;
    ULONG MhzLimit;
    ULONG MaxIdleState;
    ULONG CurrentIdleState;
} PROCESSOR_POWER_INFORMATION, *PPROCESSOR_POWER_INFORMATION;

typedef struct _SYSTEM_POWER_INFORMATION
{
    ULONG MaxIdlenessAllowed;
    ULONG Idleness;
    ULONG TimeRemaining;
    UCHAR CoolingMode;
} SYSTEM_POWER_INFORMATION, *PSYSTEM_POWER_INFORMATION;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPowerInformation(
    _In_ POWER_INFORMATION_LEVEL InformationLevel,
    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetThreadExecutionState(
    _In_ EXECUTION_STATE NewFlags, // ES_* flags
    _Out_ EXECUTION_STATE *PreviousFlags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRequestWakeupLatency(
    _In_ LATENCY_TIME latency
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtInitiatePowerAction(
    _In_ POWER_ACTION SystemAction,
    _In_ SYSTEM_POWER_STATE LightestSystemState,
    _In_ ULONG Flags, // POWER_ACTION_* flags
    _In_ BOOLEAN Asynchronous
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetSystemPowerState(
    _In_ POWER_ACTION SystemAction,
    _In_ SYSTEM_POWER_STATE LightestSystemState,
    _In_ ULONG Flags // POWER_ACTION_* flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtGetDevicePowerState(
    _In_ HANDLE Device,
    _Out_ PDEVICE_POWER_STATE State
    );

NTSYSCALLAPI
BOOLEAN
NTAPI
NtIsSystemResumeAutomatic(
    VOID
    );

#endif

```

`phnt/ntpsapi.h`:

```h
#ifndef _NTPSAPI_H
#define _NTPSAPI_H

#if (PHNT_MODE == PHNT_MODE_KERNEL)
#define PROCESS_TERMINATE 0x0001
#define PROCESS_CREATE_THREAD 0x0002
#define PROCESS_SET_SESSIONID 0x0004
#define PROCESS_VM_OPERATION 0x0008
#define PROCESS_VM_READ 0x0010
#define PROCESS_VM_WRITE 0x0020
#define PROCESS_CREATE_PROCESS 0x0080
#define PROCESS_SET_QUOTA 0x0100
#define PROCESS_SET_INFORMATION 0x0200
#define PROCESS_QUERY_INFORMATION 0x0400
#define PROCESS_SET_PORT 0x0800
#define PROCESS_SUSPEND_RESUME 0x0800
#define PROCESS_QUERY_LIMITED_INFORMATION 0x1000
#else
#ifndef PROCESS_SET_PORT
#define PROCESS_SET_PORT 0x0800
#endif
#endif

#if (PHNT_MODE == PHNT_MODE_KERNEL)
#define THREAD_QUERY_INFORMATION 0x0040
#define THREAD_SET_THREAD_TOKEN 0x0080
#define THREAD_IMPERSONATE 0x0100
#define THREAD_DIRECT_IMPERSONATION 0x0200
#else
#ifndef THREAD_ALERT
#define THREAD_ALERT 0x0004
#endif
#endif

#if (PHNT_MODE == PHNT_MODE_KERNEL)
#define JOB_OBJECT_ASSIGN_PROCESS 0x0001
#define JOB_OBJECT_SET_ATTRIBUTES 0x0002
#define JOB_OBJECT_QUERY 0x0004
#define JOB_OBJECT_TERMINATE 0x0008
#define JOB_OBJECT_SET_SECURITY_ATTRIBUTES 0x0010
#define JOB_OBJECT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x1f)
#endif

#define GDI_HANDLE_BUFFER_SIZE32 34
#define GDI_HANDLE_BUFFER_SIZE64 60

#ifndef _WIN64
#define GDI_HANDLE_BUFFER_SIZE GDI_HANDLE_BUFFER_SIZE32
#else
#define GDI_HANDLE_BUFFER_SIZE GDI_HANDLE_BUFFER_SIZE64
#endif

typedef ULONG GDI_HANDLE_BUFFER[GDI_HANDLE_BUFFER_SIZE];

typedef ULONG GDI_HANDLE_BUFFER32[GDI_HANDLE_BUFFER_SIZE32];
typedef ULONG GDI_HANDLE_BUFFER64[GDI_HANDLE_BUFFER_SIZE64];

//#define FLS_MAXIMUM_AVAILABLE 128
#define TLS_MINIMUM_AVAILABLE 64
#define TLS_EXPANSION_SLOTS 1024

// symbols
typedef struct _PEB_LDR_DATA
{
    ULONG Length;
    BOOLEAN Initialized;
    HANDLE SsHandle;
    LIST_ENTRY InLoadOrderModuleList;
    LIST_ENTRY InMemoryOrderModuleList;
    LIST_ENTRY InInitializationOrderModuleList;
    PVOID EntryInProgress;
    BOOLEAN ShutdownInProgress;
    HANDLE ShutdownThreadId;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef struct _INITIAL_TEB
{
    struct
    {
        PVOID OldStackBase;
        PVOID OldStackLimit;
    } OldInitialTeb;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID StackAllocationBase;
} INITIAL_TEB, *PINITIAL_TEB;

typedef struct _WOW64_PROCESS
{
    PVOID Wow64;
} WOW64_PROCESS, *PWOW64_PROCESS;

#include "ntpebteb.h"

#if (PHNT_MODE != PHNT_MODE_KERNEL)
typedef enum _PROCESSINFOCLASS
{
    ProcessBasicInformation, // q: PROCESS_BASIC_INFORMATION, PROCESS_EXTENDED_BASIC_INFORMATION
    ProcessQuotaLimits, // qs: QUOTA_LIMITS, QUOTA_LIMITS_EX
    ProcessIoCounters, // q: IO_COUNTERS
    ProcessVmCounters, // q: VM_COUNTERS, VM_COUNTERS_EX, VM_COUNTERS_EX2
    ProcessTimes, // q: KERNEL_USER_TIMES
    ProcessBasePriority, // s: KPRIORITY
    ProcessRaisePriority, // s: ULONG
    ProcessDebugPort, // q: HANDLE
    ProcessExceptionPort, // s: PROCESS_EXCEPTION_PORT
    ProcessAccessToken, // s: PROCESS_ACCESS_TOKEN
    ProcessLdtInformation, // qs: PROCESS_LDT_INFORMATION // 10
    ProcessLdtSize, // s: PROCESS_LDT_SIZE
    ProcessDefaultHardErrorMode, // qs: ULONG
    ProcessIoPortHandlers, // (kernel-mode only)
    ProcessPooledUsageAndLimits, // q: POOLED_USAGE_AND_LIMITS
    ProcessWorkingSetWatch, // q: PROCESS_WS_WATCH_INFORMATION[]; s: void
    ProcessUserModeIOPL,
    ProcessEnableAlignmentFaultFixup, // s: BOOLEAN
    ProcessPriorityClass, // qs: PROCESS_PRIORITY_CLASS
    ProcessWx86Information,
    ProcessHandleCount, // q: ULONG, PROCESS_HANDLE_INFORMATION // 20
    ProcessAffinityMask, // s: KAFFINITY
    ProcessPriorityBoost, // qs: ULONG
    ProcessDeviceMap, // qs: PROCESS_DEVICEMAP_INFORMATION, PROCESS_DEVICEMAP_INFORMATION_EX
    ProcessSessionInformation, // q: PROCESS_SESSION_INFORMATION
    ProcessForegroundInformation, // s: PROCESS_FOREGROUND_BACKGROUND
    ProcessWow64Information, // q: ULONG_PTR
    ProcessImageFileName, // q: UNICODE_STRING
    ProcessLUIDDeviceMapsEnabled, // q: ULONG
    ProcessBreakOnTermination, // qs: ULONG
    ProcessDebugObjectHandle, // q: HANDLE // 30
    ProcessDebugFlags, // qs: ULONG
    ProcessHandleTracing, // q: PROCESS_HANDLE_TRACING_QUERY; s: size 0 disables, otherwise enables
    ProcessIoPriority, // qs: IO_PRIORITY_HINT
    ProcessExecuteFlags, // qs: ULONG
    ProcessResourceManagement, // ProcessTlsInformation // PROCESS_TLS_INFORMATION
    ProcessCookie, // q: ULONG
    ProcessImageInformation, // q: SECTION_IMAGE_INFORMATION
    ProcessCycleTime, // q: PROCESS_CYCLE_TIME_INFORMATION // since VISTA
    ProcessPagePriority, // q: PAGE_PRIORITY_INFORMATION
    ProcessInstrumentationCallback, // qs: PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION // 40
    ProcessThreadStackAllocation, // s: PROCESS_STACK_ALLOCATION_INFORMATION, PROCESS_STACK_ALLOCATION_INFORMATION_EX
    ProcessWorkingSetWatchEx, // q: PROCESS_WS_WATCH_INFORMATION_EX[]
    ProcessImageFileNameWin32, // q: UNICODE_STRING
    ProcessImageFileMapping, // q: HANDLE (input)
    ProcessAffinityUpdateMode, // qs: PROCESS_AFFINITY_UPDATE_MODE
    ProcessMemoryAllocationMode, // qs: PROCESS_MEMORY_ALLOCATION_MODE
    ProcessGroupInformation, // q: USHORT[]
    ProcessTokenVirtualizationEnabled, // s: ULONG
    ProcessConsoleHostProcess, // q: ULONG_PTR // ProcessOwnerInformation
    ProcessWindowInformation, // q: PROCESS_WINDOW_INFORMATION // 50
    ProcessHandleInformation, // q: PROCESS_HANDLE_SNAPSHOT_INFORMATION // since WIN8
    ProcessMitigationPolicy, // s: PROCESS_MITIGATION_POLICY_INFORMATION
    ProcessDynamicFunctionTableInformation,
    ProcessHandleCheckingMode, // qs: ULONG; s: 0 disables, otherwise enables
    ProcessKeepAliveCount, // q: PROCESS_KEEPALIVE_COUNT_INFORMATION
    ProcessRevokeFileHandles, // s: PROCESS_REVOKE_FILE_HANDLES_INFORMATION
    ProcessWorkingSetControl, // s: PROCESS_WORKING_SET_CONTROL
    ProcessHandleTable, // q: ULONG[] // since WINBLUE
    ProcessCheckStackExtentsMode,
    ProcessCommandLineInformation, // q: UNICODE_STRING // 60
    ProcessProtectionInformation, // q: PS_PROTECTION
    ProcessMemoryExhaustion, // PROCESS_MEMORY_EXHAUSTION_INFO // since THRESHOLD
    ProcessFaultInformation, // PROCESS_FAULT_INFORMATION
    ProcessTelemetryIdInformation, // PROCESS_TELEMETRY_ID_INFORMATION
    ProcessCommitReleaseInformation, // PROCESS_COMMIT_RELEASE_INFORMATION
    ProcessDefaultCpuSetsInformation,
    ProcessAllowedCpuSetsInformation,
    ProcessSubsystemProcess,
    ProcessJobMemoryInformation, // PROCESS_JOB_MEMORY_INFO
    ProcessInPrivate, // since THRESHOLD2 // 70
    ProcessRaiseUMExceptionOnInvalidHandleClose, // qs: ULONG; s: 0 disables, otherwise enables
    ProcessIumChallengeResponse,
    ProcessChildProcessInformation, // PROCESS_CHILD_PROCESS_INFORMATION
    ProcessHighGraphicsPriorityInformation,
    ProcessSubsystemInformation, // q: SUBSYSTEM_INFORMATION_TYPE // since REDSTONE2
    ProcessEnergyValues, // PROCESS_ENERGY_VALUES, PROCESS_EXTENDED_ENERGY_VALUES
    ProcessActivityThrottleState, // PROCESS_ACTIVITY_THROTTLE_STATE
    ProcessActivityThrottlePolicy, // PROCESS_ACTIVITY_THROTTLE_POLICY
    ProcessWin32kSyscallFilterInformation,
    ProcessDisableSystemAllowedCpuSets, // 80
    ProcessWakeInformation, // PROCESS_WAKE_INFORMATION
    ProcessEnergyTrackingState, // PROCESS_ENERGY_TRACKING_STATE
    ProcessManageWritesToExecutableMemory, // MANAGE_WRITES_TO_EXECUTABLE_MEMORY // since REDSTONE3
    ProcessCaptureTrustletLiveDump,
    ProcessTelemetryCoverage,
    ProcessEnclaveInformation,
    ProcessEnableReadWriteVmLogging, // PROCESS_READWRITEVM_LOGGING_INFORMATION
    ProcessUptimeInformation, // PROCESS_UPTIME_INFORMATION
    ProcessImageSection, // q: HANDLE
    ProcessDebugAuthInformation, // since REDSTONE4 // 90
    ProcessSystemResourceManagement, // PROCESS_SYSTEM_RESOURCE_MANAGEMENT
    ProcessSequenceNumber, // q: ULONGLONG
    ProcessLoaderDetour, // since REDSTONE5
    ProcessSecurityDomainInformation, // PROCESS_SECURITY_DOMAIN_INFORMATION
    ProcessCombineSecurityDomainsInformation, // PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION
    ProcessEnableLogging, // PROCESS_LOGGING_INFORMATION
    ProcessLeapSecondInformation, // PROCESS_LEAP_SECOND_INFORMATION
    ProcessFiberShadowStackAllocation, // PROCESS_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION // since 19H1
    ProcessFreeFiberShadowStackAllocation, // PROCESS_FREE_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION
    MaxProcessInfoClass
} PROCESSINFOCLASS;
#endif

#if (PHNT_MODE != PHNT_MODE_KERNEL)
typedef enum _THREADINFOCLASS
{
    ThreadBasicInformation, // q: THREAD_BASIC_INFORMATION
    ThreadTimes, // q: KERNEL_USER_TIMES
    ThreadPriority, // s: KPRIORITY
    ThreadBasePriority, // s: LONG
    ThreadAffinityMask, // s: KAFFINITY
    ThreadImpersonationToken, // s: HANDLE
    ThreadDescriptorTableEntry, // q: DESCRIPTOR_TABLE_ENTRY (or WOW64_DESCRIPTOR_TABLE_ENTRY)
    ThreadEnableAlignmentFaultFixup, // s: BOOLEAN
    ThreadEventPair,
    ThreadQuerySetWin32StartAddress, // q: PVOID
    ThreadZeroTlsCell, // 10
    ThreadPerformanceCount, // q: LARGE_INTEGER
    ThreadAmILastThread, // q: ULONG
    ThreadIdealProcessor, // s: ULONG
    ThreadPriorityBoost, // qs: ULONG
    ThreadSetTlsArrayAddress,
    ThreadIsIoPending, // q: ULONG
    ThreadHideFromDebugger, // s: void
    ThreadBreakOnTermination, // qs: ULONG
    ThreadSwitchLegacyState,
    ThreadIsTerminated, // q: ULONG // 20
    ThreadLastSystemCall, // q: THREAD_LAST_SYSCALL_INFORMATION
    ThreadIoPriority, // qs: IO_PRIORITY_HINT
    ThreadCycleTime, // q: THREAD_CYCLE_TIME_INFORMATION
    ThreadPagePriority, // q: ULONG
    ThreadActualBasePriority,
    ThreadTebInformation, // q: THREAD_TEB_INFORMATION (requires THREAD_GET_CONTEXT + THREAD_SET_CONTEXT)
    ThreadCSwitchMon,
    ThreadCSwitchPmu,
    ThreadWow64Context, // q: WOW64_CONTEXT
    ThreadGroupInformation, // q: GROUP_AFFINITY // 30
    ThreadUmsInformation, // q: THREAD_UMS_INFORMATION
    ThreadCounterProfiling,
    ThreadIdealProcessorEx, // q: PROCESSOR_NUMBER
    ThreadCpuAccountingInformation, // since WIN8
    ThreadSuspendCount, // since WINBLUE
    ThreadHeterogeneousCpuPolicy, // q: KHETERO_CPU_POLICY // since THRESHOLD
    ThreadContainerId, // q: GUID
    ThreadNameInformation, // qs: THREAD_NAME_INFORMATION
    ThreadSelectedCpuSets,
    ThreadSystemThreadInformation, // q: SYSTEM_THREAD_INFORMATION // 40
    ThreadActualGroupAffinity, // since THRESHOLD2
    ThreadDynamicCodePolicyInfo,
    ThreadExplicitCaseSensitivity, // qs: ULONG; s: 0 disables, otherwise enables
    ThreadWorkOnBehalfTicket,
    ThreadSubsystemInformation, // q: SUBSYSTEM_INFORMATION_TYPE // since REDSTONE2
    ThreadDbgkWerReportActive,
    ThreadAttachContainer,
    ThreadManageWritesToExecutableMemory, // MANAGE_WRITES_TO_EXECUTABLE_MEMORY // since REDSTONE3
    ThreadPowerThrottlingState, // THREAD_POWER_THROTTLING_STATE
    ThreadWorkloadClass, // THREAD_WORKLOAD_CLASS // since REDSTONE5 // 50
    MaxThreadInfoClass
} THREADINFOCLASS;
#endif

#if (PHNT_MODE != PHNT_MODE_KERNEL)
// Use with both ProcessPagePriority and ThreadPagePriority
typedef struct _PAGE_PRIORITY_INFORMATION
{
    ULONG PagePriority;
} PAGE_PRIORITY_INFORMATION, *PPAGE_PRIORITY_INFORMATION;
#endif

// Process information structures

#if (PHNT_MODE != PHNT_MODE_KERNEL)

typedef struct _PROCESS_BASIC_INFORMATION
{
    NTSTATUS ExitStatus;
    PPEB PebBaseAddress;
    ULONG_PTR AffinityMask;
    KPRIORITY BasePriority;
    HANDLE UniqueProcessId;
    HANDLE InheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION, *PPROCESS_BASIC_INFORMATION;

typedef struct _PROCESS_EXTENDED_BASIC_INFORMATION
{
    SIZE_T Size; // set to sizeof structure on input
    PROCESS_BASIC_INFORMATION BasicInfo;
    union
    {
        ULONG Flags;
        struct
        {
            ULONG IsProtectedProcess : 1;
            ULONG IsWow64Process : 1;
            ULONG IsProcessDeleting : 1;
            ULONG IsCrossSessionCreate : 1;
            ULONG IsFrozen : 1;
            ULONG IsBackground : 1;
            ULONG IsStronglyNamed : 1;
            ULONG IsSecureProcess : 1;
            ULONG IsSubsystemProcess : 1;
            ULONG SpareBits : 23;
        };
    };
} PROCESS_EXTENDED_BASIC_INFORMATION, *PPROCESS_EXTENDED_BASIC_INFORMATION;

typedef struct _VM_COUNTERS
{
    SIZE_T PeakVirtualSize;
    SIZE_T VirtualSize;
    ULONG PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
} VM_COUNTERS, *PVM_COUNTERS;

typedef struct _VM_COUNTERS_EX
{
    SIZE_T PeakVirtualSize;
    SIZE_T VirtualSize;
    ULONG PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivateUsage;
} VM_COUNTERS_EX, *PVM_COUNTERS_EX;

// private
typedef struct _VM_COUNTERS_EX2
{
    VM_COUNTERS_EX CountersEx;
    SIZE_T PrivateWorkingSetSize;
    SIZE_T SharedCommitUsage;
} VM_COUNTERS_EX2, *PVM_COUNTERS_EX2;

typedef struct _KERNEL_USER_TIMES
{
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER ExitTime;
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
} KERNEL_USER_TIMES, *PKERNEL_USER_TIMES;

typedef struct _POOLED_USAGE_AND_LIMITS
{
    SIZE_T PeakPagedPoolUsage;
    SIZE_T PagedPoolUsage;
    SIZE_T PagedPoolLimit;
    SIZE_T PeakNonPagedPoolUsage;
    SIZE_T NonPagedPoolUsage;
    SIZE_T NonPagedPoolLimit;
    SIZE_T PeakPagefileUsage;
    SIZE_T PagefileUsage;
    SIZE_T PagefileLimit;
} POOLED_USAGE_AND_LIMITS, *PPOOLED_USAGE_AND_LIMITS;

#define PROCESS_EXCEPTION_PORT_ALL_STATE_BITS 0x00000003
#define PROCESS_EXCEPTION_PORT_ALL_STATE_FLAGS ((ULONG_PTR)((1UL << PROCESS_EXCEPTION_PORT_ALL_STATE_BITS) - 1))

typedef struct _PROCESS_EXCEPTION_PORT 
{
    _In_ HANDLE ExceptionPortHandle; // Handle to the exception port. No particular access required.
    _Inout_ ULONG StateFlags; // Miscellaneous state flags to be cached along with the exception port in the kernel.
} PROCESS_EXCEPTION_PORT, *PPROCESS_EXCEPTION_PORT;

typedef struct _PROCESS_ACCESS_TOKEN
{
    HANDLE Token; // needs TOKEN_ASSIGN_PRIMARY access
    HANDLE Thread; // handle to initial/only thread; needs THREAD_QUERY_INFORMATION access
} PROCESS_ACCESS_TOKEN, *PPROCESS_ACCESS_TOKEN;

typedef struct _PROCESS_LDT_INFORMATION
{
    ULONG Start;
    ULONG Length;
    LDT_ENTRY LdtEntries[1];
} PROCESS_LDT_INFORMATION, *PPROCESS_LDT_INFORMATION;

typedef struct _PROCESS_LDT_SIZE
{
    ULONG Length;
} PROCESS_LDT_SIZE, *PPROCESS_LDT_SIZE;

typedef struct _PROCESS_WS_WATCH_INFORMATION
{
    PVOID FaultingPc;
    PVOID FaultingVa;
} PROCESS_WS_WATCH_INFORMATION, *PPROCESS_WS_WATCH_INFORMATION;

#endif

// psapi:PSAPI_WS_WATCH_INFORMATION_EX
typedef struct _PROCESS_WS_WATCH_INFORMATION_EX
{
    PROCESS_WS_WATCH_INFORMATION BasicInfo;
    ULONG_PTR FaultingThreadId;
    ULONG_PTR Flags;
} PROCESS_WS_WATCH_INFORMATION_EX, *PPROCESS_WS_WATCH_INFORMATION_EX;

#define PROCESS_PRIORITY_CLASS_UNKNOWN 0
#define PROCESS_PRIORITY_CLASS_IDLE 1
#define PROCESS_PRIORITY_CLASS_NORMAL 2
#define PROCESS_PRIORITY_CLASS_HIGH 3
#define PROCESS_PRIORITY_CLASS_REALTIME 4
#define PROCESS_PRIORITY_CLASS_BELOW_NORMAL 5
#define PROCESS_PRIORITY_CLASS_ABOVE_NORMAL 6

typedef struct _PROCESS_PRIORITY_CLASS
{
    BOOLEAN Foreground;
    UCHAR PriorityClass;
} PROCESS_PRIORITY_CLASS, *PPROCESS_PRIORITY_CLASS;

typedef struct _PROCESS_FOREGROUND_BACKGROUND
{
    BOOLEAN Foreground;
} PROCESS_FOREGROUND_BACKGROUND, *PPROCESS_FOREGROUND_BACKGROUND;

#if (PHNT_MODE != PHNT_MODE_KERNEL)

typedef struct _PROCESS_DEVICEMAP_INFORMATION
{
    union
    {
        struct
        {
            HANDLE DirectoryHandle;
        } Set;
        struct
        {
            ULONG DriveMap;
            UCHAR DriveType[32];
        } Query;
    };
} PROCESS_DEVICEMAP_INFORMATION, *PPROCESS_DEVICEMAP_INFORMATION;

#define PROCESS_LUID_DOSDEVICES_ONLY 0x00000001

typedef struct _PROCESS_DEVICEMAP_INFORMATION_EX
{
    union
    {
        struct
        {
            HANDLE DirectoryHandle;
        } Set;
        struct
        {
            ULONG DriveMap;
            UCHAR DriveType[32];
        } Query;
    };
    ULONG Flags; // PROCESS_LUID_DOSDEVICES_ONLY
} PROCESS_DEVICEMAP_INFORMATION_EX, *PPROCESS_DEVICEMAP_INFORMATION_EX;

typedef struct _PROCESS_SESSION_INFORMATION
{
    ULONG SessionId;
} PROCESS_SESSION_INFORMATION, *PPROCESS_SESSION_INFORMATION;

#define PROCESS_HANDLE_EXCEPTIONS_ENABLED 0x00000001

#define PROCESS_HANDLE_RAISE_EXCEPTION_ON_INVALID_HANDLE_CLOSE_DISABLED 0x00000000
#define PROCESS_HANDLE_RAISE_EXCEPTION_ON_INVALID_HANDLE_CLOSE_ENABLED 0x00000001

typedef struct _PROCESS_HANDLE_TRACING_ENABLE
{
    ULONG Flags;
} PROCESS_HANDLE_TRACING_ENABLE, *PPROCESS_HANDLE_TRACING_ENABLE;

#define PROCESS_HANDLE_TRACING_MAX_SLOTS 0x20000

typedef struct _PROCESS_HANDLE_TRACING_ENABLE_EX
{
    ULONG Flags;
    ULONG TotalSlots;
} PROCESS_HANDLE_TRACING_ENABLE_EX, *PPROCESS_HANDLE_TRACING_ENABLE_EX;

#define PROCESS_HANDLE_TRACING_MAX_STACKS 16

#define PROCESS_HANDLE_TRACE_TYPE_OPEN 1
#define PROCESS_HANDLE_TRACE_TYPE_CLOSE 2
#define PROCESS_HANDLE_TRACE_TYPE_BADREF 3

typedef struct _PROCESS_HANDLE_TRACING_ENTRY
{
    HANDLE Handle;
    CLIENT_ID ClientId;
    ULONG Type;
    PVOID Stacks[PROCESS_HANDLE_TRACING_MAX_STACKS];
} PROCESS_HANDLE_TRACING_ENTRY, *PPROCESS_HANDLE_TRACING_ENTRY;

typedef struct _PROCESS_HANDLE_TRACING_QUERY
{
    HANDLE Handle;
    ULONG TotalTraces;
    PROCESS_HANDLE_TRACING_ENTRY HandleTrace[1];
} PROCESS_HANDLE_TRACING_QUERY, *PPROCESS_HANDLE_TRACING_QUERY;

#endif

// private
typedef struct _THREAD_TLS_INFORMATION
{
    ULONG Flags;
    PVOID NewTlsData;
    PVOID OldTlsData;
    HANDLE ThreadId;
} THREAD_TLS_INFORMATION, *PTHREAD_TLS_INFORMATION;

// private
typedef enum _PROCESS_TLS_INFORMATION_TYPE
{
    ProcessTlsReplaceIndex,
    ProcessTlsReplaceVector,
    MaxProcessTlsOperation
} PROCESS_TLS_INFORMATION_TYPE, *PPROCESS_TLS_INFORMATION_TYPE;

// private
typedef struct _PROCESS_TLS_INFORMATION
{
    ULONG Flags;
    ULONG OperationType;
    ULONG ThreadDataCount;
    ULONG TlsIndex;
    ULONG PreviousCount;
    THREAD_TLS_INFORMATION ThreadData[1];
} PROCESS_TLS_INFORMATION, *PPROCESS_TLS_INFORMATION;

// private
typedef struct _PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION
{
    ULONG Version;
    ULONG Reserved;
    PVOID Callback;
} PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION, *PPROCESS_INSTRUMENTATION_CALLBACK_INFORMATION;

// private
typedef struct _PROCESS_STACK_ALLOCATION_INFORMATION
{
    SIZE_T ReserveSize;
    SIZE_T ZeroBits;
    PVOID StackBase;
} PROCESS_STACK_ALLOCATION_INFORMATION, *PPROCESS_STACK_ALLOCATION_INFORMATION;

// private
typedef struct _PROCESS_STACK_ALLOCATION_INFORMATION_EX
{
    ULONG PreferredNode;
    ULONG Reserved0;
    ULONG Reserved1;
    ULONG Reserved2;
    PROCESS_STACK_ALLOCATION_INFORMATION AllocInfo;
} PROCESS_STACK_ALLOCATION_INFORMATION_EX, *PPROCESS_STACK_ALLOCATION_INFORMATION_EX;

// private
typedef union _PROCESS_AFFINITY_UPDATE_MODE
{
    ULONG Flags;
    struct
    {
        ULONG EnableAutoUpdate : 1;
        ULONG Permanent : 1;
        ULONG Reserved : 30;
    };
} PROCESS_AFFINITY_UPDATE_MODE, *PPROCESS_AFFINITY_UPDATE_MODE;

// private
typedef union _PROCESS_MEMORY_ALLOCATION_MODE
{
    ULONG Flags;
    struct
    {
        ULONG TopDown : 1;
        ULONG Reserved : 31;
    };
} PROCESS_MEMORY_ALLOCATION_MODE, *PPROCESS_MEMORY_ALLOCATION_MODE;

// private
typedef struct _PROCESS_HANDLE_INFORMATION
{
    ULONG HandleCount;
    ULONG HandleCountHighWatermark;
} PROCESS_HANDLE_INFORMATION, *PPROCESS_HANDLE_INFORMATION;

// private
typedef struct _PROCESS_CYCLE_TIME_INFORMATION
{
    ULONGLONG AccumulatedCycles;
    ULONGLONG CurrentCycleCount;
} PROCESS_CYCLE_TIME_INFORMATION, *PPROCESS_CYCLE_TIME_INFORMATION;

// private
typedef struct _PROCESS_WINDOW_INFORMATION
{
    ULONG WindowFlags;
    USHORT WindowTitleLength;
    WCHAR WindowTitle[1];
} PROCESS_WINDOW_INFORMATION, *PPROCESS_WINDOW_INFORMATION;

// private
typedef struct _PROCESS_HANDLE_TABLE_ENTRY_INFO
{
    HANDLE HandleValue;
    ULONG_PTR HandleCount;
    ULONG_PTR PointerCount;
    ULONG GrantedAccess;
    ULONG ObjectTypeIndex;
    ULONG HandleAttributes;
    ULONG Reserved;
} PROCESS_HANDLE_TABLE_ENTRY_INFO, *PPROCESS_HANDLE_TABLE_ENTRY_INFO;

// private
typedef struct _PROCESS_HANDLE_SNAPSHOT_INFORMATION
{
    ULONG_PTR NumberOfHandles;
    ULONG_PTR Reserved;
    PROCESS_HANDLE_TABLE_ENTRY_INFO Handles[1];
} PROCESS_HANDLE_SNAPSHOT_INFORMATION, *PPROCESS_HANDLE_SNAPSHOT_INFORMATION;

#if (PHNT_MODE != PHNT_MODE_KERNEL)

// private
typedef struct _PROCESS_MITIGATION_POLICY_INFORMATION
{
    PROCESS_MITIGATION_POLICY Policy;
    union
    {
        PROCESS_MITIGATION_ASLR_POLICY ASLRPolicy;
        PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY StrictHandleCheckPolicy;
        PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY SystemCallDisablePolicy;
        PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY ExtensionPointDisablePolicy;
        PROCESS_MITIGATION_DYNAMIC_CODE_POLICY DynamicCodePolicy;
        PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY ControlFlowGuardPolicy;
        PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY SignaturePolicy;
        PROCESS_MITIGATION_FONT_DISABLE_POLICY FontDisablePolicy;
        PROCESS_MITIGATION_IMAGE_LOAD_POLICY ImageLoadPolicy;
        PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY SystemCallFilterPolicy;
        PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY PayloadRestrictionPolicy;
        PROCESS_MITIGATION_CHILD_PROCESS_POLICY ChildProcessPolicy;
        PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY SideChannelIsolationPolicy;
    };
} PROCESS_MITIGATION_POLICY_INFORMATION, *PPROCESS_MITIGATION_POLICY_INFORMATION;

typedef struct _PROCESS_KEEPALIVE_COUNT_INFORMATION
{
    ULONG WakeCount;
    ULONG NoWakeCount;
} PROCESS_KEEPALIVE_COUNT_INFORMATION, *PPROCESS_KEEPALIVE_COUNT_INFORMATION;

typedef struct _PROCESS_REVOKE_FILE_HANDLES_INFORMATION
{
    UNICODE_STRING TargetDevicePath;
} PROCESS_REVOKE_FILE_HANDLES_INFORMATION, *PPROCESS_REVOKE_FILE_HANDLES_INFORMATION;

// begin_private

typedef enum _PROCESS_WORKING_SET_OPERATION
{
    ProcessWorkingSetSwap,
    ProcessWorkingSetEmpty,
    ProcessWorkingSetOperationMax
} PROCESS_WORKING_SET_OPERATION;

typedef struct _PROCESS_WORKING_SET_CONTROL
{
    ULONG Version;
    PROCESS_WORKING_SET_OPERATION Operation;
    ULONG Flags;
} PROCESS_WORKING_SET_CONTROL, *PPROCESS_WORKING_SET_CONTROL;

typedef enum _PS_PROTECTED_TYPE
{
    PsProtectedTypeNone,
    PsProtectedTypeProtectedLight,
    PsProtectedTypeProtected,
    PsProtectedTypeMax
} PS_PROTECTED_TYPE;

typedef enum _PS_PROTECTED_SIGNER
{
    PsProtectedSignerNone,
    PsProtectedSignerAuthenticode,
    PsProtectedSignerCodeGen,
    PsProtectedSignerAntimalware,
    PsProtectedSignerLsa,
    PsProtectedSignerWindows,
    PsProtectedSignerWinTcb,
    PsProtectedSignerWinSystem,
    PsProtectedSignerApp,
    PsProtectedSignerMax
} PS_PROTECTED_SIGNER;

#define PS_PROTECTED_SIGNER_MASK 0xFF
#define PS_PROTECTED_AUDIT_MASK 0x08
#define PS_PROTECTED_TYPE_MASK 0x07

// vProtectionLevel.Level = PsProtectedValue(PsProtectedSignerCodeGen, FALSE, PsProtectedTypeProtectedLight)
#define PsProtectedValue(aSigner, aAudit, aType) ( \
    ((aSigner & PS_PROTECTED_SIGNER_MASK) << 4) | \
    ((aAudit & PS_PROTECTED_AUDIT_MASK) << 3) | \
    (aType & PS_PROTECTED_TYPE_MASK)\
    )

// InitializePsProtection(&vProtectionLevel, PsProtectedSignerCodeGen, FALSE, PsProtectedTypeProtectedLight)
#define InitializePsProtection(aProtectionLevelPtr, aSigner, aAudit, aType) { \
    (aProtectionLevelPtr)->Signer = aSigner; \
    (aProtectionLevelPtr)->Audit = aAudit; \
    (aProtectionLevelPtr)->Type = aType; \
    }

typedef struct _PS_PROTECTION
{
    union
    {
        UCHAR Level;
        struct
        {
            UCHAR Type : 3;
            UCHAR Audit : 1;
            UCHAR Signer : 4;
        };
    };
} PS_PROTECTION, *PPS_PROTECTION;

typedef struct _PROCESS_FAULT_INFORMATION
{
    ULONG FaultFlags;
    ULONG AdditionalInfo;
} PROCESS_FAULT_INFORMATION, *PPROCESS_FAULT_INFORMATION;

typedef struct _PROCESS_TELEMETRY_ID_INFORMATION
{
    ULONG HeaderSize;
    ULONG ProcessId;
    ULONGLONG ProcessStartKey;
    ULONGLONG CreateTime;
    ULONGLONG CreateInterruptTime;
    ULONGLONG CreateUnbiasedInterruptTime;
    ULONGLONG ProcessSequenceNumber;
    ULONGLONG SessionCreateTime;
    ULONG SessionId;
    ULONG BootId;
    ULONG ImageChecksum;
    ULONG ImageTimeDateStamp;
    ULONG UserSidOffset;
    ULONG ImagePathOffset;
    ULONG PackageNameOffset;
    ULONG RelativeAppNameOffset;
    ULONG CommandLineOffset;
} PROCESS_TELEMETRY_ID_INFORMATION, *PPROCESS_TELEMETRY_ID_INFORMATION;

typedef struct _PROCESS_COMMIT_RELEASE_INFORMATION
{
    ULONG Version;
    struct
    {
        ULONG Eligible : 1;
        ULONG ReleaseRepurposedMemResetCommit : 1;
        ULONG ForceReleaseMemResetCommit : 1;
        ULONG Spare : 29;
    };
    SIZE_T CommitDebt;
    SIZE_T CommittedMemResetSize;
    SIZE_T RepurposedMemResetSize;
} PROCESS_COMMIT_RELEASE_INFORMATION, *PPROCESS_COMMIT_RELEASE_INFORMATION;

typedef struct _PROCESS_JOB_MEMORY_INFO
{
    ULONGLONG SharedCommitUsage;
    ULONGLONG PrivateCommitUsage;
    ULONGLONG PeakPrivateCommitUsage;
    ULONGLONG PrivateCommitLimit;
    ULONGLONG TotalCommitLimit;
} PROCESS_JOB_MEMORY_INFO, *PPROCESS_JOB_MEMORY_INFO;

typedef struct _PROCESS_CHILD_PROCESS_INFORMATION
{
    BOOLEAN ProhibitChildProcesses;
    //BOOLEAN EnableAutomaticOverride; // REDSTONE2
    BOOLEAN AlwaysAllowSecureChildProcess; // REDSTONE3
    BOOLEAN AuditProhibitChildProcesses;
} PROCESS_CHILD_PROCESS_INFORMATION, *PPROCESS_CHILD_PROCESS_INFORMATION;

typedef struct _PROCESS_WAKE_INFORMATION
{
    ULONGLONG NotificationChannel;
    ULONG WakeCounters[7];
    struct _JOBOBJECT_WAKE_FILTER* WakeFilter;
} PROCESS_WAKE_INFORMATION, *PPROCESS_WAKE_INFORMATION;

typedef struct _PROCESS_ENERGY_TRACKING_STATE
{
    ULONG StateUpdateMask;
    ULONG StateDesiredValue;
    ULONG StateSequence;
    ULONG UpdateTag : 1;
    WCHAR Tag[64];
} PROCESS_ENERGY_TRACKING_STATE, *PPROCESS_ENERGY_TRACKING_STATE;

typedef struct _MANAGE_WRITES_TO_EXECUTABLE_MEMORY
{
    ULONG Version : 8;
    ULONG ProcessEnableWriteExceptions : 1;
    ULONG ThreadAllowWrites : 1;
    ULONG Spare : 22;
    PVOID KernelWriteToExecutableSignal; // 19H1
} MANAGE_WRITES_TO_EXECUTABLE_MEMORY, *PMANAGE_WRITES_TO_EXECUTABLE_MEMORY;

#define PROCESS_READWRITEVM_LOGGING_ENABLE_READVM 1
#define PROCESS_READWRITEVM_LOGGING_ENABLE_WRITEVM 2
#define PROCESS_READWRITEVM_LOGGING_ENABLE_READVM_V 1UL
#define PROCESS_READWRITEVM_LOGGING_ENABLE_WRITEVM_V 2UL

typedef union _PROCESS_READWRITEVM_LOGGING_INFORMATION
{
    UCHAR Flags;
    struct
    {
        UCHAR EnableReadVmLogging : 1;
        UCHAR EnableWriteVmLogging : 1;
        UCHAR Unused : 6;
    };
} PROCESS_READWRITEVM_LOGGING_INFORMATION, *PPROCESS_READWRITEVM_LOGGING_INFORMATION;

typedef struct _PROCESS_UPTIME_INFORMATION
{
    ULONGLONG QueryInterruptTime;
    ULONGLONG QueryUnbiasedTime;
    ULONGLONG EndInterruptTime;
    ULONGLONG TimeSinceCreation;
    ULONGLONG Uptime;
    ULONGLONG SuspendedTime;
    union
    {
        ULONG HangCount : 4;
        ULONG GhostCount : 4;
        ULONG Crashed : 1;
        ULONG Terminated : 1;       
    };
} PROCESS_UPTIME_INFORMATION, *PPROCESS_UPTIME_INFORMATION;

typedef union _PROCESS_SYSTEM_RESOURCE_MANAGEMENT
{
    ULONG Flags;
    struct
    {
        ULONG Foreground : 1;
        ULONG Reserved : 31;
    };
} PROCESS_SYSTEM_RESOURCE_MANAGEMENT, *PPROCESS_SYSTEM_RESOURCE_MANAGEMENT;

// private
typedef struct _PROCESS_SECURITY_DOMAIN_INFORMATION
{
    ULONGLONG SecurityDomain;
} PROCESS_SECURITY_DOMAIN_INFORMATION, *PPROCESS_SECURITY_DOMAIN_INFORMATION;

// private
typedef struct _PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION
{
    HANDLE ProcessHandle;
} PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION, *PPROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION;

// private
typedef struct _PROCESS_LOGGING_INFORMATION
{
    ULONG Flags;
    struct
    {
        ULONG EnableReadVmLogging : 1;
        ULONG EnableWriteVmLogging : 1;
        ULONG EnableProcessSuspendResumeLogging : 1;
        ULONG EnableThreadSuspendResumeLogging : 1;
        ULONG Reserved : 28;
    };
} PROCESS_LOGGING_INFORMATION, *PPROCESS_LOGGING_INFORMATION;

// private
typedef struct _PROCESS_LEAP_SECOND_INFORMATION
{
    ULONG Flags;
    ULONG Reserved;
} PROCESS_LEAP_SECOND_INFORMATION, *PPROCESS_LEAP_SECOND_INFORMATION;

// private
typedef struct _PROCESS_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION
{
    ULONGLONG ReserveSize;
    ULONGLONG CommitSize;
    ULONG PreferredNode;
    ULONG Reserved;
    PVOID Ssp;
} PROCESS_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION, *PPROCESS_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION;

// private
typedef struct _PROCESS_FREE_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION
{
    PVOID Ssp;
} PROCESS_FREE_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION, *PPROCESS_FREE_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION;

// end_private

#endif

// Thread information structures

typedef struct _THREAD_BASIC_INFORMATION
{
    NTSTATUS ExitStatus;
    PTEB TebBaseAddress;
    CLIENT_ID ClientId;
    ULONG_PTR AffinityMask;
    KPRIORITY Priority;
    LONG BasePriority;
} THREAD_BASIC_INFORMATION, *PTHREAD_BASIC_INFORMATION;

// private
typedef struct _THREAD_LAST_SYSCALL_INFORMATION
{
    PVOID FirstArgument;
    USHORT SystemCallNumber;
#ifdef WIN64
    USHORT Pad[0x3]; // since REDSTONE2
#else
    USHORT Pad[0x1]; // since REDSTONE2
#endif
    ULONG64 WaitTime;
} THREAD_LAST_SYSCALL_INFORMATION, *PTHREAD_LAST_SYSCALL_INFORMATION;

// private
typedef struct _THREAD_CYCLE_TIME_INFORMATION
{
    ULONGLONG AccumulatedCycles;
    ULONGLONG CurrentCycleCount;
} THREAD_CYCLE_TIME_INFORMATION, *PTHREAD_CYCLE_TIME_INFORMATION;

// private
typedef struct _THREAD_TEB_INFORMATION
{
    PVOID TebInformation; // buffer to place data in
    ULONG TebOffset; // offset in TEB to begin reading from
    ULONG BytesToRead; // number of bytes to read
} THREAD_TEB_INFORMATION, *PTHREAD_TEB_INFORMATION;

// symbols
typedef struct _COUNTER_READING
{
    HARDWARE_COUNTER_TYPE Type;
    ULONG Index;
    ULONG64 Start;
    ULONG64 Total;
} COUNTER_READING, *PCOUNTER_READING;

// symbols
typedef struct _THREAD_PERFORMANCE_DATA
{
    USHORT Size;
    USHORT Version;
    PROCESSOR_NUMBER ProcessorNumber;
    ULONG ContextSwitches;
    ULONG HwCountersCount;
    ULONG64 UpdateCount;
    ULONG64 WaitReasonBitMap;
    ULONG64 HardwareCounters;
    COUNTER_READING CycleTime;
    COUNTER_READING HwCounters[MAX_HW_COUNTERS];
} THREAD_PERFORMANCE_DATA, *PTHREAD_PERFORMANCE_DATA;

// private
typedef struct _THREAD_PROFILING_INFORMATION
{
    ULONG64 HardwareCounters;
    ULONG Flags;
    ULONG Enable;
    PTHREAD_PERFORMANCE_DATA PerformanceData;
} THREAD_PROFILING_INFORMATION, *PTHREAD_PROFILING_INFORMATION;

// private
typedef struct _RTL_UMS_CONTEXT
{
    SINGLE_LIST_ENTRY Link;
    CONTEXT Context;
    PVOID Teb;
    PVOID UserContext;
    volatile ULONG ScheduledThread;
    volatile ULONG Suspended;
    volatile ULONG VolatileContext;
    volatile ULONG Terminated;
    volatile ULONG DebugActive;
    volatile ULONG RunningOnSelfThread;
    volatile ULONG DenyRunningOnSelfThread;
    volatile LONG Flags;
    volatile ULONG64 KernelUpdateLock;
    volatile ULONG64 PrimaryClientID;
    volatile ULONG64 ContextLock;
    struct _RTL_UMS_CONTEXT* PrimaryUmsContext;
    ULONG SwitchCount;
    ULONG KernelYieldCount;
    ULONG MixedYieldCount;
    ULONG YieldCount;
} RTL_UMS_CONTEXT, *PRTL_UMS_CONTEXT;

// private
typedef enum _THREAD_UMS_INFORMATION_COMMAND
{
    UmsInformationCommandInvalid,
    UmsInformationCommandAttach,
    UmsInformationCommandDetach,
    UmsInformationCommandQuery
} THREAD_UMS_INFORMATION_COMMAND;

// private
typedef struct _RTL_UMS_COMPLETION_LIST
{
    PSINGLE_LIST_ENTRY ThreadListHead;
    PVOID CompletionEvent;
    ULONG CompletionFlags;
    SINGLE_LIST_ENTRY InternalListHead;
} RTL_UMS_COMPLETION_LIST, *PRTL_UMS_COMPLETION_LIST;

// private
typedef struct _THREAD_UMS_INFORMATION
{
    THREAD_UMS_INFORMATION_COMMAND Command;
    PRTL_UMS_COMPLETION_LIST CompletionList;
    PRTL_UMS_CONTEXT UmsContext;
    union
    {
        ULONG Flags;
        struct
        {
            ULONG IsUmsSchedulerThread : 1;
            ULONG IsUmsWorkerThread : 1;
            ULONG SpareBits : 30;
        };
    };
} THREAD_UMS_INFORMATION, *PTHREAD_UMS_INFORMATION;

// private
typedef struct _THREAD_NAME_INFORMATION
{
    UNICODE_STRING ThreadName;
} THREAD_NAME_INFORMATION, *PTHREAD_NAME_INFORMATION;

#if (PHNT_MODE != PHNT_MODE_KERNEL)
// private
typedef enum _SUBSYSTEM_INFORMATION_TYPE 
{
    SubsystemInformationTypeWin32,
    SubsystemInformationTypeWSL,
    MaxSubsystemInformationType
} SUBSYSTEM_INFORMATION_TYPE;
#endif

// private
typedef enum _THREAD_WORKLOAD_CLASS
{
    ThreadWorkloadClassDefault,
    ThreadWorkloadClassGraphics,
    MaxThreadWorkloadClass
} THREAD_WORKLOAD_CLASS;

// Processes

#if (PHNT_MODE != PHNT_MODE_KERNEL)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateProcess(
    _Out_ PHANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ParentProcess,
    _In_ BOOLEAN InheritObjectTable,
    _In_opt_ HANDLE SectionHandle,
    _In_opt_ HANDLE DebugPort,
    _In_opt_ HANDLE ExceptionPort
    );

#define PROCESS_CREATE_FLAGS_BREAKAWAY 0x00000001
#define PROCESS_CREATE_FLAGS_NO_DEBUG_INHERIT 0x00000002
#define PROCESS_CREATE_FLAGS_INHERIT_HANDLES 0x00000004
#define PROCESS_CREATE_FLAGS_OVERRIDE_ADDRESS_SPACE 0x00000008
#define PROCESS_CREATE_FLAGS_LARGE_PAGES 0x00000010

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateProcessEx(
    _Out_ PHANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ParentProcess,
    _In_ ULONG Flags,
    _In_opt_ HANDLE SectionHandle,
    _In_opt_ HANDLE DebugPort,
    _In_opt_ HANDLE ExceptionPort,
    _In_ ULONG JobMemberLevel
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenProcess(
    _Out_ PHANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PCLIENT_ID ClientId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtTerminateProcess(
    _In_opt_ HANDLE ProcessHandle,
    _In_ NTSTATUS ExitStatus
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSuspendProcess(
    _In_ HANDLE ProcessHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtResumeProcess(
    _In_ HANDLE ProcessHandle
    );

#define NtCurrentProcess() ((HANDLE)(LONG_PTR)-1)
#define ZwCurrentProcess() NtCurrentProcess()
#define NtCurrentThread() ((HANDLE)(LONG_PTR)-2)
#define ZwCurrentThread() NtCurrentThread()
#define NtCurrentSession() ((HANDLE)(LONG_PTR)-3)
#define ZwCurrentSession() NtCurrentSession()
#define NtCurrentPeb() (NtCurrentTeb()->ProcessEnvironmentBlock)

// Windows 8 and above
#define NtCurrentProcessToken() ((HANDLE)(LONG_PTR)-4)
#define NtCurrentThreadToken() ((HANDLE)(LONG_PTR)-5)
#define NtCurrentEffectiveToken() ((HANDLE)(LONG_PTR)-6)
#define NtCurrentSilo() ((HANDLE)(LONG_PTR)-1)

// Not NT, but useful.
#define NtCurrentProcessId() (NtCurrentTeb()->ClientId.UniqueProcess)
#define NtCurrentThreadId() (NtCurrentTeb()->ClientId.UniqueThread)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationProcess(
    _In_ HANDLE ProcessHandle,
    _In_ PROCESSINFOCLASS ProcessInformationClass,
    _Out_writes_bytes_(ProcessInformationLength) PVOID ProcessInformation,
    _In_ ULONG ProcessInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

#if (PHNT_VERSION >= PHNT_WS03)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtGetNextProcess(
    _In_opt_ HANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _In_ ULONG Flags,
    _Out_ PHANDLE NewProcessHandle
    );
#endif

#if (PHNT_VERSION >= PHNT_WS03)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtGetNextThread(
    _In_ HANDLE ProcessHandle,
    _In_ HANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _In_ ULONG Flags,
    _Out_ PHANDLE NewThreadHandle
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationProcess(
    _In_ HANDLE ProcessHandle,
    _In_ PROCESSINFOCLASS ProcessInformationClass,
    _In_reads_bytes_(ProcessInformationLength) PVOID ProcessInformation,
    _In_ ULONG ProcessInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryPortInformationProcess(
    VOID
    );

#endif

// Threads

#if (PHNT_MODE != PHNT_MODE_KERNEL)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateThread(
    _Out_ PHANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ProcessHandle,
    _Out_ PCLIENT_ID ClientId,
    _In_ PCONTEXT ThreadContext,
    _In_ PINITIAL_TEB InitialTeb,
    _In_ BOOLEAN CreateSuspended
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenThread(
    _Out_ PHANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PCLIENT_ID ClientId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtTerminateThread(
    _In_opt_ HANDLE ThreadHandle,
    _In_ NTSTATUS ExitStatus
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSuspendThread(
    _In_ HANDLE ThreadHandle,
    _Out_opt_ PULONG PreviousSuspendCount
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtResumeThread(
    _In_ HANDLE ThreadHandle,
    _Out_opt_ PULONG PreviousSuspendCount
    );

NTSYSCALLAPI
ULONG
NTAPI
NtGetCurrentProcessorNumber(
    VOID
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtGetContextThread(
    _In_ HANDLE ThreadHandle,
    _Inout_ PCONTEXT ThreadContext
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetContextThread(
    _In_ HANDLE ThreadHandle,
    _In_ PCONTEXT ThreadContext
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationThread(
    _In_ HANDLE ThreadHandle,
    _In_ THREADINFOCLASS ThreadInformationClass,
    _Out_writes_bytes_(ThreadInformationLength) PVOID ThreadInformation,
    _In_ ULONG ThreadInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationThread(
    _In_ HANDLE ThreadHandle,
    _In_ THREADINFOCLASS ThreadInformationClass,
    _In_reads_bytes_(ThreadInformationLength) PVOID ThreadInformation,
    _In_ ULONG ThreadInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlertThread(
    _In_ HANDLE ThreadHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlertResumeThread(
    _In_ HANDLE ThreadHandle,
    _Out_opt_ PULONG PreviousSuspendCount
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtTestAlert(
    VOID
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtImpersonateThread(
    _In_ HANDLE ServerThreadHandle,
    _In_ HANDLE ClientThreadHandle,
    _In_ PSECURITY_QUALITY_OF_SERVICE SecurityQos
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRegisterThreadTerminatePort(
    _In_ HANDLE PortHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetLdtEntries(
    _In_ ULONG Selector0,
    _In_ ULONG Entry0Low,
    _In_ ULONG Entry0Hi,
    _In_ ULONG Selector1,
    _In_ ULONG Entry1Low,
    _In_ ULONG Entry1Hi
    );

typedef VOID (*PPS_APC_ROUTINE)(
    _In_opt_ PVOID ApcArgument1,
    _In_opt_ PVOID ApcArgument2,
    _In_opt_ PVOID ApcArgument3
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueueApcThread(
    _In_ HANDLE ThreadHandle,
    _In_ PPS_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcArgument1,
    _In_opt_ PVOID ApcArgument2,
    _In_opt_ PVOID ApcArgument3
    );

#if (PHNT_VERSION >= PHNT_WIN7)

#define APC_FORCE_THREAD_SIGNAL ((HANDLE)1) // UserApcReserveHandle

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueueApcThreadEx(
    _In_ HANDLE ThreadHandle,
    _In_opt_ HANDLE UserApcReserveHandle,
    _In_ PPS_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcArgument1,
    _In_opt_ PVOID ApcArgument2,
    _In_opt_ PVOID ApcArgument3
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN8)

// rev
NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlertThreadByThreadId(
    _In_ HANDLE ThreadId
    );

// rev
NTSYSCALLAPI
NTSTATUS
NTAPI
NtWaitForAlertByThreadId(
    _In_ PVOID Address,
    _In_opt_ PLARGE_INTEGER Timeout
    );

#endif

#endif

// User processes and threads

#if (PHNT_MODE != PHNT_MODE_KERNEL)

// Attributes

// private
#define PS_ATTRIBUTE_NUMBER_MASK 0x0000ffff
#define PS_ATTRIBUTE_THREAD 0x00010000 // may be used with thread creation
#define PS_ATTRIBUTE_INPUT 0x00020000 // input only
#define PS_ATTRIBUTE_ADDITIVE 0x00040000 // "accumulated" e.g. bitmasks, counters, etc.

// private
typedef enum _PS_ATTRIBUTE_NUM
{
    PsAttributeParentProcess, // in HANDLE
    PsAttributeDebugPort, // in HANDLE
    PsAttributeToken, // in HANDLE
    PsAttributeClientId, // out PCLIENT_ID
    PsAttributeTebAddress, // out PTEB *
    PsAttributeImageName, // in PWSTR
    PsAttributeImageInfo, // out PSECTION_IMAGE_INFORMATION
    PsAttributeMemoryReserve, // in PPS_MEMORY_RESERVE
    PsAttributePriorityClass, // in UCHAR
    PsAttributeErrorMode, // in ULONG
    PsAttributeStdHandleInfo, // 10, in PPS_STD_HANDLE_INFO
    PsAttributeHandleList, // in PHANDLE
    PsAttributeGroupAffinity, // in PGROUP_AFFINITY
    PsAttributePreferredNode, // in PUSHORT
    PsAttributeIdealProcessor, // in PPROCESSOR_NUMBER
    PsAttributeUmsThread, // ? in PUMS_CREATE_THREAD_ATTRIBUTES
    PsAttributeMitigationOptions, // in UCHAR
    PsAttributeProtectionLevel, // in ULONG
    PsAttributeSecureProcess, // since THRESHOLD
    PsAttributeJobList,
    PsAttributeChildProcessPolicy, // since THRESHOLD2
    PsAttributeAllApplicationPackagesPolicy, // since REDSTONE
    PsAttributeWin32kFilter,
    PsAttributeSafeOpenPromptOriginClaim,
    PsAttributeBnoIsolation, // PS_BNO_ISOLATION_PARAMETERS
    PsAttributeDesktopAppPolicy, // in ULONG
    PsAttributeChpe, // since REDSTONE3
    PsAttributeMax
} PS_ATTRIBUTE_NUM;

// begin_rev

#define PsAttributeValue(Number, Thread, Input, Additive) \
    (((Number) & PS_ATTRIBUTE_NUMBER_MASK) | \
    ((Thread) ? PS_ATTRIBUTE_THREAD : 0) | \
    ((Input) ? PS_ATTRIBUTE_INPUT : 0) | \
    ((Additive) ? PS_ATTRIBUTE_ADDITIVE : 0))

#define PS_ATTRIBUTE_PARENT_PROCESS \
    PsAttributeValue(PsAttributeParentProcess, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_DEBUG_PORT \
    PsAttributeValue(PsAttributeDebugPort, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_TOKEN \
    PsAttributeValue(PsAttributeToken, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_CLIENT_ID \
    PsAttributeValue(PsAttributeClientId, TRUE, FALSE, FALSE)
#define PS_ATTRIBUTE_TEB_ADDRESS \
    PsAttributeValue(PsAttributeTebAddress, TRUE, FALSE, FALSE)
#define PS_ATTRIBUTE_IMAGE_NAME \
    PsAttributeValue(PsAttributeImageName, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_IMAGE_INFO \
    PsAttributeValue(PsAttributeImageInfo, FALSE, FALSE, FALSE)
#define PS_ATTRIBUTE_MEMORY_RESERVE \
    PsAttributeValue(PsAttributeMemoryReserve, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_PRIORITY_CLASS \
    PsAttributeValue(PsAttributePriorityClass, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_ERROR_MODE \
    PsAttributeValue(PsAttributeErrorMode, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_STD_HANDLE_INFO \
    PsAttributeValue(PsAttributeStdHandleInfo, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_HANDLE_LIST \
    PsAttributeValue(PsAttributeHandleList, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_GROUP_AFFINITY \
    PsAttributeValue(PsAttributeGroupAffinity, TRUE, TRUE, FALSE)
#define PS_ATTRIBUTE_PREFERRED_NODE \
    PsAttributeValue(PsAttributePreferredNode, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_IDEAL_PROCESSOR \
    PsAttributeValue(PsAttributeIdealProcessor, TRUE, TRUE, FALSE)
#define PS_ATTRIBUTE_UMS_THREAD \
    PsAttributeValue(PsAttributeUmsThread, TRUE, TRUE, FALSE)
#define PS_ATTRIBUTE_MITIGATION_OPTIONS \
    PsAttributeValue(PsAttributeMitigationOptions, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_PROTECTION_LEVEL \
    PsAttributeValue(PsAttributeProtectionLevel, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_SECURE_PROCESS \
    PsAttributeValue(PsAttributeSecureProcess, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_JOB_LIST \
    PsAttributeValue(PsAttributeJobList, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_CHILD_PROCESS_POLICY \
    PsAttributeValue(PsAttributeChildProcessPolicy, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_ALL_APPLICATION_PACKAGES_POLICY \
    PsAttributeValue(PsAttributeAllApplicationPackagesPolicy, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_WIN32K_FILTER \
    PsAttributeValue(PsAttributeWin32kFilter, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_SAFE_OPEN_PROMPT_ORIGIN_CLAIM \
    PsAttributeValue(PsAttributeSafeOpenPromptOriginClaim, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_BNO_ISOLATION \
    PsAttributeValue(PsAttributeBnoIsolation, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_DESKTOP_APP_POLICY \
    PsAttributeValue(PsAttributeDesktopAppPolicy, FALSE, TRUE, FALSE)

// end_rev

// begin_private

typedef struct _PS_ATTRIBUTE
{
    ULONG_PTR Attribute;
    SIZE_T Size;
    union
    {
        ULONG_PTR Value;
        PVOID ValuePtr;
    };
    PSIZE_T ReturnLength;
} PS_ATTRIBUTE, *PPS_ATTRIBUTE;

typedef struct _PS_ATTRIBUTE_LIST
{
    SIZE_T TotalLength;
    PS_ATTRIBUTE Attributes[1];
} PS_ATTRIBUTE_LIST, *PPS_ATTRIBUTE_LIST;

typedef struct _PS_MEMORY_RESERVE
{
    PVOID ReserveAddress;
    SIZE_T ReserveSize;
} PS_MEMORY_RESERVE, *PPS_MEMORY_RESERVE;

typedef enum _PS_STD_HANDLE_STATE
{
    PsNeverDuplicate,
    PsRequestDuplicate, // duplicate standard handles specified by PseudoHandleMask, and only if StdHandleSubsystemType matches the image subsystem
    PsAlwaysDuplicate, // always duplicate standard handles
    PsMaxStdHandleStates
} PS_STD_HANDLE_STATE;

// begin_rev
#define PS_STD_INPUT_HANDLE 0x1
#define PS_STD_OUTPUT_HANDLE 0x2
#define PS_STD_ERROR_HANDLE 0x4
// end_rev

typedef struct _PS_STD_HANDLE_INFO
{
    union
    {
        ULONG Flags;
        struct
        {
            ULONG StdHandleState : 2; // PS_STD_HANDLE_STATE
            ULONG PseudoHandleMask : 3; // PS_STD_*
        };
    };
    ULONG StdHandleSubsystemType;
} PS_STD_HANDLE_INFO, *PPS_STD_HANDLE_INFO;

// private
typedef struct _PS_BNO_ISOLATION_PARAMETERS
{
    UNICODE_STRING IsolationPrefix;
    ULONG HandleCount;
    PVOID *Handles;
    BOOLEAN IsolationEnabled;
} PS_BNO_ISOLATION_PARAMETERS, *PPS_BNO_ISOLATION_PARAMETERS;

// private
typedef enum _PS_MITIGATION_OPTION
{
    PS_MITIGATION_OPTION_NX,
    PS_MITIGATION_OPTION_SEHOP,
    PS_MITIGATION_OPTION_FORCE_RELOCATE_IMAGES,
    PS_MITIGATION_OPTION_HEAP_TERMINATE,
    PS_MITIGATION_OPTION_BOTTOM_UP_ASLR,
    PS_MITIGATION_OPTION_HIGH_ENTROPY_ASLR,
    PS_MITIGATION_OPTION_STRICT_HANDLE_CHECKS,
    PS_MITIGATION_OPTION_WIN32K_SYSTEM_CALL_DISABLE,
    PS_MITIGATION_OPTION_EXTENSION_POINT_DISABLE,
    PS_MITIGATION_OPTION_PROHIBIT_DYNAMIC_CODE,
    PS_MITIGATION_OPTION_CONTROL_FLOW_GUARD,
    PS_MITIGATION_OPTION_BLOCK_NON_MICROSOFT_BINARIES,
    PS_MITIGATION_OPTION_FONT_DISABLE,
    PS_MITIGATION_OPTION_IMAGE_LOAD_NO_REMOTE,
    PS_MITIGATION_OPTION_IMAGE_LOAD_NO_LOW_LABEL,
    PS_MITIGATION_OPTION_IMAGE_LOAD_PREFER_SYSTEM32,
    PS_MITIGATION_OPTION_RETURN_FLOW_GUARD,
    PS_MITIGATION_OPTION_LOADER_INTEGRITY_CONTINUITY,
    PS_MITIGATION_OPTION_STRICT_CONTROL_FLOW_GUARD,
    PS_MITIGATION_OPTION_RESTRICT_SET_THREAD_CONTEXT,
    PS_MITIGATION_OPTION_ROP_STACKPIVOT, // since REDSTONE3
    PS_MITIGATION_OPTION_ROP_CALLER_CHECK,
    PS_MITIGATION_OPTION_ROP_SIMEXEC,
    PS_MITIGATION_OPTION_EXPORT_ADDRESS_FILTER,
    PS_MITIGATION_OPTION_EXPORT_ADDRESS_FILTER_PLUS,
    PS_MITIGATION_OPTION_RESTRICT_CHILD_PROCESS_CREATION,
    PS_MITIGATION_OPTION_IMPORT_ADDRESS_FILTER,
    PS_MITIGATION_OPTION_MODULE_TAMPERING_PROTECTION,
    PS_MITIGATION_OPTION_RESTRICT_INDIRECT_BRANCH_PREDICTION,
    PS_MITIGATION_OPTION_SPECULATIVE_STORE_BYPASS_DISABLE, // since REDSTONE5
    PS_MITIGATION_OPTION_ALLOW_DOWNGRADE_DYNAMIC_CODE_POLICY,
    PS_MITIGATION_OPTION_CET_SHADOW_STACKS
} PS_MITIGATION_OPTION;

// windows-internals-book:"Chapter 5"
typedef enum _PS_CREATE_STATE
{
    PsCreateInitialState,
    PsCreateFailOnFileOpen,
    PsCreateFailOnSectionCreate,
    PsCreateFailExeFormat,
    PsCreateFailMachineMismatch,
    PsCreateFailExeName, // Debugger specified
    PsCreateSuccess,
    PsCreateMaximumStates
} PS_CREATE_STATE;

typedef struct _PS_CREATE_INFO
{
    SIZE_T Size;
    PS_CREATE_STATE State;
    union
    {
        // PsCreateInitialState
        struct
        {
            union
            {
                ULONG InitFlags;
                struct
                {
                    UCHAR WriteOutputOnExit : 1;
                    UCHAR DetectManifest : 1;
                    UCHAR IFEOSkipDebugger : 1;
                    UCHAR IFEODoNotPropagateKeyState : 1;
                    UCHAR SpareBits1 : 4;
                    UCHAR SpareBits2 : 8;
                    USHORT ProhibitedImageCharacteristics : 16;
                };
            };
            ACCESS_MASK AdditionalFileAccess;
        } InitState;

        // PsCreateFailOnSectionCreate
        struct
        {
            HANDLE FileHandle;
        } FailSection;

        // PsCreateFailExeFormat
        struct
        {
            USHORT DllCharacteristics;
        } ExeFormat;

        // PsCreateFailExeName
        struct
        {
            HANDLE IFEOKey;
        } ExeName;

        // PsCreateSuccess
        struct
        {
            union
            {
                ULONG OutputFlags;
                struct
                {
                    UCHAR ProtectedProcess : 1;
                    UCHAR AddressSpaceOverride : 1;
                    UCHAR DevOverrideEnabled : 1; // from Image File Execution Options
                    UCHAR ManifestDetected : 1;
                    UCHAR ProtectedProcessLight : 1;
                    UCHAR SpareBits1 : 3;
                    UCHAR SpareBits2 : 8;
                    USHORT SpareBits3 : 16;
                };
            };
            HANDLE FileHandle;
            HANDLE SectionHandle;
            ULONGLONG UserProcessParametersNative;
            ULONG UserProcessParametersWow64;
            ULONG CurrentParameterFlags;
            ULONGLONG PebAddressNative;
            ULONG PebAddressWow64;
            ULONGLONG ManifestAddress;
            ULONG ManifestSize;
        } SuccessState;
    };
} PS_CREATE_INFO, *PPS_CREATE_INFO;

// end_private

// begin_rev
#define PROCESS_CREATE_FLAGS_BREAKAWAY 0x00000001
#define PROCESS_CREATE_FLAGS_NO_DEBUG_INHERIT 0x00000002
#define PROCESS_CREATE_FLAGS_INHERIT_HANDLES 0x00000004
#define PROCESS_CREATE_FLAGS_OVERRIDE_ADDRESS_SPACE 0x00000008
#define PROCESS_CREATE_FLAGS_LARGE_PAGES 0x00000010
#define PROCESS_CREATE_FLAGS_LARGE_PAGE_SYSTEM_DLL 0x00000020
// Extended PROCESS_CREATE_FLAGS_*
#define PROCESS_CREATE_FLAGS_PROTECTED_PROCESS 0x00000040
#define PROCESS_CREATE_FLAGS_CREATE_SESSION 0x00000080 // ?
#define PROCESS_CREATE_FLAGS_INHERIT_FROM_PARENT 0x00000100
#define PROCESS_CREATE_FLAGS_SUSPENDED 0x00000200
#define PROCESS_CREATE_FLAGS_EXTENDED_UNKNOWN 0x00000400
// end_rev

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateUserProcess(
    _Out_ PHANDLE ProcessHandle,
    _Out_ PHANDLE ThreadHandle,
    _In_ ACCESS_MASK ProcessDesiredAccess,
    _In_ ACCESS_MASK ThreadDesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ProcessObjectAttributes,
    _In_opt_ POBJECT_ATTRIBUTES ThreadObjectAttributes,
    _In_ ULONG ProcessFlags, // PROCESS_CREATE_FLAGS_*
    _In_ ULONG ThreadFlags, // THREAD_CREATE_FLAGS_*
    _In_opt_ PVOID ProcessParameters, // PRTL_USER_PROCESS_PARAMETERS
    _Inout_ PPS_CREATE_INFO CreateInfo,
    _In_opt_ PPS_ATTRIBUTE_LIST AttributeList
    );
#endif

// begin_rev
#define THREAD_CREATE_FLAGS_CREATE_SUSPENDED 0x00000001
#define THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH 0x00000002 // ?
#define THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER 0x00000004
#define THREAD_CREATE_FLAGS_HAS_SECURITY_DESCRIPTOR 0x00000010 // ?
#define THREAD_CREATE_FLAGS_ACCESS_CHECK_IN_TARGET 0x00000020 // ?
#define THREAD_CREATE_FLAGS_INITIAL_THREAD 0x00000080
// end_rev

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateThreadEx(
    _Out_ PHANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ProcessHandle,
    _In_ PVOID StartRoutine, // PUSER_THREAD_START_ROUTINE
    _In_opt_ PVOID Argument,
    _In_ ULONG CreateFlags, // THREAD_CREATE_FLAGS_*
    _In_ SIZE_T ZeroBits,
    _In_ SIZE_T StackSize,
    _In_ SIZE_T MaximumStackSize,
    _In_opt_ PPS_ATTRIBUTE_LIST AttributeList
    );
#endif

#endif

// Job objects

#if (PHNT_MODE != PHNT_MODE_KERNEL)

// JOBOBJECTINFOCLASS
// Note: We don't use an enum since it conflicts with the Windows SDK.
#define JobObjectBasicAccountingInformation 1 // JOBOBJECT_BASIC_ACCOUNTING_INFORMATION
#define JobObjectBasicLimitInformation 2 // JOBOBJECT_BASIC_LIMIT_INFORMATION
#define JobObjectBasicProcessIdList 3 // JOBOBJECT_BASIC_PROCESS_ID_LIST
#define JobObjectBasicUIRestrictions 4 // JOBOBJECT_BASIC_UI_RESTRICTIONS
#define JobObjectSecurityLimitInformation 5 // JOBOBJECT_SECURITY_LIMIT_INFORMATION
#define JobObjectEndOfJobTimeInformation 6 // JOBOBJECT_END_OF_JOB_TIME_INFORMATION
#define JobObjectAssociateCompletionPortInformation 7 // JOBOBJECT_ASSOCIATE_COMPLETION_PORT
#define JobObjectBasicAndIoAccountingInformation 8 // JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION
#define JobObjectExtendedLimitInformation 9 // JOBOBJECT_EXTENDED_LIMIT_INFORMATION
#define JobObjectJobSetInformation 10 // JOBOBJECT_JOBSET_INFORMATION
#define JobObjectGroupInformation 11 // USHORT
#define JobObjectNotificationLimitInformation 12 // JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION
#define JobObjectLimitViolationInformation 13 // JOBOBJECT_LIMIT_VIOLATION_INFORMATION
#define JobObjectGroupInformationEx 14 // GROUP_AFFINITY (ARRAY)
#define JobObjectCpuRateControlInformation 15 // JOBOBJECT_CPU_RATE_CONTROL_INFORMATION
#define JobObjectCompletionFilter 16
#define JobObjectCompletionCounter 17
#define JobObjectFreezeInformation 18 // JOBOBJECT_FREEZE_INFORMATION
#define JobObjectExtendedAccountingInformation 19 // JOBOBJECT_EXTENDED_ACCOUNTING_INFORMATION
#define JobObjectWakeInformation 20 // JOBOBJECT_WAKE_INFORMATION
#define JobObjectBackgroundInformation 21
#define JobObjectSchedulingRankBiasInformation 22
#define JobObjectTimerVirtualizationInformation 23
#define JobObjectCycleTimeNotification 24
#define JobObjectClearEvent 25
#define JobObjectInterferenceInformation 26 // JOBOBJECT_INTERFERENCE_INFORMATION
#define JobObjectClearPeakJobMemoryUsed 27
#define JobObjectMemoryUsageInformation 28 // JOBOBJECT_MEMORY_USAGE_INFORMATION // JOBOBJECT_MEMORY_USAGE_INFORMATION_V2
#define JobObjectSharedCommit 29
#define JobObjectContainerId 30
#define JobObjectIoRateControlInformation 31
#define JobObjectNetRateControlInformation 32 // JOBOBJECT_NET_RATE_CONTROL_INFORMATION
#define JobObjectNotificationLimitInformation2 33 // JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2
#define JobObjectLimitViolationInformation2 34 // JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2
#define JobObjectCreateSilo 35
#define JobObjectSiloBasicInformation 36 // SILOOBJECT_BASIC_INFORMATION
#define JobObjectSiloRootDirectory 37 // SILOOBJECT_ROOT_DIRECTORY
#define JobObjectServerSiloBasicInformation 38 // SERVERSILO_BASIC_INFORMATION
#define JobObjectServerSiloUserSharedData 39 // SILO_USER_SHARED_DATA
#define JobObjectServerSiloInitialize 40
#define JobObjectServerSiloRunningState 41
#define JobObjectIoAttribution 42
#define JobObjectMemoryPartitionInformation 43
#define JobObjectContainerTelemetryId 44
#define JobObjectSiloSystemRoot 45
#define JobObjectEnergyTrackingState 46 // JOBOBJECT_ENERGY_TRACKING_STATE
#define JobObjectThreadImpersonationInformation 47
#define MaxJobObjectInfoClass 48

// private
typedef struct _JOBOBJECT_EXTENDED_ACCOUNTING_INFORMATION
{
    JOBOBJECT_BASIC_ACCOUNTING_INFORMATION BasicInfo;
    IO_COUNTERS IoInfo;
    PROCESS_DISK_COUNTERS DiskIoInfo;
    ULONG64 ContextSwitches;
    LARGE_INTEGER TotalCycleTime;
    ULONG64 ReadyTime;
    PROCESS_ENERGY_VALUES EnergyValues;
} JOBOBJECT_EXTENDED_ACCOUNTING_INFORMATION, *PJOBOBJECT_EXTENDED_ACCOUNTING_INFORMATION;

// private
typedef struct _JOBOBJECT_WAKE_INFORMATION
{
    HANDLE NotificationChannel;
    ULONG64 WakeCounters[7];
} JOBOBJECT_WAKE_INFORMATION, *PJOBOBJECT_WAKE_INFORMATION;

// private
typedef struct _JOBOBJECT_WAKE_INFORMATION_V1
{
    HANDLE NotificationChannel;
    ULONG64 WakeCounters[4];
} JOBOBJECT_WAKE_INFORMATION_V1, *PJOBOBJECT_WAKE_INFORMATION_V1;

// private
typedef struct _JOBOBJECT_INTERFERENCE_INFORMATION
{
    ULONG64 Count;
} JOBOBJECT_INTERFERENCE_INFORMATION, *PJOBOBJECT_INTERFERENCE_INFORMATION;

// private
typedef struct _JOBOBJECT_WAKE_FILTER
{
    ULONG HighEdgeFilter;
    ULONG LowEdgeFilter;
} JOBOBJECT_WAKE_FILTER, *PJOBOBJECT_WAKE_FILTER;

// private
typedef struct _JOBOBJECT_FREEZE_INFORMATION
{
    union
    {
        ULONG Flags;
        struct
        {
            ULONG FreezeOperation : 1;
            ULONG FilterOperation : 1;
            ULONG SwapOperation : 1;
            ULONG Reserved : 29;
        };
    };
    BOOLEAN Freeze;
    BOOLEAN Swap;
    UCHAR Reserved0[2];
    JOBOBJECT_WAKE_FILTER WakeFilter;
} JOBOBJECT_FREEZE_INFORMATION, *PJOBOBJECT_FREEZE_INFORMATION;

// private
typedef struct _JOBOBJECT_MEMORY_USAGE_INFORMATION
{
    ULONG64 JobMemory;
    ULONG64 PeakJobMemoryUsed;
} JOBOBJECT_MEMORY_USAGE_INFORMATION, *PJOBOBJECT_MEMORY_USAGE_INFORMATION;

// private
typedef struct _JOBOBJECT_MEMORY_USAGE_INFORMATION_V2
{
    JOBOBJECT_MEMORY_USAGE_INFORMATION BasicInfo;
    ULONG64 JobSharedMemory;
    ULONG64 Reserved[2];
} JOBOBJECT_MEMORY_USAGE_INFORMATION_V2, *PJOBOBJECT_MEMORY_USAGE_INFORMATION_V2;

// private
typedef struct _SILO_USER_SHARED_DATA
{
    ULONG64 ServiceSessionId;
    ULONG ActiveConsoleId;
    LONGLONG ConsoleSessionForegroundProcessId;
    NT_PRODUCT_TYPE NtProductType;
    ULONG SuiteMask;
    ULONG SharedUserSessionId;
    BOOLEAN IsMultiSessionSku;
    WCHAR NtSystemRoot[260];
    USHORT UserModeGlobalLogger[16];
} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;

// private
typedef struct _SILOOBJECT_ROOT_DIRECTORY
{
    ULONG ControlFlags;
    UNICODE_STRING Path;
} SILOOBJECT_ROOT_DIRECTORY, *PSILOOBJECT_ROOT_DIRECTORY;

// private
typedef struct _JOBOBJECT_ENERGY_TRACKING_STATE
{
    ULONG64 Value;
    ULONG UpdateMask;
    ULONG DesiredState;
} JOBOBJECT_ENERGY_TRACKING_STATE, *PJOBOBJECT_ENERGY_TRACKING_STATE;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateJobObject(
    _Out_ PHANDLE JobHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenJobObject(
    _Out_ PHANDLE JobHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAssignProcessToJobObject(
    _In_ HANDLE JobHandle,
    _In_ HANDLE ProcessHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtTerminateJobObject(
    _In_ HANDLE JobHandle,
    _In_ NTSTATUS ExitStatus
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtIsProcessInJob(
    _In_ HANDLE ProcessHandle,
    _In_opt_ HANDLE JobHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationJobObject(
    _In_opt_ HANDLE JobHandle,
    _In_ JOBOBJECTINFOCLASS JobObjectInformationClass,
    _Out_writes_bytes_(JobObjectInformationLength) PVOID JobObjectInformation,
    _In_ ULONG JobObjectInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationJobObject(
    _In_ HANDLE JobHandle,
    _In_ JOBOBJECTINFOCLASS JobObjectInformationClass,
    _In_reads_bytes_(JobObjectInformationLength) PVOID JobObjectInformation,
    _In_ ULONG JobObjectInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateJobSet(
    _In_ ULONG NumJob,
    _In_reads_(NumJob) PJOB_SET_ARRAY UserJobSet,
    _In_ ULONG Flags
    );

#if (PHNT_VERSION >= PHNT_THRESHOLD)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtRevertContainerImpersonation(
    VOID
    );
#endif

#endif

// Reserve objects

#if (PHNT_MODE != PHNT_MODE_KERNEL)

// private
typedef enum _MEMORY_RESERVE_TYPE
{
    MemoryReserveUserApc,
    MemoryReserveIoCompletion,
    MemoryReserveTypeMax
} MEMORY_RESERVE_TYPE;

#if (PHNT_VERSION >= PHNT_WIN7)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtAllocateReserveObject(
    _Out_ PHANDLE MemoryReserveHandle,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ MEMORY_RESERVE_TYPE Type
    );
#endif

#endif

#endif

```

`phnt/ntregapi.h`:

```h
#ifndef _NTREGAPI_H
#define _NTREGAPI_H

// Boot condition flags (NtInitializeRegistry)

#define REG_INIT_BOOT_SM 0x0000
#define REG_INIT_BOOT_SETUP 0x0001
#define REG_INIT_BOOT_ACCEPTED_BASE 0x0002
#define REG_INIT_BOOT_ACCEPTED_MAX REG_INIT_BOOT_ACCEPTED_BASE + 999

#define REG_MAX_KEY_VALUE_NAME_LENGTH 32767
#define REG_MAX_KEY_NAME_LENGTH 512

typedef enum _KEY_INFORMATION_CLASS
{
    KeyBasicInformation, // KEY_BASIC_INFORMATION
    KeyNodeInformation, // KEY_NODE_INFORMATION
    KeyFullInformation, // KEY_FULL_INFORMATION
    KeyNameInformation, // KEY_NAME_INFORMATION
    KeyCachedInformation, // KEY_CACHED_INFORMATION
    KeyFlagsInformation, // KEY_FLAGS_INFORMATION
    KeyVirtualizationInformation, // KEY_VIRTUALIZATION_INFORMATION
    KeyHandleTagsInformation, // KEY_HANDLE_TAGS_INFORMATION
    KeyTrustInformation, // KEY_TRUST_INFORMATION
    KeyLayerInformation, // KEY_LAYER_INFORMATION
    MaxKeyInfoClass
} KEY_INFORMATION_CLASS;

typedef struct _KEY_BASIC_INFORMATION
{
    LARGE_INTEGER LastWriteTime;
    ULONG TitleIndex;
    ULONG NameLength;
    WCHAR Name[1];
} KEY_BASIC_INFORMATION, *PKEY_BASIC_INFORMATION;

typedef struct _KEY_NODE_INFORMATION
{
    LARGE_INTEGER LastWriteTime;
    ULONG TitleIndex;
    ULONG ClassOffset;
    ULONG ClassLength;
    ULONG NameLength;
    WCHAR Name[1];
    // ...
    // WCHAR Class[1];
} KEY_NODE_INFORMATION, *PKEY_NODE_INFORMATION;

typedef struct _KEY_FULL_INFORMATION
{
    LARGE_INTEGER LastWriteTime;
    ULONG TitleIndex;
    ULONG ClassOffset;
    ULONG ClassLength;
    ULONG SubKeys;
    ULONG MaxNameLen;
    ULONG MaxClassLen;
    ULONG Values;
    ULONG MaxValueNameLen;
    ULONG MaxValueDataLen;
    WCHAR Class[1];
} KEY_FULL_INFORMATION, *PKEY_FULL_INFORMATION;

typedef struct _KEY_NAME_INFORMATION
{
    ULONG NameLength;
    WCHAR Name[1];
} KEY_NAME_INFORMATION, *PKEY_NAME_INFORMATION;

typedef struct _KEY_CACHED_INFORMATION
{
    LARGE_INTEGER LastWriteTime;
    ULONG TitleIndex;
    ULONG SubKeys;
    ULONG MaxNameLen;
    ULONG Values;
    ULONG MaxValueNameLen;
    ULONG MaxValueDataLen;
    ULONG NameLength;
    WCHAR Name[1];
} KEY_CACHED_INFORMATION, *PKEY_CACHED_INFORMATION;

typedef struct _KEY_FLAGS_INFORMATION
{
    ULONG UserFlags;
} KEY_FLAGS_INFORMATION, *PKEY_FLAGS_INFORMATION;

typedef struct _KEY_VIRTUALIZATION_INFORMATION
{
    ULONG VirtualizationCandidate : 1; // Tells whether the key is part of the virtualization namespace scope (only HKLM\Software for now).
    ULONG VirtualizationEnabled : 1; // Tells whether virtualization is enabled on this key. Can be 1 only if above flag is 1.
    ULONG VirtualTarget : 1; // Tells if the key is a virtual key. Can be 1 only if above 2 are 0. Valid only on the virtual store key handles.
    ULONG VirtualStore : 1; // Tells if the key is a part of the virtual store path. Valid only on the virtual store key handles.
    ULONG VirtualSource : 1; // Tells if the key has ever been virtualized, can be 1 only if VirtualizationCandidate is 1.
    ULONG Reserved : 27;
} KEY_VIRTUALIZATION_INFORMATION, *PKEY_VIRTUALIZATION_INFORMATION;

// private
typedef struct _KEY_TRUST_INFORMATION
{
    ULONG TrustedKey : 1;
    ULONG Reserved : 31;
} KEY_TRUST_INFORMATION, *PKEY_TRUST_INFORMATION;

// private
typedef struct _KEY_LAYER_INFORMATION
{
    ULONG IsTombstone;
    ULONG IsSupersedeLocal;
    ULONG IsSupersedeTree;
    ULONG ClassIsInherited;
    ULONG Reserved;
} KEY_LAYER_INFORMATION, *PKEY_LAYER_INFORMATION;

typedef enum _KEY_SET_INFORMATION_CLASS
{
    KeyWriteTimeInformation, // KEY_WRITE_TIME_INFORMATION
    KeyWow64FlagsInformation, // KEY_WOW64_FLAGS_INFORMATION
    KeyControlFlagsInformation, // KEY_CONTROL_FLAGS_INFORMATION
    KeySetVirtualizationInformation, // KEY_SET_VIRTUALIZATION_INFORMATION
    KeySetDebugInformation,
    KeySetHandleTagsInformation, // KEY_HANDLE_TAGS_INFORMATION
    KeySetLayerInformation, // KEY_SET_LAYER_INFORMATION
    MaxKeySetInfoClass
} KEY_SET_INFORMATION_CLASS;

typedef struct _KEY_WRITE_TIME_INFORMATION
{
    LARGE_INTEGER LastWriteTime;
} KEY_WRITE_TIME_INFORMATION, *PKEY_WRITE_TIME_INFORMATION;

typedef struct _KEY_WOW64_FLAGS_INFORMATION
{
    ULONG UserFlags;
} KEY_WOW64_FLAGS_INFORMATION, *PKEY_WOW64_FLAGS_INFORMATION;

typedef struct _KEY_HANDLE_TAGS_INFORMATION
{
    ULONG HandleTags;
} KEY_HANDLE_TAGS_INFORMATION, *PKEY_HANDLE_TAGS_INFORMATION;

typedef struct _KEY_SET_LAYER_INFORMATION
{
    ULONG IsTombstone : 1;
    ULONG IsSupersedeLocal : 1;
    ULONG IsSupersedeTree : 1;
    ULONG ClassIsInherited : 1;
    ULONG Reserved : 28;
} KEY_SET_LAYER_INFORMATION, *PKEY_SET_LAYER_INFORMATION;

typedef struct _KEY_CONTROL_FLAGS_INFORMATION
{
    ULONG ControlFlags;
} KEY_CONTROL_FLAGS_INFORMATION, *PKEY_CONTROL_FLAGS_INFORMATION;

typedef struct _KEY_SET_VIRTUALIZATION_INFORMATION
{
    ULONG VirtualTarget : 1;
    ULONG VirtualStore : 1;
    ULONG VirtualSource : 1; // true if key has been virtualized at least once
    ULONG Reserved : 29;
} KEY_SET_VIRTUALIZATION_INFORMATION, *PKEY_SET_VIRTUALIZATION_INFORMATION;

typedef enum _KEY_VALUE_INFORMATION_CLASS
{
    KeyValueBasicInformation, // KEY_VALUE_BASIC_INFORMATION
    KeyValueFullInformation, // KEY_VALUE_FULL_INFORMATION
    KeyValuePartialInformation, // KEY_VALUE_PARTIAL_INFORMATION
    KeyValueFullInformationAlign64,
    KeyValuePartialInformationAlign64,  // KEY_VALUE_PARTIAL_INFORMATION_ALIGN64
    KeyValueLayerInformation, // KEY_VALUE_LAYER_INFORMATION
    MaxKeyValueInfoClass
} KEY_VALUE_INFORMATION_CLASS;

typedef struct _KEY_VALUE_BASIC_INFORMATION
{
    ULONG TitleIndex;
    ULONG Type;
    ULONG NameLength;
    WCHAR Name[1];
} KEY_VALUE_BASIC_INFORMATION, *PKEY_VALUE_BASIC_INFORMATION;

typedef struct _KEY_VALUE_FULL_INFORMATION
{
    ULONG TitleIndex;
    ULONG Type;
    ULONG DataOffset;
    ULONG DataLength;
    ULONG NameLength;
    WCHAR Name[1];
    // ...
    // UCHAR Data[1];
} KEY_VALUE_FULL_INFORMATION, *PKEY_VALUE_FULL_INFORMATION;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION
{
    ULONG TitleIndex;
    ULONG Type;
    ULONG DataLength;
    UCHAR Data[1];
} KEY_VALUE_PARTIAL_INFORMATION, *PKEY_VALUE_PARTIAL_INFORMATION;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64
{
    ULONG Type;
    ULONG DataLength;
    UCHAR Data[1];
} KEY_VALUE_PARTIAL_INFORMATION_ALIGN64, *PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64;

// private
typedef struct _KEY_VALUE_LAYER_INFORMATION
{
    ULONG IsTombstone;
    ULONG Reserved;
} KEY_VALUE_LAYER_INFORMATION, *PKEY_VALUE_LAYER_INFORMATION;

typedef struct _KEY_VALUE_ENTRY
{
    PUNICODE_STRING ValueName;
    ULONG DataLength;
    ULONG DataOffset;
    ULONG Type;
} KEY_VALUE_ENTRY, *PKEY_VALUE_ENTRY;

typedef enum _REG_ACTION
{
    KeyAdded,
    KeyRemoved,
    KeyModified
} REG_ACTION;

typedef struct _REG_NOTIFY_INFORMATION
{
    ULONG NextEntryOffset;
    REG_ACTION Action;
    ULONG KeyLength;
    WCHAR Key[1];
} REG_NOTIFY_INFORMATION, *PREG_NOTIFY_INFORMATION;

typedef struct _KEY_PID_ARRAY
{
    HANDLE ProcessId;
    UNICODE_STRING KeyName;
} KEY_PID_ARRAY, *PKEY_PID_ARRAY;

typedef struct _KEY_OPEN_SUBKEYS_INFORMATION
{
    ULONG Count;
    KEY_PID_ARRAY KeyArray[1];
} KEY_OPEN_SUBKEYS_INFORMATION, *PKEY_OPEN_SUBKEYS_INFORMATION;

// System calls

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateKey(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Reserved_ ULONG TitleIndex,
    _In_opt_ PUNICODE_STRING Class,
    _In_ ULONG CreateOptions,
    _Out_opt_ PULONG Disposition
    );

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateKeyTransacted(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Reserved_ ULONG TitleIndex,
    _In_opt_ PUNICODE_STRING Class,
    _In_ ULONG CreateOptions,
    _In_ HANDLE TransactionHandle,
    _Out_opt_ PULONG Disposition
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenKey(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenKeyTransacted(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE TransactionHandle
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN7)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenKeyEx(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG OpenOptions
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN7)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenKeyTransactedEx(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG OpenOptions,
    _In_ HANDLE TransactionHandle
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeleteKey(
    _In_ HANDLE KeyHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRenameKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING NewName
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeleteValueKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING ValueName
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryKey(
    _In_ HANDLE KeyHandle,
    _In_ KEY_INFORMATION_CLASS KeyInformationClass,
    _Out_writes_bytes_opt_(Length) PVOID KeyInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationKey(
    _In_ HANDLE KeyHandle,
    _In_ KEY_SET_INFORMATION_CLASS KeySetInformationClass,
    _In_reads_bytes_(KeySetInformationLength) PVOID KeySetInformation,
    _In_ ULONG KeySetInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryValueKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING ValueName,
    _In_ KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    _Out_writes_bytes_opt_(Length) PVOID KeyValueInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetValueKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING ValueName,
    _In_opt_ ULONG TitleIndex,
    _In_ ULONG Type,
    _In_reads_bytes_opt_(DataSize) PVOID Data,
    _In_ ULONG DataSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryMultipleValueKey(
    _In_ HANDLE KeyHandle,
    _Inout_updates_(EntryCount) PKEY_VALUE_ENTRY ValueEntries,
    _In_ ULONG EntryCount,
    _Out_writes_bytes_(*BufferLength) PVOID ValueBuffer,
    _Inout_ PULONG BufferLength,
    _Out_opt_ PULONG RequiredBufferLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtEnumerateKey(
    _In_ HANDLE KeyHandle,
    _In_ ULONG Index,
    _In_ KEY_INFORMATION_CLASS KeyInformationClass,
    _Out_writes_bytes_opt_(Length) PVOID KeyInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtEnumerateValueKey(
    _In_ HANDLE KeyHandle,
    _In_ ULONG Index,
    _In_ KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    _Out_writes_bytes_opt_(Length) PVOID KeyValueInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFlushKey(
    _In_ HANDLE KeyHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCompactKeys(
    _In_ ULONG Count,
    _In_reads_(Count) HANDLE KeyArray[]
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCompressKey(
    _In_ HANDLE Key
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtLoadKey(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ POBJECT_ATTRIBUTES SourceFile
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtLoadKey2(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ POBJECT_ATTRIBUTES SourceFile,
    _In_ ULONG Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtLoadKeyEx(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ POBJECT_ATTRIBUTES SourceFile,
    _In_ ULONG Flags,
    _In_opt_ HANDLE TrustClassKey,
    _In_opt_ HANDLE Event,
    _In_opt_ ACCESS_MASK DesiredAccess,
    _Out_opt_ PHANDLE RootHandle,
    _Out_opt_ PIO_STATUS_BLOCK IoStatus
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReplaceKey(
    _In_ POBJECT_ATTRIBUTES NewFile,
    _In_ HANDLE TargetHandle,
    _In_ POBJECT_ATTRIBUTES OldFile
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSaveKey(
    _In_ HANDLE KeyHandle,
    _In_ HANDLE FileHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSaveKeyEx(
    _In_ HANDLE KeyHandle,
    _In_ HANDLE FileHandle,
    _In_ ULONG Format
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSaveMergedKeys(
    _In_ HANDLE HighPrecedenceKeyHandle,
    _In_ HANDLE LowPrecedenceKeyHandle,
    _In_ HANDLE FileHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRestoreKey(
    _In_ HANDLE KeyHandle,
    _In_ HANDLE FileHandle,
    _In_ ULONG Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnloadKey(
    _In_ POBJECT_ATTRIBUTES TargetKey
    );

//
// NtUnloadKey2 Flags (from winnt.h)
//
//#define REG_FORCE_UNLOAD            1
//#define REG_UNLOAD_LEGAL_FLAGS      (REG_FORCE_UNLOAD)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnloadKey2(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ ULONG Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnloadKeyEx(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_opt_ HANDLE Event
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtNotifyChangeKey(
    _In_ HANDLE KeyHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG CompletionFilter,
    _In_ BOOLEAN WatchTree,
    _Out_writes_bytes_opt_(BufferSize) PVOID Buffer,
    _In_ ULONG BufferSize,
    _In_ BOOLEAN Asynchronous
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtNotifyChangeMultipleKeys(
    _In_ HANDLE MasterKeyHandle,
    _In_opt_ ULONG Count,
    _In_reads_opt_(Count) OBJECT_ATTRIBUTES SubordinateObjects[],
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG CompletionFilter,
    _In_ BOOLEAN WatchTree,
    _Out_writes_bytes_opt_(BufferSize) PVOID Buffer,
    _In_ ULONG BufferSize,
    _In_ BOOLEAN Asynchronous
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryOpenSubKeys(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _Out_ PULONG HandleCount
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryOpenSubKeysEx(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ ULONG BufferLength,
    _Out_writes_bytes_opt_(BufferLength) PVOID Buffer,
    _Out_ PULONG RequiredSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtInitializeRegistry(
    _In_ USHORT BootCondition
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtLockRegistryKey(
    _In_ HANDLE KeyHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtLockProductActivationKeys(
    _Inout_opt_ ULONG *pPrivateVer,
    _Out_opt_ ULONG *pSafeMode
    );

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSCALLAPI
NTSTATUS
NTAPI
NtFreezeRegistry(
    _In_ ULONG TimeOutInSeconds
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSCALLAPI
NTSTATUS
NTAPI
NtThawRegistry(
    VOID
    );
#endif

#endif

```

`phnt/ntrtl.h`:

```h
/*
 * Process Hacker -
 *   RTL support functions
 *
 * This file is part of Process Hacker.
 *
 * Process Hacker is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Process Hacker is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Process Hacker.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef _NTRTL_H
#define _NTRTL_H

#define RtlOffsetToPointer(Base, Offset) ((PCHAR)(((PCHAR)(Base)) + ((ULONG_PTR)(Offset))))
#define RtlPointerToOffset(Base, Pointer) ((ULONG)(((PCHAR)(Pointer)) - ((PCHAR)(Base))))

// Linked lists

FORCEINLINE VOID InitializeListHead(
    _Out_ PLIST_ENTRY ListHead
    )
{
    ListHead->Flink = ListHead->Blink = ListHead;
}

_Check_return_ FORCEINLINE BOOLEAN IsListEmpty(
    _In_ PLIST_ENTRY ListHead
    )
{
    return ListHead->Flink == ListHead;
}

FORCEINLINE BOOLEAN RemoveEntryList(
    _In_ PLIST_ENTRY Entry
    )
{
    PLIST_ENTRY Blink;
    PLIST_ENTRY Flink;

    Flink = Entry->Flink;
    Blink = Entry->Blink;
    Blink->Flink = Flink;
    Flink->Blink = Blink;

    return Flink == Blink;
}

FORCEINLINE PLIST_ENTRY RemoveHeadList(
    _Inout_ PLIST_ENTRY ListHead
    )
{
    PLIST_ENTRY Flink;
    PLIST_ENTRY Entry;

    Entry = ListHead->Flink;
    Flink = Entry->Flink;
    ListHead->Flink = Flink;
    Flink->Blink = ListHead;

    return Entry;
}

FORCEINLINE PLIST_ENTRY RemoveTailList(
    _Inout_ PLIST_ENTRY ListHead
    )
{
    PLIST_ENTRY Blink;
    PLIST_ENTRY Entry;

    Entry = ListHead->Blink;
    Blink = Entry->Blink;
    ListHead->Blink = Blink;
    Blink->Flink = ListHead;

    return Entry;
}

FORCEINLINE VOID InsertTailList(
    _Inout_ PLIST_ENTRY ListHead,
    _Inout_ PLIST_ENTRY Entry
    )
{
    PLIST_ENTRY Blink;

    Blink = ListHead->Blink;
    Entry->Flink = ListHead;
    Entry->Blink = Blink;
    Blink->Flink = Entry;
    ListHead->Blink = Entry;
}

FORCEINLINE VOID InsertHeadList(
    _Inout_ PLIST_ENTRY ListHead,
    _Inout_ PLIST_ENTRY Entry
    )
{
    PLIST_ENTRY Flink;

    Flink = ListHead->Flink;
    Entry->Flink = Flink;
    Entry->Blink = ListHead;
    Flink->Blink = Entry;
    ListHead->Flink = Entry;
}

FORCEINLINE VOID AppendTailList(
    _Inout_ PLIST_ENTRY ListHead,
    _Inout_ PLIST_ENTRY ListToAppend
    )
{
    PLIST_ENTRY ListEnd = ListHead->Blink;

    ListHead->Blink->Flink = ListToAppend;
    ListHead->Blink = ListToAppend->Blink;
    ListToAppend->Blink->Flink = ListHead;
    ListToAppend->Blink = ListEnd;
}

FORCEINLINE PSINGLE_LIST_ENTRY PopEntryList(
    _Inout_ PSINGLE_LIST_ENTRY ListHead
    )
{
    PSINGLE_LIST_ENTRY FirstEntry;

    FirstEntry = ListHead->Next;

    if (FirstEntry)
        ListHead->Next = FirstEntry->Next;

    return FirstEntry;
}

FORCEINLINE VOID PushEntryList(
    _Inout_ PSINGLE_LIST_ENTRY ListHead,
    _Inout_ PSINGLE_LIST_ENTRY Entry
    )
{
    Entry->Next = ListHead->Next;
    ListHead->Next = Entry;
}

// AVL and splay trees

typedef enum _TABLE_SEARCH_RESULT
{
    TableEmptyTree,
    TableFoundNode,
    TableInsertAsLeft,
    TableInsertAsRight
} TABLE_SEARCH_RESULT;

typedef enum _RTL_GENERIC_COMPARE_RESULTS
{
    GenericLessThan,
    GenericGreaterThan,
    GenericEqual
} RTL_GENERIC_COMPARE_RESULTS;

typedef RTL_GENERIC_COMPARE_RESULTS (NTAPI *PRTL_AVL_COMPARE_ROUTINE)(
    _In_ struct _RTL_AVL_TABLE *Table,
    _In_ PVOID FirstStruct,
    _In_ PVOID SecondStruct
    );

typedef PVOID (NTAPI *PRTL_AVL_ALLOCATE_ROUTINE)(
    _In_ struct _RTL_AVL_TABLE *Table,
    _In_ CLONG ByteSize
    );

typedef VOID (NTAPI *PRTL_AVL_FREE_ROUTINE)(
    _In_ struct _RTL_AVL_TABLE *Table,
    _In_ _Post_invalid_ PVOID Buffer
    );

typedef NTSTATUS (NTAPI *PRTL_AVL_MATCH_FUNCTION)(
    _In_ struct _RTL_AVL_TABLE *Table,
    _In_ PVOID UserData,
    _In_ PVOID MatchData
    );

typedef struct _RTL_BALANCED_LINKS
{
    struct _RTL_BALANCED_LINKS *Parent;
    struct _RTL_BALANCED_LINKS *LeftChild;
    struct _RTL_BALANCED_LINKS *RightChild;
    CHAR Balance;
    UCHAR Reserved[3];
} RTL_BALANCED_LINKS, *PRTL_BALANCED_LINKS;

typedef struct _RTL_AVL_TABLE
{
    RTL_BALANCED_LINKS BalancedRoot;
    PVOID OrderedPointer;
    ULONG WhichOrderedElement;
    ULONG NumberGenericTableElements;
    ULONG DepthOfTree;
    PRTL_BALANCED_LINKS RestartKey;
    ULONG DeleteCount;
    PRTL_AVL_COMPARE_ROUTINE CompareRoutine;
    PRTL_AVL_ALLOCATE_ROUTINE AllocateRoutine;
    PRTL_AVL_FREE_ROUTINE FreeRoutine;
    PVOID TableContext;
} RTL_AVL_TABLE, *PRTL_AVL_TABLE;

NTSYSAPI
VOID
NTAPI
RtlInitializeGenericTableAvl(
    _Out_ PRTL_AVL_TABLE Table,
    _In_ PRTL_AVL_COMPARE_ROUTINE CompareRoutine,
    _In_ PRTL_AVL_ALLOCATE_ROUTINE AllocateRoutine,
    _In_ PRTL_AVL_FREE_ROUTINE FreeRoutine,
    _In_opt_ PVOID TableContext
    );

NTSYSAPI
PVOID
NTAPI
RtlInsertElementGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_reads_bytes_(BufferSize) PVOID Buffer,
    _In_ CLONG BufferSize,
    _Out_opt_ PBOOLEAN NewElement
    );

NTSYSAPI
PVOID
NTAPI
RtlInsertElementGenericTableFullAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_reads_bytes_(BufferSize) PVOID Buffer,
    _In_ CLONG BufferSize,
    _Out_opt_ PBOOLEAN NewElement,
    _In_ PVOID NodeOrParent,
    _In_ TABLE_SEARCH_RESULT SearchResult
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlDeleteElementGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ PVOID Buffer
    );

_Check_return_
NTSYSAPI
PVOID
NTAPI
RtlLookupElementGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ PVOID Buffer
    );

NTSYSAPI
PVOID
NTAPI
RtlLookupElementGenericTableFullAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ PVOID Buffer,
    _Out_ PVOID *NodeOrParent,
    _Out_ TABLE_SEARCH_RESULT *SearchResult
    );

_Check_return_
NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ BOOLEAN Restart
    );

_Check_return_
NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTableWithoutSplayingAvl(
    _In_ PRTL_AVL_TABLE Table,
    _Inout_ PVOID *RestartKey
    );

_Check_return_
NTSYSAPI
PVOID
NTAPI
RtlLookupFirstMatchingElementGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ PVOID Buffer,
    _Out_ PVOID *RestartKey
    );

_Check_return_
NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTableLikeADirectory(
    _In_ PRTL_AVL_TABLE Table,
    _In_opt_ PRTL_AVL_MATCH_FUNCTION MatchFunction,
    _In_opt_ PVOID MatchData,
    _In_ ULONG NextFlag,
    _Inout_ PVOID *RestartKey,
    _Inout_ PULONG DeleteCount,
    _In_ PVOID Buffer
    );

_Check_return_
NTSYSAPI
PVOID
NTAPI
RtlGetElementGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ ULONG I
    );

NTSYSAPI
ULONG
NTAPI
RtlNumberGenericTableElementsAvl(
    _In_ PRTL_AVL_TABLE Table
    );

_Check_return_
NTSYSAPI
BOOLEAN
NTAPI
RtlIsGenericTableEmptyAvl(
    _In_ PRTL_AVL_TABLE Table
    );

typedef struct _RTL_SPLAY_LINKS
{
    struct _RTL_SPLAY_LINKS *Parent;
    struct _RTL_SPLAY_LINKS *LeftChild;
    struct _RTL_SPLAY_LINKS *RightChild;
} RTL_SPLAY_LINKS, *PRTL_SPLAY_LINKS;

#define RtlInitializeSplayLinks(Links) \
{ \
    PRTL_SPLAY_LINKS _SplayLinks; \
    _SplayLinks = (PRTL_SPLAY_LINKS)(Links); \
    _SplayLinks->Parent = _SplayLinks; \
    _SplayLinks->LeftChild = NULL; \
    _SplayLinks->RightChild = NULL; \
}

#define RtlParent(Links) ((PRTL_SPLAY_LINKS)(Links)->Parent)
#define RtlLeftChild(Links) ((PRTL_SPLAY_LINKS)(Links)->LeftChild)
#define RtlRightChild(Links) ((PRTL_SPLAY_LINKS)(Links)->RightChild)
#define RtlIsRoot(Links) ((RtlParent(Links) == (PRTL_SPLAY_LINKS)(Links)))
#define RtlIsLeftChild(Links) ((RtlLeftChild(RtlParent(Links)) == (PRTL_SPLAY_LINKS)(Links)))
#define RtlIsRightChild(Links) ((RtlRightChild(RtlParent(Links)) == (PRTL_SPLAY_LINKS)(Links)))

#define RtlInsertAsLeftChild(ParentLinks, ChildLinks) \
{ \
    PRTL_SPLAY_LINKS _SplayParent; \
    PRTL_SPLAY_LINKS _SplayChild; \
    _SplayParent = (PRTL_SPLAY_LINKS)(ParentLinks); \
    _SplayChild = (PRTL_SPLAY_LINKS)(ChildLinks); \
    _SplayParent->LeftChild = _SplayChild; \
    _SplayChild->Parent = _SplayParent; \
}

#define RtlInsertAsRightChild(ParentLinks, ChildLinks) \
{ \
    PRTL_SPLAY_LINKS _SplayParent; \
    PRTL_SPLAY_LINKS _SplayChild; \
    _SplayParent = (PRTL_SPLAY_LINKS)(ParentLinks); \
    _SplayChild = (PRTL_SPLAY_LINKS)(ChildLinks); \
    _SplayParent->RightChild = _SplayChild; \
    _SplayChild->Parent = _SplayParent; \
}

NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlSplay(
    _Inout_ PRTL_SPLAY_LINKS Links
    );

NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlDelete(
    _In_ PRTL_SPLAY_LINKS Links
    );

NTSYSAPI
VOID
NTAPI
RtlDeleteNoSplay(
    _In_ PRTL_SPLAY_LINKS Links,
    _Inout_ PRTL_SPLAY_LINKS *Root
    );

_Check_return_
NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlSubtreeSuccessor(
    _In_ PRTL_SPLAY_LINKS Links
    );

_Check_return_
NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlSubtreePredecessor(
    _In_ PRTL_SPLAY_LINKS Links
    );

_Check_return_
NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlRealSuccessor(
    _In_ PRTL_SPLAY_LINKS Links
    );

_Check_return_
NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlRealPredecessor(
    _In_ PRTL_SPLAY_LINKS Links
    );

struct _RTL_GENERIC_TABLE;

typedef RTL_GENERIC_COMPARE_RESULTS (NTAPI *PRTL_GENERIC_COMPARE_ROUTINE)(
    _In_ struct _RTL_GENERIC_TABLE *Table,
    _In_ PVOID FirstStruct,
    _In_ PVOID SecondStruct
    );

typedef PVOID (NTAPI *PRTL_GENERIC_ALLOCATE_ROUTINE)(
    _In_ struct _RTL_GENERIC_TABLE *Table,
    _In_ CLONG ByteSize
    );

typedef VOID (NTAPI *PRTL_GENERIC_FREE_ROUTINE)(
    _In_ struct _RTL_GENERIC_TABLE *Table,
    _In_ _Post_invalid_ PVOID Buffer
    );

typedef struct _RTL_GENERIC_TABLE
{
    PRTL_SPLAY_LINKS TableRoot;
    LIST_ENTRY InsertOrderList;
    PLIST_ENTRY OrderedPointer;
    ULONG WhichOrderedElement;
    ULONG NumberGenericTableElements;
    PRTL_GENERIC_COMPARE_ROUTINE CompareRoutine;
    PRTL_GENERIC_ALLOCATE_ROUTINE AllocateRoutine;
    PRTL_GENERIC_FREE_ROUTINE FreeRoutine;
    PVOID TableContext;
} RTL_GENERIC_TABLE, *PRTL_GENERIC_TABLE;

NTSYSAPI
VOID
NTAPI
RtlInitializeGenericTable(
    _Out_ PRTL_GENERIC_TABLE Table,
    _In_ PRTL_GENERIC_COMPARE_ROUTINE CompareRoutine,
    _In_ PRTL_GENERIC_ALLOCATE_ROUTINE AllocateRoutine,
    _In_ PRTL_GENERIC_FREE_ROUTINE FreeRoutine,
    _In_opt_ PVOID TableContext
    );

NTSYSAPI
PVOID
NTAPI
RtlInsertElementGenericTable(
    _In_ PRTL_GENERIC_TABLE Table,
    _In_reads_bytes_(BufferSize) PVOID Buffer,
    _In_ CLONG BufferSize,
    _Out_opt_ PBOOLEAN NewElement
    );

NTSYSAPI
PVOID
NTAPI
RtlInsertElementGenericTableFull(
    _In_ PRTL_GENERIC_TABLE Table,
    _In_reads_bytes_(BufferSize) PVOID Buffer,
    _In_ CLONG BufferSize,
    _Out_opt_ PBOOLEAN NewElement,
    _In_ PVOID NodeOrParent,
    _In_ TABLE_SEARCH_RESULT SearchResult
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlDeleteElementGenericTable(
    _In_ PRTL_GENERIC_TABLE Table,
    _In_ PVOID Buffer
    );

_Check_return_
NTSYSAPI
PVOID
NTAPI
RtlLookupElementGenericTable(
    _In_ PRTL_GENERIC_TABLE Table,
    _In_ PVOID Buffer
    );

NTSYSAPI
PVOID
NTAPI
RtlLookupElementGenericTableFull(
    _In_ PRTL_GENERIC_TABLE Table,
    _In_ PVOID Buffer,
    _Out_ PVOID *NodeOrParent,
    _Out_ TABLE_SEARCH_RESULT *SearchResult
    );

_Check_return_
NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTable(
    _In_ PRTL_GENERIC_TABLE Table,
    _In_ BOOLEAN Restart
    );

_Check_return_
NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTableWithoutSplaying(
    _In_ PRTL_GENERIC_TABLE Table,
    _Inout_ PVOID *RestartKey
    );

_Check_return_
NTSYSAPI
PVOID
NTAPI
RtlGetElementGenericTable(
    _In_ PRTL_GENERIC_TABLE Table,
    _In_ ULONG I
    );

NTSYSAPI
ULONG
NTAPI
RtlNumberGenericTableElements(
    _In_ PRTL_GENERIC_TABLE Table
    );

_Check_return_
NTSYSAPI
BOOLEAN
NTAPI
RtlIsGenericTableEmpty(
    _In_ PRTL_GENERIC_TABLE Table
    );

// RB trees

typedef struct _RTL_RB_TREE
{
    PRTL_BALANCED_NODE Root;
    PRTL_BALANCED_NODE Min;
} RTL_RB_TREE, *PRTL_RB_TREE;

#if (PHNT_VERSION >= PHNT_WIN8)

// rev
NTSYSAPI
VOID
NTAPI
RtlRbInsertNodeEx(
    _In_ PRTL_RB_TREE Tree,
    _In_opt_ PRTL_BALANCED_NODE Parent,
    _In_ BOOLEAN Right,
    _Out_ PRTL_BALANCED_NODE Node
    );

// rev
NTSYSAPI
VOID
NTAPI
RtlRbRemoveNode(
    _In_ PRTL_RB_TREE Tree,
    _In_ PRTL_BALANCED_NODE Node
    );

#endif

// Hash tables

// begin_ntddk

#define RTL_HASH_ALLOCATED_HEADER 0x00000001
#define RTL_HASH_RESERVED_SIGNATURE 0

typedef struct _RTL_DYNAMIC_HASH_TABLE_ENTRY
{
    LIST_ENTRY Linkage;
    ULONG_PTR Signature;
} RTL_DYNAMIC_HASH_TABLE_ENTRY, *PRTL_DYNAMIC_HASH_TABLE_ENTRY;

#define HASH_ENTRY_KEY(x) ((x)->Signature)

typedef struct _RTL_DYNAMIC_HASH_TABLE_CONTEXT
{
    PLIST_ENTRY ChainHead;
    PLIST_ENTRY PrevLinkage;
    ULONG_PTR Signature;
} RTL_DYNAMIC_HASH_TABLE_CONTEXT, *PRTL_DYNAMIC_HASH_TABLE_CONTEXT;

typedef struct _RTL_DYNAMIC_HASH_TABLE_ENUMERATOR
{
    RTL_DYNAMIC_HASH_TABLE_ENTRY HashEntry;
    PLIST_ENTRY ChainHead;
    ULONG BucketIndex;
} RTL_DYNAMIC_HASH_TABLE_ENUMERATOR, *PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR;

typedef struct _RTL_DYNAMIC_HASH_TABLE
{
    // Entries initialized at creation.
    ULONG Flags;
    ULONG Shift;

    // Entries used in bucket computation.
    ULONG TableSize;
    ULONG Pivot;
    ULONG DivisorMask;

    // Counters.
    ULONG NumEntries;
    ULONG NonEmptyBuckets;
    ULONG NumEnumerators;

    // The directory. This field is for internal use only.
    PVOID Directory;
} RTL_DYNAMIC_HASH_TABLE, *PRTL_DYNAMIC_HASH_TABLE;

#if (PHNT_VERSION >= PHNT_WIN7)

FORCEINLINE
VOID
RtlInitHashTableContext(
    _Inout_ PRTL_DYNAMIC_HASH_TABLE_CONTEXT Context
    )
{
    Context->ChainHead = NULL;
    Context->PrevLinkage = NULL;
}

FORCEINLINE
VOID
RtlInitHashTableContextFromEnumerator(
    _Inout_ PRTL_DYNAMIC_HASH_TABLE_CONTEXT Context,
    _In_ PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR Enumerator
    )
{
    Context->ChainHead = Enumerator->ChainHead;
    Context->PrevLinkage = Enumerator->HashEntry.Linkage.Blink;
}

FORCEINLINE
VOID
RtlReleaseHashTableContext(
    _Inout_ PRTL_DYNAMIC_HASH_TABLE_CONTEXT Context
    )
{
    UNREFERENCED_PARAMETER(Context);
    return;
}

FORCEINLINE
ULONG
RtlTotalBucketsHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable
    )
{
    return HashTable->TableSize;
}

FORCEINLINE
ULONG
RtlNonEmptyBucketsHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable
    )
{
    return HashTable->NonEmptyBuckets;
}

FORCEINLINE
ULONG
RtlEmptyBucketsHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable
    )
{
    return HashTable->TableSize - HashTable->NonEmptyBuckets;
}

FORCEINLINE
ULONG
RtlTotalEntriesHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable
    )
{
    return HashTable->NumEntries;
}

FORCEINLINE
ULONG
RtlActiveEnumeratorsHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable
    )
{
    return HashTable->NumEnumerators;
}

_Must_inspect_result_
NTSYSAPI
BOOLEAN
NTAPI
RtlCreateHashTable(
    _Inout_ _When_(*HashTable == NULL, __drv_allocatesMem(Mem)) PRTL_DYNAMIC_HASH_TABLE *HashTable,
    _In_ ULONG Shift,
    _In_ _Reserved_ ULONG Flags
    );

NTSYSAPI
VOID
NTAPI
RtlDeleteHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlInsertEntryHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable,
    _In_ PRTL_DYNAMIC_HASH_TABLE_ENTRY Entry,
    _In_ ULONG_PTR Signature,
    _Inout_opt_ PRTL_DYNAMIC_HASH_TABLE_CONTEXT Context
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlRemoveEntryHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable,
    _In_ PRTL_DYNAMIC_HASH_TABLE_ENTRY Entry,
    _Inout_opt_ PRTL_DYNAMIC_HASH_TABLE_CONTEXT Context
    );

_Must_inspect_result_
NTSYSAPI
PRTL_DYNAMIC_HASH_TABLE_ENTRY
NTAPI
RtlLookupEntryHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable,
    _In_ ULONG_PTR Signature,
    _Out_opt_ PRTL_DYNAMIC_HASH_TABLE_CONTEXT Context
    );

_Must_inspect_result_
NTSYSAPI
PRTL_DYNAMIC_HASH_TABLE_ENTRY
NTAPI
RtlGetNextEntryHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable,
    _In_ PRTL_DYNAMIC_HASH_TABLE_CONTEXT Context
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlInitEnumerationHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable,
    _Out_ PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR Enumerator
    );

_Must_inspect_result_
NTSYSAPI
PRTL_DYNAMIC_HASH_TABLE_ENTRY
NTAPI
RtlEnumerateEntryHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable,
    _Inout_ PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR Enumerator
    );

NTSYSAPI
VOID
NTAPI
RtlEndEnumerationHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable,
    _Inout_ PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR Enumerator
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlInitWeakEnumerationHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable,
    _Out_ PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR Enumerator
    );

_Must_inspect_result_
NTSYSAPI
PRTL_DYNAMIC_HASH_TABLE_ENTRY
NTAPI
RtlWeaklyEnumerateEntryHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable,
    _Inout_ PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR Enumerator
    );

NTSYSAPI
VOID
NTAPI
RtlEndWeakEnumerationHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable,
    _Inout_ PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR Enumerator
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlExpandHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlContractHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable
    );

#endif

#if (PHNT_VERSION >= PHNT_THRESHOLD)

NTSYSAPI
BOOLEAN
NTAPI
RtlInitStrongEnumerationHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable,
    _Out_ PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR Enumerator
    );

_Must_inspect_result_
NTSYSAPI
PRTL_DYNAMIC_HASH_TABLE_ENTRY
NTAPI
RtlStronglyEnumerateEntryHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable,
    _Inout_ PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR Enumerator
    );

NTSYSAPI
VOID
NTAPI
RtlEndStrongEnumerationHashTable(
    _In_ PRTL_DYNAMIC_HASH_TABLE HashTable,
    _Inout_ PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR Enumerator
    );

#endif

// end_ntddk

// Critical sections

NTSYSAPI
NTSTATUS
NTAPI
RtlInitializeCriticalSection(
    _Out_ PRTL_CRITICAL_SECTION CriticalSection
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlInitializeCriticalSectionAndSpinCount(
    _Inout_ PRTL_CRITICAL_SECTION CriticalSection,
    _In_ ULONG SpinCount
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteCriticalSection(
    _Inout_ PRTL_CRITICAL_SECTION CriticalSection
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlEnterCriticalSection(
    _Inout_ PRTL_CRITICAL_SECTION CriticalSection
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlLeaveCriticalSection(
    _Inout_ PRTL_CRITICAL_SECTION CriticalSection
    );

NTSYSAPI
LOGICAL
NTAPI
RtlTryEnterCriticalSection(
    _Inout_ PRTL_CRITICAL_SECTION CriticalSection
    );

NTSYSAPI
LOGICAL
NTAPI
RtlIsCriticalSectionLocked(
    _In_ PRTL_CRITICAL_SECTION CriticalSection
    );

NTSYSAPI
LOGICAL
NTAPI
RtlIsCriticalSectionLockedByThread(
    _In_ PRTL_CRITICAL_SECTION CriticalSection
    );

NTSYSAPI
ULONG
NTAPI
RtlGetCriticalSectionRecursionCount(
    _In_ PRTL_CRITICAL_SECTION CriticalSection
    );

NTSYSAPI
ULONG
NTAPI
RtlSetCriticalSectionSpinCount(
    _Inout_ PRTL_CRITICAL_SECTION CriticalSection,
    _In_ ULONG SpinCount
    );

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
HANDLE
NTAPI
RtlQueryCriticalSectionOwner(
    _In_ HANDLE EventHandle
    );
#endif

NTSYSAPI
VOID
NTAPI
RtlCheckForOrphanedCriticalSections(
    _In_ HANDLE ThreadHandle
    );

// Resources

typedef struct _RTL_RESOURCE
{
    RTL_CRITICAL_SECTION CriticalSection;

    HANDLE SharedSemaphore;
    volatile ULONG NumberOfWaitingShared;
    HANDLE ExclusiveSemaphore;
    volatile ULONG NumberOfWaitingExclusive;

    volatile LONG NumberOfActive; // negative: exclusive acquire; zero: not acquired; positive: shared acquire(s)
    HANDLE ExclusiveOwnerThread;

    ULONG Flags; // RTL_RESOURCE_FLAG_*

    PRTL_RESOURCE_DEBUG DebugInfo;
} RTL_RESOURCE, *PRTL_RESOURCE;

#define RTL_RESOURCE_FLAG_LONG_TERM ((ULONG)0x00000001)

NTSYSAPI
VOID
NTAPI
RtlInitializeResource(
    _Out_ PRTL_RESOURCE Resource
    );

NTSYSAPI
VOID
NTAPI
RtlDeleteResource(
    _Inout_ PRTL_RESOURCE Resource
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlAcquireResourceShared(
    _Inout_ PRTL_RESOURCE Resource,
    _In_ BOOLEAN Wait
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlAcquireResourceExclusive(
    _Inout_ PRTL_RESOURCE Resource,
    _In_ BOOLEAN Wait
    );

NTSYSAPI
VOID
NTAPI
RtlReleaseResource(
    _Inout_ PRTL_RESOURCE Resource
    );

NTSYSAPI
VOID
NTAPI
RtlConvertSharedToExclusive(
    _Inout_ PRTL_RESOURCE Resource
    );

NTSYSAPI
VOID
NTAPI
RtlConvertExclusiveToShared(
    _Inout_ PRTL_RESOURCE Resource
    );

// Slim reader-writer locks, condition variables, and barriers

#if (PHNT_VERSION >= PHNT_VISTA)

// winbase:InitializeSRWLock
NTSYSAPI
VOID
NTAPI
RtlInitializeSRWLock(
    _Out_ PRTL_SRWLOCK SRWLock
    );

// winbase:AcquireSRWLockExclusive
NTSYSAPI
VOID
NTAPI
RtlAcquireSRWLockExclusive(
    _Inout_ PRTL_SRWLOCK SRWLock
    );

// winbase:AcquireSRWLockShared
NTSYSAPI
VOID
NTAPI
RtlAcquireSRWLockShared(
    _Inout_ PRTL_SRWLOCK SRWLock
    );

// winbase:ReleaseSRWLockExclusive
NTSYSAPI
VOID
NTAPI
RtlReleaseSRWLockExclusive(
    _Inout_ PRTL_SRWLOCK SRWLock
    );

// winbase:ReleaseSRWLockShared
NTSYSAPI
VOID
NTAPI
RtlReleaseSRWLockShared(
    _Inout_ PRTL_SRWLOCK SRWLock
    );

// winbase:TryAcquireSRWLockExclusive
NTSYSAPI
BOOLEAN
NTAPI
RtlTryAcquireSRWLockExclusive(
    _Inout_ PRTL_SRWLOCK SRWLock
    );

// winbase:TryAcquireSRWLockShared
NTSYSAPI
BOOLEAN
NTAPI
RtlTryAcquireSRWLockShared(
    _Inout_ PRTL_SRWLOCK SRWLock
    );

#if (PHNT_VERSION >= PHNT_WIN7)
// rev
NTSYSAPI
VOID
NTAPI
RtlAcquireReleaseSRWLockExclusive(
    _Inout_ PRTL_SRWLOCK SRWLock
    );
#endif

#endif

#if (PHNT_VERSION >= PHNT_VISTA)

// winbase:InitializeConditionVariable
NTSYSAPI
VOID
NTAPI
RtlInitializeConditionVariable(
    _Out_ PRTL_CONDITION_VARIABLE ConditionVariable
    );

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlSleepConditionVariableCS(
    _Inout_ PRTL_CONDITION_VARIABLE ConditionVariable,
    _Inout_ PRTL_CRITICAL_SECTION CriticalSection,
    _In_opt_ PLARGE_INTEGER Timeout
    );

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlSleepConditionVariableSRW(
    _Inout_ PRTL_CONDITION_VARIABLE ConditionVariable,
    _Inout_ PRTL_SRWLOCK SRWLock,
    _In_opt_ PLARGE_INTEGER Timeout,
    _In_ ULONG Flags
    );

// winbase:WakeConditionVariable
NTSYSAPI
VOID
NTAPI
RtlWakeConditionVariable(
    _Inout_ PRTL_CONDITION_VARIABLE ConditionVariable
    );

// winbase:WakeAllConditionVariable
NTSYSAPI
VOID
NTAPI
RtlWakeAllConditionVariable(
    _Inout_ PRTL_CONDITION_VARIABLE ConditionVariable
    );

#endif

// begin_rev
#define RTL_BARRIER_FLAGS_SPIN_ONLY 0x00000001 // never block on event - always spin
#define RTL_BARRIER_FLAGS_BLOCK_ONLY 0x00000002 // always block on event - never spin
#define RTL_BARRIER_FLAGS_NO_DELETE 0x00000004 // use if barrier will never be deleted
// end_rev

// begin_private

#if (PHNT_VERSION >= PHNT_VISTA)

NTSYSAPI
NTSTATUS
NTAPI
RtlInitBarrier(
    _Out_ PRTL_BARRIER Barrier,
    _In_ ULONG TotalThreads,
    _In_ ULONG SpinCount
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteBarrier(
    _In_ PRTL_BARRIER Barrier
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlBarrier(
    _Inout_ PRTL_BARRIER Barrier,
    _In_ ULONG Flags
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlBarrierForDelete(
    _Inout_ PRTL_BARRIER Barrier,
    _In_ ULONG Flags
    );

#endif

// end_private

// Wait on address

// begin_rev

#if (PHNT_VERSION >= PHNT_WIN8)

NTSYSAPI
NTSTATUS
NTAPI
RtlWaitOnAddress(
    _In_ volatile VOID *Address,
    _In_ PVOID CompareAddress,
    _In_ SIZE_T AddressSize,
    _In_opt_ PLARGE_INTEGER Timeout
    );

NTSYSAPI
VOID
NTAPI
RtlWakeAddressAll(
    _In_ PVOID Address
    );

NTSYSAPI
VOID
NTAPI
RtlWakeAddressSingle(
    _In_ PVOID Address
    );

#endif

// end_rev

// Strings

#ifndef PHNT_NO_INLINE_INIT_STRING
FORCEINLINE VOID RtlInitString(
    _Out_ PSTRING DestinationString,
    _In_opt_ PCSTR SourceString
    )
{
    if (SourceString)
        DestinationString->MaximumLength = (DestinationString->Length = (USHORT)strlen(SourceString)) + 1;
    else
        DestinationString->MaximumLength = DestinationString->Length = 0;

    DestinationString->Buffer = (PCHAR)SourceString;
}
#else
NTSYSAPI
VOID
NTAPI
RtlInitString(
    _Out_ PSTRING DestinationString,
    _In_opt_ PCSTR SourceString
    );
#endif

#if (PHNT_VERSION >= PHNT_THRESHOLD)
NTSYSAPI
NTSTATUS
NTAPI
RtlInitStringEx(
    _Out_ PSTRING DestinationString,
    _In_opt_z_ PCSZ SourceString
    );
#endif

#ifndef PHNT_NO_INLINE_INIT_STRING
FORCEINLINE VOID RtlInitAnsiString(
    _Out_ PANSI_STRING DestinationString,
    _In_opt_ PCSTR SourceString
    )
{
    if (SourceString)
        DestinationString->MaximumLength = (DestinationString->Length = (USHORT)strlen(SourceString)) + 1;
    else
        DestinationString->MaximumLength = DestinationString->Length = 0;

    DestinationString->Buffer = (PCHAR)SourceString;
}
#else
NTSYSAPI
VOID
NTAPI
RtlInitAnsiString(
    _Out_ PANSI_STRING DestinationString,
    _In_opt_ PCSTR SourceString
    );
#endif

#if (PHNT_VERSION >= PHNT_WS03)
NTSYSAPI
NTSTATUS
NTAPI
RtlInitAnsiStringEx(
    _Out_ PANSI_STRING DestinationString,
    _In_opt_z_ PCSZ SourceString
    );
#endif

NTSYSAPI
VOID
NTAPI
RtlFreeAnsiString(
    _In_ PANSI_STRING AnsiString
    );

NTSYSAPI
VOID
NTAPI
RtlFreeOemString(
    _Inout_ POEM_STRING OemString
    );

NTSYSAPI
VOID
NTAPI
RtlCopyString(
    _In_ PSTRING DestinationString,
    _In_opt_ PSTRING SourceString
    );

NTSYSAPI
CHAR
NTAPI
RtlUpperChar(
    _In_ CHAR Character
    );

_Must_inspect_result_
NTSYSAPI
LONG
NTAPI
RtlCompareString(
    _In_ PSTRING String1,
    _In_ PSTRING String2,
    _In_ BOOLEAN CaseInSensitive
    );

_Must_inspect_result_
NTSYSAPI
BOOLEAN
NTAPI
RtlEqualString(
    _In_ PSTRING String1,
    _In_ PSTRING String2,
    _In_ BOOLEAN CaseInSensitive
    );

_Must_inspect_result_
NTSYSAPI
BOOLEAN
NTAPI
RtlPrefixString(
    _In_ PSTRING String1,
    _In_ PSTRING String2,
    _In_ BOOLEAN CaseInSensitive
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendStringToString(
    _Inout_ PSTRING Destination,
    _In_ PSTRING Source
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendAsciizToString(
    _In_ PSTRING Destination,
    _In_opt_ PCSTR Source
    );

NTSYSAPI
VOID
NTAPI
RtlUpperString(
    _In_ PSTRING DestinationString,
    _In_ PSTRING SourceString
    );

FORCEINLINE
BOOLEAN
RtlIsNullOrEmptyUnicodeString(
    _In_opt_ PUNICODE_STRING String
    )
{
    return !String || String->Length == 0;
}

FORCEINLINE
VOID
NTAPI
RtlInitEmptyUnicodeString(
    _Out_ PUNICODE_STRING DestinationString,
    _In_opt_ PWCHAR Buffer,
    _In_ USHORT MaximumLength
    )
{
    DestinationString->Buffer = Buffer;
    DestinationString->MaximumLength = MaximumLength;
    DestinationString->Length = 0;
}

#ifndef PHNT_NO_INLINE_INIT_STRING
FORCEINLINE VOID RtlInitUnicodeString(
    _Out_ PUNICODE_STRING DestinationString,
    _In_opt_ PCWSTR SourceString
    )
{
    if (SourceString)
        DestinationString->MaximumLength = (DestinationString->Length = (USHORT)(wcslen(SourceString) * sizeof(WCHAR))) + sizeof(UNICODE_NULL);
    else
        DestinationString->MaximumLength = DestinationString->Length = 0;

    DestinationString->Buffer = (PWCH)SourceString;
}
#else
NTSYSAPI
VOID
NTAPI
RtlInitUnicodeString(
    _Out_ PUNICODE_STRING DestinationString,
    _In_opt_z_ PCWSTR SourceString
    );
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlInitUnicodeStringEx(
    _Out_ PUNICODE_STRING DestinationString,
    _In_opt_z_ PCWSTR SourceString
    );

_Success_(return != 0)
_Must_inspect_result_
NTSYSAPI
BOOLEAN
NTAPI
RtlCreateUnicodeString(
    _Out_ PUNICODE_STRING DestinationString,
    _In_z_ PCWSTR SourceString
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlCreateUnicodeStringFromAsciiz(
    _Out_ PUNICODE_STRING DestinationString,
    _In_ PCSTR SourceString
    );

NTSYSAPI
VOID
NTAPI
RtlFreeUnicodeString(
    _In_ PUNICODE_STRING UnicodeString
    );

#define RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE (0x00000001)
#define RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING (0x00000002)

NTSYSAPI
NTSTATUS
NTAPI
RtlDuplicateUnicodeString(
    _In_ ULONG Flags,
    _In_ PUNICODE_STRING StringIn,
    _Out_ PUNICODE_STRING StringOut
    );

NTSYSAPI
VOID
NTAPI
RtlCopyUnicodeString(
    _In_ PUNICODE_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString
    );

NTSYSAPI
WCHAR
NTAPI
RtlUpcaseUnicodeChar(
    _In_ WCHAR SourceCharacter
    );

NTSYSAPI
WCHAR
NTAPI
RtlDowncaseUnicodeChar(
    _In_ WCHAR SourceCharacter
    );

_Must_inspect_result_
NTSYSAPI
LONG
NTAPI
RtlCompareUnicodeString(
    _In_ PUNICODE_STRING String1,
    _In_ PUNICODE_STRING String2,
    _In_ BOOLEAN CaseInSensitive
    );

#if (PHNT_VERSION >= PHNT_VISTA)
_Must_inspect_result_
NTSYSAPI
LONG
NTAPI
RtlCompareUnicodeStrings(
    _In_reads_(String1Length) PCWCH String1,
    _In_ SIZE_T String1Length,
    _In_reads_(String2Length) PCWCH String2,
    _In_ SIZE_T String2Length,
    _In_ BOOLEAN CaseInSensitive
    );
#endif

_Must_inspect_result_
NTSYSAPI
BOOLEAN
NTAPI
RtlEqualUnicodeString(
    _In_ PUNICODE_STRING String1,
    _In_ PUNICODE_STRING String2,
    _In_ BOOLEAN CaseInSensitive
    );

#define HASH_STRING_ALGORITHM_DEFAULT 0
#define HASH_STRING_ALGORITHM_X65599 1
#define HASH_STRING_ALGORITHM_INVALID 0xffffffff

NTSYSAPI
NTSTATUS
NTAPI
RtlHashUnicodeString(
    _In_ PUNICODE_STRING String,
    _In_ BOOLEAN CaseInSensitive,
    _In_ ULONG HashAlgorithm,
    _Out_ PULONG HashValue
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlValidateUnicodeString(
    _In_ ULONG Flags,
    _In_ PUNICODE_STRING String
    );

_Must_inspect_result_
NTSYSAPI
BOOLEAN
NTAPI
RtlPrefixUnicodeString(
    _In_ PUNICODE_STRING String1,
    _In_ PUNICODE_STRING String2,
    _In_ BOOLEAN CaseInSensitive
    );

#if (PHNT_VERSION >= PHNT_THRESHOLD)
_Must_inspect_result_
NTSYSAPI
BOOLEAN
NTAPI
RtlSuffixUnicodeString(
    _In_ PUNICODE_STRING String1,
    _In_ PUNICODE_STRING String2,
    _In_ BOOLEAN CaseInSensitive
    );
#endif

#if (PHNT_VERSION >= PHNT_THRESHOLD)
_Must_inspect_result_
NTSYSAPI
PWCHAR
NTAPI
RtlFindUnicodeSubstring(
    _In_ PUNICODE_STRING FullString,
    _In_ PUNICODE_STRING SearchString,
    _In_ BOOLEAN CaseInSensitive
    );
#endif

#define RTL_FIND_CHAR_IN_UNICODE_STRING_START_AT_END 0x00000001
#define RTL_FIND_CHAR_IN_UNICODE_STRING_COMPLEMENT_CHAR_SET 0x00000002
#define RTL_FIND_CHAR_IN_UNICODE_STRING_CASE_INSENSITIVE 0x00000004

NTSYSAPI
NTSTATUS
NTAPI
RtlFindCharInUnicodeString(
    _In_ ULONG Flags,
    _In_ PUNICODE_STRING StringToSearch,
    _In_ PUNICODE_STRING CharSet,
    _Out_ PUSHORT NonInclusivePrefixLength
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeStringToString(
    _In_ PUNICODE_STRING Destination,
    _In_ PUNICODE_STRING Source
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeToString(
    _In_ PUNICODE_STRING Destination,
    _In_opt_ PCWSTR Source
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeString(
    _Inout_ PUNICODE_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDowncaseUnicodeString(
    _Inout_ PUNICODE_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString
    );

NTSYSAPI
VOID
NTAPI
RtlEraseUnicodeString(
    _Inout_ PUNICODE_STRING String
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAnsiStringToUnicodeString(
    _Inout_ PUNICODE_STRING DestinationString,
    _In_ PANSI_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToAnsiString(
    _Inout_ PANSI_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString
    );

NTSYSAPI
WCHAR
NTAPI
RtlAnsiCharToUnicodeChar(
    _Inout_ PUCHAR *SourceCharacter
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeStringToAnsiString(
    _Inout_ PANSI_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlOemStringToUnicodeString(
    _Inout_ PUNICODE_STRING DestinationString,
    _In_ POEM_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToOemString(
    _Inout_ POEM_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeStringToOemString(
    _Inout_ POEM_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlOemStringToCountedUnicodeString(
    _Inout_ PUNICODE_STRING DestinationString,
    _In_ PCOEM_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToCountedOemString(
    _Inout_ POEM_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeStringToCountedOemString(
    _Inout_ POEM_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlMultiByteToUnicodeN(
    _Out_writes_bytes_to_(MaxBytesInUnicodeString, *BytesInUnicodeString) PWCH UnicodeString,
    _In_ ULONG MaxBytesInUnicodeString,
    _Out_opt_ PULONG BytesInUnicodeString,
    _In_reads_bytes_(BytesInMultiByteString) PCSTR MultiByteString,
    _In_ ULONG BytesInMultiByteString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlMultiByteToUnicodeSize(
    _Out_ PULONG BytesInUnicodeString,
    _In_reads_bytes_(BytesInMultiByteString) PCSTR MultiByteString,
    _In_ ULONG BytesInMultiByteString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeToMultiByteN(
    _Out_writes_bytes_to_(MaxBytesInMultiByteString, *BytesInMultiByteString) PCHAR MultiByteString,
    _In_ ULONG MaxBytesInMultiByteString,
    _Out_opt_ PULONG BytesInMultiByteString,
    _In_reads_bytes_(BytesInUnicodeString) PCWCH UnicodeString,
    _In_ ULONG BytesInUnicodeString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeToMultiByteSize(
    _Out_ PULONG BytesInMultiByteString,
    _In_reads_bytes_(BytesInUnicodeString) PCWCH UnicodeString,
    _In_ ULONG BytesInUnicodeString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeToMultiByteN(
    _Out_writes_bytes_to_(MaxBytesInMultiByteString, *BytesInMultiByteString) PCHAR MultiByteString,
    _In_ ULONG MaxBytesInMultiByteString,
    _Out_opt_ PULONG BytesInMultiByteString,
    _In_reads_bytes_(BytesInUnicodeString) PCWCH UnicodeString,
    _In_ ULONG BytesInUnicodeString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlOemToUnicodeN(
    _Out_writes_bytes_to_(MaxBytesInUnicodeString, *BytesInUnicodeString) PWSTR UnicodeString,
    _In_ ULONG MaxBytesInUnicodeString,
    _Out_opt_ PULONG BytesInUnicodeString,
    _In_reads_bytes_(BytesInOemString) PCCH OemString,
    _In_ ULONG BytesInOemString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeToOemN(
    _Out_writes_bytes_to_(MaxBytesInOemString, *BytesInOemString) PCHAR OemString,
    _In_ ULONG MaxBytesInOemString,
    _Out_opt_ PULONG BytesInOemString,
    _In_reads_bytes_(BytesInUnicodeString) PCWCH UnicodeString,
    _In_ ULONG BytesInUnicodeString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeToOemN(
    _Out_writes_bytes_to_(MaxBytesInOemString, *BytesInOemString) PCHAR OemString,
    _In_ ULONG MaxBytesInOemString,
    _Out_opt_ PULONG BytesInOemString,
    _In_reads_bytes_(BytesInUnicodeString) PCWCH UnicodeString,
    _In_ ULONG BytesInUnicodeString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlConsoleMultiByteToUnicodeN(
    _Out_writes_bytes_to_(MaxBytesInUnicodeString, *BytesInUnicodeString) PWCH UnicodeString,
    _In_ ULONG MaxBytesInUnicodeString,
    _Out_opt_ PULONG BytesInUnicodeString,
    _In_reads_bytes_(BytesInMultiByteString) PCCH MultiByteString,
    _In_ ULONG BytesInMultiByteString,
    _Out_ PULONG pdwSpecialChar
    );

#if (PHNT_VERSION >= PHNT_WIN7)
NTSYSAPI
NTSTATUS
NTAPI
RtlUTF8ToUnicodeN(
    _Out_writes_bytes_to_(UnicodeStringMaxByteCount, *UnicodeStringActualByteCount) PWSTR UnicodeStringDestination,
    _In_ ULONG UnicodeStringMaxByteCount,
    _Out_ PULONG UnicodeStringActualByteCount,
    _In_reads_bytes_(UTF8StringByteCount) PCCH UTF8StringSource,
    _In_ ULONG UTF8StringByteCount
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN7)
NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeToUTF8N(
    _Out_writes_bytes_to_(UTF8StringMaxByteCount, *UTF8StringActualByteCount) PCHAR UTF8StringDestination,
    _In_ ULONG UTF8StringMaxByteCount,
    _Out_ PULONG UTF8StringActualByteCount,
    _In_reads_bytes_(UnicodeStringByteCount) PCWCH UnicodeStringSource,
    _In_ ULONG UnicodeStringByteCount
    );
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlCustomCPToUnicodeN(
    _In_ PCPTABLEINFO CustomCP,
    _Out_writes_bytes_to_(MaxBytesInUnicodeString, *BytesInUnicodeString) PWCH UnicodeString,
    _In_ ULONG MaxBytesInUnicodeString,
    _Out_opt_ PULONG BytesInUnicodeString,
    _In_reads_bytes_(BytesInCustomCPString) PCH CustomCPString,
    _In_ ULONG BytesInCustomCPString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeToCustomCPN(
    _In_ PCPTABLEINFO CustomCP,
    _Out_writes_bytes_to_(MaxBytesInCustomCPString, *BytesInCustomCPString) PCH CustomCPString,
    _In_ ULONG MaxBytesInCustomCPString,
    _Out_opt_ PULONG BytesInCustomCPString,
    _In_reads_bytes_(BytesInUnicodeString) PWCH UnicodeString,
    _In_ ULONG BytesInUnicodeString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeToCustomCPN(
    _In_ PCPTABLEINFO CustomCP,
    _Out_writes_bytes_to_(MaxBytesInCustomCPString, *BytesInCustomCPString) PCH CustomCPString,
    _In_ ULONG MaxBytesInCustomCPString,
    _Out_opt_ PULONG BytesInCustomCPString,
    _In_reads_bytes_(BytesInUnicodeString) PWCH UnicodeString,
    _In_ ULONG BytesInUnicodeString
    );

NTSYSAPI
VOID
NTAPI
RtlInitCodePageTable(
    _In_reads_z_(2) PUSHORT TableBase,
    _Inout_ PCPTABLEINFO CodePageTable
    );

NTSYSAPI
VOID
NTAPI
RtlInitNlsTables(
    _In_ PUSHORT AnsiNlsBase,
    _In_ PUSHORT OemNlsBase,
    _In_ PUSHORT LanguageNlsBase,
    _Out_ PNLSTABLEINFO TableInfo // PCPTABLEINFO?
    );

NTSYSAPI
VOID
NTAPI
RtlResetRtlTranslations(
    _In_ PNLSTABLEINFO TableInfo
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlIsTextUnicode(
    _In_ PVOID Buffer,
    _In_ ULONG Size,
    _Inout_opt_ PULONG Result
    );

typedef enum _RTL_NORM_FORM
{
    NormOther = 0x0,
    NormC = 0x1,
    NormD = 0x2,
    NormKC = 0x5,
    NormKD = 0x6,
    NormIdna = 0xd,
    DisallowUnassigned = 0x100,
    NormCDisallowUnassigned = 0x101,
    NormDDisallowUnassigned = 0x102,
    NormKCDisallowUnassigned = 0x105,
    NormKDDisallowUnassigned = 0x106,
    NormIdnaDisallowUnassigned = 0x10d
} RTL_NORM_FORM;

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSAPI
NTSTATUS
NTAPI
RtlNormalizeString(
    _In_ ULONG NormForm, // RTL_NORM_FORM
    _In_ PCWSTR SourceString,
    _In_ LONG SourceStringLength,
    _Out_writes_to_(*DestinationStringLength, *DestinationStringLength) PWSTR DestinationString,
    _Inout_ PLONG DestinationStringLength
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSAPI
NTSTATUS
NTAPI
RtlIsNormalizedString(
    _In_ ULONG NormForm, // RTL_NORM_FORM
    _In_ PCWSTR SourceString,
    _In_ LONG SourceStringLength,
    _Out_ PBOOLEAN Normalized
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN7)
// ntifs:FsRtlIsNameInExpression
NTSYSAPI
BOOLEAN
NTAPI
RtlIsNameInExpression(
    _In_ PUNICODE_STRING Expression,
    _In_ PUNICODE_STRING Name,
    _In_ BOOLEAN IgnoreCase,
    _In_opt_ PWCH UpcaseTable
    );
#endif

#if (PHNT_VERSION >= PHNT_REDSTONE4)
// rev
NTSYSAPI
BOOLEAN
NTAPI
RtlIsNameInUnUpcasedExpression(
    _In_ PUNICODE_STRING Expression,
    _In_ PUNICODE_STRING Name,
    _In_ BOOLEAN IgnoreCase,
    _In_opt_ PWCH UpcaseTable
    );
#endif

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualDomainName(
    _In_ PUNICODE_STRING String1,
    _In_ PUNICODE_STRING String2
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualComputerName(
    _In_ PUNICODE_STRING String1,
    _In_ PUNICODE_STRING String2
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDnsHostNameToComputerName(
    _Out_ PUNICODE_STRING ComputerNameString,
    _In_ PUNICODE_STRING DnsHostNameString,
    _In_ BOOLEAN AllocateComputerNameString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlStringFromGUID(
    _In_ PGUID Guid,
    _Out_ PUNICODE_STRING GuidString
    );

#if (PHNT_VERSION >= PHNT_WINBLUE)

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlStringFromGUIDEx(
    _In_ PGUID Guid,
    _Inout_ PUNICODE_STRING GuidString,
    _In_ BOOLEAN AllocateGuidString
    );

#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlGUIDFromString(
    _In_ PUNICODE_STRING GuidString,
    _Out_ PGUID Guid
    );

#if (PHNT_VERSION >= PHNT_VISTA)

NTSYSAPI
LONG
NTAPI
RtlCompareAltitudes(
    _In_ PUNICODE_STRING Altitude1,
    _In_ PUNICODE_STRING Altitude2
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIdnToAscii(
    _In_ ULONG Flags,
    _In_ PCWSTR SourceString,
    _In_ LONG SourceStringLength,
    _Out_writes_to_(*DestinationStringLength, *DestinationStringLength) PWSTR DestinationString,
    _Inout_ PLONG DestinationStringLength
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIdnToUnicode(
    _In_ ULONG Flags,
    _In_ PCWSTR SourceString,
    _In_ LONG SourceStringLength,
    _Out_writes_to_(*DestinationStringLength, *DestinationStringLength) PWSTR DestinationString,
    _Inout_ PLONG DestinationStringLength
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIdnToNameprepUnicode(
    _In_ ULONG Flags,
    _In_ PCWSTR SourceString,
    _In_ LONG SourceStringLength,
    _Out_writes_to_(*DestinationStringLength, *DestinationStringLength) PWSTR DestinationString,
    _Inout_ PLONG DestinationStringLength
    );

#endif

// Prefix

typedef struct _PREFIX_TABLE_ENTRY
{
    CSHORT NodeTypeCode;
    CSHORT NameLength;
    struct _PREFIX_TABLE_ENTRY *NextPrefixTree;
    RTL_SPLAY_LINKS Links;
    PSTRING Prefix;
} PREFIX_TABLE_ENTRY, *PPREFIX_TABLE_ENTRY;

typedef struct _PREFIX_TABLE
{
    CSHORT NodeTypeCode;
    CSHORT NameLength;
    PPREFIX_TABLE_ENTRY NextPrefixTree;
} PREFIX_TABLE, *PPREFIX_TABLE;

NTSYSAPI
VOID
NTAPI
PfxInitialize(
    _Out_ PPREFIX_TABLE PrefixTable
    );

NTSYSAPI
BOOLEAN
NTAPI
PfxInsertPrefix(
    _In_ PPREFIX_TABLE PrefixTable,
    _In_ PSTRING Prefix,
    _Out_ PPREFIX_TABLE_ENTRY PrefixTableEntry
    );

NTSYSAPI
VOID
NTAPI
PfxRemovePrefix(
    _In_ PPREFIX_TABLE PrefixTable,
    _In_ PPREFIX_TABLE_ENTRY PrefixTableEntry
    );

NTSYSAPI
PPREFIX_TABLE_ENTRY
NTAPI
PfxFindPrefix(
    _In_ PPREFIX_TABLE PrefixTable,
    _In_ PSTRING FullName
    );

typedef struct _UNICODE_PREFIX_TABLE_ENTRY
{
    CSHORT NodeTypeCode;
    CSHORT NameLength;
    struct _UNICODE_PREFIX_TABLE_ENTRY *NextPrefixTree;
    struct _UNICODE_PREFIX_TABLE_ENTRY *CaseMatch;
    RTL_SPLAY_LINKS Links;
    PUNICODE_STRING Prefix;
} UNICODE_PREFIX_TABLE_ENTRY, *PUNICODE_PREFIX_TABLE_ENTRY;

typedef struct _UNICODE_PREFIX_TABLE
{
    CSHORT NodeTypeCode;
    CSHORT NameLength;
    PUNICODE_PREFIX_TABLE_ENTRY NextPrefixTree;
    PUNICODE_PREFIX_TABLE_ENTRY LastNextEntry;
} UNICODE_PREFIX_TABLE, *PUNICODE_PREFIX_TABLE;

NTSYSAPI
VOID
NTAPI
RtlInitializeUnicodePrefix(
    _Out_ PUNICODE_PREFIX_TABLE PrefixTable
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlInsertUnicodePrefix(
    _In_ PUNICODE_PREFIX_TABLE PrefixTable,
    _In_ PUNICODE_STRING Prefix,
    _Out_ PUNICODE_PREFIX_TABLE_ENTRY PrefixTableEntry
    );

NTSYSAPI
VOID
NTAPI
RtlRemoveUnicodePrefix(
    _In_ PUNICODE_PREFIX_TABLE PrefixTable,
    _In_ PUNICODE_PREFIX_TABLE_ENTRY PrefixTableEntry
    );

NTSYSAPI
PUNICODE_PREFIX_TABLE_ENTRY
NTAPI
RtlFindUnicodePrefix(
    _In_ PUNICODE_PREFIX_TABLE PrefixTable,
    _In_ PUNICODE_STRING FullName,
    _In_ ULONG CaseInsensitiveIndex
    );

NTSYSAPI
PUNICODE_PREFIX_TABLE_ENTRY
NTAPI
RtlNextUnicodePrefix(
    _In_ PUNICODE_PREFIX_TABLE PrefixTable,
    _In_ BOOLEAN Restart
    );

// Compression

typedef struct _COMPRESSED_DATA_INFO
{
    USHORT CompressionFormatAndEngine; // COMPRESSION_FORMAT_* and COMPRESSION_ENGINE_*

    UCHAR CompressionUnitShift;
    UCHAR ChunkShift;
    UCHAR ClusterShift;
    UCHAR Reserved;

    USHORT NumberOfChunks;

    ULONG CompressedChunkSizes[1];
} COMPRESSED_DATA_INFO, *PCOMPRESSED_DATA_INFO;

NTSYSAPI
NTSTATUS
NTAPI
RtlGetCompressionWorkSpaceSize(
    _In_ USHORT CompressionFormatAndEngine,
    _Out_ PULONG CompressBufferWorkSpaceSize,
    _Out_ PULONG CompressFragmentWorkSpaceSize
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlCompressBuffer(
    _In_ USHORT CompressionFormatAndEngine,
    _In_reads_bytes_(UncompressedBufferSize) PUCHAR UncompressedBuffer,
    _In_ ULONG UncompressedBufferSize,
    _Out_writes_bytes_to_(CompressedBufferSize, *FinalCompressedSize) PUCHAR CompressedBuffer,
    _In_ ULONG CompressedBufferSize,
    _In_ ULONG UncompressedChunkSize,
    _Out_ PULONG FinalCompressedSize,
    _In_ PVOID WorkSpace
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDecompressBuffer(
    _In_ USHORT CompressionFormat,
    _Out_writes_bytes_to_(UncompressedBufferSize, *FinalUncompressedSize) PUCHAR UncompressedBuffer,
    _In_ ULONG UncompressedBufferSize,
    _In_reads_bytes_(CompressedBufferSize) PUCHAR CompressedBuffer,
    _In_ ULONG CompressedBufferSize,
    _Out_ PULONG FinalUncompressedSize
    );

#if (PHNT_VERSION >= PHNT_WIN8)
NTSYSAPI
NTSTATUS
NTAPI
RtlDecompressBufferEx(
    _In_ USHORT CompressionFormat,
    _Out_writes_bytes_to_(UncompressedBufferSize, *FinalUncompressedSize) PUCHAR UncompressedBuffer,
    _In_ ULONG UncompressedBufferSize,
    _In_reads_bytes_(CompressedBufferSize) PUCHAR CompressedBuffer,
    _In_ ULONG CompressedBufferSize,
    _Out_ PULONG FinalUncompressedSize,
    _In_opt_ PVOID WorkSpace
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN8_1)
NTSYSAPI
NTSTATUS
NTAPI
RtlDecompressBufferEx2(
    _In_ USHORT CompressionFormat,
    _Out_writes_bytes_to_(UncompressedBufferSize, *FinalUncompressedSize) PUCHAR UncompressedBuffer,
    _In_ ULONG UncompressedBufferSize,
    _In_reads_bytes_(CompressedBufferSize) PUCHAR CompressedBuffer,
    _In_ ULONG CompressedBufferSize,
    _In_ ULONG UncompressedChunkSize,
    _Out_ PULONG FinalUncompressedSize,
    _In_opt_ PVOID WorkSpace
    );
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlDecompressFragment(
    _In_ USHORT CompressionFormat,
    _Out_writes_bytes_to_(UncompressedFragmentSize, *FinalUncompressedSize) PUCHAR UncompressedFragment,
    _In_ ULONG UncompressedFragmentSize,
    _In_reads_bytes_(CompressedBufferSize) PUCHAR CompressedBuffer,
    _In_ ULONG CompressedBufferSize,
    _In_range_(<, CompressedBufferSize) ULONG FragmentOffset,
    _Out_ PULONG FinalUncompressedSize,
    _In_ PVOID WorkSpace
    );

#if (PHNT_VERSION >= PHNT_WIN8_1)
NTSYSAPI
NTSTATUS
NTAPI
RtlDecompressFragmentEx(
    _In_ USHORT CompressionFormat,
    _Out_writes_bytes_to_(UncompressedFragmentSize, *FinalUncompressedSize) PUCHAR UncompressedFragment,
    _In_ ULONG UncompressedFragmentSize,
    _In_reads_bytes_(CompressedBufferSize) PUCHAR CompressedBuffer,
    _In_ ULONG CompressedBufferSize,
    _In_range_(<, CompressedBufferSize) ULONG FragmentOffset,
    _In_ ULONG UncompressedChunkSize,
    _Out_ PULONG FinalUncompressedSize,
    _In_ PVOID WorkSpace
    );
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlDescribeChunk(
    _In_ USHORT CompressionFormat,
    _Inout_ PUCHAR *CompressedBuffer,
    _In_ PUCHAR EndOfCompressedBufferPlus1,
    _Out_ PUCHAR *ChunkBuffer,
    _Out_ PULONG ChunkSize
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlReserveChunk(
    _In_ USHORT CompressionFormat,
    _Inout_ PUCHAR *CompressedBuffer,
    _In_ PUCHAR EndOfCompressedBufferPlus1,
    _Out_ PUCHAR *ChunkBuffer,
    _In_ ULONG ChunkSize
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDecompressChunks(
    _Out_writes_bytes_(UncompressedBufferSize) PUCHAR UncompressedBuffer,
    _In_ ULONG UncompressedBufferSize,
    _In_reads_bytes_(CompressedBufferSize) PUCHAR CompressedBuffer,
    _In_ ULONG CompressedBufferSize,
    _In_reads_bytes_(CompressedTailSize) PUCHAR CompressedTail,
    _In_ ULONG CompressedTailSize,
    _In_ PCOMPRESSED_DATA_INFO CompressedDataInfo
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlCompressChunks(
    _In_reads_bytes_(UncompressedBufferSize) PUCHAR UncompressedBuffer,
    _In_ ULONG UncompressedBufferSize,
    _Out_writes_bytes_(CompressedBufferSize) PUCHAR CompressedBuffer,
    _In_range_(>=, (UncompressedBufferSize - (UncompressedBufferSize / 16))) ULONG CompressedBufferSize,
    _Inout_updates_bytes_(CompressedDataInfoLength) PCOMPRESSED_DATA_INFO CompressedDataInfo,
    _In_range_(>, sizeof(COMPRESSED_DATA_INFO)) ULONG CompressedDataInfoLength,
    _In_ PVOID WorkSpace
    );

// Locale

#if (PHNT_VERSION >= PHNT_VISTA)

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlConvertLCIDToString(
    _In_ LCID LcidValue,
    _In_ ULONG Base,
    _In_ ULONG Padding, // string is padded to this width
    _Out_writes_(Size) PWSTR pResultBuf,
    _In_ ULONG Size
    );

// private
NTSYSAPI
BOOLEAN
NTAPI
RtlIsValidLocaleName(
    _In_ PCWSTR LocaleName,
    _In_ ULONG Flags
    );

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlGetParentLocaleName(
    _In_ PCWSTR LocaleName,
    _Inout_ PUNICODE_STRING ParentLocaleName,
    _In_ ULONG Flags,
    _In_ BOOLEAN AllocateDestinationString
    );

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlLcidToLocaleName(
    _In_ LCID lcid, // sic
    _Inout_ PUNICODE_STRING LocaleName,
    _In_ ULONG Flags,
    _In_ BOOLEAN AllocateDestinationString
    );

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlLocaleNameToLcid(
    _In_ PCWSTR LocaleName,
    _Out_ PLCID lcid,
    _In_ ULONG Flags
    );

// private
NTSYSAPI
BOOLEAN
NTAPI
RtlLCIDToCultureName(
    _In_ LCID Lcid,
    _Inout_ PUNICODE_STRING String
    );

// private
NTSYSAPI
BOOLEAN
NTAPI
RtlCultureNameToLCID(
    _In_ PUNICODE_STRING String,
    _Out_ PLCID Lcid
    );

// private
NTSYSAPI
VOID
NTAPI
RtlCleanUpTEBLangLists(
    VOID
    );

#endif

#if (PHNT_VERSION >= PHNT_WIN7)

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlGetLocaleFileMappingAddress(
    _Out_ PVOID *BaseAddress,
    _Out_ PLCID DefaultLocaleId,
    _Out_ PLARGE_INTEGER DefaultCasingTableSize
    );

#endif

// PEB

NTSYSAPI
PPEB
NTAPI
RtlGetCurrentPeb(
    VOID
    );

NTSYSAPI
VOID
NTAPI
RtlAcquirePebLock(
    VOID
    );

NTSYSAPI
VOID
NTAPI
RtlReleasePebLock(
    VOID
    );

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
LOGICAL
NTAPI
RtlTryAcquirePebLock(
    VOID
    );
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlAllocateFromPeb(
    _In_ ULONG Size,
    _Out_ PVOID *Block
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlFreeToPeb(
    _In_ PVOID Block,
    _In_ ULONG Size
    );

// Processes

#define DOS_MAX_COMPONENT_LENGTH 255
#define DOS_MAX_PATH_LENGTH (DOS_MAX_COMPONENT_LENGTH + 5)

typedef struct _CURDIR
{
    UNICODE_STRING DosPath;
    HANDLE Handle;
} CURDIR, *PCURDIR;

#define RTL_USER_PROC_CURDIR_CLOSE 0x00000002
#define RTL_USER_PROC_CURDIR_INHERIT 0x00000003

typedef struct _RTL_DRIVE_LETTER_CURDIR
{
    USHORT Flags;
    USHORT Length;
    ULONG TimeStamp;
    STRING DosPath;
} RTL_DRIVE_LETTER_CURDIR, *PRTL_DRIVE_LETTER_CURDIR;

#define RTL_MAX_DRIVE_LETTERS 32
#define RTL_DRIVE_LETTER_VALID (USHORT)0x0001

typedef struct _RTL_USER_PROCESS_PARAMETERS
{
    ULONG MaximumLength;
    ULONG Length;

    ULONG Flags;
    ULONG DebugFlags;

    HANDLE ConsoleHandle;
    ULONG ConsoleFlags;
    HANDLE StandardInput;
    HANDLE StandardOutput;
    HANDLE StandardError;

    CURDIR CurrentDirectory;
    UNICODE_STRING DllPath;
    UNICODE_STRING ImagePathName;
    UNICODE_STRING CommandLine;
    PVOID Environment;

    ULONG StartingX;
    ULONG StartingY;
    ULONG CountX;
    ULONG CountY;
    ULONG CountCharsX;
    ULONG CountCharsY;
    ULONG FillAttribute;

    ULONG WindowFlags;
    ULONG ShowWindowFlags;
    UNICODE_STRING WindowTitle;
    UNICODE_STRING DesktopInfo;
    UNICODE_STRING ShellInfo;
    UNICODE_STRING RuntimeData;
    RTL_DRIVE_LETTER_CURDIR CurrentDirectories[RTL_MAX_DRIVE_LETTERS];

    ULONG_PTR EnvironmentSize;
    ULONG_PTR EnvironmentVersion;
    PVOID PackageDependencyData;
    ULONG ProcessGroupId;
    ULONG LoaderThreads;

    UNICODE_STRING RedirectionDllName; // REDSTONE4
    UNICODE_STRING HeapPartitionName; // 19H1
    ULONG_PTR DefaultThreadpoolCpuSetMasks;
    ULONG DefaultThreadpoolCpuSetMaskCount;
} RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS;

#define RTL_USER_PROC_PARAMS_NORMALIZED 0x00000001
#define RTL_USER_PROC_PROFILE_USER 0x00000002
#define RTL_USER_PROC_PROFILE_KERNEL 0x00000004
#define RTL_USER_PROC_PROFILE_SERVER 0x00000008
#define RTL_USER_PROC_RESERVE_1MB 0x00000020
#define RTL_USER_PROC_RESERVE_16MB 0x00000040
#define RTL_USER_PROC_CASE_SENSITIVE 0x00000080
#define RTL_USER_PROC_DISABLE_HEAP_DECOMMIT 0x00000100
#define RTL_USER_PROC_DLL_REDIRECTION_LOCAL 0x00001000
#define RTL_USER_PROC_APP_MANIFEST_PRESENT 0x00002000
#define RTL_USER_PROC_IMAGE_KEY_MISSING 0x00004000
#define RTL_USER_PROC_OPTIN_PROCESS 0x00020000

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateProcessParameters(
    _Out_ PRTL_USER_PROCESS_PARAMETERS *pProcessParameters,
    _In_ PUNICODE_STRING ImagePathName,
    _In_opt_ PUNICODE_STRING DllPath,
    _In_opt_ PUNICODE_STRING CurrentDirectory,
    _In_opt_ PUNICODE_STRING CommandLine,
    _In_opt_ PVOID Environment,
    _In_opt_ PUNICODE_STRING WindowTitle,
    _In_opt_ PUNICODE_STRING DesktopInfo,
    _In_opt_ PUNICODE_STRING ShellInfo,
    _In_opt_ PUNICODE_STRING RuntimeData
    );

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
NTSTATUS
NTAPI
RtlCreateProcessParametersEx(
    _Out_ PRTL_USER_PROCESS_PARAMETERS *pProcessParameters,
    _In_ PUNICODE_STRING ImagePathName,
    _In_opt_ PUNICODE_STRING DllPath,
    _In_opt_ PUNICODE_STRING CurrentDirectory,
    _In_opt_ PUNICODE_STRING CommandLine,
    _In_opt_ PVOID Environment,
    _In_opt_ PUNICODE_STRING WindowTitle,
    _In_opt_ PUNICODE_STRING DesktopInfo,
    _In_opt_ PUNICODE_STRING ShellInfo,
    _In_opt_ PUNICODE_STRING RuntimeData,
    _In_ ULONG Flags // pass RTL_USER_PROC_PARAMS_NORMALIZED to keep parameters normalized
    );
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlDestroyProcessParameters(
    _In_ _Post_invalid_ PRTL_USER_PROCESS_PARAMETERS ProcessParameters
    );

NTSYSAPI
PRTL_USER_PROCESS_PARAMETERS
NTAPI
RtlNormalizeProcessParams(
    _Inout_ PRTL_USER_PROCESS_PARAMETERS ProcessParameters
    );

NTSYSAPI
PRTL_USER_PROCESS_PARAMETERS
NTAPI
RtlDeNormalizeProcessParams(
    _Inout_ PRTL_USER_PROCESS_PARAMETERS ProcessParameters
    );

typedef struct _RTL_USER_PROCESS_INFORMATION
{
    ULONG Length;
    HANDLE ProcessHandle;
    HANDLE ThreadHandle;
    CLIENT_ID ClientId;
    SECTION_IMAGE_INFORMATION ImageInformation;
} RTL_USER_PROCESS_INFORMATION, *PRTL_USER_PROCESS_INFORMATION;

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlCreateUserProcess(
    _In_ PUNICODE_STRING NtImagePathName,
    _In_ ULONG AttributesDeprecated,
    _In_ PRTL_USER_PROCESS_PARAMETERS ProcessParameters,
    _In_opt_ PSECURITY_DESCRIPTOR ProcessSecurityDescriptor,
    _In_opt_ PSECURITY_DESCRIPTOR ThreadSecurityDescriptor,
    _In_opt_ HANDLE ParentProcess,
    _In_ BOOLEAN InheritHandles,
    _In_opt_ HANDLE DebugPort,
    _In_opt_ HANDLE TokenHandle, // used to be ExceptionPort
    _Out_ PRTL_USER_PROCESS_INFORMATION ProcessInformation
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateUserProcessEx(
    _In_ PUNICODE_STRING NtImagePathName,
    _In_ PRTL_USER_PROCESS_PARAMETERS ProcessParameters,
    _In_ BOOLEAN InheritHandles,
    _Reserved_ ULONG Flags,
    _Out_ PRTL_USER_PROCESS_INFORMATION ProcessInformation
    );

#if (PHNT_VERSION >= PHNT_VISTA)
DECLSPEC_NORETURN
NTSYSAPI
VOID
NTAPI
RtlExitUserProcess(
    _In_ NTSTATUS ExitStatus
    );
#else

#define RtlExitUserProcess RtlExitUserProcess_R

DECLSPEC_NORETURN
FORCEINLINE VOID RtlExitUserProcess_R(
    _In_ NTSTATUS ExitStatus
    )
{
    ExitProcess(ExitStatus);
}

#endif

#if (PHNT_VERSION >= PHNT_VISTA)

// begin_rev
#define RTL_CLONE_PROCESS_FLAGS_CREATE_SUSPENDED 0x00000001
#define RTL_CLONE_PROCESS_FLAGS_INHERIT_HANDLES 0x00000002
#define RTL_CLONE_PROCESS_FLAGS_NO_SYNCHRONIZE 0x00000004 // don't update synchronization objects
// end_rev

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlCloneUserProcess(
    _In_ ULONG ProcessFlags,
    _In_opt_ PSECURITY_DESCRIPTOR ProcessSecurityDescriptor,
    _In_opt_ PSECURITY_DESCRIPTOR ThreadSecurityDescriptor,
    _In_opt_ HANDLE DebugPort,
    _Out_ PRTL_USER_PROCESS_INFORMATION ProcessInformation
    );

// private
NTSYSAPI
VOID
NTAPI
RtlUpdateClonedCriticalSection(
    _Inout_ PRTL_CRITICAL_SECTION CriticalSection
    );

// private
NTSYSAPI
VOID
NTAPI
RtlUpdateClonedSRWLock(
    _Inout_ PRTL_SRWLOCK SRWLock,
    _In_ LOGICAL Shared // TRUE to set to shared acquire
    );

// private
typedef struct _RTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION
{
    HANDLE ReflectionProcessHandle;
    HANDLE ReflectionThreadHandle;
    CLIENT_ID ReflectionClientId;
} RTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION, *PRTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION;

#if (PHNT_VERSION >= PHNT_WIN7)
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlCreateProcessReflection(
    _In_ HANDLE ProcessHandle,
    _In_ ULONG Flags,
    _In_opt_ PVOID StartRoutine,
    _In_opt_ PVOID StartContext,
    _In_opt_ HANDLE EventHandle,
    _Out_opt_ PRTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION ReflectionInformation
    );
#endif

#endif

NTSYSAPI
NTSTATUS
STDAPIVCALLTYPE
RtlSetProcessIsCritical(
    _In_ BOOLEAN NewValue,
    _Out_opt_ PBOOLEAN OldValue,
    _In_ BOOLEAN CheckFlag
    );

NTSYSAPI
NTSTATUS
STDAPIVCALLTYPE
RtlSetThreadIsCritical(
    _In_ BOOLEAN NewValue,
    _Out_opt_ PBOOLEAN OldValue,
    _In_ BOOLEAN CheckFlag
    );

// rev
NTSYSAPI
BOOLEAN
NTAPI
RtlValidProcessProtection(
    _In_ PS_PROTECTION ProcessProtection
    );

// rev
NTSYSAPI
BOOLEAN
NTAPI
RtlTestProtectedAccess(
    _In_ PS_PROTECTION Source,
    _In_ PS_PROTECTION Target
    );

#if (PHNT_VERSION >= PHNT_REDSTONE3)
// rev
NTSYSAPI
BOOLEAN
NTAPI
RtlIsCurrentProcess( // NtCompareObjects(NtCurrentProcess(), ProcessHandle)
    _In_ HANDLE ProcessHandle
    );

// rev
NTSYSAPI
BOOLEAN
NTAPI
RtlIsCurrentThread( // NtCompareObjects(NtCurrentThread(), ThreadHandle)
    _In_ HANDLE ThreadHandle
    );
#endif

// Threads

typedef NTSTATUS (NTAPI *PUSER_THREAD_START_ROUTINE)(
    _In_ PVOID ThreadParameter
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateUserThread(
    _In_ HANDLE Process,
    _In_opt_ PSECURITY_DESCRIPTOR ThreadSecurityDescriptor,
    _In_ BOOLEAN CreateSuspended,
    _In_opt_ ULONG ZeroBits,
    _In_opt_ SIZE_T MaximumStackSize,
    _In_opt_ SIZE_T CommittedStackSize,
    _In_ PUSER_THREAD_START_ROUTINE StartAddress,
    _In_opt_ PVOID Parameter,
    _Out_opt_ PHANDLE Thread,
    _Out_opt_ PCLIENT_ID ClientId
    );

#if (PHNT_VERSION >= PHNT_VISTA) // should be PHNT_WINXP, but is PHNT_VISTA for consistency with RtlExitUserProcess
DECLSPEC_NORETURN
NTSYSAPI
VOID
NTAPI
RtlExitUserThread(
    _In_ NTSTATUS ExitStatus
    );
#else

#define RtlExitUserThread RtlExitUserThread_R

DECLSPEC_NORETURN
FORCEINLINE VOID RtlExitUserThread_R(
    _In_ NTSTATUS ExitStatus
    )
{
    ExitThread(ExitStatus);
}

#endif

#if (PHNT_VERSION >= PHNT_VISTA)

// rev
NTSYSAPI
BOOLEAN
NTAPI
RtlIsCurrentThreadAttachExempt(
    VOID
    );

#endif

#if (PHNT_VERSION >= PHNT_VISTA)

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlCreateUserStack(
    _In_opt_ SIZE_T CommittedStackSize,
    _In_opt_ SIZE_T MaximumStackSize,
    _In_opt_ ULONG_PTR ZeroBits,
    _In_ SIZE_T PageSize,
    _In_ ULONG_PTR ReserveAlignment,
    _Out_ PINITIAL_TEB InitialTeb
    );

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlFreeUserStack(
    _In_ PVOID AllocationBase
    );

#endif

// Extended thread context

typedef struct _CONTEXT_CHUNK 
{
    LONG Offset; // Offset may be negative.
    ULONG Length;
} CONTEXT_CHUNK, *PCONTEXT_CHUNK;

typedef struct _CONTEXT_EX 
{
    CONTEXT_CHUNK All;
    CONTEXT_CHUNK Legacy;
    CONTEXT_CHUNK XState;
} CONTEXT_EX, *PCONTEXT_EX;

#define CONTEXT_EX_LENGTH ALIGN_UP_BY(sizeof(CONTEXT_EX), PAGE_SIZE)
#define RTL_CONTEXT_EX_OFFSET(ContextEx, Chunk) ((ContextEx)->Chunk.Offset)
#define RTL_CONTEXT_EX_LENGTH(ContextEx, Chunk) ((ContextEx)->Chunk.Length)
#define RTL_CONTEXT_EX_CHUNK(Base, Layout, Chunk) ((PVOID)((PCHAR)(Base) + RTL_CONTEXT_EX_OFFSET(Layout, Chunk)))
#define RTL_CONTEXT_OFFSET(Context, Chunk) RTL_CONTEXT_EX_OFFSET((PCONTEXT_EX)(Context + 1), Chunk)
#define RTL_CONTEXT_LENGTH(Context, Chunk) RTL_CONTEXT_EX_LENGTH((PCONTEXT_EX)(Context + 1), Chunk)
#define RTL_CONTEXT_CHUNK(Context, Chunk) RTL_CONTEXT_EX_CHUNK((PCONTEXT_EX)(Context + 1), (PCONTEXT_EX)(Context + 1), Chunk)

NTSYSAPI
VOID
NTAPI
RtlInitializeContext(
    _In_ HANDLE Process,
    _Out_ PCONTEXT Context,
    _In_opt_ PVOID Parameter,
    _In_opt_ PVOID InitialPc,
    _In_opt_ PVOID InitialSp
    );

NTSYSAPI
ULONG
NTAPI
RtlInitializeExtendedContext(
    _Out_ PCONTEXT Context,
    _In_ ULONG ContextFlags,
    _Out_ PCONTEXT_EX* ContextEx
    );

NTSYSAPI
ULONG
NTAPI
RtlCopyExtendedContext(
    _Out_ PCONTEXT_EX Destination,
    _In_ ULONG ContextFlags,
    _In_ PCONTEXT_EX Source
    );

NTSYSAPI
ULONG
NTAPI
RtlGetExtendedContextLength(
    _In_ ULONG ContextFlags,
    _Out_ PULONG ContextLength
    );

NTSYSAPI
ULONG64
NTAPI
RtlGetExtendedFeaturesMask(
    _In_ PCONTEXT_EX ContextEx
    );

NTSYSAPI
PVOID
NTAPI
RtlLocateExtendedFeature(
    _In_ PCONTEXT_EX ContextEx,
    _In_ ULONG FeatureId,
    _Out_opt_ PULONG Length
    );

NTSYSAPI
PCONTEXT
NTAPI
RtlLocateLegacyContext(
    _In_ PCONTEXT_EX ContextEx,
    _Out_opt_ PULONG Length
    );

NTSYSAPI
VOID
NTAPI
RtlSetExtendedFeaturesMask(
    __out PCONTEXT_EX ContextEx,
    _Out_ ULONG64 FeatureMask
    );

#ifdef _WIN64
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlWow64GetThreadContext(
    _In_ HANDLE ThreadHandle,
    _Inout_ PWOW64_CONTEXT ThreadContext
    );
#endif

#ifdef _WIN64
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlWow64SetThreadContext(
    _In_ HANDLE ThreadHandle,
    _In_ PWOW64_CONTEXT ThreadContext
    );
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlRemoteCall(
    _In_ HANDLE Process,
    _In_ HANDLE Thread,
    _In_ PVOID CallSite,
    _In_ ULONG ArgumentCount,
    _In_opt_ PULONG_PTR Arguments,
    _In_ BOOLEAN PassContext,
    _In_ BOOLEAN AlreadySuspended
    );

// Vectored exception handlers

NTSYSAPI
PVOID
NTAPI
RtlAddVectoredExceptionHandler(
    _In_ ULONG First,
    _In_ PVECTORED_EXCEPTION_HANDLER Handler
    );

NTSYSAPI
ULONG
NTAPI
RtlRemoveVectoredExceptionHandler(
    _In_ PVOID Handle
    );

NTSYSAPI
PVOID
NTAPI
RtlAddVectoredContinueHandler(
    _In_ ULONG First,
    _In_ PVECTORED_EXCEPTION_HANDLER Handler
    );

NTSYSAPI
ULONG
NTAPI
RtlRemoveVectoredContinueHandler(
    _In_ PVOID Handle
    );

// Runtime exception handling

typedef ULONG (NTAPI *PRTLP_UNHANDLED_EXCEPTION_FILTER)(
    _In_ PEXCEPTION_POINTERS ExceptionInfo
    );

NTSYSAPI
VOID
NTAPI
RtlSetUnhandledExceptionFilter(
    _In_ PRTLP_UNHANDLED_EXCEPTION_FILTER UnhandledExceptionFilter
    );

// rev
NTSYSAPI
LONG
NTAPI
RtlUnhandledExceptionFilter(
    _In_ PEXCEPTION_POINTERS ExceptionPointers
    );

// rev
NTSYSAPI
LONG
NTAPI
RtlUnhandledExceptionFilter2(
    _In_ PEXCEPTION_POINTERS ExceptionPointers,
    _In_ ULONG Flags
    );

// rev
NTSYSAPI
LONG
NTAPI
RtlKnownExceptionFilter(
    _In_ PEXCEPTION_POINTERS ExceptionPointers
    );

#ifdef _WIN64

// private
typedef enum _FUNCTION_TABLE_TYPE
{
    RF_SORTED,
    RF_UNSORTED,
    RF_CALLBACK,
    RF_KERNEL_DYNAMIC
} FUNCTION_TABLE_TYPE;

// private
typedef struct _DYNAMIC_FUNCTION_TABLE
{
    LIST_ENTRY ListEntry;
    PRUNTIME_FUNCTION FunctionTable;
    LARGE_INTEGER TimeStamp;
    ULONG64 MinimumAddress;
    ULONG64 MaximumAddress;
    ULONG64 BaseAddress;
    PGET_RUNTIME_FUNCTION_CALLBACK Callback;
    PVOID Context;
    PWSTR OutOfProcessCallbackDll;
    FUNCTION_TABLE_TYPE Type;
    ULONG EntryCount;
    RTL_BALANCED_NODE TreeNode;
} DYNAMIC_FUNCTION_TABLE, *PDYNAMIC_FUNCTION_TABLE;

// rev
NTSYSAPI
PLIST_ENTRY
NTAPI
RtlGetFunctionTableListHead(
    VOID
    );

#endif

// Images

NTSYSAPI
PIMAGE_NT_HEADERS
NTAPI
RtlImageNtHeader(
    _In_ PVOID BaseOfImage
    );

#define RTL_IMAGE_NT_HEADER_EX_FLAG_NO_RANGE_CHECK 0x00000001

NTSYSAPI
NTSTATUS
NTAPI
RtlImageNtHeaderEx(
    _In_ ULONG Flags,
    _In_ PVOID BaseOfImage,
    _In_ ULONG64 Size,
    _Out_ PIMAGE_NT_HEADERS *OutHeaders
    );

NTSYSAPI
PVOID
NTAPI
RtlAddressInSectionTable(
    _In_ PIMAGE_NT_HEADERS NtHeaders,
    _In_ PVOID BaseOfImage,
    _In_ ULONG VirtualAddress
    );

NTSYSAPI
PIMAGE_SECTION_HEADER
NTAPI
RtlSectionTableFromVirtualAddress(
    _In_ PIMAGE_NT_HEADERS NtHeaders,
    _In_ PVOID BaseOfImage,
    _In_ ULONG VirtualAddress
    );

NTSYSAPI
PVOID
NTAPI
RtlImageDirectoryEntryToData(
    _In_ PVOID BaseOfImage,
    _In_ BOOLEAN MappedAsImage,
    _In_ USHORT DirectoryEntry,
    _Out_ PULONG Size
    );

NTSYSAPI
PIMAGE_SECTION_HEADER
NTAPI
RtlImageRvaToSection(
    _In_ PIMAGE_NT_HEADERS NtHeaders,
    _In_ PVOID BaseOfImage,
    _In_ ULONG Rva
    );

NTSYSAPI
PVOID
NTAPI
RtlImageRvaToVa(
    _In_ PIMAGE_NT_HEADERS NtHeaders,
    _In_ PVOID BaseOfImage,
    _In_ ULONG Rva,
    _Inout_opt_ PIMAGE_SECTION_HEADER *LastRvaSection
    );

#if (PHNT_VERSION >= PHNT_THRESHOLD)

// rev
NTSYSAPI
PVOID
NTAPI
RtlFindExportedRoutineByName(
    _In_ PVOID BaseOfImage,
    _In_ PCSTR RoutineName
    );

#endif

#if (PHNT_VERSION >= PHNT_REDSTONE)

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlGuardCheckLongJumpTarget(
    _In_ PVOID PcValue, 
    _In_ BOOL IsFastFail, 
    _Out_ PBOOL IsLongJumpTarget
    );

#endif

// Memory

_Must_inspect_result_
NTSYSAPI
SIZE_T
NTAPI
RtlCompareMemoryUlong(
    _In_reads_bytes_(Length) PVOID Source,
    _In_ SIZE_T Length,
    _In_ ULONG Pattern
    );

#if defined(_M_AMD64)
FORCEINLINE
VOID
RtlFillMemoryUlong(
    _Out_writes_bytes_all_(Length) PVOID Destination,
    _In_ SIZE_T Length,
    _In_ ULONG Pattern
    )
{
    PULONG Address = (PULONG)Destination;

    //
    // If the number of DWORDs is not zero, then fill the specified buffer
    // with the specified pattern.
    //

    if ((Length /= 4) != 0) {

        //
        // If the destination is not quadword aligned (ignoring low bits),
        // then align the destination by storing one DWORD.
        //

        if (((ULONG64)Address & 4) != 0) {
            *Address = Pattern;
            if ((Length -= 1) == 0) {
                return;
            }

            Address += 1;
        }

        //
        // If the number of QWORDs is not zero, then fill the destination
        // buffer a QWORD at a time.
        //

         __stosq((PULONG64)(Address),
                 Pattern | ((ULONG64)Pattern << 32),
                 Length / 2);

        if ((Length & 1) != 0) {
            Address[Length - 1] = Pattern;
        }
    }

    return;
}
#else
NTSYSAPI
VOID
NTAPI
RtlFillMemoryUlong(
    _Out_writes_bytes_all_(Length) PVOID Destination,
    _In_ SIZE_T Length,
    _In_ ULONG Pattern
    );
#endif

#if defined(_M_AMD64)

#define RtlFillMemoryUlonglong(Destination, Length, Pattern) \
    __stosq((PULONG64)(Destination), Pattern, (Length) / 8)

#else
NTSYSAPI
VOID
NTAPI
RtlFillMemoryUlonglong(
    _Out_writes_bytes_all_(Length) PVOID Destination,
    _In_ SIZE_T Length,
    _In_ ULONGLONG Pattern
    );
#endif
// Environment

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateEnvironment(
    _In_ BOOLEAN CloneCurrentEnvironment,
    _Out_ PVOID *Environment
    );

// begin_rev
#define RTL_CREATE_ENVIRONMENT_TRANSLATE 0x1 // translate from multi-byte to Unicode
#define RTL_CREATE_ENVIRONMENT_TRANSLATE_FROM_OEM 0x2 // translate from OEM to Unicode (Translate flag must also be set)
#define RTL_CREATE_ENVIRONMENT_EMPTY 0x4 // create empty environment block
// end_rev

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
NTSTATUS
NTAPI
RtlCreateEnvironmentEx(
    _In_ PVOID SourceEnv,
    _Out_ PVOID *Environment,
    _In_ ULONG Flags
    );
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlDestroyEnvironment(
    _In_ PVOID Environment
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetCurrentEnvironment(
    _In_ PVOID Environment,
    _Out_opt_ PVOID *PreviousEnvironment
    );

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
NTSTATUS
NTAPI
RtlSetEnvironmentVar(
    _Inout_opt_ PVOID *Environment,
    _In_reads_(NameLength) PCWSTR Name,
    _In_ SIZE_T NameLength,
    _In_reads_(ValueLength) PCWSTR Value,
    _In_ SIZE_T ValueLength
    );
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlSetEnvironmentVariable(
    _Inout_opt_ PVOID *Environment,
    _In_ PUNICODE_STRING Name,
    _In_opt_ PUNICODE_STRING Value
    );

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
NTSTATUS
NTAPI
RtlQueryEnvironmentVariable(
    _In_opt_ PVOID Environment,
    _In_reads_(NameLength) PCWSTR Name,
    _In_ SIZE_T NameLength,
    _Out_writes_(ValueLength) PWSTR Value,
    _In_ SIZE_T ValueLength,
    _Out_ PSIZE_T ReturnLength
    );
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryEnvironmentVariable_U(
    _In_opt_ PVOID Environment,
    _In_ PUNICODE_STRING Name,
    _Inout_ PUNICODE_STRING Value
    );

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
NTSTATUS
NTAPI
RtlExpandEnvironmentStrings(
    _In_opt_ PVOID Environment,
    _In_reads_(SrcLength) PCWSTR Src,
    _In_ SIZE_T SrcLength,
    _Out_writes_(DstLength) PWSTR Dst,
    _In_ SIZE_T DstLength,
    _Out_opt_ PSIZE_T ReturnLength
    );
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlExpandEnvironmentStrings_U(
    _In_opt_ PVOID Environment,
    _In_ PUNICODE_STRING Source,
    _Inout_ PUNICODE_STRING Destination,
    _Out_opt_ PULONG ReturnedLength
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetEnvironmentStrings(
    _In_ PCWCHAR NewEnvironment,
    _In_ SIZE_T NewEnvironmentSize
    );

// Directory and path support

typedef struct _RTLP_CURDIR_REF
{
    LONG ReferenceCount;
    HANDLE DirectoryHandle;
} RTLP_CURDIR_REF, *PRTLP_CURDIR_REF;

typedef struct _RTL_RELATIVE_NAME_U
{
    UNICODE_STRING RelativeName;
    HANDLE ContainingDirectory;
    PRTLP_CURDIR_REF CurDirRef;
} RTL_RELATIVE_NAME_U, *PRTL_RELATIVE_NAME_U;

// Data exports (ntdll.lib/ntdllp.lib)

//NTSYSAPI PWSTR RtlNtdllName;
//NTSYSAPI UNICODE_STRING RtlDosPathSeperatorsString;
//NTSYSAPI UNICODE_STRING RtlAlternateDosPathSeperatorString;
//NTSYSAPI UNICODE_STRING RtlNtPathSeperatorString;

#ifndef PHNT_INLINE_SEPERATOR_STRINGS
#define RtlNtdllName L"ntdll.dll"
#define RtlDosPathSeperatorsString RTL_CONSTANT_STRING(L"\\/")
#define RtlAlternateDosPathSeperatorString RTL_CONSTANT_STRING(L"/")
#define RtlNtPathSeperatorString RTL_CONSTANT_STRING(L"\\")
#endif

// Path functions

NTSYSAPI
RTL_PATH_TYPE
NTAPI
RtlDetermineDosPathNameType_U(
    _In_ PCWSTR DosFileName
    );

NTSYSAPI
RTL_PATH_TYPE
NTAPI
RtlDetermineDosPathNameType_Ustr(
    _In_ PCUNICODE_STRING DosFileName
    );

NTSYSAPI
ULONG
NTAPI
RtlIsDosDeviceName_U(
    _In_ PCWSTR DosFileName
    );

NTSYSAPI
ULONG
NTAPI
RtlIsDosDeviceName_Ustr(
    _In_ PUNICODE_STRING DosFileName
    );

NTSYSAPI
ULONG
NTAPI
RtlGetFullPathName_U(
    _In_ PCWSTR FileName,
    _In_ ULONG BufferLength,
    _Out_writes_bytes_(BufferLength) PWSTR Buffer,
    _Out_opt_ PWSTR *FilePart
    );

#if (PHNT_VERSION >= PHNT_WIN7)
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlGetFullPathName_UEx(
    _In_ PCWSTR FileName,
    _In_ ULONG BufferLength,
    _Out_writes_bytes_(BufferLength) PWSTR Buffer,
    _Out_opt_ PWSTR *FilePart,
    _Out_opt_ ULONG *BytesRequired
    );
#endif

#if (PHNT_VERSION >= PHNT_WS03)
NTSYSAPI
NTSTATUS
NTAPI
RtlGetFullPathName_UstrEx(
    _In_ PUNICODE_STRING FileName,
    _Inout_ PUNICODE_STRING StaticString,
    _Out_opt_ PUNICODE_STRING DynamicString,
    _Out_opt_ PUNICODE_STRING *StringUsed,
    _Out_opt_ SIZE_T *FilePartPrefixCch,
    _Out_opt_ PBOOLEAN NameInvalid,
    _Out_ RTL_PATH_TYPE *InputPathType,
    _Out_opt_ SIZE_T *BytesRequired
    );
#endif

NTSYSAPI
ULONG
NTAPI
RtlGetCurrentDirectory_U(
    _In_ ULONG BufferLength,
    _Out_writes_bytes_(BufferLength) PWSTR Buffer
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetCurrentDirectory_U(
    _In_ PUNICODE_STRING PathName
    );

NTSYSAPI
ULONG
NTAPI
RtlGetLongestNtPathLength(
    VOID
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlDosPathNameToNtPathName_U(
    _In_ PCWSTR DosFileName,
    _Out_ PUNICODE_STRING NtFileName,
    _Out_opt_ PWSTR *FilePart,
    _Out_opt_ PRTL_RELATIVE_NAME_U RelativeName
    );

#if (PHNT_VERSION >= PHNT_WS03)
NTSYSAPI
NTSTATUS
NTAPI
RtlDosPathNameToNtPathName_U_WithStatus(
    _In_ PCWSTR DosFileName,
    _Out_ PUNICODE_STRING NtFileName,
    _Out_opt_ PWSTR *FilePart,
    _Out_opt_ PRTL_RELATIVE_NAME_U RelativeName
    );
#endif

#if (PHNT_VERSION >= PHNT_REDSTONE3)
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlDosLongPathNameToNtPathName_U_WithStatus(
    _In_ PCWSTR DosFileName,
    _Out_ PUNICODE_STRING NtFileName,
    _Out_opt_ PWSTR *FilePart,
    _Out_opt_ PRTL_RELATIVE_NAME_U RelativeName
    );
#endif

#if (PHNT_VERSION >= PHNT_WS03)
NTSYSAPI
BOOLEAN
NTAPI
RtlDosPathNameToRelativeNtPathName_U(
    _In_ PCWSTR DosFileName,
    _Out_ PUNICODE_STRING NtFileName,
    _Out_opt_ PWSTR *FilePart,
    _Out_opt_ PRTL_RELATIVE_NAME_U RelativeName
    );
#endif

#if (PHNT_VERSION >= PHNT_WS03)
NTSYSAPI
NTSTATUS
NTAPI
RtlDosPathNameToRelativeNtPathName_U_WithStatus(
    _In_ PCWSTR DosFileName,
    _Out_ PUNICODE_STRING NtFileName,
    _Out_opt_ PWSTR *FilePart,
    _Out_opt_ PRTL_RELATIVE_NAME_U RelativeName
    );
#endif

#if (PHNT_VERSION >= PHNT_REDSTONE3)
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlDosLongPathNameToRelativeNtPathName_U_WithStatus(
    _In_ PCWSTR DosFileName,
    _Out_ PUNICODE_STRING NtFileName,
    _Out_opt_ PWSTR *FilePart,
    _Out_opt_ PRTL_RELATIVE_NAME_U RelativeName
    );
#endif

#if (PHNT_VERSION >= PHNT_WS03)
NTSYSAPI
VOID
NTAPI
RtlReleaseRelativeName(
    _Inout_ PRTL_RELATIVE_NAME_U RelativeName
    );
#endif

NTSYSAPI
ULONG
NTAPI
RtlDosSearchPath_U(
    _In_ PCWSTR Path,
    _In_ PCWSTR FileName,
    _In_opt_ PCWSTR Extension,
    _In_ ULONG BufferLength,
    _Out_writes_bytes_(BufferLength) PWSTR Buffer,
    _Out_opt_ PWSTR *FilePart
    );

#define RTL_DOS_SEARCH_PATH_FLAG_APPLY_ISOLATION_REDIRECTION 0x00000001
#define RTL_DOS_SEARCH_PATH_FLAG_DISALLOW_DOT_RELATIVE_PATH_SEARCH 0x00000002
#define RTL_DOS_SEARCH_PATH_FLAG_APPLY_DEFAULT_EXTENSION_WHEN_NOT_RELATIVE_PATH_EVEN_IF_FILE_HAS_EXTENSION 0x00000004

NTSYSAPI
NTSTATUS
NTAPI
RtlDosSearchPath_Ustr(
    _In_ ULONG Flags,
    _In_ PUNICODE_STRING Path,
    _In_ PUNICODE_STRING FileName,
    _In_opt_ PUNICODE_STRING DefaultExtension,
    _Out_opt_ PUNICODE_STRING StaticString,
    _Out_opt_ PUNICODE_STRING DynamicString,
    _Out_opt_ PCUNICODE_STRING *FullFileNameOut,
    _Out_opt_ SIZE_T *FilePartPrefixCch,
    _Out_opt_ SIZE_T *BytesRequired
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlDoesFileExists_U(
    _In_ PCWSTR FileName
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGetLengthWithoutLastFullDosOrNtPathElement(
    _Reserved_ ULONG Flags,
    _In_ PUNICODE_STRING PathString,
    _Out_ PULONG Length
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGetLengthWithoutTrailingPathSeperators(
    _Reserved_ ULONG Flags,
    _In_ PUNICODE_STRING PathString,
    _Out_ PULONG Length
    );

typedef struct _GENERATE_NAME_CONTEXT
{
    USHORT Checksum;
    BOOLEAN CheckSumInserted;
    UCHAR NameLength;
    WCHAR NameBuffer[8];
    ULONG ExtensionLength;
    WCHAR ExtensionBuffer[4];
    ULONG LastIndexValue;
} GENERATE_NAME_CONTEXT, *PGENERATE_NAME_CONTEXT;

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlGenerate8dot3Name(
    _In_ PUNICODE_STRING Name,
    _In_ BOOLEAN AllowExtendedCharacters,
    _Inout_ PGENERATE_NAME_CONTEXT Context,
    _Inout_ PUNICODE_STRING Name8dot3
    );

#if (PHNT_VERSION >= PHNT_WIN8)

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlComputePrivatizedDllName_U(
    _In_ PUNICODE_STRING DllName,
    _Out_ PUNICODE_STRING RealName,
    _Out_ PUNICODE_STRING LocalName
    );

// rev
NTSYSAPI
BOOLEAN
NTAPI
RtlGetSearchPath(
    _Out_ PWSTR *SearchPath
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlSetSearchPathMode(
    _In_ ULONG Flags
    );

// rev
NTSYSAPI
PWSTR
NTAPI
RtlGetExePath(
    VOID
    );

#endif

#if (PHNT_VERSION >= PHNT_REDSTONE2)

// private
NTSYSAPI
PWSTR
NTAPI
RtlGetNtSystemRoot(
    VOID
    );

// rev
NTSYSAPI
BOOLEAN
NTAPI
RtlAreLongPathsEnabled(
    VOID
    );

#endif

NTSYSAPI
BOOLEAN
NTAPI
RtlIsThreadWithinLoaderCallout(
    VOID
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlDllShutdownInProgress(
    VOID
    );

// Heaps

typedef struct _RTL_HEAP_ENTRY
{
    SIZE_T Size;
    USHORT Flags;
    USHORT AllocatorBackTraceIndex;
    union
    {
        struct
        {
            SIZE_T Settable;
            ULONG Tag;
        } s1;
        struct
        {
            SIZE_T CommittedSize;
            PVOID FirstBlock;
        } s2;
    } u;
} RTL_HEAP_ENTRY, *PRTL_HEAP_ENTRY;

#define RTL_HEAP_BUSY (USHORT)0x0001
#define RTL_HEAP_SEGMENT (USHORT)0x0002
#define RTL_HEAP_SETTABLE_VALUE (USHORT)0x0010
#define RTL_HEAP_SETTABLE_FLAG1 (USHORT)0x0020
#define RTL_HEAP_SETTABLE_FLAG2 (USHORT)0x0040
#define RTL_HEAP_SETTABLE_FLAG3 (USHORT)0x0080
#define RTL_HEAP_SETTABLE_FLAGS (USHORT)0x00e0
#define RTL_HEAP_UNCOMMITTED_RANGE (USHORT)0x0100
#define RTL_HEAP_PROTECTED_ENTRY (USHORT)0x0200

typedef struct _RTL_HEAP_TAG
{
    ULONG NumberOfAllocations;
    ULONG NumberOfFrees;
    SIZE_T BytesAllocated;
    USHORT TagIndex;
    USHORT CreatorBackTraceIndex;
    WCHAR TagName[24];
} RTL_HEAP_TAG, *PRTL_HEAP_TAG;

typedef struct _RTL_HEAP_INFORMATION
{
    PVOID BaseAddress;
    ULONG Flags;
    USHORT EntryOverhead;
    USHORT CreatorBackTraceIndex;
    SIZE_T BytesAllocated;
    SIZE_T BytesCommitted;
    ULONG NumberOfTags;
    ULONG NumberOfEntries;
    ULONG NumberOfPseudoTags;
    ULONG PseudoTagGranularity;
    ULONG Reserved[5];
    PRTL_HEAP_TAG Tags;
    PRTL_HEAP_ENTRY Entries;
} RTL_HEAP_INFORMATION, *PRTL_HEAP_INFORMATION;

typedef struct _RTL_PROCESS_HEAPS
{
    ULONG NumberOfHeaps;
    RTL_HEAP_INFORMATION Heaps[1];
} RTL_PROCESS_HEAPS, *PRTL_PROCESS_HEAPS;

typedef NTSTATUS (NTAPI *PRTL_HEAP_COMMIT_ROUTINE)(
    _In_ PVOID Base,
    _Inout_ PVOID *CommitAddress,
    _Inout_ PSIZE_T CommitSize
    );

typedef struct _RTL_HEAP_PARAMETERS
{
    ULONG Length;
    SIZE_T SegmentReserve;
    SIZE_T SegmentCommit;
    SIZE_T DeCommitFreeBlockThreshold;
    SIZE_T DeCommitTotalFreeThreshold;
    SIZE_T MaximumAllocationSize;
    SIZE_T VirtualMemoryThreshold;
    SIZE_T InitialCommit;
    SIZE_T InitialReserve;
    PRTL_HEAP_COMMIT_ROUTINE CommitRoutine;
    SIZE_T Reserved[2];
} RTL_HEAP_PARAMETERS, *PRTL_HEAP_PARAMETERS;

#define HEAP_SETTABLE_USER_VALUE 0x00000100
#define HEAP_SETTABLE_USER_FLAG1 0x00000200
#define HEAP_SETTABLE_USER_FLAG2 0x00000400
#define HEAP_SETTABLE_USER_FLAG3 0x00000800
#define HEAP_SETTABLE_USER_FLAGS 0x00000e00

#define HEAP_CLASS_0 0x00000000 // Process heap
#define HEAP_CLASS_1 0x00001000 // Private heap
#define HEAP_CLASS_2 0x00002000 // Kernel heap
#define HEAP_CLASS_3 0x00003000 // GDI heap
#define HEAP_CLASS_4 0x00004000 // User heap
#define HEAP_CLASS_5 0x00005000 // Console heap
#define HEAP_CLASS_6 0x00006000 // User desktop heap
#define HEAP_CLASS_7 0x00007000 // CSR shared heap
#define HEAP_CLASS_8 0x00008000 // CSR port heap
#define HEAP_CLASS_MASK 0x0000f000

_Must_inspect_result_
NTSYSAPI
PVOID
NTAPI
RtlCreateHeap(
    _In_ ULONG Flags,
    _In_opt_ PVOID HeapBase,
    _In_opt_ SIZE_T ReserveSize,
    _In_opt_ SIZE_T CommitSize,
    _In_opt_ PVOID Lock,
    _In_opt_ PRTL_HEAP_PARAMETERS Parameters
    );

NTSYSAPI
PVOID
NTAPI
RtlDestroyHeap(
    _In_ _Post_invalid_ PVOID HeapHandle
    );

_Must_inspect_result_
_Ret_maybenull_
_Post_writable_byte_size_(Size)
NTSYSAPI
PVOID
NTAPI
RtlAllocateHeap(
    _In_ PVOID HeapHandle,
    _In_opt_ ULONG Flags,
    _In_ SIZE_T Size
    );

#if (PHNT_VERSION >= PHNT_WIN8)
_Success_(return != 0)
NTSYSAPI
LOGICAL
NTAPI
RtlFreeHeap(
    _In_ PVOID HeapHandle,
    _In_opt_ ULONG Flags,
    _Frees_ptr_opt_ PVOID BaseAddress
    );
#else
_Success_(return)
NTSYSAPI
BOOLEAN
NTAPI
RtlFreeHeap(
    _In_ PVOID HeapHandle,
    _In_opt_ ULONG Flags,
    _Frees_ptr_opt_ PVOID BaseAddress
    );
#endif

NTSYSAPI
SIZE_T
NTAPI
RtlSizeHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_ PVOID BaseAddress
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlZeroHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags
    );

NTSYSAPI
VOID
NTAPI
RtlProtectHeap(
    _In_ PVOID HeapHandle,
    _In_ BOOLEAN MakeReadOnly
    );

#define RtlProcessHeap() (NtCurrentPeb()->ProcessHeap)

NTSYSAPI
BOOLEAN
NTAPI
RtlLockHeap(
    _In_ PVOID HeapHandle
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlUnlockHeap(
    _In_ PVOID HeapHandle
    );

NTSYSAPI
PVOID
NTAPI
RtlReAllocateHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _Frees_ptr_opt_ PVOID BaseAddress,
    _In_ SIZE_T Size
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlGetUserInfoHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_ PVOID BaseAddress,
    _Out_opt_ PVOID *UserValue,
    _Out_opt_ PULONG UserFlags
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlSetUserValueHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_ PVOID BaseAddress,
    _In_ PVOID UserValue
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlSetUserFlagsHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_ PVOID BaseAddress,
    _In_ ULONG UserFlagsReset,
    _In_ ULONG UserFlagsSet
    );

typedef struct _RTL_HEAP_TAG_INFO
{
    ULONG NumberOfAllocations;
    ULONG NumberOfFrees;
    SIZE_T BytesAllocated;
} RTL_HEAP_TAG_INFO, *PRTL_HEAP_TAG_INFO;

#define RTL_HEAP_MAKE_TAG HEAP_MAKE_TAG_FLAGS

NTSYSAPI
ULONG
NTAPI
RtlCreateTagHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_opt_ PWSTR TagPrefix,
    _In_ PWSTR TagNames
    );

NTSYSAPI
PWSTR
NTAPI
RtlQueryTagHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_ USHORT TagIndex,
    _In_ BOOLEAN ResetCounters,
    _Out_opt_ PRTL_HEAP_TAG_INFO TagInfo
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlExtendHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_ PVOID Base,
    _In_ SIZE_T Size
    );

NTSYSAPI
SIZE_T
NTAPI
RtlCompactHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlValidateHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_ PVOID BaseAddress
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlValidateProcessHeaps(
    VOID
    );

NTSYSAPI
ULONG
NTAPI
RtlGetProcessHeaps(
    _In_ ULONG NumberOfHeaps,
    _Out_ PVOID *ProcessHeaps
    );

typedef NTSTATUS (NTAPI *PRTL_ENUM_HEAPS_ROUTINE)(
    _In_ PVOID HeapHandle,
    _In_ PVOID Parameter
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlEnumProcessHeaps(
    _In_ PRTL_ENUM_HEAPS_ROUTINE EnumRoutine,
    _In_ PVOID Parameter
    );

typedef struct _RTL_HEAP_USAGE_ENTRY
{
    struct _RTL_HEAP_USAGE_ENTRY *Next;
    PVOID Address;
    SIZE_T Size;
    USHORT AllocatorBackTraceIndex;
    USHORT TagIndex;
} RTL_HEAP_USAGE_ENTRY, *PRTL_HEAP_USAGE_ENTRY;

typedef struct _RTL_HEAP_USAGE
{
    ULONG Length;
    SIZE_T BytesAllocated;
    SIZE_T BytesCommitted;
    SIZE_T BytesReserved;
    SIZE_T BytesReservedMaximum;
    PRTL_HEAP_USAGE_ENTRY Entries;
    PRTL_HEAP_USAGE_ENTRY AddedEntries;
    PRTL_HEAP_USAGE_ENTRY RemovedEntries;
    ULONG_PTR Reserved[8];
} RTL_HEAP_USAGE, *PRTL_HEAP_USAGE;

#define HEAP_USAGE_ALLOCATED_BLOCKS HEAP_REALLOC_IN_PLACE_ONLY
#define HEAP_USAGE_FREE_BUFFER HEAP_ZERO_MEMORY

NTSYSAPI
NTSTATUS
NTAPI
RtlUsageHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _Inout_ PRTL_HEAP_USAGE Usage
    );

typedef struct _RTL_HEAP_WALK_ENTRY
{
    PVOID DataAddress;
    SIZE_T DataSize;
    UCHAR OverheadBytes;
    UCHAR SegmentIndex;
    USHORT Flags;
    union
    {
        struct
        {
            SIZE_T Settable;
            USHORT TagIndex;
            USHORT AllocatorBackTraceIndex;
            ULONG Reserved[2];
        } Block;
        struct
        {
            ULONG CommittedSize;
            ULONG UnCommittedSize;
            PVOID FirstEntry;
            PVOID LastEntry;
        } Segment;
    };
} RTL_HEAP_WALK_ENTRY, *PRTL_HEAP_WALK_ENTRY;

NTSYSAPI
NTSTATUS
NTAPI
RtlWalkHeap(
    _In_ PVOID HeapHandle,
    _Inout_ PRTL_HEAP_WALK_ENTRY Entry
    );

// HEAP_INFORMATION_CLASS
#define HeapCompatibilityInformation 0x0 // q; s: ULONG
#define HeapEnableTerminationOnCorruption 0x1 // q; s: NULL
#define HeapExtendedInformation 0x2 // q; s: HEAP_EXTENDED_INFORMATION
#define HeapOptimizeResources 0x3 // q; s: HEAP_OPTIMIZE_RESOURCES_INFORMATION 
#define HeapTaggingInformation 0x4
#define HeapStackDatabase 0x5
#define HeapMemoryLimit 0x6 // 19H2
#define HeapDetailedFailureInformation 0x80000001
#define HeapSetDebuggingInformation 0x80000002 // q; s: HEAP_DEBUGGING_INFORMATION

typedef enum _HEAP_COMPATIBILITY_MODE
{
    HEAP_COMPATIBILITY_STANDARD = 0UL,
    HEAP_COMPATIBILITY_LAL = 1UL,
    HEAP_COMPATIBILITY_LFH = 2UL,
} HEAP_COMPATIBILITY_MODE;

typedef struct _PROCESS_HEAP_INFORMATION
{
    ULONG_PTR ReserveSize;
    ULONG_PTR CommitSize;
    ULONG NumberOfHeaps;
    ULONG_PTR FirstHeapInformationOffset;
} PROCESS_HEAP_INFORMATION, *PPROCESS_HEAP_INFORMATION;

typedef struct _HEAP_INFORMATION
{
    ULONG_PTR Address;
    ULONG Mode;
    ULONG_PTR ReserveSize;
    ULONG_PTR CommitSize;
    ULONG_PTR FirstRegionInformationOffset;
    ULONG_PTR NextHeapInformationOffset;
} HEAP_INFORMATION, *PHEAP_INFORMATION;

typedef struct _HEAP_EXTENDED_INFORMATION
{
    HANDLE Process;
    ULONG_PTR Heap;
    ULONG Level;
    PVOID CallbackRoutine;
    PVOID CallbackContext;
    union
    {
        PROCESS_HEAP_INFORMATION ProcessHeapInformation;
        HEAP_INFORMATION HeapInformation;
    };
} HEAP_EXTENDED_INFORMATION, *PHEAP_EXTENDED_INFORMATION;

// rev
typedef NTSTATUS (NTAPI *PRTL_HEAP_LEAK_ENUMERATION_ROUTINE)(
    _In_ LONG Reserved,
    _In_ PVOID HeapHandle,
    _In_ PVOID BaseAddress,
    _In_ SIZE_T BlockSize,
    _In_ ULONG StackTraceDepth,
    _In_ PVOID *StackTrace
    );

// symbols
typedef struct _HEAP_DEBUGGING_INFORMATION
{
    PVOID InterceptorFunction;
    USHORT InterceptorValue;
    ULONG ExtendedOptions;
    ULONG StackTraceDepth;
    SIZE_T MinTotalBlockSize;
    SIZE_T MaxTotalBlockSize;
    PRTL_HEAP_LEAK_ENUMERATION_ROUTINE HeapLeakEnumerationRoutine;
} HEAP_DEBUGGING_INFORMATION, *PHEAP_DEBUGGING_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryHeapInformation(
    _In_ PVOID HeapHandle,
    _In_ HEAP_INFORMATION_CLASS HeapInformationClass,
    _Out_opt_ PVOID HeapInformation,
    _In_opt_ SIZE_T HeapInformationLength,
    _Out_opt_ PSIZE_T ReturnLength
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetHeapInformation(
    _In_ PVOID HeapHandle,
    _In_ HEAP_INFORMATION_CLASS HeapInformationClass,
    _In_opt_ PVOID HeapInformation,
    _In_opt_ SIZE_T HeapInformationLength
    );

NTSYSAPI
ULONG
NTAPI
RtlMultipleAllocateHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_ SIZE_T Size,
    _In_ ULONG Count,
    _Out_ PVOID *Array
    );

NTSYSAPI
ULONG
NTAPI
RtlMultipleFreeHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_ ULONG Count,
    _In_ PVOID *Array
    );

#if (PHNT_VERSION >= PHNT_WIN7)
NTSYSAPI
VOID
NTAPI
RtlDetectHeapLeaks(
    VOID
    );
#endif

NTSYSAPI
VOID
NTAPI
RtlFlushHeaps(
    VOID
    );

// Memory zones

// begin_private

typedef struct _RTL_MEMORY_ZONE_SEGMENT
{
    struct _RTL_MEMORY_ZONE_SEGMENT *NextSegment;
    SIZE_T Size;
    PVOID Next;
    PVOID Limit;
} RTL_MEMORY_ZONE_SEGMENT, *PRTL_MEMORY_ZONE_SEGMENT;

typedef struct _RTL_MEMORY_ZONE
{
    RTL_MEMORY_ZONE_SEGMENT Segment;
    RTL_SRWLOCK Lock;
    ULONG LockCount;
    PRTL_MEMORY_ZONE_SEGMENT FirstSegment;
} RTL_MEMORY_ZONE, *PRTL_MEMORY_ZONE;

#if (PHNT_VERSION >= PHNT_VISTA)

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateMemoryZone(
    _Out_ PVOID *MemoryZone,
    _In_ SIZE_T InitialSize,
    _Reserved_ ULONG Flags
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDestroyMemoryZone(
    _In_ _Post_invalid_ PVOID MemoryZone
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAllocateMemoryZone(
    _In_ PVOID MemoryZone,
    _In_ SIZE_T BlockSize,
    _Out_ PVOID *Block
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlResetMemoryZone(
    _In_ PVOID MemoryZone
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlLockMemoryZone(
    _In_ PVOID MemoryZone
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUnlockMemoryZone(
    _In_ PVOID MemoryZone
    );

#endif

// end_private

// Memory block lookaside lists

// begin_private

#if (PHNT_VERSION >= PHNT_VISTA)

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateMemoryBlockLookaside(
    _Out_ PVOID *MemoryBlockLookaside,
    _Reserved_ ULONG Flags,
    _In_ ULONG InitialSize,
    _In_ ULONG MinimumBlockSize,
    _In_ ULONG MaximumBlockSize
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDestroyMemoryBlockLookaside(
    _In_ PVOID MemoryBlockLookaside
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAllocateMemoryBlockLookaside(
    _In_ PVOID MemoryBlockLookaside,
    _In_ ULONG BlockSize,
    _Out_ PVOID *Block
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlFreeMemoryBlockLookaside(
    _In_ PVOID MemoryBlockLookaside,
    _In_ PVOID Block
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlExtendMemoryBlockLookaside(
    _In_ PVOID MemoryBlockLookaside,
    _In_ ULONG Increment
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlResetMemoryBlockLookaside(
    _In_ PVOID MemoryBlockLookaside
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlLockMemoryBlockLookaside(
    _In_ PVOID MemoryBlockLookaside
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUnlockMemoryBlockLookaside(
    _In_ PVOID MemoryBlockLookaside
    );

#endif

// end_private

// Transactions

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
HANDLE
NTAPI
RtlGetCurrentTransaction(
    VOID
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
LOGICAL
NTAPI
RtlSetCurrentTransaction(
    _In_ HANDLE TransactionHandle
    );
#endif

// LUIDs

FORCEINLINE BOOLEAN RtlIsEqualLuid( // RtlEqualLuid
    _In_ PLUID L1,
    _In_ PLUID L2
    )
{
    return L1->LowPart == L2->LowPart &&
        L1->HighPart == L2->HighPart;
}

FORCEINLINE BOOLEAN RtlIsZeroLuid(
    _In_ PLUID L1
    )
{
    return (L1->LowPart | L1->HighPart) == 0;
}

FORCEINLINE LUID RtlConvertLongToLuid(
    _In_ LONG Long
    )
{
    LUID tempLuid;
    LARGE_INTEGER tempLi;

    tempLi.QuadPart = Long;
    tempLuid.LowPart = tempLi.LowPart;
    tempLuid.HighPart = tempLi.HighPart;

    return tempLuid;
}

FORCEINLINE LUID RtlConvertUlongToLuid(
    _In_ ULONG Ulong
    )
{
    LUID tempLuid;

    tempLuid.LowPart = Ulong;
    tempLuid.HighPart = 0;

    return tempLuid;
}

NTSYSAPI
VOID
NTAPI
RtlCopyLuid(
    _Out_ PLUID DestinationLuid,
    _In_ PLUID SourceLuid
    );

// ros
NTSYSAPI
VOID
NTAPI
RtlCopyLuidAndAttributesArray(
    _In_ ULONG Count,
    _In_ PLUID_AND_ATTRIBUTES Src,
    _In_ PLUID_AND_ATTRIBUTES Dest
    );

// Byte swap routines.

#ifndef PHNT_RTL_BYTESWAP
#define RtlUshortByteSwap(_x) _byteswap_ushort((USHORT)(_x))
#define RtlUlongByteSwap(_x) _byteswap_ulong((_x))
#define RtlUlonglongByteSwap(_x) _byteswap_uint64((_x))
#else
NTSYSAPI
USHORT
FASTCALL
RtlUshortByteSwap(
    _In_ USHORT Source
    );

NTSYSAPI
ULONG
FASTCALL
RtlUlongByteSwap(
    _In_ ULONG Source
    );

NTSYSAPI
ULONGLONG
FASTCALL
RtlUlonglongByteSwap(
    _In_ ULONGLONG Source
    );
#endif

// Debugging

// private
typedef struct _RTL_PROCESS_VERIFIER_OPTIONS
{
    ULONG SizeStruct;
    ULONG Option;
    UCHAR OptionData[1];
} RTL_PROCESS_VERIFIER_OPTIONS, *PRTL_PROCESS_VERIFIER_OPTIONS;

// private
typedef struct _RTL_DEBUG_INFORMATION
{
    HANDLE SectionHandleClient;
    PVOID ViewBaseClient;
    PVOID ViewBaseTarget;
    ULONG_PTR ViewBaseDelta;
    HANDLE EventPairClient;
    HANDLE EventPairTarget;
    HANDLE TargetProcessId;
    HANDLE TargetThreadHandle;
    ULONG Flags;
    SIZE_T OffsetFree;
    SIZE_T CommitSize;
    SIZE_T ViewSize;
    union
    {
        struct _RTL_PROCESS_MODULES *Modules;
        struct _RTL_PROCESS_MODULE_INFORMATION_EX *ModulesEx;
    };
    struct _RTL_PROCESS_BACKTRACES *BackTraces;
    struct _RTL_PROCESS_HEAPS *Heaps;
    struct _RTL_PROCESS_LOCKS *Locks;
    PVOID SpecificHeap;
    HANDLE TargetProcessHandle;
    PRTL_PROCESS_VERIFIER_OPTIONS VerifierOptions;
    PVOID ProcessHeap;
    HANDLE CriticalSectionHandle;
    HANDLE CriticalSectionOwnerThread;
    PVOID Reserved[4];
} RTL_DEBUG_INFORMATION, *PRTL_DEBUG_INFORMATION;

NTSYSAPI
PRTL_DEBUG_INFORMATION
NTAPI
RtlCreateQueryDebugBuffer(
    _In_opt_ ULONG MaximumCommit,
    _In_ BOOLEAN UseEventPair
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDestroyQueryDebugBuffer(
    _In_ PRTL_DEBUG_INFORMATION Buffer
    );

#if (PHNT_VERSION >= PHNT_VISTA)

// private
NTSYSAPI
PVOID
NTAPI
RtlCommitDebugInfo(
    _Inout_ PRTL_DEBUG_INFORMATION Buffer,
    _In_ SIZE_T Size
    );

// private
NTSYSAPI
VOID
NTAPI
RtlDeCommitDebugInfo(
    _Inout_ PRTL_DEBUG_INFORMATION Buffer,
    _In_ PVOID p,
    _In_ SIZE_T Size
    );

#endif

#define RTL_QUERY_PROCESS_MODULES 0x00000001
#define RTL_QUERY_PROCESS_BACKTRACES 0x00000002
#define RTL_QUERY_PROCESS_HEAP_SUMMARY 0x00000004
#define RTL_QUERY_PROCESS_HEAP_TAGS 0x00000008
#define RTL_QUERY_PROCESS_HEAP_ENTRIES 0x00000010
#define RTL_QUERY_PROCESS_LOCKS 0x00000020
#define RTL_QUERY_PROCESS_MODULES32 0x00000040
#define RTL_QUERY_PROCESS_VERIFIER_OPTIONS 0x00000080 // rev
#define RTL_QUERY_PROCESS_MODULESEX 0x00000100 // rev
#define RTL_QUERY_PROCESS_HEAP_ENTRIES_EX 0x00000200 // ?
#define RTL_QUERY_PROCESS_CS_OWNER 0x00000400 // rev
#define RTL_QUERY_PROCESS_NONINVASIVE 0x80000000

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryProcessDebugInformation(
    _In_ HANDLE UniqueProcessId,
    _In_ ULONG Flags,
    _Inout_ PRTL_DEBUG_INFORMATION Buffer
    );

// Messages

NTSYSAPI
NTSTATUS
NTAPI
RtlFindMessage(
    _In_ PVOID DllHandle,
    _In_ ULONG MessageTableId,
    _In_ ULONG MessageLanguageId,
    _In_ ULONG MessageId,
    _Out_ PMESSAGE_RESOURCE_ENTRY *MessageEntry
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlFormatMessage(
    _In_ PWSTR MessageFormat,
    _In_ ULONG MaximumWidth,
    _In_ BOOLEAN IgnoreInserts,
    _In_ BOOLEAN ArgumentsAreAnsi,
    _In_ BOOLEAN ArgumentsAreAnArray,
    _In_ va_list *Arguments,
    _Out_writes_bytes_to_(Length, *ReturnLength) PWSTR Buffer,
    _In_ ULONG Length,
    _Out_opt_ PULONG ReturnLength
    );

typedef struct _PARSE_MESSAGE_CONTEXT
{
    ULONG fFlags;
    ULONG cwSavColumn;
    SIZE_T iwSrc;
    SIZE_T iwDst;
    SIZE_T iwDstSpace;
    va_list lpvArgStart;
} PARSE_MESSAGE_CONTEXT, *PPARSE_MESSAGE_CONTEXT;

#define INIT_PARSE_MESSAGE_CONTEXT(ctx) { (ctx)->fFlags = 0; }
#define TEST_PARSE_MESSAGE_CONTEXT_FLAG(ctx, flag) ((ctx)->fFlags & (flag))
#define SET_PARSE_MESSAGE_CONTEXT_FLAG(ctx, flag) ((ctx)->fFlags |= (flag))
#define CLEAR_PARSE_MESSAGE_CONTEXT_FLAG(ctx, flag) ((ctx)->fFlags &= ~(flag))

NTSYSAPI
NTSTATUS
NTAPI
RtlFormatMessageEx(
    _In_ PWSTR MessageFormat,
    _In_ ULONG MaximumWidth,
    _In_ BOOLEAN IgnoreInserts,
    _In_ BOOLEAN ArgumentsAreAnsi,
    _In_ BOOLEAN ArgumentsAreAnArray,
    _In_ va_list *Arguments,
    _Out_writes_bytes_to_(Length, *ReturnLength) PWSTR Buffer,
    _In_ ULONG Length,
    _Out_opt_ PULONG ReturnLength,
    _Out_opt_ PPARSE_MESSAGE_CONTEXT ParseContext
    );

// Errors

NTSYSAPI
ULONG
NTAPI
RtlNtStatusToDosError(
    _In_ NTSTATUS Status
    );

NTSYSAPI
ULONG
NTAPI
RtlNtStatusToDosErrorNoTeb(
    _In_ NTSTATUS Status
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGetLastNtStatus(
    VOID
    );

NTSYSAPI
LONG
NTAPI
RtlGetLastWin32Error(
    VOID
    );

NTSYSAPI
VOID
NTAPI
RtlSetLastWin32ErrorAndNtStatusFromNtStatus(
    _In_ NTSTATUS Status
    );

NTSYSAPI
VOID
NTAPI
RtlSetLastWin32Error(
    _In_ LONG Win32Error
    );

NTSYSAPI
VOID
NTAPI
RtlRestoreLastWin32Error(
    _In_ LONG Win32Error
    );

#define RTL_ERRORMODE_FAILCRITICALERRORS 0x0010
#define RTL_ERRORMODE_NOGPFAULTERRORBOX 0x0020
#define RTL_ERRORMODE_NOOPENFILEERRORBOX 0x0040

NTSYSAPI
ULONG
NTAPI
RtlGetThreadErrorMode(
    VOID
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetThreadErrorMode(
    _In_ ULONG NewMode,
    _Out_opt_ PULONG OldMode
    );

// Windows Error Reporting

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
NTSTATUS
NTAPI
RtlReportException(
    _In_ PEXCEPTION_RECORD ExceptionRecord,
    _In_ PCONTEXT ContextRecord,
    _In_ ULONG Flags
    );
#endif

#if (PHNT_VERSION >= PHNT_REDSTONE)
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlReportExceptionEx(
    _In_ PEXCEPTION_RECORD ExceptionRecord,
    _In_ PCONTEXT ContextRecord,
    _In_ ULONG Flags,
    _In_ PLARGE_INTEGER Timeout
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
NTSTATUS
NTAPI
RtlWerpReportException(
    _In_ ULONG ProcessId,
    _In_ HANDLE CrashReportSharedMem,
    _In_ ULONG Flags,
    _Out_ PHANDLE CrashVerticalProcessHandle
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN7)
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlReportSilentProcessExit(
    _In_ HANDLE ProcessHandle,
    _In_ NTSTATUS ExitStatus
    );
#endif

// Vectored Exception Handlers

NTSYSAPI
PVOID
NTAPI
RtlAddVectoredExceptionHandler(
    _In_ ULONG First,
    _In_ PVECTORED_EXCEPTION_HANDLER Handler
    );

NTSYSAPI
ULONG
NTAPI
RtlRemoveVectoredExceptionHandler(
    _In_ PVOID Handle
    );

NTSYSAPI
PVOID
NTAPI
RtlAddVectoredContinueHandler(
    _In_ ULONG First,
    _In_ PVECTORED_EXCEPTION_HANDLER Handler
    );

NTSYSAPI
ULONG
NTAPI
RtlRemoveVectoredContinueHandler(
    _In_ PVOID Handle
    );

// Random

NTSYSAPI
ULONG
NTAPI
RtlUniform(
    _Inout_ PULONG Seed
    );

_Ret_range_(<=, MAXLONG)
NTSYSAPI
ULONG
NTAPI
RtlRandom(
    _Inout_ PULONG Seed
    );

_Ret_range_(<=, MAXLONG)
NTSYSAPI
ULONG
NTAPI
RtlRandomEx(
    _Inout_ PULONG Seed
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlComputeImportTableHash(
    _In_ HANDLE FileHandle,
    _Out_writes_bytes_(16) PCHAR Hash,
    _In_ ULONG ImportTableHashRevision // must be 1
    );

// Integer conversion

NTSYSAPI
NTSTATUS
NTAPI
RtlIntegerToChar(
    _In_ ULONG Value,
    _In_opt_ ULONG Base,
    _In_ LONG OutputLength, // negative to pad to width
    _Out_ PSTR String
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlCharToInteger(
    _In_ PCSTR String,
    _In_opt_ ULONG Base,
    _Out_ PULONG Value
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlLargeIntegerToChar(
    _In_ PLARGE_INTEGER Value,
    _In_opt_ ULONG Base,
    _In_ LONG OutputLength,
    _Out_ PSTR String
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIntegerToUnicodeString(
    _In_ ULONG Value,
    _In_opt_ ULONG Base,
    _Inout_ PUNICODE_STRING String
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlInt64ToUnicodeString(
    _In_ ULONGLONG Value,
    _In_opt_ ULONG Base,
    _Inout_ PUNICODE_STRING String
    );

#ifdef _WIN64
#define RtlIntPtrToUnicodeString(Value, Base, String) RtlInt64ToUnicodeString(Value, Base, String)
#else
#define RtlIntPtrToUnicodeString(Value, Base, String) RtlIntegerToUnicodeString(Value, Base, String)
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToInteger(
    _In_ PUNICODE_STRING String,
    _In_opt_ ULONG Base,
    _Out_ PULONG Value
    );

// IPv4/6 conversion

struct in_addr;
struct in6_addr;

NTSYSAPI
PWSTR
NTAPI
RtlIpv4AddressToStringW(
    _In_ const struct in_addr *Address,
    _Out_writes_(16) PWSTR AddressString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIpv4AddressToStringExW(
    _In_ const struct in_addr *Address,
    _In_ USHORT Port,
    _Out_writes_to_(*AddressStringLength, *AddressStringLength) PWSTR AddressString,
    _Inout_ PULONG AddressStringLength
    );

NTSYSAPI
PWSTR
NTAPI
RtlIpv6AddressToStringW(
    _In_ const struct in6_addr *Address,
    _Out_writes_(46) PWSTR AddressString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIpv6AddressToStringExW(
    _In_ const struct in6_addr *Address,
    _In_ ULONG ScopeId,
    _In_ USHORT Port,
    _Out_writes_to_(*AddressStringLength, *AddressStringLength) PWSTR AddressString,
    _Inout_ PULONG AddressStringLength
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIpv4StringToAddressW(
    _In_ PCWSTR AddressString,
    _In_ BOOLEAN Strict,
    _Out_ LPCWSTR *Terminator,
    _Out_ struct in_addr *Address
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIpv4StringToAddressExW(
    _In_ PCWSTR AddressString,
    _In_ BOOLEAN Strict,
    _Out_ struct in_addr *Address,
    _Out_ PUSHORT Port
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIpv6StringToAddressW(
    _In_ PCWSTR AddressString,
    _Out_ PCWSTR *Terminator,
    _Out_ struct in6_addr *Address
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIpv6StringToAddressExW(
    _In_ PCWSTR AddressString,
    _Out_ struct in6_addr *Address,
    _Out_ PULONG ScopeId,
    _Out_ PUSHORT Port
    );

#define RtlIpv4AddressToString RtlIpv4AddressToStringW
#define RtlIpv4AddressToStringEx RtlIpv4AddressToStringExW
#define RtlIpv6AddressToString RtlIpv6AddressToStringW
#define RtlIpv6AddressToStringEx RtlIpv6AddressToStringExW
#define RtlIpv4StringToAddress RtlIpv4StringToAddressW
#define RtlIpv4StringToAddressEx RtlIpv4StringToAddressExW
#define RtlIpv6StringToAddress RtlIpv6StringToAddressW
#define RtlIpv6StringToAddressEx RtlIpv6StringToAddressExW

// Time

typedef struct _TIME_FIELDS
{
    CSHORT Year; // 1601...
    CSHORT Month; // 1..12
    CSHORT Day; // 1..31
    CSHORT Hour; // 0..23
    CSHORT Minute; // 0..59
    CSHORT Second; // 0..59
    CSHORT Milliseconds; // 0..999
    CSHORT Weekday; // 0..6 = Sunday..Saturday
} TIME_FIELDS, *PTIME_FIELDS;

NTSYSAPI
BOOLEAN
NTAPI
RtlCutoverTimeToSystemTime(
    _In_ PTIME_FIELDS CutoverTime,
    _Out_ PLARGE_INTEGER SystemTime,
    _In_ PLARGE_INTEGER CurrentSystemTime,
    _In_ BOOLEAN ThisYear
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSystemTimeToLocalTime(
    _In_ PLARGE_INTEGER SystemTime,
    _Out_ PLARGE_INTEGER LocalTime
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlLocalTimeToSystemTime(
    _In_ PLARGE_INTEGER LocalTime,
    _Out_ PLARGE_INTEGER SystemTime
    );

NTSYSAPI
VOID
NTAPI
RtlTimeToElapsedTimeFields(
    _In_ PLARGE_INTEGER Time,
    _Out_ PTIME_FIELDS TimeFields
    );

NTSYSAPI
VOID
NTAPI
RtlTimeToTimeFields(
    _In_ PLARGE_INTEGER Time,
    _Out_ PTIME_FIELDS TimeFields
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlTimeFieldsToTime(
    _In_ PTIME_FIELDS TimeFields, // Weekday is ignored
    _Out_ PLARGE_INTEGER Time
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlTimeToSecondsSince1980(
    _In_ PLARGE_INTEGER Time,
    _Out_ PULONG ElapsedSeconds
    );

NTSYSAPI
VOID
NTAPI
RtlSecondsSince1980ToTime(
    _In_ ULONG ElapsedSeconds,
    _Out_ PLARGE_INTEGER Time
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlTimeToSecondsSince1970(
    _In_ PLARGE_INTEGER Time,
    _Out_ PULONG ElapsedSeconds
    );

NTSYSAPI
VOID
NTAPI
RtlSecondsSince1970ToTime(
    _In_ ULONG ElapsedSeconds,
    _Out_ PLARGE_INTEGER Time
    );

// Time zones

typedef struct _RTL_TIME_ZONE_INFORMATION
{
    LONG Bias;
    WCHAR StandardName[32];
    TIME_FIELDS StandardStart;
    LONG StandardBias;
    WCHAR DaylightName[32];
    TIME_FIELDS DaylightStart;
    LONG DaylightBias;
} RTL_TIME_ZONE_INFORMATION, *PRTL_TIME_ZONE_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryTimeZoneInformation(
    _Out_ PRTL_TIME_ZONE_INFORMATION TimeZoneInformation
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetTimeZoneInformation(
    _In_ PRTL_TIME_ZONE_INFORMATION TimeZoneInformation
    );

// Bitmaps

typedef struct _RTL_BITMAP
{
    ULONG SizeOfBitMap;
    PULONG Buffer;
} RTL_BITMAP, *PRTL_BITMAP;

NTSYSAPI
VOID
NTAPI
RtlInitializeBitMap(
    _Out_ PRTL_BITMAP BitMapHeader,
    _In_ PULONG BitMapBuffer,
    _In_ ULONG SizeOfBitMap
    );

#if (PHNT_MODE == PHNT_MODE_KERNEL || PHNT_VERSION >= PHNT_WIN8)
NTSYSAPI
VOID
NTAPI
RtlClearBit(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_range_(<, BitMapHeader->SizeOfBitMap) ULONG BitNumber
    );
#endif

#if (PHNT_MODE == PHNT_MODE_KERNEL || PHNT_VERSION >= PHNT_WIN8)
NTSYSAPI
VOID
NTAPI
RtlSetBit(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_range_(<, BitMapHeader->SizeOfBitMap) ULONG BitNumber
    );
#endif

_Check_return_
NTSYSAPI
BOOLEAN
NTAPI
RtlTestBit(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_range_(<, BitMapHeader->SizeOfBitMap) ULONG BitNumber
    );

NTSYSAPI
VOID
NTAPI
RtlClearAllBits(
    _In_ PRTL_BITMAP BitMapHeader
    );

NTSYSAPI
VOID
NTAPI
RtlSetAllBits(
    _In_ PRTL_BITMAP BitMapHeader
    );

_Success_(return != -1)
_Check_return_
NTSYSAPI
ULONG
NTAPI
RtlFindClearBits(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_ ULONG NumberToFind,
    _In_ ULONG HintIndex
    );

_Success_(return != -1)
_Check_return_
NTSYSAPI
ULONG
NTAPI
RtlFindSetBits(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_ ULONG NumberToFind,
    _In_ ULONG HintIndex
    );

_Success_(return != -1)
NTSYSAPI
ULONG
NTAPI
RtlFindClearBitsAndSet(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_ ULONG NumberToFind,
    _In_ ULONG HintIndex
    );

_Success_(return != -1)
NTSYSAPI
ULONG
NTAPI
RtlFindSetBitsAndClear(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_ ULONG NumberToFind,
    _In_ ULONG HintIndex
    );

NTSYSAPI
VOID
NTAPI
RtlClearBits(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_range_(0, BitMapHeader->SizeOfBitMap - NumberToClear) ULONG StartingIndex,
    _In_range_(0, BitMapHeader->SizeOfBitMap - StartingIndex) ULONG NumberToClear
    );

NTSYSAPI
VOID
NTAPI
RtlSetBits(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_range_(0, BitMapHeader->SizeOfBitMap - NumberToSet) ULONG StartingIndex,
    _In_range_(0, BitMapHeader->SizeOfBitMap - StartingIndex) ULONG NumberToSet
    );

NTSYSAPI
CCHAR
NTAPI
RtlFindMostSignificantBit(
    _In_ ULONGLONG Set
    );

NTSYSAPI
CCHAR
NTAPI
RtlFindLeastSignificantBit(
    _In_ ULONGLONG Set
    );

typedef struct _RTL_BITMAP_RUN
{
    ULONG StartingIndex;
    ULONG NumberOfBits;
} RTL_BITMAP_RUN, *PRTL_BITMAP_RUN;

NTSYSAPI
ULONG
NTAPI
RtlFindClearRuns(
    _In_ PRTL_BITMAP BitMapHeader,
    _Out_writes_to_(SizeOfRunArray, return) PRTL_BITMAP_RUN RunArray,
    _In_range_(>, 0) ULONG SizeOfRunArray,
    _In_ BOOLEAN LocateLongestRuns
    );

NTSYSAPI
ULONG
NTAPI
RtlFindLongestRunClear(
    _In_ PRTL_BITMAP BitMapHeader,
    _Out_ PULONG StartingIndex
    );

NTSYSAPI
ULONG
NTAPI
RtlFindFirstRunClear(
    _In_ PRTL_BITMAP BitMapHeader,
    _Out_ PULONG StartingIndex
    );

_Check_return_
FORCEINLINE
BOOLEAN
RtlCheckBit(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_range_(<, BitMapHeader->SizeOfBitMap) ULONG BitPosition
    )
{
#ifdef _WIN64
    return BitTest64((LONG64 const *)BitMapHeader->Buffer, (LONG64)BitPosition);
#else
    return (((PLONG)BitMapHeader->Buffer)[BitPosition / 32] >> (BitPosition % 32)) & 0x1;
#endif
}

NTSYSAPI
ULONG
NTAPI
RtlNumberOfClearBits(
    _In_ PRTL_BITMAP BitMapHeader
    );

NTSYSAPI
ULONG
NTAPI
RtlNumberOfSetBits(
    _In_ PRTL_BITMAP BitMapHeader
    );

_Check_return_
NTSYSAPI
BOOLEAN
NTAPI
RtlAreBitsClear(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_ ULONG StartingIndex,
    _In_ ULONG Length
    );

_Check_return_
NTSYSAPI
BOOLEAN
NTAPI
RtlAreBitsSet(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_ ULONG StartingIndex,
    _In_ ULONG Length
    );

NTSYSAPI
ULONG
NTAPI
RtlFindNextForwardRunClear(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_ ULONG FromIndex,
    _Out_ PULONG StartingRunIndex
    );

NTSYSAPI
ULONG
NTAPI
RtlFindLastBackwardRunClear(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_ ULONG FromIndex,
    _Out_ PULONG StartingRunIndex
    );

#if (PHNT_VERSION >= PHNT_VISTA)

NTSYSAPI
ULONG
NTAPI
RtlNumberOfSetBitsUlongPtr(
    _In_ ULONG_PTR Target
    );

#endif

#if (PHNT_VERSION >= PHNT_WIN7)

// rev
NTSYSAPI
VOID
NTAPI
RtlInterlockedClearBitRun(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_range_(0, BitMapHeader->SizeOfBitMap - NumberToClear) ULONG StartingIndex,
    _In_range_(0, BitMapHeader->SizeOfBitMap - StartingIndex) ULONG NumberToClear
    );

// rev
NTSYSAPI
VOID
NTAPI
RtlInterlockedSetBitRun(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_range_(0, BitMapHeader->SizeOfBitMap - NumberToSet) ULONG StartingIndex,
    _In_range_(0, BitMapHeader->SizeOfBitMap - StartingIndex) ULONG NumberToSet
    );

#endif

#if (PHNT_VERSION >= PHNT_WIN8)

NTSYSAPI
VOID
NTAPI
RtlCopyBitMap(
    _In_ PRTL_BITMAP Source,
    _In_ PRTL_BITMAP Destination,
    _In_range_(0, Destination->SizeOfBitMap - 1) ULONG TargetBit
    );

NTSYSAPI
VOID
NTAPI
RtlExtractBitMap(
    _In_ PRTL_BITMAP Source,
    _In_ PRTL_BITMAP Destination,
    _In_range_(0, Source->SizeOfBitMap - 1) ULONG TargetBit,
    _In_range_(0, Source->SizeOfBitMap) ULONG NumberOfBits
    );

NTSYSAPI
ULONG
NTAPI
RtlNumberOfClearBitsInRange(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_ ULONG StartingIndex,
    _In_ ULONG Length
    );

NTSYSAPI
ULONG
NTAPI
RtlNumberOfSetBitsInRange(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_ ULONG StartingIndex,
    _In_ ULONG Length
    );

#endif


#if (PHNT_VERSION >= PHNT_THRESHOLD)

// private
typedef struct _RTL_BITMAP_EX
{
    ULONG64 SizeOfBitMap;
    PULONG64 Buffer;
} RTL_BITMAP_EX, *PRTL_BITMAP_EX;

// rev
NTSYSAPI
VOID
NTAPI
RtlInitializeBitMapEx(
    _Out_ PRTL_BITMAP_EX BitMapHeader,
    _In_ PULONG64 BitMapBuffer,
    _In_ ULONG64 SizeOfBitMap
    );

// rev
_Check_return_
NTSYSAPI
BOOLEAN
NTAPI
RtlTestBitEx(
    _In_ PRTL_BITMAP_EX BitMapHeader,
    _In_range_(<, BitMapHeader->SizeOfBitMap) ULONG64 BitNumber
    );

#if (PHNT_MODE == PHNT_MODE_KERNEL)
// rev
NTSYSAPI
VOID
NTAPI
RtlClearAllBitsEx(
    _In_ PRTL_BITMAP_EX BitMapHeader
    );

// rev
NTSYSAPI
VOID
NTAPI
RtlClearBitEx(
    _In_ PRTL_BITMAP_EX BitMapHeader,
    _In_range_(<, BitMapHeader->SizeOfBitMap) ULONG64 BitNumber
    );

// rev
NTSYSAPI
VOID
NTAPI
RtlSetBitEx(
    _In_ PRTL_BITMAP_EX BitMapHeader,
    _In_range_(<, BitMapHeader->SizeOfBitMap) ULONG64 BitNumber
    );

// rev
NTSYSAPI
ULONG64
NTAPI
RtlFindSetBitsEx(
    _In_ PRTL_BITMAP_EX BitMapHeader,
    _In_ ULONG64 NumberToFind,
    _In_ ULONG64 HintIndex
    );

NTSYSAPI
ULONG64
NTAPI
RtlFindSetBitsAndClearEx(
    _In_ PRTL_BITMAP_EX BitMapHeader,
    _In_ ULONG64 NumberToFind,
    _In_ ULONG64 HintIndex
    );
#endif

#endif

// Handle tables

typedef struct _RTL_HANDLE_TABLE_ENTRY
{
    union
    {
        ULONG Flags; // allocated entries have the low bit set
        struct _RTL_HANDLE_TABLE_ENTRY *NextFree;
    };
} RTL_HANDLE_TABLE_ENTRY, *PRTL_HANDLE_TABLE_ENTRY;

#define RTL_HANDLE_ALLOCATED (USHORT)0x0001

typedef struct _RTL_HANDLE_TABLE
{
    ULONG MaximumNumberOfHandles;
    ULONG SizeOfHandleTableEntry;
    ULONG Reserved[2];
    PRTL_HANDLE_TABLE_ENTRY FreeHandles;
    PRTL_HANDLE_TABLE_ENTRY CommittedHandles;
    PRTL_HANDLE_TABLE_ENTRY UnCommittedHandles;
    PRTL_HANDLE_TABLE_ENTRY MaxReservedHandles;
} RTL_HANDLE_TABLE, *PRTL_HANDLE_TABLE;

NTSYSAPI
VOID
NTAPI
RtlInitializeHandleTable(
    _In_ ULONG MaximumNumberOfHandles,
    _In_ ULONG SizeOfHandleTableEntry,
    _Out_ PRTL_HANDLE_TABLE HandleTable
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDestroyHandleTable(
    _Inout_ PRTL_HANDLE_TABLE HandleTable
    );

NTSYSAPI
PRTL_HANDLE_TABLE_ENTRY
NTAPI
RtlAllocateHandle(
    _In_ PRTL_HANDLE_TABLE HandleTable,
    _Out_opt_ PULONG HandleIndex
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlFreeHandle(
    _In_ PRTL_HANDLE_TABLE HandleTable,
    _In_ PRTL_HANDLE_TABLE_ENTRY Handle
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlIsValidHandle(
    _In_ PRTL_HANDLE_TABLE HandleTable,
    _In_ PRTL_HANDLE_TABLE_ENTRY Handle
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlIsValidIndexHandle(
    _In_ PRTL_HANDLE_TABLE HandleTable,
    _In_ ULONG HandleIndex,
    _Out_ PRTL_HANDLE_TABLE_ENTRY *Handle
    );

// Atom tables

#define RTL_ATOM_MAXIMUM_INTEGER_ATOM (RTL_ATOM)0xc000
#define RTL_ATOM_INVALID_ATOM (RTL_ATOM)0x0000
#define RTL_ATOM_TABLE_DEFAULT_NUMBER_OF_BUCKETS 37
#define RTL_ATOM_MAXIMUM_NAME_LENGTH 255
#define RTL_ATOM_PINNED 0x01

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateAtomTable(
    _In_ ULONG NumberOfBuckets,
    _Out_ PVOID *AtomTableHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDestroyAtomTable(
    _In_ _Post_invalid_ PVOID AtomTableHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlEmptyAtomTable(
    _In_ PVOID AtomTableHandle,
    _In_ BOOLEAN IncludePinnedAtoms
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAtomToAtomTable(
    _In_ PVOID AtomTableHandle,
    _In_ PWSTR AtomName,
    _Inout_opt_ PRTL_ATOM Atom
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlLookupAtomInAtomTable(
    _In_ PVOID AtomTableHandle,
    _In_ PWSTR AtomName,
    _Out_opt_ PRTL_ATOM Atom
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteAtomFromAtomTable(
    _In_ PVOID AtomTableHandle,
    _In_ RTL_ATOM Atom
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlPinAtomInAtomTable(
    _In_ PVOID AtomTableHandle,
    _In_ RTL_ATOM Atom
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryAtomInAtomTable(
    _In_ PVOID AtomTableHandle,
    _In_ RTL_ATOM Atom,
    _Out_opt_ PULONG AtomUsage,
    _Out_opt_ PULONG AtomFlags,
    _Inout_updates_bytes_to_opt_(*AtomNameLength, *AtomNameLength) PWSTR AtomName,
    _Inout_opt_ PULONG AtomNameLength
    );

#if (PHNT_VERSION >= PHNT_VISTA)
// rev
NTSYSAPI
BOOLEAN
NTAPI
RtlGetIntegerAtom(
    _In_ PWSTR AtomName,
    _Out_opt_ PUSHORT IntegerAtom
    );
#endif

// SIDs

_Must_inspect_result_
NTSYSAPI
BOOLEAN
NTAPI
RtlValidSid(
    _In_ PSID Sid
    );

_Must_inspect_result_
NTSYSAPI
BOOLEAN
NTAPI
RtlEqualSid(
    _In_ PSID Sid1,
    _In_ PSID Sid2
    );

_Must_inspect_result_
NTSYSAPI
BOOLEAN
NTAPI
RtlEqualPrefixSid(
    _In_ PSID Sid1,
    _In_ PSID Sid2
    );

NTSYSAPI
ULONG
NTAPI
RtlLengthRequiredSid(
    _In_ ULONG SubAuthorityCount
    );

NTSYSAPI
PVOID
NTAPI
RtlFreeSid(
    _In_ _Post_invalid_ PSID Sid
    );

_Must_inspect_result_
NTSYSAPI
NTSTATUS
NTAPI
RtlAllocateAndInitializeSid(
    _In_ PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    _In_ UCHAR SubAuthorityCount,
    _In_ ULONG SubAuthority0,
    _In_ ULONG SubAuthority1,
    _In_ ULONG SubAuthority2,
    _In_ ULONG SubAuthority3,
    _In_ ULONG SubAuthority4,
    _In_ ULONG SubAuthority5,
    _In_ ULONG SubAuthority6,
    _In_ ULONG SubAuthority7,
    _Outptr_ PSID *Sid
    );

#if (PHNT_VERSION >= PHNT_WIN8)
_Must_inspect_result_
NTSYSAPI
NTSTATUS
NTAPI
RtlAllocateAndInitializeSidEx(
    _In_ PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    _In_ UCHAR SubAuthorityCount,
    _In_reads_(SubAuthorityCount) PULONG SubAuthorities,
    _Outptr_ PSID *Sid
    );
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlInitializeSid(
    _Out_ PSID Sid,
    _In_ PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    _In_ UCHAR SubAuthorityCount
    );

#if (PHNT_VERSION >= PHNT_THRESHOLD)
NTSYSAPI
NTSTATUS
NTAPI
RtlInitializeSidEx(
    _Out_writes_bytes_(SECURITY_SID_SIZE(SubAuthorityCount)) PSID Sid,
    _In_ PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    _In_ UCHAR SubAuthorityCount,
    ...
    );
#endif

NTSYSAPI
PSID_IDENTIFIER_AUTHORITY
NTAPI
RtlIdentifierAuthoritySid(
    _In_ PSID Sid
    );

NTSYSAPI
PULONG
NTAPI
RtlSubAuthoritySid(
    _In_ PSID Sid,
    _In_ ULONG SubAuthority
    );

NTSYSAPI
PUCHAR
NTAPI
RtlSubAuthorityCountSid(
    _In_ PSID Sid
    );

NTSYSAPI
ULONG
NTAPI
RtlLengthSid(
    _In_ PSID Sid
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlCopySid(
    _In_ ULONG DestinationSidLength,
    _Out_writes_bytes_(DestinationSidLength) PSID DestinationSid,
    _In_ PSID SourceSid
    );

// ros
NTSYSAPI
NTSTATUS
NTAPI
RtlCopySidAndAttributesArray(
    _In_ ULONG Count,
    _In_ PSID_AND_ATTRIBUTES Src,
    _In_ ULONG SidAreaSize,
    _In_ PSID_AND_ATTRIBUTES Dest,
    _In_ PSID SidArea,
    _Out_ PSID *RemainingSidArea,
    _Out_ PULONG RemainingSidAreaSize
    );

#if (PHNT_VERSION >= PHNT_VISTA)

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateServiceSid(
    _In_ PUNICODE_STRING ServiceName,
    _Out_writes_bytes_opt_(*ServiceSidLength) PSID ServiceSid,
    _Inout_ PULONG ServiceSidLength
    );

#endif

#if (PHNT_VERSION >= PHNT_VISTA)

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlSidDominates(
    _In_ PSID Sid1,
    _In_ PSID Sid2,
    _Out_ PBOOLEAN Dominates
    );

#endif

#if (PHNT_VERSION >= PHNT_WINBLUE)

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlSidDominatesForTrust(
    _In_ PSID Sid1,
    _In_ PSID Sid2,
    _Out_ PBOOLEAN DominatesTrust // TokenProcessTrustLevel
    );

#endif

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
NTSTATUS
NTAPI
RtlSidEqualLevel(
    _In_ PSID Sid1,
    _In_ PSID Sid2,
    _Out_ PBOOLEAN EqualLevel
    );

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlSidIsHigherLevel(
    _In_ PSID Sid1,
    _In_ PSID Sid2,
    _Out_ PBOOLEAN HigherLevel
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN7)
NTSYSAPI
NTSTATUS
NTAPI
RtlCreateVirtualAccountSid(
    _In_ PUNICODE_STRING Name,
    _In_ ULONG BaseSubAuthority,
    _Out_writes_bytes_(*SidLength) PSID Sid,
    _Inout_ PULONG SidLength
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN7)
NTSYSAPI
NTSTATUS
NTAPI
RtlReplaceSidInSd(
    _Inout_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ PSID OldSid,
    _In_ PSID NewSid,
    _Out_ ULONG *NumChanges
    );
#endif

#define MAX_UNICODE_STACK_BUFFER_LENGTH 256

NTSYSAPI
NTSTATUS
NTAPI
RtlLengthSidAsUnicodeString(
    _In_ PSID Sid,
    _Out_ PULONG StringLength
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlConvertSidToUnicodeString(
    _Inout_ PUNICODE_STRING UnicodeString,
    _In_ PSID Sid,
    _In_ BOOLEAN AllocateDestinationString
    );

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
NTSTATUS
NTAPI
RtlSidHashInitialize(
    _In_reads_(SidCount) PSID_AND_ATTRIBUTES SidAttr,
    _In_ ULONG SidCount,
    _Out_ PSID_AND_ATTRIBUTES_HASH SidAttrHash
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
PSID_AND_ATTRIBUTES
NTAPI
RtlSidHashLookup(
    _In_ PSID_AND_ATTRIBUTES_HASH SidAttrHash,
    _In_ PSID Sid
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
// rev
NTSYSAPI
BOOLEAN
NTAPI
RtlIsElevatedRid(
    _In_ PSID_AND_ATTRIBUTES SidAttr
    );
#endif

#if (PHNT_VERSION >= PHNT_REDSTONE2)
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlDeriveCapabilitySidsFromName(
    _Inout_ PUNICODE_STRING UnicodeString,
    _Out_ PSID CapabilityGroupSid,
    _Out_ PSID CapabilitySid
    );
#endif

// Security Descriptors

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateSecurityDescriptor(
    _Out_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ ULONG Revision
    );

_Check_return_
NTSYSAPI
BOOLEAN
NTAPI
RtlValidSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor
    );

NTSYSAPI
ULONG
NTAPI
RtlLengthSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor
    );

_Check_return_
NTSYSAPI
BOOLEAN
NTAPI
RtlValidRelativeSecurityDescriptor(
    _In_reads_bytes_(SecurityDescriptorLength) PSECURITY_DESCRIPTOR SecurityDescriptorInput,
    _In_ ULONG SecurityDescriptorLength,
    _In_ SECURITY_INFORMATION RequiredInformation
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGetControlSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Out_ PSECURITY_DESCRIPTOR_CONTROL Control,
    _Out_ PULONG Revision
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetControlSecurityDescriptor(
     _Inout_ PSECURITY_DESCRIPTOR SecurityDescriptor,
     _In_ SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
     _In_ SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet
     );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetAttributesSecurityDescriptor(
    _Inout_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ SECURITY_DESCRIPTOR_CONTROL Control,
    _Out_ PULONG Revision
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlGetSecurityDescriptorRMControl(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Out_ PUCHAR RMControl
    );

NTSYSAPI
VOID
NTAPI
RtlSetSecurityDescriptorRMControl(
    _Inout_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PUCHAR RMControl
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetDaclSecurityDescriptor(
    _Inout_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ BOOLEAN DaclPresent,
    _In_opt_ PACL Dacl,
    _In_opt_ BOOLEAN DaclDefaulted
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGetDaclSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Out_ PBOOLEAN DaclPresent,
    _Outptr_result_maybenull_ PACL *Dacl,
    _Out_ PBOOLEAN DaclDefaulted
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetSaclSecurityDescriptor(
    _Inout_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ BOOLEAN SaclPresent,
    _In_opt_ PACL Sacl,
    _In_opt_ BOOLEAN SaclDefaulted
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGetSaclSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Out_ PBOOLEAN SaclPresent,
    _Out_ PACL *Sacl,
    _Out_ PBOOLEAN SaclDefaulted
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetOwnerSecurityDescriptor(
    _Inout_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PSID Owner,
    _In_ BOOLEAN OwnerDefaulted
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGetOwnerSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Outptr_result_maybenull_ PSID *Owner,
    _Out_ PBOOLEAN OwnerDefaulted
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetGroupSecurityDescriptor(
    _Inout_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PSID Group,
    _In_ BOOLEAN GroupDefaulted
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGetGroupSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Outptr_result_maybenull_ PSID *Group,
    _Out_ PBOOLEAN GroupDefaulted
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlMakeSelfRelativeSD(
    _In_ PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    _Out_writes_bytes_(*BufferLength) PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    _Inout_ PULONG BufferLength
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAbsoluteToSelfRelativeSD(
    _In_ PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    _Out_writes_bytes_to_opt_(*BufferLength, *BufferLength) PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    _Inout_ PULONG BufferLength
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSelfRelativeToAbsoluteSD(
    _In_ PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    _Out_writes_bytes_to_opt_(*AbsoluteSecurityDescriptorSize, *AbsoluteSecurityDescriptorSize) PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    _Inout_ PULONG AbsoluteSecurityDescriptorSize,
    _Out_writes_bytes_to_opt_(*DaclSize, *DaclSize) PACL Dacl,
    _Inout_ PULONG DaclSize,
    _Out_writes_bytes_to_opt_(*SaclSize, *SaclSize) PACL Sacl,
    _Inout_ PULONG SaclSize,
    _Out_writes_bytes_to_opt_(*OwnerSize, *OwnerSize) PSID Owner,
    _Inout_ PULONG OwnerSize,
    _Out_writes_bytes_to_opt_(*PrimaryGroupSize, *PrimaryGroupSize) PSID PrimaryGroup,
    _Inout_ PULONG PrimaryGroupSize
    );

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlSelfRelativeToAbsoluteSD2(
    _Inout_ PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
    _Inout_ PULONG pBufferSize
    );

// Access masks

NTSYSAPI
BOOLEAN
NTAPI
RtlAreAllAccessesGranted(
    _In_ ACCESS_MASK GrantedAccess,
    _In_ ACCESS_MASK DesiredAccess
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlAreAnyAccessesGranted(
    _In_ ACCESS_MASK GrantedAccess,
    _In_ ACCESS_MASK DesiredAccess
    );

NTSYSAPI
VOID
NTAPI
RtlMapGenericMask(
    _Inout_ PACCESS_MASK AccessMask,
    _In_ PGENERIC_MAPPING GenericMapping
    );

// ACLs

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateAcl(
    _Out_writes_bytes_(AclLength) PACL Acl,
    _In_ ULONG AclLength,
    _In_ ULONG AclRevision
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlValidAcl(
    _In_ PACL Acl
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryInformationAcl(
    _In_ PACL Acl,
    _Out_writes_bytes_(AclInformationLength) PVOID AclInformation,
    _In_ ULONG AclInformationLength,
    _In_ ACL_INFORMATION_CLASS AclInformationClass
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetInformationAcl(
    _Inout_ PACL Acl,
    _In_reads_bytes_(AclInformationLength) PVOID AclInformation,
    _In_ ULONG AclInformationLength,
    _In_ ACL_INFORMATION_CLASS AclInformationClass
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG StartingAceIndex,
    _In_reads_bytes_(AceListLength) PVOID AceList,
    _In_ ULONG AceListLength
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceIndex
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGetAce(
    _In_ PACL Acl,
    _In_ ULONG AceIndex,
    _Outptr_ PVOID *Ace
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlFirstFreeAce(
    _In_ PACL Acl,
    _Out_ PVOID *FirstFree
    );

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
PVOID
NTAPI
RtlFindAceByType(
    _In_ PACL pAcl,
    _In_ UCHAR AceType,
    _Out_opt_ PULONG pIndex
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
BOOLEAN
NTAPI
RtlOwnerAcesPresent(
    _In_ PACL pAcl
    );
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessAllowedAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessAllowedAceEx(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessDeniedAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessDeniedAceEx(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAuditAccessAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid,
    _In_ BOOLEAN AuditSuccess,
    _In_ BOOLEAN AuditFailure
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAuditAccessAceEx(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid,
    _In_ BOOLEAN AuditSuccess,
    _In_ BOOLEAN AuditFailure
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessAllowedObjectAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_opt_ PGUID ObjectTypeGuid,
    _In_opt_ PGUID InheritedObjectTypeGuid,
    _In_ PSID Sid
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessDeniedObjectAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_opt_ PGUID ObjectTypeGuid,
    _In_opt_ PGUID InheritedObjectTypeGuid,
    _In_ PSID Sid
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAuditAccessObjectAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_opt_ PGUID ObjectTypeGuid,
    _In_opt_ PGUID InheritedObjectTypeGuid,
    _In_ PSID Sid,
    _In_ BOOLEAN AuditSuccess,
    _In_ BOOLEAN AuditFailure
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAddCompoundAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ UCHAR AceType,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID ServerSid,
    _In_ PSID ClientSid
    );

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
NTSTATUS
NTAPI
RtlAddMandatoryAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ PSID Sid,
    _In_ UCHAR AceType,
    _In_ ACCESS_MASK AccessMask
    );
#endif

// Named pipes

NTSYSAPI
NTSTATUS
NTAPI
RtlDefaultNpAcl(
    _Out_ PACL *Acl
    );

// Security objects

NTSYSAPI
NTSTATUS
NTAPI
RtlNewSecurityObject(
    _In_opt_ PSECURITY_DESCRIPTOR ParentDescriptor,
    _In_opt_ PSECURITY_DESCRIPTOR CreatorDescriptor,
    _Out_ PSECURITY_DESCRIPTOR *NewDescriptor,
    _In_ BOOLEAN IsDirectoryObject,
    _In_opt_ HANDLE Token,
    _In_ PGENERIC_MAPPING GenericMapping
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlNewSecurityObjectEx(
    _In_opt_ PSECURITY_DESCRIPTOR ParentDescriptor,
    _In_opt_ PSECURITY_DESCRIPTOR CreatorDescriptor,
    _Out_ PSECURITY_DESCRIPTOR *NewDescriptor,
    _In_opt_ GUID *ObjectType,
    _In_ BOOLEAN IsDirectoryObject,
    _In_ ULONG AutoInheritFlags, // SEF_*
    _In_opt_ HANDLE Token,
    _In_ PGENERIC_MAPPING GenericMapping
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlNewSecurityObjectWithMultipleInheritance(
    _In_opt_ PSECURITY_DESCRIPTOR ParentDescriptor,
    _In_opt_ PSECURITY_DESCRIPTOR CreatorDescriptor,
    _Out_ PSECURITY_DESCRIPTOR *NewDescriptor,
    _In_opt_ GUID **ObjectType,
    _In_ ULONG GuidCount,
    _In_ BOOLEAN IsDirectoryObject,
    _In_ ULONG AutoInheritFlags, // SEF_*
    _In_opt_ HANDLE Token,
    _In_ PGENERIC_MAPPING GenericMapping
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteSecurityObject(
    _Inout_ PSECURITY_DESCRIPTOR *ObjectDescriptor
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlQuerySecurityObject(
     _In_ PSECURITY_DESCRIPTOR ObjectDescriptor,
     _In_ SECURITY_INFORMATION SecurityInformation,
     _Out_opt_ PSECURITY_DESCRIPTOR ResultantDescriptor,
     _In_ ULONG DescriptorLength,
     _Out_ PULONG ReturnLength
     );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetSecurityObject(
    _In_ SECURITY_INFORMATION SecurityInformation,
    _In_ PSECURITY_DESCRIPTOR ModificationDescriptor,
    _Inout_ PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    _In_ PGENERIC_MAPPING GenericMapping,
    _In_opt_ HANDLE Token
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetSecurityObjectEx(
    _In_ SECURITY_INFORMATION SecurityInformation,
    _In_ PSECURITY_DESCRIPTOR ModificationDescriptor,
    _Inout_ PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    _In_ ULONG AutoInheritFlags, // SEF_*
    _In_ PGENERIC_MAPPING GenericMapping,
    _In_opt_ HANDLE Token
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlConvertToAutoInheritSecurityObject(
    _In_opt_ PSECURITY_DESCRIPTOR ParentDescriptor,
    _In_ PSECURITY_DESCRIPTOR CurrentSecurityDescriptor,
    _Out_ PSECURITY_DESCRIPTOR *NewSecurityDescriptor,
    _In_opt_ GUID *ObjectType,
    _In_ BOOLEAN IsDirectoryObject,
    _In_ PGENERIC_MAPPING GenericMapping
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlNewInstanceSecurityObject(
    _In_ BOOLEAN ParentDescriptorChanged,
    _In_ BOOLEAN CreatorDescriptorChanged,
    _In_ PLUID OldClientTokenModifiedId,
    _Out_ PLUID NewClientTokenModifiedId,
    _In_opt_ PSECURITY_DESCRIPTOR ParentDescriptor,
    _In_opt_ PSECURITY_DESCRIPTOR CreatorDescriptor,
    _Out_ PSECURITY_DESCRIPTOR *NewDescriptor,
    _In_ BOOLEAN IsDirectoryObject,
    _In_ HANDLE Token,
    _In_ PGENERIC_MAPPING GenericMapping
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlCopySecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR InputSecurityDescriptor,
    _Out_ PSECURITY_DESCRIPTOR *OutputSecurityDescriptor
    );

// Misc. security

NTSYSAPI
VOID
NTAPI
RtlRunEncodeUnicodeString(
    _Inout_ PUCHAR Seed,
    _In_ PUNICODE_STRING String
    );

NTSYSAPI
VOID
NTAPI
RtlRunDecodeUnicodeString(
    _In_ UCHAR Seed,
    _In_ PUNICODE_STRING String
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlImpersonateSelf(
    _In_ SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    );

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
NTSTATUS
NTAPI
RtlImpersonateSelfEx(
    _In_ SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    _In_opt_ ACCESS_MASK AdditionalAccess,
    _Out_opt_ PHANDLE ThreadToken
    );
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlAdjustPrivilege(
    _In_ ULONG Privilege,
    _In_ BOOLEAN Enable,
    _In_ BOOLEAN Client,
    _Out_ PBOOLEAN WasEnabled
    );

#define RTL_ACQUIRE_PRIVILEGE_REVERT 0x00000001
#define RTL_ACQUIRE_PRIVILEGE_PROCESS 0x00000002

NTSYSAPI
NTSTATUS
NTAPI
RtlAcquirePrivilege(
    _In_ PULONG Privilege,
    _In_ ULONG NumPriv,
    _In_ ULONG Flags,
    _Out_ PVOID *ReturnedState
    );

NTSYSAPI
VOID
NTAPI
RtlReleasePrivilege(
    _In_ PVOID StatePointer
    );

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSAPI
NTSTATUS
NTAPI
RtlRemovePrivileges(
    _In_ HANDLE TokenHandle,
    _In_ PULONG PrivilegesToKeep,
    _In_ ULONG PrivilegeCount
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN8)

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlIsUntrustedObject(
    _In_opt_ HANDLE Handle,
    _In_opt_ PVOID Object,
    _Out_ PBOOLEAN IsUntrustedObject
    );

NTSYSAPI
ULONG
NTAPI
RtlQueryValidationRunlevel(
    _In_opt_ PUNICODE_STRING ComponentName
    );

#endif

// Private namespaces

#if (PHNT_VERSION >= PHNT_VISTA)

// begin_private

NTSYSAPI
PVOID
NTAPI
RtlCreateBoundaryDescriptor(
    _In_ PUNICODE_STRING Name,
    _In_ ULONG Flags
    );

NTSYSAPI
VOID
NTAPI
RtlDeleteBoundaryDescriptor(
    _In_ PVOID BoundaryDescriptor
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAddSIDToBoundaryDescriptor(
    _Inout_ PVOID *BoundaryDescriptor,
    _In_ PSID RequiredSid
    );

#if (PHNT_VERSION >= PHNT_WIN7)
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlAddIntegrityLabelToBoundaryDescriptor(
    _Inout_ PVOID *BoundaryDescriptor,
    _In_ PSID IntegrityLabel
    );
#endif

// end_private

#endif

// Version

NTSYSAPI
NTSTATUS
NTAPI
RtlGetVersion(
    _Out_ PRTL_OSVERSIONINFOEXW VersionInformation // PRTL_OSVERSIONINFOW
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlVerifyVersionInfo(
    _In_ PRTL_OSVERSIONINFOEXW VersionInformation, // PRTL_OSVERSIONINFOW
    _In_ ULONG TypeMask,
    _In_ ULONGLONG ConditionMask
    );

// rev
NTSYSAPI
VOID
NTAPI
RtlGetNtVersionNumbers(
    _Out_opt_ PULONG NtMajorVersion,
    _Out_opt_ PULONG NtMinorVersion,
    _Out_opt_ PULONG NtBuildNumber
    );

// System information

// rev
NTSYSAPI
ULONG
NTAPI
RtlGetNtGlobalFlags(
    VOID
    );

#if (PHNT_VERSION >= PHNT_REDSTONE)
// rev
NTSYSAPI
BOOLEAN
NTAPI
RtlGetNtProductType(
    _Out_ PNT_PRODUCT_TYPE NtProductType
    );
#endif

#if (PHNT_VERSION >= PHNT_REDSTONE2)
// private
NTSYSAPI
ULONG
NTAPI
RtlGetSuiteMask(
    VOID
    );
#endif

// Thread pool (old)

NTSYSAPI
NTSTATUS
NTAPI
RtlRegisterWait(
    _Out_ PHANDLE WaitHandle,
    _In_ HANDLE Handle,
    _In_ WAITORTIMERCALLBACKFUNC Function,
    _In_ PVOID Context,
    _In_ ULONG Milliseconds,
    _In_ ULONG Flags
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDeregisterWait(
    _In_ HANDLE WaitHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDeregisterWaitEx(
    _In_ HANDLE WaitHandle,
    _In_ HANDLE Event
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlQueueWorkItem(
    _In_ WORKERCALLBACKFUNC Function,
    _In_ PVOID Context,
    _In_ ULONG Flags
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetIoCompletionCallback(
    _In_ HANDLE FileHandle,
    _In_ APC_CALLBACK_FUNCTION CompletionProc,
    _In_ ULONG Flags
    );

typedef NTSTATUS (NTAPI *PRTL_START_POOL_THREAD)(
    _In_ PTHREAD_START_ROUTINE Function,
    _In_ PVOID Parameter,
    _Out_ PHANDLE ThreadHandle
    );

typedef NTSTATUS (NTAPI *PRTL_EXIT_POOL_THREAD)(
    _In_ NTSTATUS ExitStatus
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetThreadPoolStartFunc(
    _In_ PRTL_START_POOL_THREAD StartPoolThread,
    _In_ PRTL_EXIT_POOL_THREAD ExitPoolThread
    );

NTSYSAPI
VOID
NTAPI
RtlUserThreadStart(
    _In_ PTHREAD_START_ROUTINE Function,
    _In_ PVOID Parameter
    );

NTSYSAPI
VOID
NTAPI
LdrInitializeThunk(
    _In_ PCONTEXT ContextRecord,
    _In_ PVOID Parameter
    );

// Timer support

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateTimerQueue(
    _Out_ PHANDLE TimerQueueHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateTimer(
    _In_ HANDLE TimerQueueHandle,
    _Out_ PHANDLE Handle,
    _In_ WAITORTIMERCALLBACKFUNC Function,
    _In_opt_ PVOID Context,
    _In_ ULONG DueTime,
    _In_ ULONG Period,
    _In_ ULONG Flags
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUpdateTimer(
    _In_ HANDLE TimerQueueHandle,
    _In_ HANDLE TimerHandle,
    _In_ ULONG DueTime,
    _In_ ULONG Period
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteTimer(
    _In_ HANDLE TimerQueueHandle,
    _In_ HANDLE TimerToCancel,
    _In_opt_ HANDLE Event
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteTimerQueue(
    _In_ HANDLE TimerQueueHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteTimerQueueEx(
    _In_ HANDLE TimerQueueHandle,
    _In_ HANDLE Event
    );

// Registry access

NTSYSAPI
NTSTATUS
NTAPI
RtlFormatCurrentUserKeyPath(
    _Out_ PUNICODE_STRING CurrentUserKeyPath
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlOpenCurrentUser(
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE CurrentUserKey
    );

#define RTL_REGISTRY_ABSOLUTE 0
#define RTL_REGISTRY_SERVICES 1 // \Registry\Machine\System\CurrentControlSet\Services
#define RTL_REGISTRY_CONTROL 2 // \Registry\Machine\System\CurrentControlSet\Control
#define RTL_REGISTRY_WINDOWS_NT 3 // \Registry\Machine\Software\Microsoft\Windows NT\CurrentVersion
#define RTL_REGISTRY_DEVICEMAP 4 // \Registry\Machine\Hardware\DeviceMap
#define RTL_REGISTRY_USER 5 // \Registry\User\CurrentUser
#define RTL_REGISTRY_MAXIMUM 6
#define RTL_REGISTRY_HANDLE 0x40000000
#define RTL_REGISTRY_OPTIONAL 0x80000000

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateRegistryKey(
    _In_ ULONG RelativeTo,
    _In_ PWSTR Path
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlCheckRegistryKey(
    _In_ ULONG RelativeTo,
    _In_ PWSTR Path
    );

typedef NTSTATUS (NTAPI *PRTL_QUERY_REGISTRY_ROUTINE)(
    _In_ PWSTR ValueName,
    _In_ ULONG ValueType,
    _In_ PVOID ValueData,
    _In_ ULONG ValueLength,
    _In_ PVOID Context,
    _In_ PVOID EntryContext
    );

typedef struct _RTL_QUERY_REGISTRY_TABLE
{
    PRTL_QUERY_REGISTRY_ROUTINE QueryRoutine;
    ULONG Flags;
    PWSTR Name;
    PVOID EntryContext;
    ULONG DefaultType;
    PVOID DefaultData;
    ULONG DefaultLength;
} RTL_QUERY_REGISTRY_TABLE, *PRTL_QUERY_REGISTRY_TABLE;

#define RTL_QUERY_REGISTRY_SUBKEY 0x00000001
#define RTL_QUERY_REGISTRY_TOPKEY 0x00000002
#define RTL_QUERY_REGISTRY_REQUIRED 0x00000004
#define RTL_QUERY_REGISTRY_NOVALUE 0x00000008
#define RTL_QUERY_REGISTRY_NOEXPAND 0x00000010
#define RTL_QUERY_REGISTRY_DIRECT 0x00000020
#define RTL_QUERY_REGISTRY_DELETE 0x00000040

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryRegistryValues(
    _In_ ULONG RelativeTo,
    _In_ PCWSTR Path,
    _In_ PRTL_QUERY_REGISTRY_TABLE QueryTable,
    _In_ PVOID Context,
    _In_opt_ PVOID Environment
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlQueryRegistryValuesEx(
    _In_ ULONG RelativeTo,
    _In_ PCWSTR Path,
    _In_ PRTL_QUERY_REGISTRY_TABLE QueryTable,
    _In_ PVOID Context,
    _In_opt_ PVOID Environment
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlWriteRegistryValue(
    _In_ ULONG RelativeTo,
    _In_ PCWSTR Path,
    _In_ PCWSTR ValueName,
    _In_ ULONG ValueType,
    _In_ PVOID ValueData,
    _In_ ULONG ValueLength
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteRegistryValue(
    _In_ ULONG RelativeTo,
    _In_ PCWSTR Path,
    _In_ PCWSTR ValueName
    );

// Thread profiling

#if (PHNT_VERSION >= PHNT_WIN7)

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlEnableThreadProfiling(
    _In_ HANDLE ThreadHandle,
    _In_ ULONG Flags,
    _In_ ULONG64 HardwareCounters,
    _Out_ PVOID *PerformanceDataHandle
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlDisableThreadProfiling(
    _In_ PVOID PerformanceDataHandle
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlQueryThreadProfiling(
    _In_ HANDLE ThreadHandle,
    _Out_ PBOOLEAN Enabled
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlReadThreadProfilingData(
    _In_ HANDLE PerformanceDataHandle,
    _In_ ULONG Flags,
    _Out_ PPERFORMANCE_DATA PerformanceData
    );

#endif

// WOW64

NTSYSAPI
NTSTATUS
NTAPI
RtlGetNativeSystemInformation(
    _In_ ULONG SystemInformationClass,
    _In_ PVOID NativeSystemInformation,
    _In_ ULONG InformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlQueueApcWow64Thread(
    _In_ HANDLE ThreadHandle,
    _In_ PPS_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcArgument1,
    _In_opt_ PVOID ApcArgument2,
    _In_opt_ PVOID ApcArgument3
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlWow64EnableFsRedirection(
    _In_ BOOLEAN Wow64FsEnableRedirection
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlWow64EnableFsRedirectionEx(
    _In_ PVOID Wow64FsEnableRedirection,
    _Out_ PVOID *OldFsRedirectionLevel
    );

// Misc.

NTSYSAPI
ULONG32
NTAPI
RtlComputeCrc32(
    _In_ ULONG32 PartialCrc,
    _In_ PVOID Buffer,
    _In_ ULONG Length
    );

NTSYSAPI
PVOID
NTAPI
RtlEncodePointer(
    _In_ PVOID Ptr
    );

NTSYSAPI
PVOID
NTAPI
RtlDecodePointer(
    _In_ PVOID Ptr
    );

NTSYSAPI
PVOID
NTAPI
RtlEncodeSystemPointer(
    _In_ PVOID Ptr
    );

NTSYSAPI
PVOID
NTAPI
RtlDecodeSystemPointer(
    _In_ PVOID Ptr
    );

#if (PHNT_VERSION >= PHNT_THRESHOLD)
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlEncodeRemotePointer(
    _In_ HANDLE ProcessHandle,
    _In_ PVOID Pointer,
    _Out_ PVOID *EncodedPointer
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlDecodeRemotePointer(
    _In_ HANDLE ProcessHandle,
    _In_ PVOID Pointer,
    _Out_ PVOID *DecodedPointer
    );
#endif

// rev
NTSYSAPI
BOOLEAN
NTAPI
RtlIsProcessorFeaturePresent(
    _In_ ULONG ProcessorFeature
    );

// rev
NTSYSAPI
ULONG
NTAPI
RtlGetCurrentProcessorNumber(
    VOID
    );

#if (PHNT_VERSION >= PHNT_THRESHOLD)

// rev
NTSYSAPI
VOID
NTAPI
RtlGetCurrentProcessorNumberEx(
    _Out_ PPROCESSOR_NUMBER ProcessorNumber
    );

#endif

// Stack support

NTSYSAPI
VOID
NTAPI
RtlPushFrame(
    _In_ PTEB_ACTIVE_FRAME Frame
    );

NTSYSAPI
VOID
NTAPI
RtlPopFrame(
    _In_ PTEB_ACTIVE_FRAME Frame
    );

NTSYSAPI
PTEB_ACTIVE_FRAME
NTAPI
RtlGetFrame(
    VOID
    );

#define RTL_WALK_USER_MODE_STACK 0x00000001
#define RTL_WALK_VALID_FLAGS 0x00000001
#define RTL_STACK_WALKING_MODE_FRAMES_TO_SKIP_SHIFT 0x00000008

// private
NTSYSAPI
ULONG
NTAPI
RtlWalkFrameChain(
    _Out_writes_(Count - (Flags >> RTL_STACK_WALKING_MODE_FRAMES_TO_SKIP_SHIFT)) PVOID *Callers,
    _In_ ULONG Count,
    _In_ ULONG Flags
    );

// rev
NTSYSAPI
VOID
NTAPI
RtlGetCallersAddress( // Use the intrinsic _ReturnAddress instead.
    _Out_ PVOID *CallersAddress,
    _Out_ PVOID *CallersCaller
    );

#if (PHNT_VERSION >= PHNT_WIN7)

NTSYSAPI
ULONG64
NTAPI
RtlGetEnabledExtendedFeatures(
    _In_ ULONG64 FeatureMask
    );

#endif

#if (PHNT_VERSION >= PHNT_REDSTONE4)

// msdn
NTSYSAPI
ULONG64
NTAPI
RtlGetEnabledExtendedAndSupervisorFeatures(
    _In_ ULONG64 FeatureMask
    );

// msdn
_Ret_maybenull_
_Success_(return != NULL)
NTSYSAPI
PVOID
NTAPI
RtlLocateSupervisorFeature(
    _In_ PXSAVE_AREA_HEADER XStateHeader,
    _In_range_(XSTATE_AVX, MAXIMUM_XSTATE_FEATURES - 1) ULONG FeatureId,
    _Out_opt_ PULONG Length
    );

#endif

// private
typedef union _RTL_ELEVATION_FLAGS
{
    ULONG Flags;
    struct
    {
        ULONG ElevationEnabled : 1;
        ULONG VirtualizationEnabled : 1;
        ULONG InstallerDetectEnabled : 1;
        ULONG ReservedBits : 29;
    };
} RTL_ELEVATION_FLAGS, *PRTL_ELEVATION_FLAGS;

#if (PHNT_VERSION >= PHNT_VISTA)

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlQueryElevationFlags(
    _Out_ PRTL_ELEVATION_FLAGS Flags
    );

#endif

#if (PHNT_VERSION >= PHNT_VISTA)

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlRegisterThreadWithCsrss(
    VOID
    );

#endif

#if (PHNT_VERSION >= PHNT_VISTA)

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlLockCurrentThread(
    VOID
    );

#endif

#if (PHNT_VERSION >= PHNT_VISTA)

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlUnlockCurrentThread(
    VOID
    );

#endif

#if (PHNT_VERSION >= PHNT_VISTA)

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlLockModuleSection(
    _In_ PVOID Address
    );

#endif

#if (PHNT_VERSION >= PHNT_VISTA)

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlUnlockModuleSection(
    _In_ PVOID Address
    );

#endif

// begin_msdn:"Winternl"

#define RTL_UNLOAD_EVENT_TRACE_NUMBER 64

// private
typedef struct _RTL_UNLOAD_EVENT_TRACE
{
    PVOID BaseAddress;
    SIZE_T SizeOfImage;
    ULONG Sequence;
    ULONG TimeDateStamp;
    ULONG CheckSum;
    WCHAR ImageName[32];
    ULONG Version[2];
} RTL_UNLOAD_EVENT_TRACE, *PRTL_UNLOAD_EVENT_TRACE;

typedef struct _RTL_UNLOAD_EVENT_TRACE32 
{
    ULONG BaseAddress;
    ULONG SizeOfImage;
    ULONG Sequence;
    ULONG TimeDateStamp;
    ULONG CheckSum;
    WCHAR ImageName[32];
    ULONG Version[2];
} RTL_UNLOAD_EVENT_TRACE32, *PRTL_UNLOAD_EVENT_TRACE32;

NTSYSAPI
PRTL_UNLOAD_EVENT_TRACE
NTAPI
RtlGetUnloadEventTrace(
    VOID
    );

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSAPI
VOID
NTAPI
RtlGetUnloadEventTraceEx(
    _Out_ PULONG *ElementSize,
    _Out_ PULONG *ElementCount,
    _Out_ PVOID *EventTrace // works across all processes
    );
#endif

// end_msdn

#if (PHNT_VERSION >= PHNT_WIN7)
// rev
NTSYSAPI
LOGICAL
NTAPI
RtlQueryPerformanceCounter(
    _Out_ PLARGE_INTEGER PerformanceCounter
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN7)
// rev
NTSYSAPI
LOGICAL
NTAPI
RtlQueryPerformanceFrequency(
    _Out_ PLARGE_INTEGER PerformanceFrequency
    );
#endif

// Image Mitigation

// rev
typedef enum _IMAGE_MITIGATION_POLICY
{
    ImageDepPolicy, // RTL_IMAGE_MITIGATION_DEP_POLICY
    ImageAslrPolicy, // RTL_IMAGE_MITIGATION_ASLR_POLICY
    ImageDynamicCodePolicy, // RTL_IMAGE_MITIGATION_DYNAMIC_CODE_POLICY
    ImageStrictHandleCheckPolicy, // RTL_IMAGE_MITIGATION_STRICT_HANDLE_CHECK_POLICY
    ImageSystemCallDisablePolicy, // RTL_IMAGE_MITIGATION_SYSTEM_CALL_DISABLE_POLICY
    ImageMitigationOptionsMask,
    ImageExtensionPointDisablePolicy, // RTL_IMAGE_MITIGATION_EXTENSION_POINT_DISABLE_POLICY
    ImageControlFlowGuardPolicy, // RTL_IMAGE_MITIGATION_CONTROL_FLOW_GUARD_POLICY
    ImageSignaturePolicy, // RTL_IMAGE_MITIGATION_BINARY_SIGNATURE_POLICY
    ImageFontDisablePolicy, // RTL_IMAGE_MITIGATION_FONT_DISABLE_POLICY
    ImageImageLoadPolicy, // RTL_IMAGE_MITIGATION_IMAGE_LOAD_POLICY
    ImagePayloadRestrictionPolicy, // RTL_IMAGE_MITIGATION_PAYLOAD_RESTRICTION_POLICY
    ImageChildProcessPolicy, // RTL_IMAGE_MITIGATION_CHILD_PROCESS_POLICY
    ImageSehopPolicy, // RTL_IMAGE_MITIGATION_SEHOP_POLICY
    ImageHeapPolicy, // RTL_IMAGE_MITIGATION_HEAP_POLICY
    MaxImageMitigationPolicy
} IMAGE_MITIGATION_POLICY;

// rev
typedef union _RTL_IMAGE_MITIGATION_POLICY
{
    struct
    {
        ULONG64 AuditState : 2;
        ULONG64 AuditFlag : 1;
        ULONG64 EnableAdditionalAuditingOption : 1;
        ULONG64 Reserved : 60;
    };
    struct
    {
        ULONG64 PolicyState : 2;
        ULONG64 AlwaysInherit : 1;
        ULONG64 EnableAdditionalPolicyOption : 1;
        ULONG64 AuditReserved : 60;
    };
} RTL_IMAGE_MITIGATION_POLICY, *PRTL_IMAGE_MITIGATION_POLICY;

// rev
typedef struct _RTL_IMAGE_MITIGATION_DEP_POLICY
{
    RTL_IMAGE_MITIGATION_POLICY Dep;
} RTL_IMAGE_MITIGATION_DEP_POLICY, *PRTL_IMAGE_MITIGATION_DEP_POLICY;

// rev
typedef struct _RTL_IMAGE_MITIGATION_ASLR_POLICY
{
    RTL_IMAGE_MITIGATION_POLICY ForceRelocateImages;
    RTL_IMAGE_MITIGATION_POLICY BottomUpRandomization;
    RTL_IMAGE_MITIGATION_POLICY HighEntropyRandomization;
} RTL_IMAGE_MITIGATION_ASLR_POLICY, *PRTL_IMAGE_MITIGATION_ASLR_POLICY;

// rev
typedef struct _RTL_IMAGE_MITIGATION_DYNAMIC_CODE_POLICY
{
    RTL_IMAGE_MITIGATION_POLICY BlockDynamicCode;
} RTL_IMAGE_MITIGATION_DYNAMIC_CODE_POLICY, *PRTL_IMAGE_MITIGATION_DYNAMIC_CODE_POLICY;

// rev
typedef struct _RTL_IMAGE_MITIGATION_STRICT_HANDLE_CHECK_POLICY
{
    RTL_IMAGE_MITIGATION_POLICY StrictHandleChecks;
} RTL_IMAGE_MITIGATION_STRICT_HANDLE_CHECK_POLICY, *PRTL_IMAGE_MITIGATION_STRICT_HANDLE_CHECK_POLICY;

// rev
typedef struct _RTL_IMAGE_MITIGATION_SYSTEM_CALL_DISABLE_POLICY
{
    RTL_IMAGE_MITIGATION_POLICY BlockWin32kSystemCalls;
} RTL_IMAGE_MITIGATION_SYSTEM_CALL_DISABLE_POLICY, *PRTL_IMAGE_MITIGATION_SYSTEM_CALL_DISABLE_POLICY;

// rev
typedef struct _RTL_IMAGE_MITIGATION_EXTENSION_POINT_DISABLE_POLICY
{
    RTL_IMAGE_MITIGATION_POLICY DisableExtensionPoints;
} RTL_IMAGE_MITIGATION_EXTENSION_POINT_DISABLE_POLICY, *PRTL_IMAGE_MITIGATION_EXTENSION_POINT_DISABLE_POLICY;

// rev
typedef struct _RTL_IMAGE_MITIGATION_CONTROL_FLOW_GUARD_POLICY
{
    RTL_IMAGE_MITIGATION_POLICY ControlFlowGuard;
    RTL_IMAGE_MITIGATION_POLICY StrictControlFlowGuard;
} RTL_IMAGE_MITIGATION_CONTROL_FLOW_GUARD_POLICY, *PRTL_IMAGE_MITIGATION_CONTROL_FLOW_GUARD_POLICY;

// rev
typedef struct _RTL_IMAGE_MITIGATION_BINARY_SIGNATURE_POLICY
{
    RTL_IMAGE_MITIGATION_POLICY BlockNonMicrosoftSignedBinaries;
    RTL_IMAGE_MITIGATION_POLICY EnforceSigningOnModuleDependencies;
} RTL_IMAGE_MITIGATION_BINARY_SIGNATURE_POLICY, *PRTL_IMAGE_MITIGATION_BINARY_SIGNATURE_POLICY;

// rev
typedef struct _RTL_IMAGE_MITIGATION_FONT_DISABLE_POLICY
{
    RTL_IMAGE_MITIGATION_POLICY DisableNonSystemFonts;
} RTL_IMAGE_MITIGATION_FONT_DISABLE_POLICY, *PRTL_IMAGE_MITIGATION_FONT_DISABLE_POLICY;

// rev
typedef struct _RTL_IMAGE_MITIGATION_IMAGE_LOAD_POLICY
{
    RTL_IMAGE_MITIGATION_POLICY BlockRemoteImageLoads;
    RTL_IMAGE_MITIGATION_POLICY BlockLowLabelImageLoads;
    RTL_IMAGE_MITIGATION_POLICY PreferSystem32;
} RTL_IMAGE_MITIGATION_IMAGE_LOAD_POLICY, *PRTL_IMAGE_MITIGATION_IMAGE_LOAD_POLICY;

// rev
typedef struct _RTL_IMAGE_MITIGATION_PAYLOAD_RESTRICTION_POLICY
{
    RTL_IMAGE_MITIGATION_POLICY EnableExportAddressFilter;
    RTL_IMAGE_MITIGATION_POLICY EnableExportAddressFilterPlus;
    RTL_IMAGE_MITIGATION_POLICY EnableImportAddressFilter;
    RTL_IMAGE_MITIGATION_POLICY EnableRopStackPivot;
    RTL_IMAGE_MITIGATION_POLICY EnableRopCallerCheck;
    RTL_IMAGE_MITIGATION_POLICY EnableRopSimExec;
    WCHAR EafPlusModuleList[512]; // 19H1
} RTL_IMAGE_MITIGATION_PAYLOAD_RESTRICTION_POLICY, *PRTL_IMAGE_MITIGATION_PAYLOAD_RESTRICTION_POLICY;

// rev
typedef struct _RTL_IMAGE_MITIGATION_CHILD_PROCESS_POLICY
{
    RTL_IMAGE_MITIGATION_POLICY DisallowChildProcessCreation;
} RTL_IMAGE_MITIGATION_CHILD_PROCESS_POLICY, *PRTL_IMAGE_MITIGATION_CHILD_PROCESS_POLICY;

// rev
typedef struct _RTL_IMAGE_MITIGATION_SEHOP_POLICY
{
    RTL_IMAGE_MITIGATION_POLICY Sehop;
} RTL_IMAGE_MITIGATION_SEHOP_POLICY, *PRTL_IMAGE_MITIGATION_SEHOP_POLICY;

// rev
typedef struct _RTL_IMAGE_MITIGATION_HEAP_POLICY
{
    RTL_IMAGE_MITIGATION_POLICY TerminateOnHeapErrors;
} RTL_IMAGE_MITIGATION_HEAP_POLICY, *PRTL_IMAGE_MITIGATION_HEAP_POLICY;

typedef enum _RTL_IMAGE_MITIGATION_OPTION_STATE
{
    RtlMitigationOptionStateNotConfigured,
    RtlMitigationOptionStateOn,
    RtlMitigationOptionStateOff
} RTL_IMAGE_MITIGATION_OPTION_STATE;

// rev from PROCESS_MITIGATION_FLAGS
#define RTL_IMAGE_MITIGATION_FLAG_RESET 0x1
#define RTL_IMAGE_MITIGATION_FLAG_REMOVE 0x2
#define RTL_IMAGE_MITIGATION_FLAG_OSDEFAULT 0x4
#define RTL_IMAGE_MITIGATION_FLAG_AUDIT 0x8

#if (PHNT_VERSION >= PHNT_REDSTONE3)

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlQueryImageMitigationPolicy(
    _In_opt_ PWSTR ImagePath, // NULL for system-wide defaults
    _In_ IMAGE_MITIGATION_POLICY Policy,
    _In_ ULONG Flags,
    _Inout_ PVOID Buffer,
    _In_ ULONG BufferSize
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlSetImageMitigationPolicy(
    _In_opt_ PWSTR ImagePath, // NULL for system-wide defaults
    _In_ IMAGE_MITIGATION_POLICY Policy,
    _In_ ULONG Flags,
    _Inout_ PVOID Buffer,
    _In_ ULONG BufferSize
    );

#endif

// session 

// rev
NTSYSAPI
ULONG
NTAPI
RtlGetCurrentServiceSessionId(
    VOID
    );

// private
NTSYSAPI
ULONG
NTAPI
RtlGetActiveConsoleId(
    VOID
    );

#if (PHNT_VERSION >= PHNT_REDSTONE)
// private
NTSYSAPI
ULONGLONG
NTAPI
RtlGetConsoleSessionForegroundProcessId(
    VOID
    );
#endif

// Appcontainer

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlGetTokenNamedObjectPath(
    _In_ HANDLE Token, 
    _In_opt_ PSID Sid, 
    _Out_ PUNICODE_STRING ObjectPath // RtlFreeUnicodeString
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlGetAppContainerNamedObjectPath(
    _In_opt_ HANDLE Token,
    _In_opt_ PSID AppContainerSid,
    _In_ BOOLEAN RelativePath,
    _Out_ PUNICODE_STRING ObjectPath // RtlFreeUnicodeString
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlGetAppContainerParent(
    _In_ PSID AppContainerSid, 
    _Out_ PSID* AppContainerSidParent // RtlFreeSid
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlCheckSandboxedToken(
    _In_opt_ HANDLE TokenHandle,
    _Out_ PBOOLEAN IsSandboxed
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlCheckTokenCapability(
    _In_opt_ HANDLE TokenHandle,
    _In_ PSID CapabilitySidToCheck,
    _Out_ PBOOLEAN HasCapability
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlCapabilityCheck(
    _In_opt_ HANDLE TokenHandle,
    _In_ PUNICODE_STRING CapabilityName,
    _Out_ PBOOLEAN HasCapability
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlCheckTokenMembership(
    _In_opt_ HANDLE TokenHandle,
    _In_ PSID SidToCheck,
    _Out_ PBOOLEAN IsMember
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlCheckTokenMembershipEx(
    _In_opt_ HANDLE TokenHandle,
    _In_ PSID SidToCheck,
    _In_ ULONG Flags, // CTMF_VALID_FLAGS
    _Out_ PBOOLEAN IsMember
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlQueryTokenHostIdAsUlong64(
    _In_ HANDLE TokenHandle,
    _Out_ PULONG64 HostId // (WIN://PKGHOSTID)
    );

// rev
NTSYSAPI
BOOLEAN
NTAPI
RtlIsParentOfChildAppContainer(
    _In_ PSID ParentAppContainerSid,
    _In_ PSID ChildAppContainerSid
    );

// rev
NTSYSAPI
BOOLEAN
NTAPI
RtlIsCapabilitySid(
    _In_ PSID Sid
    );

// rev
NTSYSAPI
BOOLEAN
NTAPI
RtlIsPackageSid(
    _In_ PSID Sid
    );

// rev
NTSYSAPI
BOOLEAN
NTAPI
RtlIsValidProcessTrustLabelSid(
    _In_ PSID Sid
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlIsStateSeparationEnabled(
    VOID
    );

typedef enum _APPCONTAINER_SID_TYPE
{
    NotAppContainerSidType,
    ChildAppContainerSidType,
    ParentAppContainerSidType,
    InvalidAppContainerSidType,
    MaxAppContainerSidType
} APPCONTAINER_SID_TYPE, *PAPPCONTAINER_SID_TYPE;

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlGetAppContainerSidType(
    _In_ PSID AppContainerSid,
    _Out_ PAPPCONTAINER_SID_TYPE AppContainerSidType
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlFlsAlloc(
    _In_ PFLS_CALLBACK_FUNCTION Callback,
    _Out_ PULONG FlsIndex
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlFlsFree(
    _In_ ULONG FlsIndex
    );

typedef enum _STATE_LOCATION_TYPE 
{
    LocationTypeRegistry,
    LocationTypeFileSystem,
    LocationTypeMaximum
} STATE_LOCATION_TYPE;

// private
NTSYSAPI
NTSTATUS
NTAPI
RtlGetPersistedStateLocation(
    _In_ PCWSTR SourceID,
    _In_opt_ PCWSTR CustomValue,
    _In_opt_ PCWSTR DefaultPath,
    _In_ STATE_LOCATION_TYPE StateLocationType,
    _Out_writes_bytes_to_opt_(BufferLengthIn, *BufferLengthOut) PWCHAR TargetPath,
    _In_ ULONG BufferLengthIn,
    _Out_opt_ PULONG BufferLengthOut
    );

// msdn
NTSYSAPI
BOOLEAN
NTAPI
RtlIsCloudFilesPlaceholder(
    _In_ ULONG FileAttributes,
    _In_ ULONG ReparseTag
    );

// msdn
NTSYSAPI
BOOLEAN
NTAPI
RtlIsPartialPlaceholder(
    _In_ ULONG FileAttributes,
    _In_ ULONG ReparseTag
    );

// msdn
NTSYSAPI
NTSTATUS
NTAPI
RtlIsPartialPlaceholderFileHandle(
    _In_ HANDLE FileHandle,
    _Out_ PBOOLEAN IsPartialPlaceholder
    );

// msdn
NTSYSAPI
NTSTATUS
NTAPI
RtlIsPartialPlaceholderFileInfo(
    _In_ PVOID InfoBuffer,
    _In_ FILE_INFORMATION_CLASS InfoClass,
    _Out_ PBOOLEAN IsPartialPlaceholder
    );

#if (PHNT_VERSION >= PHNT_REDSTONE3)

#undef PHCM_MAX
#define PHCM_APPLICATION_DEFAULT ((CHAR)0)
#define PHCM_DISGUISE_PLACEHOLDERS ((CHAR)1)
#define PHCM_EXPOSE_PLACEHOLDERS ((CHAR)2)
#define PHCM_MAX ((CHAR)2)

#define PHCM_ERROR_INVALID_PARAMETER ((CHAR)-1)
#define PHCM_ERROR_NO_TEB ((CHAR)-2)

NTSYSAPI
CHAR
NTAPI
RtlQueryThreadPlaceholderCompatibilityMode(
    VOID
    );

NTSYSAPI
CHAR
NTAPI
RtlSetThreadPlaceholderCompatibilityMode(
    _In_ CHAR Mode
    );

#endif

#if (PHNT_VERSION >= PHNT_REDSTONE4)

#undef PHCM_MAX
#define PHCM_DISGUISE_FULL_PLACEHOLDERS ((CHAR)3)
#define PHCM_MAX ((CHAR)3)
#define PHCM_ERROR_NO_PEB ((CHAR)-3)

NTSYSAPI
CHAR
NTAPI
RtlQueryProcessPlaceholderCompatibilityMode(
    VOID
    );

NTSYSAPI
CHAR
NTAPI
RtlSetProcessPlaceholderCompatibilityMode(
    _In_ CHAR Mode
    );

#endif

// rev
NTSYSAPI
BOOLEAN
NTAPI
RtlIsNonEmptyDirectoryReparsePointAllowed(
    _In_ ULONG ReparseTag
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlAppxIsFileOwnedByTrustedInstaller(
    _In_ HANDLE FileHandle, 
    _Out_ PBOOLEAN IsFileOwnedByTrustedInstaller
    );

// rev
typedef struct _PS_PKG_CLAIM
{
    ULONGLONG Flags;
    ULONGLONG Origin;
} PS_PKG_CLAIM, *PPS_PKG_CLAIM;

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryPackageClaims(
    _In_ HANDLE TokenHandle,
    _Out_writes_bytes_to_opt_(*PackageSize, *PackageSize) PWSTR PackageFullName,
    _Inout_opt_ PSIZE_T PackageSize,
    _Out_writes_bytes_to_opt_(*AppIdSize, *AppIdSize) PWSTR AppId,
    _Inout_opt_ PSIZE_T AppIdSize,
    _Out_opt_ PGUID DynamicId,
    _Out_opt_ PPS_PKG_CLAIM PkgClaim,
    _Out_opt_ PULONG64 AttributesPresent
    );

// Protected policies

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlQueryProtectedPolicy(
    _In_ PGUID PolicyGuid,
    _Out_ PULONG_PTR PolicyValue
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlSetProtectedPolicy(
    _In_ PGUID PolicyGuid,
    _In_ ULONG_PTR PolicyValue,
    _Out_ PULONG_PTR OldPolicyValue
    );

#if (PHNT_VERSION >= PHNT_REDSTONE)
// private
NTSYSAPI
BOOLEAN
NTAPI
RtlIsMultiSessionSku(
    VOID
    );
#endif

#if (PHNT_VERSION >= PHNT_REDSTONE)
// private
NTSYSAPI
BOOLEAN
NTAPI
RtlIsMultiUsersInSessionSku(
    VOID
    );
#endif

// private
typedef enum _RTL_BSD_ITEM_TYPE
{
    RtlBsdItemVersionNumber, // q; s: ULONG
    RtlBsdItemProductType, // q; s: NT_PRODUCT_TYPE (ULONG)
    RtlBsdItemAabEnabled, // q: s: BOOLEAN
    RtlBsdItemAabTimeout, // q: s: UCHAR
    RtlBsdItemBootGood, // q: s: BOOLEAN
    RtlBsdItemBootShutdown, // q: s: BOOLEAN
    RtlBsdSleepInProgress, // q: s: BOOLEAN
    RtlBsdPowerTransition,
    RtlBsdItemBootAttemptCount, // q: s: UCHAR
    RtlBsdItemBootCheckpoint, // q: s: UCHAR
    RtlBsdItemBootId, // q; s: ULONG (USER_SHARED_DATA->BootId)
    RtlBsdItemShutdownBootId, // q; s: ULONG
    RtlBsdItemReportedAbnormalShutdownBootId, // q; s: ULONG
    RtlBsdItemErrorInfo,
    RtlBsdItemPowerButtonPressInfo,
    RtlBsdItemChecksum, // q: s: UCHAR
    RtlBsdPowerTransitionExtension,
    RtlBsdItemFeatureConfigurationState, // q; s: ULONG
    RtlBsdItemMax
} RTL_BSD_ITEM_TYPE;

// private
typedef struct _RTL_BSD_ITEM
{
    RTL_BSD_ITEM_TYPE Type;
    PVOID DataBuffer;
    ULONG DataLength;
} RTL_BSD_ITEM, *PRTL_BSD_ITEM;

// ros
NTSYSAPI
NTSTATUS
NTAPI
RtlCreateBootStatusDataFile(
    VOID
    );

// ros
NTSYSAPI
NTSTATUS
NTAPI
RtlLockBootStatusData(
    _Out_ PHANDLE FileHandle
    );

// ros
NTSYSAPI
NTSTATUS
NTAPI
RtlUnlockBootStatusData(
    _In_ HANDLE FileHandle
    );

// ros
NTSYSAPI
NTSTATUS
NTAPI
RtlGetSetBootStatusData(
    _In_ HANDLE FileHandle,
    _In_ BOOLEAN Read,
    _In_ RTL_BSD_ITEM_TYPE DataClass,
    _In_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG ReturnLength
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlCheckBootStatusIntegrity(
    _In_ HANDLE FileHandle, 
    _Out_ PBOOLEAN Verified
    );

#if (PHNT_VERSION >= PHNT_REDSTONE3)
// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlGetSystemBootStatus(
    _In_ RTL_BSD_ITEM_TYPE BootStatusInformationClass,
    _Out_ PVOID DataBuffer,
    _In_ ULONG DataLength,
    _Out_opt_ PULONG ReturnLength
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlSetSystemBootStatus(
    _In_ RTL_BSD_ITEM_TYPE BootStatusInformationClass,
    _In_ PVOID DataBuffer,
    _In_ ULONG DataLength,
    _Out_opt_ PULONG ReturnLength
    );
#endif

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlCheckPortableOperatingSystem(
    _Out_ PBOOLEAN IsPortable // VOID
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlSetPortableOperatingSystem(
    _In_ BOOLEAN IsPortable
    );

#if (PHNT_VERSION >= PHNT_THRESHOLD)

#endif

#if (PHNT_VERSION >= PHNT_VISTA)

NTSYSAPI
NTSTATUS
NTAPI
RtlFindClosestEncodableLength(
    _In_ ULONGLONG SourceLength,
    _Out_ PULONGLONG TargetLength
    );

#endif

// Memory cache

typedef NTSTATUS (NTAPI *PRTL_SECURE_MEMORY_CACHE_CALLBACK)(
    _In_ PVOID Address,
    _In_ SIZE_T Length
    );

// ros
NTSYSAPI
NTSTATUS
NTAPI
RtlRegisterSecureMemoryCacheCallback(
    _In_ PRTL_SECURE_MEMORY_CACHE_CALLBACK Callback
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDeregisterSecureMemoryCacheCallback(
    _In_ PRTL_SECURE_MEMORY_CACHE_CALLBACK Callback
    );

// ros
NTSYSAPI
BOOLEAN
NTAPI
RtlFlushSecureMemoryCache(
    _In_ PVOID MemoryCache,
    _In_opt_ SIZE_T MemoryLength
    );

#if (PHNT_VERSION >= PHNT_REDSTONE3)

// Feature configuration

typedef struct __RTL_FEATURE_USAGE_REPORT
{
    ULONG FeatureId;
    USHORT ReportingKind;
    USHORT ReportingOptions;
} RTL_FEATURE_USAGE_REPORT, *PRTL_FEATURE_USAGE_REPORT;

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlNotifyFeatureUsage(
    _In_ PRTL_FEATURE_USAGE_REPORT FeatureUsageReport
    );

typedef enum _RTL_FEATURE_CONFIGURATION_TYPE
{
    RtlFeatureConfigurationBoot,
    RtlFeatureConfigurationRuntime,
    RtlFeatureConfigurationCount
} RTL_FEATURE_CONFIGURATION_TYPE;

// rev
typedef struct _RTL_FEATURE_CONFIGURATION
{
    ULONG FeatureId;
    union
    {
        ULONG Flags;
        struct
        {
            ULONG Priority : 4;
            ULONG EnabledState : 2;
            ULONG IsWexpConfiguration : 1;
            ULONG HasSubscriptions : 1;
            ULONG Variant : 6;
            ULONG VariantPayloadKind : 2;
            ULONG Reserved : 16;
        };
    };
    ULONG VariantPayload;
} RTL_FEATURE_CONFIGURATION, *PRTL_FEATURE_CONFIGURATION;

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlQueryFeatureConfiguration(
    _In_ ULONG FeatureId,
    _In_ RTL_FEATURE_CONFIGURATION_TYPE FeatureType,
    _Inout_ PULONGLONG ChangeStamp,
    _In_ PRTL_FEATURE_CONFIGURATION FeatureConfiguration
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlSetFeatureConfigurations(
    _Inout_ PULONGLONG ChangeStamp,
    _In_ RTL_FEATURE_CONFIGURATION_TYPE FeatureType,
    _In_ PRTL_FEATURE_CONFIGURATION FeatureConfiguration,
    _In_ ULONG FeatureConfigurationCount
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlQueryAllFeatureConfigurations(
    _In_ RTL_FEATURE_CONFIGURATION_TYPE FeatureType,
    _Inout_ PULONGLONG ChangeStamp,
    _Out_ PRTL_FEATURE_CONFIGURATION FeatureConfigurations,
    _Inout_ PULONG FeatureConfigurationCount
    );

// rev
NTSYSAPI
ULONGLONG
NTAPI
RtlQueryFeatureConfigurationChangeStamp(
    VOID
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlQueryFeatureUsageNotificationSubscriptions(
    _Out_ PRTL_FEATURE_CONFIGURATION FeatureConfiguration,
    _Inout_ PULONG FeatureConfigurationCount
    );

typedef VOID (NTAPI *PRTL_FEATURE_CONFIGURATION_CHANGE_NOTIFICAION)(
    _In_opt_ PVOID Context
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlRegisterFeatureConfigurationChangeNotification(
    _In_ PRTL_FEATURE_CONFIGURATION_CHANGE_NOTIFICAION Callback,
    _In_opt_ PVOID Context,
    _Inout_opt_ PULONGLONG ChangeStamp,
    _Out_ PHANDLE NotificationHandle
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlUnregisterFeatureConfigurationChangeNotification(
    _In_ HANDLE NotificationHandle
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlSubscribeForFeatureUsageNotification(
    _In_ PRTL_FEATURE_CONFIGURATION FeatureConfiguration,
    _In_ ULONG FeatureConfigurationCount
    );

// rev
NTSYSAPI
NTSTATUS
NTAPI
RtlUnsubscribeFromFeatureUsageNotifications(
    _In_ PRTL_FEATURE_CONFIGURATION FeatureConfiguration,
    _In_ ULONG FeatureConfigurationCount
    );
#endif

#endif

```

`phnt/ntsam.h`:

```h
#ifndef _NTSAM_H
#define _NTSAM_H

#define SAM_MAXIMUM_LOOKUP_COUNT (1000)
#define SAM_MAXIMUM_LOOKUP_LENGTH (32000)
#define SAM_MAX_PASSWORD_LENGTH (256)
#define SAM_PASSWORD_ENCRYPTION_SALT_LEN (16)

typedef PVOID SAM_HANDLE, *PSAM_HANDLE;
typedef ULONG SAM_ENUMERATE_HANDLE, *PSAM_ENUMERATE_HANDLE;

typedef struct _SAM_RID_ENUMERATION
{
    ULONG RelativeId;
    UNICODE_STRING Name;
} SAM_RID_ENUMERATION, *PSAM_RID_ENUMERATION;

typedef struct _SAM_SID_ENUMERATION
{
    PSID Sid;
    UNICODE_STRING Name;
} SAM_SID_ENUMERATION, *PSAM_SID_ENUMERATION;

typedef struct _SAM_BYTE_ARRAY
{
    ULONG Size;
    _Field_size_bytes_(Size) PUCHAR Data;
} SAM_BYTE_ARRAY, *PSAM_BYTE_ARRAY;

typedef struct _SAM_BYTE_ARRAY_32K
{
    ULONG Size;
    _Field_size_bytes_(Size) PUCHAR Data;
} SAM_BYTE_ARRAY_32K, *PSAM_BYTE_ARRAY_32K;

typedef SAM_BYTE_ARRAY_32K SAM_SHELL_OBJECT_PROPERTIES, *PSAM_SHELL_OBJECT_PROPERTIES;

// Basic

NTSTATUS
NTAPI
SamFreeMemory(
    _In_ PVOID Buffer
    );

NTSTATUS
NTAPI
SamCloseHandle(
    _In_ SAM_HANDLE SamHandle
    );

_Check_return_
NTSTATUS
NTAPI
SamSetSecurityObject(
    _In_ SAM_HANDLE ObjectHandle,
    _In_ SECURITY_INFORMATION SecurityInformation,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor
    );

_Check_return_
NTSTATUS
NTAPI
SamQuerySecurityObject(
    _In_ SAM_HANDLE ObjectHandle,
    _In_ SECURITY_INFORMATION SecurityInformation,
    _Outptr_ PSECURITY_DESCRIPTOR *SecurityDescriptor
    );

_Check_return_
NTSTATUS
NTAPI
SamRidToSid(
    _In_ SAM_HANDLE ObjectHandle,
    _In_ ULONG Rid,
    _Outptr_ PSID *Sid
    );

// Server

#define SAM_SERVER_CONNECT 0x0001
#define SAM_SERVER_SHUTDOWN 0x0002
#define SAM_SERVER_INITIALIZE 0x0004
#define SAM_SERVER_CREATE_DOMAIN 0x0008
#define SAM_SERVER_ENUMERATE_DOMAINS 0x0010
#define SAM_SERVER_LOOKUP_DOMAIN 0x0020

#define SAM_SERVER_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED     | \
    SAM_SERVER_CONNECT | \
    SAM_SERVER_INITIALIZE | \
    SAM_SERVER_CREATE_DOMAIN | \
    SAM_SERVER_SHUTDOWN | \
    SAM_SERVER_ENUMERATE_DOMAINS | \
    SAM_SERVER_LOOKUP_DOMAIN)

#define SAM_SERVER_READ (STANDARD_RIGHTS_READ | \
    SAM_SERVER_ENUMERATE_DOMAINS)

#define SAM_SERVER_WRITE (STANDARD_RIGHTS_WRITE | \
    SAM_SERVER_INITIALIZE | \
    SAM_SERVER_CREATE_DOMAIN | \
    SAM_SERVER_SHUTDOWN)

#define SAM_SERVER_EXECUTE (STANDARD_RIGHTS_EXECUTE | \
    SAM_SERVER_CONNECT | \
    SAM_SERVER_LOOKUP_DOMAIN)

// Functions

_Check_return_
NTSTATUS
NTAPI
SamConnect(
    _In_opt_ PUNICODE_STRING ServerName,
    _Out_ PSAM_HANDLE ServerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

_Check_return_
NTSTATUS
NTAPI
SamShutdownSamServer(
    _In_ SAM_HANDLE ServerHandle
    );

// Domain

#define DOMAIN_READ_PASSWORD_PARAMETERS 0x0001
#define DOMAIN_WRITE_PASSWORD_PARAMS 0x0002
#define DOMAIN_READ_OTHER_PARAMETERS 0x0004
#define DOMAIN_WRITE_OTHER_PARAMETERS 0x0008
#define DOMAIN_CREATE_USER 0x0010
#define DOMAIN_CREATE_GROUP 0x0020
#define DOMAIN_CREATE_ALIAS 0x0040
#define DOMAIN_GET_ALIAS_MEMBERSHIP 0x0080
#define DOMAIN_LIST_ACCOUNTS 0x0100
#define DOMAIN_LOOKUP 0x0200
#define DOMAIN_ADMINISTER_SERVER 0x0400

#define DOMAIN_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | \
    DOMAIN_READ_OTHER_PARAMETERS | \
    DOMAIN_WRITE_OTHER_PARAMETERS | \
    DOMAIN_WRITE_PASSWORD_PARAMS | \
    DOMAIN_CREATE_USER | \
    DOMAIN_CREATE_GROUP | \
    DOMAIN_CREATE_ALIAS | \
    DOMAIN_GET_ALIAS_MEMBERSHIP | \
    DOMAIN_LIST_ACCOUNTS | \
    DOMAIN_READ_PASSWORD_PARAMETERS | \
    DOMAIN_LOOKUP | \
    DOMAIN_ADMINISTER_SERVER)

#define DOMAIN_READ (STANDARD_RIGHTS_READ | \
    DOMAIN_GET_ALIAS_MEMBERSHIP | \
    DOMAIN_READ_OTHER_PARAMETERS)

#define DOMAIN_WRITE (STANDARD_RIGHTS_WRITE | \
    DOMAIN_WRITE_OTHER_PARAMETERS | \
    DOMAIN_WRITE_PASSWORD_PARAMS | \
    DOMAIN_CREATE_USER | \
    DOMAIN_CREATE_GROUP | \
    DOMAIN_CREATE_ALIAS | \
    DOMAIN_ADMINISTER_SERVER)

#define DOMAIN_EXECUTE (STANDARD_RIGHTS_EXECUTE | \
    DOMAIN_READ_PASSWORD_PARAMETERS | \
    DOMAIN_LIST_ACCOUNTS | \
    DOMAIN_LOOKUP)

#define DOMAIN_PROMOTION_INCREMENT { 0x0, 0x10 }
#define DOMAIN_PROMOTION_MASK { 0x0, 0xfffffff0 }

// SamQueryInformationDomain/SamSetInformationDomain types

typedef enum _DOMAIN_INFORMATION_CLASS
{
    DomainPasswordInformation = 1,
    DomainGeneralInformation,
    DomainLogoffInformation,
    DomainOemInformation,
    DomainNameInformation,
    DomainReplicationInformation,
    DomainServerRoleInformation,
    DomainModifiedInformation,
    DomainStateInformation,
    DomainUasInformation,
    DomainGeneralInformation2,
    DomainLockoutInformation,
    DomainModifiedInformation2
} DOMAIN_INFORMATION_CLASS;

typedef enum _DOMAIN_SERVER_ENABLE_STATE
{
    DomainServerEnabled = 1,
    DomainServerDisabled
} DOMAIN_SERVER_ENABLE_STATE, *PDOMAIN_SERVER_ENABLE_STATE;

typedef enum _DOMAIN_SERVER_ROLE
{
    DomainServerRoleBackup = 2,
    DomainServerRolePrimary
} DOMAIN_SERVER_ROLE, *PDOMAIN_SERVER_ROLE;

#include <pshpack4.h>
typedef struct _DOMAIN_GENERAL_INFORMATION
{
    LARGE_INTEGER ForceLogoff;
    UNICODE_STRING OemInformation;
    UNICODE_STRING DomainName;
    UNICODE_STRING ReplicaSourceNodeName;
    LARGE_INTEGER DomainModifiedCount;
    DOMAIN_SERVER_ENABLE_STATE DomainServerState;
    DOMAIN_SERVER_ROLE DomainServerRole;
    BOOLEAN UasCompatibilityRequired;
    ULONG UserCount;
    ULONG GroupCount;
    ULONG AliasCount;
} DOMAIN_GENERAL_INFORMATION, *PDOMAIN_GENERAL_INFORMATION;
#include <poppack.h>

#include <pshpack4.h>
typedef struct _DOMAIN_GENERAL_INFORMATION2
{
    DOMAIN_GENERAL_INFORMATION I1;
    LARGE_INTEGER LockoutDuration; // delta time
    LARGE_INTEGER LockoutObservationWindow; // delta time
    USHORT LockoutThreshold;
} DOMAIN_GENERAL_INFORMATION2, *PDOMAIN_GENERAL_INFORMATION2;
#include <poppack.h>

typedef struct _DOMAIN_UAS_INFORMATION
{
    BOOLEAN UasCompatibilityRequired;
} DOMAIN_UAS_INFORMATION;

#ifndef _DOMAIN_PASSWORD_INFORMATION_DEFINED // defined in ntsecapi.h
#define _DOMAIN_PASSWORD_INFORMATION_DEFINED

typedef struct _DOMAIN_PASSWORD_INFORMATION
{
    USHORT MinPasswordLength;
    USHORT PasswordHistoryLength;
    ULONG PasswordProperties;
    LARGE_INTEGER MaxPasswordAge;
    LARGE_INTEGER MinPasswordAge;
} DOMAIN_PASSWORD_INFORMATION, *PDOMAIN_PASSWORD_INFORMATION;

// PasswordProperties flags

#define DOMAIN_PASSWORD_COMPLEX 0x00000001L
#define DOMAIN_PASSWORD_NO_ANON_CHANGE 0x00000002L
#define DOMAIN_PASSWORD_NO_CLEAR_CHANGE 0x00000004L
#define DOMAIN_LOCKOUT_ADMINS 0x00000008L
#define DOMAIN_PASSWORD_STORE_CLEARTEXT 0x00000010L
#define DOMAIN_REFUSE_PASSWORD_CHANGE 0x00000020L
#define DOMAIN_NO_LM_OWF_CHANGE 0x00000040L

#endif

typedef enum _DOMAIN_PASSWORD_CONSTRUCTION
{
    DomainPasswordSimple = 1,
    DomainPasswordComplex
} DOMAIN_PASSWORD_CONSTRUCTION;

typedef struct _DOMAIN_LOGOFF_INFORMATION
{
    LARGE_INTEGER ForceLogoff;
} DOMAIN_LOGOFF_INFORMATION, *PDOMAIN_LOGOFF_INFORMATION;

typedef struct _DOMAIN_OEM_INFORMATION
{
    UNICODE_STRING OemInformation;
} DOMAIN_OEM_INFORMATION, *PDOMAIN_OEM_INFORMATION;

typedef struct _DOMAIN_NAME_INFORMATION
{
    UNICODE_STRING DomainName;
} DOMAIN_NAME_INFORMATION, *PDOMAIN_NAME_INFORMATION;

typedef struct _DOMAIN_SERVER_ROLE_INFORMATION
{
    DOMAIN_SERVER_ROLE DomainServerRole;
} DOMAIN_SERVER_ROLE_INFORMATION, *PDOMAIN_SERVER_ROLE_INFORMATION;

typedef struct _DOMAIN_REPLICATION_INFORMATION
{
    UNICODE_STRING ReplicaSourceNodeName;
} DOMAIN_REPLICATION_INFORMATION, *PDOMAIN_REPLICATION_INFORMATION;

typedef struct _DOMAIN_MODIFIED_INFORMATION
{
    LARGE_INTEGER DomainModifiedCount;
    LARGE_INTEGER CreationTime;
} DOMAIN_MODIFIED_INFORMATION, *PDOMAIN_MODIFIED_INFORMATION;

typedef struct _DOMAIN_MODIFIED_INFORMATION2
{
    LARGE_INTEGER DomainModifiedCount;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER ModifiedCountAtLastPromotion;
} DOMAIN_MODIFIED_INFORMATION2, *PDOMAIN_MODIFIED_INFORMATION2;

typedef struct _DOMAIN_STATE_INFORMATION
{
    DOMAIN_SERVER_ENABLE_STATE DomainServerState;
} DOMAIN_STATE_INFORMATION, *PDOMAIN_STATE_INFORMATION;

typedef struct _DOMAIN_LOCKOUT_INFORMATION
{
    LARGE_INTEGER LockoutDuration; // delta time
    LARGE_INTEGER LockoutObservationWindow; // delta time
    USHORT LockoutThreshold; // zero means no lockout
} DOMAIN_LOCKOUT_INFORMATION, *PDOMAIN_LOCKOUT_INFORMATION;

// SamQueryDisplayInformation types

typedef enum _DOMAIN_DISPLAY_INFORMATION
{
    DomainDisplayUser = 1,
    DomainDisplayMachine,
    DomainDisplayGroup,
    DomainDisplayOemUser,
    DomainDisplayOemGroup,
    DomainDisplayServer
} DOMAIN_DISPLAY_INFORMATION, *PDOMAIN_DISPLAY_INFORMATION;

typedef struct _DOMAIN_DISPLAY_USER
{
    ULONG Index;
    ULONG Rid;
    ULONG AccountControl;
    UNICODE_STRING LogonName;
    UNICODE_STRING AdminComment;
    UNICODE_STRING FullName;
} DOMAIN_DISPLAY_USER, *PDOMAIN_DISPLAY_USER;

typedef struct _DOMAIN_DISPLAY_MACHINE
{
    ULONG Index;
    ULONG Rid;
    ULONG AccountControl;
    UNICODE_STRING Machine;
    UNICODE_STRING Comment;
} DOMAIN_DISPLAY_MACHINE, *PDOMAIN_DISPLAY_MACHINE;

typedef struct _DOMAIN_DISPLAY_GROUP
{
    ULONG Index;
    ULONG Rid;
    ULONG Attributes;
    UNICODE_STRING Group;
    UNICODE_STRING Comment;
} DOMAIN_DISPLAY_GROUP, *PDOMAIN_DISPLAY_GROUP;

typedef struct _DOMAIN_DISPLAY_OEM_USER
{
    ULONG Index;
    OEM_STRING User;
} DOMAIN_DISPLAY_OEM_USER, *PDOMAIN_DISPLAY_OEM_USER;

typedef struct _DOMAIN_DISPLAY_OEM_GROUP
{
    ULONG Index;
    OEM_STRING Group;
} DOMAIN_DISPLAY_OEM_GROUP, *PDOMAIN_DISPLAY_OEM_GROUP;

// SamQueryLocalizableAccountsInDomain types

typedef enum _DOMAIN_LOCALIZABLE_ACCOUNTS_INFORMATION
{
    DomainLocalizableAccountsBasic = 1,
} DOMAIN_LOCALIZABLE_ACCOUNTS_INFORMATION, *PDOMAIN_LOCALIZABLE_ACCOUNTS_INFORMATION;

typedef struct _DOMAIN_LOCALIZABLE_ACCOUNTS_ENTRY
{
    ULONG Rid;
    SID_NAME_USE Use;
    UNICODE_STRING Name;
    UNICODE_STRING AdminComment;
} DOMAIN_LOCALIZABLE_ACCOUNT_ENTRY, *PDOMAIN_LOCALIZABLE_ACCOUNT_ENTRY;

typedef struct _DOMAIN_LOCALIZABLE_ACCOUNTS
{
    ULONG Count;
    _Field_size_(Count) DOMAIN_LOCALIZABLE_ACCOUNT_ENTRY *Entries;
} DOMAIN_LOCALIZABLE_ACCOUNTS_BASIC, *PDOMAIN_LOCALIZABLE_ACCOUNTS_BASIC;

typedef union _DOMAIN_LOCALIZABLE_INFO_BUFFER
{
    DOMAIN_LOCALIZABLE_ACCOUNTS_BASIC Basic;
} DOMAIN_LOCALIZABLE_ACCOUNTS_INFO_BUFFER, *PDOMAIN_LOCALIZABLE_ACCOUNTS_INFO_BUFFER;

// Functions

_Check_return_
NTSTATUS
NTAPI
SamLookupDomainInSamServer(
    _In_ SAM_HANDLE ServerHandle,
    _In_ PUNICODE_STRING Name,
    _Outptr_ PSID *DomainId
    );

_Check_return_
NTSTATUS
NTAPI
SamEnumerateDomainsInSamServer(
    _In_ SAM_HANDLE ServerHandle,
    _Inout_ PSAM_ENUMERATE_HANDLE EnumerationContext,
    _Outptr_ PVOID *Buffer, // PSAM_SID_ENUMERATION *Buffer
    _In_ ULONG PreferedMaximumLength,
    _Out_ PULONG CountReturned
    );

_Check_return_
NTSTATUS
NTAPI
SamOpenDomain(
    _In_ SAM_HANDLE ServerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ PSID DomainId,
    _Out_ PSAM_HANDLE DomainHandle
    );

_Check_return_
NTSTATUS
NTAPI
SamQueryInformationDomain(
    _In_ SAM_HANDLE DomainHandle,
    _In_ DOMAIN_INFORMATION_CLASS DomainInformationClass,
    _Outptr_ PVOID *Buffer
    );

_Check_return_
NTSTATUS
NTAPI
SamSetInformationDomain(
    _In_ SAM_HANDLE DomainHandle,
    _In_ DOMAIN_INFORMATION_CLASS DomainInformationClass,
    _In_ PVOID DomainInformation
    );

_Check_return_
NTSTATUS
NTAPI
SamLookupNamesInDomain(
    _In_ SAM_HANDLE DomainHandle,
    _In_ ULONG Count,
    _In_reads_(Count) PUNICODE_STRING Names,
    _Out_ _Deref_post_count_(Count) PULONG *RelativeIds,
    _Out_ _Deref_post_count_(Count) PSID_NAME_USE *Use
    );

_Check_return_
NTSTATUS
NTAPI
SamLookupIdsInDomain(
    _In_ SAM_HANDLE DomainHandle,
    _In_ ULONG Count,
    _In_reads_(Count) PULONG RelativeIds,
    _Out_ _Deref_post_count_(Count) PUNICODE_STRING *Names,
    _Out_ _Deref_post_opt_count_(Count) PSID_NAME_USE *Use
    );

_Check_return_
NTSTATUS
NTAPI
SamRemoveMemberFromForeignDomain(
    _In_ SAM_HANDLE DomainHandle,
    _In_ PSID MemberId
    );

_Check_return_
NTSTATUS
NTAPI
SamQueryLocalizableAccountsInDomain(
    _In_ SAM_HANDLE Domain,
    _In_ ULONG Flags,
    _In_ ULONG LanguageId,
    _In_ DOMAIN_LOCALIZABLE_ACCOUNTS_INFORMATION Class,
    _Outptr_ PVOID *Buffer
    );

// Group

#define GROUP_READ_INFORMATION 0x0001
#define GROUP_WRITE_ACCOUNT 0x0002
#define GROUP_ADD_MEMBER 0x0004
#define GROUP_REMOVE_MEMBER 0x0008
#define GROUP_LIST_MEMBERS 0x0010

#define GROUP_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | \
    GROUP_LIST_MEMBERS | \
    GROUP_WRITE_ACCOUNT | \
    GROUP_ADD_MEMBER | \
    GROUP_REMOVE_MEMBER | \
    GROUP_READ_INFORMATION)

#define GROUP_READ (STANDARD_RIGHTS_READ | \
    GROUP_LIST_MEMBERS)

#define GROUP_WRITE (STANDARD_RIGHTS_WRITE | \
    GROUP_WRITE_ACCOUNT | \
    GROUP_ADD_MEMBER | \
    GROUP_REMOVE_MEMBER)

#define GROUP_EXECUTE (STANDARD_RIGHTS_EXECUTE | \
    GROUP_READ_INFORMATION)

typedef struct _GROUP_MEMBERSHIP
{
    ULONG RelativeId;
    ULONG Attributes;
} GROUP_MEMBERSHIP, *PGROUP_MEMBERSHIP;

// SamQueryInformationGroup/SamSetInformationGroup types

typedef enum _GROUP_INFORMATION_CLASS
{
    GroupGeneralInformation = 1,
    GroupNameInformation,
    GroupAttributeInformation,
    GroupAdminCommentInformation,
    GroupReplicationInformation
} GROUP_INFORMATION_CLASS;

typedef struct _GROUP_GENERAL_INFORMATION
{
    UNICODE_STRING Name;
    ULONG Attributes;
    ULONG MemberCount;
    UNICODE_STRING AdminComment;
} GROUP_GENERAL_INFORMATION, *PGROUP_GENERAL_INFORMATION;

typedef struct _GROUP_NAME_INFORMATION
{
    UNICODE_STRING Name;
} GROUP_NAME_INFORMATION, *PGROUP_NAME_INFORMATION;

typedef struct _GROUP_ATTRIBUTE_INFORMATION
{
    ULONG Attributes;
} GROUP_ATTRIBUTE_INFORMATION, *PGROUP_ATTRIBUTE_INFORMATION;

typedef struct _GROUP_ADM_COMMENT_INFORMATION
{
    UNICODE_STRING AdminComment;
} GROUP_ADM_COMMENT_INFORMATION, *PGROUP_ADM_COMMENT_INFORMATION;

// Functions

_Check_return_
NTSTATUS
NTAPI
SamEnumerateGroupsInDomain(
    _In_ SAM_HANDLE DomainHandle,
    _Inout_ PSAM_ENUMERATE_HANDLE EnumerationContext,
    _Outptr_ PVOID *Buffer, // PSAM_RID_ENUMERATION *
    _In_ ULONG PreferedMaximumLength,
    _Out_ PULONG CountReturned
    );

_Check_return_
NTSTATUS
NTAPI
SamCreateGroupInDomain(
    _In_ SAM_HANDLE DomainHandle,
    _In_ PUNICODE_STRING AccountName,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PSAM_HANDLE GroupHandle,
    _Out_ PULONG RelativeId
    );

_Check_return_
NTSTATUS
NTAPI
SamOpenGroup(
    _In_ SAM_HANDLE DomainHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG GroupId,
    _Out_ PSAM_HANDLE GroupHandle
    );

_Check_return_
NTSTATUS
NTAPI
SamDeleteGroup(
    _In_ SAM_HANDLE GroupHandle
    );

_Check_return_
NTSTATUS
NTAPI
SamQueryInformationGroup(
    _In_ SAM_HANDLE GroupHandle,
    _In_ GROUP_INFORMATION_CLASS GroupInformationClass,
    _Outptr_ PVOID *Buffer
    );

_Check_return_
NTSTATUS
NTAPI
SamSetInformationGroup(
    _In_ SAM_HANDLE GroupHandle,
    _In_ GROUP_INFORMATION_CLASS GroupInformationClass,
    _In_ PVOID Buffer
    );

_Check_return_
NTSTATUS
NTAPI
SamAddMemberToGroup(
    _In_ SAM_HANDLE GroupHandle,
    _In_ ULONG MemberId,
    _In_ ULONG Attributes
    );

_Check_return_
NTSTATUS
NTAPI
SamRemoveMemberFromGroup(
    _In_ SAM_HANDLE GroupHandle,
    _In_ ULONG MemberId
    );

_Check_return_
NTSTATUS
NTAPI
SamGetMembersInGroup(
    _In_ SAM_HANDLE GroupHandle,
    _Out_ _Deref_post_count_(*MemberCount) PULONG *MemberIds,
    _Out_ _Deref_post_count_(*MemberCount) PULONG *Attributes,
    _Out_ PULONG MemberCount
    );

_Check_return_
NTSTATUS
NTAPI
SamSetMemberAttributesOfGroup(
    _In_ SAM_HANDLE GroupHandle,
    _In_ ULONG MemberId,
    _In_ ULONG Attributes
    );

// Alias

#define ALIAS_ADD_MEMBER 0x0001
#define ALIAS_REMOVE_MEMBER 0x0002
#define ALIAS_LIST_MEMBERS 0x0004
#define ALIAS_READ_INFORMATION 0x0008
#define ALIAS_WRITE_ACCOUNT 0x0010

#define ALIAS_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | \
    ALIAS_READ_INFORMATION | \
    ALIAS_WRITE_ACCOUNT | \
    ALIAS_LIST_MEMBERS | \
    ALIAS_ADD_MEMBER | \
    ALIAS_REMOVE_MEMBER)

#define ALIAS_READ (STANDARD_RIGHTS_READ | \
    ALIAS_LIST_MEMBERS)

#define ALIAS_WRITE (STANDARD_RIGHTS_WRITE | \
    ALIAS_WRITE_ACCOUNT | \
    ALIAS_ADD_MEMBER | \
    ALIAS_REMOVE_MEMBER)

#define ALIAS_EXECUTE (STANDARD_RIGHTS_EXECUTE | \
    ALIAS_READ_INFORMATION)

// SamQueryInformationAlias/SamSetInformationAlias types

typedef enum _ALIAS_INFORMATION_CLASS
{
    AliasGeneralInformation = 1,
    AliasNameInformation,
    AliasAdminCommentInformation,
    AliasReplicationInformation,
    AliasExtendedInformation,
} ALIAS_INFORMATION_CLASS;

typedef struct _ALIAS_GENERAL_INFORMATION
{
    UNICODE_STRING Name;
    ULONG MemberCount;
    UNICODE_STRING AdminComment;
} ALIAS_GENERAL_INFORMATION,  *PALIAS_GENERAL_INFORMATION;

typedef struct _ALIAS_NAME_INFORMATION
{
    UNICODE_STRING Name;
} ALIAS_NAME_INFORMATION, *PALIAS_NAME_INFORMATION;

typedef struct _ALIAS_ADM_COMMENT_INFORMATION
{
    UNICODE_STRING AdminComment;
} ALIAS_ADM_COMMENT_INFORMATION, *PALIAS_ADM_COMMENT_INFORMATION;

#define ALIAS_ALL_NAME (0x00000001L)
#define ALIAS_ALL_MEMBER_COUNT (0x00000002L)
#define ALIAS_ALL_ADMIN_COMMENT (0x00000004L)
#define ALIAS_ALL_SHELL_ADMIN_OBJECT_PROPERTIES (0x00000008L)

typedef struct _ALIAS_EXTENDED_INFORMATION
{
    ULONG WhichFields;
    SAM_SHELL_OBJECT_PROPERTIES ShellAdminObjectProperties;
} ALIAS_EXTENDED_INFORMATION, *PALIAS_EXTENDED_INFORMATION;

// Functions

_Check_return_
NTSTATUS
NTAPI
SamEnumerateAliasesInDomain(
    _In_ SAM_HANDLE DomainHandle,
    _Inout_ PSAM_ENUMERATE_HANDLE EnumerationContext,
    _Outptr_ PVOID *Buffer, // PSAM_RID_ENUMERATION *Buffer
    _In_ ULONG PreferedMaximumLength,
    _Out_ PULONG CountReturned
    );

_Check_return_
NTSTATUS
NTAPI
SamCreateAliasInDomain(
    _In_ SAM_HANDLE DomainHandle,
    _In_ PUNICODE_STRING AccountName,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PSAM_HANDLE AliasHandle,
    _Out_ PULONG RelativeId
    );

_Check_return_
NTSTATUS
NTAPI
SamOpenAlias(
    _In_ SAM_HANDLE DomainHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG AliasId,
    _Out_ PSAM_HANDLE AliasHandle
    );

_Check_return_
NTSTATUS
NTAPI
SamDeleteAlias(
    _In_ SAM_HANDLE AliasHandle
    );

_Check_return_
NTSTATUS
NTAPI
SamQueryInformationAlias(
    _In_ SAM_HANDLE AliasHandle,
    _In_ ALIAS_INFORMATION_CLASS AliasInformationClass,
    _Outptr_ PVOID *Buffer
    );

_Check_return_
NTSTATUS
NTAPI
SamSetInformationAlias(
    _In_ SAM_HANDLE AliasHandle,
    _In_ ALIAS_INFORMATION_CLASS AliasInformationClass,
    _In_ PVOID Buffer
    );

_Check_return_
NTSTATUS
NTAPI
SamAddMemberToAlias(
    _In_ SAM_HANDLE AliasHandle,
    _In_ PSID MemberId
    );

_Check_return_
NTSTATUS
NTAPI
SamAddMultipleMembersToAlias(
    _In_ SAM_HANDLE AliasHandle,
    _In_reads_(MemberCount) PSID *MemberIds,
    _In_ ULONG MemberCount
    );

_Check_return_
NTSTATUS
NTAPI
SamRemoveMemberFromAlias(
    _In_ SAM_HANDLE AliasHandle,
    _In_ PSID MemberId
    );

_Check_return_
NTSTATUS
NTAPI
SamRemoveMultipleMembersFromAlias(
    _In_ SAM_HANDLE AliasHandle,
    _In_reads_(MemberCount) PSID *MemberIds,
    _In_ ULONG MemberCount
    );

_Check_return_
NTSTATUS
NTAPI
SamGetMembersInAlias(
    _In_ SAM_HANDLE AliasHandle,
    _Out_ _Deref_post_count_(*MemberCount) PSID **MemberIds,
    _Out_ PULONG MemberCount
    );

_Check_return_
NTSTATUS
NTAPI
SamGetAliasMembership(
    _In_ SAM_HANDLE DomainHandle,
    _In_ ULONG PassedCount,
    _In_reads_(PassedCount) PSID *Sids,
    _Out_ PULONG MembershipCount,
    _Out_ _Deref_post_count_(*MembershipCount) PULONG *Aliases
    );

// Group types

#define GROUP_TYPE_BUILTIN_LOCAL_GROUP 0x00000001
#define GROUP_TYPE_ACCOUNT_GROUP 0x00000002
#define GROUP_TYPE_RESOURCE_GROUP 0x00000004
#define GROUP_TYPE_UNIVERSAL_GROUP 0x00000008
#define GROUP_TYPE_APP_BASIC_GROUP 0x00000010
#define GROUP_TYPE_APP_QUERY_GROUP 0x00000020
#define GROUP_TYPE_SECURITY_ENABLED 0x80000000

#define GROUP_TYPE_RESOURCE_BEHAVOIR (GROUP_TYPE_RESOURCE_GROUP | \
    GROUP_TYPE_APP_BASIC_GROUP | \
    GROUP_TYPE_APP_QUERY_GROUP)

// User

#define USER_READ_GENERAL 0x0001
#define USER_READ_PREFERENCES 0x0002
#define USER_WRITE_PREFERENCES 0x0004
#define USER_READ_LOGON 0x0008
#define USER_READ_ACCOUNT 0x0010
#define USER_WRITE_ACCOUNT 0x0020
#define USER_CHANGE_PASSWORD 0x0040
#define USER_FORCE_PASSWORD_CHANGE 0x0080
#define USER_LIST_GROUPS 0x0100
#define USER_READ_GROUP_INFORMATION 0x0200
#define USER_WRITE_GROUP_INFORMATION 0x0400

#define USER_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | \
    USER_READ_PREFERENCES | \
    USER_READ_LOGON | \
    USER_LIST_GROUPS | \
    USER_READ_GROUP_INFORMATION | \
    USER_WRITE_PREFERENCES | \
    USER_CHANGE_PASSWORD | \
    USER_FORCE_PASSWORD_CHANGE | \
    USER_READ_GENERAL | \
    USER_READ_ACCOUNT | \
    USER_WRITE_ACCOUNT | \
    USER_WRITE_GROUP_INFORMATION)

#define USER_READ (STANDARD_RIGHTS_READ | \
    USER_READ_PREFERENCES | \
    USER_READ_LOGON | \
    USER_READ_ACCOUNT | \
    USER_LIST_GROUPS | \
    USER_READ_GROUP_INFORMATION)

#define USER_WRITE (STANDARD_RIGHTS_WRITE | \
    USER_WRITE_PREFERENCES | \
    USER_CHANGE_PASSWORD)

#define USER_EXECUTE (STANDARD_RIGHTS_EXECUTE | \
    USER_READ_GENERAL | \
    USER_CHANGE_PASSWORD)

// User account control flags

#define USER_ACCOUNT_DISABLED (0x00000001)
#define USER_HOME_DIRECTORY_REQUIRED (0x00000002)
#define USER_PASSWORD_NOT_REQUIRED (0x00000004)
#define USER_TEMP_DUPLICATE_ACCOUNT (0x00000008)
#define USER_NORMAL_ACCOUNT (0x00000010)
#define USER_MNS_LOGON_ACCOUNT (0x00000020)
#define USER_INTERDOMAIN_TRUST_ACCOUNT (0x00000040)
#define USER_WORKSTATION_TRUST_ACCOUNT (0x00000080)
#define USER_SERVER_TRUST_ACCOUNT (0x00000100)
#define USER_DONT_EXPIRE_PASSWORD (0x00000200)
#define USER_ACCOUNT_AUTO_LOCKED (0x00000400)
#define USER_ENCRYPTED_TEXT_PASSWORD_ALLOWED (0x00000800)
#define USER_SMARTCARD_REQUIRED (0x00001000)
#define USER_TRUSTED_FOR_DELEGATION (0x00002000)
#define USER_NOT_DELEGATED (0x00004000)
#define USER_USE_DES_KEY_ONLY (0x00008000)
#define USER_DONT_REQUIRE_PREAUTH (0x00010000)
#define USER_PASSWORD_EXPIRED (0x00020000)
#define USER_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION (0x00040000)
#define USER_NO_AUTH_DATA_REQUIRED (0x00080000)
#define USER_PARTIAL_SECRETS_ACCOUNT (0x00100000)
#define USER_USE_AES_KEYS (0x00200000) // not used

#define NEXT_FREE_ACCOUNT_CONTROL_BIT (USER_USE_AES_KEYS << 1)

#define USER_MACHINE_ACCOUNT_MASK ( \
    USER_INTERDOMAIN_TRUST_ACCOUNT | \
    USER_WORKSTATION_TRUST_ACCOUNT | \
    USER_SERVER_TRUST_ACCOUNT \
    )

#define USER_ACCOUNT_TYPE_MASK ( \
    USER_TEMP_DUPLICATE_ACCOUNT | \
    USER_NORMAL_ACCOUNT | \
    USER_MACHINE_ACCOUNT_MASK \
    )

#define USER_COMPUTED_ACCOUNT_CONTROL_BITS ( \
    USER_ACCOUNT_AUTO_LOCKED | \
    USER_PASSWORD_EXPIRED \
    )

// Logon times may be expressed in day, hour, or minute granularity.

#define SAM_DAYS_PER_WEEK (7)
#define SAM_HOURS_PER_WEEK (24 * SAM_DAYS_PER_WEEK)
#define SAM_MINUTES_PER_WEEK (60 * SAM_HOURS_PER_WEEK)

typedef struct _LOGON_HOURS
{
    USHORT UnitsPerWeek;

    // UnitsPerWeek is the number of equal length time units the week is
    // divided into. This value is used to compute the length of the bit
    // string in logon_hours. Must be less than or equal to
    // SAM_UNITS_PER_WEEK (10080) for this release.
    //
    // LogonHours is a bit map of valid logon times. Each bit represents
    // a unique division in a week. The largest bit map supported is 1260
    // bytes (10080 bits), which represents minutes per week. In this case
    // the first bit (bit 0, byte 0) is Sunday, 00:00:00 - 00-00:59; bit 1,
    // byte 0 is Sunday, 00:01:00 - 00:01:59, etc. A NULL pointer means
    // DONT_CHANGE for SamSetInformationUser() calls.

    PUCHAR LogonHours;
} LOGON_HOURS, *PLOGON_HOURS;

typedef struct _SR_SECURITY_DESCRIPTOR
{
    ULONG Length;
    PUCHAR SecurityDescriptor;
} SR_SECURITY_DESCRIPTOR, *PSR_SECURITY_DESCRIPTOR;

// SamQueryInformationUser/SamSetInformationUser types

typedef enum _USER_INFORMATION_CLASS
{
    UserGeneralInformation = 1, // USER_GENERAL_INFORMATION
    UserPreferencesInformation, // USER_PREFERENCES_INFORMATION
    UserLogonInformation, // USER_LOGON_INFORMATION
    UserLogonHoursInformation, // USER_LOGON_HOURS_INFORMATION
    UserAccountInformation, // USER_ACCOUNT_INFORMATION
    UserNameInformation, // USER_NAME_INFORMATION
    UserAccountNameInformation, // USER_ACCOUNT_NAME_INFORMATION
    UserFullNameInformation, // USER_FULL_NAME_INFORMATION
    UserPrimaryGroupInformation, // USER_PRIMARY_GROUP_INFORMATION
    UserHomeInformation, // USER_HOME_INFORMATION
    UserScriptInformation, // USER_SCRIPT_INFORMATION
    UserProfileInformation, // USER_PROFILE_INFORMATION
    UserAdminCommentInformation, // USER_ADMIN_COMMENT_INFORMATION
    UserWorkStationsInformation, // USER_WORKSTATIONS_INFORMATION
    UserSetPasswordInformation, // USER_SET_PASSWORD_INFORMATION
    UserControlInformation, // USER_CONTROL_INFORMATION
    UserExpiresInformation, // USER_EXPIRES_INFORMATION
    UserInternal1Information,
    UserInternal2Information,
    UserParametersInformation, // USER_PARAMETERS_INFORMATION
    UserAllInformation, // USER_ALL_INFORMATION
    UserInternal3Information,
    UserInternal4Information,
    UserInternal5Information,
    UserInternal4InformationNew,
    UserInternal5InformationNew,
    UserInternal6Information,
    UserExtendedInformation, // USER_EXTENDED_INFORMATION
    UserLogonUIInformation // USER_LOGON_UI_INFORMATION
} USER_INFORMATION_CLASS, *PUSER_INFORMATION_CLASS;

typedef struct _USER_GENERAL_INFORMATION
{
    UNICODE_STRING UserName;
    UNICODE_STRING FullName;
    ULONG PrimaryGroupId;
    UNICODE_STRING AdminComment;
    UNICODE_STRING UserComment;
} USER_GENERAL_INFORMATION, *PUSER_GENERAL_INFORMATION;

typedef struct _USER_PREFERENCES_INFORMATION
{
    UNICODE_STRING UserComment;
    UNICODE_STRING Reserved1;
    USHORT CountryCode;
    USHORT CodePage;
} USER_PREFERENCES_INFORMATION, *PUSER_PREFERENCES_INFORMATION;

#include <pshpack4.h>
typedef struct _USER_LOGON_INFORMATION
{
    UNICODE_STRING UserName;
    UNICODE_STRING FullName;
    ULONG UserId;
    ULONG PrimaryGroupId;
    UNICODE_STRING HomeDirectory;
    UNICODE_STRING HomeDirectoryDrive;
    UNICODE_STRING ScriptPath;
    UNICODE_STRING ProfilePath;
    UNICODE_STRING WorkStations;
    LARGE_INTEGER LastLogon;
    LARGE_INTEGER LastLogoff;
    LARGE_INTEGER PasswordLastSet;
    LARGE_INTEGER PasswordCanChange;
    LARGE_INTEGER PasswordMustChange;
    LOGON_HOURS LogonHours;
    USHORT BadPasswordCount;
    USHORT LogonCount;
    ULONG UserAccountControl;
} USER_LOGON_INFORMATION, * PUSER_LOGON_INFORMATION;
#include <poppack.h>

typedef struct _USER_LOGON_HOURS_INFORMATION
{
    LOGON_HOURS LogonHours;
} USER_LOGON_HOURS_INFORMATION, * PUSER_LOGON_HOURS_INFORMATION;

#include <pshpack4.h>
typedef struct _USER_ACCOUNT_INFORMATION
{
    UNICODE_STRING UserName;
    UNICODE_STRING FullName;
    ULONG UserId;
    ULONG PrimaryGroupId;
    UNICODE_STRING HomeDirectory;
    UNICODE_STRING HomeDirectoryDrive;
    UNICODE_STRING ScriptPath;
    UNICODE_STRING ProfilePath;
    UNICODE_STRING AdminComment;
    UNICODE_STRING WorkStations;
    LARGE_INTEGER LastLogon;
    LARGE_INTEGER LastLogoff;
    LOGON_HOURS LogonHours;
    USHORT BadPasswordCount;
    USHORT LogonCount;
    LARGE_INTEGER PasswordLastSet;
    LARGE_INTEGER AccountExpires;
    ULONG UserAccountControl;
} USER_ACCOUNT_INFORMATION, * PUSER_ACCOUNT_INFORMATION;
#include <poppack.h>

typedef struct _USER_NAME_INFORMATION
{
    UNICODE_STRING UserName;
    UNICODE_STRING FullName;
} USER_NAME_INFORMATION, *PUSER_NAME_INFORMATION;

typedef struct _USER_ACCOUNT_NAME_INFORMATION
{
    UNICODE_STRING UserName;
} USER_ACCOUNT_NAME_INFORMATION, *PUSER_ACCOUNT_NAME_INFORMATION;

typedef struct _USER_FULL_NAME_INFORMATION
{
    UNICODE_STRING FullName;
} USER_FULL_NAME_INFORMATION, *PUSER_FULL_NAME_INFORMATION;

typedef struct _USER_PRIMARY_GROUP_INFORMATION
{
    ULONG PrimaryGroupId;
} USER_PRIMARY_GROUP_INFORMATION, *PUSER_PRIMARY_GROUP_INFORMATION;

typedef struct _USER_HOME_INFORMATION
{
    UNICODE_STRING HomeDirectory;
    UNICODE_STRING HomeDirectoryDrive;
} USER_HOME_INFORMATION, *PUSER_HOME_INFORMATION;

typedef struct _USER_SCRIPT_INFORMATION
{
    UNICODE_STRING ScriptPath;
} USER_SCRIPT_INFORMATION, *PUSER_SCRIPT_INFORMATION;

typedef struct _USER_PROFILE_INFORMATION
{
    UNICODE_STRING ProfilePath;
} USER_PROFILE_INFORMATION, *PUSER_PROFILE_INFORMATION;

typedef struct _USER_ADMIN_COMMENT_INFORMATION
{
    UNICODE_STRING AdminComment;
} USER_ADMIN_COMMENT_INFORMATION, *PUSER_ADMIN_COMMENT_INFORMATION;

typedef struct _USER_WORKSTATIONS_INFORMATION
{
    UNICODE_STRING WorkStations;
} USER_WORKSTATIONS_INFORMATION, *PUSER_WORKSTATIONS_INFORMATION;

typedef struct _USER_SET_PASSWORD_INFORMATION
{
    UNICODE_STRING Password;
    BOOLEAN PasswordExpired;
} USER_SET_PASSWORD_INFORMATION, *PUSER_SET_PASSWORD_INFORMATION;

typedef struct _USER_CONTROL_INFORMATION
{
    ULONG UserAccountControl;
} USER_CONTROL_INFORMATION, *PUSER_CONTROL_INFORMATION;

typedef struct _USER_EXPIRES_INFORMATION
{
    LARGE_INTEGER AccountExpires;
} USER_EXPIRES_INFORMATION, *PUSER_EXPIRES_INFORMATION;

typedef struct _USER_PARAMETERS_INFORMATION
{
    UNICODE_STRING Parameters;
} USER_PARAMETERS_INFORMATION, *PUSER_PARAMETERS_INFORMATION;

// Flags for WhichFields in USER_ALL_INFORMATION

#define USER_ALL_USERNAME 0x00000001
#define USER_ALL_FULLNAME 0x00000002
#define USER_ALL_USERID 0x00000004
#define USER_ALL_PRIMARYGROUPID 0x00000008
#define USER_ALL_ADMINCOMMENT 0x00000010
#define USER_ALL_USERCOMMENT 0x00000020
#define USER_ALL_HOMEDIRECTORY 0x00000040
#define USER_ALL_HOMEDIRECTORYDRIVE 0x00000080
#define USER_ALL_SCRIPTPATH 0x00000100
#define USER_ALL_PROFILEPATH 0x00000200
#define USER_ALL_WORKSTATIONS 0x00000400
#define USER_ALL_LASTLOGON 0x00000800
#define USER_ALL_LASTLOGOFF 0x00001000
#define USER_ALL_LOGONHOURS 0x00002000
#define USER_ALL_BADPASSWORDCOUNT 0x00004000
#define USER_ALL_LOGONCOUNT 0x00008000
#define USER_ALL_PASSWORDCANCHANGE 0x00010000
#define USER_ALL_PASSWORDMUSTCHANGE 0x00020000
#define USER_ALL_PASSWORDLASTSET 0x00040000
#define USER_ALL_ACCOUNTEXPIRES 0x00080000
#define USER_ALL_USERACCOUNTCONTROL 0x00100000
#define USER_ALL_PARAMETERS 0x00200000
#define USER_ALL_COUNTRYCODE 0x00400000
#define USER_ALL_CODEPAGE 0x00800000
#define USER_ALL_NTPASSWORDPRESENT 0x01000000 // field AND boolean
#define USER_ALL_LMPASSWORDPRESENT 0x02000000 // field AND boolean
#define USER_ALL_PRIVATEDATA 0x04000000 // field AND boolean
#define USER_ALL_PASSWORDEXPIRED 0x08000000
#define USER_ALL_SECURITYDESCRIPTOR 0x10000000
#define USER_ALL_OWFPASSWORD 0x20000000 // boolean

#define USER_ALL_UNDEFINED_MASK 0xc0000000

// Fields that require USER_READ_GENERAL access to read.

#define USER_ALL_READ_GENERAL_MASK \
    (USER_ALL_USERNAME | \
    USER_ALL_FULLNAME | \
    USER_ALL_USERID | \
    USER_ALL_PRIMARYGROUPID | \
    USER_ALL_ADMINCOMMENT | \
    USER_ALL_USERCOMMENT)

// Fields that require USER_READ_LOGON access to read.

#define USER_ALL_READ_LOGON_MASK \
   (USER_ALL_HOMEDIRECTORY | \
    USER_ALL_HOMEDIRECTORYDRIVE | \
    USER_ALL_SCRIPTPATH | \
    USER_ALL_PROFILEPATH | \
    USER_ALL_WORKSTATIONS | \
    USER_ALL_LASTLOGON | \
    USER_ALL_LASTLOGOFF | \
    USER_ALL_LOGONHOURS | \
    USER_ALL_BADPASSWORDCOUNT | \
    USER_ALL_LOGONCOUNT | \
    USER_ALL_PASSWORDCANCHANGE | \
    USER_ALL_PASSWORDMUSTCHANGE)

// Fields that require USER_READ_ACCOUNT access to read.

#define USER_ALL_READ_ACCOUNT_MASK \
    (USER_ALL_PASSWORDLASTSET | \
    USER_ALL_ACCOUNTEXPIRES | \
    USER_ALL_USERACCOUNTCONTROL | \
    USER_ALL_PARAMETERS)

// Fields that require USER_READ_PREFERENCES access to read.

#define USER_ALL_READ_PREFERENCES_MASK \
    (USER_ALL_COUNTRYCODE | USER_ALL_CODEPAGE)

// Fields that can only be read by trusted clients.

#define USER_ALL_READ_TRUSTED_MASK \
    (USER_ALL_NTPASSWORDPRESENT | \
    USER_ALL_LMPASSWORDPRESENT | \
    USER_ALL_PASSWORDEXPIRED | \
    USER_ALL_SECURITYDESCRIPTOR | \
    USER_ALL_PRIVATEDATA)

// Fields that can't be read.

#define USER_ALL_READ_CANT_MASK USER_ALL_UNDEFINED_MASK

// Fields that require USER_WRITE_ACCOUNT access to write.

#define USER_ALL_WRITE_ACCOUNT_MASK \
    (USER_ALL_USERNAME | \
    USER_ALL_FULLNAME | \
    USER_ALL_PRIMARYGROUPID | \
    USER_ALL_HOMEDIRECTORY | \
    USER_ALL_HOMEDIRECTORYDRIVE | \
    USER_ALL_SCRIPTPATH | \
    USER_ALL_PROFILEPATH | \
    USER_ALL_ADMINCOMMENT | \
    USER_ALL_WORKSTATIONS | \
    USER_ALL_LOGONHOURS | \
    USER_ALL_ACCOUNTEXPIRES | \
    USER_ALL_USERACCOUNTCONTROL | \
    USER_ALL_PARAMETERS)

// Fields that require USER_WRITE_PREFERENCES access to write.

#define USER_ALL_WRITE_PREFERENCES_MASK \
    (USER_ALL_USERCOMMENT | USER_ALL_COUNTRYCODE | USER_ALL_CODEPAGE)

// Fields that require USER_FORCE_PASSWORD_CHANGE access to write.
//
// Note that non-trusted clients only set the NT password as a
// UNICODE string. The wrapper will convert it to an LM password,
// OWF and encrypt both versions. Trusted clients can pass in OWF
// versions of either or both.

#define USER_ALL_WRITE_FORCE_PASSWORD_CHANGE_MASK \
    (USER_ALL_NTPASSWORDPRESENT | \
    USER_ALL_LMPASSWORDPRESENT | \
    USER_ALL_PASSWORDEXPIRED)

// Fields that can only be written by trusted clients.

#define USER_ALL_WRITE_TRUSTED_MASK \
    (USER_ALL_LASTLOGON | \
    USER_ALL_LASTLOGOFF | \
    USER_ALL_BADPASSWORDCOUNT | \
    USER_ALL_LOGONCOUNT | \
    USER_ALL_PASSWORDLASTSET | \
    USER_ALL_SECURITYDESCRIPTOR | \
    USER_ALL_PRIVATEDATA)

// Fields that can't be written.

#define USER_ALL_WRITE_CANT_MASK \
    (USER_ALL_USERID | \
    USER_ALL_PASSWORDCANCHANGE | \
    USER_ALL_PASSWORDMUSTCHANGE | \
    USER_ALL_UNDEFINED_MASK)

#include <pshpack4.h>
typedef struct _USER_ALL_INFORMATION
{
    LARGE_INTEGER LastLogon;
    LARGE_INTEGER LastLogoff;
    LARGE_INTEGER PasswordLastSet;
    LARGE_INTEGER AccountExpires;
    LARGE_INTEGER PasswordCanChange;
    LARGE_INTEGER PasswordMustChange;
    UNICODE_STRING UserName;
    UNICODE_STRING FullName;
    UNICODE_STRING HomeDirectory;
    UNICODE_STRING HomeDirectoryDrive;
    UNICODE_STRING ScriptPath;
    UNICODE_STRING ProfilePath;
    UNICODE_STRING AdminComment;
    UNICODE_STRING WorkStations;
    UNICODE_STRING UserComment;
    UNICODE_STRING Parameters;
    UNICODE_STRING LmPassword;
    UNICODE_STRING NtPassword;
    UNICODE_STRING PrivateData;
    SR_SECURITY_DESCRIPTOR SecurityDescriptor;
    ULONG UserId;
    ULONG PrimaryGroupId;
    ULONG UserAccountControl;
    ULONG WhichFields;
    LOGON_HOURS LogonHours;
    USHORT BadPasswordCount;
    USHORT LogonCount;
    USHORT CountryCode;
    USHORT CodePage;
    BOOLEAN LmPasswordPresent;
    BOOLEAN NtPasswordPresent;
    BOOLEAN PasswordExpired;
    BOOLEAN PrivateDataSensitive;
} USER_ALL_INFORMATION, *PUSER_ALL_INFORMATION;
#include <poppack.h>

typedef SAM_BYTE_ARRAY_32K SAM_USER_TILE, *PSAM_USER_TILE;

// 0xff000fff is reserved for internal callers and implementation.

#define USER_EXTENDED_FIELD_USER_TILE (0x00001000L)
#define USER_EXTENDED_FIELD_PASSWORD_HINT (0x00002000L)
#define USER_EXTENDED_FIELD_DONT_SHOW_IN_LOGON_UI (0x00004000L)
#define USER_EXTENDED_FIELD_SHELL_ADMIN_OBJECT_PROPERTIES (0x00008000L)

typedef struct _USER_EXTENDED_INFORMATION
{
    ULONG ExtendedWhichFields;
    SAM_USER_TILE UserTile;
    UNICODE_STRING PasswordHint;
    BOOLEAN DontShowInLogonUI;
    SAM_SHELL_OBJECT_PROPERTIES ShellAdminObjectProperties;
} USER_EXTENDED_INFORMATION, *PUSER_EXTENDED_INFORMATION;

// For local callers only.
typedef struct _USER_LOGON_UI_INFORMATION
{
    BOOLEAN PasswordIsBlank;
    BOOLEAN AccountIsDisabled;
} USER_LOGON_UI_INFORMATION, *PUSER_LOGON_UI_INFORMATION;

// SamChangePasswordUser3 types

// Error values:
// * SAM_PWD_CHANGE_NO_ERROR
// * SAM_PWD_CHANGE_PASSWORD_TOO_SHORT
// * SAM_PWD_CHANGE_PWD_IN_HISTORY
// * SAM_PWD_CHANGE_USERNAME_IN_PASSWORD
// * SAM_PWD_CHANGE_FULLNAME_IN_PASSWORD
// * SAM_PWD_CHANGE_MACHINE_PASSWORD_NOT_DEFAULT
// * SAM_PWD_CHANGE_FAILED_BY_FILTER

typedef struct _USER_PWD_CHANGE_FAILURE_INFORMATION
{
    ULONG ExtendedFailureReason;
    UNICODE_STRING FilterModuleName;
} USER_PWD_CHANGE_FAILURE_INFORMATION,*PUSER_PWD_CHANGE_FAILURE_INFORMATION;

// ExtendedFailureReason values

#define SAM_PWD_CHANGE_NO_ERROR 0
#define SAM_PWD_CHANGE_PASSWORD_TOO_SHORT 1
#define SAM_PWD_CHANGE_PWD_IN_HISTORY 2
#define SAM_PWD_CHANGE_USERNAME_IN_PASSWORD 3
#define SAM_PWD_CHANGE_FULLNAME_IN_PASSWORD 4
#define SAM_PWD_CHANGE_NOT_COMPLEX 5
#define SAM_PWD_CHANGE_MACHINE_PASSWORD_NOT_DEFAULT 6
#define SAM_PWD_CHANGE_FAILED_BY_FILTER 7
#define SAM_PWD_CHANGE_PASSWORD_TOO_LONG 8
#define SAM_PWD_CHANGE_FAILURE_REASON_MAX 8

// Functions

_Check_return_
NTSTATUS
NTAPI
SamEnumerateUsersInDomain(
    _In_ SAM_HANDLE DomainHandle,
    _Inout_ PSAM_ENUMERATE_HANDLE EnumerationContext,
    _In_ ULONG UserAccountControl,
    _Outptr_ PVOID *Buffer, // PSAM_RID_ENUMERATION *
    _In_ ULONG PreferedMaximumLength,
    _Out_ PULONG CountReturned
    );

_Check_return_
NTSTATUS
NTAPI
SamCreateUserInDomain(
    _In_ SAM_HANDLE DomainHandle,
    _In_ PUNICODE_STRING AccountName,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PSAM_HANDLE UserHandle,
    _Out_ PULONG RelativeId
    );

_Check_return_
NTSTATUS
NTAPI
SamCreateUser2InDomain(
    _In_ SAM_HANDLE DomainHandle,
    _In_ PUNICODE_STRING AccountName,
    _In_ ULONG AccountType,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PSAM_HANDLE UserHandle,
    _Out_ PULONG GrantedAccess,
    _Out_ PULONG RelativeId
    );

_Check_return_
NTSTATUS
NTAPI
SamOpenUser(
    _In_ SAM_HANDLE DomainHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG UserId,
    _Out_ PSAM_HANDLE UserHandle
    );

_Check_return_
NTSTATUS
NTAPI
SamDeleteUser(
    _In_ SAM_HANDLE UserHandle
    );

_Check_return_
NTSTATUS
NTAPI
SamQueryInformationUser(
    _In_ SAM_HANDLE UserHandle,
    _In_ USER_INFORMATION_CLASS UserInformationClass,
    _Outptr_ PVOID *Buffer
    );

_Check_return_
NTSTATUS
NTAPI
SamSetInformationUser(
    _In_ SAM_HANDLE UserHandle,
    _In_ USER_INFORMATION_CLASS UserInformationClass,
    _In_ PVOID Buffer
    );

_Check_return_
NTSTATUS
NTAPI
SamGetGroupsForUser(
    _In_ SAM_HANDLE UserHandle,
    _Out_ _Deref_post_count_(*MembershipCount) PGROUP_MEMBERSHIP *Groups,
    _Out_ PULONG MembershipCount
    );

_Check_return_
NTSTATUS
NTAPI
SamChangePasswordUser(
    _In_ SAM_HANDLE UserHandle,
    _In_ PUNICODE_STRING OldPassword,
    _In_ PUNICODE_STRING NewPassword
    );

_Check_return_
NTSTATUS
NTAPI
SamChangePasswordUser2(
    _In_ PUNICODE_STRING ServerName,
    _In_ PUNICODE_STRING UserName,
    _In_ PUNICODE_STRING OldPassword,
    _In_ PUNICODE_STRING NewPassword
    );

_Check_return_
NTSTATUS
NTAPI
SamChangePasswordUser3(
    _In_ PUNICODE_STRING ServerName,
    _In_ PUNICODE_STRING UserName,
    _In_ PUNICODE_STRING OldPassword,
    _In_ PUNICODE_STRING NewPassword,
    _Outptr_ PDOMAIN_PASSWORD_INFORMATION *EffectivePasswordPolicy,
    _Outptr_ PUSER_PWD_CHANGE_FAILURE_INFORMATION *PasswordChangeFailureInfo
    );

_Check_return_
NTSTATUS
NTAPI
SamQueryDisplayInformation(
    _In_ SAM_HANDLE DomainHandle,
    _In_ DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    _In_ ULONG Index,
    _In_ ULONG EntryCount,
    _In_ ULONG PreferredMaximumLength,
    _In_ PULONG TotalAvailable,
    _Out_ PULONG TotalReturned,
    _Out_ PULONG ReturnedEntryCount,
    _Outptr_ PVOID *SortedBuffer
    );

_Check_return_
NTSTATUS
NTAPI
SamGetDisplayEnumerationIndex(
    _In_ SAM_HANDLE DomainHandle,
    _In_ DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    _In_ PUNICODE_STRING Prefix,
    _Out_ PULONG Index
    );

// Database replication

typedef enum _SECURITY_DB_DELTA_TYPE
{
    SecurityDbNew = 1,
    SecurityDbRename,
    SecurityDbDelete,
    SecurityDbChangeMemberAdd,
    SecurityDbChangeMemberSet,
    SecurityDbChangeMemberDel,
    SecurityDbChange,
    SecurityDbChangePassword
} SECURITY_DB_DELTA_TYPE, *PSECURITY_DB_DELTA_TYPE;

typedef enum _SECURITY_DB_OBJECT_TYPE
{
    SecurityDbObjectSamDomain = 1,
    SecurityDbObjectSamUser,
    SecurityDbObjectSamGroup,
    SecurityDbObjectSamAlias,
    SecurityDbObjectLsaPolicy,
    SecurityDbObjectLsaTDomain,
    SecurityDbObjectLsaAccount,
    SecurityDbObjectLsaSecret
} SECURITY_DB_OBJECT_TYPE, *PSECURITY_DB_OBJECT_TYPE;

typedef enum _SAM_ACCOUNT_TYPE
{
    SamObjectUser = 1,
    SamObjectGroup,
    SamObjectAlias
} SAM_ACCOUNT_TYPE, *PSAM_ACCOUNT_TYPE;

#define SAM_USER_ACCOUNT (0x00000001)
#define SAM_GLOBAL_GROUP_ACCOUNT (0x00000002)
#define SAM_LOCAL_GROUP_ACCOUNT (0x00000004)

typedef struct _SAM_GROUP_MEMBER_ID
{
    ULONG MemberRid;
} SAM_GROUP_MEMBER_ID, *PSAM_GROUP_MEMBER_ID;

typedef struct _SAM_ALIAS_MEMBER_ID
{
    PSID MemberSid;
} SAM_ALIAS_MEMBER_ID, *PSAM_ALIAS_MEMBER_ID;

typedef union _SAM_DELTA_DATA
{
    SAM_GROUP_MEMBER_ID GroupMemberId;
    SAM_ALIAS_MEMBER_ID AliasMemberId;
    ULONG AccountControl;
} SAM_DELTA_DATA, *PSAM_DELTA_DATA;

typedef NTSTATUS (NTAPI *PSAM_DELTA_NOTIFICATION_ROUTINE)(
    _In_ PSID DomainSid,
    _In_ SECURITY_DB_DELTA_TYPE DeltaType,
    _In_ SECURITY_DB_OBJECT_TYPE ObjectType,
    _In_ ULONG ObjectRid,
    _In_opt_ PUNICODE_STRING ObjectName,
    _In_ PLARGE_INTEGER ModifiedCount,
    _In_opt_ PSAM_DELTA_DATA DeltaData
    );

#define SAM_DELTA_NOTIFY_ROUTINE "DeltaNotify"

_Check_return_
NTSTATUS
NTAPI
SamRegisterObjectChangeNotification(
    _In_ SECURITY_DB_OBJECT_TYPE ObjectType,
    _In_ HANDLE NotificationEventHandle
    );

NTSTATUS
NTAPI
SamUnregisterObjectChangeNotification(
    _In_ SECURITY_DB_OBJECT_TYPE ObjectType,
    _In_ HANDLE NotificationEventHandle
    );

// Compatibility mode

#define SAM_SID_COMPATIBILITY_ALL 0
#define SAM_SID_COMPATIBILITY_LAX 1
#define SAM_SID_COMPATIBILITY_STRICT 2

_Check_return_
NTSTATUS
NTAPI
SamGetCompatibilityMode(
    _In_ SAM_HANDLE ObjectHandle,
    _Out_ ULONG *Mode
    );

// Password validation

typedef enum _PASSWORD_POLICY_VALIDATION_TYPE
{
    SamValidateAuthentication = 1,
    SamValidatePasswordChange,
    SamValidatePasswordReset
} PASSWORD_POLICY_VALIDATION_TYPE;

typedef struct _SAM_VALIDATE_PASSWORD_HASH
{
    ULONG Length;
    _Field_size_bytes_(Length) PUCHAR Hash;
} SAM_VALIDATE_PASSWORD_HASH, *PSAM_VALIDATE_PASSWORD_HASH;

// Flags for PresentFields in SAM_VALIDATE_PERSISTED_FIELDS

#define SAM_VALIDATE_PASSWORD_LAST_SET 0x00000001
#define SAM_VALIDATE_BAD_PASSWORD_TIME 0x00000002
#define SAM_VALIDATE_LOCKOUT_TIME 0x00000004
#define SAM_VALIDATE_BAD_PASSWORD_COUNT 0x00000008
#define SAM_VALIDATE_PASSWORD_HISTORY_LENGTH 0x00000010
#define SAM_VALIDATE_PASSWORD_HISTORY 0x00000020

typedef struct _SAM_VALIDATE_PERSISTED_FIELDS
{
    ULONG PresentFields;
    LARGE_INTEGER PasswordLastSet;
    LARGE_INTEGER BadPasswordTime;
    LARGE_INTEGER LockoutTime;
    ULONG BadPasswordCount;
    ULONG PasswordHistoryLength;
    _Field_size_bytes_(PasswordHistoryLength) PSAM_VALIDATE_PASSWORD_HASH PasswordHistory;
} SAM_VALIDATE_PERSISTED_FIELDS, *PSAM_VALIDATE_PERSISTED_FIELDS;

typedef enum _SAM_VALIDATE_VALIDATION_STATUS
{
    SamValidateSuccess = 0,
    SamValidatePasswordMustChange,
    SamValidateAccountLockedOut,
    SamValidatePasswordExpired,
    SamValidatePasswordIncorrect,
    SamValidatePasswordIsInHistory,
    SamValidatePasswordTooShort,
    SamValidatePasswordTooLong,
    SamValidatePasswordNotComplexEnough,
    SamValidatePasswordTooRecent,
    SamValidatePasswordFilterError
} SAM_VALIDATE_VALIDATION_STATUS, *PSAM_VALIDATE_VALIDATION_STATUS;

typedef struct _SAM_VALIDATE_STANDARD_OUTPUT_ARG
{
    SAM_VALIDATE_PERSISTED_FIELDS ChangedPersistedFields;
    SAM_VALIDATE_VALIDATION_STATUS ValidationStatus;
} SAM_VALIDATE_STANDARD_OUTPUT_ARG, *PSAM_VALIDATE_STANDARD_OUTPUT_ARG;

typedef struct _SAM_VALIDATE_AUTHENTICATION_INPUT_ARG
{
    SAM_VALIDATE_PERSISTED_FIELDS InputPersistedFields;
    BOOLEAN PasswordMatched;
} SAM_VALIDATE_AUTHENTICATION_INPUT_ARG, *PSAM_VALIDATE_AUTHENTICATION_INPUT_ARG;

typedef struct _SAM_VALIDATE_PASSWORD_CHANGE_INPUT_ARG
{
    SAM_VALIDATE_PERSISTED_FIELDS InputPersistedFields;
    UNICODE_STRING ClearPassword;
    UNICODE_STRING UserAccountName;
    SAM_VALIDATE_PASSWORD_HASH HashedPassword;
    BOOLEAN PasswordMatch; // denotes if the old password supplied by user matched or not
} SAM_VALIDATE_PASSWORD_CHANGE_INPUT_ARG, *PSAM_VALIDATE_PASSWORD_CHANGE_INPUT_ARG;

typedef struct _SAM_VALIDATE_PASSWORD_RESET_INPUT_ARG
{
    SAM_VALIDATE_PERSISTED_FIELDS InputPersistedFields;
    UNICODE_STRING ClearPassword;
    UNICODE_STRING UserAccountName;
    SAM_VALIDATE_PASSWORD_HASH HashedPassword;
    BOOLEAN PasswordMustChangeAtNextLogon; // looked at only for password reset
    BOOLEAN ClearLockout; // can be used clear user account lockout
}SAM_VALIDATE_PASSWORD_RESET_INPUT_ARG, *PSAM_VALIDATE_PASSWORD_RESET_INPUT_ARG;

typedef union _SAM_VALIDATE_INPUT_ARG
{
    SAM_VALIDATE_AUTHENTICATION_INPUT_ARG ValidateAuthenticationInput;
    SAM_VALIDATE_PASSWORD_CHANGE_INPUT_ARG ValidatePasswordChangeInput;
    SAM_VALIDATE_PASSWORD_RESET_INPUT_ARG ValidatePasswordResetInput;
} SAM_VALIDATE_INPUT_ARG, *PSAM_VALIDATE_INPUT_ARG;

typedef union _SAM_VALIDATE_OUTPUT_ARG
{
    SAM_VALIDATE_STANDARD_OUTPUT_ARG ValidateAuthenticationOutput;
    SAM_VALIDATE_STANDARD_OUTPUT_ARG ValidatePasswordChangeOutput;
    SAM_VALIDATE_STANDARD_OUTPUT_ARG ValidatePasswordResetOutput;
} SAM_VALIDATE_OUTPUT_ARG, *PSAM_VALIDATE_OUTPUT_ARG;

_Check_return_
NTSTATUS
NTAPI
SamValidatePassword(
    _In_opt_ PUNICODE_STRING ServerName,
    _In_ PASSWORD_POLICY_VALIDATION_TYPE ValidationType,
    _In_ PSAM_VALIDATE_INPUT_ARG InputArg,
    _Out_ PSAM_VALIDATE_OUTPUT_ARG *OutputArg
    );

// Generic operation

typedef enum _SAM_GENERIC_OPERATION_TYPE
{
    SamObjectChangeNotificationOperation
} SAM_GENERIC_OPERATION_TYPE, *PSAM_GENERIC_OPERATION_TYPE;

typedef struct _SAM_OPERATION_OBJCHG_INPUT
{
    BOOLEAN Register;
    ULONG64 EventHandle;
    SECURITY_DB_OBJECT_TYPE ObjectType;
    ULONG ProcessID;
} SAM_OPERATION_OBJCHG_INPUT, *PSAM_OPERATION_OBJCHG_INPUT;

typedef struct _SAM_OPERATION_OBJCHG_OUTPUT
{
    ULONG Reserved;
} SAM_OPERATION_OBJCHG_OUTPUT, *PSAM_OPERATION_OBJCHG_OUTPUT;

typedef union _SAM_GENERIC_OPERATION_INPUT
{
    SAM_OPERATION_OBJCHG_INPUT ObjChangeIn;
} SAM_GENERIC_OPERATION_INPUT, *PSAM_GENERIC_OPERATION_INPUT;

typedef union _SAM_GENERIC_OPERATION_OUTPUT
{
    SAM_OPERATION_OBJCHG_OUTPUT ObjChangeOut;
} SAM_GENERIC_OPERATION_OUTPUT, *PSAM_GENERIC_OPERATION_OUTPUT;

_Check_return_
NTSTATUS
NTAPI
SamPerformGenericOperation(
    _In_opt_ PWSTR ServerName,
    _In_ SAM_GENERIC_OPERATION_TYPE OperationType,
    _In_ PSAM_GENERIC_OPERATION_INPUT OperationIn,
    _Out_ PSAM_GENERIC_OPERATION_OUTPUT *OperationOut
    );

#endif

```

`phnt/ntseapi.h`:

```h
/*
 * Process Hacker -
 *   Authorization functions
 *
 * This file is part of Process Hacker.
 *
 * Process Hacker is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Process Hacker is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Process Hacker.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef _NTSEAPI_H
#define _NTSEAPI_H

// Privileges

#define SE_MIN_WELL_KNOWN_PRIVILEGE (2L)
#define SE_CREATE_TOKEN_PRIVILEGE (2L)
#define SE_ASSIGNPRIMARYTOKEN_PRIVILEGE (3L)
#define SE_LOCK_MEMORY_PRIVILEGE (4L)
#define SE_INCREASE_QUOTA_PRIVILEGE (5L)

#define SE_MACHINE_ACCOUNT_PRIVILEGE (6L)
#define SE_TCB_PRIVILEGE (7L)
#define SE_SECURITY_PRIVILEGE (8L)
#define SE_TAKE_OWNERSHIP_PRIVILEGE (9L)
#define SE_LOAD_DRIVER_PRIVILEGE (10L)
#define SE_SYSTEM_PROFILE_PRIVILEGE (11L)
#define SE_SYSTEMTIME_PRIVILEGE (12L)
#define SE_PROF_SINGLE_PROCESS_PRIVILEGE (13L)
#define SE_INC_BASE_PRIORITY_PRIVILEGE (14L)
#define SE_CREATE_PAGEFILE_PRIVILEGE (15L)
#define SE_CREATE_PERMANENT_PRIVILEGE (16L)
#define SE_BACKUP_PRIVILEGE (17L)
#define SE_RESTORE_PRIVILEGE (18L)
#define SE_SHUTDOWN_PRIVILEGE (19L)
#define SE_DEBUG_PRIVILEGE (20L)
#define SE_AUDIT_PRIVILEGE (21L)
#define SE_SYSTEM_ENVIRONMENT_PRIVILEGE (22L)
#define SE_CHANGE_NOTIFY_PRIVILEGE (23L)
#define SE_REMOTE_SHUTDOWN_PRIVILEGE (24L)
#define SE_UNDOCK_PRIVILEGE (25L)
#define SE_SYNC_AGENT_PRIVILEGE (26L)
#define SE_ENABLE_DELEGATION_PRIVILEGE (27L)
#define SE_MANAGE_VOLUME_PRIVILEGE (28L)
#define SE_IMPERSONATE_PRIVILEGE (29L)
#define SE_CREATE_GLOBAL_PRIVILEGE (30L)
#define SE_TRUSTED_CREDMAN_ACCESS_PRIVILEGE (31L)
#define SE_RELABEL_PRIVILEGE (32L)
#define SE_INC_WORKING_SET_PRIVILEGE (33L)
#define SE_TIME_ZONE_PRIVILEGE (34L)
#define SE_CREATE_SYMBOLIC_LINK_PRIVILEGE (35L)
#define SE_DELEGATE_SESSION_USER_IMPERSONATE_PRIVILEGE (36L)
#define SE_MAX_WELL_KNOWN_PRIVILEGE SE_DELEGATE_SESSION_USER_IMPERSONATE_PRIVILEGE

// Authz

// begin_rev

// Types

#define TOKEN_SECURITY_ATTRIBUTE_TYPE_INVALID 0x00
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_INT64 0x01
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_UINT64 0x02
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_STRING 0x03
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_FQBN 0x04
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_SID 0x05
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_BOOLEAN 0x06
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_OCTET_STRING 0x10

// Flags

#define TOKEN_SECURITY_ATTRIBUTE_NON_INHERITABLE 0x0001
#define TOKEN_SECURITY_ATTRIBUTE_VALUE_CASE_SENSITIVE 0x0002
#define TOKEN_SECURITY_ATTRIBUTE_USE_FOR_DENY_ONLY 0x0004
#define TOKEN_SECURITY_ATTRIBUTE_DISABLED_BY_DEFAULT 0x0008
#define TOKEN_SECURITY_ATTRIBUTE_DISABLED 0x0010
#define TOKEN_SECURITY_ATTRIBUTE_MANDATORY 0x0020
#define TOKEN_SECURITY_ATTRIBUTE_COMPARE_IGNORE 0x0040

#define TOKEN_SECURITY_ATTRIBUTE_VALID_FLAGS ( \
    TOKEN_SECURITY_ATTRIBUTE_NON_INHERITABLE | \
    TOKEN_SECURITY_ATTRIBUTE_VALUE_CASE_SENSITIVE | \
    TOKEN_SECURITY_ATTRIBUTE_USE_FOR_DENY_ONLY | \
    TOKEN_SECURITY_ATTRIBUTE_DISABLED_BY_DEFAULT | \
    TOKEN_SECURITY_ATTRIBUTE_DISABLED | \
    TOKEN_SECURITY_ATTRIBUTE_MANDATORY)

#define TOKEN_SECURITY_ATTRIBUTE_CUSTOM_FLAGS 0xffff0000

// end_rev

// private
typedef struct _TOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE
{
    ULONG64 Version;
    UNICODE_STRING Name;
} TOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE, *PTOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE;

// private
typedef struct _TOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE
{
    PVOID pValue;
    ULONG ValueLength;
} TOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE, *PTOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;

// private
typedef struct _TOKEN_SECURITY_ATTRIBUTE_V1
{
    UNICODE_STRING Name;
    USHORT ValueType;
    USHORT Reserved;
    ULONG Flags;
    ULONG ValueCount;
    union
    {
        PLONG64 pInt64;
        PULONG64 pUint64;
        PUNICODE_STRING pString;
        PTOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE pFqbn;
        PTOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE pOctetString;
    } Values;
} TOKEN_SECURITY_ATTRIBUTE_V1, *PTOKEN_SECURITY_ATTRIBUTE_V1;

// rev
#define TOKEN_SECURITY_ATTRIBUTES_INFORMATION_VERSION_V1 1
// rev
#define TOKEN_SECURITY_ATTRIBUTES_INFORMATION_VERSION TOKEN_SECURITY_ATTRIBUTES_INFORMATION_VERSION_V1

// private
typedef struct _TOKEN_SECURITY_ATTRIBUTES_INFORMATION
{
    USHORT Version;
    USHORT Reserved;
    ULONG AttributeCount;
    union
    {
        PTOKEN_SECURITY_ATTRIBUTE_V1 pAttributeV1;
    } Attribute;
} TOKEN_SECURITY_ATTRIBUTES_INFORMATION, *PTOKEN_SECURITY_ATTRIBUTES_INFORMATION;

// rev
typedef struct _TOKEN_PROCESS_TRUST_LEVEL
{
    PSID TrustLevelSid;
} TOKEN_PROCESS_TRUST_LEVEL, *PTOKEN_PROCESS_TRUST_LEVEL;

// Tokens

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateToken(
    _Out_ PHANDLE TokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ TOKEN_TYPE TokenType,
    _In_ PLUID AuthenticationId,
    _In_ PLARGE_INTEGER ExpirationTime,
    _In_ PTOKEN_USER User,
    _In_ PTOKEN_GROUPS Groups,
    _In_ PTOKEN_PRIVILEGES Privileges,
    _In_opt_ PTOKEN_OWNER Owner,
    _In_ PTOKEN_PRIMARY_GROUP PrimaryGroup,
    _In_opt_ PTOKEN_DEFAULT_DACL DefaultDacl,
    _In_ PTOKEN_SOURCE TokenSource
    );

#if (PHNT_VERSION >= PHNT_WIN8)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateLowBoxToken(
    _Out_ PHANDLE TokenHandle,
    _In_ HANDLE ExistingTokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ PSID PackageSid,
    _In_ ULONG CapabilityCount,
    _In_reads_opt_(CapabilityCount) PSID_AND_ATTRIBUTES Capabilities,
    _In_ ULONG HandleCount,
    _In_reads_opt_(HandleCount) HANDLE *Handles
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN8)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateTokenEx(
    _Out_ PHANDLE TokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ TOKEN_TYPE TokenType,
    _In_ PLUID AuthenticationId,
    _In_ PLARGE_INTEGER ExpirationTime,
    _In_ PTOKEN_USER User,
    _In_ PTOKEN_GROUPS Groups,
    _In_ PTOKEN_PRIVILEGES Privileges,
    _In_opt_ PTOKEN_SECURITY_ATTRIBUTES_INFORMATION UserAttributes,
    _In_opt_ PTOKEN_SECURITY_ATTRIBUTES_INFORMATION DeviceAttributes,
    _In_opt_ PTOKEN_GROUPS DeviceGroups,
    _In_opt_ PTOKEN_MANDATORY_POLICY TokenMandatoryPolicy,
    _In_opt_ PTOKEN_OWNER Owner,
    _In_ PTOKEN_PRIMARY_GROUP PrimaryGroup,
    _In_opt_ PTOKEN_DEFAULT_DACL DefaultDacl,
    _In_ PTOKEN_SOURCE TokenSource
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenProcessToken(
    _In_ HANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE TokenHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenProcessTokenEx(
    _In_ HANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _Out_ PHANDLE TokenHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenThreadToken(
    _In_ HANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ BOOLEAN OpenAsSelf,
    _Out_ PHANDLE TokenHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenThreadTokenEx(
    _In_ HANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ BOOLEAN OpenAsSelf,
    _In_ ULONG HandleAttributes,
    _Out_ PHANDLE TokenHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDuplicateToken(
    _In_ HANDLE ExistingTokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ BOOLEAN EffectiveOnly,
    _In_ TOKEN_TYPE TokenType,
    _Out_ PHANDLE NewTokenHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationToken(
    _In_ HANDLE TokenHandle,
    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,
    _Out_writes_bytes_to_opt_(TokenInformationLength, *ReturnLength) PVOID TokenInformation,
    _In_ ULONG TokenInformationLength,
    _Out_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationToken(
    _In_ HANDLE TokenHandle,
    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,
    _In_reads_bytes_(TokenInformationLength) PVOID TokenInformation,
    _In_ ULONG TokenInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAdjustPrivilegesToken(
    _In_ HANDLE TokenHandle,
    _In_ BOOLEAN DisableAllPrivileges,
    _In_opt_ PTOKEN_PRIVILEGES NewState,
    _In_ ULONG BufferLength,
    _Out_writes_bytes_to_opt_(BufferLength, *ReturnLength) PTOKEN_PRIVILEGES PreviousState,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAdjustGroupsToken(
    _In_ HANDLE TokenHandle,
    _In_ BOOLEAN ResetToDefault,
    _In_opt_ PTOKEN_GROUPS NewState,
    _In_opt_ ULONG BufferLength,
    _Out_writes_bytes_to_opt_(BufferLength, *ReturnLength) PTOKEN_GROUPS PreviousState,
    _Out_opt_ PULONG ReturnLength
    );

#if (PHNT_VERSION >= PHNT_WIN8)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtAdjustTokenClaimsAndDeviceGroups(
    _In_ HANDLE TokenHandle,
    _In_ BOOLEAN UserResetToDefault,
    _In_ BOOLEAN DeviceResetToDefault,
    _In_ BOOLEAN DeviceGroupsResetToDefault,
    _In_opt_ PTOKEN_SECURITY_ATTRIBUTES_INFORMATION NewUserState,
    _In_opt_ PTOKEN_SECURITY_ATTRIBUTES_INFORMATION NewDeviceState,
    _In_opt_ PTOKEN_GROUPS NewDeviceGroupsState,
    _In_ ULONG UserBufferLength,
    _Out_writes_bytes_to_opt_(UserBufferLength, *UserReturnLength) PTOKEN_SECURITY_ATTRIBUTES_INFORMATION PreviousUserState,
    _In_ ULONG DeviceBufferLength,
    _Out_writes_bytes_to_opt_(DeviceBufferLength, *DeviceReturnLength) PTOKEN_SECURITY_ATTRIBUTES_INFORMATION PreviousDeviceState,
    _In_ ULONG DeviceGroupsBufferLength,
    _Out_writes_bytes_to_opt_(DeviceGroupsBufferLength, *DeviceGroupsReturnBufferLength) PTOKEN_GROUPS PreviousDeviceGroups,
    _Out_opt_ PULONG UserReturnLength,
    _Out_opt_ PULONG DeviceReturnLength,
    _Out_opt_ PULONG DeviceGroupsReturnBufferLength
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFilterToken(
    _In_ HANDLE ExistingTokenHandle,
    _In_ ULONG Flags,
    _In_opt_ PTOKEN_GROUPS SidsToDisable,
    _In_opt_ PTOKEN_PRIVILEGES PrivilegesToDelete,
    _In_opt_ PTOKEN_GROUPS RestrictedSids,
    _Out_ PHANDLE NewTokenHandle
    );

#if (PHNT_VERSION >= PHNT_WIN8)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtFilterTokenEx(
    _In_ HANDLE ExistingTokenHandle,
    _In_ ULONG Flags,
    _In_opt_ PTOKEN_GROUPS SidsToDisable,
    _In_opt_ PTOKEN_PRIVILEGES PrivilegesToDelete,
    _In_opt_ PTOKEN_GROUPS RestrictedSids,
    _In_ ULONG DisableUserClaimsCount,
    _In_opt_ PUNICODE_STRING UserClaimsToDisable,
    _In_ ULONG DisableDeviceClaimsCount,
    _In_opt_ PUNICODE_STRING DeviceClaimsToDisable,
    _In_opt_ PTOKEN_GROUPS DeviceGroupsToDisable,
    _In_opt_ PTOKEN_SECURITY_ATTRIBUTES_INFORMATION RestrictedUserAttributes,
    _In_opt_ PTOKEN_SECURITY_ATTRIBUTES_INFORMATION RestrictedDeviceAttributes,
    _In_opt_ PTOKEN_GROUPS RestrictedDeviceGroups,
    _Out_ PHANDLE NewTokenHandle
    );
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCompareTokens(
    _In_ HANDLE FirstTokenHandle,
    _In_ HANDLE SecondTokenHandle,
    _Out_ PBOOLEAN Equal
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPrivilegeCheck(
    _In_ HANDLE ClientToken,
    _Inout_ PPRIVILEGE_SET RequiredPrivileges,
    _Out_ PBOOLEAN Result
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtImpersonateAnonymousToken(
    _In_ HANDLE ThreadHandle
    );

#if (PHNT_VERSION >= PHNT_WIN7)
// rev
NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySecurityAttributesToken(
    _In_ HANDLE TokenHandle,
    _In_reads_opt_(NumberOfAttributes) PUNICODE_STRING Attributes,
    _In_ ULONG NumberOfAttributes,
    _Out_writes_bytes_(Length) PVOID Buffer, // PTOKEN_SECURITY_ATTRIBUTES_INFORMATION
    _In_ ULONG Length,
    _Out_ PULONG ReturnLength
    );
#endif

// Access checking

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAccessCheck(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ PGENERIC_MAPPING GenericMapping,
    _Out_writes_bytes_(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
    _Inout_ PULONG PrivilegeSetLength,
    _Out_ PACCESS_MASK GrantedAccess,
    _Out_ PNTSTATUS AccessStatus
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAccessCheckByType(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PSID PrincipalSelfSid,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_reads_(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    _In_ ULONG ObjectTypeListLength,
    _In_ PGENERIC_MAPPING GenericMapping,
    _Out_writes_bytes_(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
    _Inout_ PULONG PrivilegeSetLength,
    _Out_ PACCESS_MASK GrantedAccess,
    _Out_ PNTSTATUS AccessStatus
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAccessCheckByTypeResultList(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PSID PrincipalSelfSid,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_reads_(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    _In_ ULONG ObjectTypeListLength,
    _In_ PGENERIC_MAPPING GenericMapping,
    _Out_writes_bytes_(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
    _Inout_ PULONG PrivilegeSetLength,
    _Out_writes_(ObjectTypeListLength) PACCESS_MASK GrantedAccess,
    _Out_writes_(ObjectTypeListLength) PNTSTATUS AccessStatus
    );

// Signing

#if (PHNT_VERSION >= PHNT_THRESHOLD)

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetCachedSigningLevel(
    _In_ ULONG Flags,
    _In_ SE_SIGNING_LEVEL InputSigningLevel,
    _In_reads_(SourceFileCount) PHANDLE SourceFiles,
    _In_ ULONG SourceFileCount,
    _In_opt_ HANDLE TargetFile
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtGetCachedSigningLevel(
    _In_ HANDLE File,
    _Out_ PULONG Flags,
    _Out_ PSE_SIGNING_LEVEL SigningLevel,
    _Out_writes_bytes_to_opt_(*ThumbprintSize, *ThumbprintSize) PUCHAR Thumbprint,
    _Inout_opt_ PULONG ThumbprintSize,
    _Out_opt_ PULONG ThumbprintAlgorithm
    );

#endif

// Audit alarm

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAccessCheckAndAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ PUNICODE_STRING ObjectTypeName,
    _In_ PUNICODE_STRING ObjectName,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ PGENERIC_MAPPING GenericMapping,
    _In_ BOOLEAN ObjectCreation,
    _Out_ PACCESS_MASK GrantedAccess,
    _Out_ PNTSTATUS AccessStatus,
    _Out_ PBOOLEAN GenerateOnClose
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAccessCheckByTypeAndAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ PUNICODE_STRING ObjectTypeName,
    _In_ PUNICODE_STRING ObjectName,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PSID PrincipalSelfSid,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ AUDIT_EVENT_TYPE AuditType,
    _In_ ULONG Flags,
    _In_reads_opt_(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    _In_ ULONG ObjectTypeListLength,
    _In_ PGENERIC_MAPPING GenericMapping,
    _In_ BOOLEAN ObjectCreation,
    _Out_ PACCESS_MASK GrantedAccess,
    _Out_ PNTSTATUS AccessStatus,
    _Out_ PBOOLEAN GenerateOnClose
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAccessCheckByTypeResultListAndAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ PUNICODE_STRING ObjectTypeName,
    _In_ PUNICODE_STRING ObjectName,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PSID PrincipalSelfSid,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ AUDIT_EVENT_TYPE AuditType,
    _In_ ULONG Flags,
    _In_reads_opt_(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    _In_ ULONG ObjectTypeListLength,
    _In_ PGENERIC_MAPPING GenericMapping,
    _In_ BOOLEAN ObjectCreation,
    _Out_writes_(ObjectTypeListLength) PACCESS_MASK GrantedAccess,
    _Out_writes_(ObjectTypeListLength) PNTSTATUS AccessStatus,
    _Out_ PBOOLEAN GenerateOnClose
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAccessCheckByTypeResultListAndAuditAlarmByHandle(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ HANDLE ClientToken,
    _In_ PUNICODE_STRING ObjectTypeName,
    _In_ PUNICODE_STRING ObjectName,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PSID PrincipalSelfSid,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ AUDIT_EVENT_TYPE AuditType,
    _In_ ULONG Flags,
    _In_reads_opt_(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    _In_ ULONG ObjectTypeListLength,
    _In_ PGENERIC_MAPPING GenericMapping,
    _In_ BOOLEAN ObjectCreation,
    _Out_writes_(ObjectTypeListLength) PACCESS_MASK GrantedAccess,
    _Out_writes_(ObjectTypeListLength) PNTSTATUS AccessStatus,
    _Out_ PBOOLEAN GenerateOnClose
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenObjectAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ PUNICODE_STRING ObjectTypeName,
    _In_ PUNICODE_STRING ObjectName,
    _In_opt_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ACCESS_MASK GrantedAccess,
    _In_opt_ PPRIVILEGE_SET Privileges,
    _In_ BOOLEAN ObjectCreation,
    _In_ BOOLEAN AccessGranted,
    _Out_ PBOOLEAN GenerateOnClose
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPrivilegeObjectAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ PPRIVILEGE_SET Privileges,
    _In_ BOOLEAN AccessGranted
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCloseObjectAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ BOOLEAN GenerateOnClose
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeleteObjectAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ BOOLEAN GenerateOnClose
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPrivilegedServiceAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_ PUNICODE_STRING ServiceName,
    _In_ HANDLE ClientToken,
    _In_ PPRIVILEGE_SET Privileges,
    _In_ BOOLEAN AccessGranted
    );

#endif

```

`phnt/ntsmss.h`:

```h
#ifndef _NTSMSS_H
#define _NTSMSS_H

NTSYSAPI
NTSTATUS
NTAPI
RtlConnectToSm(
    _In_ PUNICODE_STRING ApiPortName,
    _In_ HANDLE ApiPortHandle,
    _In_ DWORD ProcessImageType,
    _Out_ PHANDLE SmssConnection
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSendMsgToSm(
    _In_ HANDLE ApiPortHandle,
    _In_ PPORT_MESSAGE MessageData
    );

#endif

```

`phnt/nttmapi.h`:

```h
#ifndef _NTTMAPI_H
#define _NTTMAPI_H

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateTransactionManager(
    _Out_ PHANDLE TmHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PUNICODE_STRING LogFileName,
    _In_opt_ ULONG CreateOptions,
    _In_opt_ ULONG CommitStrength
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenTransactionManager(
    _Out_ PHANDLE TmHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PUNICODE_STRING LogFileName,
    _In_opt_ LPGUID TmIdentity,
    _In_opt_ ULONG OpenOptions
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtRenameTransactionManager(
    _In_ PUNICODE_STRING LogFileName,
    _In_ LPGUID ExistingTransactionManagerGuid
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtRollforwardTransactionManager(
    _In_ HANDLE TransactionManagerHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtRecoverTransactionManager(
    _In_ HANDLE TransactionManagerHandle
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationTransactionManager(
    _In_ HANDLE TransactionManagerHandle,
    _In_ TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass,
    _Out_writes_bytes_(TransactionManagerInformationLength) PVOID TransactionManagerInformation,
    _In_ ULONG TransactionManagerInformationLength,
    _Out_opt_ PULONG ReturnLength
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationTransactionManager(
    _In_opt_ HANDLE TmHandle,
    _In_ TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass,
    _In_reads_bytes_(TransactionManagerInformationLength) PVOID TransactionManagerInformation,
    _In_ ULONG TransactionManagerInformationLength
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtEnumerateTransactionObject(
    _In_opt_ HANDLE RootObjectHandle,
    _In_ KTMOBJECT_TYPE QueryType,
    _Inout_updates_bytes_(ObjectCursorLength) PKTMOBJECT_CURSOR ObjectCursor,
    _In_ ULONG ObjectCursorLength,
    _Out_ PULONG ReturnLength
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateTransaction(
    _Out_ PHANDLE TransactionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ LPGUID Uow,
    _In_opt_ HANDLE TmHandle,
    _In_opt_ ULONG CreateOptions,
    _In_opt_ ULONG IsolationLevel,
    _In_opt_ ULONG IsolationFlags,
    _In_opt_ PLARGE_INTEGER Timeout,
    _In_opt_ PUNICODE_STRING Description
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenTransaction(
    _Out_ PHANDLE TransactionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ LPGUID Uow,
    _In_opt_ HANDLE TmHandle
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationTransaction(
    _In_ HANDLE TransactionHandle,
    _In_ TRANSACTION_INFORMATION_CLASS TransactionInformationClass,
    _Out_writes_bytes_(TransactionInformationLength) PVOID TransactionInformation,
    _In_ ULONG TransactionInformationLength,
    _Out_opt_ PULONG ReturnLength
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationTransaction(
    _In_ HANDLE TransactionHandle,
    _In_ TRANSACTION_INFORMATION_CLASS TransactionInformationClass,
    _In_reads_bytes_(TransactionInformationLength) PVOID TransactionInformation,
    _In_ ULONG TransactionInformationLength
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCommitTransaction(
    _In_ HANDLE TransactionHandle,
    _In_ BOOLEAN Wait
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtRollbackTransaction(
    _In_ HANDLE TransactionHandle,
    _In_ BOOLEAN Wait
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateEnlistment(
    _Out_ PHANDLE EnlistmentHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE ResourceManagerHandle,
    _In_ HANDLE TransactionHandle,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ ULONG CreateOptions,
    _In_ NOTIFICATION_MASK NotificationMask,
    _In_opt_ PVOID EnlistmentKey
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenEnlistment(
    _Out_ PHANDLE EnlistmentHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE ResourceManagerHandle,
    _In_ LPGUID EnlistmentGuid,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationEnlistment(
    _In_ HANDLE EnlistmentHandle,
    _In_ ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass,
    _Out_writes_bytes_(EnlistmentInformationLength) PVOID EnlistmentInformation,
    _In_ ULONG EnlistmentInformationLength,
    _Out_opt_ PULONG ReturnLength
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationEnlistment(
    _In_opt_ HANDLE EnlistmentHandle,
    _In_ ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass,
    _In_reads_bytes_(EnlistmentInformationLength) PVOID EnlistmentInformation,
    _In_ ULONG EnlistmentInformationLength
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtRecoverEnlistment(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PVOID EnlistmentKey
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtPrePrepareEnlistment(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtPrepareEnlistment(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCommitEnlistment(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtRollbackEnlistment(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtPrePrepareComplete(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtPrepareComplete(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCommitComplete(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtReadOnlyEnlistment(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtRollbackComplete(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtSinglePhaseReject(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateResourceManager(
    _Out_ PHANDLE ResourceManagerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE TmHandle,
    _In_ LPGUID RmGuid,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ ULONG CreateOptions,
    _In_opt_ PUNICODE_STRING Description
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenResourceManager(
    _Out_ PHANDLE ResourceManagerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE TmHandle,
    _In_opt_ LPGUID ResourceManagerGuid,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtRecoverResourceManager(
    _In_ HANDLE ResourceManagerHandle
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtGetNotificationResourceManager(
    _In_ HANDLE ResourceManagerHandle,
    _Out_ PTRANSACTION_NOTIFICATION TransactionNotification,
    _In_ ULONG NotificationLength,
    _In_opt_ PLARGE_INTEGER Timeout,
    _Out_opt_ PULONG ReturnLength,
    _In_ ULONG Asynchronous,
    _In_opt_ ULONG_PTR AsynchronousContext
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationResourceManager(
    _In_ HANDLE ResourceManagerHandle,
    _In_ RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass,
    _Out_writes_bytes_(ResourceManagerInformationLength) PVOID ResourceManagerInformation,
    _In_ ULONG ResourceManagerInformationLength,
    _Out_opt_ PULONG ReturnLength
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationResourceManager(
    _In_ HANDLE ResourceManagerHandle,
    _In_ RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass,
    _In_reads_bytes_(ResourceManagerInformationLength) PVOID ResourceManagerInformation,
    _In_ ULONG ResourceManagerInformationLength
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtRegisterProtocolAddressInformation(
    _In_ HANDLE ResourceManager,
    _In_ PCRM_PROTOCOL_ID ProtocolId,
    _In_ ULONG ProtocolInformationSize,
    _In_ PVOID ProtocolInformation,
    _In_opt_ ULONG CreateOptions
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtPropagationComplete(
    _In_ HANDLE ResourceManagerHandle,
    _In_ ULONG RequestCookie,
    _In_ ULONG BufferLength,
    _In_ PVOID Buffer
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
NtPropagationFailed(
    _In_ HANDLE ResourceManagerHandle,
    _In_ ULONG RequestCookie,
    _In_ NTSTATUS PropStatus
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSCALLAPI
NTSTATUS
NTAPI
NtFreezeTransactions(
    _In_ PLARGE_INTEGER FreezeTimeout,
    _In_ PLARGE_INTEGER ThawTimeout
    );
#endif

#if (PHNT_VERSION >= PHNT_VISTA)
// private
NTSYSCALLAPI
NTSTATUS
NTAPI
NtThawTransactions(
    VOID
    );
#endif

#endif

```

`phnt/nttp.h`:

```h
#ifndef _NTTP_H
#define _NTTP_H

// Some types are already defined in winnt.h.

typedef struct _TP_ALPC TP_ALPC, *PTP_ALPC;

// private
typedef VOID (NTAPI *PTP_ALPC_CALLBACK)(
    _Inout_ PTP_CALLBACK_INSTANCE Instance,
    _Inout_opt_ PVOID Context,
    _In_ PTP_ALPC Alpc
    );

// rev
typedef VOID (NTAPI *PTP_ALPC_CALLBACK_EX)(
    _Inout_ PTP_CALLBACK_INSTANCE Instance,
    _Inout_opt_ PVOID Context,
    _In_ PTP_ALPC Alpc,
    _In_ PVOID ApcContext
    );

#if (PHNT_VERSION >= PHNT_VISTA)

// private
_Check_return_
NTSYSAPI
NTSTATUS
NTAPI
TpAllocPool(
    _Out_ PTP_POOL *PoolReturn,
    _Reserved_ PVOID Reserved
    );

// winbase:CloseThreadpool
NTSYSAPI
VOID
NTAPI
TpReleasePool(
    _Inout_ PTP_POOL Pool
    );

// winbase:SetThreadpoolThreadMaximum
NTSYSAPI
VOID
NTAPI
TpSetPoolMaxThreads(
    _Inout_ PTP_POOL Pool,
    _In_ ULONG MaxThreads
    );

// private
NTSYSAPI
NTSTATUS
NTAPI
TpSetPoolMinThreads(
    _Inout_ PTP_POOL Pool,
    _In_ ULONG MinThreads
    );

#if (PHNT_VERSION >= PHNT_WIN7)
// rev
NTSYSAPI
NTSTATUS
NTAPI
TpQueryPoolStackInformation(
    _In_ PTP_POOL Pool,
    _Out_ PTP_POOL_STACK_INFORMATION PoolStackInformation
    );
#endif

#if (PHNT_VERSION >= PHNT_WIN7)
// rev
NTSYSAPI
NTSTATUS
NTAPI
TpSetPoolStackInformation(
    _Inout_ PTP_POOL Pool,
    _In_ PTP_POOL_STACK_INFORMATION PoolStackInformation
    );
#endif

// private
_Check_return_
NTSYSAPI
NTSTATUS
NTAPI
TpAllocCleanupGroup(
    _Out_ PTP_CLEANUP_GROUP *CleanupGroupReturn
    );

// winbase:CloseThreadpoolCleanupGroup
NTSYSAPI
VOID
NTAPI
TpReleaseCleanupGroup(
    _Inout_ PTP_CLEANUP_GROUP CleanupGroup
    );

// winbase:CloseThreadpoolCleanupGroupMembers
NTSYSAPI
VOID
NTAPI
TpReleaseCleanupGroupMembers(
    _Inout_ PTP_CLEANUP_GROUP CleanupGroup,
    _In_ LOGICAL CancelPendingCallbacks,
    _Inout_opt_ PVOID CleanupParameter
    );

// winbase:SetEventWhenCallbackReturns
NTSYSAPI
VOID
NTAPI
TpCallbackSetEventOnCompletion(
    _Inout_ PTP_CALLBACK_INSTANCE Instance,
    _In_ HANDLE Event
    );

// winbase:ReleaseSemaphoreWhenCallbackReturns
NTSYSAPI
VOID
NTAPI
TpCallbackReleaseSemaphoreOnCompletion(
    _Inout_ PTP_CALLBACK_INSTANCE Instance,
    _In_ HANDLE Semaphore,
    _In_ ULONG ReleaseCount
    );

// winbase:ReleaseMutexWhenCallbackReturns
NTSYSAPI
VOID
NTAPI
TpCallbackReleaseMutexOnCompletion(
    _Inout_ PTP_CALLBACK_INSTANCE Instance,
    _In_ HANDLE Mutex
    );

// winbase:LeaveCriticalSectionWhenCallbackReturns
NTSYSAPI
VOID
NTAPI
TpCallbackLeaveCriticalSectionOnCompletion(
    _Inout_ PTP_CALLBACK_INSTANCE Instance,
    _Inout_ PRTL_CRITICAL_SECTION CriticalSection
    );

// winbase:FreeLibraryWhenCallbackReturns
NTSYSAPI
VOID
NTAPI
TpCallbackUnloadDllOnCompletion(
    _Inout_ PTP_CALLBACK_INSTANCE Instance,
    _In_ PVOID DllHandle
    );

// winbase:CallbackMayRunLong
NTSYSAPI
NTSTATUS
NTAPI
TpCallbackMayRunLong(
    _Inout_ PTP_CALLBACK_INSTANCE Instance
    );

// winbase:DisassociateCurrentThreadFromCallback
NTSYSAPI
VOID
NTAPI
TpDisassociateCallback(
    _Inout_ PTP_CALLBACK_INSTANCE Instance
    );

// winbase:TrySubmitThreadpoolCallback
_Check_return_
NTSYSAPI
NTSTATUS
NTAPI
TpSimpleTryPost(
    _In_ PTP_SIMPLE_CALLBACK Callback,
    _Inout_opt_ PVOID Context,
    _In_opt_ PTP_CALLBACK_ENVIRON CallbackEnviron
    );

// private
_Check_return_
NTSYSAPI
NTSTATUS
NTAPI
TpAllocWork(
    _Out_ PTP_WORK *WorkReturn,
    _In_ PTP_WORK_CALLBACK Callback,
    _Inout_opt_ PVOID Context,
    _In_opt_ PTP_CALLBACK_ENVIRON CallbackEnviron
    );

// winbase:CloseThreadpoolWork
NTSYSAPI
VOID
NTAPI
TpReleaseWork(
    _Inout_ PTP_WORK Work
    );

// winbase:SubmitThreadpoolWork
NTSYSAPI
VOID
NTAPI
TpPostWork(
    _Inout_ PTP_WORK Work
    );

// winbase:WaitForThreadpoolWorkCallbacks
NTSYSAPI
VOID
NTAPI
TpWaitForWork(
    _Inout_ PTP_WORK Work,
    _In_ LOGICAL CancelPendingCallbacks
    );

// private
_Check_return_
NTSYSAPI
NTSTATUS
NTAPI
TpAllocTimer(
    _Out_ PTP_TIMER *Timer,
    _In_ PTP_TIMER_CALLBACK Callback,
    _Inout_opt_ PVOID Context,
    _In_opt_ PTP_CALLBACK_ENVIRON CallbackEnviron
    );

// winbase:CloseThreadpoolTimer
NTSYSAPI
VOID
NTAPI
TpReleaseTimer(
    _Inout_ PTP_TIMER Timer
    );

// winbase:SetThreadpoolTimer
NTSYSAPI
VOID
NTAPI
TpSetTimer(
    _Inout_ PTP_TIMER Timer,
    _In_opt_ PLARGE_INTEGER DueTime,
    _In_ ULONG Period,
    _In_opt_ ULONG WindowLength
    );

#if (PHNT_VERSION >= PHNT_WIN7)
// winbase:SetThreadpoolTimerEx
NTSYSAPI
NTSTATUS
NTAPI
TpSetTimerEx(
    _Inout_ PTP_TIMER Timer,
    _In_opt_ PLARGE_INTEGER DueTime,
    _In_ ULONG Period,
    _In_opt_ ULONG WindowLength
    );
#endif

// winbase:IsThreadpoolTimerSet
NTSYSAPI
LOGICAL
NTAPI
TpIsTimerSet(
    _In_ PTP_TIMER Timer
    );

// winbase:WaitForThreadpoolTimerCallbacks
NTSYSAPI
VOID
NTAPI
TpWaitForTimer(
    _Inout_ PTP_TIMER Timer,
    _In_ LOGICAL CancelPendingCallbacks
    );

// private
_Check_return_
NTSYSAPI
NTSTATUS
NTAPI
TpAllocWait(
    _Out_ PTP_WAIT *WaitReturn,
    _In_ PTP_WAIT_CALLBACK Callback,
    _Inout_opt_ PVOID Context,
    _In_opt_ PTP_CALLBACK_ENVIRON CallbackEnviron
    );

// winbase:CloseThreadpoolWait
NTSYSAPI
VOID
NTAPI
TpReleaseWait(
    _Inout_ PTP_WAIT Wait
    );

// winbase:SetThreadpoolWait
NTSYSAPI
VOID
NTAPI
TpSetWait(
    _Inout_ PTP_WAIT Wait,
    _In_opt_ HANDLE Handle,
    _In_opt_ PLARGE_INTEGER Timeout
    );

#if (PHNT_VERSION >= PHNT_WIN7)
// winbase:SetThreadpoolWaitEx
NTSYSAPI
NTSTATUS
NTAPI
TpSetWaitEx(
    _Inout_ PTP_WAIT Wait,
    _In_opt_ HANDLE Handle,
    _In_opt_ PLARGE_INTEGER Timeout,
    _In_opt_ PVOID Reserved
    );
#endif

// winbase:WaitForThreadpoolWaitCallbacks
NTSYSAPI
VOID
NTAPI
TpWaitForWait(
    _Inout_ PTP_WAIT Wait,
    _In_ LOGICAL CancelPendingCallbacks
    );

// private
typedef VOID (NTAPI *PTP_IO_CALLBACK)(
    _Inout_ PTP_CALLBACK_INSTANCE Instance,
    _Inout_opt_ PVOID Context,
    _In_ PVOID ApcContext,
    _In_ PIO_STATUS_BLOCK IoSB,
    _In_ PTP_IO Io
    );

// private
_Check_return_
NTSYSAPI
NTSTATUS
NTAPI
TpAllocIoCompletion(
    _Out_ PTP_IO *IoReturn,
    _In_ HANDLE File,
    _In_ PTP_IO_CALLBACK Callback,
    _Inout_opt_ PVOID Context,
    _In_opt_ PTP_CALLBACK_ENVIRON CallbackEnviron
    );

// winbase:CloseThreadpoolIo
NTSYSAPI
VOID
NTAPI
TpReleaseIoCompletion(
    _Inout_ PTP_IO Io
    );

// winbase:StartThreadpoolIo
NTSYSAPI
VOID
NTAPI
TpStartAsyncIoOperation(
    _Inout_ PTP_IO Io
    );

// winbase:CancelThreadpoolIo
NTSYSAPI
VOID
NTAPI
TpCancelAsyncIoOperation(
    _Inout_ PTP_IO Io
    );

// winbase:WaitForThreadpoolIoCallbacks
NTSYSAPI
VOID
NTAPI
TpWaitForIoCompletion(
    _Inout_ PTP_IO Io,
    _In_ LOGICAL CancelPendingCallbacks
    );

// private
NTSYSAPI
NTSTATUS
NTAPI
TpAllocAlpcCompletion(
    _Out_ PTP_ALPC *AlpcReturn,
    _In_ HANDLE AlpcPort,
    _In_ PTP_ALPC_CALLBACK Callback,
    _Inout_opt_ PVOID Context,
    _In_opt_ PTP_CALLBACK_ENVIRON CallbackEnviron
    );

#if (PHNT_VERSION >= PHNT_WIN7)
// rev
NTSYSAPI
NTSTATUS
NTAPI
TpAllocAlpcCompletionEx(
    _Out_ PTP_ALPC *AlpcReturn,
    _In_ HANDLE AlpcPort,
    _In_ PTP_ALPC_CALLBACK_EX Callback,
    _Inout_opt_ PVOID Context,
    _In_opt_ PTP_CALLBACK_ENVIRON CallbackEnviron
    );
#endif

// private
NTSYSAPI
VOID
NTAPI
TpReleaseAlpcCompletion(
    _Inout_ PTP_ALPC Alpc
    );

// private
NTSYSAPI
VOID
NTAPI
TpWaitForAlpcCompletion(
    _Inout_ PTP_ALPC Alpc
    );

// private
typedef enum _TP_TRACE_TYPE
{
    TpTraceThreadPriority = 1,
    TpTraceThreadAffinity,
    MaxTpTraceType
} TP_TRACE_TYPE;

// private
NTSYSAPI
VOID
NTAPI
TpCaptureCaller(
    _In_ TP_TRACE_TYPE Type
    );

// private
NTSYSAPI
VOID
NTAPI
TpCheckTerminateWorker(
    _In_ HANDLE Thread
    );

#endif

#endif

```

`phnt/ntwow64.h`:

```h
#ifndef _NTWOW64_H
#define _NTWOW64_H

#define WOW64_SYSTEM_DIRECTORY "SysWOW64"
#define WOW64_SYSTEM_DIRECTORY_U L"SysWOW64"
#define WOW64_X86_TAG " (x86)"
#define WOW64_X86_TAG_U L" (x86)"

// In USER_SHARED_DATA
typedef enum _WOW64_SHARED_INFORMATION
{
    SharedNtdll32LdrInitializeThunk,
    SharedNtdll32KiUserExceptionDispatcher,
    SharedNtdll32KiUserApcDispatcher,
    SharedNtdll32KiUserCallbackDispatcher,
    SharedNtdll32ExpInterlockedPopEntrySListFault,
    SharedNtdll32ExpInterlockedPopEntrySListResume,
    SharedNtdll32ExpInterlockedPopEntrySListEnd,
    SharedNtdll32RtlUserThreadStart,
    SharedNtdll32pQueryProcessDebugInformationRemote,
    SharedNtdll32BaseAddress,
    SharedNtdll32LdrSystemDllInitBlock,
    Wow64SharedPageEntriesCount
} WOW64_SHARED_INFORMATION;

// 32-bit definitions

#define WOW64_POINTER(Type) ULONG

typedef struct _RTL_BALANCED_NODE32
{
    union
    {
        WOW64_POINTER(struct _RTL_BALANCED_NODE *) Children[2];
        struct
        {
            WOW64_POINTER(struct _RTL_BALANCED_NODE *) Left;
            WOW64_POINTER(struct _RTL_BALANCED_NODE *) Right;
        };
    };
    union
    {
        WOW64_POINTER(UCHAR) Red : 1;
        WOW64_POINTER(UCHAR) Balance : 2;
        WOW64_POINTER(ULONG_PTR) ParentValue;
    };
} RTL_BALANCED_NODE32, *PRTL_BALANCED_NODE32;

typedef struct _RTL_RB_TREE32
{
    WOW64_POINTER(PRTL_BALANCED_NODE) Root;
    WOW64_POINTER(PRTL_BALANCED_NODE) Min;
} RTL_RB_TREE32, *PRTL_RB_TREE32;

typedef struct _PEB_LDR_DATA32
{
    ULONG Length;
    BOOLEAN Initialized;
    WOW64_POINTER(HANDLE) SsHandle;
    LIST_ENTRY32 InLoadOrderModuleList;
    LIST_ENTRY32 InMemoryOrderModuleList;
    LIST_ENTRY32 InInitializationOrderModuleList;
    WOW64_POINTER(PVOID) EntryInProgress;
    BOOLEAN ShutdownInProgress;
    WOW64_POINTER(HANDLE) ShutdownThreadId;
} PEB_LDR_DATA32, *PPEB_LDR_DATA32;

typedef struct _LDR_SERVICE_TAG_RECORD32
{
    WOW64_POINTER(struct _LDR_SERVICE_TAG_RECORD *) Next;
    ULONG ServiceTag;
} LDR_SERVICE_TAG_RECORD32, *PLDR_SERVICE_TAG_RECORD32;

typedef struct _LDRP_CSLIST32
{
    WOW64_POINTER(PSINGLE_LIST_ENTRY) Tail;
} LDRP_CSLIST32, *PLDRP_CSLIST32;

typedef struct _LDR_DDAG_NODE32
{
    LIST_ENTRY32 Modules;
    WOW64_POINTER(PLDR_SERVICE_TAG_RECORD) ServiceTagList;
    ULONG LoadCount;
    ULONG LoadWhileUnloadingCount;
    ULONG LowestLink;
    union
    {
        LDRP_CSLIST32 Dependencies;
        SINGLE_LIST_ENTRY32 RemovalLink;
    };
    LDRP_CSLIST32 IncomingDependencies;
    LDR_DDAG_STATE State;
    SINGLE_LIST_ENTRY32 CondenseLink;
    ULONG PreorderNumber;
} LDR_DDAG_NODE32, *PLDR_DDAG_NODE32;

#define LDR_DATA_TABLE_ENTRY_SIZE_WINXP_32 FIELD_OFFSET(LDR_DATA_TABLE_ENTRY32, DdagNode)
#define LDR_DATA_TABLE_ENTRY_SIZE_WIN7_32 FIELD_OFFSET(LDR_DATA_TABLE_ENTRY32, BaseNameHashValue)
#define LDR_DATA_TABLE_ENTRY_SIZE_WIN8_32 FIELD_OFFSET(LDR_DATA_TABLE_ENTRY32, ImplicitPathOptions)

typedef struct _LDR_DATA_TABLE_ENTRY32
{
    LIST_ENTRY32 InLoadOrderLinks;
    LIST_ENTRY32 InMemoryOrderLinks;
    union
    {
        LIST_ENTRY32 InInitializationOrderLinks;
        LIST_ENTRY32 InProgressLinks;
    };
    WOW64_POINTER(PVOID) DllBase;
    WOW64_POINTER(PVOID) EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING32 FullDllName;
    UNICODE_STRING32 BaseDllName;
    union
    {
        UCHAR FlagGroup[4];
        ULONG Flags;
        struct
        {
            ULONG PackagedBinary : 1;
            ULONG MarkedForRemoval : 1;
            ULONG ImageDll : 1;
            ULONG LoadNotificationsSent : 1;
            ULONG TelemetryEntryProcessed : 1;
            ULONG ProcessStaticImport : 1;
            ULONG InLegacyLists : 1;
            ULONG InIndexes : 1;
            ULONG ShimDll : 1;
            ULONG InExceptionTable : 1;
            ULONG ReservedFlags1 : 2;
            ULONG LoadInProgress : 1;
            ULONG LoadConfigProcessed : 1;
            ULONG EntryProcessed : 1;
            ULONG ProtectDelayLoad : 1;
            ULONG ReservedFlags3 : 2;
            ULONG DontCallForThreads : 1;
            ULONG ProcessAttachCalled : 1;
            ULONG ProcessAttachFailed : 1;
            ULONG CorDeferredValidate : 1;
            ULONG CorImage : 1;
            ULONG DontRelocate : 1;
            ULONG CorILOnly : 1;
            ULONG ChpeImage : 1;
            ULONG ReservedFlags5 : 2;
            ULONG Redirected : 1;
            ULONG ReservedFlags6 : 2;
            ULONG CompatDatabaseProcessed : 1;
        };
    };
    USHORT ObsoleteLoadCount;
    USHORT TlsIndex;
    LIST_ENTRY32 HashLinks;
    ULONG TimeDateStamp;
    WOW64_POINTER(struct _ACTIVATION_CONTEXT *) EntryPointActivationContext;
    WOW64_POINTER(PVOID) Lock;
    WOW64_POINTER(PLDR_DDAG_NODE) DdagNode;
    LIST_ENTRY32 NodeModuleLink;
    WOW64_POINTER(struct _LDRP_LOAD_CONTEXT *) LoadContext;
    WOW64_POINTER(PVOID) ParentDllBase;
    WOW64_POINTER(PVOID) SwitchBackContext;
    RTL_BALANCED_NODE32 BaseAddressIndexNode;
    RTL_BALANCED_NODE32 MappingInfoIndexNode;
    WOW64_POINTER(ULONG_PTR) OriginalBase;
    LARGE_INTEGER LoadTime;
    ULONG BaseNameHashValue;
    LDR_DLL_LOAD_REASON LoadReason;
    ULONG ImplicitPathOptions;
    ULONG ReferenceCount;
    ULONG DependentLoadFlags;
    UCHAR SigningLevel; // since REDSTONE2
} LDR_DATA_TABLE_ENTRY32, *PLDR_DATA_TABLE_ENTRY32;

typedef struct _CURDIR32
{
    UNICODE_STRING32 DosPath;
    WOW64_POINTER(HANDLE) Handle;
} CURDIR32, *PCURDIR32;

typedef struct _RTL_DRIVE_LETTER_CURDIR32
{
    USHORT Flags;
    USHORT Length;
    ULONG TimeStamp;
    STRING32 DosPath;
} RTL_DRIVE_LETTER_CURDIR32, *PRTL_DRIVE_LETTER_CURDIR32;

typedef struct _RTL_USER_PROCESS_PARAMETERS32
{
    ULONG MaximumLength;
    ULONG Length;

    ULONG Flags;
    ULONG DebugFlags;

    WOW64_POINTER(HANDLE) ConsoleHandle;
    ULONG ConsoleFlags;
    WOW64_POINTER(HANDLE) StandardInput;
    WOW64_POINTER(HANDLE) StandardOutput;
    WOW64_POINTER(HANDLE) StandardError;

    CURDIR32 CurrentDirectory;
    UNICODE_STRING32 DllPath;
    UNICODE_STRING32 ImagePathName;
    UNICODE_STRING32 CommandLine;
    WOW64_POINTER(PVOID) Environment;

    ULONG StartingX;
    ULONG StartingY;
    ULONG CountX;
    ULONG CountY;
    ULONG CountCharsX;
    ULONG CountCharsY;
    ULONG FillAttribute;

    ULONG WindowFlags;
    ULONG ShowWindowFlags;
    UNICODE_STRING32 WindowTitle;
    UNICODE_STRING32 DesktopInfo;
    UNICODE_STRING32 ShellInfo;
    UNICODE_STRING32 RuntimeData;
    RTL_DRIVE_LETTER_CURDIR32 CurrentDirectories[RTL_MAX_DRIVE_LETTERS];

    WOW64_POINTER(ULONG_PTR) EnvironmentSize;
    WOW64_POINTER(ULONG_PTR) EnvironmentVersion;
    WOW64_POINTER(PVOID) PackageDependencyData;
    ULONG ProcessGroupId;
    ULONG LoaderThreads;

    UNICODE_STRING32 RedirectionDllName; // REDSTONE4
    UNICODE_STRING32 HeapPartitionName; // 19H1
    WOW64_POINTER(ULONG_PTR) DefaultThreadpoolCpuSetMasks;
    ULONG DefaultThreadpoolCpuSetMaskCount;
} RTL_USER_PROCESS_PARAMETERS32, *PRTL_USER_PROCESS_PARAMETERS32;

typedef struct _PEB32
{
    BOOLEAN InheritedAddressSpace;
    BOOLEAN ReadImageFileExecOptions;
    BOOLEAN BeingDebugged;
    union
    {
        BOOLEAN BitField;
        struct
        {
            BOOLEAN ImageUsesLargePages : 1;
            BOOLEAN IsProtectedProcess : 1;
            BOOLEAN IsImageDynamicallyRelocated : 1;
            BOOLEAN SkipPatchingUser32Forwarders : 1;
            BOOLEAN IsPackagedProcess : 1;
            BOOLEAN IsAppContainer : 1;
            BOOLEAN IsProtectedProcessLight : 1;
            BOOLEAN IsLongPathAwareProcess : 1;
        };
    };
    WOW64_POINTER(HANDLE) Mutant;

    WOW64_POINTER(PVOID) ImageBaseAddress;
    WOW64_POINTER(PPEB_LDR_DATA) Ldr;
    WOW64_POINTER(PRTL_USER_PROCESS_PARAMETERS) ProcessParameters;
    WOW64_POINTER(PVOID) SubSystemData;
    WOW64_POINTER(PVOID) ProcessHeap;
    WOW64_POINTER(PRTL_CRITICAL_SECTION) FastPebLock;
    WOW64_POINTER(PVOID) AtlThunkSListPtr;
    WOW64_POINTER(PVOID) IFEOKey;
    union
    {
        ULONG CrossProcessFlags;
        struct
        {
            ULONG ProcessInJob : 1;
            ULONG ProcessInitializing : 1;
            ULONG ProcessUsingVEH : 1;
            ULONG ProcessUsingVCH : 1;
            ULONG ProcessUsingFTH : 1;
            ULONG ReservedBits0 : 27;
        };
    };
    union
    {
        WOW64_POINTER(PVOID) KernelCallbackTable;
        WOW64_POINTER(PVOID) UserSharedInfoPtr;
    };
    ULONG SystemReserved;
    ULONG AtlThunkSListPtr32;
    WOW64_POINTER(PVOID) ApiSetMap;
    ULONG TlsExpansionCounter;
    WOW64_POINTER(PVOID) TlsBitmap;
    ULONG TlsBitmapBits[2];
    WOW64_POINTER(PVOID) ReadOnlySharedMemoryBase;
    WOW64_POINTER(PVOID) HotpatchInformation;
    WOW64_POINTER(PVOID *) ReadOnlyStaticServerData;
    WOW64_POINTER(PVOID) AnsiCodePageData;
    WOW64_POINTER(PVOID) OemCodePageData;
    WOW64_POINTER(PVOID) UnicodeCaseTableData;

    ULONG NumberOfProcessors;
    ULONG NtGlobalFlag;

    LARGE_INTEGER CriticalSectionTimeout;
    WOW64_POINTER(SIZE_T) HeapSegmentReserve;
    WOW64_POINTER(SIZE_T) HeapSegmentCommit;
    WOW64_POINTER(SIZE_T) HeapDeCommitTotalFreeThreshold;
    WOW64_POINTER(SIZE_T) HeapDeCommitFreeBlockThreshold;

    ULONG NumberOfHeaps;
    ULONG MaximumNumberOfHeaps;
    WOW64_POINTER(PVOID *) ProcessHeaps;

    WOW64_POINTER(PVOID) GdiSharedHandleTable;
    WOW64_POINTER(PVOID) ProcessStarterHelper;
    ULONG GdiDCAttributeList;

    WOW64_POINTER(PRTL_CRITICAL_SECTION) LoaderLock;

    ULONG OSMajorVersion;
    ULONG OSMinorVersion;
    USHORT OSBuildNumber;
    USHORT OSCSDVersion;
    ULONG OSPlatformId;
    ULONG ImageSubsystem;
    ULONG ImageSubsystemMajorVersion;
    ULONG ImageSubsystemMinorVersion;
    WOW64_POINTER(ULONG_PTR) ActiveProcessAffinityMask;
    GDI_HANDLE_BUFFER32 GdiHandleBuffer;
    WOW64_POINTER(PVOID) PostProcessInitRoutine;

    WOW64_POINTER(PVOID) TlsExpansionBitmap;
    ULONG TlsExpansionBitmapBits[32];

    ULONG SessionId;

    ULARGE_INTEGER AppCompatFlags;
    ULARGE_INTEGER AppCompatFlagsUser;
    WOW64_POINTER(PVOID) pShimData;
    WOW64_POINTER(PVOID) AppCompatInfo;

    UNICODE_STRING32 CSDVersion;

    WOW64_POINTER(PVOID) ActivationContextData;
    WOW64_POINTER(PVOID) ProcessAssemblyStorageMap;
    WOW64_POINTER(PVOID) SystemDefaultActivationContextData;
    WOW64_POINTER(PVOID) SystemAssemblyStorageMap;

    WOW64_POINTER(SIZE_T) MinimumStackCommit;

    WOW64_POINTER(PVOID) SparePointers[4];
    ULONG SpareUlongs[5];
    //WOW64_POINTER(PVOID *) FlsCallback;
    //LIST_ENTRY32 FlsListHead;
    //WOW64_POINTER(PVOID) FlsBitmap;
    //ULONG FlsBitmapBits[FLS_MAXIMUM_AVAILABLE / (sizeof(ULONG) * 8)];
    //ULONG FlsHighIndex;

    WOW64_POINTER(PVOID) WerRegistrationData;
    WOW64_POINTER(PVOID) WerShipAssertPtr;
    WOW64_POINTER(PVOID) pContextData;
    WOW64_POINTER(PVOID) pImageHeaderHash;
    union
    {
        ULONG TracingFlags;
        struct
        {
            ULONG HeapTracingEnabled : 1;
            ULONG CritSecTracingEnabled : 1;
            ULONG LibLoaderTracingEnabled : 1;
            ULONG SpareTracingBits : 29;
        };
    };
    ULONGLONG CsrServerReadOnlySharedMemoryBase;
    WOW64_POINTER(PVOID) TppWorkerpListLock;
    LIST_ENTRY32 TppWorkerpList;
    WOW64_POINTER(PVOID) WaitOnAddressHashTable[128];
    WOW64_POINTER(PVOID) TelemetryCoverageHeader; // REDSTONE3
    ULONG CloudFileFlags;
    ULONG CloudFileDiagFlags; // REDSTONE4
    CHAR PlaceholderCompatibilityMode;
    CHAR PlaceholderCompatibilityModeReserved[7];
} PEB32, *PPEB32;

C_ASSERT(FIELD_OFFSET(PEB32, IFEOKey) == 0x024);
C_ASSERT(FIELD_OFFSET(PEB32, UnicodeCaseTableData) == 0x060);
C_ASSERT(FIELD_OFFSET(PEB32, SystemAssemblyStorageMap) == 0x204);
C_ASSERT(FIELD_OFFSET(PEB32, pImageHeaderHash) == 0x23c);
C_ASSERT(FIELD_OFFSET(PEB32, WaitOnAddressHashTable) == 0x25c);
//C_ASSERT(sizeof(PEB32) == 0x460); // REDSTONE3
C_ASSERT(sizeof(PEB32) == 0x470);

#define GDI_BATCH_BUFFER_SIZE 310

typedef struct _GDI_TEB_BATCH32
{
    ULONG Offset;
    WOW64_POINTER(ULONG_PTR) HDC;
    ULONG Buffer[GDI_BATCH_BUFFER_SIZE];
} GDI_TEB_BATCH32, *PGDI_TEB_BATCH32;

typedef struct _TEB32
{
    NT_TIB32 NtTib;

    WOW64_POINTER(PVOID) EnvironmentPointer;
    CLIENT_ID32 ClientId;
    WOW64_POINTER(PVOID) ActiveRpcHandle;
    WOW64_POINTER(PVOID) ThreadLocalStoragePointer;
    WOW64_POINTER(PPEB) ProcessEnvironmentBlock;

    ULONG LastErrorValue;
    ULONG CountOfOwnedCriticalSections;
    WOW64_POINTER(PVOID) CsrClientThread;
    WOW64_POINTER(PVOID) Win32ThreadInfo;
    ULONG User32Reserved[26];
    ULONG UserReserved[5];
    WOW64_POINTER(PVOID) WOW32Reserved;
    LCID CurrentLocale;
    ULONG FpSoftwareStatusRegister;
    WOW64_POINTER(PVOID) ReservedForDebuggerInstrumentation[16];
    WOW64_POINTER(PVOID) SystemReserved1[36];
    UCHAR WorkingOnBehalfTicket[8];
    NTSTATUS ExceptionCode;

    WOW64_POINTER(PVOID) ActivationContextStackPointer;
    WOW64_POINTER(ULONG_PTR) InstrumentationCallbackSp;
    WOW64_POINTER(ULONG_PTR) InstrumentationCallbackPreviousPc;
    WOW64_POINTER(ULONG_PTR) InstrumentationCallbackPreviousSp;
    BOOLEAN InstrumentationCallbackDisabled;
    UCHAR SpareBytes[23];
    ULONG TxFsContext;

    GDI_TEB_BATCH32 GdiTebBatch;
    CLIENT_ID32 RealClientId;
    WOW64_POINTER(HANDLE) GdiCachedProcessHandle;
    ULONG GdiClientPID;
    ULONG GdiClientTID;
    WOW64_POINTER(PVOID) GdiThreadLocalInfo;
    WOW64_POINTER(ULONG_PTR) Win32ClientInfo[62];
    WOW64_POINTER(PVOID) glDispatchTable[233];
    WOW64_POINTER(ULONG_PTR) glReserved1[29];
    WOW64_POINTER(PVOID) glReserved2;
    WOW64_POINTER(PVOID) glSectionInfo;
    WOW64_POINTER(PVOID) glSection;
    WOW64_POINTER(PVOID) glTable;
    WOW64_POINTER(PVOID) glCurrentRC;
    WOW64_POINTER(PVOID) glContext;

    NTSTATUS LastStatusValue;
    UNICODE_STRING32 StaticUnicodeString;
    WCHAR StaticUnicodeBuffer[261];

    WOW64_POINTER(PVOID) DeallocationStack;
    WOW64_POINTER(PVOID) TlsSlots[64];
    LIST_ENTRY32 TlsLinks;

    WOW64_POINTER(PVOID) Vdm;
    WOW64_POINTER(PVOID) ReservedForNtRpc;
    WOW64_POINTER(PVOID) DbgSsReserved[2];

    ULONG HardErrorMode;
    WOW64_POINTER(PVOID) Instrumentation[9];
    GUID ActivityId;

    WOW64_POINTER(PVOID) SubProcessTag;
    WOW64_POINTER(PVOID) PerflibData;
    WOW64_POINTER(PVOID) EtwTraceData;
    WOW64_POINTER(PVOID) WinSockData;
    ULONG GdiBatchCount;

    union
    {
        PROCESSOR_NUMBER CurrentIdealProcessor;
        ULONG IdealProcessorValue;
        struct
        {
            UCHAR ReservedPad0;
            UCHAR ReservedPad1;
            UCHAR ReservedPad2;
            UCHAR IdealProcessor;
        };
    };

    ULONG GuaranteedStackBytes;
    WOW64_POINTER(PVOID) ReservedForPerf;
    WOW64_POINTER(PVOID) ReservedForOle;
    ULONG WaitingOnLoaderLock;
    WOW64_POINTER(PVOID) SavedPriorityState;
    WOW64_POINTER(ULONG_PTR) ReservedForCodeCoverage;
    WOW64_POINTER(PVOID) ThreadPoolData;
    WOW64_POINTER(PVOID *) TlsExpansionSlots;

    ULONG MuiGeneration;
    ULONG IsImpersonating;
    WOW64_POINTER(PVOID) NlsCache;
    WOW64_POINTER(PVOID) pShimData;
    USHORT HeapVirtualAffinity;
    USHORT LowFragHeapDataSlot;
    WOW64_POINTER(HANDLE) CurrentTransactionHandle;
    WOW64_POINTER(PTEB_ACTIVE_FRAME) ActiveFrame;
    WOW64_POINTER(PVOID) FlsData;

    WOW64_POINTER(PVOID) PreferredLanguages;
    WOW64_POINTER(PVOID) UserPrefLanguages;
    WOW64_POINTER(PVOID) MergedPrefLanguages;
    ULONG MuiImpersonation;

    union
    {
        USHORT CrossTebFlags;
        USHORT SpareCrossTebBits : 16;
    };
    union
    {
        USHORT SameTebFlags;
        struct
        {
            USHORT SafeThunkCall : 1;
            USHORT InDebugPrint : 1;
            USHORT HasFiberData : 1;
            USHORT SkipThreadAttach : 1;
            USHORT WerInShipAssertCode : 1;
            USHORT RanProcessInit : 1;
            USHORT ClonedThread : 1;
            USHORT SuppressDebugMsg : 1;
            USHORT DisableUserStackWalk : 1;
            USHORT RtlExceptionAttached : 1;
            USHORT InitialThread : 1;
            USHORT SessionAware : 1;
            USHORT LoadOwner : 1;
            USHORT LoaderWorker : 1;
            USHORT SpareSameTebBits : 2;
        };
    };

    WOW64_POINTER(PVOID) TxnScopeEnterCallback;
    WOW64_POINTER(PVOID) TxnScopeExitCallback;
    WOW64_POINTER(PVOID) TxnScopeContext;
    ULONG LockCount;
    LONG WowTebOffset;
    WOW64_POINTER(PVOID) ResourceRetValue;
    WOW64_POINTER(PVOID) ReservedForWdf;
    ULONGLONG ReservedForCrt;
    GUID EffectiveContainerId;
} TEB32, *PTEB32;

C_ASSERT(FIELD_OFFSET(TEB32, ProcessEnvironmentBlock) == 0x030);
C_ASSERT(FIELD_OFFSET(TEB32, ExceptionCode) == 0x1a4);
C_ASSERT(FIELD_OFFSET(TEB32, TxFsContext) == 0x1d0);
C_ASSERT(FIELD_OFFSET(TEB32, glContext) == 0xbf0);
C_ASSERT(FIELD_OFFSET(TEB32, StaticUnicodeBuffer) == 0xc00);
C_ASSERT(FIELD_OFFSET(TEB32, TlsLinks) == 0xf10);
C_ASSERT(FIELD_OFFSET(TEB32, DbgSsReserved) == 0xf20);
C_ASSERT(FIELD_OFFSET(TEB32, ActivityId) == 0xf50);
C_ASSERT(FIELD_OFFSET(TEB32, GdiBatchCount) == 0xf70);
C_ASSERT(FIELD_OFFSET(TEB32, TlsExpansionSlots) == 0xf94);
C_ASSERT(FIELD_OFFSET(TEB32, FlsData) == 0xfb4);
C_ASSERT(FIELD_OFFSET(TEB32, MuiImpersonation) == 0xfc4);
C_ASSERT(FIELD_OFFSET(TEB32, ReservedForCrt) == 0xfe8);
C_ASSERT(FIELD_OFFSET(TEB32, EffectiveContainerId) == 0xff0);
C_ASSERT(sizeof(TEB32) == 0x1000);

// Conversion

FORCEINLINE VOID UStr32ToUStr(
    _Out_ PUNICODE_STRING Destination,
    _In_ PUNICODE_STRING32 Source
    )
{
    Destination->Length = Source->Length;
    Destination->MaximumLength = Source->MaximumLength;
    Destination->Buffer = (PWCH)UlongToPtr(Source->Buffer);
}

FORCEINLINE VOID UStrToUStr32(
    _Out_ PUNICODE_STRING32 Destination,
    _In_ PUNICODE_STRING Source
    )
{
    Destination->Length = Source->Length;
    Destination->MaximumLength = Source->MaximumLength;
    Destination->Buffer = PtrToUlong(Source->Buffer);
}

#endif

```

`phnt/ntxcapi.h`:

```h
#ifndef _NTXCAPI_H
#define _NTXCAPI_H

NTSYSAPI
BOOLEAN
NTAPI
RtlDispatchException(
    _In_ PEXCEPTION_RECORD ExceptionRecord,
    _In_ PCONTEXT ContextRecord
    );

NTSYSAPI
DECLSPEC_NORETURN
VOID
NTAPI
RtlRaiseStatus(
    _In_ NTSTATUS Status
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtContinue(
    _In_ PCONTEXT ContextRecord,
    _In_ BOOLEAN TestAlert
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRaiseException(
    _In_ PEXCEPTION_RECORD ExceptionRecord,
    _In_ PCONTEXT ContextRecord,
    _In_ BOOLEAN FirstChance
    );

__analysis_noreturn
NTSYSCALLAPI
VOID
NTAPI
RtlAssert(
    _In_ PVOID VoidFailedAssertion,
    _In_ PVOID VoidFileName,
    _In_ ULONG LineNumber,
    _In_opt_ PSTR MutableMessage
    );

#define RTL_ASSERT(exp) \
    ((!(exp)) ? (RtlAssert((PVOID)#exp, (PVOID)__FILE__, __LINE__, NULL), FALSE) : TRUE)
#define RTL_ASSERTMSG(msg, exp) \
    ((!(exp)) ? (RtlAssert((PVOID)#exp, (PVOID)__FILE__, __LINE__, msg), FALSE) : TRUE)
#define RTL_SOFT_ASSERT(_exp) \
    ((!(_exp)) ? (DbgPrint("%s(%d): Soft assertion failed\n   Expression: %s\n", __FILE__, __LINE__, #_exp), FALSE) : TRUE)
#define RTL_SOFT_ASSERTMSG(_msg, _exp) \
    ((!(_exp)) ? (DbgPrint("%s(%d): Soft assertion failed\n   Expression: %s\n   Message: %s\n", __FILE__, __LINE__, #_exp, (_msg)), FALSE) : TRUE)

#endif

```

`phnt/ntzwapi.h`:

```h
#ifndef _NTZWAPI_H
#define _NTZWAPI_H

// This file was automatically generated. Do not edit.

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAcceptConnectPort(
    _Out_ PHANDLE PortHandle,
    _In_opt_ PVOID PortContext,
    _In_ PPORT_MESSAGE ConnectionRequest,
    _In_ BOOLEAN AcceptConnection,
    _Inout_opt_ PPORT_VIEW ServerView,
    _Out_opt_ PREMOTE_PORT_VIEW ClientView
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAccessCheck(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ PGENERIC_MAPPING GenericMapping,
    _Out_writes_bytes_(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
    _Inout_ PULONG PrivilegeSetLength,
    _Out_ PACCESS_MASK GrantedAccess,
    _Out_ PNTSTATUS AccessStatus
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAccessCheckAndAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ PUNICODE_STRING ObjectTypeName,
    _In_ PUNICODE_STRING ObjectName,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ PGENERIC_MAPPING GenericMapping,
    _In_ BOOLEAN ObjectCreation,
    _Out_ PACCESS_MASK GrantedAccess,
    _Out_ PNTSTATUS AccessStatus,
    _Out_ PBOOLEAN GenerateOnClose
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAccessCheckByType(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PSID PrincipalSelfSid,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_reads_(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    _In_ ULONG ObjectTypeListLength,
    _In_ PGENERIC_MAPPING GenericMapping,
    _Out_writes_bytes_(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
    _Inout_ PULONG PrivilegeSetLength,
    _Out_ PACCESS_MASK GrantedAccess,
    _Out_ PNTSTATUS AccessStatus
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAccessCheckByTypeAndAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ PUNICODE_STRING ObjectTypeName,
    _In_ PUNICODE_STRING ObjectName,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PSID PrincipalSelfSid,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ AUDIT_EVENT_TYPE AuditType,
    _In_ ULONG Flags,
    _In_reads_opt_(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    _In_ ULONG ObjectTypeListLength,
    _In_ PGENERIC_MAPPING GenericMapping,
    _In_ BOOLEAN ObjectCreation,
    _Out_ PACCESS_MASK GrantedAccess,
    _Out_ PNTSTATUS AccessStatus,
    _Out_ PBOOLEAN GenerateOnClose
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAccessCheckByTypeResultList(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PSID PrincipalSelfSid,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_reads_(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    _In_ ULONG ObjectTypeListLength,
    _In_ PGENERIC_MAPPING GenericMapping,
    _Out_writes_bytes_(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
    _Inout_ PULONG PrivilegeSetLength,
    _Out_writes_(ObjectTypeListLength) PACCESS_MASK GrantedAccess,
    _Out_writes_(ObjectTypeListLength) PNTSTATUS AccessStatus
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAccessCheckByTypeResultListAndAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ PUNICODE_STRING ObjectTypeName,
    _In_ PUNICODE_STRING ObjectName,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PSID PrincipalSelfSid,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ AUDIT_EVENT_TYPE AuditType,
    _In_ ULONG Flags,
    _In_reads_opt_(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    _In_ ULONG ObjectTypeListLength,
    _In_ PGENERIC_MAPPING GenericMapping,
    _In_ BOOLEAN ObjectCreation,
    _Out_writes_(ObjectTypeListLength) PACCESS_MASK GrantedAccess,
    _Out_writes_(ObjectTypeListLength) PNTSTATUS AccessStatus,
    _Out_ PBOOLEAN GenerateOnClose
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAccessCheckByTypeResultListAndAuditAlarmByHandle(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ HANDLE ClientToken,
    _In_ PUNICODE_STRING ObjectTypeName,
    _In_ PUNICODE_STRING ObjectName,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PSID PrincipalSelfSid,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ AUDIT_EVENT_TYPE AuditType,
    _In_ ULONG Flags,
    _In_reads_opt_(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    _In_ ULONG ObjectTypeListLength,
    _In_ PGENERIC_MAPPING GenericMapping,
    _In_ BOOLEAN ObjectCreation,
    _Out_writes_(ObjectTypeListLength) PACCESS_MASK GrantedAccess,
    _Out_writes_(ObjectTypeListLength) PNTSTATUS AccessStatus,
    _Out_ PBOOLEAN GenerateOnClose
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAcquireCMFViewOwnership(
    _Out_ PULONGLONG TimeStamp,
    _Out_ PBOOLEAN tokenTaken,
    _In_ BOOLEAN replaceExisting
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAddAtom(
    _In_reads_bytes_opt_(Length) PWSTR AtomName,
    _In_ ULONG Length,
    _Out_opt_ PRTL_ATOM Atom
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAddAtomEx(
    _In_reads_bytes_opt_(Length) PWSTR AtomName,
    _In_ ULONG Length,
    _Out_opt_ PRTL_ATOM Atom,
    _In_ ULONG Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAddBootEntry(
    _In_ PBOOT_ENTRY BootEntry,
    _Out_opt_ PULONG Id
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAddDriverEntry(
    _In_ PEFI_DRIVER_ENTRY DriverEntry,
    _Out_opt_ PULONG Id
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAdjustGroupsToken(
    _In_ HANDLE TokenHandle,
    _In_ BOOLEAN ResetToDefault,
    _In_opt_ PTOKEN_GROUPS NewState,
    _In_opt_ ULONG BufferLength,
    _Out_writes_bytes_to_opt_(BufferLength, *ReturnLength) PTOKEN_GROUPS PreviousState,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAdjustPrivilegesToken(
    _In_ HANDLE TokenHandle,
    _In_ BOOLEAN DisableAllPrivileges,
    _In_opt_ PTOKEN_PRIVILEGES NewState,
    _In_ ULONG BufferLength,
    _Out_writes_bytes_to_opt_(BufferLength, *ReturnLength) PTOKEN_PRIVILEGES PreviousState,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAdjustTokenClaimsAndDeviceGroups(
    _In_ HANDLE TokenHandle,
    _In_ BOOLEAN UserResetToDefault,
    _In_ BOOLEAN DeviceResetToDefault,
    _In_ BOOLEAN DeviceGroupsResetToDefault,
    _In_opt_ PTOKEN_SECURITY_ATTRIBUTES_INFORMATION NewUserState,
    _In_opt_ PTOKEN_SECURITY_ATTRIBUTES_INFORMATION NewDeviceState,
    _In_opt_ PTOKEN_GROUPS NewDeviceGroupsState,
    _In_ ULONG UserBufferLength,
    _Out_writes_bytes_to_opt_(UserBufferLength, *UserReturnLength) PTOKEN_SECURITY_ATTRIBUTES_INFORMATION PreviousUserState,
    _In_ ULONG DeviceBufferLength,
    _Out_writes_bytes_to_opt_(DeviceBufferLength, *DeviceReturnLength) PTOKEN_SECURITY_ATTRIBUTES_INFORMATION PreviousDeviceState,
    _In_ ULONG DeviceGroupsBufferLength,
    _Out_writes_bytes_to_opt_(DeviceGroupsBufferLength, *DeviceGroupsReturnBufferLength) PTOKEN_GROUPS PreviousDeviceGroups,
    _Out_opt_ PULONG UserReturnLength,
    _Out_opt_ PULONG DeviceReturnLength,
    _Out_opt_ PULONG DeviceGroupsReturnBufferLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlertResumeThread(
    _In_ HANDLE ThreadHandle,
    _Out_opt_ PULONG PreviousSuspendCount
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlertThread(
    _In_ HANDLE ThreadHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlertThreadByThreadId(
    _In_ HANDLE ThreadId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAllocateLocallyUniqueId(
    _Out_ PLUID Luid
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAllocateReserveObject(
    _Out_ PHANDLE MemoryReserveHandle,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ MEMORY_RESERVE_TYPE Type
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAllocateUserPhysicalPages(
    _In_ HANDLE ProcessHandle,
    _Inout_ PULONG_PTR NumberOfPages,
    _Out_writes_(*NumberOfPages) PULONG_PTR UserPfnArray
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAllocateUuids(
    _Out_ PULARGE_INTEGER Time,
    _Out_ PULONG Range,
    _Out_ PULONG Sequence,
    _Out_ PCHAR Seed
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAllocateVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ _At_(*BaseAddress, _Readable_bytes_(*RegionSize) _Writable_bytes_(*RegionSize) _Post_readable_byte_size_(*RegionSize)) PVOID *BaseAddress,
    _In_ ULONG_PTR ZeroBits,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG AllocationType,
    _In_ ULONG Protect
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcAcceptConnectPort(
    _Out_ PHANDLE PortHandle,
    _In_ HANDLE ConnectionPortHandle,
    _In_ ULONG Flags,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PALPC_PORT_ATTRIBUTES PortAttributes,
    _In_opt_ PVOID PortContext,
    _In_reads_bytes_(ConnectionRequest->u1.s1.TotalLength) PPORT_MESSAGE ConnectionRequest,
    _Inout_opt_ PALPC_MESSAGE_ATTRIBUTES ConnectionMessageAttributes,
    _In_ BOOLEAN AcceptConnection
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcCancelMessage(
    _In_ HANDLE PortHandle,
    _In_ ULONG Flags,
    _In_ PALPC_CONTEXT_ATTR MessageContext
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcConnectPort(
    _Out_ PHANDLE PortHandle,
    _In_ PUNICODE_STRING PortName,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PALPC_PORT_ATTRIBUTES PortAttributes,
    _In_ ULONG Flags,
    _In_opt_ PSID RequiredServerSid,
    _Inout_updates_bytes_to_opt_(*BufferLength, *BufferLength) PPORT_MESSAGE ConnectionMessage,
    _Inout_opt_ PULONG BufferLength,
    _Inout_opt_ PALPC_MESSAGE_ATTRIBUTES OutMessageAttributes,
    _Inout_opt_ PALPC_MESSAGE_ATTRIBUTES InMessageAttributes,
    _In_opt_ PLARGE_INTEGER Timeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcConnectPortEx(
    _Out_ PHANDLE PortHandle,
    _In_ POBJECT_ATTRIBUTES ConnectionPortObjectAttributes,
    _In_opt_ POBJECT_ATTRIBUTES ClientPortObjectAttributes,
    _In_opt_ PALPC_PORT_ATTRIBUTES PortAttributes,
    _In_ ULONG Flags,
    _In_opt_ PSECURITY_DESCRIPTOR ServerSecurityRequirements,
    _Inout_updates_bytes_to_opt_(*BufferLength, *BufferLength) PPORT_MESSAGE ConnectionMessage,
    _Inout_opt_ PSIZE_T BufferLength,
    _Inout_opt_ PALPC_MESSAGE_ATTRIBUTES OutMessageAttributes,
    _Inout_opt_ PALPC_MESSAGE_ATTRIBUTES InMessageAttributes,
    _In_opt_ PLARGE_INTEGER Timeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcCreatePort(
    _Out_ PHANDLE PortHandle,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PALPC_PORT_ATTRIBUTES PortAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcCreatePortSection(
    _In_ HANDLE PortHandle,
    _In_ ULONG Flags,
    _In_opt_ HANDLE SectionHandle,
    _In_ SIZE_T SectionSize,
    _Out_ PALPC_HANDLE AlpcSectionHandle,
    _Out_ PSIZE_T ActualSectionSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcCreateResourceReserve(
    _In_ HANDLE PortHandle,
    _Reserved_ ULONG Flags,
    _In_ SIZE_T MessageSize,
    _Out_ PALPC_HANDLE ResourceId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcCreateSectionView(
    _In_ HANDLE PortHandle,
    _Reserved_ ULONG Flags,
    _Inout_ PALPC_DATA_VIEW_ATTR ViewAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcCreateSecurityContext(
    _In_ HANDLE PortHandle,
    _Reserved_ ULONG Flags,
    _Inout_ PALPC_SECURITY_ATTR SecurityAttribute
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcDeletePortSection(
    _In_ HANDLE PortHandle,
    _Reserved_ ULONG Flags,
    _In_ ALPC_HANDLE SectionHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcDeleteResourceReserve(
    _In_ HANDLE PortHandle,
    _Reserved_ ULONG Flags,
    _In_ ALPC_HANDLE ResourceId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcDeleteSectionView(
    _In_ HANDLE PortHandle,
    _Reserved_ ULONG Flags,
    _In_ PVOID ViewBase
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcDeleteSecurityContext(
    _In_ HANDLE PortHandle,
    _Reserved_ ULONG Flags,
    _In_ ALPC_HANDLE ContextHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcDisconnectPort(
    _In_ HANDLE PortHandle,
    _In_ ULONG Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcImpersonateClientContainerOfPort(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE Message,
    _In_ ULONG Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcImpersonateClientOfPort(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE Message,
    _In_ PVOID Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcOpenSenderProcess(
    _Out_ PHANDLE ProcessHandle,
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE PortMessage,
    _In_ ULONG Flags,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcOpenSenderThread(
    _Out_ PHANDLE ThreadHandle,
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE PortMessage,
    _In_ ULONG Flags,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcQueryInformation(
    _In_opt_ HANDLE PortHandle,
    _In_ ALPC_PORT_INFORMATION_CLASS PortInformationClass,
    _Inout_updates_bytes_to_(Length, *ReturnLength) PVOID PortInformation,
    _In_ ULONG Length,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcQueryInformationMessage(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE PortMessage,
    _In_ ALPC_MESSAGE_INFORMATION_CLASS MessageInformationClass,
    _Out_writes_bytes_to_opt_(Length, *ReturnLength) PVOID MessageInformation,
    _In_ ULONG Length,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcRevokeSecurityContext(
    _In_ HANDLE PortHandle,
    _Reserved_ ULONG Flags,
    _In_ ALPC_HANDLE ContextHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcSendWaitReceivePort(
    _In_ HANDLE PortHandle,
    _In_ ULONG Flags,
    _In_reads_bytes_opt_(SendMessage->u1.s1.TotalLength) PPORT_MESSAGE SendMessage,
    _Inout_opt_ PALPC_MESSAGE_ATTRIBUTES SendMessageAttributes,
    _Out_writes_bytes_to_opt_(*BufferLength, *BufferLength) PPORT_MESSAGE ReceiveMessage,
    _Inout_opt_ PSIZE_T BufferLength,
    _Inout_opt_ PALPC_MESSAGE_ATTRIBUTES ReceiveMessageAttributes,
    _In_opt_ PLARGE_INTEGER Timeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAlpcSetInformation(
    _In_ HANDLE PortHandle,
    _In_ ALPC_PORT_INFORMATION_CLASS PortInformationClass,
    _In_reads_bytes_opt_(Length) PVOID PortInformation,
    _In_ ULONG Length
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAreMappedFilesTheSame(
    _In_ PVOID File1MappedAsAnImage,
    _In_ PVOID File2MappedAsFile
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAssignProcessToJobObject(
    _In_ HANDLE JobHandle,
    _In_ HANDLE ProcessHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAssociateWaitCompletionPacket(
    _In_ HANDLE WaitCompletionPacketHandle,
    _In_ HANDLE IoCompletionHandle,
    _In_ HANDLE TargetObjectHandle,
    _In_opt_ PVOID KeyContext,
    _In_opt_ PVOID ApcContext,
    _In_ NTSTATUS IoStatus,
    _In_ ULONG_PTR IoStatusInformation,
    _Out_opt_ PBOOLEAN AlreadySignaled
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCallbackReturn(
    _In_reads_bytes_opt_(OutputLength) PVOID OutputBuffer,
    _In_ ULONG OutputLength,
    _In_ NTSTATUS Status
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCancelIoFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCancelIoFileEx(
    _In_ HANDLE FileHandle,
    _In_opt_ PIO_STATUS_BLOCK IoRequestToCancel,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCancelSynchronousIoFile(
    _In_ HANDLE ThreadHandle,
    _In_opt_ PIO_STATUS_BLOCK IoRequestToCancel,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCancelTimer(
    _In_ HANDLE TimerHandle,
    _Out_opt_ PBOOLEAN CurrentState
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCancelTimer2(
    _In_ HANDLE TimerHandle,
    _In_ PT2_CANCEL_PARAMETERS Parameters
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCancelWaitCompletionPacket(
    _In_ HANDLE WaitCompletionPacketHandle,
    _In_ BOOLEAN RemoveSignaledPacket
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwClearEvent(
    _In_ HANDLE EventHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwClose(
    _In_ HANDLE Handle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCloseObjectAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ BOOLEAN GenerateOnClose
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCommitComplete(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCommitEnlistment(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCommitTransaction(
    _In_ HANDLE TransactionHandle,
    _In_ BOOLEAN Wait
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCompactKeys(
    _In_ ULONG Count,
    _In_reads_(Count) HANDLE KeyArray[]
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCompareObjects(
    _In_ HANDLE FirstObjectHandle,
    _In_ HANDLE SecondObjectHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCompareTokens(
    _In_ HANDLE FirstTokenHandle,
    _In_ HANDLE SecondTokenHandle,
    _Out_ PBOOLEAN Equal
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCompleteConnectPort(
    _In_ HANDLE PortHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCompressKey(
    _In_ HANDLE Key
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwConnectPort(
    _Out_ PHANDLE PortHandle,
    _In_ PUNICODE_STRING PortName,
    _In_ PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    _Inout_opt_ PPORT_VIEW ClientView,
    _Inout_opt_ PREMOTE_PORT_VIEW ServerView,
    _Out_opt_ PULONG MaxMessageLength,
    _Inout_updates_bytes_to_opt_(*ConnectionInformationLength, *ConnectionInformationLength) PVOID ConnectionInformation,
    _Inout_opt_ PULONG ConnectionInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwContinue(
    _In_ PCONTEXT ContextRecord,
    _In_ BOOLEAN TestAlert
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateDebugObject(
    _Out_ PHANDLE DebugObjectHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateDirectoryObject(
    _Out_ PHANDLE DirectoryHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateDirectoryObjectEx(
    _Out_ PHANDLE DirectoryHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ShadowDirectoryHandle,
    _In_ ULONG Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateEnlistment(
    _Out_ PHANDLE EnlistmentHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE ResourceManagerHandle,
    _In_ HANDLE TransactionHandle,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ ULONG CreateOptions,
    _In_ NOTIFICATION_MASK NotificationMask,
    _In_opt_ PVOID EnlistmentKey
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateEvent(
    _Out_ PHANDLE EventHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ EVENT_TYPE EventType,
    _In_ BOOLEAN InitialState
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateEventPair(
    _Out_ PHANDLE EventPairHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateFile(
    _Out_ PHANDLE FileHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_opt_ PLARGE_INTEGER AllocationSize,
    _In_ ULONG FileAttributes,
    _In_ ULONG ShareAccess,
    _In_ ULONG CreateDisposition,
    _In_ ULONG CreateOptions,
    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,
    _In_ ULONG EaLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateIoCompletion(
    _Out_ PHANDLE IoCompletionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ ULONG Count
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateIRTimer(
    _Out_ PHANDLE TimerHandle,
    _In_ ACCESS_MASK DesiredAccess
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateJobObject(
    _Out_ PHANDLE JobHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateJobSet(
    _In_ ULONG NumJob,
    _In_reads_(NumJob) PJOB_SET_ARRAY UserJobSet,
    _In_ ULONG Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateKey(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Reserved_ ULONG TitleIndex,
    _In_opt_ PUNICODE_STRING Class,
    _In_ ULONG CreateOptions,
    _Out_opt_ PULONG Disposition
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateKeyedEvent(
    _Out_ PHANDLE KeyedEventHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateKeyTransacted(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Reserved_ ULONG TitleIndex,
    _In_opt_ PUNICODE_STRING Class,
    _In_ ULONG CreateOptions,
    _In_ HANDLE TransactionHandle,
    _Out_opt_ PULONG Disposition
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateLowBoxToken(
    _Out_ PHANDLE TokenHandle,
    _In_ HANDLE ExistingTokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ PSID PackageSid,
    _In_ ULONG CapabilityCount,
    _In_reads_opt_(CapabilityCount) PSID_AND_ATTRIBUTES Capabilities,
    _In_ ULONG HandleCount,
    _In_reads_opt_(HandleCount) HANDLE *Handles
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateMailslotFile(
    _Out_ PHANDLE FileHandle,
    _In_ ULONG DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG CreateOptions,
    _In_ ULONG MailslotQuota,
    _In_ ULONG MaximumMessageSize,
    _In_ PLARGE_INTEGER ReadTimeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateMutant(
    _Out_ PHANDLE MutantHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ BOOLEAN InitialOwner
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateNamedPipeFile(
    _Out_ PHANDLE FileHandle,
    _In_ ULONG DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG ShareAccess,
    _In_ ULONG CreateDisposition,
    _In_ ULONG CreateOptions,
    _In_ ULONG NamedPipeType,
    _In_ ULONG ReadMode,
    _In_ ULONG CompletionMode,
    _In_ ULONG MaximumInstances,
    _In_ ULONG InboundQuota,
    _In_ ULONG OutboundQuota,
    _In_opt_ PLARGE_INTEGER DefaultTimeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreatePagingFile(
    _In_ PUNICODE_STRING PageFileName,
    _In_ PLARGE_INTEGER MinimumSize,
    _In_ PLARGE_INTEGER MaximumSize,
    _In_ ULONG Priority
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreatePartition(
    _Out_ PHANDLE PartitionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG PreferredNode
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreatePort(
    _Out_ PHANDLE PortHandle,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG MaxConnectionInfoLength,
    _In_ ULONG MaxMessageLength,
    _In_opt_ ULONG MaxPoolUsage
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreatePrivateNamespace(
    _Out_ PHANDLE NamespaceHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ PVOID BoundaryDescriptor
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateProcess(
    _Out_ PHANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ParentProcess,
    _In_ BOOLEAN InheritObjectTable,
    _In_opt_ HANDLE SectionHandle,
    _In_opt_ HANDLE DebugPort,
    _In_opt_ HANDLE ExceptionPort
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateProcessEx(
    _Out_ PHANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ParentProcess,
    _In_ ULONG Flags,
    _In_opt_ HANDLE SectionHandle,
    _In_opt_ HANDLE DebugPort,
    _In_opt_ HANDLE ExceptionPort,
    _In_ ULONG JobMemberLevel
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateProfile(
    _Out_ PHANDLE ProfileHandle,
    _In_opt_ HANDLE Process,
    _In_ PVOID ProfileBase,
    _In_ SIZE_T ProfileSize,
    _In_ ULONG BucketSize,
    _In_reads_bytes_(BufferSize) PULONG Buffer,
    _In_ ULONG BufferSize,
    _In_ KPROFILE_SOURCE ProfileSource,
    _In_ KAFFINITY Affinity
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateProfileEx(
    _Out_ PHANDLE ProfileHandle,
    _In_opt_ HANDLE Process,
    _In_ PVOID ProfileBase,
    _In_ SIZE_T ProfileSize,
    _In_ ULONG BucketSize,
    _In_reads_bytes_(BufferSize) PULONG Buffer,
    _In_ ULONG BufferSize,
    _In_ KPROFILE_SOURCE ProfileSource,
    _In_ USHORT GroupCount,
    _In_reads_(GroupCount) PGROUP_AFFINITY GroupAffinity
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateResourceManager(
    _Out_ PHANDLE ResourceManagerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE TmHandle,
    _In_ LPGUID RmGuid,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ ULONG CreateOptions,
    _In_opt_ PUNICODE_STRING Description
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateSection(
    _Out_ PHANDLE SectionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PLARGE_INTEGER MaximumSize,
    _In_ ULONG SectionPageProtection,
    _In_ ULONG AllocationAttributes,
    _In_opt_ HANDLE FileHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateSectionEx(
    _Out_ PHANDLE SectionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PLARGE_INTEGER MaximumSize,
    _In_ ULONG SectionPageProtection,
    _In_ ULONG AllocationAttributes,
    _In_opt_ HANDLE FileHandle,
    _In_ PMEM_EXTENDED_PARAMETER ExtendedParameters,
    _In_ ULONG ExtendedParameterCount
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateSemaphore(
    _Out_ PHANDLE SemaphoreHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ LONG InitialCount,
    _In_ LONG MaximumCount
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateSymbolicLinkObject(
    _Out_ PHANDLE LinkHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ PUNICODE_STRING LinkTarget
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateThread(
    _Out_ PHANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ProcessHandle,
    _Out_ PCLIENT_ID ClientId,
    _In_ PCONTEXT ThreadContext,
    _In_ PINITIAL_TEB InitialTeb,
    _In_ BOOLEAN CreateSuspended
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateThreadEx(
    _Out_ PHANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ProcessHandle,
    _In_ PVOID StartRoutine, // PUSER_THREAD_START_ROUTINE
    _In_opt_ PVOID Argument,
    _In_ ULONG CreateFlags, // THREAD_CREATE_FLAGS_*
    _In_ SIZE_T ZeroBits,
    _In_ SIZE_T StackSize,
    _In_ SIZE_T MaximumStackSize,
    _In_opt_ PPS_ATTRIBUTE_LIST AttributeList
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateTimer(
    _Out_ PHANDLE TimerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ TIMER_TYPE TimerType
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateTimer2(
    _Out_ PHANDLE TimerHandle,
    _In_opt_ PVOID Reserved1,
    _In_opt_ PVOID Reserved2,
    _In_ ULONG Attributes,
    _In_ ACCESS_MASK DesiredAccess
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateToken(
    _Out_ PHANDLE TokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ TOKEN_TYPE TokenType,
    _In_ PLUID AuthenticationId,
    _In_ PLARGE_INTEGER ExpirationTime,
    _In_ PTOKEN_USER User,
    _In_ PTOKEN_GROUPS Groups,
    _In_ PTOKEN_PRIVILEGES Privileges,
    _In_opt_ PTOKEN_OWNER Owner,
    _In_ PTOKEN_PRIMARY_GROUP PrimaryGroup,
    _In_opt_ PTOKEN_DEFAULT_DACL DefaultDacl,
    _In_ PTOKEN_SOURCE TokenSource
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateTokenEx(
    _Out_ PHANDLE TokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ TOKEN_TYPE TokenType,
    _In_ PLUID AuthenticationId,
    _In_ PLARGE_INTEGER ExpirationTime,
    _In_ PTOKEN_USER User,
    _In_ PTOKEN_GROUPS Groups,
    _In_ PTOKEN_PRIVILEGES Privileges,
    _In_opt_ PTOKEN_SECURITY_ATTRIBUTES_INFORMATION UserAttributes,
    _In_opt_ PTOKEN_SECURITY_ATTRIBUTES_INFORMATION DeviceAttributes,
    _In_opt_ PTOKEN_GROUPS DeviceGroups,
    _In_opt_ PTOKEN_MANDATORY_POLICY TokenMandatoryPolicy,
    _In_opt_ PTOKEN_OWNER Owner,
    _In_ PTOKEN_PRIMARY_GROUP PrimaryGroup,
    _In_opt_ PTOKEN_DEFAULT_DACL DefaultDacl,
    _In_ PTOKEN_SOURCE TokenSource
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateTransaction(
    _Out_ PHANDLE TransactionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ LPGUID Uow,
    _In_opt_ HANDLE TmHandle,
    _In_opt_ ULONG CreateOptions,
    _In_opt_ ULONG IsolationLevel,
    _In_opt_ ULONG IsolationFlags,
    _In_opt_ PLARGE_INTEGER Timeout,
    _In_opt_ PUNICODE_STRING Description
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateTransactionManager(
    _Out_ PHANDLE TmHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PUNICODE_STRING LogFileName,
    _In_opt_ ULONG CreateOptions,
    _In_opt_ ULONG CommitStrength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateUserProcess(
    _Out_ PHANDLE ProcessHandle,
    _Out_ PHANDLE ThreadHandle,
    _In_ ACCESS_MASK ProcessDesiredAccess,
    _In_ ACCESS_MASK ThreadDesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ProcessObjectAttributes,
    _In_opt_ POBJECT_ATTRIBUTES ThreadObjectAttributes,
    _In_ ULONG ProcessFlags, // PROCESS_CREATE_FLAGS_*
    _In_ ULONG ThreadFlags, // THREAD_CREATE_FLAGS_*
    _In_opt_ PVOID ProcessParameters, // PRTL_USER_PROCESS_PARAMETERS
    _Inout_ PPS_CREATE_INFO CreateInfo,
    _In_opt_ PPS_ATTRIBUTE_LIST AttributeList
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateWaitablePort(
    _Out_ PHANDLE PortHandle,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG MaxConnectionInfoLength,
    _In_ ULONG MaxMessageLength,
    _In_opt_ ULONG MaxPoolUsage
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateWaitCompletionPacket(
    _Out_ PHANDLE WaitCompletionPacketHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateWnfStateName(
    _Out_ PWNF_STATE_NAME StateName,
    _In_ WNF_STATE_NAME_LIFETIME NameLifetime,
    _In_ WNF_DATA_SCOPE DataScope,
    _In_ BOOLEAN PersistData,
    _In_opt_ PCWNF_TYPE_ID TypeId,
    _In_ ULONG MaximumStateSize,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateWorkerFactory(
    _Out_ PHANDLE WorkerFactoryHandleReturn,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE CompletionPortHandle,
    _In_ HANDLE WorkerProcessHandle,
    _In_ PVOID StartRoutine,
    _In_opt_ PVOID StartParameter,
    _In_opt_ ULONG MaxThreadCount,
    _In_opt_ SIZE_T StackReserve,
    _In_opt_ SIZE_T StackCommit
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDebugActiveProcess(
    _In_ HANDLE ProcessHandle,
    _In_ HANDLE DebugObjectHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDebugContinue(
    _In_ HANDLE DebugObjectHandle,
    _In_ PCLIENT_ID ClientId,
    _In_ NTSTATUS ContinueStatus
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDelayExecution(
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER DelayInterval
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDeleteAtom(
    _In_ RTL_ATOM Atom
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDeleteBootEntry(
    _In_ ULONG Id
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDeleteDriverEntry(
    _In_ ULONG Id
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDeleteFile(
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDeleteKey(
    _In_ HANDLE KeyHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDeleteObjectAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ BOOLEAN GenerateOnClose
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDeletePrivateNamespace(
    _In_ HANDLE NamespaceHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDeleteValueKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING ValueName
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDeleteWnfStateData(
    _In_ PCWNF_STATE_NAME StateName,
    _In_opt_ const VOID *ExplicitScope
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDeleteWnfStateName(
    _In_ PCWNF_STATE_NAME StateName
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDeviceIoControlFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG IoControlCode,
    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDisableLastKnownGood(
    VOID
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDisplayString(
    _In_ PUNICODE_STRING String
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDrawText(
    _In_ PUNICODE_STRING Text
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDuplicateObject(
    _In_ HANDLE SourceProcessHandle,
    _In_ HANDLE SourceHandle,
    _In_opt_ HANDLE TargetProcessHandle,
    _Out_opt_ PHANDLE TargetHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _In_ ULONG Options
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDuplicateToken(
    _In_ HANDLE ExistingTokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ BOOLEAN EffectiveOnly,
    _In_ TOKEN_TYPE TokenType,
    _Out_ PHANDLE NewTokenHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwEnableLastKnownGood(
    VOID
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwEnumerateBootEntries(
    _Out_writes_bytes_opt_(*BufferLength) PVOID Buffer,
    _Inout_ PULONG BufferLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwEnumerateDriverEntries(
    _Out_writes_bytes_opt_(*BufferLength) PVOID Buffer,
    _Inout_ PULONG BufferLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwEnumerateKey(
    _In_ HANDLE KeyHandle,
    _In_ ULONG Index,
    _In_ KEY_INFORMATION_CLASS KeyInformationClass,
    _Out_writes_bytes_opt_(Length) PVOID KeyInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwEnumerateSystemEnvironmentValuesEx(
    _In_ ULONG InformationClass,
    _Out_ PVOID Buffer,
    _Inout_ PULONG BufferLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwEnumerateTransactionObject(
    _In_opt_ HANDLE RootObjectHandle,
    _In_ KTMOBJECT_TYPE QueryType,
    _Inout_updates_bytes_(ObjectCursorLength) PKTMOBJECT_CURSOR ObjectCursor,
    _In_ ULONG ObjectCursorLength,
    _Out_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwEnumerateValueKey(
    _In_ HANDLE KeyHandle,
    _In_ ULONG Index,
    _In_ KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    _Out_writes_bytes_opt_(Length) PVOID KeyValueInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwExtendSection(
    _In_ HANDLE SectionHandle,
    _Inout_ PLARGE_INTEGER NewSectionSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFilterBootOption(
    _In_ FILTER_BOOT_OPTION_OPERATION FilterOperation,
    _In_ ULONG ObjectType,
    _In_ ULONG ElementType,
    _In_reads_bytes_opt_(DataSize) PVOID Data,
    _In_ ULONG DataSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFilterToken(
    _In_ HANDLE ExistingTokenHandle,
    _In_ ULONG Flags,
    _In_opt_ PTOKEN_GROUPS SidsToDisable,
    _In_opt_ PTOKEN_PRIVILEGES PrivilegesToDelete,
    _In_opt_ PTOKEN_GROUPS RestrictedSids,
    _Out_ PHANDLE NewTokenHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFilterTokenEx(
    _In_ HANDLE ExistingTokenHandle,
    _In_ ULONG Flags,
    _In_opt_ PTOKEN_GROUPS SidsToDisable,
    _In_opt_ PTOKEN_PRIVILEGES PrivilegesToDelete,
    _In_opt_ PTOKEN_GROUPS RestrictedSids,
    _In_ ULONG DisableUserClaimsCount,
    _In_opt_ PUNICODE_STRING UserClaimsToDisable,
    _In_ ULONG DisableDeviceClaimsCount,
    _In_opt_ PUNICODE_STRING DeviceClaimsToDisable,
    _In_opt_ PTOKEN_GROUPS DeviceGroupsToDisable,
    _In_opt_ PTOKEN_SECURITY_ATTRIBUTES_INFORMATION RestrictedUserAttributes,
    _In_opt_ PTOKEN_SECURITY_ATTRIBUTES_INFORMATION RestrictedDeviceAttributes,
    _In_opt_ PTOKEN_GROUPS RestrictedDeviceGroups,
    _Out_ PHANDLE NewTokenHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFindAtom(
    _In_reads_bytes_opt_(Length) PWSTR AtomName,
    _In_ ULONG Length,
    _Out_opt_ PRTL_ATOM Atom
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFlushBuffersFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFlushBuffersFileEx(
    _In_ HANDLE FileHandle,
    _In_ ULONG Flags,
    _In_reads_bytes_(ParametersSize) PVOID Parameters,
    _In_ ULONG ParametersSize,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFlushInstallUILanguage(
    _In_ LANGID InstallUILanguage,
    _In_ ULONG SetComittedFlag
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFlushInstructionCache(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _In_ SIZE_T Length
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFlushKey(
    _In_ HANDLE KeyHandle
    );

NTSYSCALLAPI
VOID
NTAPI
ZwFlushProcessWriteBuffers(
    VOID
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFlushWriteBuffer(
    VOID
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFreeUserPhysicalPages(
    _In_ HANDLE ProcessHandle,
    _Inout_ PULONG_PTR NumberOfPages,
    _In_reads_(*NumberOfPages) PULONG_PTR UserPfnArray
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFreeVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG FreeType
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFreezeRegistry(
    _In_ ULONG TimeOutInSeconds
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFreezeTransactions(
    _In_ PLARGE_INTEGER FreezeTimeout,
    _In_ PLARGE_INTEGER ThawTimeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwFsControlFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG FsControlCode,
    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwGetCachedSigningLevel(
    _In_ HANDLE File,
    _Out_ PULONG Flags,
    _Out_ PSE_SIGNING_LEVEL SigningLevel,
    _Out_writes_bytes_to_opt_(*ThumbprintSize, *ThumbprintSize) PUCHAR Thumbprint,
    _Inout_opt_ PULONG ThumbprintSize,
    _Out_opt_ PULONG ThumbprintAlgorithm
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwGetCompleteWnfStateSubscription(
    _In_opt_ PWNF_STATE_NAME OldDescriptorStateName,
    _In_opt_ ULONG64 *OldSubscriptionId,
    _In_opt_ ULONG OldDescriptorEventMask,
    _In_opt_ ULONG OldDescriptorStatus,
    _Out_writes_bytes_(DescriptorSize) PWNF_DELIVERY_DESCRIPTOR NewDeliveryDescriptor,
    _In_ ULONG DescriptorSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwGetContextThread(
    _In_ HANDLE ThreadHandle,
    _Inout_ PCONTEXT ThreadContext
    );

NTSYSCALLAPI
ULONG
NTAPI
ZwGetCurrentProcessorNumber(
    VOID
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwGetDevicePowerState(
    _In_ HANDLE Device,
    _Out_ PDEVICE_POWER_STATE State
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwGetMUIRegistryInfo(
    _In_ ULONG Flags,
    _Inout_ PULONG DataSize,
    _Out_ PVOID Data
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwGetNextProcess(
    _In_opt_ HANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _In_ ULONG Flags,
    _Out_ PHANDLE NewProcessHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwGetNextThread(
    _In_ HANDLE ProcessHandle,
    _In_ HANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _In_ ULONG Flags,
    _Out_ PHANDLE NewThreadHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwGetNlsSectionPtr(
    _In_ ULONG SectionType,
    _In_ ULONG SectionData,
    _In_ PVOID ContextData,
    _Out_ PVOID *SectionPointer,
    _Out_ PULONG SectionSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwGetNotificationResourceManager(
    _In_ HANDLE ResourceManagerHandle,
    _Out_ PTRANSACTION_NOTIFICATION TransactionNotification,
    _In_ ULONG NotificationLength,
    _In_opt_ PLARGE_INTEGER Timeout,
    _Out_opt_ PULONG ReturnLength,
    _In_ ULONG Asynchronous,
    _In_opt_ ULONG_PTR AsynchronousContext
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwGetPlugPlayEvent(
    _In_ HANDLE EventHandle,
    _In_opt_ PVOID Context,
    _Out_writes_bytes_(EventBufferSize) PPLUGPLAY_EVENT_BLOCK EventBlock,
    _In_ ULONG EventBufferSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwGetWriteWatch(
    _In_ HANDLE ProcessHandle,
    _In_ ULONG Flags,
    _In_ PVOID BaseAddress,
    _In_ SIZE_T RegionSize,
    _Out_writes_(*EntriesInUserAddressArray) PVOID *UserAddressArray,
    _Inout_ PULONG_PTR EntriesInUserAddressArray,
    _Out_ PULONG Granularity
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwImpersonateAnonymousToken(
    _In_ HANDLE ThreadHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwImpersonateClientOfPort(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE Message
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwImpersonateThread(
    _In_ HANDLE ServerThreadHandle,
    _In_ HANDLE ClientThreadHandle,
    _In_ PSECURITY_QUALITY_OF_SERVICE SecurityQos
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwInitializeNlsFiles(
    _Out_ PVOID *BaseAddress,
    _Out_ PLCID DefaultLocaleId,
    _Out_ PLARGE_INTEGER DefaultCasingTableSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwInitializeRegistry(
    _In_ USHORT BootCondition
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwInitiatePowerAction(
    _In_ POWER_ACTION SystemAction,
    _In_ SYSTEM_POWER_STATE LightestSystemState,
    _In_ ULONG Flags, // POWER_ACTION_* flags
    _In_ BOOLEAN Asynchronous
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwIsProcessInJob(
    _In_ HANDLE ProcessHandle,
    _In_opt_ HANDLE JobHandle
    );

NTSYSCALLAPI
BOOLEAN
NTAPI
ZwIsSystemResumeAutomatic(
    VOID
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwIsUILanguageComitted(
    VOID
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwListenPort(
    _In_ HANDLE PortHandle,
    _Out_ PPORT_MESSAGE ConnectionRequest
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwLoadDriver(
    _In_ PUNICODE_STRING DriverServiceName
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwLoadKey(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ POBJECT_ATTRIBUTES SourceFile
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwLoadKey2(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ POBJECT_ATTRIBUTES SourceFile,
    _In_ ULONG Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwLoadKeyEx(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ POBJECT_ATTRIBUTES SourceFile,
    _In_ ULONG Flags,
    _In_opt_ HANDLE TrustClassKey,
    _In_opt_ HANDLE Event,
    _In_opt_ ACCESS_MASK DesiredAccess,
    _Out_opt_ PHANDLE RootHandle,
    _Out_opt_ PIO_STATUS_BLOCK IoStatus
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwLockFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PLARGE_INTEGER ByteOffset,
    _In_ PLARGE_INTEGER Length,
    _In_ ULONG Key,
    _In_ BOOLEAN FailImmediately,
    _In_ BOOLEAN ExclusiveLock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwLockProductActivationKeys(
    _Inout_opt_ ULONG *pPrivateVer,
    _Out_opt_ ULONG *pSafeMode
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwLockRegistryKey(
    _In_ HANDLE KeyHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwLockVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG MapType
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwMakePermanentObject(
    _In_ HANDLE Handle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwMakeTemporaryObject(
    _In_ HANDLE Handle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwManagePartition(
    _In_ MEMORY_PARTITION_INFORMATION_CLASS PartitionInformationClass,
    _In_ PVOID PartitionInformation,
    _In_ ULONG PartitionInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwMapCMFModule(
    _In_ ULONG What,
    _In_ ULONG Index,
    _Out_opt_ PULONG CacheIndexOut,
    _Out_opt_ PULONG CacheFlagsOut,
    _Out_opt_ PULONG ViewSizeOut,
    _Out_opt_ PVOID *BaseAddress
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwMapUserPhysicalPages(
    _In_ PVOID VirtualAddress,
    _In_ ULONG_PTR NumberOfPages,
    _In_reads_opt_(NumberOfPages) PULONG_PTR UserPfnArray
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwMapUserPhysicalPagesScatter(
    _In_reads_(NumberOfPages) PVOID *VirtualAddresses,
    _In_ ULONG_PTR NumberOfPages,
    _In_reads_opt_(NumberOfPages) PULONG_PTR UserPfnArray
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwMapViewOfSection(
    _In_ HANDLE SectionHandle,
    _In_ HANDLE ProcessHandle,
    _Inout_ _At_(*BaseAddress, _Readable_bytes_(*ViewSize) _Writable_bytes_(*ViewSize) _Post_readable_byte_size_(*ViewSize)) PVOID *BaseAddress,
    _In_ ULONG_PTR ZeroBits,
    _In_ SIZE_T CommitSize,
    _Inout_opt_ PLARGE_INTEGER SectionOffset,
    _Inout_ PSIZE_T ViewSize,
    _In_ SECTION_INHERIT InheritDisposition,
    _In_ ULONG AllocationType,
    _In_ ULONG Win32Protect
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwModifyBootEntry(
    _In_ PBOOT_ENTRY BootEntry
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwModifyDriverEntry(
    _In_ PEFI_DRIVER_ENTRY DriverEntry
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwNotifyChangeDirectoryFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer, // FILE_NOTIFY_INFORMATION
    _In_ ULONG Length,
    _In_ ULONG CompletionFilter,
    _In_ BOOLEAN WatchTree
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwNotifyChangeDirectoryFileEx(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_ ULONG CompletionFilter,
    _In_ BOOLEAN WatchTree,
    _In_opt_ DIRECTORY_NOTIFY_INFORMATION_CLASS DirectoryNotifyInformationClass
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwNotifyChangeKey(
    _In_ HANDLE KeyHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG CompletionFilter,
    _In_ BOOLEAN WatchTree,
    _Out_writes_bytes_opt_(BufferSize) PVOID Buffer,
    _In_ ULONG BufferSize,
    _In_ BOOLEAN Asynchronous
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwNotifyChangeMultipleKeys(
    _In_ HANDLE MasterKeyHandle,
    _In_opt_ ULONG Count,
    _In_reads_opt_(Count) OBJECT_ATTRIBUTES SubordinateObjects[],
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG CompletionFilter,
    _In_ BOOLEAN WatchTree,
    _Out_writes_bytes_opt_(BufferSize) PVOID Buffer,
    _In_ ULONG BufferSize,
    _In_ BOOLEAN Asynchronous
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwNotifyChangeSession(
    _In_ HANDLE SessionHandle,
    _In_ ULONG ChangeSequenceNumber,
    _In_ PLARGE_INTEGER ChangeTimeStamp,
    _In_ IO_SESSION_EVENT Event,
    _In_ IO_SESSION_STATE NewState,
    _In_ IO_SESSION_STATE PreviousState,
    _In_reads_bytes_opt_(PayloadSize) PVOID Payload,
    _In_ ULONG PayloadSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenDirectoryObject(
    _Out_ PHANDLE DirectoryHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenEnlistment(
    _Out_ PHANDLE EnlistmentHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE ResourceManagerHandle,
    _In_ LPGUID EnlistmentGuid,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenEvent(
    _Out_ PHANDLE EventHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenEventPair(
    _Out_ PHANDLE EventPairHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenFile(
    _Out_ PHANDLE FileHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG ShareAccess,
    _In_ ULONG OpenOptions
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenIoCompletion(
    _Out_ PHANDLE IoCompletionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenJobObject(
    _Out_ PHANDLE JobHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenKey(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenKeyedEvent(
    _Out_ PHANDLE KeyedEventHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenKeyEx(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG OpenOptions
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenKeyTransacted(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE TransactionHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenKeyTransactedEx(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG OpenOptions,
    _In_ HANDLE TransactionHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenMutant(
    _Out_ PHANDLE MutantHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenObjectAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ PUNICODE_STRING ObjectTypeName,
    _In_ PUNICODE_STRING ObjectName,
    _In_opt_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ACCESS_MASK GrantedAccess,
    _In_opt_ PPRIVILEGE_SET Privileges,
    _In_ BOOLEAN ObjectCreation,
    _In_ BOOLEAN AccessGranted,
    _Out_ PBOOLEAN GenerateOnClose
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenPartition(
    _Out_ PHANDLE PartitionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenPrivateNamespace(
    _Out_ PHANDLE NamespaceHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ PVOID BoundaryDescriptor
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenProcess(
    _Out_ PHANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PCLIENT_ID ClientId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenProcessToken(
    _In_ HANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE TokenHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenProcessTokenEx(
    _In_ HANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _Out_ PHANDLE TokenHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenResourceManager(
    _Out_ PHANDLE ResourceManagerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE TmHandle,
    _In_opt_ LPGUID ResourceManagerGuid,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenSection(
    _Out_ PHANDLE SectionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenSemaphore(
    _Out_ PHANDLE SemaphoreHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenSession(
    _Out_ PHANDLE SessionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenSymbolicLinkObject(
    _Out_ PHANDLE LinkHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenThread(
    _Out_ PHANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PCLIENT_ID ClientId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenThreadToken(
    _In_ HANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ BOOLEAN OpenAsSelf,
    _Out_ PHANDLE TokenHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenThreadTokenEx(
    _In_ HANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ BOOLEAN OpenAsSelf,
    _In_ ULONG HandleAttributes,
    _Out_ PHANDLE TokenHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenTimer(
    _Out_ PHANDLE TimerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenTransaction(
    _Out_ PHANDLE TransactionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ LPGUID Uow,
    _In_opt_ HANDLE TmHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenTransactionManager(
    _Out_ PHANDLE TmHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PUNICODE_STRING LogFileName,
    _In_opt_ LPGUID TmIdentity,
    _In_opt_ ULONG OpenOptions
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPlugPlayControl(
    _In_ PLUGPLAY_CONTROL_CLASS PnPControlClass,
    _Inout_updates_bytes_(PnPControlDataLength) PVOID PnPControlData,
    _In_ ULONG PnPControlDataLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPowerInformation(
    _In_ POWER_INFORMATION_LEVEL InformationLevel,
    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPrepareComplete(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPrepareEnlistment(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPrePrepareComplete(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPrePrepareEnlistment(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPrivilegeCheck(
    _In_ HANDLE ClientToken,
    _Inout_ PPRIVILEGE_SET RequiredPrivileges,
    _Out_ PBOOLEAN Result
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPrivilegedServiceAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_ PUNICODE_STRING ServiceName,
    _In_ HANDLE ClientToken,
    _In_ PPRIVILEGE_SET Privileges,
    _In_ BOOLEAN AccessGranted
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPrivilegeObjectAuditAlarm(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ PPRIVILEGE_SET Privileges,
    _In_ BOOLEAN AccessGranted
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPropagationComplete(
    _In_ HANDLE ResourceManagerHandle,
    _In_ ULONG RequestCookie,
    _In_ ULONG BufferLength,
    _In_ PVOID Buffer
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPropagationFailed(
    _In_ HANDLE ResourceManagerHandle,
    _In_ ULONG RequestCookie,
    _In_ NTSTATUS PropStatus
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwProtectVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG NewProtect,
    _Out_ PULONG OldProtect
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPulseEvent(
    _In_ HANDLE EventHandle,
    _Out_opt_ PLONG PreviousState
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryAttributesFile(
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PFILE_BASIC_INFORMATION FileInformation
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryBootEntryOrder(
    _Out_writes_opt_(*Count) PULONG Ids,
    _Inout_ PULONG Count
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryBootOptions(
    _Out_writes_bytes_opt_(*BootOptionsLength) PBOOT_OPTIONS BootOptions,
    _Inout_ PULONG BootOptionsLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryDebugFilterState(
    _In_ ULONG ComponentId,
    _In_ ULONG Level
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryDefaultLocale(
    _In_ BOOLEAN UserProfile,
    _Out_ PLCID DefaultLocaleId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryDefaultUILanguage(
    _Out_ LANGID *DefaultUILanguageId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryDirectoryFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_opt_ PUNICODE_STRING FileName,
    _In_ BOOLEAN RestartScan
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryDirectoryObject(
    _In_ HANDLE DirectoryHandle,
    _Out_writes_bytes_opt_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_ BOOLEAN RestartScan,
    _Inout_ PULONG Context,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryDriverEntryOrder(
    _Out_writes_opt_(*Count) PULONG Ids,
    _Inout_ PULONG Count
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryEaFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_reads_bytes_opt_(EaListLength) PVOID EaList,
    _In_ ULONG EaListLength,
    _In_opt_ PULONG EaIndex,
    _In_ BOOLEAN RestartScan
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryEvent(
    _In_ HANDLE EventHandle,
    _In_ EVENT_INFORMATION_CLASS EventInformationClass,
    _Out_writes_bytes_(EventInformationLength) PVOID EventInformation,
    _In_ ULONG EventInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryFullAttributesFile(
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PFILE_NETWORK_OPEN_INFORMATION FileInformation
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInformationAtom(
    _In_ RTL_ATOM Atom,
    _In_ ATOM_INFORMATION_CLASS AtomInformationClass,
    _Out_writes_bytes_(AtomInformationLength) PVOID AtomInformation,
    _In_ ULONG AtomInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInformationByName(
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInformationEnlistment(
    _In_ HANDLE EnlistmentHandle,
    _In_ ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass,
    _Out_writes_bytes_(EnlistmentInformationLength) PVOID EnlistmentInformation,
    _In_ ULONG EnlistmentInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInformationJobObject(
    _In_opt_ HANDLE JobHandle,
    _In_ JOBOBJECTINFOCLASS JobObjectInformationClass,
    _Out_writes_bytes_(JobObjectInformationLength) PVOID JobObjectInformation,
    _In_ ULONG JobObjectInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInformationPort(
    _In_ HANDLE PortHandle,
    _In_ PORT_INFORMATION_CLASS PortInformationClass,
    _Out_writes_bytes_to_(Length, *ReturnLength) PVOID PortInformation,
    _In_ ULONG Length,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInformationProcess(
    _In_ HANDLE ProcessHandle,
    _In_ PROCESSINFOCLASS ProcessInformationClass,
    _Out_writes_bytes_(ProcessInformationLength) PVOID ProcessInformation,
    _In_ ULONG ProcessInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInformationResourceManager(
    _In_ HANDLE ResourceManagerHandle,
    _In_ RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass,
    _Out_writes_bytes_(ResourceManagerInformationLength) PVOID ResourceManagerInformation,
    _In_ ULONG ResourceManagerInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInformationThread(
    _In_ HANDLE ThreadHandle,
    _In_ THREADINFOCLASS ThreadInformationClass,
    _Out_writes_bytes_(ThreadInformationLength) PVOID ThreadInformation,
    _In_ ULONG ThreadInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInformationToken(
    _In_ HANDLE TokenHandle,
    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,
    _Out_writes_bytes_(TokenInformationLength) PVOID TokenInformation,
    _In_ ULONG TokenInformationLength,
    _Out_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInformationTransaction(
    _In_ HANDLE TransactionHandle,
    _In_ TRANSACTION_INFORMATION_CLASS TransactionInformationClass,
    _Out_writes_bytes_(TransactionInformationLength) PVOID TransactionInformation,
    _In_ ULONG TransactionInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInformationTransactionManager(
    _In_ HANDLE TransactionManagerHandle,
    _In_ TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass,
    _Out_writes_bytes_(TransactionManagerInformationLength) PVOID TransactionManagerInformation,
    _In_ ULONG TransactionManagerInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInformationWorkerFactory(
    _In_ HANDLE WorkerFactoryHandle,
    _In_ WORKERFACTORYINFOCLASS WorkerFactoryInformationClass,
    _Out_writes_bytes_(WorkerFactoryInformationLength) PVOID WorkerFactoryInformation,
    _In_ ULONG WorkerFactoryInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInstallUILanguage(
    _Out_ LANGID *InstallUILanguageId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryIntervalProfile(
    _In_ KPROFILE_SOURCE ProfileSource,
    _Out_ PULONG Interval
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryIoCompletion(
    _In_ HANDLE IoCompletionHandle,
    _In_ IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass,
    _Out_writes_bytes_(IoCompletionInformationLength) PVOID IoCompletionInformation,
    _In_ ULONG IoCompletionInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryKey(
    _In_ HANDLE KeyHandle,
    _In_ KEY_INFORMATION_CLASS KeyInformationClass,
    _Out_writes_bytes_opt_(Length) PVOID KeyInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryLicenseValue(
    _In_ PUNICODE_STRING ValueName,
    _Out_opt_ PULONG Type,
    _Out_writes_bytes_to_opt_(DataSize, *ResultDataSize) PVOID Data,
    _In_ ULONG DataSize,
    _Out_ PULONG ResultDataSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryMultipleValueKey(
    _In_ HANDLE KeyHandle,
    _Inout_updates_(EntryCount) PKEY_VALUE_ENTRY ValueEntries,
    _In_ ULONG EntryCount,
    _Out_writes_bytes_(*BufferLength) PVOID ValueBuffer,
    _Inout_ PULONG BufferLength,
    _Out_opt_ PULONG RequiredBufferLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryMutant(
    _In_ HANDLE MutantHandle,
    _In_ MUTANT_INFORMATION_CLASS MutantInformationClass,
    _Out_writes_bytes_(MutantInformationLength) PVOID MutantInformation,
    _In_ ULONG MutantInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryObject(
    _In_opt_ HANDLE Handle,
    _In_ OBJECT_INFORMATION_CLASS ObjectInformationClass,
    _Out_writes_bytes_opt_(ObjectInformationLength) PVOID ObjectInformation,
    _In_ ULONG ObjectInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryOpenSubKeys(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _Out_ PULONG HandleCount
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryOpenSubKeysEx(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ ULONG BufferLength,
    _Out_writes_bytes_opt_(BufferLength) PVOID Buffer,
    _Out_ PULONG RequiredSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryPerformanceCounter(
    _Out_ PLARGE_INTEGER PerformanceCounter,
    _Out_opt_ PLARGE_INTEGER PerformanceFrequency
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryPortInformationProcess(
    VOID
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryQuotaInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_reads_bytes_opt_(SidListLength) PVOID SidList,
    _In_ ULONG SidListLength,
    _In_opt_ PSID StartSid,
    _In_ BOOLEAN RestartScan
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQuerySection(
    _In_ HANDLE SectionHandle,
    _In_ SECTION_INFORMATION_CLASS SectionInformationClass,
    _Out_writes_bytes_(SectionInformationLength) PVOID SectionInformation,
    _In_ SIZE_T SectionInformationLength,
    _Out_opt_ PSIZE_T ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQuerySecurityAttributesToken(
    _In_ HANDLE TokenHandle,
    _In_reads_opt_(NumberOfAttributes) PUNICODE_STRING Attributes,
    _In_ ULONG NumberOfAttributes,
    _Out_writes_bytes_(Length) PVOID Buffer, // PTOKEN_SECURITY_ATTRIBUTES_INFORMATION
    _In_ ULONG Length,
    _Out_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQuerySecurityObject(
    _In_ HANDLE Handle,
    _In_ SECURITY_INFORMATION SecurityInformation,
    _Out_writes_bytes_opt_(Length) PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ ULONG Length,
    _Out_ PULONG LengthNeeded
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQuerySemaphore(
    _In_ HANDLE SemaphoreHandle,
    _In_ SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass,
    _Out_writes_bytes_(SemaphoreInformationLength) PVOID SemaphoreInformation,
    _In_ ULONG SemaphoreInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQuerySymbolicLinkObject(
    _In_ HANDLE LinkHandle,
    _Inout_ PUNICODE_STRING LinkTarget,
    _Out_opt_ PULONG ReturnedLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQuerySystemEnvironmentValue(
    _In_ PUNICODE_STRING VariableName,
    _Out_writes_bytes_(ValueLength) PWSTR VariableValue,
    _In_ USHORT ValueLength,
    _Out_opt_ PUSHORT ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQuerySystemEnvironmentValueEx(
    _In_ PUNICODE_STRING VariableName,
    _In_ LPGUID VendorGuid,
    _Out_writes_bytes_opt_(*ValueLength) PVOID Value,
    _Inout_ PULONG ValueLength,
    _Out_opt_ PULONG Attributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQuerySystemInformation(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _Out_writes_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
    _In_ ULONG SystemInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQuerySystemInformationEx(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _In_reads_bytes_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
    _In_ ULONG SystemInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQuerySystemTime(
    _Out_ PLARGE_INTEGER SystemTime
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryTimer(
    _In_ HANDLE TimerHandle,
    _In_ TIMER_INFORMATION_CLASS TimerInformationClass,
    _Out_writes_bytes_(TimerInformationLength) PVOID TimerInformation,
    _In_ ULONG TimerInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryTimerResolution(
    _Out_ PULONG MaximumTime,
    _Out_ PULONG MinimumTime,
    _Out_ PULONG CurrentTime
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryValueKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING ValueName,
    _In_ KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    _Out_writes_bytes_opt_(Length) PVOID KeyValueInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _In_ MEMORY_INFORMATION_CLASS MemoryInformationClass,
    _Out_writes_bytes_(MemoryInformationLength) PVOID MemoryInformation,
    _In_ SIZE_T MemoryInformationLength,
    _Out_opt_ PSIZE_T ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryVolumeInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID FsInformation,
    _In_ ULONG Length,
    _In_ FSINFOCLASS FsInformationClass
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryWnfStateData(
    _In_ PCWNF_STATE_NAME StateName,
    _In_opt_ PCWNF_TYPE_ID TypeId,
    _In_opt_ const VOID *ExplicitScope,
    _Out_ PWNF_CHANGE_STAMP ChangeStamp,
    _Out_writes_bytes_to_opt_(*BufferSize, *BufferSize) PVOID Buffer,
    _Inout_ PULONG BufferSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryWnfStateNameInformation(
    _In_ PCWNF_STATE_NAME StateName,
    _In_ WNF_STATE_NAME_INFORMATION NameInfoClass,
    _In_opt_ const VOID *ExplicitScope,
    _Out_writes_bytes_(InfoBufferSize) PVOID InfoBuffer,
    _In_ ULONG InfoBufferSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueueApcThread(
    _In_ HANDLE ThreadHandle,
    _In_ PPS_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcArgument1,
    _In_opt_ PVOID ApcArgument2,
    _In_opt_ PVOID ApcArgument3
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueueApcThreadEx(
    _In_ HANDLE ThreadHandle,
    _In_opt_ HANDLE UserApcReserveHandle,
    _In_ PPS_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcArgument1,
    _In_opt_ PVOID ApcArgument2,
    _In_opt_ PVOID ApcArgument3
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRaiseException(
    _In_ PEXCEPTION_RECORD ExceptionRecord,
    _In_ PCONTEXT ContextRecord,
    _In_ BOOLEAN FirstChance
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRaiseHardError(
    _In_ NTSTATUS ErrorStatus,
    _In_ ULONG NumberOfParameters,
    _In_ ULONG UnicodeStringParameterMask,
    _In_reads_(NumberOfParameters) PULONG_PTR Parameters,
    _In_ ULONG ValidResponseOptions,
    _Out_ PULONG Response
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReadFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReadFileScatter(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PFILE_SEGMENT_ELEMENT SegmentArray,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReadOnlyEnlistment(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReadRequestData(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE Message,
    _In_ ULONG DataEntryIndex,
    _Out_writes_bytes_to_(BufferSize, *NumberOfBytesRead) PVOID Buffer,
    _In_ SIZE_T BufferSize,
    _Out_opt_ PSIZE_T NumberOfBytesRead
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReadVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _Out_writes_bytes_(BufferSize) PVOID Buffer,
    _In_ SIZE_T BufferSize,
    _Out_opt_ PSIZE_T NumberOfBytesRead
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRecoverEnlistment(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PVOID EnlistmentKey
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRecoverResourceManager(
    _In_ HANDLE ResourceManagerHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRecoverTransactionManager(
    _In_ HANDLE TransactionManagerHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRegisterProtocolAddressInformation(
    _In_ HANDLE ResourceManager,
    _In_ PCRM_PROTOCOL_ID ProtocolId,
    _In_ ULONG ProtocolInformationSize,
    _In_ PVOID ProtocolInformation,
    _In_opt_ ULONG CreateOptions
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRegisterThreadTerminatePort(
    _In_ HANDLE PortHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReleaseCMFViewOwnership(
    VOID
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReleaseKeyedEvent(
    _In_ HANDLE KeyedEventHandle,
    _In_ PVOID KeyValue,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReleaseMutant(
    _In_ HANDLE MutantHandle,
    _Out_opt_ PLONG PreviousCount
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReleaseSemaphore(
    _In_ HANDLE SemaphoreHandle,
    _In_ LONG ReleaseCount,
    _Out_opt_ PLONG PreviousCount
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReleaseWorkerFactoryWorker(
    _In_ HANDLE WorkerFactoryHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRemoveIoCompletion(
    _In_ HANDLE IoCompletionHandle,
    _Out_ PVOID *KeyContext,
    _Out_ PVOID *ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_opt_ PLARGE_INTEGER Timeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRemoveIoCompletionEx(
    _In_ HANDLE IoCompletionHandle,
    _Out_writes_to_(Count, *NumEntriesRemoved) PFILE_IO_COMPLETION_INFORMATION IoCompletionInformation,
    _In_ ULONG Count,
    _Out_ PULONG NumEntriesRemoved,
    _In_opt_ PLARGE_INTEGER Timeout,
    _In_ BOOLEAN Alertable
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRemoveProcessDebug(
    _In_ HANDLE ProcessHandle,
    _In_ HANDLE DebugObjectHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRenameKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING NewName
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRenameTransactionManager(
    _In_ PUNICODE_STRING LogFileName,
    _In_ LPGUID ExistingTransactionManagerGuid
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReplaceKey(
    _In_ POBJECT_ATTRIBUTES NewFile,
    _In_ HANDLE TargetHandle,
    _In_ POBJECT_ATTRIBUTES OldFile
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReplacePartitionUnit(
    _In_ PUNICODE_STRING TargetInstancePath,
    _In_ PUNICODE_STRING SpareInstancePath,
    _In_ ULONG Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReplyPort(
    _In_ HANDLE PortHandle,
    _In_reads_bytes_(ReplyMessage->u1.s1.TotalLength) PPORT_MESSAGE ReplyMessage
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReplyWaitReceivePort(
    _In_ HANDLE PortHandle,
    _Out_opt_ PVOID *PortContext,
    _In_reads_bytes_opt_(ReplyMessage->u1.s1.TotalLength) PPORT_MESSAGE ReplyMessage,
    _Out_ PPORT_MESSAGE ReceiveMessage
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReplyWaitReceivePortEx(
    _In_ HANDLE PortHandle,
    _Out_opt_ PVOID *PortContext,
    _In_reads_bytes_opt_(ReplyMessage->u1.s1.TotalLength) PPORT_MESSAGE ReplyMessage,
    _Out_ PPORT_MESSAGE ReceiveMessage,
    _In_opt_ PLARGE_INTEGER Timeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReplyWaitReplyPort(
    _In_ HANDLE PortHandle,
    _Inout_ PPORT_MESSAGE ReplyMessage
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRequestPort(
    _In_ HANDLE PortHandle,
    _In_reads_bytes_(RequestMessage->u1.s1.TotalLength) PPORT_MESSAGE RequestMessage
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRequestWaitReplyPort(
    _In_ HANDLE PortHandle,
    _In_reads_bytes_(RequestMessage->u1.s1.TotalLength) PPORT_MESSAGE RequestMessage,
    _Out_ PPORT_MESSAGE ReplyMessage
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRequestWakeupLatency(
    _In_ LATENCY_TIME latency
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwResetEvent(
    _In_ HANDLE EventHandle,
    _Out_opt_ PLONG PreviousState
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwResetWriteWatch(
    _In_ HANDLE ProcessHandle,
    _In_ PVOID BaseAddress,
    _In_ SIZE_T RegionSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRestoreKey(
    _In_ HANDLE KeyHandle,
    _In_ HANDLE FileHandle,
    _In_ ULONG Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwResumeProcess(
    _In_ HANDLE ProcessHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwResumeThread(
    _In_ HANDLE ThreadHandle,
    _Out_opt_ PULONG PreviousSuspendCount
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRevertContainerImpersonation(
    VOID
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRollbackComplete(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRollbackEnlistment(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRollbackTransaction(
    _In_ HANDLE TransactionHandle,
    _In_ BOOLEAN Wait
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRollforwardTransactionManager(
    _In_ HANDLE TransactionManagerHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSaveKey(
    _In_ HANDLE KeyHandle,
    _In_ HANDLE FileHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSaveKeyEx(
    _In_ HANDLE KeyHandle,
    _In_ HANDLE FileHandle,
    _In_ ULONG Format
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSaveMergedKeys(
    _In_ HANDLE HighPrecedenceKeyHandle,
    _In_ HANDLE LowPrecedenceKeyHandle,
    _In_ HANDLE FileHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSecureConnectPort(
    _Out_ PHANDLE PortHandle,
    _In_ PUNICODE_STRING PortName,
    _In_ PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    _Inout_opt_ PPORT_VIEW ClientView,
    _In_opt_ PSID RequiredServerSid,
    _Inout_opt_ PREMOTE_PORT_VIEW ServerView,
    _Out_opt_ PULONG MaxMessageLength,
    _Inout_updates_bytes_to_opt_(*ConnectionInformationLength, *ConnectionInformationLength) PVOID ConnectionInformation,
    _Inout_opt_ PULONG ConnectionInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSerializeBoot(
    VOID
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetBootEntryOrder(
    _In_reads_(Count) PULONG Ids,
    _In_ ULONG Count
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetBootOptions(
    _In_ PBOOT_OPTIONS BootOptions,
    _In_ ULONG FieldsToChange
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetCachedSigningLevel(
    _In_ ULONG Flags,
    _In_ SE_SIGNING_LEVEL InputSigningLevel,
    _In_reads_(SourceFileCount) PHANDLE SourceFiles,
    _In_ ULONG SourceFileCount,
    _In_opt_ HANDLE TargetFile
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetContextThread(
    _In_ HANDLE ThreadHandle,
    _In_ PCONTEXT ThreadContext
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetDebugFilterState(
    _In_ ULONG ComponentId,
    _In_ ULONG Level,
    _In_ BOOLEAN State
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetDefaultHardErrorPort(
    _In_ HANDLE DefaultHardErrorPort
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetDefaultLocale(
    _In_ BOOLEAN UserProfile,
    _In_ LCID DefaultLocaleId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetDefaultUILanguage(
    _In_ LANGID DefaultUILanguageId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetDriverEntryOrder(
    _In_reads_(Count) PULONG Ids,
    _In_ ULONG Count
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetEaFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_reads_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetEvent(
    _In_ HANDLE EventHandle,
    _Out_opt_ PLONG PreviousState
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetEventBoostPriority(
    _In_ HANDLE EventHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetHighEventPair(
    _In_ HANDLE EventPairHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetHighWaitLowEventPair(
    _In_ HANDLE EventPairHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationDebugObject(
    _In_ HANDLE DebugObjectHandle,
    _In_ DEBUGOBJECTINFOCLASS DebugObjectInformationClass,
    _In_ PVOID DebugInformation,
    _In_ ULONG DebugInformationLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationEnlistment(
    _In_opt_ HANDLE EnlistmentHandle,
    _In_ ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass,
    _In_reads_bytes_(EnlistmentInformationLength) PVOID EnlistmentInformation,
    _In_ ULONG EnlistmentInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_reads_bytes_(Length) PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationJobObject(
    _In_ HANDLE JobHandle,
    _In_ JOBOBJECTINFOCLASS JobObjectInformationClass,
    _In_reads_bytes_(JobObjectInformationLength) PVOID JobObjectInformation,
    _In_ ULONG JobObjectInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationKey(
    _In_ HANDLE KeyHandle,
    _In_ KEY_SET_INFORMATION_CLASS KeySetInformationClass,
    _In_reads_bytes_(KeySetInformationLength) PVOID KeySetInformation,
    _In_ ULONG KeySetInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationObject(
    _In_ HANDLE Handle,
    _In_ OBJECT_INFORMATION_CLASS ObjectInformationClass,
    _In_reads_bytes_(ObjectInformationLength) PVOID ObjectInformation,
    _In_ ULONG ObjectInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationProcess(
    _In_ HANDLE ProcessHandle,
    _In_ PROCESSINFOCLASS ProcessInformationClass,
    _In_reads_bytes_(ProcessInformationLength) PVOID ProcessInformation,
    _In_ ULONG ProcessInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationResourceManager(
    _In_ HANDLE ResourceManagerHandle,
    _In_ RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass,
    _In_reads_bytes_(ResourceManagerInformationLength) PVOID ResourceManagerInformation,
    _In_ ULONG ResourceManagerInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationThread(
    _In_ HANDLE ThreadHandle,
    _In_ THREADINFOCLASS ThreadInformationClass,
    _In_reads_bytes_(ThreadInformationLength) PVOID ThreadInformation,
    _In_ ULONG ThreadInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationToken(
    _In_ HANDLE TokenHandle,
    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,
    _In_reads_bytes_(TokenInformationLength) PVOID TokenInformation,
    _In_ ULONG TokenInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationTransaction(
    _In_ HANDLE TransactionHandle,
    _In_ TRANSACTION_INFORMATION_CLASS TransactionInformationClass,
    _In_reads_bytes_(TransactionInformationLength) PVOID TransactionInformation,
    _In_ ULONG TransactionInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationTransactionManager(
    _In_opt_ HANDLE TmHandle,
    _In_ TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass,
    _In_reads_bytes_(TransactionManagerInformationLength) PVOID TransactionManagerInformation,
    _In_ ULONG TransactionManagerInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_ VIRTUAL_MEMORY_INFORMATION_CLASS VmInformationClass,
    _In_ ULONG_PTR NumberOfEntries,
    _In_reads_ (NumberOfEntries) PMEMORY_RANGE_ENTRY VirtualAddresses,
    _In_reads_bytes_ (VmInformationLength) PVOID VmInformation,
    _In_ ULONG VmInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationWorkerFactory(
    _In_ HANDLE WorkerFactoryHandle,
    _In_ WORKERFACTORYINFOCLASS WorkerFactoryInformationClass,
    _In_reads_bytes_(WorkerFactoryInformationLength) PVOID WorkerFactoryInformation,
    _In_ ULONG WorkerFactoryInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetIntervalProfile(
    _In_ ULONG Interval,
    _In_ KPROFILE_SOURCE Source
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetIoCompletion(
    _In_ HANDLE IoCompletionHandle,
    _In_opt_ PVOID KeyContext,
    _In_opt_ PVOID ApcContext,
    _In_ NTSTATUS IoStatus,
    _In_ ULONG_PTR IoStatusInformation
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetIoCompletionEx(
    _In_ HANDLE IoCompletionHandle,
    _In_ HANDLE IoCompletionPacketHandle,
    _In_opt_ PVOID KeyContext,
    _In_opt_ PVOID ApcContext,
    _In_ NTSTATUS IoStatus,
    _In_ ULONG_PTR IoStatusInformation
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetIRTimer(
    _In_ HANDLE TimerHandle,
    _In_opt_ PLARGE_INTEGER DueTime
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetLdtEntries(
    _In_ ULONG Selector0,
    _In_ ULONG Entry0Low,
    _In_ ULONG Entry0Hi,
    _In_ ULONG Selector1,
    _In_ ULONG Entry1Low,
    _In_ ULONG Entry1Hi
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetLowEventPair(
    _In_ HANDLE EventPairHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetLowWaitHighEventPair(
    _In_ HANDLE EventPairHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetQuotaInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_reads_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetSecurityObject(
    _In_ HANDLE Handle,
    _In_ SECURITY_INFORMATION SecurityInformation,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetSystemEnvironmentValue(
    _In_ PUNICODE_STRING VariableName,
    _In_ PUNICODE_STRING VariableValue
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetSystemEnvironmentValueEx(
    _In_ PUNICODE_STRING VariableName,
    _In_ LPGUID VendorGuid,
    _In_reads_bytes_opt_(ValueLength) PVOID Value,
    _In_ ULONG ValueLength,
    _In_ ULONG Attributes
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetSystemInformation(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _In_reads_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
    _In_ ULONG SystemInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetSystemPowerState(
    _In_ POWER_ACTION SystemAction,
    _In_ SYSTEM_POWER_STATE LightestSystemState,
    _In_ ULONG Flags // POWER_ACTION_* flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetSystemTime(
    _In_opt_ PLARGE_INTEGER SystemTime,
    _Out_opt_ PLARGE_INTEGER PreviousTime
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetThreadExecutionState(
    _In_ EXECUTION_STATE NewFlags, // ES_* flags
    _Out_ EXECUTION_STATE *PreviousFlags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetTimer(
    _In_ HANDLE TimerHandle,
    _In_ PLARGE_INTEGER DueTime,
    _In_opt_ PTIMER_APC_ROUTINE TimerApcRoutine,
    _In_opt_ PVOID TimerContext,
    _In_ BOOLEAN ResumeTimer,
    _In_opt_ LONG Period,
    _Out_opt_ PBOOLEAN PreviousState
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetTimer2(
    _In_ HANDLE TimerHandle,
    _In_ PLARGE_INTEGER DueTime,
    _In_opt_ PLARGE_INTEGER Period,
    _In_ PT2_SET_PARAMETERS Parameters
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetTimerEx(
    _In_ HANDLE TimerHandle,
    _In_ TIMER_SET_INFORMATION_CLASS TimerSetInformationClass,
    _Inout_updates_bytes_opt_(TimerSetInformationLength) PVOID TimerSetInformation,
    _In_ ULONG TimerSetInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetTimerResolution(
    _In_ ULONG DesiredTime,
    _In_ BOOLEAN SetResolution,
    _Out_ PULONG ActualTime
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetUuidSeed(
    _In_ PCHAR Seed
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetValueKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING ValueName,
    _In_opt_ ULONG TitleIndex,
    _In_ ULONG Type,
    _In_reads_bytes_opt_(DataSize) PVOID Data,
    _In_ ULONG DataSize
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetVolumeInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_reads_bytes_(Length) PVOID FsInformation,
    _In_ ULONG Length,
    _In_ FSINFOCLASS FsInformationClass
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetWnfProcessNotificationEvent(
    _In_ HANDLE NotificationEvent
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwShutdownSystem(
    _In_ SHUTDOWN_ACTION Action
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwShutdownWorkerFactory(
    _In_ HANDLE WorkerFactoryHandle,
    _Inout_ volatile LONG *PendingWorkerCount
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSignalAndWaitForSingleObject(
    _In_ HANDLE SignalHandle,
    _In_ HANDLE WaitHandle,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSinglePhaseReject(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwStartProfile(
    _In_ HANDLE ProfileHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwStopProfile(
    _In_ HANDLE ProfileHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSubscribeWnfStateChange(
    _In_ PCWNF_STATE_NAME StateName,
    _In_opt_ WNF_CHANGE_STAMP ChangeStamp,
    _In_ ULONG EventMask,
    _Out_opt_ PULONG64 SubscriptionId
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSuspendProcess(
    _In_ HANDLE ProcessHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSuspendThread(
    _In_ HANDLE ThreadHandle,
    _Out_opt_ PULONG PreviousSuspendCount
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSystemDebugControl(
    _In_ SYSDBG_COMMAND Command,
    _Inout_updates_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength,
    _Out_opt_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwTerminateJobObject(
    _In_ HANDLE JobHandle,
    _In_ NTSTATUS ExitStatus
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwTerminateProcess(
    _In_opt_ HANDLE ProcessHandle,
    _In_ NTSTATUS ExitStatus
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwTerminateThread(
    _In_opt_ HANDLE ThreadHandle,
    _In_ NTSTATUS ExitStatus
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwTestAlert(
    VOID
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwThawRegistry(
    VOID
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwThawTransactions(
    VOID
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwTraceControl(
    _In_ ULONG FunctionCode,
    _In_reads_bytes_opt_(InBufferLen) PVOID InBuffer,
    _In_ ULONG InBufferLen,
    _Out_writes_bytes_opt_(OutBufferLen) PVOID OutBuffer,
    _In_ ULONG OutBufferLen,
    _Out_ PULONG ReturnLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwTraceEvent(
    _In_ HANDLE TraceHandle,
    _In_ ULONG Flags,
    _In_ ULONG FieldSize,
    _In_ PVOID Fields
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwTranslateFilePath(
    _In_ PFILE_PATH InputFilePath,
    _In_ ULONG OutputType,
    _Out_writes_bytes_opt_(*OutputFilePathLength) PFILE_PATH OutputFilePath,
    _Inout_opt_ PULONG OutputFilePathLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwUmsThreadYield(
    _In_ PVOID SchedulerParam
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwUnloadDriver(
    _In_ PUNICODE_STRING DriverServiceName
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwUnloadKey(
    _In_ POBJECT_ATTRIBUTES TargetKey
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwUnloadKey2(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ ULONG Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwUnloadKeyEx(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_opt_ HANDLE Event
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwUnlockFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PLARGE_INTEGER ByteOffset,
    _In_ PLARGE_INTEGER Length,
    _In_ ULONG Key
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwUnlockVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG MapType
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwUnmapViewOfSection(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwUnmapViewOfSectionEx(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _In_ ULONG Flags
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwUnsubscribeWnfStateChange(
    _In_ PCWNF_STATE_NAME StateName
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwUpdateWnfStateData(
    _In_ PCWNF_STATE_NAME StateName,
    _In_reads_bytes_opt_(Length) const VOID *Buffer,
    _In_opt_ ULONG Length,
    _In_opt_ PCWNF_TYPE_ID TypeId,
    _In_opt_ const VOID *ExplicitScope,
    _In_ WNF_CHANGE_STAMP MatchingChangeStamp,
    _In_ LOGICAL CheckStamp
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwVdmControl(
    _In_ VDMSERVICECLASS Service,
    _Inout_ PVOID ServiceData
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWaitForAlertByThreadId(
    _In_ PVOID Address,
    _In_opt_ PLARGE_INTEGER Timeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWaitForDebugEvent(
    _In_ HANDLE DebugObjectHandle,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout,
    _Out_ PDBGUI_WAIT_STATE_CHANGE WaitStateChange
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWaitForKeyedEvent(
    _In_ HANDLE KeyedEventHandle,
    _In_ PVOID KeyValue,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWaitForMultipleObjects(
    _In_ ULONG Count,
    _In_reads_(Count) HANDLE Handles[],
    _In_ WAIT_TYPE WaitType,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWaitForMultipleObjects32(
    _In_ ULONG Count,
    _In_reads_(Count) LONG Handles[],
    _In_ WAIT_TYPE WaitType,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWaitForSingleObject(
    _In_ HANDLE Handle,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWaitForWorkViaWorkerFactory(
    _In_ HANDLE WorkerFactoryHandle,
    _Out_ struct _FILE_IO_COMPLETION_INFORMATION *MiniPacket
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWaitHighEventPair(
    _In_ HANDLE EventPairHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWaitLowEventPair(
    _In_ HANDLE EventPairHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWorkerFactoryWorkerReady(
    _In_ HANDLE WorkerFactoryHandle
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWriteFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_reads_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWriteFileGather(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PFILE_SEGMENT_ELEMENT SegmentArray,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWriteRequestData(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE Message,
    _In_ ULONG DataEntryIndex,
    _In_reads_bytes_(BufferSize) PVOID Buffer,
    _In_ SIZE_T BufferSize,
    _Out_opt_ PSIZE_T NumberOfBytesWritten
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWriteVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _In_reads_bytes_(BufferSize) PVOID Buffer,
    _In_ SIZE_T BufferSize,
    _Out_opt_ PSIZE_T NumberOfBytesWritten
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwYieldExecution(
    VOID
    );

#endif

```

`phnt/phnt.h`:

```h
#ifndef _PHNT_H
#define _PHNT_H

// This header file provides access to NT APIs.

// Definitions are annotated to indicate their source. If a definition is not annotated, it has been
// retrieved from an official Microsoft source (NT headers, DDK headers, winnt.h).

// * "winbase" indicates that a definition has been reconstructed from a Win32-ized NT definition in
//   winbase.h.
// * "rev" indicates that a definition has been reverse-engineered.
// * "dbg" indicates that a definition has been obtained from a debug message or assertion in a
//   checked build of the kernel or file.

// Reliability:
// 1. No annotation.
// 2. dbg.
// 3. symbols, private. Types may be incorrect.
// 4. winbase. Names and types may be incorrect.
// 5. rev.

// Mode
#define PHNT_MODE_KERNEL 0
#define PHNT_MODE_USER 1

// Version
#define PHNT_WIN2K 50
#define PHNT_WINXP 51
#define PHNT_WS03 52
#define PHNT_VISTA 60
#define PHNT_WIN7 61
#define PHNT_WIN8 62
#define PHNT_WINBLUE 63
#define PHNT_THRESHOLD 100
#define PHNT_THRESHOLD2 101
#define PHNT_REDSTONE 102
#define PHNT_REDSTONE2 103
#define PHNT_REDSTONE3 104
#define PHNT_REDSTONE4 105
#define PHNT_REDSTONE5 106
#define PHNT_19H1 107
#define PHNT_19H2 108

#ifndef PHNT_MODE
#define PHNT_MODE PHNT_MODE_USER
#endif

#ifndef PHNT_VERSION
#define PHNT_VERSION PHNT_19H2
#endif

// Options

//#define PHNT_NO_INLINE_INIT_STRING

#ifdef __cplusplus
extern "C" {
#endif

#if (PHNT_MODE != PHNT_MODE_KERNEL)
#include "phnt_ntdef.h"
#include "ntnls.h"
#include "ntkeapi.h"
#endif

#include "ntldr.h"
#include "ntexapi.h"

#include "ntmmapi.h"
#include "ntobapi.h"
#include "ntpsapi.h"

#if (PHNT_MODE != PHNT_MODE_KERNEL)
#include "cfg.h"
#include "ntdbg.h"
#include "ntioapi.h"
#include "ntlpcapi.h"
#include "ntpfapi.h"
#include "ntpnpapi.h"
#include "ntpoapi.h"
#include "ntregapi.h"
#include "ntrtl.h"
#endif

#if (PHNT_MODE != PHNT_MODE_KERNEL)

#include "ntseapi.h"
#include "nttmapi.h"
#include "nttp.h"
#include "ntxcapi.h"

#include "ntwow64.h"

#include "ntlsa.h"
#include "ntsam.h"

#include "ntmisc.h"

#include "ntzwapi.h"

#endif

#ifdef __cplusplus
}
#endif

#endif

```

`phnt/phnt_ntdef.h`:

```h
#ifndef _PHNT_NTDEF_H
#define _PHNT_NTDEF_H

#ifndef _NTDEF_
#define _NTDEF_

// This header file provides basic NT types not included in Win32. If you have included winnt.h
// (perhaps indirectly), you must use this file instead of ntdef.h.

#ifndef NOTHING
#define NOTHING
#endif

// Basic types

typedef struct _QUAD
{
    union
    {
        __int64 UseThisFieldToCopy;
        double DoNotUseThisField;
    };
} QUAD, *PQUAD;

// This isn't in NT, but it's useful.
typedef struct DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) _QUAD_PTR
{
    ULONG_PTR DoNotUseThisField1;
    ULONG_PTR DoNotUseThisField2;
} QUAD_PTR, *PQUAD_PTR;

typedef ULONG LOGICAL;
typedef ULONG *PLOGICAL;

typedef _Return_type_success_(return >= 0) LONG NTSTATUS;
typedef NTSTATUS *PNTSTATUS;

// Cardinal types

typedef char CCHAR;
typedef short CSHORT;
typedef ULONG CLONG;

typedef CCHAR *PCCHAR;
typedef CSHORT *PCSHORT;
typedef CLONG *PCLONG;

typedef PCSTR PCSZ;

// Specific

typedef UCHAR KIRQL, *PKIRQL;
typedef LONG KPRIORITY;
typedef USHORT RTL_ATOM, *PRTL_ATOM;

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;

// NT status macros

#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
#define NT_INFORMATION(Status) ((((ULONG)(Status)) >> 30) == 1)
#define NT_WARNING(Status) ((((ULONG)(Status)) >> 30) == 2)
#define NT_ERROR(Status) ((((ULONG)(Status)) >> 30) == 3)

#define NT_FACILITY_MASK 0xfff
#define NT_FACILITY_SHIFT 16
#define NT_FACILITY(Status) ((((ULONG)(Status)) >> NT_FACILITY_SHIFT) & NT_FACILITY_MASK)

#define NT_NTWIN32(Status) (NT_FACILITY(Status) == FACILITY_NTWIN32)
#define WIN32_FROM_NTSTATUS(Status) (((ULONG)(Status)) & 0xffff)

// Functions

#ifndef _WIN64
#define FASTCALL __fastcall
#else
#define FASTCALL
#endif

// Synchronization enumerations

typedef enum _EVENT_TYPE
{
    NotificationEvent,
    SynchronizationEvent
} EVENT_TYPE;

typedef enum _TIMER_TYPE
{
    NotificationTimer,
    SynchronizationTimer
} TIMER_TYPE;

typedef enum _WAIT_TYPE
{
    WaitAll,
    WaitAny,
    WaitNotification
} WAIT_TYPE;

// Strings

typedef struct _STRING
{
    USHORT Length;
    USHORT MaximumLength;
    _Field_size_bytes_part_opt_(MaximumLength, Length) PCHAR Buffer;
} STRING, *PSTRING, ANSI_STRING, *PANSI_STRING, OEM_STRING, *POEM_STRING;

typedef const STRING *PCSTRING;
typedef const ANSI_STRING *PCANSI_STRING;
typedef const OEM_STRING *PCOEM_STRING;

typedef struct _UNICODE_STRING
{
    USHORT Length;
    USHORT MaximumLength;
    _Field_size_bytes_part_(MaximumLength, Length) PWCH Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

typedef const UNICODE_STRING *PCUNICODE_STRING;

#define RTL_CONSTANT_STRING(s)  { sizeof(s) - sizeof((s)[0]), sizeof(s), (PWCH)(s) }

// Balanced tree node

#define RTL_BALANCED_NODE_RESERVED_PARENT_MASK 3

typedef struct _RTL_BALANCED_NODE
{
    union
    {
        struct _RTL_BALANCED_NODE *Children[2];
        struct
        {
            struct _RTL_BALANCED_NODE *Left;
            struct _RTL_BALANCED_NODE *Right;
        };
    };
    union
    {
        UCHAR Red : 1;
        UCHAR Balance : 2;
        ULONG_PTR ParentValue;
    };
} RTL_BALANCED_NODE, *PRTL_BALANCED_NODE;

#define RTL_BALANCED_NODE_GET_PARENT_POINTER(Node) \
    ((PRTL_BALANCED_NODE)((Node)->ParentValue & ~RTL_BALANCED_NODE_RESERVED_PARENT_MASK))

// Portability

typedef struct _SINGLE_LIST_ENTRY32
{
    ULONG Next;
} SINGLE_LIST_ENTRY32, *PSINGLE_LIST_ENTRY32;

typedef struct _STRING32
{
    USHORT Length;
    USHORT MaximumLength;
    ULONG Buffer;
} STRING32, *PSTRING32;

typedef STRING32 UNICODE_STRING32, *PUNICODE_STRING32;
typedef STRING32 ANSI_STRING32, *PANSI_STRING32;

typedef struct _STRING64
{
    USHORT Length;
    USHORT MaximumLength;
    ULONGLONG Buffer;
} STRING64, *PSTRING64;

typedef STRING64 UNICODE_STRING64, *PUNICODE_STRING64;
typedef STRING64 ANSI_STRING64, *PANSI_STRING64;

// Object attributes

#define OBJ_INHERIT 0x00000002
#define OBJ_PERMANENT 0x00000010
#define OBJ_EXCLUSIVE 0x00000020
#define OBJ_CASE_INSENSITIVE 0x00000040
#define OBJ_OPENIF 0x00000080
#define OBJ_OPENLINK 0x00000100
#define OBJ_KERNEL_HANDLE 0x00000200
#define OBJ_FORCE_ACCESS_CHECK 0x00000400
#define OBJ_IGNORE_IMPERSONATED_DEVICEMAP 0x00000800
#define OBJ_DONT_REPARSE 0x00001000
#define OBJ_VALID_ATTRIBUTES 0x00001ff2

typedef struct _OBJECT_ATTRIBUTES
{
    ULONG Length;
    HANDLE RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor; // PSECURITY_DESCRIPTOR;
    PVOID SecurityQualityOfService; // PSECURITY_QUALITY_OF_SERVICE
} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;

typedef const OBJECT_ATTRIBUTES *PCOBJECT_ATTRIBUTES;

#define InitializeObjectAttributes(p, n, a, r, s) { \
    (p)->Length = sizeof(OBJECT_ATTRIBUTES); \
    (p)->RootDirectory = r; \
    (p)->Attributes = a; \
    (p)->ObjectName = n; \
    (p)->SecurityDescriptor = s; \
    (p)->SecurityQualityOfService = NULL; \
    }

#define RTL_CONSTANT_OBJECT_ATTRIBUTES(n, a) { sizeof(OBJECT_ATTRIBUTES), NULL, n, a, NULL, NULL }
#define RTL_INIT_OBJECT_ATTRIBUTES(n, a) RTL_CONSTANT_OBJECT_ATTRIBUTES(n, a)

#define OBJ_NAME_PATH_SEPARATOR ((WCHAR)L'\\')

// Portability

typedef struct _OBJECT_ATTRIBUTES64
{
    ULONG Length;
    ULONG64 RootDirectory;
    ULONG64 ObjectName;
    ULONG Attributes;
    ULONG64 SecurityDescriptor;
    ULONG64 SecurityQualityOfService;
} OBJECT_ATTRIBUTES64, *POBJECT_ATTRIBUTES64;

typedef const OBJECT_ATTRIBUTES64 *PCOBJECT_ATTRIBUTES64;

typedef struct _OBJECT_ATTRIBUTES32
{
    ULONG Length;
    ULONG RootDirectory;
    ULONG ObjectName;
    ULONG Attributes;
    ULONG SecurityDescriptor;
    ULONG SecurityQualityOfService;
} OBJECT_ATTRIBUTES32, *POBJECT_ATTRIBUTES32;

typedef const OBJECT_ATTRIBUTES32 *PCOBJECT_ATTRIBUTES32;

// Product types

typedef enum _NT_PRODUCT_TYPE
{
    NtProductWinNt = 1,
    NtProductLanManNt,
    NtProductServer
} NT_PRODUCT_TYPE, *PNT_PRODUCT_TYPE;

typedef enum _SUITE_TYPE
{
    SmallBusiness,
    Enterprise,
    BackOffice,
    CommunicationServer,
    TerminalServer,
    SmallBusinessRestricted,
    EmbeddedNT,
    DataCenter,
    SingleUserTS,
    Personal,
    Blade,
    EmbeddedRestricted,
    SecurityAppliance,
    StorageServer,
    ComputeServer,
    WHServer,
    PhoneNT,
    MaxSuiteType
} SUITE_TYPE;

// Specific

typedef struct _CLIENT_ID
{
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
} CLIENT_ID, *PCLIENT_ID;

typedef struct _CLIENT_ID32
{
    ULONG UniqueProcess;
    ULONG UniqueThread;
} CLIENT_ID32, *PCLIENT_ID32;

typedef struct _CLIENT_ID64
{
    ULONGLONG UniqueProcess;
    ULONGLONG UniqueThread;
} CLIENT_ID64, *PCLIENT_ID64;

#include <pshpack4.h>

typedef struct _KSYSTEM_TIME
{
    ULONG LowPart;
    LONG High1Time;
    LONG High2Time;
} KSYSTEM_TIME, *PKSYSTEM_TIME;

#include <poppack.h>

#endif

#endif

```

`phnt/phnt_windows.h`:

```h
#ifndef _PHNT_WINDOWS_H
#define _PHNT_WINDOWS_H

// This header file provides access to Win32, plus NTSTATUS values and some access mask values.

#ifndef CINTERFACE
#define CINTERFACE
#endif

#ifndef COBJMACROS
#define COBJMACROS
#endif

#ifndef INITGUID
#define INITGUID
#endif

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#ifndef WIN32_NO_STATUS
#define WIN32_NO_STATUS
#endif

#include <windows.h>
#include <windowsx.h>
#undef WIN32_NO_STATUS
#include <ntstatus.h>
#include <winioctl.h>



typedef double DOUBLE;
typedef GUID *PGUID;

// Desktop access rights
#define DESKTOP_ALL_ACCESS \
    (DESKTOP_CREATEMENU | DESKTOP_CREATEWINDOW | DESKTOP_ENUMERATE | \
    DESKTOP_HOOKCONTROL | DESKTOP_JOURNALPLAYBACK | DESKTOP_JOURNALRECORD | \
    DESKTOP_READOBJECTS | DESKTOP_SWITCHDESKTOP | DESKTOP_WRITEOBJECTS | \
    STANDARD_RIGHTS_REQUIRED)
#define DESKTOP_GENERIC_READ \
    (DESKTOP_ENUMERATE | DESKTOP_READOBJECTS | STANDARD_RIGHTS_READ)
#define DESKTOP_GENERIC_WRITE \
    (DESKTOP_CREATEMENU | DESKTOP_CREATEWINDOW | DESKTOP_HOOKCONTROL | \
    DESKTOP_JOURNALPLAYBACK | DESKTOP_JOURNALRECORD | DESKTOP_WRITEOBJECTS | \
    STANDARD_RIGHTS_WRITE)
#define DESKTOP_GENERIC_EXECUTE \
    (DESKTOP_SWITCHDESKTOP | STANDARD_RIGHTS_EXECUTE)

// Window station access rights
#define WINSTA_GENERIC_READ \
    (WINSTA_ENUMDESKTOPS | WINSTA_ENUMERATE | WINSTA_READATTRIBUTES | \
    WINSTA_READSCREEN | STANDARD_RIGHTS_READ)
#define WINSTA_GENERIC_WRITE \
    (WINSTA_ACCESSCLIPBOARD | WINSTA_CREATEDESKTOP | WINSTA_WRITEATTRIBUTES | \
    STANDARD_RIGHTS_WRITE)
#define WINSTA_GENERIC_EXECUTE \
    (WINSTA_ACCESSGLOBALATOMS | WINSTA_EXITWINDOWS | STANDARD_RIGHTS_EXECUTE)

// WMI access rights
#define WMIGUID_GENERIC_READ \
    (WMIGUID_QUERY | WMIGUID_NOTIFICATION | WMIGUID_READ_DESCRIPTION | \
    STANDARD_RIGHTS_READ)
#define WMIGUID_GENERIC_WRITE \
    (WMIGUID_SET | TRACELOG_CREATE_REALTIME | TRACELOG_CREATE_ONDISK | \
    STANDARD_RIGHTS_WRITE)
#define WMIGUID_GENERIC_EXECUTE \
    (WMIGUID_EXECUTE | TRACELOG_GUID_ENABLE | TRACELOG_LOG_EVENT | \
    TRACELOG_ACCESS_REALTIME | TRACELOG_REGISTER_GUIDS | \
    STANDARD_RIGHTS_EXECUTE)

#endif

#undef NTSYSCALLAPI
#define NTSYSCALLAPI
#undef NTSYSAPI
#define NTSYSAPI

```

`phnt/subprocesstag.h`:

```h
#ifndef _SUBPROCESSTAG_H
#define _SUBPROCESSTAG_H

// Subprocess tag information

typedef enum _TAG_INFO_LEVEL
{
    eTagInfoLevelNameFromTag = 1, // TAG_INFO_NAME_FROM_TAG
    eTagInfoLevelNamesReferencingModule, // TAG_INFO_NAMES_REFERENCING_MODULE
    eTagInfoLevelNameTagMapping, // TAG_INFO_NAME_TAG_MAPPING
    eTagInfoLevelMax
} TAG_INFO_LEVEL;

typedef enum _TAG_TYPE
{
    eTagTypeService = 1,
    eTagTypeMax
} TAG_TYPE;

typedef struct _TAG_INFO_NAME_FROM_TAG_IN_PARAMS
{
    ULONG dwPid;
    ULONG dwTag;
} TAG_INFO_NAME_FROM_TAG_IN_PARAMS, *PTAG_INFO_NAME_FROM_TAG_IN_PARAMS;

typedef struct _TAG_INFO_NAME_FROM_TAG_OUT_PARAMS
{
    ULONG eTagType;
    PWSTR pszName;
} TAG_INFO_NAME_FROM_TAG_OUT_PARAMS, *PTAG_INFO_NAME_FROM_TAG_OUT_PARAMS;

typedef struct _TAG_INFO_NAME_FROM_TAG
{
    TAG_INFO_NAME_FROM_TAG_IN_PARAMS InParams;
    TAG_INFO_NAME_FROM_TAG_OUT_PARAMS OutParams;
} TAG_INFO_NAME_FROM_TAG, *PTAG_INFO_NAME_FROM_TAG;

typedef struct _TAG_INFO_NAMES_REFERENCING_MODULE_IN_PARAMS
{
    ULONG dwPid;
    PWSTR pszModule;
} TAG_INFO_NAMES_REFERENCING_MODULE_IN_PARAMS, *PTAG_INFO_NAMES_REFERENCING_MODULE_IN_PARAMS;

typedef struct _TAG_INFO_NAMES_REFERENCING_MODULE_OUT_PARAMS
{
    ULONG eTagType;
    PWSTR pmszNames;
} TAG_INFO_NAMES_REFERENCING_MODULE_OUT_PARAMS, *PTAG_INFO_NAMES_REFERENCING_MODULE_OUT_PARAMS;

typedef struct _TAG_INFO_NAMES_REFERENCING_MODULE
{
    TAG_INFO_NAMES_REFERENCING_MODULE_IN_PARAMS InParams;
    TAG_INFO_NAMES_REFERENCING_MODULE_OUT_PARAMS OutParams;
} TAG_INFO_NAMES_REFERENCING_MODULE, *PTAG_INFO_NAMES_REFERENCING_MODULE;

typedef struct _TAG_INFO_NAME_TAG_MAPPING_IN_PARAMS
{
    ULONG dwPid;
} TAG_INFO_NAME_TAG_MAPPING_IN_PARAMS, *PTAG_INFO_NAME_TAG_MAPPING_IN_PARAMS;

typedef struct _TAG_INFO_NAME_TAG_MAPPING_ELEMENT
{
    ULONG eTagType;
    ULONG dwTag;
    PWSTR pszName;
    PWSTR pszGroupName;
} TAG_INFO_NAME_TAG_MAPPING_ELEMENT, *PTAG_INFO_NAME_TAG_MAPPING_ELEMENT;

typedef struct _TAG_INFO_NAME_TAG_MAPPING_OUT_PARAMS
{
    ULONG cElements;
    PTAG_INFO_NAME_TAG_MAPPING_ELEMENT pNameTagMappingElements;
} TAG_INFO_NAME_TAG_MAPPING_OUT_PARAMS, *PTAG_INFO_NAME_TAG_MAPPING_OUT_PARAMS;

typedef struct _TAG_INFO_NAME_TAG_MAPPING
{
    TAG_INFO_NAME_TAG_MAPPING_IN_PARAMS InParams;
    PTAG_INFO_NAME_TAG_MAPPING_OUT_PARAMS pOutParams;
} TAG_INFO_NAME_TAG_MAPPING, *PTAG_INFO_NAME_TAG_MAPPING;

_Must_inspect_result_
ULONG
WINAPI
I_QueryTagInformation(
    _In_opt_ PCWSTR MachineName,
    _In_ TAG_INFO_LEVEL InfoLevel,
    _Inout_ PVOID TagInfo
    );

typedef ULONG (WINAPI *PQUERY_TAG_INFORMATION)(
    _In_opt_ PCWSTR MachineName,
    _In_ TAG_INFO_LEVEL InfoLevel,
    _Inout_ PVOID TagInfo
    );

#endif

```

`phnt/winsta.h`:

```h
#ifndef _WINSTA_H
#define _WINSTA_H

// Access rights

#define WINSTATION_QUERY 0x00000001 // WinStationQueryInformation
#define WINSTATION_SET 0x00000002 // WinStationSetInformation
#define WINSTATION_RESET 0x00000004 // WinStationReset
#define WINSTATION_VIRTUAL 0x00000008 //read/write direct data
#define WINSTATION_SHADOW 0x00000010 // WinStationShadow
#define WINSTATION_LOGON 0x00000020 // logon to WinStation
#define WINSTATION_LOGOFF 0x00000040 // WinStationLogoff
#define WINSTATION_MSG 0x00000080 // WinStationMsg
#define WINSTATION_CONNECT 0x00000100 // WinStationConnect
#define WINSTATION_DISCONNECT 0x00000200 // WinStationDisconnect
#define WINSTATION_GUEST_ACCESS WINSTATION_LOGON

#define WINSTATION_CURRENT_GUEST_ACCESS (WINSTATION_VIRTUAL | WINSTATION_LOGOFF)
#define WINSTATION_USER_ACCESS (WINSTATION_GUEST_ACCESS | WINSTATION_QUERY | WINSTATION_CONNECT)
#define WINSTATION_CURRENT_USER_ACCESS \
    (WINSTATION_SET | WINSTATION_RESET | WINSTATION_VIRTUAL | \
    WINSTATION_LOGOFF | WINSTATION_DISCONNECT)
#define WINSTATION_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | WINSTATION_QUERY | \
    WINSTATION_SET | WINSTATION_RESET | WINSTATION_VIRTUAL | \
    WINSTATION_SHADOW | WINSTATION_LOGON | WINSTATION_MSG | \
    WINSTATION_CONNECT | WINSTATION_DISCONNECT)

#define WDPREFIX_LENGTH 12
#define CALLBACK_LENGTH 50
#define DLLNAME_LENGTH 32
#define CDNAME_LENGTH 32
#define WDNAME_LENGTH 32
#define PDNAME_LENGTH 32
#define DEVICENAME_LENGTH 128
#define MODEMNAME_LENGTH DEVICENAME_LENGTH
#define STACK_ADDRESS_LENGTH 128
#define MAX_BR_NAME 65
#define DIRECTORY_LENGTH 256
#define INITIALPROGRAM_LENGTH 256
#define USERNAME_LENGTH 20
#define DOMAIN_LENGTH 17
#define PASSWORD_LENGTH 14
#define NASISPECIFICNAME_LENGTH 14
#define NASIUSERNAME_LENGTH 47
#define NASIPASSWORD_LENGTH 24
#define NASISESSIONNAME_LENGTH 16
#define NASIFILESERVER_LENGTH 47

#define CLIENTDATANAME_LENGTH 7
#define CLIENTNAME_LENGTH 20
#define CLIENTADDRESS_LENGTH 30
#define IMEFILENAME_LENGTH 32
#define DIRECTORY_LENGTH 256
#define CLIENTLICENSE_LENGTH 32
#define CLIENTMODEM_LENGTH 40
#define CLIENT_PRODUCT_ID_LENGTH 32
#define MAX_COUNTER_EXTENSIONS 2
#define WINSTATIONNAME_LENGTH 32

#define TERMSRV_TOTAL_SESSIONS 1
#define TERMSRV_DISC_SESSIONS 2
#define TERMSRV_RECON_SESSIONS 3
#define TERMSRV_CURRENT_ACTIVE_SESSIONS 4
#define TERMSRV_CURRENT_DISC_SESSIONS 5
#define TERMSRV_PENDING_SESSIONS 6
#define TERMSRV_SUCC_TOTAL_LOGONS 7
#define TERMSRV_SUCC_LOCAL_LOGONS 8
#define TERMSRV_SUCC_REMOTE_LOGONS 9
#define TERMSRV_SUCC_SESSION0_LOGONS 10
#define TERMSRV_CURRENT_TERMINATING_SESSIONS 11
#define TERMSRV_CURRENT_LOGGEDON_SESSIONS 12

typedef RTL_TIME_ZONE_INFORMATION TS_TIME_ZONE_INFORMATION, *PTS_TIME_ZONE_INFORMATION;

typedef WCHAR WINSTATIONNAME[WINSTATIONNAME_LENGTH + 1];

// Variable length data descriptor (not needed)
typedef struct _VARDATA_WIRE
{
    USHORT Size;
    USHORT Offset;
} VARDATA_WIRE, *PVARDATA_WIRE;

typedef enum _WINSTATIONSTATECLASS
{
    State_Active = 0,
    State_Connected = 1,
    State_ConnectQuery = 2,
    State_Shadow = 3,
    State_Disconnected = 4,
    State_Idle = 5,
    State_Listen = 6,
    State_Reset = 7,
    State_Down = 8,
    State_Init = 9
} WINSTATIONSTATECLASS;

typedef struct _SESSIONIDW
{
    union
    {
        ULONG SessionId;
        ULONG LogonId;
    };
    WINSTATIONNAME WinStationName;
    WINSTATIONSTATECLASS State;
} SESSIONIDW, *PSESSIONIDW;

// private
typedef enum _WINSTATIONINFOCLASS
{
    WinStationCreateData, // WINSTATIONCREATE
    WinStationConfiguration, // WINSTACONFIGWIRE + USERCONFIG
    WinStationPdParams, // PDPARAMS
    WinStationWd, // WDCONFIG
    WinStationPd, // PDCONFIG2 + PDPARAMS
    WinStationPrinter, // Not supported.
    WinStationClient, // WINSTATIONCLIENT
    WinStationModules,
    WinStationInformation, // WINSTATIONINFORMATION
    WinStationTrace,
    WinStationBeep,
    WinStationEncryptionOff,
    WinStationEncryptionPerm,
    WinStationNtSecurity,
    WinStationUserToken, // WINSTATIONUSERTOKEN
    WinStationUnused1,
    WinStationVideoData, // WINSTATIONVIDEODATA
    WinStationInitialProgram,
    WinStationCd, // CDCONFIG
    WinStationSystemTrace,
    WinStationVirtualData,
    WinStationClientData, // WINSTATIONCLIENTDATA
    WinStationSecureDesktopEnter,
    WinStationSecureDesktopExit,
    WinStationLoadBalanceSessionTarget, // ULONG
    WinStationLoadIndicator, // WINSTATIONLOADINDICATORDATA
    WinStationShadowInfo, // WINSTATIONSHADOW
    WinStationDigProductId, // WINSTATIONPRODID
    WinStationLockedState, // BOOL
    WinStationRemoteAddress, // WINSTATIONREMOTEADDRESS
    WinStationIdleTime, // ULONG
    WinStationLastReconnectType, // ULONG
    WinStationDisallowAutoReconnect, // BOOLEAN
    WinStationMprNotifyInfo,
    WinStationExecSrvSystemPipe,
    WinStationSmartCardAutoLogon,
    WinStationIsAdminLoggedOn,
    WinStationReconnectedFromId, // ULONG
    WinStationEffectsPolicy, // ULONG
    WinStationType, // ULONG
    WinStationInformationEx, // WINSTATIONINFORMATIONEX 
    WinStationValidationInfo
} WINSTATIONINFOCLASS;

// Retrieves general information on the type of terminal server session (protocol) to which the session belongs.
typedef struct _WINSTATIONCREATE
{
    ULONG fEnableWinStation : 1;
    ULONG MaxInstanceCount;
} WINSTATIONCREATE, *PWINSTATIONCREATE;

typedef struct _WINSTACONFIGWIRE
{
    WCHAR Comment[61]; // The WinStation descriptive comment.
    CHAR OEMId[4]; // Value identifying the OEM implementor of the TermService Listener to which this session (WinStation) belongs. This can be any value defined by the implementer (OEM) of the listener.
    VARDATA_WIRE UserConfig; // VARDATA_WIRE structure defining the size and offset of the variable-length user configuration data succeeding it.
    VARDATA_WIRE NewFields; // VARDATA_WIRE structure defining the size and offset of the variable-length new data succeeding it. This field is not used and is a placeholder for any new data, if and when added.
} WINSTACONFIGWIRE, *PWINSTACONFIGWIRE;

typedef enum _CALLBACKCLASS
{
    Callback_Disable,
    Callback_Roving,
    Callback_Fixed
} CALLBACKCLASS;

// The SHADOWCLASS enumeration is used to indicate the shadow-related settings for a session running on a terminal server.
typedef enum _SHADOWCLASS
{
    Shadow_Disable, // Shadowing is disabled.
    Shadow_EnableInputNotify, // Permission is asked first from the session being shadowed. The shadower is also permitted keyboard and mouse input.
    Shadow_EnableInputNoNotify, // Permission is not asked first from the session being shadowed. The shadower is also permitted keyboard and mouse input.
    Shadow_EnableNoInputNotify, // Permission is asked first from the session being shadowed. The shadower is not permitted keyboard and mouse input and MUST observe the shadowed session.
    Shadow_EnableNoInputNoNotify // Permission is not asked first from the session being shadowed. The shadower is not permitted keyboard and mouse input and MUST observe the shadowed session.
} SHADOWCLASS;

// For a specific terminal server session, the USERCONFIG structure indicates the user and session configuration.
// https://msdn.microsoft.com/en-us/library/cc248610.aspx
typedef struct _USERCONFIG
{
    ULONG fInheritAutoLogon : 1;
    ULONG fInheritResetBroken : 1;
    ULONG fInheritReconnectSame : 1;
    ULONG fInheritInitialProgram : 1;
    ULONG fInheritCallback : 1;
    ULONG fInheritCallbackNumber : 1;
    ULONG fInheritShadow : 1;
    ULONG fInheritMaxSessionTime : 1;
    ULONG fInheritMaxDisconnectionTime : 1;
    ULONG fInheritMaxIdleTime : 1;
    ULONG fInheritAutoClient : 1;
    ULONG fInheritSecurity : 1;
    ULONG fPromptForPassword : 1;
    ULONG fResetBroken : 1;
    ULONG fReconnectSame : 1;
    ULONG fLogonDisabled : 1;
    ULONG fWallPaperDisabled : 1;
    ULONG fAutoClientDrives : 1;
    ULONG fAutoClientLpts : 1;
    ULONG fForceClientLptDef : 1;
    ULONG fRequireEncryption : 1;
    ULONG fDisableEncryption : 1;
    ULONG fUnused1 : 1;
    ULONG fHomeDirectoryMapRoot : 1;
    ULONG fUseDefaultGina : 1;
    ULONG fCursorBlinkDisabled : 1;
    ULONG fPublishedApp : 1;
    ULONG fHideTitleBar : 1;
    ULONG fMaximize : 1;
    ULONG fDisableCpm : 1;
    ULONG fDisableCdm : 1;
    ULONG fDisableCcm : 1;
    ULONG fDisableLPT : 1;
    ULONG fDisableClip : 1;
    ULONG fDisableExe : 1;
    ULONG fDisableCam : 1;
    ULONG fDisableAutoReconnect : 1;
    ULONG ColorDepth : 3;
    ULONG fInheritColorDepth : 1;
    ULONG fErrorInvalidProfile : 1;
    ULONG fPasswordIsScPin : 1;
    ULONG fDisablePNPRedir : 1;
    WCHAR UserName[USERNAME_LENGTH + 1];
    WCHAR Domain[DOMAIN_LENGTH + 1];
    WCHAR Password[PASSWORD_LENGTH + 1];
    WCHAR WorkDirectory[DIRECTORY_LENGTH + 1];
    WCHAR InitialProgram[INITIALPROGRAM_LENGTH + 1];
    WCHAR CallbackNumber[CALLBACK_LENGTH + 1];
    CALLBACKCLASS Callback;
    SHADOWCLASS Shadow;
    ULONG MaxConnectionTime;
    ULONG MaxDisconnectionTime;
    ULONG MaxIdleTime;
    ULONG KeyboardLayout;
    BYTE MinEncryptionLevel;
    WCHAR NWLogonServer[NASIFILESERVER_LENGTH + 1];
    WCHAR PublishedName[MAX_BR_NAME];
    WCHAR WFProfilePath[DIRECTORY_LENGTH + 1];
    WCHAR WFHomeDir[DIRECTORY_LENGTH + 1];
    WCHAR WFHomeDirDrive[4];
} USERCONFIG, *PUSERCONFIG;

typedef enum _SDCLASS
{
    SdNone = 0,
    SdConsole,
    SdNetwork,
    SdAsync,
    SdOemTransport
} SDCLASS;

typedef WCHAR DEVICENAME[DEVICENAME_LENGTH + 1];
typedef WCHAR MODEMNAME[MODEMNAME_LENGTH + 1];
typedef WCHAR NASISPECIFICNAME[NASISPECIFICNAME_LENGTH + 1];
typedef WCHAR NASIUSERNAME[NASIUSERNAME_LENGTH + 1];
typedef WCHAR NASIPASSWORD[NASIPASSWORD_LENGTH + 1];
typedef WCHAR NASISESIONNAME[NASISESSIONNAME_LENGTH + 1];
typedef WCHAR NASIFILESERVER[NASIFILESERVER_LENGTH + 1];
typedef WCHAR WDNAME[WDNAME_LENGTH + 1];
typedef WCHAR WDPREFIX[WDPREFIX_LENGTH + 1];
typedef WCHAR CDNAME[CDNAME_LENGTH + 1];
typedef WCHAR DLLNAME[DLLNAME_LENGTH + 1];
typedef WCHAR PDNAME[PDNAME_LENGTH + 1];

typedef struct _NETWORKCONFIG
{
    LONG LanAdapter;
    DEVICENAME NetworkName;
    ULONG Flags;
} NETWORKCONFIG, *PNETWORKCONFIG;

typedef enum _FLOWCONTROLCLASS
{
    FlowControl_None,
    FlowControl_Hardware,
    FlowControl_Software
} FLOWCONTROLCLASS;

typedef enum _RECEIVEFLOWCONTROLCLASS
{
    ReceiveFlowControl_None,
    ReceiveFlowControl_RTS,
    ReceiveFlowControl_DTR,
} RECEIVEFLOWCONTROLCLASS;

typedef enum _TRANSMITFLOWCONTROLCLASS
{
    TransmitFlowControl_None,
    TransmitFlowControl_CTS,
    TransmitFlowControl_DSR,
} TRANSMITFLOWCONTROLCLASS;

typedef enum _ASYNCCONNECTCLASS
{
    Connect_CTS,
    Connect_DSR,
    Connect_RI,
    Connect_DCD,
    Connect_FirstChar,
    Connect_Perm,
} ASYNCCONNECTCLASS;

typedef struct _FLOWCONTROLCONFIG
{
    ULONG fEnableSoftwareTx : 1;
    ULONG fEnableSoftwareRx : 1;
    ULONG fEnableDTR : 1;
    ULONG fEnableRTS : 1;
    CHAR XonChar;
    CHAR XoffChar;
    FLOWCONTROLCLASS Type;
    RECEIVEFLOWCONTROLCLASS HardwareReceive;
    TRANSMITFLOWCONTROLCLASS HardwareTransmit;
} FLOWCONTROLCONFIG, *PFLOWCONTROLCONFIG;

typedef struct _CONNECTCONFIG
{
    ASYNCCONNECTCLASS Type;
    ULONG fEnableBreakDisconnect : 1;
} CONNECTCONFIG, *PCONNECTCONFIG;

typedef struct _ASYNCCONFIG
{
    DEVICENAME DeviceName;
    MODEMNAME ModemName;
    ULONG BaudRate;
    ULONG Parity;
    ULONG StopBits;
    ULONG ByteSize;
    ULONG fEnableDsrSensitivity : 1;
    ULONG fConnectionDriver : 1;
    FLOWCONTROLCONFIG FlowControl;
    CONNECTCONFIG Connect;
} ASYNCCONFIG, *PASYNCCONFIG;

typedef struct _NASICONFIG
{
    NASISPECIFICNAME SpecificName;
    NASIUSERNAME UserName;
    NASIPASSWORD PassWord;
    NASISESIONNAME SessionName;
    NASIFILESERVER FileServer;
    BOOLEAN GlobalSession;
} NASICONFIG, *PNASICONFIG;

typedef struct _OEMTDCONFIG
{
    LONG Adapter;
    DEVICENAME DeviceName;
    ULONG Flags;
} OEMTDCONFIG, *POEMTDCONFIG;

// Retrieves transport protocol driver parameters.
typedef struct _PDPARAMS
{
    SDCLASS SdClass; // Stack driver class. Indicates which one of the union's structures is valid.
    union
    {
        NETWORKCONFIG Network; // Configuration of network drivers. Used if SdClass is SdNetwork.
        ASYNCCONFIG Async; // Configuration of async (modem) driver. Used if SdClass is SdAsync.
        NASICONFIG Nasi; // Reserved.
        OEMTDCONFIG OemTd; // Configuration of OEM transport driver. Used if SdClass is SdOemTransport.
    };
} PDPARAMS, *PPDPARAMS;

// The WinStation (session) driver configuration.
typedef struct _WDCONFIG
{
    WDNAME WdName; // The descriptive name of the WinStation driver.
    DLLNAME WdDLL; // The driver's image name.
    DLLNAME WsxDLL; // Used by the Terminal Services service to communicate with the WinStation driver.
    ULONG WdFlag; // Driver flags.
    ULONG WdInputBufferLength; // Length, in bytes, of the input buffer used by the driver. Defaults to 2048.
    DLLNAME CfgDLL; // Configuration DLL used by Terminal Services administrative tools for configuring the driver.
    WDPREFIX WdPrefix; // Used as the prefix of the WinStation name generated for the connected sessions with this WinStation driver.
} WDCONFIG, *PWDCONFIG;

// The protocol driver's software configuration.
typedef struct _PDCONFIG2
{
    PDNAME PdName;
    SDCLASS SdClass;
    DLLNAME PdDLL;
    ULONG PdFlag;
    ULONG OutBufLength;
    ULONG OutBufCount;
    ULONG OutBufDelay;
    ULONG InteractiveDelay;
    ULONG PortNumber;
    ULONG KeepAliveTimeout;
} PDCONFIG2, *PPDCONFIG2;

// WinStationClient
typedef struct _WINSTATIONCLIENT
{
    ULONG fTextOnly : 1;
    ULONG fDisableCtrlAltDel : 1;
    ULONG fMouse : 1;
    ULONG fDoubleClickDetect : 1;
    ULONG fINetClient : 1;
    ULONG fPromptForPassword : 1;
    ULONG fMaximizeShell : 1;
    ULONG fEnableWindowsKey : 1;
    ULONG fRemoteConsoleAudio : 1;
    ULONG fPasswordIsScPin : 1;
    ULONG fNoAudioPlayback : 1;
    ULONG fUsingSavedCreds : 1;
    WCHAR ClientName[CLIENTNAME_LENGTH + 1];
    WCHAR Domain[DOMAIN_LENGTH + 1];
    WCHAR UserName[USERNAME_LENGTH + 1];
    WCHAR Password[PASSWORD_LENGTH + 1];
    WCHAR WorkDirectory[DIRECTORY_LENGTH + 1];
    WCHAR InitialProgram[INITIALPROGRAM_LENGTH + 1];
    ULONG SerialNumber;
    BYTE EncryptionLevel;
    ULONG ClientAddressFamily;
    WCHAR ClientAddress[CLIENTADDRESS_LENGTH + 1];
    USHORT HRes;
    USHORT VRes;
    USHORT ColorDepth;
    USHORT ProtocolType;
    ULONG KeyboardLayout;
    ULONG KeyboardType;
    ULONG KeyboardSubType;
    ULONG KeyboardFunctionKey;
    WCHAR ImeFileName[IMEFILENAME_LENGTH + 1];
    WCHAR ClientDirectory[DIRECTORY_LENGTH + 1];
    WCHAR ClientLicense[CLIENTLICENSE_LENGTH + 1];
    WCHAR ClientModem[CLIENTMODEM_LENGTH + 1];
    ULONG ClientBuildNumber;
    ULONG ClientHardwareId;
    USHORT ClientProductId;
    USHORT OutBufCountHost;
    USHORT OutBufCountClient;
    USHORT OutBufLength;
    WCHAR AudioDriverName[9];
    TS_TIME_ZONE_INFORMATION ClientTimeZone;
    ULONG ClientSessionId;
    WCHAR ClientDigProductId[CLIENT_PRODUCT_ID_LENGTH];
    ULONG PerformanceFlags;
    ULONG ActiveInputLocale;
} WINSTATIONCLIENT, *PWINSTATIONCLIENT;

typedef struct _TSHARE_COUNTERS
{
    ULONG Reserved;
} TSHARE_COUNTERS, *PTSHARE_COUNTERS;

typedef struct _PROTOCOLCOUNTERS
{
    ULONG WdBytes;
    ULONG WdFrames;
    ULONG WaitForOutBuf;
    ULONG Frames;
    ULONG Bytes;
    ULONG CompressedBytes;
    ULONG CompressFlushes;
    ULONG Errors;
    ULONG Timeouts;
    ULONG AsyncFramingError;
    ULONG AsyncOverrunError;
    ULONG AsyncOverflowError;
    ULONG AsyncParityError;
    ULONG TdErrors;
    USHORT ProtocolType;
    USHORT Length;
    union
    {
        TSHARE_COUNTERS TShareCounters;
        ULONG Reserved[100];
    } Specific;
} PROTOCOLCOUNTERS, *PPROTOCOLCOUNTERS;

typedef struct _THINWIRECACHE
{
    ULONG CacheReads;
    ULONG CacheHits;
} THINWIRECACHE, *PTHINWIRECACHE;

#define MAX_THINWIRECACHE 4

typedef struct _RESERVED_CACHE
{
    THINWIRECACHE ThinWireCache[MAX_THINWIRECACHE];
} RESERVED_CACHE, *PRESERVED_CACHE;

typedef struct _TSHARE_CACHE
{
    ULONG Reserved;
} TSHARE_CACHE, *PTSHARE_CACHE;

typedef struct CACHE_STATISTICS
{
    USHORT ProtocolType;
    USHORT Length;
    union
    {
        RESERVED_CACHE ReservedCacheStats;
        TSHARE_CACHE TShareCacheStats;
        ULONG Reserved[20];
    } Specific;
} CACHE_STATISTICS, *PCACHE_STATISTICS;

typedef struct _PROTOCOLSTATUS
{
    PROTOCOLCOUNTERS Output;
    PROTOCOLCOUNTERS Input;
    CACHE_STATISTICS Cache;
    ULONG AsyncSignal;
    ULONG AsyncSignalMask;
} PROTOCOLSTATUS, *PPROTOCOLSTATUS;

// Retrieves information on the session.
typedef struct _WINSTATIONINFORMATION
{
    WINSTATIONSTATECLASS ConnectState;
    WINSTATIONNAME WinStationName;
    ULONG LogonId;
    LARGE_INTEGER ConnectTime;
    LARGE_INTEGER DisconnectTime;
    LARGE_INTEGER LastInputTime;
    LARGE_INTEGER LogonTime;
    PROTOCOLSTATUS Status;
    WCHAR Domain[DOMAIN_LENGTH + 1];
    WCHAR UserName[USERNAME_LENGTH + 1];
    LARGE_INTEGER CurrentTime;
} WINSTATIONINFORMATION, *PWINSTATIONINFORMATION;

// Retrieves the user's token in the session. Caller requires WINSTATION_ALL_ACCESS permission.
typedef struct _WINSTATIONUSERTOKEN
{
    HANDLE ProcessId;
    HANDLE ThreadId;
    HANDLE UserToken;
} WINSTATIONUSERTOKEN, *PWINSTATIONUSERTOKEN;

// Retrieves resolution and color depth of the session.
typedef struct _WINSTATIONVIDEODATA
{
    USHORT HResolution;
    USHORT VResolution;
    USHORT fColorDepth;
} WINSTATIONVIDEODATA, *PWINSTATIONVIDEODATA;

typedef enum _CDCLASS
{
    CdNone, // No connection driver.   
    CdModem, // Connection driver is a modem.
    CdClass_Maximum,
} CDCLASS;

// Connection driver configuration. It is used for connecting via modem to a server.
typedef struct _CDCONFIG
{
    CDCLASS CdClass; // Connection driver type.
    CDNAME CdName; // Connection driver descriptive name.
    DLLNAME CdDLL; // Connection driver image name.
    ULONG CdFlag; // Connection driver flags. Connection driver specific.
} CDCONFIG, *PCDCONFIG;

// The name has the following form:
// name syntax : xxxyyyy<null>
typedef CHAR CLIENTDATANAME[CLIENTDATANAME_LENGTH + 1];
typedef CHAR* PCLIENTDATANAME;

typedef struct _WINSTATIONCLIENTDATA
{
    CLIENTDATANAME DataName; // Identifies the type of data sent in this WINSTATIONCLIENTDATA structure. The definition is dependent on the caller and on the client receiving it. This MUST be a data name following a format similar to that of the CLIENTDATANAME data type.
    BOOLEAN fUnicodeData; // TRUE indicates data is in Unicode format; FALSE otherwise.
} WINSTATIONCLIENTDATA, *PWINSTATIONCLIENTDATA;

typedef enum _LOADFACTORTYPE
{
    ErrorConstraint, // An error occurred while obtaining constraint data.
    PagedPoolConstraint, // The amount of paged pool is the constraint.
    NonPagedPoolConstraint, // The amount of non-paged pool is the constraint.
    AvailablePagesConstraint, // The amount of available pages is the constraint.
    SystemPtesConstraint, // The number of system page table entries (PTEs) is the constraint.
    CPUConstraint // CPU usage is the constraint.
} LOADFACTORTYPE;

// The WINSTATIONLOADINDICATORDATA structure defines data used for the load balancing of a server.
typedef struct _WINSTATIONLOADINDICATORDATA
{
    ULONG RemainingSessionCapacity; // The estimated number of additional sessions that can be supported given the CPU constraint.
    LOADFACTORTYPE LoadFactor; // Indicates the most constrained current resource.
    ULONG TotalSessions; // The total number of sessions.
    ULONG DisconnectedSessions; // The number of disconnected sessions.
    LARGE_INTEGER IdleCPU; // This is always set to 0.
    LARGE_INTEGER TotalCPU; // This is always set to 0.
    ULONG RawSessionCapacity; // The raw number of sessions capacity.
    ULONG reserved[9]; // Reserved.
} WINSTATIONLOADINDICATORDATA, *PWINSTATIONLOADINDICATORDATA;

typedef enum _SHADOWSTATECLASS
{
    State_NoShadow, // No shadow operations are currently being performed on this session.
    State_Shadowing, // The session is shadowing a different session. The current session is referred to as a shadow client.
    State_Shadowed // The session is being shadowed by a different session. The current session is referred to as a shadow target.
} SHADOWSTATECLASS;

// Retrieves the current shadow state of a session.
typedef struct _WINSTATIONSHADOW
{
    SHADOWSTATECLASS ShadowState; // Specifies the current state of shadowing.
    SHADOWCLASS ShadowClass; // Specifies the type of shadowing.
    ULONG SessionId; // Specifies the session ID of the session.
    ULONG ProtocolType; // Specifies the type of protocol on the session. Can be one of the following values.
} WINSTATIONSHADOW, *PWINSTATIONSHADOW;

// Retrieves the client product ID and current product ID of the session.
typedef struct _WINSTATIONPRODID
{
    WCHAR DigProductId[CLIENT_PRODUCT_ID_LENGTH];
    WCHAR ClientDigProductId[CLIENT_PRODUCT_ID_LENGTH];
    WCHAR OuterMostDigProductId[CLIENT_PRODUCT_ID_LENGTH];
    ULONG CurrentSessionId;
    ULONG ClientSessionId;
    ULONG OuterMostSessionId;
} WINSTATIONPRODID, *PWINSTATIONPRODID;

// Retrieves the remote IP address of the terminal server client in the session.
typedef struct _WINSTATIONREMOTEADDRESS
{
    USHORT sin_family;
    union
    {
        struct
        {
            USHORT sin_port;
            ULONG sin_addr;
            UCHAR sin_zero[8];
        } ipv4;
        struct
        {
            USHORT sin6_port;
            ULONG sin6_flowinfo;
            USHORT sin6_addr[8];
            ULONG sin6_scope_id;
        } ipv6;
    };
} WINSTATIONREMOTEADDRESS, *PWINSTATIONREMOTEADDRESS;

// WinStationInformationEx

// private
typedef struct _WINSTATIONINFORMATIONEX_LEVEL1
{
    ULONG SessionId;
    WINSTATIONSTATECLASS SessionState;
    LONG SessionFlags;
    WINSTATIONNAME WinStationName;
    WCHAR UserName[USERNAME_LENGTH + 1];
    WCHAR DomainName[DOMAIN_LENGTH + 1];
    LARGE_INTEGER LogonTime;
    LARGE_INTEGER ConnectTime;
    LARGE_INTEGER DisconnectTime;
    LARGE_INTEGER LastInputTime;
    LARGE_INTEGER CurrentTime;
    PROTOCOLSTATUS ProtocolStatus;
} WINSTATIONINFORMATIONEX_LEVEL1, *PWINSTATIONINFORMATIONEX_LEVEL1;

// private
typedef struct _WINSTATIONINFORMATIONEX_LEVEL2
{
    ULONG SessionId;
    WINSTATIONSTATECLASS SessionState;
    LONG SessionFlags;
    WINSTATIONNAME WinStationName;
    WCHAR SamCompatibleUserName[USERNAME_LENGTH + 1];
    WCHAR SamCompatibleDomainName[DOMAIN_LENGTH + 1];
    LARGE_INTEGER LogonTime;
    LARGE_INTEGER ConnectTime;
    LARGE_INTEGER DisconnectTime;
    LARGE_INTEGER LastInputTime;
    LARGE_INTEGER CurrentTime;
    PROTOCOLSTATUS ProtocolStatus;
    WCHAR UserName[257];
    WCHAR DomainName[256];
} WINSTATIONINFORMATIONEX_LEVEL2, *PWINSTATIONINFORMATIONEX_LEVEL2;

// private
typedef union _WINSTATIONINFORMATIONEX_LEVEL
{
    WINSTATIONINFORMATIONEX_LEVEL1 WinStationInfoExLevel1;
    WINSTATIONINFORMATIONEX_LEVEL2 WinStationInfoExLevel2;
} WINSTATIONINFORMATIONEX_LEVEL, *PWINSTATIONINFORMATIONEX_LEVEL;

// private
typedef struct _WINSTATIONINFORMATIONEX
{
    ULONG Level;
    WINSTATIONINFORMATIONEX_LEVEL Data;
} WINSTATIONINFORMATIONEX, *PWINSTATIONINFORMATIONEX;

#define TS_PROCESS_INFO_MAGIC_NT4 0x23495452

typedef struct _TS_PROCESS_INFORMATION_NT4
{
    ULONG MagicNumber;
    ULONG LogonId;
    PVOID ProcessSid;
    ULONG Pad;
} TS_PROCESS_INFORMATION_NT4, *PTS_PROCESS_INFORMATION_NT4;

#define SIZEOF_TS4_SYSTEM_THREAD_INFORMATION 64
#define SIZEOF_TS4_SYSTEM_PROCESS_INFORMATION 136

typedef struct _TS_SYS_PROCESS_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG NumberOfThreads;
    LARGE_INTEGER SpareLi1;
    LARGE_INTEGER SpareLi2;
    LARGE_INTEGER SpareLi3;
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER KernelTime;
    UNICODE_STRING ImageName;
    LONG BasePriority;
    ULONG UniqueProcessId;
    ULONG InheritedFromUniqueProcessId;
    ULONG HandleCount;
    ULONG SessionId;
    ULONG SpareUl3;
    SIZE_T PeakVirtualSize;
    SIZE_T VirtualSize;
    ULONG PageFaultCount;
    ULONG PeakWorkingSetSize;
    ULONG WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivatePageCount;
} TS_SYS_PROCESS_INFORMATION, *PTS_SYS_PROCESS_INFORMATION;

typedef struct _TS_ALL_PROCESSES_INFO
{
    PTS_SYS_PROCESS_INFORMATION pTsProcessInfo;
    ULONG SizeOfSid;
    PSID pSid;
} TS_ALL_PROCESSES_INFO, *PTS_ALL_PROCESSES_INFO;

typedef struct _TS_COUNTER_HEADER
{
    DWORD dwCounterID;
    BOOLEAN bResult;
} TS_COUNTER_HEADER, *PTS_COUNTER_HEADER;

typedef struct _TS_COUNTER
{
    TS_COUNTER_HEADER CounterHead;
    DWORD dwValue;
    LARGE_INTEGER StartTime;
} TS_COUNTER, *PTS_COUNTER;

// Flags for WinStationShutdownSystem
#define WSD_LOGOFF 0x1
#define WSD_SHUTDOWN 0x2
#define WSD_REBOOT 0x4
#define WSD_POWEROFF 0x8

// Flags for WinStationWaitSystemEvent
#define WEVENT_NONE 0x0
#define WEVENT_CREATE 0x1
#define WEVENT_DELETE 0x2
#define WEVENT_RENAME 0x4
#define WEVENT_CONNECT 0x8
#define WEVENT_DISCONNECT 0x10
#define WEVENT_LOGON 0x20
#define WEVENT_LOGOFF 0x40
#define WEVENT_STATECHANGE 0x80
#define WEVENT_LICENSE 0x100
#define WEVENT_ALL 0x7fffffff
#define WEVENT_FLUSH 0x80000000

// Hotkey modifiers for WinStationShadow
#define KBDSHIFT 0x1
#define KBDCTRL 0x2
#define KBDALT 0x4

// begin_rev
// Flags for WinStationRegisterConsoleNotification
#define WNOTIFY_ALL_SESSIONS 0x1
// end_rev

// In the functions below, memory returned can be freed using LocalFree. NULL can be specified for
// server handles to indicate the local server. -1 can be specified for session IDs to indicate the
// current session ID.

#define LOGONID_CURRENT (-1)
#define SERVERNAME_CURRENT ((PWSTR)NULL)

// rev
BOOLEAN
WINAPI
WinStationFreeMemory(
    _In_ PVOID Buffer
    );

// rev
HANDLE
WINAPI
WinStationOpenServerW(
    _In_ PWSTR ServerName
    );

// rev
BOOLEAN
WINAPI
WinStationCloseServer(
    _In_ HANDLE ServerHandle
    );

// rev
BOOLEAN
WINAPI
WinStationServerPing(
    _In_opt_ HANDLE ServerHandle
    );

// rev
BOOLEAN
WINAPI
WinStationGetTermSrvCountersValue(
    _In_opt_ HANDLE ServerHandle,
    _In_ ULONG Count,
    _Inout_ PTS_COUNTER Counters // set counter IDs before calling
    );

BOOLEAN
WINAPI
WinStationShutdownSystem(
    _In_opt_ HANDLE ServerHandle,
    _In_ ULONG ShutdownFlags // WSD_*
    );

// rev
BOOLEAN
WINAPI
WinStationWaitSystemEvent(
    _In_opt_ HANDLE ServerHandle,
    _In_ ULONG EventMask, // WEVENT_*
    _Out_ PULONG EventFlags
    );

// rev
BOOLEAN
WINAPI
WinStationRegisterConsoleNotification(
    _In_opt_ HANDLE ServerHandle,
    _In_ HWND WindowHandle,
    _In_ ULONG Flags
    );

// rev
BOOLEAN
WINAPI
WinStationUnRegisterConsoleNotification(
    _In_opt_ HANDLE ServerHandle,
    _In_ HWND WindowHandle
    );

// Sessions

// rev
BOOLEAN
WINAPI
WinStationEnumerateW(
    _In_opt_ HANDLE ServerHandle,
    _Out_ PSESSIONIDW *SessionIds,
    _Out_ PULONG Count
    );

BOOLEAN
WINAPI
WinStationQueryInformationW(
    _In_opt_ HANDLE ServerHandle,
    _In_ ULONG SessionId,
    _In_ WINSTATIONINFOCLASS WinStationInformationClass,
    _Out_writes_bytes_(WinStationInformationLength) PVOID pWinStationInformation,
    _In_ ULONG WinStationInformationLength,
    _Out_ PULONG pReturnLength
    );

// rev
BOOLEAN
WINAPI
WinStationSetInformationW(
    _In_opt_ HANDLE ServerHandle,
    _In_ ULONG SessionId,
    _In_ WINSTATIONINFOCLASS WinStationInformationClass,
    _In_reads_bytes_(WinStationInformationLength) PVOID pWinStationInformation,
    _In_ ULONG WinStationInformationLength
    );

BOOLEAN
WINAPI
WinStationNameFromLogonIdW(
    _In_opt_ HANDLE ServerHandle,
    _In_ ULONG SessionId,
    _Out_writes_(WINSTATIONNAME_LENGTH + 1) PWSTR pWinStationName
    );

// rev
BOOLEAN
WINAPI
WinStationSendMessageW(
    _In_opt_ HANDLE ServerHandle,
    _In_ ULONG SessionId,
    _In_ PWSTR Title,
    _In_ ULONG TitleLength,
    _In_ PWSTR Message,
    _In_ ULONG MessageLength,
    _In_ ULONG Style,
    _In_ ULONG Timeout,
    _Out_ PULONG Response,
    _In_ BOOLEAN DoNotWait
    );

BOOLEAN
WINAPI
WinStationConnectW(
    _In_opt_ HANDLE ServerHandle,
    _In_ ULONG SessionId,
    _In_ ULONG TargetSessionId,
    _In_opt_ PWSTR pPassword,
    _In_ BOOLEAN bWait
    );

BOOLEAN
WINAPI
WinStationDisconnect(
    _In_opt_ HANDLE ServerHandle,
    _In_ ULONG SessionId,
    _In_ BOOLEAN bWait
    );

// rev
BOOLEAN
WINAPI
WinStationReset(
    _In_opt_ HANDLE ServerHandle,
    _In_ ULONG SessionId,
    _In_ BOOLEAN bWait
    );

// rev
BOOLEAN
WINAPI
WinStationShadow(
    _In_opt_ HANDLE ServerHandle,
    _In_ PWSTR TargetServerName,
    _In_ ULONG TargetSessionId,
    _In_ UCHAR HotKeyVk,
    _In_ USHORT HotkeyModifiers // KBD*
    );

// rev
BOOLEAN
WINAPI
WinStationShadowStop(
    _In_opt_ HANDLE ServerHandle,
    _In_ ULONG SessionId,
    _In_ BOOLEAN bWait // ignored
    );

// Processes

// rev
BOOLEAN
WINAPI
WinStationEnumerateProcesses(
    _In_opt_ HANDLE ServerHandle,
    _Out_ PVOID *Processes
    );

// rev
BOOLEAN
WINAPI
WinStationGetAllProcesses(
    _In_opt_ HANDLE ServerHandle,
    _In_ ULONG Level,
    _Out_ PULONG NumberOfProcesses,
    _Out_ PTS_ALL_PROCESSES_INFO *Processes
    );

// rev
BOOLEAN
WINAPI
WinStationFreeGAPMemory(
    _In_ ULONG Level,
    _In_ PTS_ALL_PROCESSES_INFO Processes,
    _In_ ULONG NumberOfProcesses
    );

// rev
BOOLEAN
WINAPI
WinStationTerminateProcess(
    _In_opt_ HANDLE ServerHandle,
    _In_ ULONG ProcessId,
    _In_ ULONG ExitCode
    );

BOOLEAN
WINAPI
WinStationGetProcessSid(
    _In_opt_ HANDLE ServerHandle,
    _In_ ULONG ProcessId,
    _In_ FILETIME ProcessStartTime,
    _Out_ PVOID pProcessUserSid,
    _Inout_ PULONG dwSidSize
    );

// Services isolation

#if (PHNT_VERSION >= PHNT_VISTA)

// rev
BOOLEAN
WINAPI
WinStationSwitchToServicesSession(
    VOID
    );

// rev
BOOLEAN
WINAPI
WinStationRevertFromServicesSession(
    VOID
    );

#endif

// Misc.

BOOLEAN
WINAPI
_WinStationWaitForConnect(
    VOID
    );

#endif

```

`readme.md`:

```md
NtCall
===

Library for using direct system calls
It automatically detect type of gate for call system call (`WOW64` \ `custom WOW64` \ `Int2E` \ `Sysenter` \ `Syscall` )

Checked Support on Windows
---

|Tested|Status|
|---|---|
|Windows 11 x64| OK |
|Windows 10 x64| OK |
|Windows 7 x86| OK |

How it works
---
By using `TEB` and `KUSER_SHARED_DATA` strucures we can determine what must use for make call to kernel.

On x86 we check `WOW32Reserved` in `TEB` for detect used `wow64` wrapper, and `SystemCall` in `KUSER_SHARED_DATA` for detect what's used `int2e` or direct call.
On x64 we check only `SystemCall` in `KUSER_SHARED_DATA` because it doesnt use any wow64.

So we detect used call type, next we need somehow use it.
Use it on x86 can be in 4 kinds

1. Int2E
2. sysenter - default on windows x86 for ntdll
3. Original Wow64 - default on windows x64 in wow64 for ntdll
4. Custom Wow64 - custom wow64 wrapper to convert x86 call parameters to x64 representation and vice versa

In x64 this used shared methods so it notinteresting :)

1. Int2E
2. syscall - default on windows x64

For comfortable use it (wow64 custom wrapper), project depend on `object_cvt64to32` what can convert object file with arch x64 to use it in arch x86 build


Why
---

Custom wow64 basically supports almost all, except ENUM functions such as `NtQuerySystemInformaton`. Functions with ENUM are also supported, but most of them crash the process at the stage of calling the parameter conversion.
It takes a lot of hours to debug and fix. So if anyone wants to help with a fix, I welcome all contributions to this project :)

Example Use
----
```
#include <higu_ntcall.h>

int main() {
  /*
     initialize syscall indexes in the start
  */
  initialize_syscall_table_auto(); 
  ...
  
  ...
  /*
     use Nt functions like staticly imported
  */
  HANDLE handle;
  NTSTATUS nt_status = NtCreateEvent(&handle, EVENT_ALL_ACCESS, 0, EVENT_TYPE::NotificationEvent, 0);
  ...
}

```

Authors
---
Founder of project [JNA](https://github.com/jnastarot)
```

`src/HIGU_ntcall/HIGU_ntcall.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{933fcdd7-35ec-4902-bc6b-c19044c493ce}</ProjectGuid>
    <RootNamespace>HIGUntcall</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\$(Configuration)$(PlatformArchitecture)\</OutDir>
    <IntDir>$(SolutionDir)tmp\$(ProjectName)_$(Configuration)$(PlatformArchitecture)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\$(Configuration)$(PlatformArchitecture)\</OutDir>
    <IntDir>$(SolutionDir)tmp\$(ProjectName)_$(Configuration)$(PlatformArchitecture)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\$(Configuration)$(PlatformArchitecture)\</OutDir>
    <IntDir>$(SolutionDir)tmp\$(ProjectName)_$(Configuration)$(PlatformArchitecture)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\$(Configuration)$(PlatformArchitecture)\</OutDir>
    <IntDir>$(SolutionDir)tmp\$(ProjectName)_$(Configuration)$(PlatformArchitecture)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>$(SolutionDir)phnt;$(ProjectDir)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>
      </SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <MASM>
      <UseSafeExceptionHandlers>true</UseSafeExceptionHandlers>
    </MASM>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>$(SolutionDir)phnt;$(ProjectDir)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>
      </SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <MASM>
      <UseSafeExceptionHandlers>true</UseSafeExceptionHandlers>
    </MASM>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>$(SolutionDir)phnt;$(ProjectDir)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>
      </SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>$(SolutionDir)phnt;$(ProjectDir)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>
      </SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="cleancall\cleancall.h" />
    <ClInclude Include="ntdll_3264_thunks.h" />
    <ClInclude Include="ntdll_functions.h" />
    <ClInclude Include="pch.h" />
    <ClInclude Include="syscall_table.h" />
    <ClInclude Include="syscall_table_initialize.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="cleancall\cleancall.cpp" />
    <ClCompile Include="ntdll_functions.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="syscall_table.cpp" />
    <ClCompile Include="syscall_table_initialize.cpp" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="cleancall\impl_cleancall_32.asm">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </MASM>
    <MASM Include="cleancall\impl_cleancall_64.asm">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
    </MASM>
  </ItemGroup>
  <ItemGroup>
    <Object Include="$(SolutionDir)tmp\HIGU_ntcall_3264_Release64\impl_syscall.obj">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
    </Object>
    <Object Include="$(SolutionDir)tmp\HIGU_ntcall_3264_Release64\ntcall3264.obj">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
    </Object>
        <Object Include="$(SolutionDir)tmp\HIGU_ntcall_3264_Debug64\impl_syscall.obj">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
    </Object>
    <Object Include="$(SolutionDir)tmp\HIGU_ntcall_3264_Debug64\ntcall3264.obj">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
    </Object>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`src/HIGU_ntcall/HIGU_ntcall.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Source Files\ntdll">
      <UniqueIdentifier>{4d06c60f-7387-4356-8fdb-af20ed7fbad7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\cleancall">
      <UniqueIdentifier>{a1e69f1f-b999-4453-9ab7-5b05292489f9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\cleancall\32">
      <UniqueIdentifier>{0acf2854-c411-48b3-8686-0d22a51ef5b5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\cleancall\64">
      <UniqueIdentifier>{20f3417e-b3c3-4eba-a3dc-f1fa698ad3b9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\syscall_table">
      <UniqueIdentifier>{4d73bbc8-1ec7-4f1d-ba05-8e9e1b21ae16}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ntdll_functions.h">
      <Filter>Source Files\ntdll</Filter>
    </ClInclude>
    <ClInclude Include="syscall_table_initialize.h">
      <Filter>Source Files\syscall_table</Filter>
    </ClInclude>
    <ClInclude Include="syscall_table.h">
      <Filter>Source Files\syscall_table</Filter>
    </ClInclude>
    <ClInclude Include="cleancall\cleancall.h">
      <Filter>Source Files\cleancall</Filter>
    </ClInclude>
    <ClInclude Include="ntdll_3264_thunks.h">
      <Filter>Source Files\ntdll</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="pch.cpp">
      <Filter>Header Files</Filter>
    </ClCompile>
    <ClCompile Include="ntdll_functions.cpp">
      <Filter>Source Files\ntdll</Filter>
    </ClCompile>
    <ClCompile Include="syscall_table.cpp">
      <Filter>Source Files\syscall_table</Filter>
    </ClCompile>
    <ClCompile Include="syscall_table_initialize.cpp">
      <Filter>Source Files\syscall_table</Filter>
    </ClCompile>
    <ClCompile Include="cleancall\cleancall.cpp">
      <Filter>Source Files\cleancall</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="cleancall\impl_cleancall_32.asm">
      <Filter>Source Files\cleancall\32</Filter>
    </MASM>
    <MASM Include="cleancall\impl_cleancall_64.asm">
      <Filter>Source Files\cleancall\64</Filter>
    </MASM>
  </ItemGroup>
  <ItemGroup>
    <Object Include="$(SolutionDir)tmp\HIGU_ntcall_3264_Debug64\impl_syscall.obj">
      <Filter>Source Files\cleancall\32</Filter>
    </Object>
    <Object Include="$(SolutionDir)tmp\HIGU_ntcall_3264_Release64\impl_syscall.obj">
      <Filter>Source Files\cleancall\32</Filter>
    </Object>
    <Object Include="$(SolutionDir)tmp\HIGU_ntcall_3264_Debug64\ntcall3264.obj">
      <Filter>Source Files\cleancall\32</Filter>
    </Object>
    <Object Include="$(SolutionDir)tmp\HIGU_ntcall_3264_Release64\ntcall3264.obj">
      <Filter>Source Files\cleancall\32</Filter>
    </Object>
  </ItemGroup>
</Project>
```

`src/HIGU_ntcall/cleancall/cleancall.cpp`:

```cpp
#include "pch.h"
#include "cleancall.h"





#ifndef STATUS_NOT_IMPLEMENTED
#define STATUS_NOT_IMPLEMENTED 0xC0000002
#endif

#ifdef _M_AMD64

using sys_gate_proc = int64_t(__fastcall*)(uint32_t syscall_idx, uint32_t args_count, uint64_t* arg_table);

extern "C" int64_t __fastcall internal_cleancall_native_int2e(uint32_t syscall_idx, uint32_t args_count, uint64_t * arg_table);
extern "C" int64_t __fastcall internal_cleancall_native_syscall(uint32_t syscall_idx, uint32_t args_count, uint64_t * arg_table);

#else

extern "C" void* internal_cleancall_wow64_gate = 0;

using sys_gate_proc = int32_t(__cdecl*)(uint32_t syscall_idx, uint32_t args_count, uint32_t* arg_table);

extern "C" int32_t __cdecl internal_cleancall_native_int2e(uint32_t syscall_idx, uint32_t args_count, uint32_t * arg_table);
extern "C" int32_t __cdecl internal_cleancall_native_sysenter(uint32_t syscall_idx, uint32_t args_count, uint32_t * arg_table);
extern "C" int32_t __cdecl internal_cleancall_WOW64(uint32_t syscall_idx, uint32_t args_count, uint32_t * arg_table);
extern "C" int32_t __cdecl internal_cleancall_WOW64_syscall(uint32_t syscall_idx, uint32_t args_count, uint32_t * arg_table);

#endif

namespace cleancall {

    static sys_gate_proc used_sys_gate = 0;
    static cleancall_gate_type used_gate_type = SYSCALL_CALL_TYPE_UNKNOWN;


    void detect_gate_type() {

#ifdef _M_AMD64

        if (*(uint32_t*)0x7FFE0308 == 0) {

            set_gate_type(SYSCALL_CALL_TYPE_SYSCALL);

        }
        else {

            set_gate_type(SYSCALL_CALL_TYPE_INT2E);
        }

#else

        internal_cleancall_wow64_gate = (void*)__readfsdword(0xC0);

        if (internal_cleancall_wow64_gate) {

            set_gate_type(SYSCALL_CALL_TYPE_WOW64_SYSCALL);
            //or
            //set_gate_type(SYSCALL_CALL_TYPE_WOW64);

        }
        else {

            if (*(uint32_t*)0x7FFE0308 == 0) {

                set_gate_type(SYSCALL_CALL_TYPE_SYSENTER);
            }
            else {

                set_gate_type(SYSCALL_CALL_TYPE_INT2E);
            }
        }

#endif

    }

    cleancall_gate_type get_gate_type() {

        if (used_gate_type == SYSCALL_CALL_TYPE_UNKNOWN) {

            detect_gate_type();
        }

        return used_gate_type;
    }

    void set_gate_type(cleancall_gate_type type) {

        used_gate_type = type;

#ifdef _M_AMD64

        switch (used_gate_type) {

        case SYSCALL_CALL_TYPE_SYSCALL: {

            used_sys_gate = internal_cleancall_native_syscall;
            break;
        }

        case SYSCALL_CALL_TYPE_INT2E: {

            used_sys_gate = internal_cleancall_native_int2e;
            break;
        }

        default: {

            used_sys_gate = 0;
            break;
        }
        }

#else

        switch (used_gate_type) {

        case SYSCALL_CALL_TYPE_WOW64: {

            used_sys_gate = (sys_gate_proc)internal_cleancall_WOW64;
            break;
        }

        case SYSCALL_CALL_TYPE_WOW64_SYSCALL: {

            used_sys_gate = (sys_gate_proc)internal_cleancall_WOW64_syscall;
            break;
        }

        case SYSCALL_CALL_TYPE_SYSENTER: {

            used_sys_gate = (sys_gate_proc)internal_cleancall_native_sysenter;
            break;
        }

        case SYSCALL_CALL_TYPE_INT2E: {

            used_sys_gate = (sys_gate_proc)internal_cleancall_native_int2e;
            break;
        }

        default: {

            used_sys_gate = 0;
            break;
        }
        }

#endif

    }

    int64_t __stdcall call(uint32_t syscall_idx, uint32_t x64_thunk, uint32_t arg_count, ...) {

        if (used_gate_type == SYSCALL_CALL_TYPE_UNKNOWN) {

            detect_gate_type();
        }

#ifdef _M_AMD64

        uint64_t arg_table[20];

        va_list variadic_arg;

        va_start(variadic_arg, arg_count);

        for (uint32_t idx = 0; idx < arg_count; idx++) {

            arg_table[idx] = va_arg(variadic_arg, uint64_t);
        }

        va_end(variadic_arg);

#else

        uint32_t arg_table[20];
        size_t arg_idx = 0;

        va_list variadic_arg;
        uint32_t allocate32_ctx[10];

        va_start(variadic_arg, arg_count);

        if (used_gate_type == SYSCALL_CALL_TYPE_WOW64_SYSCALL) {

            allocate32_ctx[0] = 0;

            arg_table[0] = (uint32_t)&allocate32_ctx;

            arg_table[1] = (uint32_t)syscall_idx;
            arg_idx = 2;

            //now it point to x64 callback function
            syscall_idx = x64_thunk;
        }

        for (uint32_t idx = 0; idx < arg_count; idx++, arg_idx++) {

            arg_table[arg_idx] = va_arg(variadic_arg, uint32_t);
        }

        va_end(variadic_arg);

#endif
        int64_t result = STATUS_NOT_IMPLEMENTED;

        if (used_sys_gate) {
            result = used_sys_gate(syscall_idx, arg_count, arg_table);
        }

#ifdef _M_IX86
        if (used_gate_type == SYSCALL_CALL_TYPE_WOW64_SYSCALL) {

            for (size_t idx = 0; idx < allocate32_ctx[0]; idx++) {
                PVOID baseaddress = (PVOID)allocate32_ctx[2 + idx];
                SIZE_T region_size = 0x1000;
                NtFreeVirtualMemory(GetCurrentProcess(), &baseaddress, &region_size, MEM_FREE);
            }
        }
#endif

        return result;
    }

#ifdef _M_IX86
    int64_t __stdcall call64(uint32_t syscall_idx, uint32_t x64_thunk, uint32_t arg_count, ...) {

        if (used_gate_type == SYSCALL_CALL_TYPE_UNKNOWN) {

            detect_gate_type();
        }

        uint64_t arg_table[20];
        size_t arg_idx = 0;

        va_list variadic_arg;
        uint64_t allocate32_ctx[10];

        va_start(variadic_arg, arg_count);

        if (used_gate_type == SYSCALL_CALL_TYPE_WOW64_SYSCALL) {

            allocate32_ctx[0] = 0;

            arg_table[0] = (uint32_t)&allocate32_ctx;

            arg_table[1] = (uint32_t)syscall_idx;
            arg_idx = 2;

            //now it point to x64 callback function
            syscall_idx = x64_thunk;
        }

        for (uint32_t idx = 0; idx < arg_count; idx++, arg_idx++) {

            arg_table[arg_idx] = va_arg(variadic_arg, uint64_t);
        }

        va_end(variadic_arg);

        int64_t result = STATUS_NOT_IMPLEMENTED;

        if (used_sys_gate) {
            result = used_sys_gate(syscall_idx, arg_count, (uint32_t*)arg_table);
        }

        if (used_gate_type == SYSCALL_CALL_TYPE_WOW64_SYSCALL) {

            for (size_t idx = 0; idx < allocate32_ctx[0]; idx++) {
                PVOID baseaddress = (PVOID)allocate32_ctx[2 + idx];
                SIZE_T region_size = 0x1000;
                NtFreeVirtualMemory(GetCurrentProcess(), &baseaddress, &region_size, MEM_FREE);
            }
        }

        return result;
    }

#endif
};

#ifdef _M_IX86
extern "C" void* __cdecl intrnl__ntcallmalloc32(void* ctx, uint32_t size) {

    uint32_t* allocated32_ctx = (uint32_t*)ctx;

    PVOID baseaddress = 0;
    SIZE_T region_size = 0x1000;
    NtAllocateVirtualMemory(GetCurrentProcess(), &baseaddress, 0, &region_size, MEM_COMMIT, PAGE_READWRITE);

    allocated32_ctx[allocated32_ctx[0] + 1] = (uint32_t)baseaddress;
    allocated32_ctx[0]++;

    if (allocated32_ctx[0] == 12) {
        __debugbreak();
    }

    return baseaddress;
}
#endif
```

`src/HIGU_ntcall/cleancall/cleancall.h`:

```h
#pragma once

namespace cleancall {

    typedef enum _cleancall_gate_type {

        SYSCALL_CALL_TYPE_UNKNOWN = 0,
        SYSCALL_CALL_TYPE_INT2E = 1, //for x32 or x64
        SYSCALL_CALL_TYPE_SYSENTER = 2, //for x32 only
        SYSCALL_CALL_TYPE_WOW64 = 3, //for x32 working in x64 system
        SYSCALL_CALL_TYPE_WOW64_SYSCALL = 4,  //for x32 working in x64 system
        SYSCALL_CALL_TYPE_SYSCALL = 4  //for x64 only

    } cleancall_gate_type;

    cleancall_gate_type get_gate_type();
    void set_gate_type(cleancall_gate_type type);

    int64_t __stdcall call(uint32_t syscall_idx, uint32_t reserved, uint32_t arg_count, ...);
    int64_t __stdcall call(uint32_t syscall_idx, uint32_t x64_thunk, uint32_t arg_count, ...);

#ifdef _M_IX86
    int64_t __stdcall call64(uint32_t syscall_idx, uint32_t x64_thunk, uint32_t arg_count, ...);
#endif

};
```

`src/HIGU_ntcall/cleancall/impl_cleancall_32.asm`:

```asm
.686 
.XMM 
.MODEL flat, c 
ASSUME fs:_DATA 
.CODE

EXTERN internal_cleancall_wow64_gate: PROC

internal_cleancall_native_int2e PROC

mov eax, [esp + 4]   ; syscall idx from param  
lea edx, [esp + 0Ch] ; arguments table
int 02Eh
ret

internal_cleancall_native_int2e ENDP


internal_cleancall_native_sysenter PROC

push ebp
mov ebp, esp

mov ecx, [ebp + 0Ch]  ; arguments count
mov edx, [ebp + 010h] ; arguments table

test ecx, ecx
jz make_call

push_argument:
 dec ecx
 push [edx + ecx * 4]
 jnz push_argument

make_call:
mov eax, [ebp + 8] ; syscall idx from param

push ret_address_epilog

call do_sysenter_interupt
lea esp, [esp+4]

ret_address_epilog:
mov esp, ebp
pop ebp

ret

do_sysenter_interupt:

mov edx, esp

sysenter

ret

internal_cleancall_native_sysenter ENDP


internal_cleancall_WOW64 PROC

push ebp
mov ebp, esp

mov ecx, [ebp + 0Ch]  ; arguments count
mov edx, [ebp + 010h] ; arguments table

test ecx, ecx
jz make_call

push_argument:
 dec ecx
 push [edx + ecx * 4]
 jnz push_argument

make_call:
mov eax, [ebp + 8] ; syscall idx from param

push ret_address_epilog

call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
lea esp, [esp+4]

ret_address_epilog:

mov esp, ebp
pop ebp

ret

internal_cleancall_WOW64 ENDP


internal_cleancall_WOW64_syscall PROC

push ebp
mov ebp, esp

and esp, 0FFFFFFF8h

mov edx, [ebp + 4*2]  ; pointer to x64 callback
mov ecx, [ebp + 4*4]  ; arguments table
    
push 033h ; 033 - x64 cs seg
push start_context_in_64mode
retf
start_context_in_64mode:

; x64 execution
;;;;;;;;;;;;;;;;;;;;

db 41h ; push r15
db 57h 
db 41h ; push r14
db 56h
db 41h ; push r13
db 55h 
db 41h ; push r12
db 54h
db 41h ; push r11
db 53h 
db 41h ; push r10
db 52h
db 41h ; push r9
db 51h
db 41h ; push r8
db 50h  

sub esp, 28h

call edx

add esp, 28h

db 41h ; pop r8
db 58h
db 41h ; pop r9
db 59h
db 41h ; pop r10
db 5Ah
db 41h ; pop r11
db 5Bh
db 41h ; pop r12
db 5Ch
db 41h ; pop r13
db 5Dh
db 41h ; pop r14
db 5Eh
db 41h ; pop r15
db 5Fh

;;;;;;;;;;;;;;;;;;;;

push eax
db 0C7h ; mov dword [esp + 4], 0x23
db 044h
db 024h
db 004h
db 023h
db 000h
db 000h
db 000h
    
mov [esp], end_context_in_64mode
retf

end_context_in_64mode:
    
mov esp, ebp
pop ebp

ret

internal_cleancall_WOW64_syscall ENDP


END
```

`src/HIGU_ntcall/cleancall/impl_cleancall_64.asm`:

```asm
.CODE


internal_cleancall_native_int2e PROC

sub rsp, 020h ; save regs
mov [rsp],        rsi
mov [rsp + 8],    rdi
mov [rsp + 010h], rbx
mov [rsp + 018h], r12

mov eax,  ecx ; syscall index 
mov esi,  edx ; params count
mov rdi,  r8  ; param table
xor rbx, rbx

cmp rsi, 0
je  make_call

mov rcx, [rdi] ;fill 1st arg
add rdi, 8

dec rsi
je  make_call

mov rdx, [rdi] ;fill 2st arg
add rdi, 8

dec rsi
je  make_call

mov r8, [rdi] ;fill 3st arg
add rdi, 8

dec rsi
je  make_call

mov r9, [rdi] ;fill 4st arg
add rdi, 8

dec rsi
je  make_call

lea rbx, [rsi * 8]
sub rsp, rbx  ;if more we push it on stack
mov rbx, 0 

push_argument:
 mov r12, [rdi]
 mov [rsp + rbx], r12
 add rbx, 8
 add rdi, 8
 dec rsi
 jnz push_argument

make_call:

sub rsp, 028h

mov r10, rcx 
int 02eh

add rsp, 028h
add rsp, rbx

mov r12, [rsp + 018h] 
mov rbx, [rsp + 010h]
mov rdi, [rsp + 8]
mov rsi, [rsp]

add rsp, 20h

ret

internal_cleancall_native_int2e ENDP


internal_cleancall_native_syscall PROC


sub rsp, 020h ; save regs
mov [rsp],        rsi
mov [rsp + 8],    rdi
mov [rsp + 010h], rbx
mov [rsp + 018h], r12

mov eax,  ecx ; syscall index 
mov esi,  edx ; params count
mov rdi,  r8  ; param table
xor rbx, rbx

cmp rsi, 0
je  make_call

mov rcx, [rdi] ;fill 1st arg
add rdi, 8

dec rsi
je  make_call

mov rdx, [rdi] ;fill 2st arg
add rdi, 8

dec rsi
je  make_call

mov r8, [rdi] ;fill 3st arg
add rdi, 8

dec rsi
je  make_call

mov r9, [rdi] ;fill 4st arg
add rdi, 8

dec rsi
je  make_call

lea rbx, [rsi * 8]
sub rsp, rbx  ;if more we push it on stack
mov rbx, 0 

push_argument:
 mov r12, [rdi]
 mov [rsp + rbx], r12
 add rbx, 8
 add rdi, 8
 dec rsi
 jnz push_argument

make_call:

sub rsp, 028h

mov r10, rcx 
syscall

add rsp, 028h
add rsp, rbx

mov r12, [rsp + 018h] 
mov rbx, [rsp + 010h]
mov rdi, [rsp + 8]
mov rsi, [rsp]

add rsp, 20h

ret

internal_cleancall_native_syscall ENDP


END
```

`src/HIGU_ntcall/higu_ntcall.h`:

```h
#pragma once

typedef enum _RTL_PATH_TYPE {
    RtlPathTypeUnknown,         // 0
    RtlPathTypeUncAbsolute,     // 1
    RtlPathTypeDriveAbsolute,   // 2
    RtlPathTypeDriveRelative,   // 3
    RtlPathTypeRooted,          // 4
    RtlPathTypeRelative,        // 5
    RtlPathTypeLocalDevice,     // 6
    RtlPathTypeRootLocalDevice  // 7
} RTL_PATH_TYPE;

#pragma warning(push)
#pragma warning(disable: 4005 4201)

#include <phnt_windows.h>
#include <phnt.h>

#pragma warning(pop)

#include <stdint.h>
#include <stdarg.h>
#include <string.h>
#include <cstdlib>
#include <intrin.h>

#include "cleancall/cleancall.h"

#pragma warning(push)
#pragma warning(disable: 4005) //redefine defs

#include "syscall_table.h"
#include "syscall_table_initialize.h"

#include "ntdll_functions.h"

#pragma warning(pop)
```

`src/HIGU_ntcall/ntdll_3264_thunks.h`:

```h
#pragma once

#include <list>

extern "C" {

    //Because mangling in x64 and x32 are different
#pragma comment(linker, "/alternatename:__ImageBase=___ImageBase")

    NTSTATUS __cdecl w32_NtMapViewOfSectionEx(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCallbackReturn(uint32_t* x32based_args);
    void __cdecl w32_NtFlushProcessWriteBuffers(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryDebugFilterState(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetDebugFilterState(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtYieldExecution(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtDelayExecution(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQuerySystemEnvironmentValue(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetSystemEnvironmentValue(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQuerySystemEnvironmentValueEx(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetSystemEnvironmentValueEx(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtEnumerateSystemEnvironmentValuesEx(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAddBootEntry(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtDeleteBootEntry(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtModifyBootEntry(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtEnumerateBootEntries(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryBootEntryOrder(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetBootEntryOrder(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryBootOptions(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetBootOptions(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtTranslateFilePath(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAddDriverEntry(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtDeleteDriverEntry(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtModifyDriverEntry(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtEnumerateDriverEntries(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryDriverEntryOrder(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetDriverEntryOrder(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtFilterBootOption(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateEvent(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtOpenEvent(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetEvent(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetEventBoostPriority(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtClearEvent(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtResetEvent(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtPulseEvent(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryEvent(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateEventPair(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtOpenEventPair(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetLowEventPair(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetHighEventPair(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtWaitLowEventPair(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtWaitHighEventPair(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetLowWaitHighEventPair(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetHighWaitLowEventPair(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateMutant(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtOpenMutant(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtReleaseMutant(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryMutant(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateSemaphore(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtOpenSemaphore(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtReleaseSemaphore(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQuerySemaphore(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateTimer(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtOpenTimer(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetTimer(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetTimerEx(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCancelTimer(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryTimer(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateIRTimer(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetIRTimer(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateTimer2(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetTimer2(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCancelTimer2(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateProfile(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateProfileEx(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtStartProfile(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtStopProfile(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryIntervalProfile(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetIntervalProfile(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateKeyedEvent(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtOpenKeyedEvent(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtReleaseKeyedEvent(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtWaitForKeyedEvent(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtUmsThreadYield(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateWnfStateName(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtDeleteWnfStateName(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtUpdateWnfStateData(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtDeleteWnfStateData(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryWnfStateData(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryWnfStateNameInformation(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSubscribeWnfStateChange(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtUnsubscribeWnfStateChange(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtGetCompleteWnfStateSubscription(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetWnfProcessNotificationEvent(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateWorkerFactory(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryInformationWorkerFactory(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetInformationWorkerFactory(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtShutdownWorkerFactory(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtReleaseWorkerFactoryWorker(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtWorkerFactoryWorkerReady(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtWaitForWorkViaWorkerFactory(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetSystemTime(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryTimerResolution(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetTimerResolution(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryPerformanceCounter(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAllocateLocallyUniqueId(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetUuidSeed(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAllocateUuids(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQuerySystemInformation(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQuerySystemInformationEx(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetSystemInformation(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSystemDebugControl(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtRaiseHardError(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryDefaultLocale(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetDefaultLocale(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryInstallUILanguage(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtFlushInstallUILanguage(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryDefaultUILanguage(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetDefaultUILanguage(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtIsUILanguageComitted(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtInitializeNlsFiles(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtGetNlsSectionPtr(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtMapCMFModule(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtGetMUIRegistryInfo(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAddAtom(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAddAtomEx(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtFindAtom(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtDeleteAtom(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryInformationAtom(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryLicenseValue(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetDefaultHardErrorPort(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtShutdownSystem(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtDisplayString(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtDrawText(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAllocateVirtualMemory(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtFreeVirtualMemory(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtReadVirtualMemory(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtWriteVirtualMemory(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtProtectVirtualMemory(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryVirtualMemory(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetInformationVirtualMemory(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtLockVirtualMemory(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtUnlockVirtualMemory(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateSection(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateSectionEx(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtOpenSection(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtMapViewOfSection(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtUnmapViewOfSection(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtUnmapViewOfSectionEx(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtExtendSection(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQuerySection(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAreMappedFilesTheSame(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreatePartition(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtOpenPartition(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtManagePartition(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtMapUserPhysicalPages(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtMapUserPhysicalPagesScatter(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAllocateUserPhysicalPages(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtFreeUserPhysicalPages(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtGetWriteWatch(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtResetWriteWatch(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreatePagingFile(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtFlushInstructionCache(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtFlushWriteBuffer(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateEnclave(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtLoadEnclaveData(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtInitializeEnclave(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtTerminateEnclave(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCallEnclave(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryObject(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetInformationObject(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtDuplicateObject(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtMakeTemporaryObject(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtMakePermanentObject(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSignalAndWaitForSingleObject(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtWaitForSingleObject(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtWaitForMultipleObjects(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtWaitForMultipleObjects32(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetSecurityObject(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQuerySecurityObject(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtClose(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCompareObjects(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateDirectoryObject(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateDirectoryObjectEx(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtOpenDirectoryObject(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryDirectoryObject(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreatePrivateNamespace(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtOpenPrivateNamespace(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtDeletePrivateNamespace(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateSymbolicLinkObject(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtOpenSymbolicLinkObject(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQuerySymbolicLinkObject(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateProcess(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateProcessEx(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtOpenProcess(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtTerminateProcess(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSuspendProcess(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtResumeProcess(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryInformationProcess(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtGetNextProcess(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtGetNextThread(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetInformationProcess(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryPortInformationProcess(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateThread(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtOpenThread(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtTerminateThread(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSuspendThread(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtResumeThread(uint32_t* x32based_args);
    ULONG __cdecl w32_NtGetCurrentProcessorNumber(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtGetContextThread(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetContextThread(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryInformationThread(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetInformationThread(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAlertThread(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAlertResumeThread(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtTestAlert(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtImpersonateThread(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtRegisterThreadTerminatePort(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetLdtEntries(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueueApcThread(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueueApcThreadEx(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAlertThreadByThreadId(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtWaitForAlertByThreadId(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateUserProcess(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateThreadEx(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateJobObject(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtOpenJobObject(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAssignProcessToJobObject(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtTerminateJobObject(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtIsProcessInJob(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryInformationJobObject(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetInformationJobObject(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateJobSet(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtRevertContainerImpersonation(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAllocateReserveObject(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateDebugObject(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtDebugActiveProcess(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtDebugContinue(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtRemoveProcessDebug(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetInformationDebugObject(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtWaitForDebugEvent(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateFile(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateNamedPipeFile(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateMailslotFile(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtOpenFile(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtDeleteFile(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtFlushBuffersFile(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtFlushBuffersFileEx(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryInformationFile(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryInformationByName(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetInformationFile(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryDirectoryFile(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryDirectoryFileEx(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryEaFile(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetEaFile(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryQuotaInformationFile(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetQuotaInformationFile(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryVolumeInformationFile(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetVolumeInformationFile(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCancelIoFile(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCancelIoFileEx(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCancelSynchronousIoFile(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtDeviceIoControlFile(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtFsControlFile(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtReadFile(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtWriteFile(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtReadFileScatter(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtWriteFileGather(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtLockFile(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtUnlockFile(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryAttributesFile(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryFullAttributesFile(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtNotifyChangeDirectoryFile(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtNotifyChangeDirectoryFileEx(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtLoadDriver(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtUnloadDriver(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateIoCompletion(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtOpenIoCompletion(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryIoCompletion(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetIoCompletion(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetIoCompletionEx(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtRemoveIoCompletion(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtRemoveIoCompletionEx(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateWaitCompletionPacket(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAssociateWaitCompletionPacket(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCancelWaitCompletionPacket(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtOpenSession(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtNotifyChangeSession(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreatePort(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateWaitablePort(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtConnectPort(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSecureConnectPort(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtListenPort(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAcceptConnectPort(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCompleteConnectPort(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtRequestPort(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtRequestWaitReplyPort(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtReplyPort(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtReplyWaitReplyPort(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtReplyWaitReceivePort(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtReplyWaitReceivePortEx(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtImpersonateClientOfPort(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtReadRequestData(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtWriteRequestData(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryInformationPort(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAlpcCreatePort(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAlpcDisconnectPort(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAlpcQueryInformation(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAlpcSetInformation(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAlpcCreatePortSection(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAlpcDeletePortSection(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAlpcCreateResourceReserve(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAlpcDeleteResourceReserve(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAlpcCreateSectionView(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAlpcDeleteSectionView(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAlpcCreateSecurityContext(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAlpcDeleteSecurityContext(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAlpcRevokeSecurityContext(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAlpcQueryInformationMessage(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAlpcConnectPort(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAlpcConnectPortEx(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAlpcAcceptConnectPort(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAlpcSendWaitReceivePort(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAlpcCancelMessage(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAlpcImpersonateClientOfPort(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAlpcImpersonateClientContainerOfPort(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAlpcOpenSenderProcess(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAlpcOpenSenderThread(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtPlugPlayControl(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSerializeBoot(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtEnableLastKnownGood(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtDisableLastKnownGood(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtReplacePartitionUnit(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtPowerInformation(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetThreadExecutionState(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtInitiatePowerAction(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetSystemPowerState(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtGetDevicePowerState(uint32_t* x32based_args);
    BOOLEAN __cdecl w32_NtIsSystemResumeAutomatic(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateKey(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateKeyTransacted(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtOpenKey(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtOpenKeyTransacted(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtOpenKeyEx(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtOpenKeyTransactedEx(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtDeleteKey(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtRenameKey(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtDeleteValueKey(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryKey(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetInformationKey(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryValueKey(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetValueKey(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryMultipleValueKey(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtEnumerateKey(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtEnumerateValueKey(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtFlushKey(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCompactKeys(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCompressKey(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtLoadKey(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtLoadKey2(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtLoadKeyEx(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtReplaceKey(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSaveKey(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSaveKeyEx(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSaveMergedKeys(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtRestoreKey(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtUnloadKey(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtUnloadKey2(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtUnloadKeyEx(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtNotifyChangeKey(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtNotifyChangeMultipleKeys(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryOpenSubKeys(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryOpenSubKeysEx(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtInitializeRegistry(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtLockRegistryKey(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtLockProductActivationKeys(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtFreezeRegistry(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtThawRegistry(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateToken(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateLowBoxToken(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateTokenEx(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtOpenProcessToken(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtOpenProcessTokenEx(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtOpenThreadToken(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtOpenThreadTokenEx(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtDuplicateToken(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryInformationToken(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetInformationToken(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAdjustPrivilegesToken(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAdjustGroupsToken(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAdjustTokenClaimsAndDeviceGroups(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtFilterToken(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtFilterTokenEx(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCompareTokens(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtPrivilegeCheck(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtImpersonateAnonymousToken(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQuerySecurityAttributesToken(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAccessCheck(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAccessCheckByType(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAccessCheckByTypeResultList(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetCachedSigningLevel(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtGetCachedSigningLevel(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAccessCheckAndAuditAlarm(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAccessCheckByTypeAndAuditAlarm(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAccessCheckByTypeResultListAndAuditAlarm(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtAccessCheckByTypeResultListAndAuditAlarmByHandle(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtOpenObjectAuditAlarm(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtPrivilegeObjectAuditAlarm(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCloseObjectAuditAlarm(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtDeleteObjectAuditAlarm(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtPrivilegedServiceAuditAlarm(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateTransactionManager(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtOpenTransactionManager(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtRenameTransactionManager(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtRollforwardTransactionManager(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtRecoverTransactionManager(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryInformationTransactionManager(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetInformationTransactionManager(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtEnumerateTransactionObject(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateTransaction(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtOpenTransaction(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryInformationTransaction(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetInformationTransaction(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCommitTransaction(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtRollbackTransaction(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateEnlistment(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtOpenEnlistment(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryInformationEnlistment(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetInformationEnlistment(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtRecoverEnlistment(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtPrePrepareEnlistment(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtPrepareEnlistment(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCommitEnlistment(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtRollbackEnlistment(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtPrePrepareComplete(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtPrepareComplete(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCommitComplete(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtReadOnlyEnlistment(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtRollbackComplete(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSinglePhaseReject(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtCreateResourceManager(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtOpenResourceManager(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtRecoverResourceManager(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtGetNotificationResourceManager(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtQueryInformationResourceManager(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtSetInformationResourceManager(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtRegisterProtocolAddressInformation(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtPropagationComplete(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtPropagationFailed(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtFreezeTransactions(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtThawTransactions(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtContinue(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtRaiseException(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtVdmControl(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtTraceEvent(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtTraceControl(uint32_t* x32based_args);
    NTSTATUS __cdecl w32_NtFlushVirtualMemory(uint32_t* x32based_args);

    //wow64 to amd64
    NTSTATUS __cdecl w64_NtAllocateVirtualMemory(uint64_t* x32based_args);
    NTSTATUS __cdecl w64_NtFreeVirtualMemory(uint64_t* x32based_args);
    NTSTATUS __cdecl w64_NtReadVirtualMemory(uint64_t* x32based_args);
    NTSTATUS __cdecl w64_NtWriteVirtualMemory(uint64_t* x32based_args);
    NTSTATUS __cdecl w64_NtProtectVirtualMemory(uint64_t* x32based_args);
};
```

`src/HIGU_ntcall/ntdll_functions.cpp`:

```cpp
#include "pch.h"
#include "ntdll_functions.h"

#ifdef _M_IX86
#include "ntdll_3264_thunks.h"
#endif

extern "C" {

#pragma warning(push)
#pragma warning(disable: 26812 4273 4244)
   
    NTSTATUS WINAPI NtAcceptConnectPort(PHANDLE PortHandle, PVOID PortContext, PPORT_MESSAGE ConnectionRequest, BOOLEAN AcceptConnection, PPORT_VIEW ServerView, PREMOTE_PORT_VIEW ClientView) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAcceptConnectPort), 0, 6, PortHandle, PortContext, ConnectionRequest, AcceptConnection, ServerView, ClientView);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAcceptConnectPort), (uint32_t)w32_NtAcceptConnectPort, 6, PortHandle, PortContext, ConnectionRequest, AcceptConnection, ServerView, ClientView);
#endif
    }

    NTSTATUS WINAPI NtAccessCheck(PSECURITY_DESCRIPTOR SecurityDescriptor, HANDLE ClientToken, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAccessCheck), 0, 8, SecurityDescriptor, ClientToken, DesiredAccess, GenericMapping, PrivilegeSet, PrivilegeSetLength, GrantedAccess, AccessStatus);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAccessCheck), (uint32_t)w32_NtAccessCheck, 8, SecurityDescriptor, ClientToken, DesiredAccess, GenericMapping, PrivilegeSet, PrivilegeSetLength, GrantedAccess, AccessStatus);
#endif
    }

    NTSTATUS WINAPI NtAccessCheckAndAuditAlarm(PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAccessCheckAndAuditAlarm), 0, 11, SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, DesiredAccess, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, GenerateOnClose);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAccessCheckAndAuditAlarm), (uint32_t)w32_NtAccessCheckAndAuditAlarm, 11, SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, DesiredAccess, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, GenerateOnClose);
#endif
    }

    NTSTATUS WINAPI NtAccessCheckByType(PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, ACCESS_MASK DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAccessCheckByType), 0, 11, SecurityDescriptor, PrincipalSelfSid, ClientToken, DesiredAccess, ObjectTypeList, ObjectTypeListLength, GenericMapping, PrivilegeSet, PrivilegeSetLength, GrantedAccess, AccessStatus);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAccessCheckByType), (uint32_t)w32_NtAccessCheckByType, 11, SecurityDescriptor, PrincipalSelfSid, ClientToken, DesiredAccess, ObjectTypeList, ObjectTypeListLength, GenericMapping, PrivilegeSet, PrivilegeSetLength, GrantedAccess, AccessStatus);
#endif
    }

    NTSTATUS WINAPI NtAccessCheckByTypeAndAuditAlarm(PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAccessCheckByTypeAndAuditAlarm), 0, 16, SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, GenerateOnClose);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAccessCheckByTypeAndAuditAlarm), (uint32_t)w32_NtAccessCheckByTypeAndAuditAlarm, 16, SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, GenerateOnClose);
#endif
    }

    NTSTATUS WINAPI NtAccessCheckByTypeResultList(PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, ACCESS_MASK DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAccessCheckByTypeResultList), 0, 11, SecurityDescriptor, PrincipalSelfSid, ClientToken, DesiredAccess, ObjectTypeList, ObjectTypeListLength, GenericMapping, PrivilegeSet, PrivilegeSetLength, GrantedAccess, AccessStatus);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAccessCheckByTypeResultList), (uint32_t)w32_NtAccessCheckByTypeResultList, 11, SecurityDescriptor, PrincipalSelfSid, ClientToken, DesiredAccess, ObjectTypeList, ObjectTypeListLength, GenericMapping, PrivilegeSet, PrivilegeSetLength, GrantedAccess, AccessStatus);
#endif
    }

    NTSTATUS WINAPI NtAccessCheckByTypeResultListAndAuditAlarm(PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAccessCheckByTypeResultListAndAuditAlarm), 0, 16, SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, GenerateOnClose);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAccessCheckByTypeResultListAndAuditAlarm), (uint32_t)w32_NtAccessCheckByTypeResultListAndAuditAlarm, 16, SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, GenerateOnClose);
#endif
    }

    NTSTATUS WINAPI NtAccessCheckByTypeResultListAndAuditAlarmByHandle(PUNICODE_STRING SubsystemName, PVOID HandleId, HANDLE ClientToken, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAccessCheckByTypeResultListAndAuditAlarmByHandle), 0, 17, SubsystemName, HandleId, ClientToken, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, GenerateOnClose);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAccessCheckByTypeResultListAndAuditAlarmByHandle), (uint32_t)w32_NtAccessCheckByTypeResultListAndAuditAlarmByHandle, 17, SubsystemName, HandleId, ClientToken, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, GenerateOnClose);
#endif
    }

    NTSTATUS WINAPI NtAddAtom(PWSTR AtomName, ULONG Length, PRTL_ATOM Atom) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAddAtom), 0, 3, AtomName, Length, Atom);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAddAtom), (uint32_t)w32_NtAddAtom, 3, AtomName, Length, Atom);
#endif
    }

    NTSTATUS WINAPI NtAddAtomEx(PWSTR AtomName, ULONG Length, PRTL_ATOM Atom, ULONG Flags) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAddAtomEx), 0, 4, AtomName, Length, Atom, Flags);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAddAtomEx), (uint32_t)w32_NtAddAtomEx, 4, AtomName, Length, Atom, Flags);
#endif
    }

    NTSTATUS WINAPI NtAddBootEntry(PBOOT_ENTRY BootEntry, PULONG Id) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAddBootEntry), 0, 2, BootEntry, Id);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAddBootEntry), (uint32_t)w32_NtAddBootEntry, 2, BootEntry, Id);
#endif
    }

    NTSTATUS WINAPI NtAddDriverEntry(PEFI_DRIVER_ENTRY DriverEntry, PULONG Id) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAddDriverEntry), 0, 2, DriverEntry, Id);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAddDriverEntry), (uint32_t)w32_NtAddDriverEntry, 2, DriverEntry, Id);
#endif
    }

    NTSTATUS WINAPI NtAdjustGroupsToken(HANDLE TokenHandle, BOOLEAN ResetToDefault, PTOKEN_GROUPS NewState, ULONG BufferLength, PTOKEN_GROUPS PreviousState, PULONG ReturnLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAdjustGroupsToken), 0, 6, TokenHandle, ResetToDefault, NewState, BufferLength, PreviousState, ReturnLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAdjustGroupsToken), (uint32_t)w32_NtAdjustGroupsToken, 6, TokenHandle, ResetToDefault, NewState, BufferLength, PreviousState, ReturnLength);
#endif
    }

    NTSTATUS WINAPI NtAdjustPrivilegesToken(HANDLE TokenHandle, BOOLEAN DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, ULONG BufferLength, PTOKEN_PRIVILEGES PreviousState, PULONG ReturnLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAdjustPrivilegesToken), 0, 6, TokenHandle, DisableAllPrivileges, NewState, BufferLength, PreviousState, ReturnLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAdjustPrivilegesToken), (uint32_t)w32_NtAdjustPrivilegesToken, 6, TokenHandle, DisableAllPrivileges, NewState, BufferLength, PreviousState, ReturnLength);
#endif
    }

    NTSTATUS WINAPI NtAdjustTokenClaimsAndDeviceGroups(HANDLE TokenHandle, BOOLEAN UserResetToDefault, BOOLEAN DeviceResetToDefault, BOOLEAN DeviceGroupsResetToDefault, PTOKEN_SECURITY_ATTRIBUTES_INFORMATION NewUserState, PTOKEN_SECURITY_ATTRIBUTES_INFORMATION NewDeviceState, PTOKEN_GROUPS NewDeviceGroupsState, ULONG UserBufferLength, PTOKEN_SECURITY_ATTRIBUTES_INFORMATION PreviousUserState, ULONG DeviceBufferLength, PTOKEN_SECURITY_ATTRIBUTES_INFORMATION PreviousDeviceState, ULONG DeviceGroupsBufferLength, PTOKEN_GROUPS PreviousDeviceGroups, PULONG UserReturnLength, PULONG DeviceReturnLength, PULONG DeviceGroupsReturnBufferLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAdjustTokenClaimsAndDeviceGroups), 0, 16, TokenHandle, UserResetToDefault, DeviceResetToDefault, DeviceGroupsResetToDefault, NewUserState, NewDeviceState, NewDeviceGroupsState, UserBufferLength, PreviousUserState, DeviceBufferLength, PreviousDeviceState, DeviceGroupsBufferLength, PreviousDeviceGroups, UserReturnLength, DeviceReturnLength, DeviceGroupsReturnBufferLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAdjustTokenClaimsAndDeviceGroups), (uint32_t)w32_NtAdjustTokenClaimsAndDeviceGroups, 16, TokenHandle, UserResetToDefault, DeviceResetToDefault, DeviceGroupsResetToDefault, NewUserState, NewDeviceState, NewDeviceGroupsState, UserBufferLength, PreviousUserState, DeviceBufferLength, PreviousDeviceState, DeviceGroupsBufferLength, PreviousDeviceGroups, UserReturnLength, DeviceReturnLength, DeviceGroupsReturnBufferLength);
#endif
    }

    NTSTATUS WINAPI NtAlertResumeThread(HANDLE ThreadHandle, PULONG PreviousSuspendCount) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlertResumeThread), 0, 2, ThreadHandle, PreviousSuspendCount);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlertResumeThread), (uint32_t)w32_NtAlertResumeThread, 2, ThreadHandle, PreviousSuspendCount);
#endif
    }

    NTSTATUS WINAPI NtAlertThread(HANDLE ThreadHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlertThread), 0, 1, ThreadHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlertThread), (uint32_t)w32_NtAlertThread, 1, ThreadHandle);
#endif
    }

    NTSTATUS WINAPI NtAlertThreadByThreadId(HANDLE ThreadId) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlertThreadByThreadId), 0, 1, ThreadId);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlertThreadByThreadId), (uint32_t)w32_NtAlertThreadByThreadId, 1, ThreadId);
#endif
    }

    NTSTATUS WINAPI NtAllocateLocallyUniqueId(PLUID Luid) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAllocateLocallyUniqueId), 0, 1, Luid);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAllocateLocallyUniqueId), (uint32_t)w32_NtAllocateLocallyUniqueId, 1, Luid);
#endif
    }

    NTSTATUS WINAPI NtAllocateReserveObject(PHANDLE MemoryReserveHandle, POBJECT_ATTRIBUTES ObjectAttributes, MEMORY_RESERVE_TYPE Type) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAllocateReserveObject), 0, 3, MemoryReserveHandle, ObjectAttributes, Type);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAllocateReserveObject), (uint32_t)w32_NtAllocateReserveObject, 3, MemoryReserveHandle, ObjectAttributes, Type);
#endif
    }

    NTSTATUS WINAPI NtAllocateUserPhysicalPages(HANDLE ProcessHandle, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAllocateUserPhysicalPages), 0, 3, ProcessHandle, NumberOfPages, UserPfnArray);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAllocateUserPhysicalPages), (uint32_t)w32_NtAllocateUserPhysicalPages, 3, ProcessHandle, NumberOfPages, UserPfnArray);
#endif
    }

    NTSTATUS WINAPI NtAllocateUuids(PULARGE_INTEGER Time, PULONG Range, PULONG Sequence, PCHAR Seed) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAllocateUuids), 0, 4, Time, Range, Sequence, Seed);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAllocateUuids), (uint32_t)w32_NtAllocateUuids, 4, Time, Range, Sequence, Seed);
#endif
    }

    NTSTATUS WINAPI NtAllocateVirtualMemory(HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits, PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAllocateVirtualMemory), 0, 6, ProcessHandle, BaseAddress, ZeroBits, RegionSize, AllocationType, Protect);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAllocateVirtualMemory), (uint32_t)w32_NtAllocateVirtualMemory, 6, ProcessHandle, BaseAddress, ZeroBits, RegionSize, AllocationType, Protect);
#endif
    }

    NTSTATUS WINAPI NtAlpcAcceptConnectPort(PHANDLE PortHandle, HANDLE ConnectionPortHandle, ULONG Flags, POBJECT_ATTRIBUTES ObjectAttributes, PALPC_PORT_ATTRIBUTES PortAttributes, PVOID PortContext, PPORT_MESSAGE ConnectionRequest, PALPC_MESSAGE_ATTRIBUTES ConnectionMessageAttributes, BOOLEAN AcceptConnection) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcAcceptConnectPort), 0, 9, PortHandle, ConnectionPortHandle, Flags, ObjectAttributes, PortAttributes, PortContext, ConnectionRequest, ConnectionMessageAttributes, AcceptConnection);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcAcceptConnectPort), (uint32_t)w32_NtAlpcAcceptConnectPort, 9, PortHandle, ConnectionPortHandle, Flags, ObjectAttributes, PortAttributes, PortContext, ConnectionRequest, ConnectionMessageAttributes, AcceptConnection);
#endif
    }

    NTSTATUS WINAPI NtAlpcCancelMessage(HANDLE PortHandle, ULONG Flags, PALPC_CONTEXT_ATTR MessageContext) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcCancelMessage), 0, 3, PortHandle, Flags, MessageContext);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcCancelMessage), (uint32_t)w32_NtAlpcCancelMessage, 3, PortHandle, Flags, MessageContext);
#endif
    }

    NTSTATUS WINAPI NtAlpcConnectPort(PHANDLE PortHandle, PUNICODE_STRING PortName, POBJECT_ATTRIBUTES ObjectAttributes, PALPC_PORT_ATTRIBUTES PortAttributes, ULONG Flags, PSID RequiredServerSid, PPORT_MESSAGE ConnectionMessage, PULONG BufferLength, PALPC_MESSAGE_ATTRIBUTES OutMessageAttributes, PALPC_MESSAGE_ATTRIBUTES InMessageAttributes, PLARGE_INTEGER Timeout) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcConnectPort), 0, 11, PortHandle, PortName, ObjectAttributes, PortAttributes, Flags, RequiredServerSid, ConnectionMessage, BufferLength, OutMessageAttributes, InMessageAttributes, Timeout);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcConnectPort), (uint32_t)w32_NtAlpcConnectPort, 11, PortHandle, PortName, ObjectAttributes, PortAttributes, Flags, RequiredServerSid, ConnectionMessage, BufferLength, OutMessageAttributes, InMessageAttributes, Timeout);
#endif
    }

    NTSTATUS WINAPI NtAlpcConnectPortEx(PHANDLE PortHandle, POBJECT_ATTRIBUTES ConnectionPortObjectAttributes, POBJECT_ATTRIBUTES ClientPortObjectAttributes, PALPC_PORT_ATTRIBUTES PortAttributes, ULONG Flags, PSECURITY_DESCRIPTOR ServerSecurityRequirements, PPORT_MESSAGE ConnectionMessage, PSIZE_T BufferLength, PALPC_MESSAGE_ATTRIBUTES OutMessageAttributes, PALPC_MESSAGE_ATTRIBUTES InMessageAttributes, PLARGE_INTEGER Timeout) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcConnectPortEx), 0, 11, PortHandle, ConnectionPortObjectAttributes, ClientPortObjectAttributes, PortAttributes, Flags, ServerSecurityRequirements, ConnectionMessage, BufferLength, OutMessageAttributes, InMessageAttributes, Timeout);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcConnectPortEx), (uint32_t)w32_NtAlpcConnectPortEx, 11, PortHandle, ConnectionPortObjectAttributes, ClientPortObjectAttributes, PortAttributes, Flags, ServerSecurityRequirements, ConnectionMessage, BufferLength, OutMessageAttributes, InMessageAttributes, Timeout);
#endif
    }

    NTSTATUS WINAPI NtAlpcCreatePort(PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, PALPC_PORT_ATTRIBUTES PortAttributes) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcCreatePort), 0, 3, PortHandle, ObjectAttributes, PortAttributes);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcCreatePort), (uint32_t)w32_NtAlpcCreatePort, 3, PortHandle, ObjectAttributes, PortAttributes);
#endif
    }

    NTSTATUS WINAPI NtAlpcCreatePortSection(HANDLE PortHandle, ULONG Flags, HANDLE SectionHandle, SIZE_T SectionSize, PALPC_HANDLE AlpcSectionHandle, PSIZE_T ActualSectionSize) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcCreatePortSection), 0, 6, PortHandle, Flags, SectionHandle, SectionSize, AlpcSectionHandle, ActualSectionSize);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcCreatePortSection), (uint32_t)w32_NtAlpcCreatePortSection, 6, PortHandle, Flags, SectionHandle, SectionSize, AlpcSectionHandle, ActualSectionSize);
#endif
    }

    NTSTATUS WINAPI NtAlpcCreateResourceReserve(HANDLE PortHandle, ULONG Flags, SIZE_T MessageSize, PALPC_HANDLE ResourceId) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcCreateResourceReserve), 0, 4, PortHandle, Flags, MessageSize, ResourceId);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcCreateResourceReserve), (uint32_t)w32_NtAlpcCreateResourceReserve, 4, PortHandle, Flags, MessageSize, ResourceId);
#endif
    }

    NTSTATUS WINAPI NtAlpcCreateSectionView(HANDLE PortHandle, ULONG Flags, PALPC_DATA_VIEW_ATTR ViewAttributes) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcCreateSectionView), 0, 3, PortHandle, Flags, ViewAttributes);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcCreateSectionView), (uint32_t)w32_NtAlpcCreateSectionView, 3, PortHandle, Flags, ViewAttributes);
#endif
    }

    NTSTATUS WINAPI NtAlpcCreateSecurityContext(HANDLE PortHandle, ULONG Flags, PALPC_SECURITY_ATTR SecurityAttribute) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcCreateSecurityContext), 0, 3, PortHandle, Flags, SecurityAttribute);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcCreateSecurityContext), (uint32_t)w32_NtAlpcCreateSecurityContext, 3, PortHandle, Flags, SecurityAttribute);
#endif
    }

    NTSTATUS WINAPI NtAlpcDeletePortSection(HANDLE PortHandle, ULONG Flags, ALPC_HANDLE SectionHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcDeletePortSection), 0, 3, PortHandle, Flags, SectionHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcDeletePortSection), (uint32_t)w32_NtAlpcDeletePortSection, 3, PortHandle, Flags, SectionHandle);
#endif
    }

    NTSTATUS WINAPI NtAlpcDeleteResourceReserve(HANDLE PortHandle, ULONG Flags, ALPC_HANDLE ResourceId) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcDeleteResourceReserve), 0, 3, PortHandle, Flags, ResourceId);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcDeleteResourceReserve), (uint32_t)w32_NtAlpcDeleteResourceReserve, 3, PortHandle, Flags, ResourceId);
#endif
    }

    NTSTATUS WINAPI NtAlpcDeleteSectionView(HANDLE PortHandle, ULONG Flags, PVOID ViewBase) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcDeleteSectionView), 0, 3, PortHandle, Flags, ViewBase);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcDeleteSectionView), (uint32_t)w32_NtAlpcDeleteSectionView, 3, PortHandle, Flags, ViewBase);
#endif
    }

    NTSTATUS WINAPI NtAlpcDeleteSecurityContext(HANDLE PortHandle, ULONG Flags, ALPC_HANDLE ContextHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcDeleteSecurityContext), 0, 3, PortHandle, Flags, ContextHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcDeleteSecurityContext), (uint32_t)w32_NtAlpcDeleteSecurityContext, 3, PortHandle, Flags, ContextHandle);
#endif
    }

    NTSTATUS WINAPI NtAlpcDisconnectPort(HANDLE PortHandle, ULONG Flags) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcDisconnectPort), 0, 2, PortHandle, Flags);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcDisconnectPort), (uint32_t)w32_NtAlpcDisconnectPort, 2, PortHandle, Flags);
#endif
    }

    NTSTATUS WINAPI NtAlpcImpersonateClientContainerOfPort(HANDLE PortHandle, PPORT_MESSAGE Message, ULONG Flags) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcImpersonateClientContainerOfPort), 0, 3, PortHandle, Message, Flags);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcImpersonateClientContainerOfPort), (uint32_t)w32_NtAlpcImpersonateClientContainerOfPort, 3, PortHandle, Message, Flags);
#endif
    }

    NTSTATUS WINAPI NtAlpcImpersonateClientOfPort(HANDLE PortHandle, PPORT_MESSAGE Message, PVOID Flags) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcImpersonateClientOfPort), 0, 3, PortHandle, Message, Flags);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcImpersonateClientOfPort), (uint32_t)w32_NtAlpcImpersonateClientOfPort, 3, PortHandle, Message, Flags);
#endif
    }

    NTSTATUS WINAPI NtAlpcOpenSenderProcess(PHANDLE ProcessHandle, HANDLE PortHandle, PPORT_MESSAGE PortMessage, ULONG Flags, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcOpenSenderProcess), 0, 6, ProcessHandle, PortHandle, PortMessage, Flags, DesiredAccess, ObjectAttributes);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcOpenSenderProcess), (uint32_t)w32_NtAlpcOpenSenderProcess, 6, ProcessHandle, PortHandle, PortMessage, Flags, DesiredAccess, ObjectAttributes);
#endif
    }

    NTSTATUS WINAPI NtAlpcOpenSenderThread(PHANDLE ThreadHandle, HANDLE PortHandle, PPORT_MESSAGE PortMessage, ULONG Flags, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcOpenSenderThread), 0, 6, ThreadHandle, PortHandle, PortMessage, Flags, DesiredAccess, ObjectAttributes);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcOpenSenderThread), (uint32_t)w32_NtAlpcOpenSenderThread, 6, ThreadHandle, PortHandle, PortMessage, Flags, DesiredAccess, ObjectAttributes);
#endif
    }

    NTSTATUS WINAPI NtAlpcQueryInformation(HANDLE PortHandle, ALPC_PORT_INFORMATION_CLASS PortInformationClass, PVOID PortInformation, ULONG Length, PULONG ReturnLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcQueryInformation), 0, 5, PortHandle, PortInformationClass, PortInformation, Length, ReturnLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcQueryInformation), (uint32_t)w32_NtAlpcQueryInformation, 5, PortHandle, PortInformationClass, PortInformation, Length, ReturnLength);
#endif
    }

    NTSTATUS WINAPI NtAlpcQueryInformationMessage(HANDLE PortHandle, PPORT_MESSAGE PortMessage, ALPC_MESSAGE_INFORMATION_CLASS MessageInformationClass, PVOID MessageInformation, ULONG Length, PULONG ReturnLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcQueryInformationMessage), 0, 6, PortHandle, PortMessage, MessageInformationClass, MessageInformation, Length, ReturnLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcQueryInformationMessage), (uint32_t)w32_NtAlpcQueryInformationMessage, 6, PortHandle, PortMessage, MessageInformationClass, MessageInformation, Length, ReturnLength);
#endif
    }

    NTSTATUS WINAPI NtAlpcRevokeSecurityContext(HANDLE PortHandle, ULONG Flags, ALPC_HANDLE ContextHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcRevokeSecurityContext), 0, 3, PortHandle, Flags, ContextHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcRevokeSecurityContext), (uint32_t)w32_NtAlpcRevokeSecurityContext, 3, PortHandle, Flags, ContextHandle);
#endif
    }

    NTSTATUS WINAPI NtAlpcSendWaitReceivePort(HANDLE PortHandle, ULONG Flags, PPORT_MESSAGE SendMessageA, PALPC_MESSAGE_ATTRIBUTES SendMessageAttributes, PPORT_MESSAGE ReceiveMessage, PSIZE_T BufferLength, PALPC_MESSAGE_ATTRIBUTES ReceiveMessageAttributes, PLARGE_INTEGER Timeout) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcSendWaitReceivePort), 0, 8, PortHandle, Flags, SendMessageA, SendMessageAttributes, ReceiveMessage, BufferLength, ReceiveMessageAttributes, Timeout);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcSendWaitReceivePort), (uint32_t)w32_NtAlpcSendWaitReceivePort, 8, PortHandle, Flags, SendMessageA, SendMessageAttributes, ReceiveMessage, BufferLength, ReceiveMessageAttributes, Timeout);
#endif
    }

    NTSTATUS WINAPI NtAlpcSetInformation(HANDLE PortHandle, ALPC_PORT_INFORMATION_CLASS PortInformationClass, PVOID PortInformation, ULONG Length) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcSetInformation), 0, 4, PortHandle, PortInformationClass, PortInformation, Length);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAlpcSetInformation), (uint32_t)w32_NtAlpcSetInformation, 4, PortHandle, PortInformationClass, PortInformation, Length);
#endif
    }

    NTSTATUS WINAPI NtAreMappedFilesTheSame(PVOID File1MappedAsAnImage, PVOID File2MappedAsFile) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAreMappedFilesTheSame), 0, 2, File1MappedAsAnImage, File2MappedAsFile);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAreMappedFilesTheSame), (uint32_t)w32_NtAreMappedFilesTheSame, 2, File1MappedAsAnImage, File2MappedAsFile);
#endif
    }

    NTSTATUS WINAPI NtAssignProcessToJobObject(HANDLE JobHandle, HANDLE ProcessHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAssignProcessToJobObject), 0, 2, JobHandle, ProcessHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAssignProcessToJobObject), (uint32_t)w32_NtAssignProcessToJobObject, 2, JobHandle, ProcessHandle);
#endif
    }

    NTSTATUS WINAPI NtAssociateWaitCompletionPacket(HANDLE WaitCompletionPacketHandle, HANDLE IoCompletionHandle, HANDLE TargetObjectHandle, PVOID KeyContext, PVOID ApcContext, NTSTATUS IoStatus, ULONG_PTR IoStatusInformation, PBOOLEAN AlreadySignaled) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAssociateWaitCompletionPacket), 0, 8, WaitCompletionPacketHandle, IoCompletionHandle, TargetObjectHandle, KeyContext, ApcContext, IoStatus, IoStatusInformation, AlreadySignaled);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtAssociateWaitCompletionPacket), (uint32_t)w32_NtAssociateWaitCompletionPacket, 8, WaitCompletionPacketHandle, IoCompletionHandle, TargetObjectHandle, KeyContext, ApcContext, IoStatus, IoStatusInformation, AlreadySignaled);
#endif
    }

    NTSTATUS WINAPI NtCallEnclave(PENCLAVE_ROUTINE Routine, PVOID Parameter, BOOLEAN WaitForThread, PVOID* ReturnValue) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCallEnclave), 0, 4, Routine, Parameter, WaitForThread, ReturnValue);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCallEnclave), (uint32_t)w32_NtCallEnclave, 4, Routine, Parameter, WaitForThread, ReturnValue);
#endif
    }

    NTSTATUS WINAPI NtCallbackReturn(PVOID OutputBuffer, ULONG OutputLength, NTSTATUS Status) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCallbackReturn), 0, 3, OutputBuffer, OutputLength, Status);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCallbackReturn), (uint32_t)w32_NtCallbackReturn, 3, OutputBuffer, OutputLength, Status);
#endif
    }

    NTSTATUS WINAPI NtCancelIoFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCancelIoFile), 0, 2, FileHandle, IoStatusBlock);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCancelIoFile), (uint32_t)w32_NtCancelIoFile, 2, FileHandle, IoStatusBlock);
#endif
    }

    NTSTATUS WINAPI NtCancelIoFileEx(HANDLE FileHandle, PIO_STATUS_BLOCK IoRequestToCancel, PIO_STATUS_BLOCK IoStatusBlock) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCancelIoFileEx), 0, 3, FileHandle, IoRequestToCancel, IoStatusBlock);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCancelIoFileEx), (uint32_t)w32_NtCancelIoFileEx, 3, FileHandle, IoRequestToCancel, IoStatusBlock);
#endif
    }

    NTSTATUS WINAPI NtCancelSynchronousIoFile(HANDLE ThreadHandle, PIO_STATUS_BLOCK IoRequestToCancel, PIO_STATUS_BLOCK IoStatusBlock) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCancelSynchronousIoFile), 0, 3, ThreadHandle, IoRequestToCancel, IoStatusBlock);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCancelSynchronousIoFile), (uint32_t)w32_NtCancelSynchronousIoFile, 3, ThreadHandle, IoRequestToCancel, IoStatusBlock);
#endif
    }

    NTSTATUS WINAPI NtCancelTimer(HANDLE TimerHandle, PBOOLEAN CurrentState) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCancelTimer), 0, 2, TimerHandle, CurrentState);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCancelTimer), (uint32_t)w32_NtCancelTimer, 2, TimerHandle, CurrentState);
#endif
    }

    NTSTATUS WINAPI NtCancelTimer2(HANDLE TimerHandle, PT2_CANCEL_PARAMETERS Parameters) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCancelTimer2), 0, 2, TimerHandle, Parameters);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCancelTimer2), (uint32_t)w32_NtCancelTimer2, 2, TimerHandle, Parameters);
#endif
    }

    NTSTATUS WINAPI NtCancelWaitCompletionPacket(HANDLE WaitCompletionPacketHandle, BOOLEAN RemoveSignaledPacket) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCancelWaitCompletionPacket), 0, 2, WaitCompletionPacketHandle, RemoveSignaledPacket);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCancelWaitCompletionPacket), (uint32_t)w32_NtCancelWaitCompletionPacket, 2, WaitCompletionPacketHandle, RemoveSignaledPacket);
#endif
    }

    NTSTATUS WINAPI NtClearEvent(HANDLE EventHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtClearEvent), 0, 1, EventHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtClearEvent), (uint32_t)w32_NtClearEvent, 1, EventHandle);
#endif
    }

    NTSTATUS WINAPI NtClose(HANDLE Handle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtClose), 0, 1, Handle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtClose), (uint32_t)w32_NtClose, 1, Handle);
#endif
    }

    NTSTATUS WINAPI NtCloseObjectAuditAlarm(PUNICODE_STRING SubsystemName, PVOID HandleId, BOOLEAN GenerateOnClose) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCloseObjectAuditAlarm), 0, 3, SubsystemName, HandleId, GenerateOnClose);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCloseObjectAuditAlarm), (uint32_t)w32_NtCloseObjectAuditAlarm, 3, SubsystemName, HandleId, GenerateOnClose);
#endif
    }

    NTSTATUS WINAPI NtCommitComplete(HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCommitComplete), 0, 2, EnlistmentHandle, TmVirtualClock);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCommitComplete), (uint32_t)w32_NtCommitComplete, 2, EnlistmentHandle, TmVirtualClock);
#endif
    }

    NTSTATUS WINAPI NtCommitEnlistment(HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCommitEnlistment), 0, 2, EnlistmentHandle, TmVirtualClock);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCommitEnlistment), (uint32_t)w32_NtCommitEnlistment, 2, EnlistmentHandle, TmVirtualClock);
#endif
    }

    NTSTATUS WINAPI NtCommitTransaction(HANDLE TransactionHandle, BOOLEAN Wait) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCommitTransaction), 0, 2, TransactionHandle, Wait);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCommitTransaction), (uint32_t)w32_NtCommitTransaction, 2, TransactionHandle, Wait);
#endif
    }

    NTSTATUS WINAPI NtCompactKeys(ULONG Count, HANDLE* KeyArray) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCompactKeys), 0, 2, Count, KeyArray);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCompactKeys), (uint32_t)w32_NtCompactKeys, 2, Count, KeyArray);
#endif
    }

    NTSTATUS WINAPI NtCompareObjects(HANDLE FirstObjectHandle, HANDLE SecondObjectHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCompareObjects), 0, 2, FirstObjectHandle, SecondObjectHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCompareObjects), (uint32_t)w32_NtCompareObjects, 2, FirstObjectHandle, SecondObjectHandle);
#endif
    }

    NTSTATUS WINAPI NtCompareTokens(HANDLE FirstTokenHandle, HANDLE SecondTokenHandle, PBOOLEAN Equal) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCompareTokens), 0, 3, FirstTokenHandle, SecondTokenHandle, Equal);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCompareTokens), (uint32_t)w32_NtCompareTokens, 3, FirstTokenHandle, SecondTokenHandle, Equal);
#endif
    }

    NTSTATUS WINAPI NtCompleteConnectPort(HANDLE PortHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCompleteConnectPort), 0, 1, PortHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCompleteConnectPort), (uint32_t)w32_NtCompleteConnectPort, 1, PortHandle);
#endif
    }

    NTSTATUS WINAPI NtCompressKey(HANDLE Key) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCompressKey), 0, 1, Key);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCompressKey), (uint32_t)w32_NtCompressKey, 1, Key);
#endif
    }

    NTSTATUS WINAPI NtConnectPort(PHANDLE PortHandle, PUNICODE_STRING PortName, PSECURITY_QUALITY_OF_SERVICE SecurityQos, PPORT_VIEW ClientView, PREMOTE_PORT_VIEW ServerView, PULONG MaxMessageLength, PVOID ConnectionInformation, PULONG ConnectionInformationLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtConnectPort), 0, 8, PortHandle, PortName, SecurityQos, ClientView, ServerView, MaxMessageLength, ConnectionInformation, ConnectionInformationLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtConnectPort), (uint32_t)w32_NtConnectPort, 8, PortHandle, PortName, SecurityQos, ClientView, ServerView, MaxMessageLength, ConnectionInformation, ConnectionInformationLength);
#endif
    }

    NTSTATUS WINAPI NtContinue(PCONTEXT ContextRecord, BOOLEAN TestAlert) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtContinue), 0, 2, ContextRecord, TestAlert);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtContinue), (uint32_t)w32_NtContinue, 2, ContextRecord, TestAlert);
#endif
    }

    NTSTATUS WINAPI NtCreateDebugObject(PHANDLE DebugObjectHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Flags) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateDebugObject), 0, 4, DebugObjectHandle, DesiredAccess, ObjectAttributes, Flags);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateDebugObject), (uint32_t)w32_NtCreateDebugObject, 4, DebugObjectHandle, DesiredAccess, ObjectAttributes, Flags);
#endif
    }

    NTSTATUS WINAPI NtCreateDirectoryObject(PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateDirectoryObject), 0, 3, DirectoryHandle, DesiredAccess, ObjectAttributes);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateDirectoryObject), (uint32_t)w32_NtCreateDirectoryObject, 3, DirectoryHandle, DesiredAccess, ObjectAttributes);
#endif
    }

    NTSTATUS WINAPI NtCreateDirectoryObjectEx(PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ShadowDirectoryHandle, ULONG Flags) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateDirectoryObjectEx), 0, 5, DirectoryHandle, DesiredAccess, ObjectAttributes, ShadowDirectoryHandle, Flags);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateDirectoryObjectEx), (uint32_t)w32_NtCreateDirectoryObjectEx, 5, DirectoryHandle, DesiredAccess, ObjectAttributes, ShadowDirectoryHandle, Flags);
#endif
    }

    NTSTATUS WINAPI NtCreateEnclave(HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits, SIZE_T Size, SIZE_T InitialCommitment, ULONG EnclaveType, PVOID EnclaveInformation, ULONG EnclaveInformationLength, PULONG EnclaveError) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateEnclave), 0, 9, ProcessHandle, BaseAddress, ZeroBits, Size, InitialCommitment, EnclaveType, EnclaveInformation, EnclaveInformationLength, EnclaveError);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateEnclave), (uint32_t)w32_NtCreateEnclave, 9, ProcessHandle, BaseAddress, ZeroBits, Size, InitialCommitment, EnclaveType, EnclaveInformation, EnclaveInformationLength, EnclaveError);
#endif
    }

    NTSTATUS WINAPI NtCreateEnlistment(PHANDLE EnlistmentHandle, ACCESS_MASK DesiredAccess, HANDLE ResourceManagerHandle, HANDLE TransactionHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG CreateOptions, NOTIFICATION_MASK NotificationMask, PVOID EnlistmentKey) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateEnlistment), 0, 8, EnlistmentHandle, DesiredAccess, ResourceManagerHandle, TransactionHandle, ObjectAttributes, CreateOptions, NotificationMask, EnlistmentKey);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateEnlistment), (uint32_t)w32_NtCreateEnlistment, 8, EnlistmentHandle, DesiredAccess, ResourceManagerHandle, TransactionHandle, ObjectAttributes, CreateOptions, NotificationMask, EnlistmentKey);
#endif
    }

    NTSTATUS WINAPI NtCreateEvent(PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, EVENT_TYPE EventType, BOOLEAN InitialState) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateEvent), 0, 5, EventHandle, DesiredAccess, ObjectAttributes, EventType, InitialState);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateEvent), (uint32_t)w32_NtCreateEvent, 5, EventHandle, DesiredAccess, ObjectAttributes, EventType, InitialState);
#endif
    }

    NTSTATUS WINAPI NtCreateEventPair(PHANDLE EventPairHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateEventPair), 0, 3, EventPairHandle, DesiredAccess, ObjectAttributes);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateEventPair), (uint32_t)w32_NtCreateEventPair, 3, EventPairHandle, DesiredAccess, ObjectAttributes);
#endif
    }

    NTSTATUS WINAPI NtCreateFile(PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateFile), 0, 11, FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, AllocationSize, FileAttributes, ShareAccess, CreateDisposition, CreateOptions, EaBuffer, EaLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateFile), (uint32_t)w32_NtCreateFile, 11, FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, AllocationSize, FileAttributes, ShareAccess, CreateDisposition, CreateOptions, EaBuffer, EaLength);
#endif
    }

    NTSTATUS WINAPI NtCreateIRTimer(PHANDLE TimerHandle, ACCESS_MASK DesiredAccess) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateIRTimer), 0, 2, TimerHandle, DesiredAccess);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateIRTimer), (uint32_t)w32_NtCreateIRTimer, 2, TimerHandle, DesiredAccess);
#endif
    }

    NTSTATUS WINAPI NtCreateIoCompletion(PHANDLE IoCompletionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Count) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateIoCompletion), 0, 4, IoCompletionHandle, DesiredAccess, ObjectAttributes, Count);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateIoCompletion), (uint32_t)w32_NtCreateIoCompletion, 4, IoCompletionHandle, DesiredAccess, ObjectAttributes, Count);
#endif
    }

    NTSTATUS WINAPI NtCreateJobObject(PHANDLE JobHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateJobObject), 0, 3, JobHandle, DesiredAccess, ObjectAttributes);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateJobObject), (uint32_t)w32_NtCreateJobObject, 3, JobHandle, DesiredAccess, ObjectAttributes);
#endif
    }

    NTSTATUS WINAPI NtCreateJobSet(ULONG NumJob, PJOB_SET_ARRAY UserJobSet, ULONG Flags) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateJobSet), 0, 3, NumJob, UserJobSet, Flags);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateJobSet), (uint32_t)w32_NtCreateJobSet, 3, NumJob, UserJobSet, Flags);
#endif
    }

    NTSTATUS WINAPI NtCreateKey(PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG TitleIndex, PUNICODE_STRING Class, ULONG CreateOptions, PULONG Disposition) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateKey), 0, 7, KeyHandle, DesiredAccess, ObjectAttributes, TitleIndex, Class, CreateOptions, Disposition);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateKey), (uint32_t)w32_NtCreateKey, 7, KeyHandle, DesiredAccess, ObjectAttributes, TitleIndex, Class, CreateOptions, Disposition);
#endif
    }

    NTSTATUS WINAPI NtCreateKeyTransacted(PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG TitleIndex, PUNICODE_STRING Class, ULONG CreateOptions, HANDLE TransactionHandle, PULONG Disposition) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateKeyTransacted), 0, 8, KeyHandle, DesiredAccess, ObjectAttributes, TitleIndex, Class, CreateOptions, TransactionHandle, Disposition);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateKeyTransacted), (uint32_t)w32_NtCreateKeyTransacted, 8, KeyHandle, DesiredAccess, ObjectAttributes, TitleIndex, Class, CreateOptions, TransactionHandle, Disposition);
#endif
    }

    NTSTATUS WINAPI NtCreateKeyedEvent(PHANDLE KeyedEventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Flags) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateKeyedEvent), 0, 4, KeyedEventHandle, DesiredAccess, ObjectAttributes, Flags);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateKeyedEvent), (uint32_t)w32_NtCreateKeyedEvent, 4, KeyedEventHandle, DesiredAccess, ObjectAttributes, Flags);
#endif
    }

    NTSTATUS WINAPI NtCreateLowBoxToken(PHANDLE TokenHandle, HANDLE ExistingTokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PSID PackageSid, ULONG CapabilityCount, PSID_AND_ATTRIBUTES Capabilities, ULONG HandleCount, HANDLE* Handles) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateLowBoxToken), 0, 9, TokenHandle, ExistingTokenHandle, DesiredAccess, ObjectAttributes, PackageSid, CapabilityCount, Capabilities, HandleCount, Handles);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateLowBoxToken), (uint32_t)w32_NtCreateLowBoxToken, 9, TokenHandle, ExistingTokenHandle, DesiredAccess, ObjectAttributes, PackageSid, CapabilityCount, Capabilities, HandleCount, Handles);
#endif
    }

    NTSTATUS WINAPI NtCreateMailslotFile(PHANDLE FileHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG CreateOptions, ULONG MailslotQuota, ULONG MaximumMessageSize, PLARGE_INTEGER ReadTimeout) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateMailslotFile), 0, 8, FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, CreateOptions, MailslotQuota, MaximumMessageSize, ReadTimeout);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateMailslotFile), (uint32_t)w32_NtCreateMailslotFile, 8, FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, CreateOptions, MailslotQuota, MaximumMessageSize, ReadTimeout);
#endif
    }

    NTSTATUS WINAPI NtCreateMutant(PHANDLE MutantHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, BOOLEAN InitialOwner) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateMutant), 0, 4, MutantHandle, DesiredAccess, ObjectAttributes, InitialOwner);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateMutant), (uint32_t)w32_NtCreateMutant, 4, MutantHandle, DesiredAccess, ObjectAttributes, InitialOwner);
#endif
    }

    NTSTATUS WINAPI NtCreateNamedPipeFile(PHANDLE FileHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, ULONG NamedPipeType, ULONG ReadMode, ULONG CompletionMode, ULONG MaximumInstances, ULONG InboundQuota, ULONG OutboundQuota, PLARGE_INTEGER DefaultTimeout) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateNamedPipeFile), 0, 14, FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, ShareAccess, CreateDisposition, CreateOptions, NamedPipeType, ReadMode, CompletionMode, MaximumInstances, InboundQuota, OutboundQuota, DefaultTimeout);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateNamedPipeFile), (uint32_t)w32_NtCreateNamedPipeFile, 14, FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, ShareAccess, CreateDisposition, CreateOptions, NamedPipeType, ReadMode, CompletionMode, MaximumInstances, InboundQuota, OutboundQuota, DefaultTimeout);
#endif
    }

    NTSTATUS WINAPI NtCreatePagingFile(PUNICODE_STRING PageFileName, PLARGE_INTEGER MinimumSize, PLARGE_INTEGER MaximumSize, ULONG Priority) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreatePagingFile), 0, 4, PageFileName, MinimumSize, MaximumSize, Priority);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreatePagingFile), (uint32_t)w32_NtCreatePagingFile, 4, PageFileName, MinimumSize, MaximumSize, Priority);
#endif
    }

    NTSTATUS WINAPI NtCreatePartition(PHANDLE PartitionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG PreferredNode) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreatePartition), 0, 4, PartitionHandle, DesiredAccess, ObjectAttributes, PreferredNode);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreatePartition), (uint32_t)w32_NtCreatePartition, 4, PartitionHandle, DesiredAccess, ObjectAttributes, PreferredNode);
#endif
    }

    NTSTATUS WINAPI NtCreatePort(PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreatePort), 0, 5, PortHandle, ObjectAttributes, MaxConnectionInfoLength, MaxMessageLength, MaxPoolUsage);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreatePort), (uint32_t)w32_NtCreatePort, 5, PortHandle, ObjectAttributes, MaxConnectionInfoLength, MaxMessageLength, MaxPoolUsage);
#endif
    }

    NTSTATUS WINAPI NtCreatePrivateNamespace(PHANDLE NamespaceHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PVOID BoundaryDescriptor) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreatePrivateNamespace), 0, 4, NamespaceHandle, DesiredAccess, ObjectAttributes, BoundaryDescriptor);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreatePrivateNamespace), (uint32_t)w32_NtCreatePrivateNamespace, 4, NamespaceHandle, DesiredAccess, ObjectAttributes, BoundaryDescriptor);
#endif
    }

    NTSTATUS WINAPI NtCreateProcess(PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ParentProcess, BOOLEAN InheritObjectTable, HANDLE SectionHandle, HANDLE DebugPort, HANDLE ExceptionPort) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateProcess), 0, 8, ProcessHandle, DesiredAccess, ObjectAttributes, ParentProcess, InheritObjectTable, SectionHandle, DebugPort, ExceptionPort);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateProcess), (uint32_t)w32_NtCreateProcess, 8, ProcessHandle, DesiredAccess, ObjectAttributes, ParentProcess, InheritObjectTable, SectionHandle, DebugPort, ExceptionPort);
#endif
    }

    NTSTATUS WINAPI NtCreateProcessEx(PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ParentProcess, ULONG Flags, HANDLE SectionHandle, HANDLE DebugPort, HANDLE ExceptionPort, ULONG JobMemberLevel) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateProcessEx), 0, 9, ProcessHandle, DesiredAccess, ObjectAttributes, ParentProcess, Flags, SectionHandle, DebugPort, ExceptionPort, JobMemberLevel);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateProcessEx), (uint32_t)w32_NtCreateProcessEx, 9, ProcessHandle, DesiredAccess, ObjectAttributes, ParentProcess, Flags, SectionHandle, DebugPort, ExceptionPort, JobMemberLevel);
#endif
    }

    NTSTATUS WINAPI NtCreateProfile(PHANDLE ProfileHandle, HANDLE Process, PVOID ProfileBase, SIZE_T ProfileSize, ULONG BucketSize, PULONG Buffer, ULONG BufferSize, KPROFILE_SOURCE ProfileSource, KAFFINITY Affinity) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateProfile), 0, 9, ProfileHandle, Process, ProfileBase, ProfileSize, BucketSize, Buffer, BufferSize, ProfileSource, Affinity);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateProfile), (uint32_t)w32_NtCreateProfile, 9, ProfileHandle, Process, ProfileBase, ProfileSize, BucketSize, Buffer, BufferSize, ProfileSource, Affinity);
#endif
    }

    NTSTATUS WINAPI NtCreateProfileEx(PHANDLE ProfileHandle, HANDLE Process, PVOID ProfileBase, SIZE_T ProfileSize, ULONG BucketSize, PULONG Buffer, ULONG BufferSize, KPROFILE_SOURCE ProfileSource, USHORT GroupCount, PGROUP_AFFINITY GroupAffinity) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateProfileEx), 0, 10, ProfileHandle, Process, ProfileBase, ProfileSize, BucketSize, Buffer, BufferSize, ProfileSource, GroupCount, GroupAffinity);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateProfileEx), (uint32_t)w32_NtCreateProfileEx, 10, ProfileHandle, Process, ProfileBase, ProfileSize, BucketSize, Buffer, BufferSize, ProfileSource, GroupCount, GroupAffinity);
#endif
    }

    NTSTATUS WINAPI NtCreateResourceManager(PHANDLE ResourceManagerHandle, ACCESS_MASK DesiredAccess, HANDLE TmHandle, LPGUID RmGuid, POBJECT_ATTRIBUTES ObjectAttributes, ULONG CreateOptions, PUNICODE_STRING Description) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateResourceManager), 0, 7, ResourceManagerHandle, DesiredAccess, TmHandle, RmGuid, ObjectAttributes, CreateOptions, Description);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateResourceManager), (uint32_t)w32_NtCreateResourceManager, 7, ResourceManagerHandle, DesiredAccess, TmHandle, RmGuid, ObjectAttributes, CreateOptions, Description);
#endif
    }

    NTSTATUS WINAPI NtCreateSection(PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PLARGE_INTEGER MaximumSize, ULONG SectionPageProtection, ULONG AllocationAttributes, HANDLE FileHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateSection), 0, 7, SectionHandle, DesiredAccess, ObjectAttributes, MaximumSize, SectionPageProtection, AllocationAttributes, FileHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateSection), (uint32_t)w32_NtCreateSection, 7, SectionHandle, DesiredAccess, ObjectAttributes, MaximumSize, SectionPageProtection, AllocationAttributes, FileHandle);
#endif
    }

    NTSTATUS WINAPI NtCreateSectionEx(PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PLARGE_INTEGER MaximumSize, ULONG SectionPageProtection, ULONG AllocationAttributes, HANDLE FileHandle, PMEM_EXTENDED_PARAMETER ExtendedParameters, ULONG ExtendedParameterCount) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateSectionEx), 0, 9, SectionHandle, DesiredAccess, ObjectAttributes, MaximumSize, SectionPageProtection, AllocationAttributes, FileHandle, ExtendedParameters, ExtendedParameterCount);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateSectionEx), (uint32_t)w32_NtCreateSectionEx, 9, SectionHandle, DesiredAccess, ObjectAttributes, MaximumSize, SectionPageProtection, AllocationAttributes, FileHandle, ExtendedParameters, ExtendedParameterCount);
#endif
    }

    NTSTATUS WINAPI NtCreateSemaphore(PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LONG InitialCount, LONG MaximumCount) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateSemaphore), 0, 5, SemaphoreHandle, DesiredAccess, ObjectAttributes, InitialCount, MaximumCount);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateSemaphore), (uint32_t)w32_NtCreateSemaphore, 5, SemaphoreHandle, DesiredAccess, ObjectAttributes, InitialCount, MaximumCount);
#endif
    }

    NTSTATUS WINAPI NtCreateSymbolicLinkObject(PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LinkTarget) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateSymbolicLinkObject), 0, 4, LinkHandle, DesiredAccess, ObjectAttributes, LinkTarget);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateSymbolicLinkObject), (uint32_t)w32_NtCreateSymbolicLinkObject, 4, LinkHandle, DesiredAccess, ObjectAttributes, LinkTarget);
#endif
    }

    NTSTATUS WINAPI NtCreateThread(PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PCLIENT_ID ClientId, PCONTEXT ThreadContext, PINITIAL_TEB InitialTeb, BOOLEAN CreateSuspended) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateThread), 0, 8, ThreadHandle, DesiredAccess, ObjectAttributes, ProcessHandle, ClientId, ThreadContext, InitialTeb, CreateSuspended);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateThread), (uint32_t)w32_NtCreateThread, 8, ThreadHandle, DesiredAccess, ObjectAttributes, ProcessHandle, ClientId, ThreadContext, InitialTeb, CreateSuspended);
#endif
    }

    NTSTATUS WINAPI NtCreateThreadEx(PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PVOID StartRoutine, PVOID Argument, ULONG CreateFlags, SIZE_T ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, PPS_ATTRIBUTE_LIST AttributeList) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateThreadEx), 0, 11, ThreadHandle, DesiredAccess, ObjectAttributes, ProcessHandle, StartRoutine, Argument, CreateFlags, ZeroBits, StackSize, MaximumStackSize, AttributeList);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateThreadEx), (uint32_t)w32_NtCreateThreadEx, 11, ThreadHandle, DesiredAccess, ObjectAttributes, ProcessHandle, StartRoutine, Argument, CreateFlags, ZeroBits, StackSize, MaximumStackSize, AttributeList);
#endif
    }

    NTSTATUS WINAPI NtCreateTimer(PHANDLE TimerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TIMER_TYPE TimerType) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateTimer), 0, 4, TimerHandle, DesiredAccess, ObjectAttributes, TimerType);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateTimer), (uint32_t)w32_NtCreateTimer, 4, TimerHandle, DesiredAccess, ObjectAttributes, TimerType);
#endif
    }

    NTSTATUS WINAPI NtCreateTimer2(PHANDLE TimerHandle, PVOID Reserved1, PVOID Reserved2, ULONG Attributes, ACCESS_MASK DesiredAccess) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateTimer2), 0, 5, TimerHandle, Reserved1, Reserved2, Attributes, DesiredAccess);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateTimer2), (uint32_t)w32_NtCreateTimer2, 5, TimerHandle, Reserved1, Reserved2, Attributes, DesiredAccess);
#endif
    }

    NTSTATUS WINAPI NtCreateToken(PHANDLE TokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TOKEN_TYPE TokenType, PLUID AuthenticationId, PLARGE_INTEGER ExpirationTime, PTOKEN_USER User, PTOKEN_GROUPS Groups, PTOKEN_PRIVILEGES Privileges, PTOKEN_OWNER Owner, PTOKEN_PRIMARY_GROUP PrimaryGroup, PTOKEN_DEFAULT_DACL DefaultDacl, PTOKEN_SOURCE TokenSource) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateToken), 0, 13, TokenHandle, DesiredAccess, ObjectAttributes, TokenType, AuthenticationId, ExpirationTime, User, Groups, Privileges, Owner, PrimaryGroup, DefaultDacl, TokenSource);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateToken), (uint32_t)w32_NtCreateToken, 13, TokenHandle, DesiredAccess, ObjectAttributes, TokenType, AuthenticationId, ExpirationTime, User, Groups, Privileges, Owner, PrimaryGroup, DefaultDacl, TokenSource);
#endif
    }

    NTSTATUS WINAPI NtCreateTokenEx(PHANDLE TokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TOKEN_TYPE TokenType, PLUID AuthenticationId, PLARGE_INTEGER ExpirationTime, PTOKEN_USER User, PTOKEN_GROUPS Groups, PTOKEN_PRIVILEGES Privileges, PTOKEN_SECURITY_ATTRIBUTES_INFORMATION UserAttributes, PTOKEN_SECURITY_ATTRIBUTES_INFORMATION DeviceAttributes, PTOKEN_GROUPS DeviceGroups, PTOKEN_MANDATORY_POLICY TokenMandatoryPolicy, PTOKEN_OWNER Owner, PTOKEN_PRIMARY_GROUP PrimaryGroup, PTOKEN_DEFAULT_DACL DefaultDacl, PTOKEN_SOURCE TokenSource) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateTokenEx), 0, 17, TokenHandle, DesiredAccess, ObjectAttributes, TokenType, AuthenticationId, ExpirationTime, User, Groups, Privileges, UserAttributes, DeviceAttributes, DeviceGroups, TokenMandatoryPolicy, Owner, PrimaryGroup, DefaultDacl, TokenSource);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateTokenEx), (uint32_t)w32_NtCreateTokenEx, 17, TokenHandle, DesiredAccess, ObjectAttributes, TokenType, AuthenticationId, ExpirationTime, User, Groups, Privileges, UserAttributes, DeviceAttributes, DeviceGroups, TokenMandatoryPolicy, Owner, PrimaryGroup, DefaultDacl, TokenSource);
#endif
    }

    NTSTATUS WINAPI NtCreateTransaction(PHANDLE TransactionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LPGUID Uow, HANDLE TmHandle, ULONG CreateOptions, ULONG IsolationLevel, ULONG IsolationFlags, PLARGE_INTEGER Timeout, PUNICODE_STRING Description) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateTransaction), 0, 10, TransactionHandle, DesiredAccess, ObjectAttributes, Uow, TmHandle, CreateOptions, IsolationLevel, IsolationFlags, Timeout, Description);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateTransaction), (uint32_t)w32_NtCreateTransaction, 10, TransactionHandle, DesiredAccess, ObjectAttributes, Uow, TmHandle, CreateOptions, IsolationLevel, IsolationFlags, Timeout, Description);
#endif
    }

    NTSTATUS WINAPI NtCreateTransactionManager(PHANDLE TmHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LogFileName, ULONG CreateOptions, ULONG CommitStrength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateTransactionManager), 0, 6, TmHandle, DesiredAccess, ObjectAttributes, LogFileName, CreateOptions, CommitStrength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateTransactionManager), (uint32_t)w32_NtCreateTransactionManager, 6, TmHandle, DesiredAccess, ObjectAttributes, LogFileName, CreateOptions, CommitStrength);
#endif
    }

    NTSTATUS WINAPI NtCreateUserProcess(PHANDLE ProcessHandle, PHANDLE ThreadHandle, ACCESS_MASK ProcessDesiredAccess, ACCESS_MASK ThreadDesiredAccess, POBJECT_ATTRIBUTES ProcessObjectAttributes, POBJECT_ATTRIBUTES ThreadObjectAttributes, ULONG ProcessFlags, ULONG ThreadFlags, PVOID ProcessParameters, PPS_CREATE_INFO CreateInfo, PPS_ATTRIBUTE_LIST AttributeList) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateUserProcess), 0, 11, ProcessHandle, ThreadHandle, ProcessDesiredAccess, ThreadDesiredAccess, ProcessObjectAttributes, ThreadObjectAttributes, ProcessFlags, ThreadFlags, ProcessParameters, CreateInfo, AttributeList);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateUserProcess), (uint32_t)w32_NtCreateUserProcess, 11, ProcessHandle, ThreadHandle, ProcessDesiredAccess, ThreadDesiredAccess, ProcessObjectAttributes, ThreadObjectAttributes, ProcessFlags, ThreadFlags, ProcessParameters, CreateInfo, AttributeList);
#endif
    }

    NTSTATUS WINAPI NtCreateWaitCompletionPacket(PHANDLE WaitCompletionPacketHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateWaitCompletionPacket), 0, 3, WaitCompletionPacketHandle, DesiredAccess, ObjectAttributes);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateWaitCompletionPacket), (uint32_t)w32_NtCreateWaitCompletionPacket, 3, WaitCompletionPacketHandle, DesiredAccess, ObjectAttributes);
#endif
    }

    NTSTATUS WINAPI NtCreateWaitablePort(PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateWaitablePort), 0, 5, PortHandle, ObjectAttributes, MaxConnectionInfoLength, MaxMessageLength, MaxPoolUsage);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateWaitablePort), (uint32_t)w32_NtCreateWaitablePort, 5, PortHandle, ObjectAttributes, MaxConnectionInfoLength, MaxMessageLength, MaxPoolUsage);
#endif
    }

    NTSTATUS WINAPI NtCreateWnfStateName(PWNF_STATE_NAME StateName, WNF_STATE_NAME_LIFETIME NameLifetime, WNF_DATA_SCOPE DataScope, BOOLEAN PersistData, PCWNF_TYPE_ID TypeId, ULONG MaximumStateSize, PSECURITY_DESCRIPTOR SecurityDescriptor) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateWnfStateName), 0, 7, StateName, NameLifetime, DataScope, PersistData, TypeId, MaximumStateSize, SecurityDescriptor);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateWnfStateName), (uint32_t)w32_NtCreateWnfStateName, 7, StateName, NameLifetime, DataScope, PersistData, TypeId, MaximumStateSize, SecurityDescriptor);
#endif
    }

    NTSTATUS WINAPI NtCreateWorkerFactory(PHANDLE WorkerFactoryHandleReturn, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE CompletionPortHandle, HANDLE WorkerProcessHandle, PVOID StartRoutine, PVOID StartParameter, ULONG MaxThreadCount, SIZE_T StackReserve, SIZE_T StackCommit) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateWorkerFactory), 0, 10, WorkerFactoryHandleReturn, DesiredAccess, ObjectAttributes, CompletionPortHandle, WorkerProcessHandle, StartRoutine, StartParameter, MaxThreadCount, StackReserve, StackCommit);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtCreateWorkerFactory), (uint32_t)w32_NtCreateWorkerFactory, 10, WorkerFactoryHandleReturn, DesiredAccess, ObjectAttributes, CompletionPortHandle, WorkerProcessHandle, StartRoutine, StartParameter, MaxThreadCount, StackReserve, StackCommit);
#endif
    }

    NTSTATUS WINAPI NtDebugActiveProcess(HANDLE ProcessHandle, HANDLE DebugObjectHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDebugActiveProcess), 0, 2, ProcessHandle, DebugObjectHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDebugActiveProcess), (uint32_t)w32_NtDebugActiveProcess, 2, ProcessHandle, DebugObjectHandle);
#endif
    }

    NTSTATUS WINAPI NtDebugContinue(HANDLE DebugObjectHandle, PCLIENT_ID ClientId, NTSTATUS ContinueStatus) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDebugContinue), 0, 3, DebugObjectHandle, ClientId, ContinueStatus);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDebugContinue), (uint32_t)w32_NtDebugContinue, 3, DebugObjectHandle, ClientId, ContinueStatus);
#endif
    }

    NTSTATUS WINAPI NtDelayExecution(BOOLEAN Alertable, PLARGE_INTEGER DelayInterval) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDelayExecution), 0, 2, Alertable, DelayInterval);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDelayExecution), (uint32_t)w32_NtDelayExecution, 2, Alertable, DelayInterval);
#endif
    }

    NTSTATUS WINAPI NtDeleteAtom(RTL_ATOM Atom) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDeleteAtom), 0, 1, Atom);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDeleteAtom), (uint32_t)w32_NtDeleteAtom, 1, Atom);
#endif
    }

    NTSTATUS WINAPI NtDeleteBootEntry(ULONG Id) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDeleteBootEntry), 0, 1, Id);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDeleteBootEntry), (uint32_t)w32_NtDeleteBootEntry, 1, Id);
#endif
    }

    NTSTATUS WINAPI NtDeleteDriverEntry(ULONG Id) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDeleteDriverEntry), 0, 1, Id);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDeleteDriverEntry), (uint32_t)w32_NtDeleteDriverEntry, 1, Id);
#endif
    }

    NTSTATUS WINAPI NtDeleteFile(POBJECT_ATTRIBUTES ObjectAttributes) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDeleteFile), 0, 1, ObjectAttributes);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDeleteFile), (uint32_t)w32_NtDeleteFile, 1, ObjectAttributes);
#endif
    }

    NTSTATUS WINAPI NtDeleteKey(HANDLE KeyHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDeleteKey), 0, 1, KeyHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDeleteKey), (uint32_t)w32_NtDeleteKey, 1, KeyHandle);
#endif
    }

    NTSTATUS WINAPI NtDeleteObjectAuditAlarm(PUNICODE_STRING SubsystemName, PVOID HandleId, BOOLEAN GenerateOnClose) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDeleteObjectAuditAlarm), 0, 3, SubsystemName, HandleId, GenerateOnClose);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDeleteObjectAuditAlarm), (uint32_t)w32_NtDeleteObjectAuditAlarm, 3, SubsystemName, HandleId, GenerateOnClose);
#endif
    }

    NTSTATUS WINAPI NtDeletePrivateNamespace(HANDLE NamespaceHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDeletePrivateNamespace), 0, 1, NamespaceHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDeletePrivateNamespace), (uint32_t)w32_NtDeletePrivateNamespace, 1, NamespaceHandle);
#endif
    }

    NTSTATUS WINAPI NtDeleteValueKey(HANDLE KeyHandle, PUNICODE_STRING ValueName) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDeleteValueKey), 0, 2, KeyHandle, ValueName);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDeleteValueKey), (uint32_t)w32_NtDeleteValueKey, 2, KeyHandle, ValueName);
#endif
    }

    NTSTATUS WINAPI NtDeleteWnfStateData(PCWNF_STATE_NAME StateName, void const* ExplicitScope) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDeleteWnfStateData), 0, 2, StateName, ExplicitScope);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDeleteWnfStateData), (uint32_t)w32_NtDeleteWnfStateData, 2, StateName, ExplicitScope);
#endif
    }

    NTSTATUS WINAPI NtDeleteWnfStateName(PCWNF_STATE_NAME StateName) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDeleteWnfStateName), 0, 1, StateName);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDeleteWnfStateName), (uint32_t)w32_NtDeleteWnfStateName, 1, StateName);
#endif
    }

    NTSTATUS WINAPI NtDeviceIoControlFile(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDeviceIoControlFile), 0, 10, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, IoControlCode, InputBuffer, InputBufferLength, OutputBuffer, OutputBufferLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDeviceIoControlFile), (uint32_t)w32_NtDeviceIoControlFile, 10, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, IoControlCode, InputBuffer, InputBufferLength, OutputBuffer, OutputBufferLength);
#endif
    }

    NTSTATUS WINAPI NtDisableLastKnownGood() {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDisableLastKnownGood), 0, 0);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDisableLastKnownGood), (uint32_t)w32_NtDisableLastKnownGood, 0);
#endif
    }

    NTSTATUS WINAPI NtDisplayString(PUNICODE_STRING String) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDisplayString), 0, 1, String);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDisplayString), (uint32_t)w32_NtDisplayString, 1, String);
#endif
    }

    NTSTATUS WINAPI NtDrawText(PUNICODE_STRING Text) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDrawText), 0, 1, Text);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDrawText), (uint32_t)w32_NtDrawText, 1, Text);
#endif
    }

    NTSTATUS WINAPI NtDuplicateObject(HANDLE SourceProcessHandle, HANDLE SourceHandle, HANDLE TargetProcessHandle, PHANDLE TargetHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Options) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDuplicateObject), 0, 7, SourceProcessHandle, SourceHandle, TargetProcessHandle, TargetHandle, DesiredAccess, HandleAttributes, Options);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDuplicateObject), (uint32_t)w32_NtDuplicateObject, 7, SourceProcessHandle, SourceHandle, TargetProcessHandle, TargetHandle, DesiredAccess, HandleAttributes, Options);
#endif
    }

    NTSTATUS WINAPI NtDuplicateToken(HANDLE ExistingTokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, BOOLEAN EffectiveOnly, TOKEN_TYPE TokenType, PHANDLE NewTokenHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDuplicateToken), 0, 6, ExistingTokenHandle, DesiredAccess, ObjectAttributes, EffectiveOnly, TokenType, NewTokenHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtDuplicateToken), (uint32_t)w32_NtDuplicateToken, 6, ExistingTokenHandle, DesiredAccess, ObjectAttributes, EffectiveOnly, TokenType, NewTokenHandle);
#endif
    }

    NTSTATUS WINAPI NtEnableLastKnownGood() {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtEnableLastKnownGood), 0, 0);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtEnableLastKnownGood), (uint32_t)w32_NtEnableLastKnownGood, 0);
#endif
    }

    NTSTATUS WINAPI NtEnumerateBootEntries(PVOID Buffer, PULONG BufferLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtEnumerateBootEntries), 0, 2, Buffer, BufferLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtEnumerateBootEntries), (uint32_t)w32_NtEnumerateBootEntries, 2, Buffer, BufferLength);
#endif
    }

    NTSTATUS WINAPI NtEnumerateDriverEntries(PVOID Buffer, PULONG BufferLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtEnumerateDriverEntries), 0, 2, Buffer, BufferLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtEnumerateDriverEntries), (uint32_t)w32_NtEnumerateDriverEntries, 2, Buffer, BufferLength);
#endif
    }

    NTSTATUS WINAPI NtEnumerateKey(HANDLE KeyHandle, ULONG Index, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtEnumerateKey), 0, 6, KeyHandle, Index, KeyInformationClass, KeyInformation, Length, ResultLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtEnumerateKey), (uint32_t)w32_NtEnumerateKey, 6, KeyHandle, Index, KeyInformationClass, KeyInformation, Length, ResultLength);
#endif
    }

    NTSTATUS WINAPI NtEnumerateSystemEnvironmentValuesEx(ULONG InformationClass, PVOID Buffer, PULONG BufferLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtEnumerateSystemEnvironmentValuesEx), 0, 3, InformationClass, Buffer, BufferLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtEnumerateSystemEnvironmentValuesEx), (uint32_t)w32_NtEnumerateSystemEnvironmentValuesEx, 3, InformationClass, Buffer, BufferLength);
#endif
    }

    NTSTATUS WINAPI NtEnumerateTransactionObject(HANDLE RootObjectHandle, KTMOBJECT_TYPE QueryType, PKTMOBJECT_CURSOR ObjectCursor, ULONG ObjectCursorLength, PULONG ReturnLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtEnumerateTransactionObject), 0, 5, RootObjectHandle, QueryType, ObjectCursor, ObjectCursorLength, ReturnLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtEnumerateTransactionObject), (uint32_t)w32_NtEnumerateTransactionObject, 5, RootObjectHandle, QueryType, ObjectCursor, ObjectCursorLength, ReturnLength);
#endif
    }

    NTSTATUS WINAPI NtEnumerateValueKey(HANDLE KeyHandle, ULONG Index, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtEnumerateValueKey), 0, 6, KeyHandle, Index, KeyValueInformationClass, KeyValueInformation, Length, ResultLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtEnumerateValueKey), (uint32_t)w32_NtEnumerateValueKey, 6, KeyHandle, Index, KeyValueInformationClass, KeyValueInformation, Length, ResultLength);
#endif
    }

    NTSTATUS WINAPI NtExtendSection(HANDLE SectionHandle, PLARGE_INTEGER NewSectionSize) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtExtendSection), 0, 2, SectionHandle, NewSectionSize);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtExtendSection), (uint32_t)w32_NtExtendSection, 2, SectionHandle, NewSectionSize);
#endif
    }

    NTSTATUS WINAPI NtFilterBootOption(FILTER_BOOT_OPTION_OPERATION FilterOperation, ULONG ObjectType, ULONG ElementType, PVOID Data, ULONG DataSize) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtFilterBootOption), 0, 5, FilterOperation, ObjectType, ElementType, Data, DataSize);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtFilterBootOption), (uint32_t)w32_NtFilterBootOption, 5, FilterOperation, ObjectType, ElementType, Data, DataSize);
#endif
    }

    NTSTATUS WINAPI NtFilterToken(HANDLE ExistingTokenHandle, ULONG Flags, PTOKEN_GROUPS SidsToDisable, PTOKEN_PRIVILEGES PrivilegesToDelete, PTOKEN_GROUPS RestrictedSids, PHANDLE NewTokenHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtFilterToken), 0, 6, ExistingTokenHandle, Flags, SidsToDisable, PrivilegesToDelete, RestrictedSids, NewTokenHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtFilterToken), (uint32_t)w32_NtFilterToken, 6, ExistingTokenHandle, Flags, SidsToDisable, PrivilegesToDelete, RestrictedSids, NewTokenHandle);
#endif
    }

    NTSTATUS WINAPI NtFilterTokenEx(HANDLE ExistingTokenHandle, ULONG Flags, PTOKEN_GROUPS SidsToDisable, PTOKEN_PRIVILEGES PrivilegesToDelete, PTOKEN_GROUPS RestrictedSids, ULONG DisableUserClaimsCount, PUNICODE_STRING UserClaimsToDisable, ULONG DisableDeviceClaimsCount, PUNICODE_STRING DeviceClaimsToDisable, PTOKEN_GROUPS DeviceGroupsToDisable, PTOKEN_SECURITY_ATTRIBUTES_INFORMATION RestrictedUserAttributes, PTOKEN_SECURITY_ATTRIBUTES_INFORMATION RestrictedDeviceAttributes, PTOKEN_GROUPS RestrictedDeviceGroups, PHANDLE NewTokenHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtFilterTokenEx), 0, 14, ExistingTokenHandle, Flags, SidsToDisable, PrivilegesToDelete, RestrictedSids, DisableUserClaimsCount, UserClaimsToDisable, DisableDeviceClaimsCount, DeviceClaimsToDisable, DeviceGroupsToDisable, RestrictedUserAttributes, RestrictedDeviceAttributes, RestrictedDeviceGroups, NewTokenHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtFilterTokenEx), (uint32_t)w32_NtFilterTokenEx, 14, ExistingTokenHandle, Flags, SidsToDisable, PrivilegesToDelete, RestrictedSids, DisableUserClaimsCount, UserClaimsToDisable, DisableDeviceClaimsCount, DeviceClaimsToDisable, DeviceGroupsToDisable, RestrictedUserAttributes, RestrictedDeviceAttributes, RestrictedDeviceGroups, NewTokenHandle);
#endif
    }

    NTSTATUS WINAPI NtFindAtom(PWSTR AtomName, ULONG Length, PRTL_ATOM Atom) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtFindAtom), 0, 3, AtomName, Length, Atom);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtFindAtom), (uint32_t)w32_NtFindAtom, 3, AtomName, Length, Atom);
#endif
    }

    NTSTATUS WINAPI NtFlushBuffersFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtFlushBuffersFile), 0, 2, FileHandle, IoStatusBlock);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtFlushBuffersFile), (uint32_t)w32_NtFlushBuffersFile, 2, FileHandle, IoStatusBlock);
#endif
    }

    NTSTATUS WINAPI NtFlushBuffersFileEx(HANDLE FileHandle, ULONG Flags, PVOID Parameters, ULONG ParametersSize, PIO_STATUS_BLOCK IoStatusBlock) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtFlushBuffersFileEx), 0, 5, FileHandle, Flags, Parameters, ParametersSize, IoStatusBlock);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtFlushBuffersFileEx), (uint32_t)w32_NtFlushBuffersFileEx, 5, FileHandle, Flags, Parameters, ParametersSize, IoStatusBlock);
#endif
    }

    NTSTATUS WINAPI NtFlushInstallUILanguage(LANGID InstallUILanguage, ULONG SetComittedFlag) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtFlushInstallUILanguage), 0, 2, InstallUILanguage, SetComittedFlag);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtFlushInstallUILanguage), (uint32_t)w32_NtFlushInstallUILanguage, 2, InstallUILanguage, SetComittedFlag);
#endif
    }

    NTSTATUS WINAPI NtFlushInstructionCache(HANDLE ProcessHandle, PVOID BaseAddress, SIZE_T Length) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtFlushInstructionCache), 0, 3, ProcessHandle, BaseAddress, Length);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtFlushInstructionCache), (uint32_t)w32_NtFlushInstructionCache, 3, ProcessHandle, BaseAddress, Length);
#endif
    }

    NTSTATUS WINAPI NtFlushKey(HANDLE KeyHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtFlushKey), 0, 1, KeyHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtFlushKey), (uint32_t)w32_NtFlushKey, 1, KeyHandle);
#endif
    }

    void WINAPI NtFlushProcessWriteBuffers() {

        if (!is_syscall_table_initialized()) {
            return;
        }

#ifdef _M_AMD64
        cleancall::call(get_syscall_by_idx(SYSCALL_NtFlushProcessWriteBuffers), 0, 0);
#else
        cleancall::call(get_syscall_by_idx(SYSCALL_NtFlushProcessWriteBuffers), (uint32_t)w32_NtFlushProcessWriteBuffers, 0);
#endif
    }

    NTSTATUS WINAPI NtFlushVirtualMemory(IN HANDLE ProcessHandle, IN OUT PVOID* BaseAddress, IN OUT PSIZE_T RegionSize, OUT PIO_STATUS_BLOCK IoStatus) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtFlushVirtualMemory), 0, 0);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtFlushVirtualMemory), (uint32_t)w32_NtFlushVirtualMemory, 0);
#endif
    }

    NTSTATUS WINAPI NtFlushWriteBuffer() {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtFlushWriteBuffer), 0, 0);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtFlushWriteBuffer), (uint32_t)w32_NtFlushWriteBuffer, 0);
#endif
    }

    NTSTATUS WINAPI NtFreeUserPhysicalPages(HANDLE ProcessHandle, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtFreeUserPhysicalPages), 0, 3, ProcessHandle, NumberOfPages, UserPfnArray);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtFreeUserPhysicalPages), (uint32_t)w32_NtFreeUserPhysicalPages, 3, ProcessHandle, NumberOfPages, UserPfnArray);
#endif
    }

    NTSTATUS WINAPI NtFreeVirtualMemory(HANDLE ProcessHandle, PVOID* BaseAddress, PSIZE_T RegionSize, ULONG FreeType) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtFreeVirtualMemory), 0, 4, ProcessHandle, BaseAddress, RegionSize, FreeType);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtFreeVirtualMemory), (uint32_t)w32_NtFreeVirtualMemory, 4, ProcessHandle, BaseAddress, RegionSize, FreeType);
#endif
    }

    NTSTATUS WINAPI NtFreezeRegistry(ULONG TimeOutInSeconds) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtFreezeRegistry), 0, 1, TimeOutInSeconds);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtFreezeRegistry), (uint32_t)w32_NtFreezeRegistry, 1, TimeOutInSeconds);
#endif
    }

    NTSTATUS WINAPI NtFreezeTransactions(PLARGE_INTEGER FreezeTimeout, PLARGE_INTEGER ThawTimeout) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtFreezeTransactions), 0, 2, FreezeTimeout, ThawTimeout);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtFreezeTransactions), (uint32_t)w32_NtFreezeTransactions, 2, FreezeTimeout, ThawTimeout);
#endif
    }

    NTSTATUS WINAPI NtFsControlFile(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG FsControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtFsControlFile), 0, 10, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, FsControlCode, InputBuffer, InputBufferLength, OutputBuffer, OutputBufferLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtFsControlFile), (uint32_t)w32_NtFsControlFile, 10, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, FsControlCode, InputBuffer, InputBufferLength, OutputBuffer, OutputBufferLength);
#endif
    }

    NTSTATUS WINAPI NtGetCachedSigningLevel(HANDLE File, PULONG Flags, PSE_SIGNING_LEVEL SigningLevel, PUCHAR Thumbprint, PULONG ThumbprintSize, PULONG ThumbprintAlgorithm) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtGetCachedSigningLevel), 0, 6, File, Flags, SigningLevel, Thumbprint, ThumbprintSize, ThumbprintAlgorithm);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtGetCachedSigningLevel), (uint32_t)w32_NtGetCachedSigningLevel, 6, File, Flags, SigningLevel, Thumbprint, ThumbprintSize, ThumbprintAlgorithm);
#endif
    }

    NTSTATUS WINAPI NtGetCompleteWnfStateSubscription(PWNF_STATE_NAME OldDescriptorStateName, ULONG64* OldSubscriptionId, ULONG OldDescriptorEventMask, ULONG OldDescriptorStatus, PWNF_DELIVERY_DESCRIPTOR NewDeliveryDescriptor, ULONG DescriptorSize) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtGetCompleteWnfStateSubscription), 0, 6, OldDescriptorStateName, OldSubscriptionId, OldDescriptorEventMask, OldDescriptorStatus, NewDeliveryDescriptor, DescriptorSize);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtGetCompleteWnfStateSubscription), (uint32_t)w32_NtGetCompleteWnfStateSubscription, 6, OldDescriptorStateName, OldSubscriptionId, OldDescriptorEventMask, OldDescriptorStatus, NewDeliveryDescriptor, DescriptorSize);
#endif
    }

    NTSTATUS WINAPI NtGetContextThread(HANDLE ThreadHandle, PCONTEXT ThreadContext) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtGetContextThread), 0, 2, ThreadHandle, ThreadContext);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtGetContextThread), (uint32_t)w32_NtGetContextThread, 2, ThreadHandle, ThreadContext);
#endif
    }

    ULONG WINAPI NtGetCurrentProcessorNumber() {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtGetCurrentProcessorNumber), 0, 0);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtGetCurrentProcessorNumber), (uint32_t)w32_NtGetCurrentProcessorNumber, 0);
#endif
    }

    NTSTATUS WINAPI NtGetDevicePowerState(HANDLE Device, PDEVICE_POWER_STATE State) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtGetDevicePowerState), 0, 2, Device, State);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtGetDevicePowerState), (uint32_t)w32_NtGetDevicePowerState, 2, Device, State);
#endif
    }

    NTSTATUS WINAPI NtGetMUIRegistryInfo(ULONG Flags, PULONG DataSize, PVOID Data) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtGetMUIRegistryInfo), 0, 3, Flags, DataSize, Data);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtGetMUIRegistryInfo), (uint32_t)w32_NtGetMUIRegistryInfo, 3, Flags, DataSize, Data);
#endif
    }

    NTSTATUS WINAPI NtGetNextProcess(HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Flags, PHANDLE NewProcessHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtGetNextProcess), 0, 5, ProcessHandle, DesiredAccess, HandleAttributes, Flags, NewProcessHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtGetNextProcess), (uint32_t)w32_NtGetNextProcess, 5, ProcessHandle, DesiredAccess, HandleAttributes, Flags, NewProcessHandle);
#endif
    }

    NTSTATUS WINAPI NtGetNextThread(HANDLE ProcessHandle, HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Flags, PHANDLE NewThreadHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtGetNextThread), 0, 6, ProcessHandle, ThreadHandle, DesiredAccess, HandleAttributes, Flags, NewThreadHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtGetNextThread), (uint32_t)w32_NtGetNextThread, 6, ProcessHandle, ThreadHandle, DesiredAccess, HandleAttributes, Flags, NewThreadHandle);
#endif
    }

    NTSTATUS WINAPI NtGetNlsSectionPtr(ULONG SectionType, ULONG SectionData, PVOID ContextData, PVOID* SectionPointer, PULONG SectionSize) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtGetNlsSectionPtr), 0, 5, SectionType, SectionData, ContextData, SectionPointer, SectionSize);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtGetNlsSectionPtr), (uint32_t)w32_NtGetNlsSectionPtr, 5, SectionType, SectionData, ContextData, SectionPointer, SectionSize);
#endif
    }

    NTSTATUS WINAPI NtGetNotificationResourceManager(HANDLE ResourceManagerHandle, PTRANSACTION_NOTIFICATION TransactionNotification, ULONG NotificationLength, PLARGE_INTEGER Timeout, PULONG ReturnLength, ULONG Asynchronous, ULONG_PTR AsynchronousContext) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtGetNotificationResourceManager), 0, 7, ResourceManagerHandle, TransactionNotification, NotificationLength, Timeout, ReturnLength, Asynchronous, AsynchronousContext);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtGetNotificationResourceManager), (uint32_t)w32_NtGetNotificationResourceManager, 7, ResourceManagerHandle, TransactionNotification, NotificationLength, Timeout, ReturnLength, Asynchronous, AsynchronousContext);
#endif
    }

    NTSTATUS WINAPI NtGetWriteWatch(HANDLE ProcessHandle, ULONG Flags, PVOID BaseAddress, SIZE_T RegionSize, PVOID* UserAddressArray, PULONG_PTR EntriesInUserAddressArray, PULONG Granularity) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtGetWriteWatch), 0, 7, ProcessHandle, Flags, BaseAddress, RegionSize, UserAddressArray, EntriesInUserAddressArray, Granularity);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtGetWriteWatch), (uint32_t)w32_NtGetWriteWatch, 7, ProcessHandle, Flags, BaseAddress, RegionSize, UserAddressArray, EntriesInUserAddressArray, Granularity);
#endif
    }

    NTSTATUS WINAPI NtImpersonateAnonymousToken(HANDLE ThreadHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtImpersonateAnonymousToken), 0, 1, ThreadHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtImpersonateAnonymousToken), (uint32_t)w32_NtImpersonateAnonymousToken, 1, ThreadHandle);
#endif
    }

    NTSTATUS WINAPI NtImpersonateClientOfPort(HANDLE PortHandle, PPORT_MESSAGE Message) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtImpersonateClientOfPort), 0, 2, PortHandle, Message);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtImpersonateClientOfPort), (uint32_t)w32_NtImpersonateClientOfPort, 2, PortHandle, Message);
#endif
    }

    NTSTATUS WINAPI NtImpersonateThread(HANDLE ServerThreadHandle, HANDLE ClientThreadHandle, PSECURITY_QUALITY_OF_SERVICE SecurityQos) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtImpersonateThread), 0, 3, ServerThreadHandle, ClientThreadHandle, SecurityQos);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtImpersonateThread), (uint32_t)w32_NtImpersonateThread, 3, ServerThreadHandle, ClientThreadHandle, SecurityQos);
#endif
    }

    NTSTATUS WINAPI NtInitializeEnclave(HANDLE ProcessHandle, PVOID BaseAddress, PVOID EnclaveInformation, ULONG EnclaveInformationLength, PULONG EnclaveError) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtInitializeEnclave), 0, 5, ProcessHandle, BaseAddress, EnclaveInformation, EnclaveInformationLength, EnclaveError);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtInitializeEnclave), (uint32_t)w32_NtInitializeEnclave, 5, ProcessHandle, BaseAddress, EnclaveInformation, EnclaveInformationLength, EnclaveError);
#endif
    }

    NTSTATUS WINAPI NtInitializeNlsFiles(PVOID* BaseAddress, PLCID DefaultLocaleId, PLARGE_INTEGER DefaultCasingTableSize) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtInitializeNlsFiles), 0, 3, BaseAddress, DefaultLocaleId, DefaultCasingTableSize);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtInitializeNlsFiles), (uint32_t)w32_NtInitializeNlsFiles, 3, BaseAddress, DefaultLocaleId, DefaultCasingTableSize);
#endif
    }

    NTSTATUS WINAPI NtInitializeRegistry(USHORT BootCondition) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtInitializeRegistry), 0, 1, BootCondition);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtInitializeRegistry), (uint32_t)w32_NtInitializeRegistry, 1, BootCondition);
#endif
    }

    NTSTATUS WINAPI NtInitiatePowerAction(POWER_ACTION SystemAction, SYSTEM_POWER_STATE LightestSystemState, ULONG Flags, BOOLEAN Asynchronous) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtInitiatePowerAction), 0, 4, SystemAction, LightestSystemState, Flags, Asynchronous);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtInitiatePowerAction), (uint32_t)w32_NtInitiatePowerAction, 4, SystemAction, LightestSystemState, Flags, Asynchronous);
#endif
    }

    NTSTATUS WINAPI NtIsProcessInJob(HANDLE ProcessHandle, HANDLE JobHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtIsProcessInJob), 0, 2, ProcessHandle, JobHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtIsProcessInJob), (uint32_t)w32_NtIsProcessInJob, 2, ProcessHandle, JobHandle);
#endif
    }

    BOOLEAN WINAPI NtIsSystemResumeAutomatic() {

        if (!is_syscall_table_initialized()) {
            return FALSE;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtIsSystemResumeAutomatic), 0, 0);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtIsSystemResumeAutomatic), (uint32_t)w32_NtIsSystemResumeAutomatic, 0);
#endif
    }

    NTSTATUS WINAPI NtIsUILanguageComitted() {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtIsUILanguageComitted), 0, 0);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtIsUILanguageComitted), (uint32_t)w32_NtIsUILanguageComitted, 0);
#endif
    }

    NTSTATUS WINAPI NtListenPort(HANDLE PortHandle, PPORT_MESSAGE ConnectionRequest) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtListenPort), 0, 2, PortHandle, ConnectionRequest);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtListenPort), (uint32_t)w32_NtListenPort, 2, PortHandle, ConnectionRequest);
#endif
    }

    NTSTATUS WINAPI NtLoadDriver(PUNICODE_STRING DriverServiceName) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtLoadDriver), 0, 1, DriverServiceName);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtLoadDriver), (uint32_t)w32_NtLoadDriver, 1, DriverServiceName);
#endif
    }

    NTSTATUS WINAPI NtLoadEnclaveData(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, ULONG Protect, PVOID PageInformation, ULONG PageInformationLength, PSIZE_T NumberOfBytesWritten, PULONG EnclaveError) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtLoadEnclaveData), 0, 9, ProcessHandle, BaseAddress, Buffer, BufferSize, Protect, PageInformation, PageInformationLength, NumberOfBytesWritten, EnclaveError);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtLoadEnclaveData), (uint32_t)w32_NtLoadEnclaveData, 9, ProcessHandle, BaseAddress, Buffer, BufferSize, Protect, PageInformation, PageInformationLength, NumberOfBytesWritten, EnclaveError);
#endif
    }

    NTSTATUS WINAPI NtLoadKey(POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtLoadKey), 0, 2, TargetKey, SourceFile);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtLoadKey), (uint32_t)w32_NtLoadKey, 2, TargetKey, SourceFile);
#endif
    }

    NTSTATUS WINAPI NtLoadKey2(POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile, ULONG Flags) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtLoadKey2), 0, 3, TargetKey, SourceFile, Flags);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtLoadKey2), (uint32_t)w32_NtLoadKey2, 3, TargetKey, SourceFile, Flags);
#endif
    }

    NTSTATUS WINAPI NtLoadKeyEx(POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile, ULONG Flags, HANDLE TrustClassKey, HANDLE Event, ACCESS_MASK DesiredAccess, PHANDLE RootHandle, PIO_STATUS_BLOCK IoStatus) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtLoadKeyEx), 0, 8, TargetKey, SourceFile, Flags, TrustClassKey, Event, DesiredAccess, RootHandle, IoStatus);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtLoadKeyEx), (uint32_t)w32_NtLoadKeyEx, 8, TargetKey, SourceFile, Flags, TrustClassKey, Event, DesiredAccess, RootHandle, IoStatus);
#endif
    }

    NTSTATUS WINAPI NtLockFile(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER ByteOffset, PLARGE_INTEGER Length, ULONG Key, BOOLEAN FailImmediately, BOOLEAN ExclusiveLock) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtLockFile), 0, 10, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, ByteOffset, Length, Key, FailImmediately, ExclusiveLock);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtLockFile), (uint32_t)w32_NtLockFile, 10, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, ByteOffset, Length, Key, FailImmediately, ExclusiveLock);
#endif
    }

    NTSTATUS WINAPI NtLockProductActivationKeys(ULONG* pPrivateVer, ULONG* pSafeMode) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtLockProductActivationKeys), 0, 2, pPrivateVer, pSafeMode);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtLockProductActivationKeys), (uint32_t)w32_NtLockProductActivationKeys, 2, pPrivateVer, pSafeMode);
#endif
    }

    NTSTATUS WINAPI NtLockRegistryKey(HANDLE KeyHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtLockRegistryKey), 0, 1, KeyHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtLockRegistryKey), (uint32_t)w32_NtLockRegistryKey, 1, KeyHandle);
#endif
    }

    NTSTATUS WINAPI NtLockVirtualMemory(HANDLE ProcessHandle, PVOID* BaseAddress, PSIZE_T RegionSize, ULONG MapType) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtLockVirtualMemory), 0, 4, ProcessHandle, BaseAddress, RegionSize, MapType);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtLockVirtualMemory), (uint32_t)w32_NtLockVirtualMemory, 4, ProcessHandle, BaseAddress, RegionSize, MapType);
#endif
    }

    NTSTATUS WINAPI NtMakePermanentObject(HANDLE Handle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtMakePermanentObject), 0, 1, Handle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtMakePermanentObject), (uint32_t)w32_NtMakePermanentObject, 1, Handle);
#endif
    }

    NTSTATUS WINAPI NtMakeTemporaryObject(HANDLE Handle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtMakeTemporaryObject), 0, 1, Handle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtMakeTemporaryObject), (uint32_t)w32_NtMakeTemporaryObject, 1, Handle);
#endif
    }

    NTSTATUS WINAPI NtManagePartition(MEMORY_PARTITION_INFORMATION_CLASS PartitionInformationClass, PVOID PartitionInformation, ULONG PartitionInformationLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtManagePartition), 0, 3, PartitionInformationClass, PartitionInformation, PartitionInformationLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtManagePartition), (uint32_t)w32_NtManagePartition, 3, PartitionInformationClass, PartitionInformation, PartitionInformationLength);
#endif
    }

    NTSTATUS WINAPI NtMapCMFModule(ULONG What, ULONG Index, PULONG CacheIndexOut, PULONG CacheFlagsOut, PULONG ViewSizeOut, PVOID* BaseAddress) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtMapCMFModule), 0, 6, What, Index, CacheIndexOut, CacheFlagsOut, ViewSizeOut, BaseAddress);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtMapCMFModule), (uint32_t)w32_NtMapCMFModule, 6, What, Index, CacheIndexOut, CacheFlagsOut, ViewSizeOut, BaseAddress);
#endif
    }

    NTSTATUS WINAPI NtMapUserPhysicalPages(PVOID VirtualAddress, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtMapUserPhysicalPages), 0, 3, VirtualAddress, NumberOfPages, UserPfnArray);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtMapUserPhysicalPages), (uint32_t)w32_NtMapUserPhysicalPages, 3, VirtualAddress, NumberOfPages, UserPfnArray);
#endif
    }

    NTSTATUS WINAPI NtMapUserPhysicalPagesScatter(PVOID* VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtMapUserPhysicalPagesScatter), 0, 3, VirtualAddresses, NumberOfPages, UserPfnArray);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtMapUserPhysicalPagesScatter), (uint32_t)w32_NtMapUserPhysicalPagesScatter, 3, VirtualAddresses, NumberOfPages, UserPfnArray);
#endif
    }

    NTSTATUS WINAPI NtMapViewOfSection(HANDLE SectionHandle, HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits, SIZE_T CommitSize, PLARGE_INTEGER SectionOffset, PSIZE_T ViewSize, SECTION_INHERIT InheritDisposition, ULONG AllocationType, ULONG Win32Protect) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtMapViewOfSection), 0, 10, SectionHandle, ProcessHandle, BaseAddress, ZeroBits, CommitSize, SectionOffset, ViewSize, InheritDisposition, AllocationType, Win32Protect);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtMapViewOfSection), (uint32_t)w32_NtMapViewOfSection, 10, SectionHandle, ProcessHandle, BaseAddress, ZeroBits, CommitSize, SectionOffset, ViewSize, InheritDisposition, AllocationType, Win32Protect);
#endif
    }

    NTSTATUS WINAPI NtMapViewOfSectionEx(HANDLE SectionHandle, HANDLE ProcessHandle, PVOID* BaseAddress, PLARGE_INTEGER SectionOffset, PSIZE_T ViewSize, ULONG AllocationType, ULONG Win32Protect, MEM_EXTENDED_PARAMETER* Parameters, ULONG ParameterCount) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtMapViewOfSectionEx), 0, 9, SectionHandle, ProcessHandle, BaseAddress, SectionOffset, ViewSize, AllocationType, Win32Protect, Parameters, ParameterCount);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtMapViewOfSectionEx), (uint32_t)w32_NtMapViewOfSectionEx, 9, SectionHandle, ProcessHandle, BaseAddress, SectionOffset, ViewSize, AllocationType, Win32Protect, Parameters, ParameterCount);
#endif
    }

    NTSTATUS WINAPI NtModifyBootEntry(PBOOT_ENTRY BootEntry) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtModifyBootEntry), 0, 1, BootEntry);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtModifyBootEntry), (uint32_t)w32_NtModifyBootEntry, 1, BootEntry);
#endif
    }

    NTSTATUS WINAPI NtModifyDriverEntry(PEFI_DRIVER_ENTRY DriverEntry) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtModifyDriverEntry), 0, 1, DriverEntry);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtModifyDriverEntry), (uint32_t)w32_NtModifyDriverEntry, 1, DriverEntry);
#endif
    }

    NTSTATUS WINAPI NtNotifyChangeDirectoryFile(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, ULONG CompletionFilter, BOOLEAN WatchTree) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtNotifyChangeDirectoryFile), 0, 9, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, Buffer, Length, CompletionFilter, WatchTree);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtNotifyChangeDirectoryFile), (uint32_t)w32_NtNotifyChangeDirectoryFile, 9, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, Buffer, Length, CompletionFilter, WatchTree);
#endif
    }

    NTSTATUS WINAPI NtNotifyChangeDirectoryFileEx(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, ULONG CompletionFilter, BOOLEAN WatchTree, DIRECTORY_NOTIFY_INFORMATION_CLASS DirectoryNotifyInformationClass) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtNotifyChangeDirectoryFileEx), 0, 10, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, Buffer, Length, CompletionFilter, WatchTree, DirectoryNotifyInformationClass);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtNotifyChangeDirectoryFileEx), (uint32_t)w32_NtNotifyChangeDirectoryFileEx, 10, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, Buffer, Length, CompletionFilter, WatchTree, DirectoryNotifyInformationClass);
#endif
    }

    NTSTATUS WINAPI NtNotifyChangeKey(HANDLE KeyHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG CompletionFilter, BOOLEAN WatchTree, PVOID Buffer, ULONG BufferSize, BOOLEAN Asynchronous) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtNotifyChangeKey), 0, 10, KeyHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, CompletionFilter, WatchTree, Buffer, BufferSize, Asynchronous);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtNotifyChangeKey), (uint32_t)w32_NtNotifyChangeKey, 10, KeyHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, CompletionFilter, WatchTree, Buffer, BufferSize, Asynchronous);
#endif
    }

    NTSTATUS WINAPI NtNotifyChangeMultipleKeys(HANDLE MasterKeyHandle, ULONG Count, OBJECT_ATTRIBUTES* SubordinateObjects, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG CompletionFilter, BOOLEAN WatchTree, PVOID Buffer, ULONG BufferSize, BOOLEAN Asynchronous) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtNotifyChangeMultipleKeys), 0, 12, MasterKeyHandle, Count, SubordinateObjects, Event, ApcRoutine, ApcContext, IoStatusBlock, CompletionFilter, WatchTree, Buffer, BufferSize, Asynchronous);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtNotifyChangeMultipleKeys), (uint32_t)w32_NtNotifyChangeMultipleKeys, 12, MasterKeyHandle, Count, SubordinateObjects, Event, ApcRoutine, ApcContext, IoStatusBlock, CompletionFilter, WatchTree, Buffer, BufferSize, Asynchronous);
#endif
    }

    NTSTATUS WINAPI NtNotifyChangeSession(HANDLE SessionHandle, ULONG ChangeSequenceNumber, PLARGE_INTEGER ChangeTimeStamp, IO_SESSION_EVENT Event, IO_SESSION_STATE NewState, IO_SESSION_STATE PreviousState, PVOID Payload, ULONG PayloadSize) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtNotifyChangeSession), 0, 8, SessionHandle, ChangeSequenceNumber, ChangeTimeStamp, Event, NewState, PreviousState, Payload, PayloadSize);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtNotifyChangeSession), (uint32_t)w32_NtNotifyChangeSession, 8, SessionHandle, ChangeSequenceNumber, ChangeTimeStamp, Event, NewState, PreviousState, Payload, PayloadSize);
#endif
    }

    NTSTATUS WINAPI NtOpenDirectoryObject(PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenDirectoryObject), 0, 3, DirectoryHandle, DesiredAccess, ObjectAttributes);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenDirectoryObject), (uint32_t)w32_NtOpenDirectoryObject, 3, DirectoryHandle, DesiredAccess, ObjectAttributes);
#endif
    }

    NTSTATUS WINAPI NtOpenEnlistment(PHANDLE EnlistmentHandle, ACCESS_MASK DesiredAccess, HANDLE ResourceManagerHandle, LPGUID EnlistmentGuid, POBJECT_ATTRIBUTES ObjectAttributes) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenEnlistment), 0, 5, EnlistmentHandle, DesiredAccess, ResourceManagerHandle, EnlistmentGuid, ObjectAttributes);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenEnlistment), (uint32_t)w32_NtOpenEnlistment, 5, EnlistmentHandle, DesiredAccess, ResourceManagerHandle, EnlistmentGuid, ObjectAttributes);
#endif
    }

    NTSTATUS WINAPI NtOpenEvent(PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenEvent), 0, 3, EventHandle, DesiredAccess, ObjectAttributes);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenEvent), (uint32_t)w32_NtOpenEvent, 3, EventHandle, DesiredAccess, ObjectAttributes);
#endif
    }

    NTSTATUS WINAPI NtOpenEventPair(PHANDLE EventPairHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenEventPair), 0, 3, EventPairHandle, DesiredAccess, ObjectAttributes);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenEventPair), (uint32_t)w32_NtOpenEventPair, 3, EventPairHandle, DesiredAccess, ObjectAttributes);
#endif
    }

    NTSTATUS WINAPI NtOpenFile(PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG OpenOptions) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenFile), 0, 6, FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, ShareAccess, OpenOptions);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenFile), (uint32_t)w32_NtOpenFile, 6, FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, ShareAccess, OpenOptions);
#endif
    }

    NTSTATUS WINAPI NtOpenIoCompletion(PHANDLE IoCompletionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenIoCompletion), 0, 3, IoCompletionHandle, DesiredAccess, ObjectAttributes);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenIoCompletion), (uint32_t)w32_NtOpenIoCompletion, 3, IoCompletionHandle, DesiredAccess, ObjectAttributes);
#endif
    }

    NTSTATUS WINAPI NtOpenJobObject(PHANDLE JobHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenJobObject), 0, 3, JobHandle, DesiredAccess, ObjectAttributes);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenJobObject), (uint32_t)w32_NtOpenJobObject, 3, JobHandle, DesiredAccess, ObjectAttributes);
#endif
    }

    NTSTATUS WINAPI NtOpenKey(PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenKey), 0, 3, KeyHandle, DesiredAccess, ObjectAttributes);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenKey), (uint32_t)w32_NtOpenKey, 3, KeyHandle, DesiredAccess, ObjectAttributes);
#endif
    }

    NTSTATUS WINAPI NtOpenKeyEx(PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG OpenOptions) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenKeyEx), 0, 4, KeyHandle, DesiredAccess, ObjectAttributes, OpenOptions);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenKeyEx), (uint32_t)w32_NtOpenKeyEx, 4, KeyHandle, DesiredAccess, ObjectAttributes, OpenOptions);
#endif
    }

    NTSTATUS WINAPI NtOpenKeyTransacted(PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE TransactionHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenKeyTransacted), 0, 4, KeyHandle, DesiredAccess, ObjectAttributes, TransactionHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenKeyTransacted), (uint32_t)w32_NtOpenKeyTransacted, 4, KeyHandle, DesiredAccess, ObjectAttributes, TransactionHandle);
#endif
    }

    NTSTATUS WINAPI NtOpenKeyTransactedEx(PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG OpenOptions, HANDLE TransactionHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenKeyTransactedEx), 0, 5, KeyHandle, DesiredAccess, ObjectAttributes, OpenOptions, TransactionHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenKeyTransactedEx), (uint32_t)w32_NtOpenKeyTransactedEx, 5, KeyHandle, DesiredAccess, ObjectAttributes, OpenOptions, TransactionHandle);
#endif
    }

    NTSTATUS WINAPI NtOpenKeyedEvent(PHANDLE KeyedEventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenKeyedEvent), 0, 3, KeyedEventHandle, DesiredAccess, ObjectAttributes);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenKeyedEvent), (uint32_t)w32_NtOpenKeyedEvent, 3, KeyedEventHandle, DesiredAccess, ObjectAttributes);
#endif
    }

    NTSTATUS WINAPI NtOpenMutant(PHANDLE MutantHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenMutant), 0, 3, MutantHandle, DesiredAccess, ObjectAttributes);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenMutant), (uint32_t)w32_NtOpenMutant, 3, MutantHandle, DesiredAccess, ObjectAttributes);
#endif
    }

    NTSTATUS WINAPI NtOpenObjectAuditAlarm(PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, HANDLE ClientToken, ACCESS_MASK DesiredAccess, ACCESS_MASK GrantedAccess, PPRIVILEGE_SET Privileges, BOOLEAN ObjectCreation, BOOLEAN AccessGranted, PBOOLEAN GenerateOnClose) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenObjectAuditAlarm), 0, 12, SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, ClientToken, DesiredAccess, GrantedAccess, Privileges, ObjectCreation, AccessGranted, GenerateOnClose);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenObjectAuditAlarm), (uint32_t)w32_NtOpenObjectAuditAlarm, 12, SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, ClientToken, DesiredAccess, GrantedAccess, Privileges, ObjectCreation, AccessGranted, GenerateOnClose);
#endif
    }

    NTSTATUS WINAPI NtOpenPartition(PHANDLE PartitionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenPartition), 0, 3, PartitionHandle, DesiredAccess, ObjectAttributes);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenPartition), (uint32_t)w32_NtOpenPartition, 3, PartitionHandle, DesiredAccess, ObjectAttributes);
#endif
    }

    NTSTATUS WINAPI NtOpenPrivateNamespace(PHANDLE NamespaceHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PVOID BoundaryDescriptor) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenPrivateNamespace), 0, 4, NamespaceHandle, DesiredAccess, ObjectAttributes, BoundaryDescriptor);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenPrivateNamespace), (uint32_t)w32_NtOpenPrivateNamespace, 4, NamespaceHandle, DesiredAccess, ObjectAttributes, BoundaryDescriptor);
#endif
    }

    NTSTATUS WINAPI NtOpenProcess(PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenProcess), 0, 4, ProcessHandle, DesiredAccess, ObjectAttributes, ClientId);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenProcess), (uint32_t)w32_NtOpenProcess, 4, ProcessHandle, DesiredAccess, ObjectAttributes, ClientId);
#endif
    }

    NTSTATUS WINAPI NtOpenProcessToken(HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, PHANDLE TokenHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenProcessToken), 0, 3, ProcessHandle, DesiredAccess, TokenHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenProcessToken), (uint32_t)w32_NtOpenProcessToken, 3, ProcessHandle, DesiredAccess, TokenHandle);
#endif
    }

    NTSTATUS WINAPI NtOpenProcessTokenEx(HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, PHANDLE TokenHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenProcessTokenEx), 0, 4, ProcessHandle, DesiredAccess, HandleAttributes, TokenHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenProcessTokenEx), (uint32_t)w32_NtOpenProcessTokenEx, 4, ProcessHandle, DesiredAccess, HandleAttributes, TokenHandle);
#endif
    }

    NTSTATUS WINAPI NtOpenResourceManager(PHANDLE ResourceManagerHandle, ACCESS_MASK DesiredAccess, HANDLE TmHandle, LPGUID ResourceManagerGuid, POBJECT_ATTRIBUTES ObjectAttributes) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenResourceManager), 0, 5, ResourceManagerHandle, DesiredAccess, TmHandle, ResourceManagerGuid, ObjectAttributes);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenResourceManager), (uint32_t)w32_NtOpenResourceManager, 5, ResourceManagerHandle, DesiredAccess, TmHandle, ResourceManagerGuid, ObjectAttributes);
#endif
    }

    NTSTATUS WINAPI NtOpenSection(PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenSection), 0, 3, SectionHandle, DesiredAccess, ObjectAttributes);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenSection), (uint32_t)w32_NtOpenSection, 3, SectionHandle, DesiredAccess, ObjectAttributes);
#endif
    }

    NTSTATUS WINAPI NtOpenSemaphore(PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenSemaphore), 0, 3, SemaphoreHandle, DesiredAccess, ObjectAttributes);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenSemaphore), (uint32_t)w32_NtOpenSemaphore, 3, SemaphoreHandle, DesiredAccess, ObjectAttributes);
#endif
    }

    NTSTATUS WINAPI NtOpenSession(PHANDLE SessionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenSession), 0, 3, SessionHandle, DesiredAccess, ObjectAttributes);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenSession), (uint32_t)w32_NtOpenSession, 3, SessionHandle, DesiredAccess, ObjectAttributes);
#endif
    }

    NTSTATUS WINAPI NtOpenSymbolicLinkObject(PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenSymbolicLinkObject), 0, 3, LinkHandle, DesiredAccess, ObjectAttributes);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenSymbolicLinkObject), (uint32_t)w32_NtOpenSymbolicLinkObject, 3, LinkHandle, DesiredAccess, ObjectAttributes);
#endif
    }

    NTSTATUS WINAPI NtOpenThread(PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenThread), 0, 4, ThreadHandle, DesiredAccess, ObjectAttributes, ClientId);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenThread), (uint32_t)w32_NtOpenThread, 4, ThreadHandle, DesiredAccess, ObjectAttributes, ClientId);
#endif
    }

    NTSTATUS WINAPI NtOpenThreadToken(HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, PHANDLE TokenHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenThreadToken), 0, 4, ThreadHandle, DesiredAccess, OpenAsSelf, TokenHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenThreadToken), (uint32_t)w32_NtOpenThreadToken, 4, ThreadHandle, DesiredAccess, OpenAsSelf, TokenHandle);
#endif
    }

    NTSTATUS WINAPI NtOpenThreadTokenEx(HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, ULONG HandleAttributes, PHANDLE TokenHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenThreadTokenEx), 0, 5, ThreadHandle, DesiredAccess, OpenAsSelf, HandleAttributes, TokenHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenThreadTokenEx), (uint32_t)w32_NtOpenThreadTokenEx, 5, ThreadHandle, DesiredAccess, OpenAsSelf, HandleAttributes, TokenHandle);
#endif
    }

    NTSTATUS WINAPI NtOpenTimer(PHANDLE TimerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenTimer), 0, 3, TimerHandle, DesiredAccess, ObjectAttributes);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenTimer), (uint32_t)w32_NtOpenTimer, 3, TimerHandle, DesiredAccess, ObjectAttributes);
#endif
    }

    NTSTATUS WINAPI NtOpenTransaction(PHANDLE TransactionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LPGUID Uow, HANDLE TmHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenTransaction), 0, 5, TransactionHandle, DesiredAccess, ObjectAttributes, Uow, TmHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenTransaction), (uint32_t)w32_NtOpenTransaction, 5, TransactionHandle, DesiredAccess, ObjectAttributes, Uow, TmHandle);
#endif
    }

    NTSTATUS WINAPI NtOpenTransactionManager(PHANDLE TmHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LogFileName, LPGUID TmIdentity, ULONG OpenOptions) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenTransactionManager), 0, 6, TmHandle, DesiredAccess, ObjectAttributes, LogFileName, TmIdentity, OpenOptions);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtOpenTransactionManager), (uint32_t)w32_NtOpenTransactionManager, 6, TmHandle, DesiredAccess, ObjectAttributes, LogFileName, TmIdentity, OpenOptions);
#endif
    }

    NTSTATUS WINAPI NtPlugPlayControl(PLUGPLAY_CONTROL_CLASS PnPControlClass, PVOID PnPControlData, ULONG PnPControlDataLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtPlugPlayControl), 0, 3, PnPControlClass, PnPControlData, PnPControlDataLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtPlugPlayControl), (uint32_t)w32_NtPlugPlayControl, 3, PnPControlClass, PnPControlData, PnPControlDataLength);
#endif
    }

    NTSTATUS WINAPI NtPowerInformation(POWER_INFORMATION_LEVEL InformationLevel, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtPowerInformation), 0, 5, InformationLevel, InputBuffer, InputBufferLength, OutputBuffer, OutputBufferLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtPowerInformation), (uint32_t)w32_NtPowerInformation, 5, InformationLevel, InputBuffer, InputBufferLength, OutputBuffer, OutputBufferLength);
#endif
    }

    NTSTATUS WINAPI NtPrePrepareComplete(HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtPrePrepareComplete), 0, 2, EnlistmentHandle, TmVirtualClock);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtPrePrepareComplete), (uint32_t)w32_NtPrePrepareComplete, 2, EnlistmentHandle, TmVirtualClock);
#endif
    }

    NTSTATUS WINAPI NtPrePrepareEnlistment(HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtPrePrepareEnlistment), 0, 2, EnlistmentHandle, TmVirtualClock);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtPrePrepareEnlistment), (uint32_t)w32_NtPrePrepareEnlistment, 2, EnlistmentHandle, TmVirtualClock);
#endif
    }

    NTSTATUS WINAPI NtPrepareComplete(HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtPrepareComplete), 0, 2, EnlistmentHandle, TmVirtualClock);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtPrepareComplete), (uint32_t)w32_NtPrepareComplete, 2, EnlistmentHandle, TmVirtualClock);
#endif
    }

    NTSTATUS WINAPI NtPrepareEnlistment(HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtPrepareEnlistment), 0, 2, EnlistmentHandle, TmVirtualClock);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtPrepareEnlistment), (uint32_t)w32_NtPrepareEnlistment, 2, EnlistmentHandle, TmVirtualClock);
#endif
    }

    NTSTATUS WINAPI NtPrivilegeCheck(HANDLE ClientToken, PPRIVILEGE_SET RequiredPrivileges, PBOOLEAN Result) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtPrivilegeCheck), 0, 3, ClientToken, RequiredPrivileges, Result);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtPrivilegeCheck), (uint32_t)w32_NtPrivilegeCheck, 3, ClientToken, RequiredPrivileges, Result);
#endif
    }

    NTSTATUS WINAPI NtPrivilegeObjectAuditAlarm(PUNICODE_STRING SubsystemName, PVOID HandleId, HANDLE ClientToken, ACCESS_MASK DesiredAccess, PPRIVILEGE_SET Privileges, BOOLEAN AccessGranted) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtPrivilegeObjectAuditAlarm), 0, 6, SubsystemName, HandleId, ClientToken, DesiredAccess, Privileges, AccessGranted);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtPrivilegeObjectAuditAlarm), (uint32_t)w32_NtPrivilegeObjectAuditAlarm, 6, SubsystemName, HandleId, ClientToken, DesiredAccess, Privileges, AccessGranted);
#endif
    }

    NTSTATUS WINAPI NtPrivilegedServiceAuditAlarm(PUNICODE_STRING SubsystemName, PUNICODE_STRING ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOLEAN AccessGranted) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtPrivilegedServiceAuditAlarm), 0, 5, SubsystemName, ServiceName, ClientToken, Privileges, AccessGranted);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtPrivilegedServiceAuditAlarm), (uint32_t)w32_NtPrivilegedServiceAuditAlarm, 5, SubsystemName, ServiceName, ClientToken, Privileges, AccessGranted);
#endif
    }

    NTSTATUS WINAPI NtPropagationComplete(HANDLE ResourceManagerHandle, ULONG RequestCookie, ULONG BufferLength, PVOID Buffer) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtPropagationComplete), 0, 4, ResourceManagerHandle, RequestCookie, BufferLength, Buffer);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtPropagationComplete), (uint32_t)w32_NtPropagationComplete, 4, ResourceManagerHandle, RequestCookie, BufferLength, Buffer);
#endif
    }

    NTSTATUS WINAPI NtPropagationFailed(HANDLE ResourceManagerHandle, ULONG RequestCookie, NTSTATUS PropStatus) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtPropagationFailed), 0, 3, ResourceManagerHandle, RequestCookie, PropStatus);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtPropagationFailed), (uint32_t)w32_NtPropagationFailed, 3, ResourceManagerHandle, RequestCookie, PropStatus);
#endif
    }

    NTSTATUS WINAPI NtProtectVirtualMemory(HANDLE ProcessHandle, PVOID* BaseAddress, PSIZE_T RegionSize, ULONG NewProtect, PULONG OldProtect) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtProtectVirtualMemory), 0, 5, ProcessHandle, BaseAddress, RegionSize, NewProtect, OldProtect);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtProtectVirtualMemory), (uint32_t)w32_NtProtectVirtualMemory, 5, ProcessHandle, BaseAddress, RegionSize, NewProtect, OldProtect);
#endif
    }

    NTSTATUS WINAPI NtPulseEvent(HANDLE EventHandle, PLONG PreviousState) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtPulseEvent), 0, 2, EventHandle, PreviousState);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtPulseEvent), (uint32_t)w32_NtPulseEvent, 2, EventHandle, PreviousState);
#endif
    }

    NTSTATUS WINAPI NtQueryAttributesFile(POBJECT_ATTRIBUTES ObjectAttributes, PFILE_BASIC_INFORMATION FileInformation) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryAttributesFile), 0, 2, ObjectAttributes, FileInformation);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryAttributesFile), (uint32_t)w32_NtQueryAttributesFile, 2, ObjectAttributes, FileInformation);
#endif
    }

    NTSTATUS WINAPI NtQueryBootEntryOrder(PULONG Ids, PULONG Count) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryBootEntryOrder), 0, 2, Ids, Count);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryBootEntryOrder), (uint32_t)w32_NtQueryBootEntryOrder, 2, Ids, Count);
#endif
    }

    NTSTATUS WINAPI NtQueryBootOptions(PBOOT_OPTIONS BootOptions, PULONG BootOptionsLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryBootOptions), 0, 2, BootOptions, BootOptionsLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryBootOptions), (uint32_t)w32_NtQueryBootOptions, 2, BootOptions, BootOptionsLength);
#endif
    }

    NTSTATUS WINAPI NtQueryDebugFilterState(ULONG ComponentId, ULONG Level) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryDebugFilterState), 0, 2, ComponentId, Level);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryDebugFilterState), (uint32_t)w32_NtQueryDebugFilterState, 2, ComponentId, Level);
#endif
    }

    NTSTATUS WINAPI NtQueryDefaultLocale(BOOLEAN UserProfile, PLCID DefaultLocaleId) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryDefaultLocale), 0, 2, UserProfile, DefaultLocaleId);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryDefaultLocale), (uint32_t)w32_NtQueryDefaultLocale, 2, UserProfile, DefaultLocaleId);
#endif
    }

    NTSTATUS WINAPI NtQueryDefaultUILanguage(LANGID* DefaultUILanguageId) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryDefaultUILanguage), 0, 1, DefaultUILanguageId);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryDefaultUILanguage), (uint32_t)w32_NtQueryDefaultUILanguage, 1, DefaultUILanguageId);
#endif
    }

    NTSTATUS WINAPI NtQueryDirectoryFile(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass, BOOLEAN ReturnSingleEntry, PUNICODE_STRING FileName, BOOLEAN RestartScan) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryDirectoryFile), 0, 11, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, FileInformation, Length, FileInformationClass, ReturnSingleEntry, FileName, RestartScan);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryDirectoryFile), (uint32_t)w32_NtQueryDirectoryFile, 11, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, FileInformation, Length, FileInformationClass, ReturnSingleEntry, FileName, RestartScan);
#endif
    }

    NTSTATUS WINAPI NtQueryDirectoryFileEx(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass, ULONG QueryFlags, PUNICODE_STRING FileName) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryDirectoryFileEx), 0, 10, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, FileInformation, Length, FileInformationClass, QueryFlags, FileName);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryDirectoryFileEx), (uint32_t)w32_NtQueryDirectoryFileEx, 10, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, FileInformation, Length, FileInformationClass, QueryFlags, FileName);
#endif
    }

    NTSTATUS WINAPI NtQueryDirectoryObject(HANDLE DirectoryHandle, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, BOOLEAN RestartScan, PULONG Context, PULONG ReturnLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryDirectoryObject), 0, 7, DirectoryHandle, Buffer, Length, ReturnSingleEntry, RestartScan, Context, ReturnLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryDirectoryObject), (uint32_t)w32_NtQueryDirectoryObject, 7, DirectoryHandle, Buffer, Length, ReturnSingleEntry, RestartScan, Context, ReturnLength);
#endif
    }

    NTSTATUS WINAPI NtQueryDriverEntryOrder(PULONG Ids, PULONG Count) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryDriverEntryOrder), 0, 2, Ids, Count);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryDriverEntryOrder), (uint32_t)w32_NtQueryDriverEntryOrder, 2, Ids, Count);
#endif
    }

    NTSTATUS WINAPI NtQueryEaFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, PVOID EaList, ULONG EaListLength, PULONG EaIndex, BOOLEAN RestartScan) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryEaFile), 0, 9, FileHandle, IoStatusBlock, Buffer, Length, ReturnSingleEntry, EaList, EaListLength, EaIndex, RestartScan);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryEaFile), (uint32_t)w32_NtQueryEaFile, 9, FileHandle, IoStatusBlock, Buffer, Length, ReturnSingleEntry, EaList, EaListLength, EaIndex, RestartScan);
#endif
    }

    NTSTATUS WINAPI NtQueryEvent(HANDLE EventHandle, EVENT_INFORMATION_CLASS EventInformationClass, PVOID EventInformation, ULONG EventInformationLength, PULONG ReturnLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryEvent), 0, 5, EventHandle, EventInformationClass, EventInformation, EventInformationLength, ReturnLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryEvent), (uint32_t)w32_NtQueryEvent, 5, EventHandle, EventInformationClass, EventInformation, EventInformationLength, ReturnLength);
#endif
    }

    NTSTATUS WINAPI NtQueryFullAttributesFile(POBJECT_ATTRIBUTES ObjectAttributes, PFILE_NETWORK_OPEN_INFORMATION FileInformation) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryFullAttributesFile), 0, 2, ObjectAttributes, FileInformation);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryFullAttributesFile), (uint32_t)w32_NtQueryFullAttributesFile, 2, ObjectAttributes, FileInformation);
#endif
    }

    NTSTATUS WINAPI NtQueryInformationAtom(RTL_ATOM Atom, ATOM_INFORMATION_CLASS AtomInformationClass, PVOID AtomInformation, ULONG AtomInformationLength, PULONG ReturnLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryInformationAtom), 0, 5, Atom, AtomInformationClass, AtomInformation, AtomInformationLength, ReturnLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryInformationAtom), (uint32_t)w32_NtQueryInformationAtom, 5, Atom, AtomInformationClass, AtomInformation, AtomInformationLength, ReturnLength);
#endif
    }

    NTSTATUS WINAPI NtQueryInformationByName(POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryInformationByName), 0, 5, ObjectAttributes, IoStatusBlock, FileInformation, Length, FileInformationClass);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryInformationByName), (uint32_t)w32_NtQueryInformationByName, 5, ObjectAttributes, IoStatusBlock, FileInformation, Length, FileInformationClass);
#endif
    }

    NTSTATUS WINAPI NtQueryInformationEnlistment(HANDLE EnlistmentHandle, ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass, PVOID EnlistmentInformation, ULONG EnlistmentInformationLength, PULONG ReturnLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryInformationEnlistment), 0, 5, EnlistmentHandle, EnlistmentInformationClass, EnlistmentInformation, EnlistmentInformationLength, ReturnLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryInformationEnlistment), (uint32_t)w32_NtQueryInformationEnlistment, 5, EnlistmentHandle, EnlistmentInformationClass, EnlistmentInformation, EnlistmentInformationLength, ReturnLength);
#endif
    }

    NTSTATUS WINAPI NtQueryInformationFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryInformationFile), 0, 5, FileHandle, IoStatusBlock, FileInformation, Length, FileInformationClass);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryInformationFile), (uint32_t)w32_NtQueryInformationFile, 5, FileHandle, IoStatusBlock, FileInformation, Length, FileInformationClass);
#endif
    }

    NTSTATUS WINAPI NtQueryInformationJobObject(HANDLE JobHandle, JOBOBJECTINFOCLASS JobObjectInformationClass, PVOID JobObjectInformation, ULONG JobObjectInformationLength, PULONG ReturnLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryInformationJobObject), 0, 5, JobHandle, JobObjectInformationClass, JobObjectInformation, JobObjectInformationLength, ReturnLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryInformationJobObject), (uint32_t)w32_NtQueryInformationJobObject, 5, JobHandle, JobObjectInformationClass, JobObjectInformation, JobObjectInformationLength, ReturnLength);
#endif
    }

    NTSTATUS WINAPI NtQueryInformationPort(HANDLE PortHandle, PORT_INFORMATION_CLASS PortInformationClass, PVOID PortInformation, ULONG Length, PULONG ReturnLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryInformationPort), 0, 5, PortHandle, PortInformationClass, PortInformation, Length, ReturnLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryInformationPort), (uint32_t)w32_NtQueryInformationPort, 5, PortHandle, PortInformationClass, PortInformation, Length, ReturnLength);
#endif
    }

    NTSTATUS WINAPI NtQueryInformationProcess(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryInformationProcess), 0, 5, ProcessHandle, ProcessInformationClass, ProcessInformation, ProcessInformationLength, ReturnLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryInformationProcess), (uint32_t)w32_NtQueryInformationProcess, 5, ProcessHandle, ProcessInformationClass, ProcessInformation, ProcessInformationLength, ReturnLength);
#endif
    }

    NTSTATUS WINAPI NtQueryInformationResourceManager(HANDLE ResourceManagerHandle, RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass, PVOID ResourceManagerInformation, ULONG ResourceManagerInformationLength, PULONG ReturnLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryInformationResourceManager), 0, 5, ResourceManagerHandle, ResourceManagerInformationClass, ResourceManagerInformation, ResourceManagerInformationLength, ReturnLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryInformationResourceManager), (uint32_t)w32_NtQueryInformationResourceManager, 5, ResourceManagerHandle, ResourceManagerInformationClass, ResourceManagerInformation, ResourceManagerInformationLength, ReturnLength);
#endif
    }

    NTSTATUS WINAPI NtQueryInformationThread(HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength, PULONG ReturnLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryInformationThread), 0, 5, ThreadHandle, ThreadInformationClass, ThreadInformation, ThreadInformationLength, ReturnLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryInformationThread), (uint32_t)w32_NtQueryInformationThread, 5, ThreadHandle, ThreadInformationClass, ThreadInformation, ThreadInformationLength, ReturnLength);
#endif
    }

    NTSTATUS WINAPI NtQueryInformationToken(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, PVOID TokenInformation, ULONG TokenInformationLength, PULONG ReturnLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryInformationToken), 0, 5, TokenHandle, TokenInformationClass, TokenInformation, TokenInformationLength, ReturnLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryInformationToken), (uint32_t)w32_NtQueryInformationToken, 5, TokenHandle, TokenInformationClass, TokenInformation, TokenInformationLength, ReturnLength);
#endif
    }

    NTSTATUS WINAPI NtQueryInformationTransaction(HANDLE TransactionHandle, TRANSACTION_INFORMATION_CLASS TransactionInformationClass, PVOID TransactionInformation, ULONG TransactionInformationLength, PULONG ReturnLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryInformationTransaction), 0, 5, TransactionHandle, TransactionInformationClass, TransactionInformation, TransactionInformationLength, ReturnLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryInformationTransaction), (uint32_t)w32_NtQueryInformationTransaction, 5, TransactionHandle, TransactionInformationClass, TransactionInformation, TransactionInformationLength, ReturnLength);
#endif
    }

    NTSTATUS WINAPI NtQueryInformationTransactionManager(HANDLE TransactionManagerHandle, TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass, PVOID TransactionManagerInformation, ULONG TransactionManagerInformationLength, PULONG ReturnLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryInformationTransactionManager), 0, 5, TransactionManagerHandle, TransactionManagerInformationClass, TransactionManagerInformation, TransactionManagerInformationLength, ReturnLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryInformationTransactionManager), (uint32_t)w32_NtQueryInformationTransactionManager, 5, TransactionManagerHandle, TransactionManagerInformationClass, TransactionManagerInformation, TransactionManagerInformationLength, ReturnLength);
#endif
    }

    NTSTATUS WINAPI NtQueryInformationWorkerFactory(HANDLE WorkerFactoryHandle, WORKERFACTORYINFOCLASS WorkerFactoryInformationClass, PVOID WorkerFactoryInformation, ULONG WorkerFactoryInformationLength, PULONG ReturnLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryInformationWorkerFactory), 0, 5, WorkerFactoryHandle, WorkerFactoryInformationClass, WorkerFactoryInformation, WorkerFactoryInformationLength, ReturnLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryInformationWorkerFactory), (uint32_t)w32_NtQueryInformationWorkerFactory, 5, WorkerFactoryHandle, WorkerFactoryInformationClass, WorkerFactoryInformation, WorkerFactoryInformationLength, ReturnLength);
#endif
    }

    NTSTATUS WINAPI NtQueryInstallUILanguage(LANGID* InstallUILanguageId) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryInstallUILanguage), 0, 1, InstallUILanguageId);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryInstallUILanguage), (uint32_t)w32_NtQueryInstallUILanguage, 1, InstallUILanguageId);
#endif
    }

    NTSTATUS WINAPI NtQueryIntervalProfile(KPROFILE_SOURCE ProfileSource, PULONG Interval) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryIntervalProfile), 0, 2, ProfileSource, Interval);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryIntervalProfile), (uint32_t)w32_NtQueryIntervalProfile, 2, ProfileSource, Interval);
#endif
    }

    NTSTATUS WINAPI NtQueryIoCompletion(HANDLE IoCompletionHandle, IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass, PVOID IoCompletionInformation, ULONG IoCompletionInformationLength, PULONG ReturnLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryIoCompletion), 0, 5, IoCompletionHandle, IoCompletionInformationClass, IoCompletionInformation, IoCompletionInformationLength, ReturnLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryIoCompletion), (uint32_t)w32_NtQueryIoCompletion, 5, IoCompletionHandle, IoCompletionInformationClass, IoCompletionInformation, IoCompletionInformationLength, ReturnLength);
#endif
    }

    NTSTATUS WINAPI NtQueryKey(HANDLE KeyHandle, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryKey), 0, 5, KeyHandle, KeyInformationClass, KeyInformation, Length, ResultLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryKey), (uint32_t)w32_NtQueryKey, 5, KeyHandle, KeyInformationClass, KeyInformation, Length, ResultLength);
#endif
    }

    NTSTATUS WINAPI NtQueryLicenseValue(PUNICODE_STRING ValueName, PULONG Type, PVOID Data, ULONG DataSize, PULONG ResultDataSize) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryLicenseValue), 0, 5, ValueName, Type, Data, DataSize, ResultDataSize);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryLicenseValue), (uint32_t)w32_NtQueryLicenseValue, 5, ValueName, Type, Data, DataSize, ResultDataSize);
#endif
    }

    NTSTATUS WINAPI NtQueryMultipleValueKey(HANDLE KeyHandle, PKEY_VALUE_ENTRY ValueEntries, ULONG EntryCount, PVOID ValueBuffer, PULONG BufferLength, PULONG RequiredBufferLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryMultipleValueKey), 0, 6, KeyHandle, ValueEntries, EntryCount, ValueBuffer, BufferLength, RequiredBufferLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryMultipleValueKey), (uint32_t)w32_NtQueryMultipleValueKey, 6, KeyHandle, ValueEntries, EntryCount, ValueBuffer, BufferLength, RequiredBufferLength);
#endif
    }

    NTSTATUS WINAPI NtQueryMutant(HANDLE MutantHandle, MUTANT_INFORMATION_CLASS MutantInformationClass, PVOID MutantInformation, ULONG MutantInformationLength, PULONG ReturnLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryMutant), 0, 5, MutantHandle, MutantInformationClass, MutantInformation, MutantInformationLength, ReturnLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryMutant), (uint32_t)w32_NtQueryMutant, 5, MutantHandle, MutantInformationClass, MutantInformation, MutantInformationLength, ReturnLength);
#endif
    }

    NTSTATUS WINAPI NtQueryObject(HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength, PULONG ReturnLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryObject), 0, 5, Handle, ObjectInformationClass, ObjectInformation, ObjectInformationLength, ReturnLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryObject), (uint32_t)w32_NtQueryObject, 5, Handle, ObjectInformationClass, ObjectInformation, ObjectInformationLength, ReturnLength);
#endif
    }

    NTSTATUS WINAPI NtQueryOpenSubKeys(POBJECT_ATTRIBUTES TargetKey, PULONG HandleCount) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryOpenSubKeys), 0, 2, TargetKey, HandleCount);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryOpenSubKeys), (uint32_t)w32_NtQueryOpenSubKeys, 2, TargetKey, HandleCount);
#endif
    }

    NTSTATUS WINAPI NtQueryOpenSubKeysEx(POBJECT_ATTRIBUTES TargetKey, ULONG BufferLength, PVOID Buffer, PULONG RequiredSize) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryOpenSubKeysEx), 0, 4, TargetKey, BufferLength, Buffer, RequiredSize);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryOpenSubKeysEx), (uint32_t)w32_NtQueryOpenSubKeysEx, 4, TargetKey, BufferLength, Buffer, RequiredSize);
#endif
    }

    NTSTATUS WINAPI NtQueryPerformanceCounter(PLARGE_INTEGER PerformanceCounter, PLARGE_INTEGER PerformanceFrequency) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryPerformanceCounter), 0, 2, PerformanceCounter, PerformanceFrequency);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryPerformanceCounter), (uint32_t)w32_NtQueryPerformanceCounter, 2, PerformanceCounter, PerformanceFrequency);
#endif
    }

    NTSTATUS WINAPI NtQueryPortInformationProcess() {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryPortInformationProcess), 0, 0);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryPortInformationProcess), (uint32_t)w32_NtQueryPortInformationProcess, 0);
#endif
    }

    NTSTATUS WINAPI NtQueryQuotaInformationFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, PVOID SidList, ULONG SidListLength, PSID StartSid, BOOLEAN RestartScan) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryQuotaInformationFile), 0, 9, FileHandle, IoStatusBlock, Buffer, Length, ReturnSingleEntry, SidList, SidListLength, StartSid, RestartScan);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryQuotaInformationFile), (uint32_t)w32_NtQueryQuotaInformationFile, 9, FileHandle, IoStatusBlock, Buffer, Length, ReturnSingleEntry, SidList, SidListLength, StartSid, RestartScan);
#endif
    }

    NTSTATUS WINAPI NtQuerySection(HANDLE SectionHandle, SECTION_INFORMATION_CLASS SectionInformationClass, PVOID SectionInformation, SIZE_T SectionInformationLength, PSIZE_T ReturnLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQuerySection), 0, 5, SectionHandle, SectionInformationClass, SectionInformation, SectionInformationLength, ReturnLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQuerySection), (uint32_t)w32_NtQuerySection, 5, SectionHandle, SectionInformationClass, SectionInformation, SectionInformationLength, ReturnLength);
#endif
    }

    NTSTATUS WINAPI NtQuerySecurityAttributesToken(HANDLE TokenHandle, PUNICODE_STRING Attributes, ULONG NumberOfAttributes, PVOID Buffer, ULONG Length, PULONG ReturnLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQuerySecurityAttributesToken), 0, 6, TokenHandle, Attributes, NumberOfAttributes, Buffer, Length, ReturnLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQuerySecurityAttributesToken), (uint32_t)w32_NtQuerySecurityAttributesToken, 6, TokenHandle, Attributes, NumberOfAttributes, Buffer, Length, ReturnLength);
#endif
    }

    NTSTATUS WINAPI NtQuerySecurityObject(HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor, ULONG Length, PULONG LengthNeeded) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQuerySecurityObject), 0, 5, Handle, SecurityInformation, SecurityDescriptor, Length, LengthNeeded);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQuerySecurityObject), (uint32_t)w32_NtQuerySecurityObject, 5, Handle, SecurityInformation, SecurityDescriptor, Length, LengthNeeded);
#endif
    }

    NTSTATUS WINAPI NtQuerySemaphore(HANDLE SemaphoreHandle, SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass, PVOID SemaphoreInformation, ULONG SemaphoreInformationLength, PULONG ReturnLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQuerySemaphore), 0, 5, SemaphoreHandle, SemaphoreInformationClass, SemaphoreInformation, SemaphoreInformationLength, ReturnLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQuerySemaphore), (uint32_t)w32_NtQuerySemaphore, 5, SemaphoreHandle, SemaphoreInformationClass, SemaphoreInformation, SemaphoreInformationLength, ReturnLength);
#endif
    }

    NTSTATUS WINAPI NtQuerySymbolicLinkObject(HANDLE LinkHandle, PUNICODE_STRING LinkTarget, PULONG ReturnedLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQuerySymbolicLinkObject), 0, 3, LinkHandle, LinkTarget, ReturnedLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQuerySymbolicLinkObject), (uint32_t)w32_NtQuerySymbolicLinkObject, 3, LinkHandle, LinkTarget, ReturnedLength);
#endif
    }

    NTSTATUS WINAPI NtQuerySystemEnvironmentValue(PUNICODE_STRING VariableName, PWSTR VariableValue, USHORT ValueLength, PUSHORT ReturnLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQuerySystemEnvironmentValue), 0, 4, VariableName, VariableValue, ValueLength, ReturnLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQuerySystemEnvironmentValue), (uint32_t)w32_NtQuerySystemEnvironmentValue, 4, VariableName, VariableValue, ValueLength, ReturnLength);
#endif
    }

    NTSTATUS WINAPI NtQuerySystemEnvironmentValueEx(PUNICODE_STRING VariableName, LPGUID VendorGuid, PVOID Value, PULONG ValueLength, PULONG Attributes) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQuerySystemEnvironmentValueEx), 0, 5, VariableName, VendorGuid, Value, ValueLength, Attributes);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQuerySystemEnvironmentValueEx), (uint32_t)w32_NtQuerySystemEnvironmentValueEx, 5, VariableName, VendorGuid, Value, ValueLength, Attributes);
#endif
    }

    NTSTATUS WINAPI NtQuerySystemInformation(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQuerySystemInformation), 0, 4, SystemInformationClass, SystemInformation, SystemInformationLength, ReturnLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQuerySystemInformation), (uint32_t)w32_NtQuerySystemInformation, 4, SystemInformationClass, SystemInformation, SystemInformationLength, ReturnLength);
#endif
    }

    NTSTATUS WINAPI NtQuerySystemInformationEx(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID InputBuffer, ULONG InputBufferLength, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQuerySystemInformationEx), 0, 6, SystemInformationClass, InputBuffer, InputBufferLength, SystemInformation, SystemInformationLength, ReturnLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQuerySystemInformationEx), (uint32_t)w32_NtQuerySystemInformationEx, 6, SystemInformationClass, InputBuffer, InputBufferLength, SystemInformation, SystemInformationLength, ReturnLength);
#endif
    }

    NTSTATUS WINAPI NtQueryTimer(HANDLE TimerHandle, TIMER_INFORMATION_CLASS TimerInformationClass, PVOID TimerInformation, ULONG TimerInformationLength, PULONG ReturnLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryTimer), 0, 5, TimerHandle, TimerInformationClass, TimerInformation, TimerInformationLength, ReturnLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryTimer), (uint32_t)w32_NtQueryTimer, 5, TimerHandle, TimerInformationClass, TimerInformation, TimerInformationLength, ReturnLength);
#endif
    }

    NTSTATUS WINAPI NtQueryTimerResolution(PULONG MaximumTime, PULONG MinimumTime, PULONG CurrentTime) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryTimerResolution), 0, 3, MaximumTime, MinimumTime, CurrentTime);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryTimerResolution), (uint32_t)w32_NtQueryTimerResolution, 3, MaximumTime, MinimumTime, CurrentTime);
#endif
    }

    NTSTATUS WINAPI NtQueryValueKey(HANDLE KeyHandle, PUNICODE_STRING ValueName, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryValueKey), 0, 6, KeyHandle, ValueName, KeyValueInformationClass, KeyValueInformation, Length, ResultLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryValueKey), (uint32_t)w32_NtQueryValueKey, 6, KeyHandle, ValueName, KeyValueInformationClass, KeyValueInformation, Length, ResultLength);
#endif
    }

    NTSTATUS WINAPI NtQueryVirtualMemory(HANDLE ProcessHandle, PVOID BaseAddress, MEMORY_INFORMATION_CLASS MemoryInformationClass, PVOID MemoryInformation, SIZE_T MemoryInformationLength, PSIZE_T ReturnLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryVirtualMemory), 0, 6, ProcessHandle, BaseAddress, MemoryInformationClass, MemoryInformation, MemoryInformationLength, ReturnLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryVirtualMemory), (uint32_t)w32_NtQueryVirtualMemory, 6, ProcessHandle, BaseAddress, MemoryInformationClass, MemoryInformation, MemoryInformationLength, ReturnLength);
#endif
    }

    NTSTATUS WINAPI NtQueryVolumeInformationFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FsInformation, ULONG Length, FSINFOCLASS FsInformationClass) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryVolumeInformationFile), 0, 5, FileHandle, IoStatusBlock, FsInformation, Length, FsInformationClass);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryVolumeInformationFile), (uint32_t)w32_NtQueryVolumeInformationFile, 5, FileHandle, IoStatusBlock, FsInformation, Length, FsInformationClass);
#endif
    }

    NTSTATUS WINAPI NtQueryWnfStateData(PCWNF_STATE_NAME StateName, PCWNF_TYPE_ID TypeId, void const* ExplicitScope, PWNF_CHANGE_STAMP ChangeStamp, PVOID Buffer, PULONG BufferSize) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryWnfStateData), 0, 6, StateName, TypeId, ExplicitScope, ChangeStamp, Buffer, BufferSize);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryWnfStateData), (uint32_t)w32_NtQueryWnfStateData, 6, StateName, TypeId, ExplicitScope, ChangeStamp, Buffer, BufferSize);
#endif
    }

    NTSTATUS WINAPI NtQueryWnfStateNameInformation(PCWNF_STATE_NAME StateName, WNF_STATE_NAME_INFORMATION NameInfoClass, void const* ExplicitScope, PVOID InfoBuffer, ULONG InfoBufferSize) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryWnfStateNameInformation), 0, 5, StateName, NameInfoClass, ExplicitScope, InfoBuffer, InfoBufferSize);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueryWnfStateNameInformation), (uint32_t)w32_NtQueryWnfStateNameInformation, 5, StateName, NameInfoClass, ExplicitScope, InfoBuffer, InfoBufferSize);
#endif
    }

    NTSTATUS WINAPI NtQueueApcThread(HANDLE ThreadHandle, PPS_APC_ROUTINE ApcRoutine, PVOID ApcArgument1, PVOID ApcArgument2, PVOID ApcArgument3) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueueApcThread), 0, 5, ThreadHandle, ApcRoutine, ApcArgument1, ApcArgument2, ApcArgument3);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueueApcThread), (uint32_t)w32_NtQueueApcThread, 5, ThreadHandle, ApcRoutine, ApcArgument1, ApcArgument2, ApcArgument3);
#endif
    }

    NTSTATUS WINAPI NtQueueApcThreadEx(HANDLE ThreadHandle, HANDLE UserApcReserveHandle, PPS_APC_ROUTINE ApcRoutine, PVOID ApcArgument1, PVOID ApcArgument2, PVOID ApcArgument3) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueueApcThreadEx), 0, 6, ThreadHandle, UserApcReserveHandle, ApcRoutine, ApcArgument1, ApcArgument2, ApcArgument3);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtQueueApcThreadEx), (uint32_t)w32_NtQueueApcThreadEx, 6, ThreadHandle, UserApcReserveHandle, ApcRoutine, ApcArgument1, ApcArgument2, ApcArgument3);
#endif
    }

    NTSTATUS WINAPI NtRaiseException(PEXCEPTION_RECORD ExceptionRecord, PCONTEXT ContextRecord, BOOLEAN FirstChance) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRaiseException), 0, 3, ExceptionRecord, ContextRecord, FirstChance);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRaiseException), (uint32_t)w32_NtRaiseException, 3, ExceptionRecord, ContextRecord, FirstChance);
#endif
    }

    NTSTATUS WINAPI NtRaiseHardError(NTSTATUS ErrorStatus, ULONG NumberOfParameters, ULONG UnicodeStringParameterMask, PULONG_PTR Parameters, ULONG ValidResponseOptions, PULONG Response) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRaiseHardError), 0, 6, ErrorStatus, NumberOfParameters, UnicodeStringParameterMask, Parameters, ValidResponseOptions, Response);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRaiseHardError), (uint32_t)w32_NtRaiseHardError, 6, ErrorStatus, NumberOfParameters, UnicodeStringParameterMask, Parameters, ValidResponseOptions, Response);
#endif
    }

    NTSTATUS WINAPI NtReadFile(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtReadFile), 0, 9, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, Buffer, Length, ByteOffset, Key);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtReadFile), (uint32_t)w32_NtReadFile, 9, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, Buffer, Length, ByteOffset, Key);
#endif
    }

    NTSTATUS WINAPI NtReadFileScatter(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PFILE_SEGMENT_ELEMENT SegmentArray, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtReadFileScatter), 0, 9, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, SegmentArray, Length, ByteOffset, Key);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtReadFileScatter), (uint32_t)w32_NtReadFileScatter, 9, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, SegmentArray, Length, ByteOffset, Key);
#endif
    }

    NTSTATUS WINAPI NtReadOnlyEnlistment(HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtReadOnlyEnlistment), 0, 2, EnlistmentHandle, TmVirtualClock);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtReadOnlyEnlistment), (uint32_t)w32_NtReadOnlyEnlistment, 2, EnlistmentHandle, TmVirtualClock);
#endif
    }

    NTSTATUS WINAPI NtReadRequestData(HANDLE PortHandle, PPORT_MESSAGE Message, ULONG DataEntryIndex, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesRead) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtReadRequestData), 0, 6, PortHandle, Message, DataEntryIndex, Buffer, BufferSize, NumberOfBytesRead);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtReadRequestData), (uint32_t)w32_NtReadRequestData, 6, PortHandle, Message, DataEntryIndex, Buffer, BufferSize, NumberOfBytesRead);
#endif
    }

    NTSTATUS WINAPI NtReadVirtualMemory(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesRead) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtReadVirtualMemory), 0, 5, ProcessHandle, BaseAddress, Buffer, BufferSize, NumberOfBytesRead);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtReadVirtualMemory), (uint32_t)w32_NtReadVirtualMemory, 5, ProcessHandle, BaseAddress, Buffer, BufferSize, NumberOfBytesRead);
#endif
    }

    NTSTATUS WINAPI NtRecoverEnlistment(HANDLE EnlistmentHandle, PVOID EnlistmentKey) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRecoverEnlistment), 0, 2, EnlistmentHandle, EnlistmentKey);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRecoverEnlistment), (uint32_t)w32_NtRecoverEnlistment, 2, EnlistmentHandle, EnlistmentKey);
#endif
    }

    NTSTATUS WINAPI NtRecoverResourceManager(HANDLE ResourceManagerHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRecoverResourceManager), 0, 1, ResourceManagerHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRecoverResourceManager), (uint32_t)w32_NtRecoverResourceManager, 1, ResourceManagerHandle);
#endif
    }

    NTSTATUS WINAPI NtRecoverTransactionManager(HANDLE TransactionManagerHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRecoverTransactionManager), 0, 1, TransactionManagerHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRecoverTransactionManager), (uint32_t)w32_NtRecoverTransactionManager, 1, TransactionManagerHandle);
#endif
    }

    NTSTATUS WINAPI NtRegisterProtocolAddressInformation(HANDLE ResourceManager, PCRM_PROTOCOL_ID ProtocolId, ULONG ProtocolInformationSize, PVOID ProtocolInformation, ULONG CreateOptions) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRegisterProtocolAddressInformation), 0, 5, ResourceManager, ProtocolId, ProtocolInformationSize, ProtocolInformation, CreateOptions);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRegisterProtocolAddressInformation), (uint32_t)w32_NtRegisterProtocolAddressInformation, 5, ResourceManager, ProtocolId, ProtocolInformationSize, ProtocolInformation, CreateOptions);
#endif
    }

    NTSTATUS WINAPI NtRegisterThreadTerminatePort(HANDLE PortHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRegisterThreadTerminatePort), 0, 1, PortHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRegisterThreadTerminatePort), (uint32_t)w32_NtRegisterThreadTerminatePort, 1, PortHandle);
#endif
    }

    NTSTATUS WINAPI NtReleaseKeyedEvent(HANDLE KeyedEventHandle, PVOID KeyValue, BOOLEAN Alertable, PLARGE_INTEGER Timeout) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtReleaseKeyedEvent), 0, 4, KeyedEventHandle, KeyValue, Alertable, Timeout);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtReleaseKeyedEvent), (uint32_t)w32_NtReleaseKeyedEvent, 4, KeyedEventHandle, KeyValue, Alertable, Timeout);
#endif
    }

    NTSTATUS WINAPI NtReleaseMutant(HANDLE MutantHandle, PLONG PreviousCount) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtReleaseMutant), 0, 2, MutantHandle, PreviousCount);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtReleaseMutant), (uint32_t)w32_NtReleaseMutant, 2, MutantHandle, PreviousCount);
#endif
    }

    NTSTATUS WINAPI NtReleaseSemaphore(HANDLE SemaphoreHandle, LONG ReleaseCount, PLONG PreviousCount) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtReleaseSemaphore), 0, 3, SemaphoreHandle, ReleaseCount, PreviousCount);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtReleaseSemaphore), (uint32_t)w32_NtReleaseSemaphore, 3, SemaphoreHandle, ReleaseCount, PreviousCount);
#endif
    }

    NTSTATUS WINAPI NtReleaseWorkerFactoryWorker(HANDLE WorkerFactoryHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtReleaseWorkerFactoryWorker), 0, 1, WorkerFactoryHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtReleaseWorkerFactoryWorker), (uint32_t)w32_NtReleaseWorkerFactoryWorker, 1, WorkerFactoryHandle);
#endif
    }

    NTSTATUS WINAPI NtRemoveIoCompletion(HANDLE IoCompletionHandle, PVOID* KeyContext, PVOID* ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER Timeout) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRemoveIoCompletion), 0, 5, IoCompletionHandle, KeyContext, ApcContext, IoStatusBlock, Timeout);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRemoveIoCompletion), (uint32_t)w32_NtRemoveIoCompletion, 5, IoCompletionHandle, KeyContext, ApcContext, IoStatusBlock, Timeout);
#endif
    }

    NTSTATUS WINAPI NtRemoveIoCompletionEx(HANDLE IoCompletionHandle, PFILE_IO_COMPLETION_INFORMATION IoCompletionInformation, ULONG Count, PULONG NumEntriesRemoved, PLARGE_INTEGER Timeout, BOOLEAN Alertable) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRemoveIoCompletionEx), 0, 6, IoCompletionHandle, IoCompletionInformation, Count, NumEntriesRemoved, Timeout, Alertable);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRemoveIoCompletionEx), (uint32_t)w32_NtRemoveIoCompletionEx, 6, IoCompletionHandle, IoCompletionInformation, Count, NumEntriesRemoved, Timeout, Alertable);
#endif
    }

    NTSTATUS WINAPI NtRemoveProcessDebug(HANDLE ProcessHandle, HANDLE DebugObjectHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRemoveProcessDebug), 0, 2, ProcessHandle, DebugObjectHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRemoveProcessDebug), (uint32_t)w32_NtRemoveProcessDebug, 2, ProcessHandle, DebugObjectHandle);
#endif
    }

    NTSTATUS WINAPI NtRenameKey(HANDLE KeyHandle, PUNICODE_STRING NewName) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRenameKey), 0, 2, KeyHandle, NewName);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRenameKey), (uint32_t)w32_NtRenameKey, 2, KeyHandle, NewName);
#endif
    }

    NTSTATUS WINAPI NtRenameTransactionManager(PUNICODE_STRING LogFileName, LPGUID ExistingTransactionManagerGuid) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRenameTransactionManager), 0, 2, LogFileName, ExistingTransactionManagerGuid);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRenameTransactionManager), (uint32_t)w32_NtRenameTransactionManager, 2, LogFileName, ExistingTransactionManagerGuid);
#endif
    }

    NTSTATUS WINAPI NtReplaceKey(POBJECT_ATTRIBUTES NewFile, HANDLE TargetHandle, POBJECT_ATTRIBUTES OldFile) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtReplaceKey), 0, 3, NewFile, TargetHandle, OldFile);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtReplaceKey), (uint32_t)w32_NtReplaceKey, 3, NewFile, TargetHandle, OldFile);
#endif
    }

    NTSTATUS WINAPI NtReplacePartitionUnit(PUNICODE_STRING TargetInstancePath, PUNICODE_STRING SpareInstancePath, ULONG Flags) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtReplacePartitionUnit), 0, 3, TargetInstancePath, SpareInstancePath, Flags);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtReplacePartitionUnit), (uint32_t)w32_NtReplacePartitionUnit, 3, TargetInstancePath, SpareInstancePath, Flags);
#endif
    }

    NTSTATUS WINAPI NtReplyPort(HANDLE PortHandle, PPORT_MESSAGE ReplyMessage) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtReplyPort), 0, 2, PortHandle, ReplyMessage);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtReplyPort), (uint32_t)w32_NtReplyPort, 2, PortHandle, ReplyMessage);
#endif
    }

    NTSTATUS WINAPI NtReplyWaitReceivePort(HANDLE PortHandle, PVOID* PortContext, PPORT_MESSAGE ReplyMessage, PPORT_MESSAGE ReceiveMessage) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtReplyWaitReceivePort), 0, 4, PortHandle, PortContext, ReplyMessage, ReceiveMessage);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtReplyWaitReceivePort), (uint32_t)w32_NtReplyWaitReceivePort, 4, PortHandle, PortContext, ReplyMessage, ReceiveMessage);
#endif
    }

    NTSTATUS WINAPI NtReplyWaitReceivePortEx(HANDLE PortHandle, PVOID* PortContext, PPORT_MESSAGE ReplyMessage, PPORT_MESSAGE ReceiveMessage, PLARGE_INTEGER Timeout) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtReplyWaitReceivePortEx), 0, 5, PortHandle, PortContext, ReplyMessage, ReceiveMessage, Timeout);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtReplyWaitReceivePortEx), (uint32_t)w32_NtReplyWaitReceivePortEx, 5, PortHandle, PortContext, ReplyMessage, ReceiveMessage, Timeout);
#endif
    }

    NTSTATUS WINAPI NtReplyWaitReplyPort(HANDLE PortHandle, PPORT_MESSAGE ReplyMessage) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtReplyWaitReplyPort), 0, 2, PortHandle, ReplyMessage);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtReplyWaitReplyPort), (uint32_t)w32_NtReplyWaitReplyPort, 2, PortHandle, ReplyMessage);
#endif
    }

    NTSTATUS WINAPI NtRequestPort(HANDLE PortHandle, PPORT_MESSAGE RequestMessage) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRequestPort), 0, 2, PortHandle, RequestMessage);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRequestPort), (uint32_t)w32_NtRequestPort, 2, PortHandle, RequestMessage);
#endif
    }

    NTSTATUS WINAPI NtRequestWaitReplyPort(HANDLE PortHandle, PPORT_MESSAGE RequestMessage, PPORT_MESSAGE ReplyMessage) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRequestWaitReplyPort), 0, 3, PortHandle, RequestMessage, ReplyMessage);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRequestWaitReplyPort), (uint32_t)w32_NtRequestWaitReplyPort, 3, PortHandle, RequestMessage, ReplyMessage);
#endif
    }

    NTSTATUS WINAPI NtResetEvent(HANDLE EventHandle, PLONG PreviousState) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtResetEvent), 0, 2, EventHandle, PreviousState);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtResetEvent), (uint32_t)w32_NtResetEvent, 2, EventHandle, PreviousState);
#endif
    }

    NTSTATUS WINAPI NtResetWriteWatch(HANDLE ProcessHandle, PVOID BaseAddress, SIZE_T RegionSize) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtResetWriteWatch), 0, 3, ProcessHandle, BaseAddress, RegionSize);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtResetWriteWatch), (uint32_t)w32_NtResetWriteWatch, 3, ProcessHandle, BaseAddress, RegionSize);
#endif
    }

    NTSTATUS WINAPI NtRestoreKey(HANDLE KeyHandle, HANDLE FileHandle, ULONG Flags) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRestoreKey), 0, 3, KeyHandle, FileHandle, Flags);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRestoreKey), (uint32_t)w32_NtRestoreKey, 3, KeyHandle, FileHandle, Flags);
#endif
    }

    NTSTATUS WINAPI NtResumeProcess(HANDLE ProcessHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtResumeProcess), 0, 1, ProcessHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtResumeProcess), (uint32_t)w32_NtResumeProcess, 1, ProcessHandle);
#endif
    }

    NTSTATUS WINAPI NtResumeThread(HANDLE ThreadHandle, PULONG PreviousSuspendCount) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtResumeThread), 0, 2, ThreadHandle, PreviousSuspendCount);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtResumeThread), (uint32_t)w32_NtResumeThread, 2, ThreadHandle, PreviousSuspendCount);
#endif
    }

    NTSTATUS WINAPI NtRevertContainerImpersonation() {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRevertContainerImpersonation), 0, 0);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRevertContainerImpersonation), (uint32_t)w32_NtRevertContainerImpersonation, 0);
#endif
    }

    NTSTATUS WINAPI NtRollbackComplete(HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRollbackComplete), 0, 2, EnlistmentHandle, TmVirtualClock);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRollbackComplete), (uint32_t)w32_NtRollbackComplete, 2, EnlistmentHandle, TmVirtualClock);
#endif
    }

    NTSTATUS WINAPI NtRollbackEnlistment(HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRollbackEnlistment), 0, 2, EnlistmentHandle, TmVirtualClock);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRollbackEnlistment), (uint32_t)w32_NtRollbackEnlistment, 2, EnlistmentHandle, TmVirtualClock);
#endif
    }

    NTSTATUS WINAPI NtRollbackTransaction(HANDLE TransactionHandle, BOOLEAN Wait) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRollbackTransaction), 0, 2, TransactionHandle, Wait);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRollbackTransaction), (uint32_t)w32_NtRollbackTransaction, 2, TransactionHandle, Wait);
#endif
    }

    NTSTATUS WINAPI NtRollforwardTransactionManager(HANDLE TransactionManagerHandle, PLARGE_INTEGER TmVirtualClock) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRollforwardTransactionManager), 0, 2, TransactionManagerHandle, TmVirtualClock);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtRollforwardTransactionManager), (uint32_t)w32_NtRollforwardTransactionManager, 2, TransactionManagerHandle, TmVirtualClock);
#endif
    }

    NTSTATUS WINAPI NtSaveKey(HANDLE KeyHandle, HANDLE FileHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSaveKey), 0, 2, KeyHandle, FileHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSaveKey), (uint32_t)w32_NtSaveKey, 2, KeyHandle, FileHandle);
#endif
    }

    NTSTATUS WINAPI NtSaveKeyEx(HANDLE KeyHandle, HANDLE FileHandle, ULONG Format) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSaveKeyEx), 0, 3, KeyHandle, FileHandle, Format);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSaveKeyEx), (uint32_t)w32_NtSaveKeyEx, 3, KeyHandle, FileHandle, Format);
#endif
    }

    NTSTATUS WINAPI NtSaveMergedKeys(HANDLE HighPrecedenceKeyHandle, HANDLE LowPrecedenceKeyHandle, HANDLE FileHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSaveMergedKeys), 0, 3, HighPrecedenceKeyHandle, LowPrecedenceKeyHandle, FileHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSaveMergedKeys), (uint32_t)w32_NtSaveMergedKeys, 3, HighPrecedenceKeyHandle, LowPrecedenceKeyHandle, FileHandle);
#endif
    }

    NTSTATUS WINAPI NtSecureConnectPort(PHANDLE PortHandle, PUNICODE_STRING PortName, PSECURITY_QUALITY_OF_SERVICE SecurityQos, PPORT_VIEW ClientView, PSID RequiredServerSid, PREMOTE_PORT_VIEW ServerView, PULONG MaxMessageLength, PVOID ConnectionInformation, PULONG ConnectionInformationLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSecureConnectPort), 0, 9, PortHandle, PortName, SecurityQos, ClientView, RequiredServerSid, ServerView, MaxMessageLength, ConnectionInformation, ConnectionInformationLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSecureConnectPort), (uint32_t)w32_NtSecureConnectPort, 9, PortHandle, PortName, SecurityQos, ClientView, RequiredServerSid, ServerView, MaxMessageLength, ConnectionInformation, ConnectionInformationLength);
#endif
    }

    NTSTATUS WINAPI NtSerializeBoot() {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSerializeBoot), 0, 0);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSerializeBoot), (uint32_t)w32_NtSerializeBoot, 0);
#endif
    }

    NTSTATUS WINAPI NtSetBootEntryOrder(PULONG Ids, ULONG Count) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetBootEntryOrder), 0, 2, Ids, Count);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetBootEntryOrder), (uint32_t)w32_NtSetBootEntryOrder, 2, Ids, Count);
#endif
    }

    NTSTATUS WINAPI NtSetBootOptions(PBOOT_OPTIONS BootOptions, ULONG FieldsToChange) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetBootOptions), 0, 2, BootOptions, FieldsToChange);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetBootOptions), (uint32_t)w32_NtSetBootOptions, 2, BootOptions, FieldsToChange);
#endif
    }

    NTSTATUS WINAPI NtSetCachedSigningLevel(ULONG Flags, SE_SIGNING_LEVEL InputSigningLevel, PHANDLE SourceFiles, ULONG SourceFileCount, HANDLE TargetFile) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetCachedSigningLevel), 0, 5, Flags, InputSigningLevel, SourceFiles, SourceFileCount, TargetFile);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetCachedSigningLevel), (uint32_t)w32_NtSetCachedSigningLevel, 5, Flags, InputSigningLevel, SourceFiles, SourceFileCount, TargetFile);
#endif
    }

    NTSTATUS WINAPI NtSetContextThread(HANDLE ThreadHandle, PCONTEXT ThreadContext) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetContextThread), 0, 2, ThreadHandle, ThreadContext);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetContextThread), (uint32_t)w32_NtSetContextThread, 2, ThreadHandle, ThreadContext);
#endif
    }

    NTSTATUS WINAPI NtSetDebugFilterState(ULONG ComponentId, ULONG Level, BOOLEAN State) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetDebugFilterState), 0, 3, ComponentId, Level, State);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetDebugFilterState), (uint32_t)w32_NtSetDebugFilterState, 3, ComponentId, Level, State);
#endif
    }

    NTSTATUS WINAPI NtSetDefaultHardErrorPort(HANDLE DefaultHardErrorPort) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetDefaultHardErrorPort), 0, 1, DefaultHardErrorPort);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetDefaultHardErrorPort), (uint32_t)w32_NtSetDefaultHardErrorPort, 1, DefaultHardErrorPort);
#endif
    }

    NTSTATUS WINAPI NtSetDefaultLocale(BOOLEAN UserProfile, LCID DefaultLocaleId) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetDefaultLocale), 0, 2, UserProfile, DefaultLocaleId);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetDefaultLocale), (uint32_t)w32_NtSetDefaultLocale, 2, UserProfile, DefaultLocaleId);
#endif
    }

    NTSTATUS WINAPI NtSetDefaultUILanguage(LANGID DefaultUILanguageId) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetDefaultUILanguage), 0, 1, DefaultUILanguageId);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetDefaultUILanguage), (uint32_t)w32_NtSetDefaultUILanguage, 1, DefaultUILanguageId);
#endif
    }

    NTSTATUS WINAPI NtSetDriverEntryOrder(PULONG Ids, ULONG Count) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetDriverEntryOrder), 0, 2, Ids, Count);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetDriverEntryOrder), (uint32_t)w32_NtSetDriverEntryOrder, 2, Ids, Count);
#endif
    }

    NTSTATUS WINAPI NtSetEaFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetEaFile), 0, 4, FileHandle, IoStatusBlock, Buffer, Length);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetEaFile), (uint32_t)w32_NtSetEaFile, 4, FileHandle, IoStatusBlock, Buffer, Length);
#endif
    }

    NTSTATUS WINAPI NtSetEvent(HANDLE EventHandle, PLONG PreviousState) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetEvent), 0, 2, EventHandle, PreviousState);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetEvent), (uint32_t)w32_NtSetEvent, 2, EventHandle, PreviousState);
#endif
    }

    NTSTATUS WINAPI NtSetEventBoostPriority(HANDLE EventHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetEventBoostPriority), 0, 1, EventHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetEventBoostPriority), (uint32_t)w32_NtSetEventBoostPriority, 1, EventHandle);
#endif
    }

    NTSTATUS WINAPI NtSetHighEventPair(HANDLE EventPairHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetHighEventPair), 0, 1, EventPairHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetHighEventPair), (uint32_t)w32_NtSetHighEventPair, 1, EventPairHandle);
#endif
    }

    NTSTATUS WINAPI NtSetHighWaitLowEventPair(HANDLE EventPairHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetHighWaitLowEventPair), 0, 1, EventPairHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetHighWaitLowEventPair), (uint32_t)w32_NtSetHighWaitLowEventPair, 1, EventPairHandle);
#endif
    }

    NTSTATUS WINAPI NtSetIRTimer(HANDLE TimerHandle, PLARGE_INTEGER DueTime) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetIRTimer), 0, 2, TimerHandle, DueTime);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetIRTimer), (uint32_t)w32_NtSetIRTimer, 2, TimerHandle, DueTime);
#endif
    }

    NTSTATUS WINAPI NtSetInformationDebugObject(HANDLE DebugObjectHandle, DEBUGOBJECTINFOCLASS DebugObjectInformationClass, PVOID DebugInformation, ULONG DebugInformationLength, PULONG ReturnLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetInformationDebugObject), 0, 5, DebugObjectHandle, DebugObjectInformationClass, DebugInformation, DebugInformationLength, ReturnLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetInformationDebugObject), (uint32_t)w32_NtSetInformationDebugObject, 5, DebugObjectHandle, DebugObjectInformationClass, DebugInformation, DebugInformationLength, ReturnLength);
#endif
    }

    NTSTATUS WINAPI NtSetInformationEnlistment(HANDLE EnlistmentHandle, ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass, PVOID EnlistmentInformation, ULONG EnlistmentInformationLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetInformationEnlistment), 0, 4, EnlistmentHandle, EnlistmentInformationClass, EnlistmentInformation, EnlistmentInformationLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetInformationEnlistment), (uint32_t)w32_NtSetInformationEnlistment, 4, EnlistmentHandle, EnlistmentInformationClass, EnlistmentInformation, EnlistmentInformationLength);
#endif
    }

    NTSTATUS WINAPI NtSetInformationFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetInformationFile), 0, 5, FileHandle, IoStatusBlock, FileInformation, Length, FileInformationClass);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetInformationFile), (uint32_t)w32_NtSetInformationFile, 5, FileHandle, IoStatusBlock, FileInformation, Length, FileInformationClass);
#endif
    }

    NTSTATUS WINAPI NtSetInformationJobObject(HANDLE JobHandle, JOBOBJECTINFOCLASS JobObjectInformationClass, PVOID JobObjectInformation, ULONG JobObjectInformationLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetInformationJobObject), 0, 4, JobHandle, JobObjectInformationClass, JobObjectInformation, JobObjectInformationLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetInformationJobObject), (uint32_t)w32_NtSetInformationJobObject, 4, JobHandle, JobObjectInformationClass, JobObjectInformation, JobObjectInformationLength);
#endif
    }

    NTSTATUS WINAPI NtSetInformationKey(HANDLE KeyHandle, KEY_SET_INFORMATION_CLASS KeySetInformationClass, PVOID KeySetInformation, ULONG KeySetInformationLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetInformationKey), 0, 4, KeyHandle, KeySetInformationClass, KeySetInformation, KeySetInformationLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetInformationKey), (uint32_t)w32_NtSetInformationKey, 4, KeyHandle, KeySetInformationClass, KeySetInformation, KeySetInformationLength);
#endif
    }

    NTSTATUS WINAPI NtSetInformationObject(HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetInformationObject), 0, 4, Handle, ObjectInformationClass, ObjectInformation, ObjectInformationLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetInformationObject), (uint32_t)w32_NtSetInformationObject, 4, Handle, ObjectInformationClass, ObjectInformation, ObjectInformationLength);
#endif
    }

    NTSTATUS WINAPI NtSetInformationProcess(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetInformationProcess), 0, 4, ProcessHandle, ProcessInformationClass, ProcessInformation, ProcessInformationLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetInformationProcess), (uint32_t)w32_NtSetInformationProcess, 4, ProcessHandle, ProcessInformationClass, ProcessInformation, ProcessInformationLength);
#endif
    }

    NTSTATUS WINAPI NtSetInformationResourceManager(HANDLE ResourceManagerHandle, RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass, PVOID ResourceManagerInformation, ULONG ResourceManagerInformationLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetInformationResourceManager), 0, 4, ResourceManagerHandle, ResourceManagerInformationClass, ResourceManagerInformation, ResourceManagerInformationLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetInformationResourceManager), (uint32_t)w32_NtSetInformationResourceManager, 4, ResourceManagerHandle, ResourceManagerInformationClass, ResourceManagerInformation, ResourceManagerInformationLength);
#endif
    }

    NTSTATUS WINAPI NtSetInformationThread(HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetInformationThread), 0, 4, ThreadHandle, ThreadInformationClass, ThreadInformation, ThreadInformationLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetInformationThread), (uint32_t)w32_NtSetInformationThread, 4, ThreadHandle, ThreadInformationClass, ThreadInformation, ThreadInformationLength);
#endif
    }

    NTSTATUS WINAPI NtSetInformationToken(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, PVOID TokenInformation, ULONG TokenInformationLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetInformationToken), 0, 4, TokenHandle, TokenInformationClass, TokenInformation, TokenInformationLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetInformationToken), (uint32_t)w32_NtSetInformationToken, 4, TokenHandle, TokenInformationClass, TokenInformation, TokenInformationLength);
#endif
    }

    NTSTATUS WINAPI NtSetInformationTransaction(HANDLE TransactionHandle, TRANSACTION_INFORMATION_CLASS TransactionInformationClass, PVOID TransactionInformation, ULONG TransactionInformationLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetInformationTransaction), 0, 4, TransactionHandle, TransactionInformationClass, TransactionInformation, TransactionInformationLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetInformationTransaction), (uint32_t)w32_NtSetInformationTransaction, 4, TransactionHandle, TransactionInformationClass, TransactionInformation, TransactionInformationLength);
#endif
    }

    NTSTATUS WINAPI NtSetInformationTransactionManager(HANDLE TmHandle, TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass, PVOID TransactionManagerInformation, ULONG TransactionManagerInformationLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetInformationTransactionManager), 0, 4, TmHandle, TransactionManagerInformationClass, TransactionManagerInformation, TransactionManagerInformationLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetInformationTransactionManager), (uint32_t)w32_NtSetInformationTransactionManager, 4, TmHandle, TransactionManagerInformationClass, TransactionManagerInformation, TransactionManagerInformationLength);
#endif
    }

    NTSTATUS WINAPI NtSetInformationVirtualMemory(HANDLE ProcessHandle, VIRTUAL_MEMORY_INFORMATION_CLASS VmInformationClass, ULONG_PTR NumberOfEntries, PMEMORY_RANGE_ENTRY VirtualAddresses, PVOID VmInformation, ULONG VmInformationLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetInformationVirtualMemory), 0, 6, ProcessHandle, VmInformationClass, NumberOfEntries, VirtualAddresses, VmInformation, VmInformationLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetInformationVirtualMemory), (uint32_t)w32_NtSetInformationVirtualMemory, 6, ProcessHandle, VmInformationClass, NumberOfEntries, VirtualAddresses, VmInformation, VmInformationLength);
#endif
    }

    NTSTATUS WINAPI NtSetInformationWorkerFactory(HANDLE WorkerFactoryHandle, WORKERFACTORYINFOCLASS WorkerFactoryInformationClass, PVOID WorkerFactoryInformation, ULONG WorkerFactoryInformationLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetInformationWorkerFactory), 0, 4, WorkerFactoryHandle, WorkerFactoryInformationClass, WorkerFactoryInformation, WorkerFactoryInformationLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetInformationWorkerFactory), (uint32_t)w32_NtSetInformationWorkerFactory, 4, WorkerFactoryHandle, WorkerFactoryInformationClass, WorkerFactoryInformation, WorkerFactoryInformationLength);
#endif
    }

    NTSTATUS WINAPI NtSetIntervalProfile(ULONG Interval, KPROFILE_SOURCE Source) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetIntervalProfile), 0, 2, Interval, Source);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetIntervalProfile), (uint32_t)w32_NtSetIntervalProfile, 2, Interval, Source);
#endif
    }

    NTSTATUS WINAPI NtSetIoCompletion(HANDLE IoCompletionHandle, PVOID KeyContext, PVOID ApcContext, NTSTATUS IoStatus, ULONG_PTR IoStatusInformation) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetIoCompletion), 0, 5, IoCompletionHandle, KeyContext, ApcContext, IoStatus, IoStatusInformation);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetIoCompletion), (uint32_t)w32_NtSetIoCompletion, 5, IoCompletionHandle, KeyContext, ApcContext, IoStatus, IoStatusInformation);
#endif
    }

    NTSTATUS WINAPI NtSetIoCompletionEx(HANDLE IoCompletionHandle, HANDLE IoCompletionPacketHandle, PVOID KeyContext, PVOID ApcContext, NTSTATUS IoStatus, ULONG_PTR IoStatusInformation) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetIoCompletionEx), 0, 6, IoCompletionHandle, IoCompletionPacketHandle, KeyContext, ApcContext, IoStatus, IoStatusInformation);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetIoCompletionEx), (uint32_t)w32_NtSetIoCompletionEx, 6, IoCompletionHandle, IoCompletionPacketHandle, KeyContext, ApcContext, IoStatus, IoStatusInformation);
#endif
    }

    NTSTATUS WINAPI NtSetLdtEntries(ULONG Selector0, ULONG Entry0Low, ULONG Entry0Hi, ULONG Selector1, ULONG Entry1Low, ULONG Entry1Hi) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetLdtEntries), 0, 6, Selector0, Entry0Low, Entry0Hi, Selector1, Entry1Low, Entry1Hi);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetLdtEntries), (uint32_t)w32_NtSetLdtEntries, 6, Selector0, Entry0Low, Entry0Hi, Selector1, Entry1Low, Entry1Hi);
#endif
    }

    NTSTATUS WINAPI NtSetLowEventPair(HANDLE EventPairHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetLowEventPair), 0, 1, EventPairHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetLowEventPair), (uint32_t)w32_NtSetLowEventPair, 1, EventPairHandle);
#endif
    }

    NTSTATUS WINAPI NtSetLowWaitHighEventPair(HANDLE EventPairHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetLowWaitHighEventPair), 0, 1, EventPairHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetLowWaitHighEventPair), (uint32_t)w32_NtSetLowWaitHighEventPair, 1, EventPairHandle);
#endif
    }

    NTSTATUS WINAPI NtSetQuotaInformationFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetQuotaInformationFile), 0, 4, FileHandle, IoStatusBlock, Buffer, Length);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetQuotaInformationFile), (uint32_t)w32_NtSetQuotaInformationFile, 4, FileHandle, IoStatusBlock, Buffer, Length);
#endif
    }

    NTSTATUS WINAPI NtSetSecurityObject(HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetSecurityObject), 0, 3, Handle, SecurityInformation, SecurityDescriptor);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetSecurityObject), (uint32_t)w32_NtSetSecurityObject, 3, Handle, SecurityInformation, SecurityDescriptor);
#endif
    }

    NTSTATUS WINAPI NtSetSystemEnvironmentValue(PUNICODE_STRING VariableName, PUNICODE_STRING VariableValue) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetSystemEnvironmentValue), 0, 2, VariableName, VariableValue);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetSystemEnvironmentValue), (uint32_t)w32_NtSetSystemEnvironmentValue, 2, VariableName, VariableValue);
#endif
    }

    NTSTATUS WINAPI NtSetSystemEnvironmentValueEx(PUNICODE_STRING VariableName, LPGUID VendorGuid, PVOID Value, ULONG ValueLength, ULONG Attributes) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetSystemEnvironmentValueEx), 0, 5, VariableName, VendorGuid, Value, ValueLength, Attributes);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetSystemEnvironmentValueEx), (uint32_t)w32_NtSetSystemEnvironmentValueEx, 5, VariableName, VendorGuid, Value, ValueLength, Attributes);
#endif
    }

    NTSTATUS WINAPI NtSetSystemInformation(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetSystemInformation), 0, 3, SystemInformationClass, SystemInformation, SystemInformationLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetSystemInformation), (uint32_t)w32_NtSetSystemInformation, 3, SystemInformationClass, SystemInformation, SystemInformationLength);
#endif
    }

    NTSTATUS WINAPI NtSetSystemPowerState(POWER_ACTION SystemAction, SYSTEM_POWER_STATE LightestSystemState, ULONG Flags) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetSystemPowerState), 0, 3, SystemAction, LightestSystemState, Flags);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetSystemPowerState), (uint32_t)w32_NtSetSystemPowerState, 3, SystemAction, LightestSystemState, Flags);
#endif
    }

    NTSTATUS WINAPI NtSetSystemTime(PLARGE_INTEGER SystemTime, PLARGE_INTEGER PreviousTime) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetSystemTime), 0, 2, SystemTime, PreviousTime);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetSystemTime), (uint32_t)w32_NtSetSystemTime, 2, SystemTime, PreviousTime);
#endif
    }

    NTSTATUS WINAPI NtSetThreadExecutionState(EXECUTION_STATE NewFlags, EXECUTION_STATE* PreviousFlags) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetThreadExecutionState), 0, 2, NewFlags, PreviousFlags);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetThreadExecutionState), (uint32_t)w32_NtSetThreadExecutionState, 2, NewFlags, PreviousFlags);
#endif
    }

    NTSTATUS WINAPI NtSetTimer(HANDLE TimerHandle, PLARGE_INTEGER DueTime, PTIMER_APC_ROUTINE TimerApcRoutine, PVOID TimerContext, BOOLEAN ResumeTimer, LONG Period, PBOOLEAN PreviousState) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetTimer), 0, 7, TimerHandle, DueTime, TimerApcRoutine, TimerContext, ResumeTimer, Period, PreviousState);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetTimer), (uint32_t)w32_NtSetTimer, 7, TimerHandle, DueTime, TimerApcRoutine, TimerContext, ResumeTimer, Period, PreviousState);
#endif
    }

    NTSTATUS WINAPI NtSetTimer2(HANDLE TimerHandle, PLARGE_INTEGER DueTime, PLARGE_INTEGER Period, PT2_SET_PARAMETERS Parameters) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetTimer2), 0, 4, TimerHandle, DueTime, Period, Parameters);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetTimer2), (uint32_t)w32_NtSetTimer2, 4, TimerHandle, DueTime, Period, Parameters);
#endif
    }

    NTSTATUS WINAPI NtSetTimerEx(HANDLE TimerHandle, TIMER_SET_INFORMATION_CLASS TimerSetInformationClass, PVOID TimerSetInformation, ULONG TimerSetInformationLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetTimerEx), 0, 4, TimerHandle, TimerSetInformationClass, TimerSetInformation, TimerSetInformationLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetTimerEx), (uint32_t)w32_NtSetTimerEx, 4, TimerHandle, TimerSetInformationClass, TimerSetInformation, TimerSetInformationLength);
#endif
    }

    NTSTATUS WINAPI NtSetTimerResolution(ULONG DesiredTime, BOOLEAN SetResolution, PULONG ActualTime) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetTimerResolution), 0, 3, DesiredTime, SetResolution, ActualTime);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetTimerResolution), (uint32_t)w32_NtSetTimerResolution, 3, DesiredTime, SetResolution, ActualTime);
#endif
    }

    NTSTATUS WINAPI NtSetUuidSeed(PCHAR Seed) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetUuidSeed), 0, 1, Seed);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetUuidSeed), (uint32_t)w32_NtSetUuidSeed, 1, Seed);
#endif
    }

    NTSTATUS WINAPI NtSetValueKey(HANDLE KeyHandle, PUNICODE_STRING ValueName, ULONG TitleIndex, ULONG Type, PVOID Data, ULONG DataSize) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetValueKey), 0, 6, KeyHandle, ValueName, TitleIndex, Type, Data, DataSize);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetValueKey), (uint32_t)w32_NtSetValueKey, 6, KeyHandle, ValueName, TitleIndex, Type, Data, DataSize);
#endif
    }

    NTSTATUS WINAPI NtSetVolumeInformationFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FsInformation, ULONG Length, FSINFOCLASS FsInformationClass) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetVolumeInformationFile), 0, 5, FileHandle, IoStatusBlock, FsInformation, Length, FsInformationClass);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetVolumeInformationFile), (uint32_t)w32_NtSetVolumeInformationFile, 5, FileHandle, IoStatusBlock, FsInformation, Length, FsInformationClass);
#endif
    }

    NTSTATUS WINAPI NtSetWnfProcessNotificationEvent(HANDLE NotificationEvent) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetWnfProcessNotificationEvent), 0, 1, NotificationEvent);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSetWnfProcessNotificationEvent), (uint32_t)w32_NtSetWnfProcessNotificationEvent, 1, NotificationEvent);
#endif
    }

    NTSTATUS WINAPI NtShutdownSystem(SHUTDOWN_ACTION Action) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtShutdownSystem), 0, 1, Action);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtShutdownSystem), (uint32_t)w32_NtShutdownSystem, 1, Action);
#endif
    }

    NTSTATUS WINAPI NtShutdownWorkerFactory(HANDLE WorkerFactoryHandle, LONG volatile* PendingWorkerCount) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtShutdownWorkerFactory), 0, 2, WorkerFactoryHandle, PendingWorkerCount);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtShutdownWorkerFactory), (uint32_t)w32_NtShutdownWorkerFactory, 2, WorkerFactoryHandle, PendingWorkerCount);
#endif
    }

    NTSTATUS WINAPI NtSignalAndWaitForSingleObject(HANDLE SignalHandle, HANDLE WaitHandle, BOOLEAN Alertable, PLARGE_INTEGER Timeout) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSignalAndWaitForSingleObject), 0, 4, SignalHandle, WaitHandle, Alertable, Timeout);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSignalAndWaitForSingleObject), (uint32_t)w32_NtSignalAndWaitForSingleObject, 4, SignalHandle, WaitHandle, Alertable, Timeout);
#endif
    }

    NTSTATUS WINAPI NtSinglePhaseReject(HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSinglePhaseReject), 0, 2, EnlistmentHandle, TmVirtualClock);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSinglePhaseReject), (uint32_t)w32_NtSinglePhaseReject, 2, EnlistmentHandle, TmVirtualClock);
#endif
    }

    NTSTATUS WINAPI NtStartProfile(HANDLE ProfileHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtStartProfile), 0, 1, ProfileHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtStartProfile), (uint32_t)w32_NtStartProfile, 1, ProfileHandle);
#endif
    }

    NTSTATUS WINAPI NtStopProfile(HANDLE ProfileHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtStopProfile), 0, 1, ProfileHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtStopProfile), (uint32_t)w32_NtStopProfile, 1, ProfileHandle);
#endif
    }

    NTSTATUS WINAPI NtSubscribeWnfStateChange(PCWNF_STATE_NAME StateName, WNF_CHANGE_STAMP ChangeStamp, ULONG EventMask, PULONG64 SubscriptionId) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSubscribeWnfStateChange), 0, 4, StateName, ChangeStamp, EventMask, SubscriptionId);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSubscribeWnfStateChange), (uint32_t)w32_NtSubscribeWnfStateChange, 4, StateName, ChangeStamp, EventMask, SubscriptionId);
#endif
    }

    NTSTATUS WINAPI NtSuspendProcess(HANDLE ProcessHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSuspendProcess), 0, 1, ProcessHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSuspendProcess), (uint32_t)w32_NtSuspendProcess, 1, ProcessHandle);
#endif
    }

    NTSTATUS WINAPI NtSuspendThread(HANDLE ThreadHandle, PULONG PreviousSuspendCount) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSuspendThread), 0, 2, ThreadHandle, PreviousSuspendCount);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSuspendThread), (uint32_t)w32_NtSuspendThread, 2, ThreadHandle, PreviousSuspendCount);
#endif
    }

    NTSTATUS WINAPI NtSystemDebugControl(SYSDBG_COMMAND Command, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength, PULONG ReturnLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSystemDebugControl), 0, 6, Command, InputBuffer, InputBufferLength, OutputBuffer, OutputBufferLength, ReturnLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtSystemDebugControl), (uint32_t)w32_NtSystemDebugControl, 6, Command, InputBuffer, InputBufferLength, OutputBuffer, OutputBufferLength, ReturnLength);
#endif
    }

    NTSTATUS WINAPI NtTerminateEnclave(PVOID BaseAddress, BOOLEAN WaitForThread) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtTerminateEnclave), 0, 2, BaseAddress, WaitForThread);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtTerminateEnclave), (uint32_t)w32_NtTerminateEnclave, 2, BaseAddress, WaitForThread);
#endif
    }

    NTSTATUS WINAPI NtTerminateJobObject(HANDLE JobHandle, NTSTATUS ExitStatus) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtTerminateJobObject), 0, 2, JobHandle, ExitStatus);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtTerminateJobObject), (uint32_t)w32_NtTerminateJobObject, 2, JobHandle, ExitStatus);
#endif
    }

    NTSTATUS WINAPI NtTerminateProcess(HANDLE ProcessHandle, NTSTATUS ExitStatus) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtTerminateProcess), 0, 2, ProcessHandle, ExitStatus);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtTerminateProcess), (uint32_t)w32_NtTerminateProcess, 2, ProcessHandle, ExitStatus);
#endif
    }

    NTSTATUS WINAPI NtTerminateThread(HANDLE ThreadHandle, NTSTATUS ExitStatus) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtTerminateThread), 0, 2, ThreadHandle, ExitStatus);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtTerminateThread), (uint32_t)w32_NtTerminateThread, 2, ThreadHandle, ExitStatus);
#endif
    }

    NTSTATUS WINAPI NtTestAlert() {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtTestAlert), 0, 0);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtTestAlert), (uint32_t)w32_NtTestAlert, 0);
#endif
    }

    NTSTATUS WINAPI NtThawRegistry() {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtThawRegistry), 0, 0);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtThawRegistry), (uint32_t)w32_NtThawRegistry, 0);
#endif
    }

    NTSTATUS WINAPI NtThawTransactions() {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtThawTransactions), 0, 0);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtThawTransactions), (uint32_t)w32_NtThawTransactions, 0);
#endif
    }

    NTSTATUS WINAPI NtTraceControl(TRACE_CONTROL_INFORMATION_CLASS TraceInformationClass, PVOID InputBuffer, ULONG InputBufferLength, PVOID TraceInformation, ULONG TraceInformationLength, PULONG ReturnLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtTraceControl), 0, 6, TraceInformationClass, InputBuffer, InputBufferLength, TraceInformation, TraceInformationLength, ReturnLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtTraceControl), (uint32_t)w32_NtTraceControl, 6, TraceInformationClass, InputBuffer, InputBufferLength, TraceInformation, TraceInformationLength, ReturnLength);
#endif
    }

    NTSTATUS WINAPI NtTraceEvent(HANDLE TraceHandle, ULONG Flags, ULONG FieldSize, PVOID Fields) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtTraceEvent), 0, 4, TraceHandle, Flags, FieldSize, Fields);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtTraceEvent), (uint32_t)w32_NtTraceEvent, 4, TraceHandle, Flags, FieldSize, Fields);
#endif
    }

    NTSTATUS WINAPI NtTranslateFilePath(PFILE_PATH InputFilePath, ULONG OutputType, PFILE_PATH OutputFilePath, PULONG OutputFilePathLength) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtTranslateFilePath), 0, 4, InputFilePath, OutputType, OutputFilePath, OutputFilePathLength);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtTranslateFilePath), (uint32_t)w32_NtTranslateFilePath, 4, InputFilePath, OutputType, OutputFilePath, OutputFilePathLength);
#endif
    }

    NTSTATUS WINAPI NtUmsThreadYield(PVOID SchedulerParam) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtUmsThreadYield), 0, 1, SchedulerParam);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtUmsThreadYield), (uint32_t)w32_NtUmsThreadYield, 1, SchedulerParam);
#endif
    }

    NTSTATUS WINAPI NtUnloadDriver(PUNICODE_STRING DriverServiceName) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtUnloadDriver), 0, 1, DriverServiceName);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtUnloadDriver), (uint32_t)w32_NtUnloadDriver, 1, DriverServiceName);
#endif
    }

    NTSTATUS WINAPI NtUnloadKey(POBJECT_ATTRIBUTES TargetKey) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtUnloadKey), 0, 1, TargetKey);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtUnloadKey), (uint32_t)w32_NtUnloadKey, 1, TargetKey);
#endif
    }

    NTSTATUS WINAPI NtUnloadKey2(POBJECT_ATTRIBUTES TargetKey, ULONG Flags) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtUnloadKey2), 0, 2, TargetKey, Flags);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtUnloadKey2), (uint32_t)w32_NtUnloadKey2, 2, TargetKey, Flags);
#endif
    }

    NTSTATUS WINAPI NtUnloadKeyEx(POBJECT_ATTRIBUTES TargetKey, HANDLE Event) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtUnloadKeyEx), 0, 2, TargetKey, Event);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtUnloadKeyEx), (uint32_t)w32_NtUnloadKeyEx, 2, TargetKey, Event);
#endif
    }

    NTSTATUS WINAPI NtUnlockFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER ByteOffset, PLARGE_INTEGER Length, ULONG Key) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtUnlockFile), 0, 5, FileHandle, IoStatusBlock, ByteOffset, Length, Key);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtUnlockFile), (uint32_t)w32_NtUnlockFile, 5, FileHandle, IoStatusBlock, ByteOffset, Length, Key);
#endif
    }

    NTSTATUS WINAPI NtUnlockVirtualMemory(HANDLE ProcessHandle, PVOID* BaseAddress, PSIZE_T RegionSize, ULONG MapType) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtUnlockVirtualMemory), 0, 4, ProcessHandle, BaseAddress, RegionSize, MapType);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtUnlockVirtualMemory), (uint32_t)w32_NtUnlockVirtualMemory, 4, ProcessHandle, BaseAddress, RegionSize, MapType);
#endif
    }

    NTSTATUS WINAPI NtUnmapViewOfSection(HANDLE ProcessHandle, PVOID BaseAddress) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtUnmapViewOfSection), 0, 2, ProcessHandle, BaseAddress);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtUnmapViewOfSection), (uint32_t)w32_NtUnmapViewOfSection, 2, ProcessHandle, BaseAddress);
#endif
    }

    NTSTATUS WINAPI NtUnmapViewOfSectionEx(HANDLE ProcessHandle, PVOID BaseAddress, ULONG Flags) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtUnmapViewOfSectionEx), 0, 3, ProcessHandle, BaseAddress, Flags);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtUnmapViewOfSectionEx), (uint32_t)w32_NtUnmapViewOfSectionEx, 3, ProcessHandle, BaseAddress, Flags);
#endif
    }

    NTSTATUS WINAPI NtUnsubscribeWnfStateChange(PCWNF_STATE_NAME StateName) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtUnsubscribeWnfStateChange), 0, 1, StateName);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtUnsubscribeWnfStateChange), (uint32_t)w32_NtUnsubscribeWnfStateChange, 1, StateName);
#endif
    }

    NTSTATUS WINAPI NtUpdateWnfStateData(PCWNF_STATE_NAME StateName, void const* Buffer, ULONG Length, PCWNF_TYPE_ID TypeId, void const* ExplicitScope, WNF_CHANGE_STAMP MatchingChangeStamp, LOGICAL CheckStamp) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtUpdateWnfStateData), 0, 7, StateName, Buffer, Length, TypeId, ExplicitScope, MatchingChangeStamp, CheckStamp);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtUpdateWnfStateData), (uint32_t)w32_NtUpdateWnfStateData, 7, StateName, Buffer, Length, TypeId, ExplicitScope, MatchingChangeStamp, CheckStamp);
#endif
    }

    NTSTATUS WINAPI NtVdmControl(VDMSERVICECLASS Service, PVOID ServiceData) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtVdmControl), 0, 2, Service, ServiceData);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtVdmControl), (uint32_t)w32_NtVdmControl, 2, Service, ServiceData);
#endif
    }

    NTSTATUS WINAPI NtWaitForAlertByThreadId(PVOID Address, PLARGE_INTEGER Timeout) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtWaitForAlertByThreadId), 0, 2, Address, Timeout);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtWaitForAlertByThreadId), (uint32_t)w32_NtWaitForAlertByThreadId, 2, Address, Timeout);
#endif
    }

    NTSTATUS WINAPI NtWaitForDebugEvent(HANDLE DebugObjectHandle, BOOLEAN Alertable, PLARGE_INTEGER Timeout, PDBGUI_WAIT_STATE_CHANGE WaitStateChange) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtWaitForDebugEvent), 0, 4, DebugObjectHandle, Alertable, Timeout, WaitStateChange);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtWaitForDebugEvent), (uint32_t)w32_NtWaitForDebugEvent, 4, DebugObjectHandle, Alertable, Timeout, WaitStateChange);
#endif
    }

    NTSTATUS WINAPI NtWaitForKeyedEvent(HANDLE KeyedEventHandle, PVOID KeyValue, BOOLEAN Alertable, PLARGE_INTEGER Timeout) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtWaitForKeyedEvent), 0, 4, KeyedEventHandle, KeyValue, Alertable, Timeout);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtWaitForKeyedEvent), (uint32_t)w32_NtWaitForKeyedEvent, 4, KeyedEventHandle, KeyValue, Alertable, Timeout);
#endif
    }

    NTSTATUS WINAPI NtWaitForMultipleObjects(ULONG Count, HANDLE* Handles, WAIT_TYPE WaitType, BOOLEAN Alertable, PLARGE_INTEGER Timeout) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtWaitForMultipleObjects), 0, 5, Count, Handles, WaitType, Alertable, Timeout);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtWaitForMultipleObjects), (uint32_t)w32_NtWaitForMultipleObjects, 5, Count, Handles, WaitType, Alertable, Timeout);
#endif
    }

    NTSTATUS WINAPI NtWaitForMultipleObjects32(ULONG Count, LONG* Handles, WAIT_TYPE WaitType, BOOLEAN Alertable, PLARGE_INTEGER Timeout) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtWaitForMultipleObjects32), 0, 5, Count, Handles, WaitType, Alertable, Timeout);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtWaitForMultipleObjects32), (uint32_t)w32_NtWaitForMultipleObjects32, 5, Count, Handles, WaitType, Alertable, Timeout);
#endif
    }

    NTSTATUS WINAPI NtWaitForSingleObject(HANDLE Handle, BOOLEAN Alertable, PLARGE_INTEGER Timeout) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtWaitForSingleObject), 0, 3, Handle, Alertable, Timeout);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtWaitForSingleObject), (uint32_t)w32_NtWaitForSingleObject, 3, Handle, Alertable, Timeout);
#endif
    }

    NTSTATUS WINAPI NtWaitForWorkViaWorkerFactory(HANDLE WorkerFactoryHandle, _FILE_IO_COMPLETION_INFORMATION* MiniPacket) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtWaitForWorkViaWorkerFactory), 0, 2, WorkerFactoryHandle, MiniPacket);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtWaitForWorkViaWorkerFactory), (uint32_t)w32_NtWaitForWorkViaWorkerFactory, 2, WorkerFactoryHandle, MiniPacket);
#endif
    }

    NTSTATUS WINAPI NtWaitHighEventPair(HANDLE EventPairHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtWaitHighEventPair), 0, 1, EventPairHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtWaitHighEventPair), (uint32_t)w32_NtWaitHighEventPair, 1, EventPairHandle);
#endif
    }

    NTSTATUS WINAPI NtWaitLowEventPair(HANDLE EventPairHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtWaitLowEventPair), 0, 1, EventPairHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtWaitLowEventPair), (uint32_t)w32_NtWaitLowEventPair, 1, EventPairHandle);
#endif
    }

    NTSTATUS WINAPI NtWorkerFactoryWorkerReady(HANDLE WorkerFactoryHandle) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtWorkerFactoryWorkerReady), 0, 1, WorkerFactoryHandle);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtWorkerFactoryWorkerReady), (uint32_t)w32_NtWorkerFactoryWorkerReady, 1, WorkerFactoryHandle);
#endif
    }

    NTSTATUS WINAPI NtWriteFile(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtWriteFile), 0, 9, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, Buffer, Length, ByteOffset, Key);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtWriteFile), (uint32_t)w32_NtWriteFile, 9, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, Buffer, Length, ByteOffset, Key);
#endif
    }

    NTSTATUS WINAPI NtWriteFileGather(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PFILE_SEGMENT_ELEMENT SegmentArray, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtWriteFileGather), 0, 9, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, SegmentArray, Length, ByteOffset, Key);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtWriteFileGather), (uint32_t)w32_NtWriteFileGather, 9, FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, SegmentArray, Length, ByteOffset, Key);
#endif
    }

    NTSTATUS WINAPI NtWriteRequestData(HANDLE PortHandle, PPORT_MESSAGE Message, ULONG DataEntryIndex, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesWritten) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtWriteRequestData), 0, 6, PortHandle, Message, DataEntryIndex, Buffer, BufferSize, NumberOfBytesWritten);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtWriteRequestData), (uint32_t)w32_NtWriteRequestData, 6, PortHandle, Message, DataEntryIndex, Buffer, BufferSize, NumberOfBytesWritten);
#endif
    }

    NTSTATUS WINAPI NtWriteVirtualMemory(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesWritten) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtWriteVirtualMemory), 0, 5, ProcessHandle, BaseAddress, Buffer, BufferSize, NumberOfBytesWritten);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtWriteVirtualMemory), (uint32_t)w32_NtWriteVirtualMemory, 5, ProcessHandle, BaseAddress, Buffer, BufferSize, NumberOfBytesWritten);
#endif
    }

    NTSTATUS WINAPI NtYieldExecution() {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

#ifdef _M_AMD64
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtYieldExecution), 0, 0);
#else
        return cleancall::call(get_syscall_by_idx(SYSCALL_NtYieldExecution), (uint32_t)w32_NtYieldExecution, 0);
#endif
    }



#ifdef _M_IX86
    NTSTATUS WINAPI NtWow64NtAllocateVirtualMemory64(HANDLE ProcessHandle, PULONGLONG BaseAddress, ULONGLONG ZeroBits, PULONGLONG RegionSize, ULONG AllocationType, ULONG Protect) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

        return cleancall::call64(get_syscall_by_idx(SYSCALL_NtAllocateVirtualMemory), (uint32_t)w64_NtAllocateVirtualMemory, 6, (ULONGLONG)ProcessHandle, (ULONGLONG)BaseAddress, (ULONGLONG)ZeroBits, (ULONGLONG)RegionSize, (ULONGLONG)AllocationType, (ULONGLONG)Protect);
    }

    NTSTATUS WINAPI NtWow64NtFreeVirtualMemory64(HANDLE ProcessHandle, ULONGLONG BaseAddress, PULONGLONG RegionSize, ULONG FreeType) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

        return cleancall::call64(get_syscall_by_idx(SYSCALL_NtFreeVirtualMemory), (uint32_t)w64_NtFreeVirtualMemory, 4, (ULONGLONG)ProcessHandle, (ULONGLONG)BaseAddress, (ULONGLONG)RegionSize, (ULONGLONG)FreeType);
    }

    NTSTATUS WINAPI NtWow64ReadVirtualMemory64(HANDLE ProcessHandle, ULONGLONG BaseAddress, ULONGLONG Buffer, ULONGLONG BufferSize, PULONGLONG NumberOfBytesRead) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

        return cleancall::call64(get_syscall_by_idx(SYSCALL_NtReadVirtualMemory), (uint32_t)w64_NtReadVirtualMemory, 5, (ULONGLONG)ProcessHandle, (ULONGLONG)BaseAddress, (ULONGLONG)Buffer, (ULONGLONG)BufferSize, (ULONGLONG)NumberOfBytesRead);
    }

    NTSTATUS WINAPI NtWow64WriteVirtualMemory64(HANDLE ProcessHandle, ULONGLONG BaseAddress, ULONGLONG Buffer, ULONGLONG BufferSize, PULONGLONG NumberOfBytesWritten) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

        return cleancall::call64(get_syscall_by_idx(SYSCALL_NtWriteVirtualMemory), (uint32_t)w64_NtWriteVirtualMemory, 5, (ULONGLONG)ProcessHandle, (ULONGLONG)BaseAddress, (ULONGLONG)Buffer, (ULONGLONG)BufferSize, (ULONGLONG)NumberOfBytesWritten);
    }

    NTSTATUS WINAPI NtWow64NtProtectVirtualMemory64(HANDLE ProcessHandle, ULONGLONG BaseAddress, PULONGLONG RegionSize, ULONG NewProtect, PULONG OldProtect) {

        if (!is_syscall_table_initialized()) {
            return STATUS_NOT_IMPLEMENTED;
        }

        return cleancall::call64(get_syscall_by_idx(SYSCALL_NtProtectVirtualMemory), (uint32_t)w64_NtProtectVirtualMemory, 5, (ULONGLONG)ProcessHandle, (ULONGLONG)BaseAddress, (ULONGLONG)RegionSize, (ULONGLONG)NewProtect, (ULONGLONG)OldProtect);
    }
#endif

#pragma warning(pop)

};
```

`src/HIGU_ntcall/ntdll_functions.h`:

```h
#pragma once

#pragma warning(push)
#pragma warning(disable: 4273)


#ifdef __cplusplus
extern "C" {
#endif

    NTSTATUS WINAPI NtAcceptConnectPort(PHANDLE PortHandle, PVOID PortContext, PPORT_MESSAGE ConnectionRequest, BOOLEAN AcceptConnection, PPORT_VIEW ServerView, PREMOTE_PORT_VIEW ClientView);
    NTSTATUS WINAPI NtAccessCheck(PSECURITY_DESCRIPTOR SecurityDescriptor, HANDLE ClientToken, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);
    NTSTATUS WINAPI NtAccessCheckAndAuditAlarm(PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);
    NTSTATUS WINAPI NtAccessCheckByType(PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, ACCESS_MASK DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);
    NTSTATUS WINAPI NtAccessCheckByTypeAndAuditAlarm(PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);
    NTSTATUS WINAPI NtAccessCheckByTypeResultList(PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, ACCESS_MASK DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);
    NTSTATUS WINAPI NtAccessCheckByTypeResultListAndAuditAlarm(PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);
    NTSTATUS WINAPI NtAccessCheckByTypeResultListAndAuditAlarmByHandle(PUNICODE_STRING SubsystemName, PVOID HandleId, HANDLE ClientToken, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, ACCESS_MASK DesiredAccess, AUDIT_EVENT_TYPE AuditType, ULONG Flags, POBJECT_TYPE_LIST ObjectTypeList, ULONG ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus, PBOOLEAN GenerateOnClose);
    NTSTATUS WINAPI NtAddAtom(PWSTR AtomName, ULONG Length, PRTL_ATOM Atom);
    NTSTATUS WINAPI NtAddAtomEx(PWSTR AtomName, ULONG Length, PRTL_ATOM Atom, ULONG Flags);
    NTSTATUS WINAPI NtAddBootEntry(PBOOT_ENTRY BootEntry, PULONG Id);
    NTSTATUS WINAPI NtAddDriverEntry(PEFI_DRIVER_ENTRY DriverEntry, PULONG Id);
    NTSTATUS WINAPI NtAdjustGroupsToken(HANDLE TokenHandle, BOOLEAN ResetToDefault, PTOKEN_GROUPS NewState, ULONG BufferLength, PTOKEN_GROUPS PreviousState, PULONG ReturnLength);
    NTSTATUS WINAPI NtAdjustPrivilegesToken(HANDLE TokenHandle, BOOLEAN DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, ULONG BufferLength, PTOKEN_PRIVILEGES PreviousState, PULONG ReturnLength);
    NTSTATUS WINAPI NtAdjustTokenClaimsAndDeviceGroups(HANDLE TokenHandle, BOOLEAN UserResetToDefault, BOOLEAN DeviceResetToDefault, BOOLEAN DeviceGroupsResetToDefault, PTOKEN_SECURITY_ATTRIBUTES_INFORMATION NewUserState, PTOKEN_SECURITY_ATTRIBUTES_INFORMATION NewDeviceState, PTOKEN_GROUPS NewDeviceGroupsState, ULONG UserBufferLength, PTOKEN_SECURITY_ATTRIBUTES_INFORMATION PreviousUserState, ULONG DeviceBufferLength, PTOKEN_SECURITY_ATTRIBUTES_INFORMATION PreviousDeviceState, ULONG DeviceGroupsBufferLength, PTOKEN_GROUPS PreviousDeviceGroups, PULONG UserReturnLength, PULONG DeviceReturnLength, PULONG DeviceGroupsReturnBufferLength);
    NTSTATUS WINAPI NtAlertResumeThread(HANDLE ThreadHandle, PULONG PreviousSuspendCount);
    NTSTATUS WINAPI NtAlertThread(HANDLE ThreadHandle);
    NTSTATUS WINAPI NtAlertThreadByThreadId(HANDLE ThreadId);
    NTSTATUS WINAPI NtAllocateLocallyUniqueId(PLUID Luid);
    NTSTATUS WINAPI NtAllocateReserveObject(PHANDLE MemoryReserveHandle, POBJECT_ATTRIBUTES ObjectAttributes, MEMORY_RESERVE_TYPE Type);
    NTSTATUS WINAPI NtAllocateUserPhysicalPages(HANDLE ProcessHandle, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);
    NTSTATUS WINAPI NtAllocateUuids(PULARGE_INTEGER Time, PULONG Range, PULONG Sequence, PCHAR Seed);
    NTSTATUS WINAPI NtAllocateVirtualMemory(HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits, PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect);
    NTSTATUS WINAPI NtAlpcAcceptConnectPort(PHANDLE PortHandle, HANDLE ConnectionPortHandle, ULONG Flags, POBJECT_ATTRIBUTES ObjectAttributes, PALPC_PORT_ATTRIBUTES PortAttributes, PVOID PortContext, PPORT_MESSAGE ConnectionRequest, PALPC_MESSAGE_ATTRIBUTES ConnectionMessageAttributes, BOOLEAN AcceptConnection);
    NTSTATUS WINAPI NtAlpcCancelMessage(HANDLE PortHandle, ULONG Flags, PALPC_CONTEXT_ATTR MessageContext);
    NTSTATUS WINAPI NtAlpcConnectPort(PHANDLE PortHandle, PUNICODE_STRING PortName, POBJECT_ATTRIBUTES ObjectAttributes, PALPC_PORT_ATTRIBUTES PortAttributes, ULONG Flags, PSID RequiredServerSid, PPORT_MESSAGE ConnectionMessage, PULONG BufferLength, PALPC_MESSAGE_ATTRIBUTES OutMessageAttributes, PALPC_MESSAGE_ATTRIBUTES InMessageAttributes, PLARGE_INTEGER Timeout);
    NTSTATUS WINAPI NtAlpcConnectPortEx(PHANDLE PortHandle, POBJECT_ATTRIBUTES ConnectionPortObjectAttributes, POBJECT_ATTRIBUTES ClientPortObjectAttributes, PALPC_PORT_ATTRIBUTES PortAttributes, ULONG Flags, PSECURITY_DESCRIPTOR ServerSecurityRequirements, PPORT_MESSAGE ConnectionMessage, PSIZE_T BufferLength, PALPC_MESSAGE_ATTRIBUTES OutMessageAttributes, PALPC_MESSAGE_ATTRIBUTES InMessageAttributes, PLARGE_INTEGER Timeout);
    NTSTATUS WINAPI NtAlpcCreatePort(PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, PALPC_PORT_ATTRIBUTES PortAttributes);
    NTSTATUS WINAPI NtAlpcCreatePortSection(HANDLE PortHandle, ULONG Flags, HANDLE SectionHandle, SIZE_T SectionSize, PALPC_HANDLE AlpcSectionHandle, PSIZE_T ActualSectionSize);
    NTSTATUS WINAPI NtAlpcCreateResourceReserve(HANDLE PortHandle, ULONG Flags, SIZE_T MessageSize, PALPC_HANDLE ResourceId);
    NTSTATUS WINAPI NtAlpcCreateSectionView(HANDLE PortHandle, ULONG Flags, PALPC_DATA_VIEW_ATTR ViewAttributes);
    NTSTATUS WINAPI NtAlpcCreateSecurityContext(HANDLE PortHandle, ULONG Flags, PALPC_SECURITY_ATTR SecurityAttribute);
    NTSTATUS WINAPI NtAlpcDeletePortSection(HANDLE PortHandle, ULONG Flags, ALPC_HANDLE SectionHandle);
    NTSTATUS WINAPI NtAlpcDeleteResourceReserve(HANDLE PortHandle, ULONG Flags, ALPC_HANDLE ResourceId);
    NTSTATUS WINAPI NtAlpcDeleteSectionView(HANDLE PortHandle, ULONG Flags, PVOID ViewBase);
    NTSTATUS WINAPI NtAlpcDeleteSecurityContext(HANDLE PortHandle, ULONG Flags, ALPC_HANDLE ContextHandle);
    NTSTATUS WINAPI NtAlpcDisconnectPort(HANDLE PortHandle, ULONG Flags);
    NTSTATUS WINAPI NtAlpcImpersonateClientContainerOfPort(HANDLE PortHandle, PPORT_MESSAGE Message, ULONG Flags);
    NTSTATUS WINAPI NtAlpcImpersonateClientOfPort(HANDLE PortHandle, PPORT_MESSAGE Message, PVOID Flags);
    NTSTATUS WINAPI NtAlpcOpenSenderProcess(PHANDLE ProcessHandle, HANDLE PortHandle, PPORT_MESSAGE PortMessage, ULONG Flags, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);
    NTSTATUS WINAPI NtAlpcOpenSenderThread(PHANDLE ThreadHandle, HANDLE PortHandle, PPORT_MESSAGE PortMessage, ULONG Flags, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);
    NTSTATUS WINAPI NtAlpcQueryInformation(HANDLE PortHandle, ALPC_PORT_INFORMATION_CLASS PortInformationClass, PVOID PortInformation, ULONG Length, PULONG ReturnLength);
    NTSTATUS WINAPI NtAlpcQueryInformationMessage(HANDLE PortHandle, PPORT_MESSAGE PortMessage, ALPC_MESSAGE_INFORMATION_CLASS MessageInformationClass, PVOID MessageInformation, ULONG Length, PULONG ReturnLength);
    NTSTATUS WINAPI NtAlpcRevokeSecurityContext(HANDLE PortHandle, ULONG Flags, ALPC_HANDLE ContextHandle);
    NTSTATUS WINAPI NtAlpcSendWaitReceivePort(HANDLE PortHandle, ULONG Flags, PPORT_MESSAGE SendMessageA, PALPC_MESSAGE_ATTRIBUTES SendMessageAttributes, PPORT_MESSAGE ReceiveMessage, PSIZE_T BufferLength, PALPC_MESSAGE_ATTRIBUTES ReceiveMessageAttributes, PLARGE_INTEGER Timeout);
    NTSTATUS WINAPI NtAlpcSetInformation(HANDLE PortHandle, ALPC_PORT_INFORMATION_CLASS PortInformationClass, PVOID PortInformation, ULONG Length);
    NTSTATUS WINAPI NtAreMappedFilesTheSame(PVOID File1MappedAsAnImage, PVOID File2MappedAsFile);
    NTSTATUS WINAPI NtAssignProcessToJobObject(HANDLE JobHandle, HANDLE ProcessHandle);
    NTSTATUS WINAPI NtAssociateWaitCompletionPacket(HANDLE WaitCompletionPacketHandle, HANDLE IoCompletionHandle, HANDLE TargetObjectHandle, PVOID KeyContext, PVOID ApcContext, NTSTATUS IoStatus, ULONG_PTR IoStatusInformation, PBOOLEAN AlreadySignaled);
    NTSTATUS WINAPI NtCallEnclave(PENCLAVE_ROUTINE Routine, PVOID Parameter, BOOLEAN WaitForThread, PVOID* ReturnValue);
    NTSTATUS WINAPI NtCallbackReturn(PVOID OutputBuffer, ULONG OutputLength, NTSTATUS Status);
    NTSTATUS WINAPI NtCancelIoFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock);
    NTSTATUS WINAPI NtCancelIoFileEx(HANDLE FileHandle, PIO_STATUS_BLOCK IoRequestToCancel, PIO_STATUS_BLOCK IoStatusBlock);
    NTSTATUS WINAPI NtCancelSynchronousIoFile(HANDLE ThreadHandle, PIO_STATUS_BLOCK IoRequestToCancel, PIO_STATUS_BLOCK IoStatusBlock);
    NTSTATUS WINAPI NtCancelTimer(HANDLE TimerHandle, PBOOLEAN CurrentState);
    NTSTATUS WINAPI NtCancelTimer2(HANDLE TimerHandle, PT2_CANCEL_PARAMETERS Parameters);
    NTSTATUS WINAPI NtCancelWaitCompletionPacket(HANDLE WaitCompletionPacketHandle, BOOLEAN RemoveSignaledPacket);
    NTSTATUS WINAPI NtClearEvent(HANDLE EventHandle);
    NTSTATUS WINAPI NtClose(HANDLE Handle);
    NTSTATUS WINAPI NtCloseObjectAuditAlarm(PUNICODE_STRING SubsystemName, PVOID HandleId, BOOLEAN GenerateOnClose);
    NTSTATUS WINAPI NtCommitComplete(HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);
    NTSTATUS WINAPI NtCommitEnlistment(HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);
    NTSTATUS WINAPI NtCommitTransaction(HANDLE TransactionHandle, BOOLEAN Wait);
    NTSTATUS WINAPI NtCompactKeys(ULONG Count, HANDLE* KeyArray);
    NTSTATUS WINAPI NtCompareObjects(HANDLE FirstObjectHandle, HANDLE SecondObjectHandle);
    NTSTATUS WINAPI NtCompareTokens(HANDLE FirstTokenHandle, HANDLE SecondTokenHandle, PBOOLEAN Equal);
    NTSTATUS WINAPI NtCompleteConnectPort(HANDLE PortHandle);
    NTSTATUS WINAPI NtCompressKey(HANDLE Key);
    NTSTATUS WINAPI NtConnectPort(PHANDLE PortHandle, PUNICODE_STRING PortName, PSECURITY_QUALITY_OF_SERVICE SecurityQos, PPORT_VIEW ClientView, PREMOTE_PORT_VIEW ServerView, PULONG MaxMessageLength, PVOID ConnectionInformation, PULONG ConnectionInformationLength);
    NTSTATUS WINAPI NtContinue(PCONTEXT ContextRecord, BOOLEAN TestAlert);
    NTSTATUS WINAPI NtCreateDebugObject(PHANDLE DebugObjectHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Flags);
    NTSTATUS WINAPI NtCreateDirectoryObject(PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);
    NTSTATUS WINAPI NtCreateDirectoryObjectEx(PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ShadowDirectoryHandle, ULONG Flags);
    NTSTATUS WINAPI NtCreateEnclave(HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits, SIZE_T Size, SIZE_T InitialCommitment, ULONG EnclaveType, PVOID EnclaveInformation, ULONG EnclaveInformationLength, PULONG EnclaveError);
    NTSTATUS WINAPI NtCreateEnlistment(PHANDLE EnlistmentHandle, ACCESS_MASK DesiredAccess, HANDLE ResourceManagerHandle, HANDLE TransactionHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG CreateOptions, NOTIFICATION_MASK NotificationMask, PVOID EnlistmentKey);
    NTSTATUS WINAPI NtCreateEvent(PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, EVENT_TYPE EventType, BOOLEAN InitialState);
    NTSTATUS WINAPI NtCreateEventPair(PHANDLE EventPairHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);
    NTSTATUS WINAPI NtCreateFile(PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);
    NTSTATUS WINAPI NtCreateIRTimer(PHANDLE TimerHandle, ACCESS_MASK DesiredAccess);
    NTSTATUS WINAPI NtCreateIoCompletion(PHANDLE IoCompletionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Count);
    NTSTATUS WINAPI NtCreateJobObject(PHANDLE JobHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);
    NTSTATUS WINAPI NtCreateJobSet(ULONG NumJob, PJOB_SET_ARRAY UserJobSet, ULONG Flags);
    NTSTATUS WINAPI NtCreateKey(PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG TitleIndex, PUNICODE_STRING Class, ULONG CreateOptions, PULONG Disposition);
    NTSTATUS WINAPI NtCreateKeyTransacted(PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG TitleIndex, PUNICODE_STRING Class, ULONG CreateOptions, HANDLE TransactionHandle, PULONG Disposition);
    NTSTATUS WINAPI NtCreateKeyedEvent(PHANDLE KeyedEventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG Flags);
    NTSTATUS WINAPI NtCreateLowBoxToken(PHANDLE TokenHandle, HANDLE ExistingTokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PSID PackageSid, ULONG CapabilityCount, PSID_AND_ATTRIBUTES Capabilities, ULONG HandleCount, HANDLE* Handles);
    NTSTATUS WINAPI NtCreateMailslotFile(PHANDLE FileHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG CreateOptions, ULONG MailslotQuota, ULONG MaximumMessageSize, PLARGE_INTEGER ReadTimeout);
    NTSTATUS WINAPI NtCreateMutant(PHANDLE MutantHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, BOOLEAN InitialOwner);
    NTSTATUS WINAPI NtCreateNamedPipeFile(PHANDLE FileHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, ULONG NamedPipeType, ULONG ReadMode, ULONG CompletionMode, ULONG MaximumInstances, ULONG InboundQuota, ULONG OutboundQuota, PLARGE_INTEGER DefaultTimeout);
    NTSTATUS WINAPI NtCreatePagingFile(PUNICODE_STRING PageFileName, PLARGE_INTEGER MinimumSize, PLARGE_INTEGER MaximumSize, ULONG Priority);
    NTSTATUS WINAPI NtCreatePartition(PHANDLE PartitionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG PreferredNode);
    NTSTATUS WINAPI NtCreatePort(PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage);
    NTSTATUS WINAPI NtCreatePrivateNamespace(PHANDLE NamespaceHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PVOID BoundaryDescriptor);
    NTSTATUS WINAPI NtCreateProcess(PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ParentProcess, BOOLEAN InheritObjectTable, HANDLE SectionHandle, HANDLE DebugPort, HANDLE ExceptionPort);
    NTSTATUS WINAPI NtCreateProcessEx(PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ParentProcess, ULONG Flags, HANDLE SectionHandle, HANDLE DebugPort, HANDLE ExceptionPort, ULONG JobMemberLevel);
    NTSTATUS WINAPI NtCreateProfile(PHANDLE ProfileHandle, HANDLE Process, PVOID ProfileBase, SIZE_T ProfileSize, ULONG BucketSize, PULONG Buffer, ULONG BufferSize, KPROFILE_SOURCE ProfileSource, KAFFINITY Affinity);
    NTSTATUS WINAPI NtCreateProfileEx(PHANDLE ProfileHandle, HANDLE Process, PVOID ProfileBase, SIZE_T ProfileSize, ULONG BucketSize, PULONG Buffer, ULONG BufferSize, KPROFILE_SOURCE ProfileSource, USHORT GroupCount, PGROUP_AFFINITY GroupAffinity);
    NTSTATUS WINAPI NtCreateResourceManager(PHANDLE ResourceManagerHandle, ACCESS_MASK DesiredAccess, HANDLE TmHandle, LPGUID RmGuid, POBJECT_ATTRIBUTES ObjectAttributes, ULONG CreateOptions, PUNICODE_STRING Description);
    NTSTATUS WINAPI NtCreateSection(PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PLARGE_INTEGER MaximumSize, ULONG SectionPageProtection, ULONG AllocationAttributes, HANDLE FileHandle);
    NTSTATUS WINAPI NtCreateSectionEx(PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PLARGE_INTEGER MaximumSize, ULONG SectionPageProtection, ULONG AllocationAttributes, HANDLE FileHandle, PMEM_EXTENDED_PARAMETER ExtendedParameters, ULONG ExtendedParameterCount);
    NTSTATUS WINAPI NtCreateSemaphore(PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LONG InitialCount, LONG MaximumCount);
    NTSTATUS WINAPI NtCreateSymbolicLinkObject(PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LinkTarget);
    NTSTATUS WINAPI NtCreateThread(PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PCLIENT_ID ClientId, PCONTEXT ThreadContext, PINITIAL_TEB InitialTeb, BOOLEAN CreateSuspended);
    NTSTATUS WINAPI NtCreateThreadEx(PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PVOID StartRoutine, PVOID Argument, ULONG CreateFlags, SIZE_T ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, PPS_ATTRIBUTE_LIST AttributeList);
    NTSTATUS WINAPI NtCreateTimer(PHANDLE TimerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TIMER_TYPE TimerType);
    NTSTATUS WINAPI NtCreateTimer2(PHANDLE TimerHandle, PVOID Reserved1, PVOID Reserved2, ULONG Attributes, ACCESS_MASK DesiredAccess);
    NTSTATUS WINAPI NtCreateToken(PHANDLE TokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TOKEN_TYPE TokenType, PLUID AuthenticationId, PLARGE_INTEGER ExpirationTime, PTOKEN_USER User, PTOKEN_GROUPS Groups, PTOKEN_PRIVILEGES Privileges, PTOKEN_OWNER Owner, PTOKEN_PRIMARY_GROUP PrimaryGroup, PTOKEN_DEFAULT_DACL DefaultDacl, PTOKEN_SOURCE TokenSource);
    NTSTATUS WINAPI NtCreateTokenEx(PHANDLE TokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, TOKEN_TYPE TokenType, PLUID AuthenticationId, PLARGE_INTEGER ExpirationTime, PTOKEN_USER User, PTOKEN_GROUPS Groups, PTOKEN_PRIVILEGES Privileges, PTOKEN_SECURITY_ATTRIBUTES_INFORMATION UserAttributes, PTOKEN_SECURITY_ATTRIBUTES_INFORMATION DeviceAttributes, PTOKEN_GROUPS DeviceGroups, PTOKEN_MANDATORY_POLICY TokenMandatoryPolicy, PTOKEN_OWNER Owner, PTOKEN_PRIMARY_GROUP PrimaryGroup, PTOKEN_DEFAULT_DACL DefaultDacl, PTOKEN_SOURCE TokenSource);
    NTSTATUS WINAPI NtCreateTransaction(PHANDLE TransactionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LPGUID Uow, HANDLE TmHandle, ULONG CreateOptions, ULONG IsolationLevel, ULONG IsolationFlags, PLARGE_INTEGER Timeout, PUNICODE_STRING Description);
    NTSTATUS WINAPI NtCreateTransactionManager(PHANDLE TmHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LogFileName, ULONG CreateOptions, ULONG CommitStrength);
    NTSTATUS WINAPI NtCreateUserProcess(PHANDLE ProcessHandle, PHANDLE ThreadHandle, ACCESS_MASK ProcessDesiredAccess, ACCESS_MASK ThreadDesiredAccess, POBJECT_ATTRIBUTES ProcessObjectAttributes, POBJECT_ATTRIBUTES ThreadObjectAttributes, ULONG ProcessFlags, ULONG ThreadFlags, PVOID ProcessParameters, PPS_CREATE_INFO CreateInfo, PPS_ATTRIBUTE_LIST AttributeList);
    NTSTATUS WINAPI NtCreateWaitCompletionPacket(PHANDLE WaitCompletionPacketHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);
    NTSTATUS WINAPI NtCreateWaitablePort(PHANDLE PortHandle, POBJECT_ATTRIBUTES ObjectAttributes, ULONG MaxConnectionInfoLength, ULONG MaxMessageLength, ULONG MaxPoolUsage);
    NTSTATUS WINAPI NtCreateWnfStateName(PWNF_STATE_NAME StateName, WNF_STATE_NAME_LIFETIME NameLifetime, WNF_DATA_SCOPE DataScope, BOOLEAN PersistData, PCWNF_TYPE_ID TypeId, ULONG MaximumStateSize, PSECURITY_DESCRIPTOR SecurityDescriptor);
    NTSTATUS WINAPI NtCreateWorkerFactory(PHANDLE WorkerFactoryHandleReturn, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE CompletionPortHandle, HANDLE WorkerProcessHandle, PVOID StartRoutine, PVOID StartParameter, ULONG MaxThreadCount, SIZE_T StackReserve, SIZE_T StackCommit);
    NTSTATUS WINAPI NtDebugActiveProcess(HANDLE ProcessHandle, HANDLE DebugObjectHandle);
    NTSTATUS WINAPI NtDebugContinue(HANDLE DebugObjectHandle, PCLIENT_ID ClientId, NTSTATUS ContinueStatus);
    NTSTATUS WINAPI NtDelayExecution(BOOLEAN Alertable, PLARGE_INTEGER DelayInterval);
    NTSTATUS WINAPI NtDeleteAtom(RTL_ATOM Atom);
    NTSTATUS WINAPI NtDeleteBootEntry(ULONG Id);
    NTSTATUS WINAPI NtDeleteDriverEntry(ULONG Id);
    NTSTATUS WINAPI NtDeleteFile(POBJECT_ATTRIBUTES ObjectAttributes);
    NTSTATUS WINAPI NtDeleteKey(HANDLE KeyHandle);
    NTSTATUS WINAPI NtDeleteObjectAuditAlarm(PUNICODE_STRING SubsystemName, PVOID HandleId, BOOLEAN GenerateOnClose);
    NTSTATUS WINAPI NtDeletePrivateNamespace(HANDLE NamespaceHandle);
    NTSTATUS WINAPI NtDeleteValueKey(HANDLE KeyHandle, PUNICODE_STRING ValueName);
    NTSTATUS WINAPI NtDeleteWnfStateData(PCWNF_STATE_NAME StateName, void const* ExplicitScope);
    NTSTATUS WINAPI NtDeleteWnfStateName(PCWNF_STATE_NAME StateName);
    NTSTATUS WINAPI NtDeviceIoControlFile(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);
    NTSTATUS WINAPI NtDisableLastKnownGood();
    NTSTATUS WINAPI NtDisplayString(PUNICODE_STRING String);
    NTSTATUS WINAPI NtDrawText(PUNICODE_STRING Text);
    NTSTATUS WINAPI NtDuplicateObject(HANDLE SourceProcessHandle, HANDLE SourceHandle, HANDLE TargetProcessHandle, PHANDLE TargetHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Options);
    NTSTATUS WINAPI NtDuplicateToken(HANDLE ExistingTokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, BOOLEAN EffectiveOnly, TOKEN_TYPE TokenType, PHANDLE NewTokenHandle);
    NTSTATUS WINAPI NtEnableLastKnownGood();
    NTSTATUS WINAPI NtEnumerateBootEntries(PVOID Buffer, PULONG BufferLength);
    NTSTATUS WINAPI NtEnumerateDriverEntries(PVOID Buffer, PULONG BufferLength);
    NTSTATUS WINAPI NtEnumerateKey(HANDLE KeyHandle, ULONG Index, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);
    NTSTATUS WINAPI NtEnumerateSystemEnvironmentValuesEx(ULONG InformationClass, PVOID Buffer, PULONG BufferLength);
    NTSTATUS WINAPI NtEnumerateTransactionObject(HANDLE RootObjectHandle, KTMOBJECT_TYPE QueryType, PKTMOBJECT_CURSOR ObjectCursor, ULONG ObjectCursorLength, PULONG ReturnLength);
    NTSTATUS WINAPI NtEnumerateValueKey(HANDLE KeyHandle, ULONG Index, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);
    NTSTATUS WINAPI NtExtendSection(HANDLE SectionHandle, PLARGE_INTEGER NewSectionSize);
    NTSTATUS WINAPI NtFilterBootOption(FILTER_BOOT_OPTION_OPERATION FilterOperation, ULONG ObjectType, ULONG ElementType, PVOID Data, ULONG DataSize);
    NTSTATUS WINAPI NtFilterToken(HANDLE ExistingTokenHandle, ULONG Flags, PTOKEN_GROUPS SidsToDisable, PTOKEN_PRIVILEGES PrivilegesToDelete, PTOKEN_GROUPS RestrictedSids, PHANDLE NewTokenHandle);
    NTSTATUS WINAPI NtFilterTokenEx(HANDLE ExistingTokenHandle, ULONG Flags, PTOKEN_GROUPS SidsToDisable, PTOKEN_PRIVILEGES PrivilegesToDelete, PTOKEN_GROUPS RestrictedSids, ULONG DisableUserClaimsCount, PUNICODE_STRING UserClaimsToDisable, ULONG DisableDeviceClaimsCount, PUNICODE_STRING DeviceClaimsToDisable, PTOKEN_GROUPS DeviceGroupsToDisable, PTOKEN_SECURITY_ATTRIBUTES_INFORMATION RestrictedUserAttributes, PTOKEN_SECURITY_ATTRIBUTES_INFORMATION RestrictedDeviceAttributes, PTOKEN_GROUPS RestrictedDeviceGroups, PHANDLE NewTokenHandle);
    NTSTATUS WINAPI NtFindAtom(PWSTR AtomName, ULONG Length, PRTL_ATOM Atom);
    NTSTATUS WINAPI NtFlushBuffersFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock);
    NTSTATUS WINAPI NtFlushBuffersFileEx(HANDLE FileHandle, ULONG Flags, PVOID Parameters, ULONG ParametersSize, PIO_STATUS_BLOCK IoStatusBlock);
    NTSTATUS WINAPI NtFlushInstallUILanguage(LANGID InstallUILanguage, ULONG SetComittedFlag);
    NTSTATUS WINAPI NtFlushInstructionCache(HANDLE ProcessHandle, PVOID BaseAddress, SIZE_T Length);
    NTSTATUS WINAPI NtFlushKey(HANDLE KeyHandle);
    void WINAPI NtFlushProcessWriteBuffers();
    NTSTATUS WINAPI NtFlushVirtualMemory(IN HANDLE ProcessHandle,IN OUT PVOID* BaseAddress,IN OUT PSIZE_T RegionSize,OUT PIO_STATUS_BLOCK IoStatus);
    NTSTATUS WINAPI NtFlushWriteBuffer();
    NTSTATUS WINAPI NtFreeUserPhysicalPages(HANDLE ProcessHandle, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);
    NTSTATUS WINAPI NtFreeVirtualMemory(HANDLE ProcessHandle, PVOID* BaseAddress, PSIZE_T RegionSize, ULONG FreeType);
    NTSTATUS WINAPI NtFreezeRegistry(ULONG TimeOutInSeconds);
    NTSTATUS WINAPI NtFreezeTransactions(PLARGE_INTEGER FreezeTimeout, PLARGE_INTEGER ThawTimeout);
    NTSTATUS WINAPI NtFsControlFile(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG FsControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);
    NTSTATUS WINAPI NtGetCachedSigningLevel(HANDLE File, PULONG Flags, PSE_SIGNING_LEVEL SigningLevel, PUCHAR Thumbprint, PULONG ThumbprintSize, PULONG ThumbprintAlgorithm);
    NTSTATUS WINAPI NtGetCompleteWnfStateSubscription(PWNF_STATE_NAME OldDescriptorStateName, ULONG64* OldSubscriptionId, ULONG OldDescriptorEventMask, ULONG OldDescriptorStatus, PWNF_DELIVERY_DESCRIPTOR NewDeliveryDescriptor, ULONG DescriptorSize);
    NTSTATUS WINAPI NtGetContextThread(HANDLE ThreadHandle, PCONTEXT ThreadContext);
    ULONG WINAPI NtGetCurrentProcessorNumber();
    NTSTATUS WINAPI NtGetDevicePowerState(HANDLE Device, PDEVICE_POWER_STATE State);
    NTSTATUS WINAPI NtGetMUIRegistryInfo(ULONG Flags, PULONG DataSize, PVOID Data);
    NTSTATUS WINAPI NtGetNextProcess(HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Flags, PHANDLE NewProcessHandle);
    NTSTATUS WINAPI NtGetNextThread(HANDLE ProcessHandle, HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Flags, PHANDLE NewThreadHandle);
    NTSTATUS WINAPI NtGetNlsSectionPtr(ULONG SectionType, ULONG SectionData, PVOID ContextData, PVOID* SectionPointer, PULONG SectionSize);
    NTSTATUS WINAPI NtGetNotificationResourceManager(HANDLE ResourceManagerHandle, PTRANSACTION_NOTIFICATION TransactionNotification, ULONG NotificationLength, PLARGE_INTEGER Timeout, PULONG ReturnLength, ULONG Asynchronous, ULONG_PTR AsynchronousContext);
    NTSTATUS WINAPI NtGetWriteWatch(HANDLE ProcessHandle, ULONG Flags, PVOID BaseAddress, SIZE_T RegionSize, PVOID* UserAddressArray, PULONG_PTR EntriesInUserAddressArray, PULONG Granularity);
    NTSTATUS WINAPI NtImpersonateAnonymousToken(HANDLE ThreadHandle);
    NTSTATUS WINAPI NtImpersonateClientOfPort(HANDLE PortHandle, PPORT_MESSAGE Message);
    NTSTATUS WINAPI NtImpersonateThread(HANDLE ServerThreadHandle, HANDLE ClientThreadHandle, PSECURITY_QUALITY_OF_SERVICE SecurityQos);
    NTSTATUS WINAPI NtInitializeEnclave(HANDLE ProcessHandle, PVOID BaseAddress, PVOID EnclaveInformation, ULONG EnclaveInformationLength, PULONG EnclaveError);
    NTSTATUS WINAPI NtInitializeNlsFiles(PVOID* BaseAddress, PLCID DefaultLocaleId, PLARGE_INTEGER DefaultCasingTableSize);
    NTSTATUS WINAPI NtInitializeRegistry(USHORT BootCondition);
    NTSTATUS WINAPI NtInitiatePowerAction(POWER_ACTION SystemAction, SYSTEM_POWER_STATE LightestSystemState, ULONG Flags, BOOLEAN Asynchronous);
    NTSTATUS WINAPI NtIsProcessInJob(HANDLE ProcessHandle, HANDLE JobHandle);
    BOOLEAN WINAPI NtIsSystemResumeAutomatic();
    NTSTATUS WINAPI NtIsUILanguageComitted();
    NTSTATUS WINAPI NtListenPort(HANDLE PortHandle, PPORT_MESSAGE ConnectionRequest);
    NTSTATUS WINAPI NtLoadDriver(PUNICODE_STRING DriverServiceName);
    NTSTATUS WINAPI NtLoadEnclaveData(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, ULONG Protect, PVOID PageInformation, ULONG PageInformationLength, PSIZE_T NumberOfBytesWritten, PULONG EnclaveError);
    NTSTATUS WINAPI NtLoadKey(POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile);
    NTSTATUS WINAPI NtLoadKey2(POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile, ULONG Flags);
    NTSTATUS WINAPI NtLoadKeyEx(POBJECT_ATTRIBUTES TargetKey, POBJECT_ATTRIBUTES SourceFile, ULONG Flags, HANDLE TrustClassKey, HANDLE Event, ACCESS_MASK DesiredAccess, PHANDLE RootHandle, PIO_STATUS_BLOCK IoStatus);
    NTSTATUS WINAPI NtLockFile(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER ByteOffset, PLARGE_INTEGER Length, ULONG Key, BOOLEAN FailImmediately, BOOLEAN ExclusiveLock);
    NTSTATUS WINAPI NtLockProductActivationKeys(ULONG* pPrivateVer, ULONG* pSafeMode);
    NTSTATUS WINAPI NtLockRegistryKey(HANDLE KeyHandle);
    NTSTATUS WINAPI NtLockVirtualMemory(HANDLE ProcessHandle, PVOID* BaseAddress, PSIZE_T RegionSize, ULONG MapType);
    NTSTATUS WINAPI NtMakePermanentObject(HANDLE Handle);
    NTSTATUS WINAPI NtMakeTemporaryObject(HANDLE Handle);
    NTSTATUS WINAPI NtManagePartition(MEMORY_PARTITION_INFORMATION_CLASS PartitionInformationClass, PVOID PartitionInformation, ULONG PartitionInformationLength);
    NTSTATUS WINAPI NtMapCMFModule(ULONG What, ULONG Index, PULONG CacheIndexOut, PULONG CacheFlagsOut, PULONG ViewSizeOut, PVOID* BaseAddress);
    NTSTATUS WINAPI NtMapUserPhysicalPages(PVOID VirtualAddress, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);
    NTSTATUS WINAPI NtMapUserPhysicalPagesScatter(PVOID* VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);
    NTSTATUS WINAPI NtMapViewOfSection(HANDLE SectionHandle, HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits, SIZE_T CommitSize, PLARGE_INTEGER SectionOffset, PSIZE_T ViewSize, SECTION_INHERIT InheritDisposition, ULONG AllocationType, ULONG Win32Protect);
    NTSTATUS WINAPI NtModifyBootEntry(PBOOT_ENTRY BootEntry);
    NTSTATUS WINAPI NtModifyDriverEntry(PEFI_DRIVER_ENTRY DriverEntry);
    NTSTATUS WINAPI NtNotifyChangeDirectoryFile(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, ULONG CompletionFilter, BOOLEAN WatchTree);
    NTSTATUS WINAPI NtNotifyChangeDirectoryFileEx(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, ULONG CompletionFilter, BOOLEAN WatchTree, DIRECTORY_NOTIFY_INFORMATION_CLASS DirectoryNotifyInformationClass);
    NTSTATUS WINAPI NtNotifyChangeKey(HANDLE KeyHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG CompletionFilter, BOOLEAN WatchTree, PVOID Buffer, ULONG BufferSize, BOOLEAN Asynchronous);
    NTSTATUS WINAPI NtNotifyChangeMultipleKeys(HANDLE MasterKeyHandle, ULONG Count, OBJECT_ATTRIBUTES* SubordinateObjects, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG CompletionFilter, BOOLEAN WatchTree, PVOID Buffer, ULONG BufferSize, BOOLEAN Asynchronous);
    NTSTATUS WINAPI NtNotifyChangeSession(HANDLE SessionHandle, ULONG ChangeSequenceNumber, PLARGE_INTEGER ChangeTimeStamp, IO_SESSION_EVENT Event, IO_SESSION_STATE NewState, IO_SESSION_STATE PreviousState, PVOID Payload, ULONG PayloadSize);
    NTSTATUS WINAPI NtOpenDirectoryObject(PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);
    NTSTATUS WINAPI NtOpenEnlistment(PHANDLE EnlistmentHandle, ACCESS_MASK DesiredAccess, HANDLE ResourceManagerHandle, LPGUID EnlistmentGuid, POBJECT_ATTRIBUTES ObjectAttributes);
    NTSTATUS WINAPI NtOpenEvent(PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);
    NTSTATUS WINAPI NtOpenEventPair(PHANDLE EventPairHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);
    NTSTATUS WINAPI NtOpenFile(PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG OpenOptions);
    NTSTATUS WINAPI NtOpenIoCompletion(PHANDLE IoCompletionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);
    NTSTATUS WINAPI NtOpenJobObject(PHANDLE JobHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);
    NTSTATUS WINAPI NtOpenKey(PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);
    NTSTATUS WINAPI NtOpenKeyEx(PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG OpenOptions);
    NTSTATUS WINAPI NtOpenKeyTransacted(PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE TransactionHandle);
    NTSTATUS WINAPI NtOpenKeyTransactedEx(PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG OpenOptions, HANDLE TransactionHandle);
    NTSTATUS WINAPI NtOpenKeyedEvent(PHANDLE KeyedEventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);
    NTSTATUS WINAPI NtOpenMutant(PHANDLE MutantHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);
    NTSTATUS WINAPI NtOpenObjectAuditAlarm(PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, HANDLE ClientToken, ACCESS_MASK DesiredAccess, ACCESS_MASK GrantedAccess, PPRIVILEGE_SET Privileges, BOOLEAN ObjectCreation, BOOLEAN AccessGranted, PBOOLEAN GenerateOnClose);
    NTSTATUS WINAPI NtOpenPartition(PHANDLE PartitionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);
    NTSTATUS WINAPI NtOpenPrivateNamespace(PHANDLE NamespaceHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PVOID BoundaryDescriptor);
    NTSTATUS WINAPI NtOpenProcess(PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);
    NTSTATUS WINAPI NtOpenProcessToken(HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, PHANDLE TokenHandle);
    NTSTATUS WINAPI NtOpenProcessTokenEx(HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, PHANDLE TokenHandle);
    NTSTATUS WINAPI NtOpenResourceManager(PHANDLE ResourceManagerHandle, ACCESS_MASK DesiredAccess, HANDLE TmHandle, LPGUID ResourceManagerGuid, POBJECT_ATTRIBUTES ObjectAttributes);
    NTSTATUS WINAPI NtOpenSection(PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);
    NTSTATUS WINAPI NtOpenSemaphore(PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);
    NTSTATUS WINAPI NtOpenSession(PHANDLE SessionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);
    NTSTATUS WINAPI NtOpenSymbolicLinkObject(PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);
    NTSTATUS WINAPI NtOpenThread(PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);
    NTSTATUS WINAPI NtOpenThreadToken(HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, PHANDLE TokenHandle);
    NTSTATUS WINAPI NtOpenThreadTokenEx(HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, ULONG HandleAttributes, PHANDLE TokenHandle);
    NTSTATUS WINAPI NtOpenTimer(PHANDLE TimerHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);
    NTSTATUS WINAPI NtOpenTransaction(PHANDLE TransactionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, LPGUID Uow, HANDLE TmHandle);
    NTSTATUS WINAPI NtOpenTransactionManager(PHANDLE TmHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING LogFileName, LPGUID TmIdentity, ULONG OpenOptions);
    NTSTATUS WINAPI NtPlugPlayControl(PLUGPLAY_CONTROL_CLASS PnPControlClass, PVOID PnPControlData, ULONG PnPControlDataLength);
    NTSTATUS WINAPI NtPowerInformation(POWER_INFORMATION_LEVEL InformationLevel, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);
    NTSTATUS WINAPI NtPrePrepareComplete(HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);
    NTSTATUS WINAPI NtPrePrepareEnlistment(HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);
    NTSTATUS WINAPI NtPrepareComplete(HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);
    NTSTATUS WINAPI NtPrepareEnlistment(HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);
    NTSTATUS WINAPI NtPrivilegeCheck(HANDLE ClientToken, PPRIVILEGE_SET RequiredPrivileges, PBOOLEAN Result);
    NTSTATUS WINAPI NtPrivilegeObjectAuditAlarm(PUNICODE_STRING SubsystemName, PVOID HandleId, HANDLE ClientToken, ACCESS_MASK DesiredAccess, PPRIVILEGE_SET Privileges, BOOLEAN AccessGranted);
    NTSTATUS WINAPI NtPrivilegedServiceAuditAlarm(PUNICODE_STRING SubsystemName, PUNICODE_STRING ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOLEAN AccessGranted);
    NTSTATUS WINAPI NtPropagationComplete(HANDLE ResourceManagerHandle, ULONG RequestCookie, ULONG BufferLength, PVOID Buffer);
    NTSTATUS WINAPI NtPropagationFailed(HANDLE ResourceManagerHandle, ULONG RequestCookie, NTSTATUS PropStatus);
    NTSTATUS WINAPI NtProtectVirtualMemory(HANDLE ProcessHandle, PVOID* BaseAddress, PSIZE_T RegionSize, ULONG NewProtect, PULONG OldProtect);
    NTSTATUS WINAPI NtPulseEvent(HANDLE EventHandle, PLONG PreviousState);
    NTSTATUS WINAPI NtQueryAttributesFile(POBJECT_ATTRIBUTES ObjectAttributes, PFILE_BASIC_INFORMATION FileInformation);
    NTSTATUS WINAPI NtQueryBootEntryOrder(PULONG Ids, PULONG Count);
    NTSTATUS WINAPI NtQueryBootOptions(PBOOT_OPTIONS BootOptions, PULONG BootOptionsLength);
    NTSTATUS WINAPI NtQueryDebugFilterState(ULONG ComponentId, ULONG Level);
    NTSTATUS WINAPI NtQueryDefaultLocale(BOOLEAN UserProfile, PLCID DefaultLocaleId);
    NTSTATUS WINAPI NtQueryDefaultUILanguage(LANGID* DefaultUILanguageId);
    NTSTATUS WINAPI NtQueryDirectoryFile(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass, BOOLEAN ReturnSingleEntry, PUNICODE_STRING FileName, BOOLEAN RestartScan);
    NTSTATUS WINAPI NtQueryDirectoryFileEx(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass, ULONG QueryFlags, PUNICODE_STRING FileName);
    NTSTATUS WINAPI NtQueryDirectoryObject(HANDLE DirectoryHandle, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, BOOLEAN RestartScan, PULONG Context, PULONG ReturnLength);
    NTSTATUS WINAPI NtQueryDriverEntryOrder(PULONG Ids, PULONG Count);
    NTSTATUS WINAPI NtQueryEaFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, PVOID EaList, ULONG EaListLength, PULONG EaIndex, BOOLEAN RestartScan);
    NTSTATUS WINAPI NtQueryEvent(HANDLE EventHandle, EVENT_INFORMATION_CLASS EventInformationClass, PVOID EventInformation, ULONG EventInformationLength, PULONG ReturnLength);
    NTSTATUS WINAPI NtQueryFullAttributesFile(POBJECT_ATTRIBUTES ObjectAttributes, PFILE_NETWORK_OPEN_INFORMATION FileInformation);
    NTSTATUS WINAPI NtQueryInformationAtom(RTL_ATOM Atom, ATOM_INFORMATION_CLASS AtomInformationClass, PVOID AtomInformation, ULONG AtomInformationLength, PULONG ReturnLength);
    NTSTATUS WINAPI NtQueryInformationByName(POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);
    NTSTATUS WINAPI NtQueryInformationEnlistment(HANDLE EnlistmentHandle, ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass, PVOID EnlistmentInformation, ULONG EnlistmentInformationLength, PULONG ReturnLength);
    NTSTATUS WINAPI NtQueryInformationFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);
    NTSTATUS WINAPI NtQueryInformationJobObject(HANDLE JobHandle, JOBOBJECTINFOCLASS JobObjectInformationClass, PVOID JobObjectInformation, ULONG JobObjectInformationLength, PULONG ReturnLength);
    NTSTATUS WINAPI NtQueryInformationPort(HANDLE PortHandle, PORT_INFORMATION_CLASS PortInformationClass, PVOID PortInformation, ULONG Length, PULONG ReturnLength);
    NTSTATUS WINAPI NtQueryInformationProcess(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);
    NTSTATUS WINAPI NtQueryInformationResourceManager(HANDLE ResourceManagerHandle, RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass, PVOID ResourceManagerInformation, ULONG ResourceManagerInformationLength, PULONG ReturnLength);
    NTSTATUS WINAPI NtQueryInformationThread(HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength, PULONG ReturnLength);
    NTSTATUS WINAPI NtQueryInformationToken(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, PVOID TokenInformation, ULONG TokenInformationLength, PULONG ReturnLength);
    NTSTATUS WINAPI NtQueryInformationTransaction(HANDLE TransactionHandle, TRANSACTION_INFORMATION_CLASS TransactionInformationClass, PVOID TransactionInformation, ULONG TransactionInformationLength, PULONG ReturnLength);
    NTSTATUS WINAPI NtQueryInformationTransactionManager(HANDLE TransactionManagerHandle, TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass, PVOID TransactionManagerInformation, ULONG TransactionManagerInformationLength, PULONG ReturnLength);
    NTSTATUS WINAPI NtQueryInformationWorkerFactory(HANDLE WorkerFactoryHandle, WORKERFACTORYINFOCLASS WorkerFactoryInformationClass, PVOID WorkerFactoryInformation, ULONG WorkerFactoryInformationLength, PULONG ReturnLength);
    NTSTATUS WINAPI NtQueryInstallUILanguage(LANGID* InstallUILanguageId);
    NTSTATUS WINAPI NtQueryIntervalProfile(KPROFILE_SOURCE ProfileSource, PULONG Interval);
    NTSTATUS WINAPI NtQueryIoCompletion(HANDLE IoCompletionHandle, IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass, PVOID IoCompletionInformation, ULONG IoCompletionInformationLength, PULONG ReturnLength);
    NTSTATUS WINAPI NtQueryKey(HANDLE KeyHandle, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);
    NTSTATUS WINAPI NtQueryLicenseValue(PUNICODE_STRING ValueName, PULONG Type, PVOID Data, ULONG DataSize, PULONG ResultDataSize);
    NTSTATUS WINAPI NtQueryMultipleValueKey(HANDLE KeyHandle, PKEY_VALUE_ENTRY ValueEntries, ULONG EntryCount, PVOID ValueBuffer, PULONG BufferLength, PULONG RequiredBufferLength);
    NTSTATUS WINAPI NtQueryMutant(HANDLE MutantHandle, MUTANT_INFORMATION_CLASS MutantInformationClass, PVOID MutantInformation, ULONG MutantInformationLength, PULONG ReturnLength);
    NTSTATUS WINAPI NtQueryObject(HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength, PULONG ReturnLength);
    NTSTATUS WINAPI NtQueryOpenSubKeys(POBJECT_ATTRIBUTES TargetKey, PULONG HandleCount);
    NTSTATUS WINAPI NtQueryOpenSubKeysEx(POBJECT_ATTRIBUTES TargetKey, ULONG BufferLength, PVOID Buffer, PULONG RequiredSize);
    NTSTATUS WINAPI NtQueryPerformanceCounter(PLARGE_INTEGER PerformanceCounter, PLARGE_INTEGER PerformanceFrequency);
    NTSTATUS WINAPI NtQueryPortInformationProcess();
    NTSTATUS WINAPI NtQueryQuotaInformationFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry, PVOID SidList, ULONG SidListLength, PSID StartSid, BOOLEAN RestartScan);
    NTSTATUS WINAPI NtQuerySection(HANDLE SectionHandle, SECTION_INFORMATION_CLASS SectionInformationClass, PVOID SectionInformation, SIZE_T SectionInformationLength, PSIZE_T ReturnLength);
    NTSTATUS WINAPI NtQuerySecurityAttributesToken(HANDLE TokenHandle, PUNICODE_STRING Attributes, ULONG NumberOfAttributes, PVOID Buffer, ULONG Length, PULONG ReturnLength);
    NTSTATUS WINAPI NtQuerySecurityObject(HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor, ULONG Length, PULONG LengthNeeded);
    NTSTATUS WINAPI NtQuerySemaphore(HANDLE SemaphoreHandle, SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass, PVOID SemaphoreInformation, ULONG SemaphoreInformationLength, PULONG ReturnLength);
    NTSTATUS WINAPI NtQuerySymbolicLinkObject(HANDLE LinkHandle, PUNICODE_STRING LinkTarget, PULONG ReturnedLength);
    NTSTATUS WINAPI NtQuerySystemEnvironmentValue(PUNICODE_STRING VariableName, PWSTR VariableValue, USHORT ValueLength, PUSHORT ReturnLength);
    NTSTATUS WINAPI NtQuerySystemEnvironmentValueEx(PUNICODE_STRING VariableName, LPGUID VendorGuid, PVOID Value, PULONG ValueLength, PULONG Attributes);
    NTSTATUS WINAPI NtQuerySystemInformation(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);
    NTSTATUS WINAPI NtQuerySystemInformationEx(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID InputBuffer, ULONG InputBufferLength, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);
    NTSTATUS WINAPI NtQueryTimer(HANDLE TimerHandle, TIMER_INFORMATION_CLASS TimerInformationClass, PVOID TimerInformation, ULONG TimerInformationLength, PULONG ReturnLength);
    NTSTATUS WINAPI NtQueryTimerResolution(PULONG MaximumTime, PULONG MinimumTime, PULONG CurrentTime);
    NTSTATUS WINAPI NtQueryValueKey(HANDLE KeyHandle, PUNICODE_STRING ValueName, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);
    NTSTATUS WINAPI NtQueryVirtualMemory(HANDLE ProcessHandle, PVOID BaseAddress, MEMORY_INFORMATION_CLASS MemoryInformationClass, PVOID MemoryInformation, SIZE_T MemoryInformationLength, PSIZE_T ReturnLength);
    NTSTATUS WINAPI NtQueryVolumeInformationFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FsInformation, ULONG Length, FSINFOCLASS FsInformationClass);
    NTSTATUS WINAPI NtQueryWnfStateData(PCWNF_STATE_NAME StateName, PCWNF_TYPE_ID TypeId, void const* ExplicitScope, PWNF_CHANGE_STAMP ChangeStamp, PVOID Buffer, PULONG BufferSize);
    NTSTATUS WINAPI NtQueryWnfStateNameInformation(PCWNF_STATE_NAME StateName, WNF_STATE_NAME_INFORMATION NameInfoClass, void const* ExplicitScope, PVOID InfoBuffer, ULONG InfoBufferSize);
    NTSTATUS WINAPI NtQueueApcThread(HANDLE ThreadHandle, PPS_APC_ROUTINE ApcRoutine, PVOID ApcArgument1, PVOID ApcArgument2, PVOID ApcArgument3);
    NTSTATUS WINAPI NtQueueApcThreadEx(HANDLE ThreadHandle, HANDLE UserApcReserveHandle, PPS_APC_ROUTINE ApcRoutine, PVOID ApcArgument1, PVOID ApcArgument2, PVOID ApcArgument3);
    NTSTATUS WINAPI NtRaiseException(PEXCEPTION_RECORD ExceptionRecord, PCONTEXT ContextRecord, BOOLEAN FirstChance);
    NTSTATUS WINAPI NtRaiseHardError(NTSTATUS ErrorStatus, ULONG NumberOfParameters, ULONG UnicodeStringParameterMask, PULONG_PTR Parameters, ULONG ValidResponseOptions, PULONG Response);
    NTSTATUS WINAPI NtReadFile(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);
    NTSTATUS WINAPI NtReadFileScatter(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PFILE_SEGMENT_ELEMENT SegmentArray, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);
    NTSTATUS WINAPI NtReadOnlyEnlistment(HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);
    NTSTATUS WINAPI NtReadRequestData(HANDLE PortHandle, PPORT_MESSAGE Message, ULONG DataEntryIndex, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesRead);
    NTSTATUS WINAPI NtReadVirtualMemory(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesRead);
    NTSTATUS WINAPI NtRecoverEnlistment(HANDLE EnlistmentHandle, PVOID EnlistmentKey);
    NTSTATUS WINAPI NtRecoverResourceManager(HANDLE ResourceManagerHandle);
    NTSTATUS WINAPI NtRecoverTransactionManager(HANDLE TransactionManagerHandle);
    NTSTATUS WINAPI NtRegisterProtocolAddressInformation(HANDLE ResourceManager, PCRM_PROTOCOL_ID ProtocolId, ULONG ProtocolInformationSize, PVOID ProtocolInformation, ULONG CreateOptions);
    NTSTATUS WINAPI NtRegisterThreadTerminatePort(HANDLE PortHandle);
    NTSTATUS WINAPI NtReleaseKeyedEvent(HANDLE KeyedEventHandle, PVOID KeyValue, BOOLEAN Alertable, PLARGE_INTEGER Timeout);
    NTSTATUS WINAPI NtReleaseMutant(HANDLE MutantHandle, PLONG PreviousCount);
    NTSTATUS WINAPI NtReleaseSemaphore(HANDLE SemaphoreHandle, LONG ReleaseCount, PLONG PreviousCount);
    NTSTATUS WINAPI NtReleaseWorkerFactoryWorker(HANDLE WorkerFactoryHandle);
    NTSTATUS WINAPI NtRemoveIoCompletion(HANDLE IoCompletionHandle, PVOID* KeyContext, PVOID* ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER Timeout);
    NTSTATUS WINAPI NtRemoveIoCompletionEx(HANDLE IoCompletionHandle, PFILE_IO_COMPLETION_INFORMATION IoCompletionInformation, ULONG Count, PULONG NumEntriesRemoved, PLARGE_INTEGER Timeout, BOOLEAN Alertable);
    NTSTATUS WINAPI NtRemoveProcessDebug(HANDLE ProcessHandle, HANDLE DebugObjectHandle);
    NTSTATUS WINAPI NtRenameKey(HANDLE KeyHandle, PUNICODE_STRING NewName);
    NTSTATUS WINAPI NtRenameTransactionManager(PUNICODE_STRING LogFileName, LPGUID ExistingTransactionManagerGuid);
    NTSTATUS WINAPI NtReplaceKey(POBJECT_ATTRIBUTES NewFile, HANDLE TargetHandle, POBJECT_ATTRIBUTES OldFile);
    NTSTATUS WINAPI NtReplacePartitionUnit(PUNICODE_STRING TargetInstancePath, PUNICODE_STRING SpareInstancePath, ULONG Flags);
    NTSTATUS WINAPI NtReplyPort(HANDLE PortHandle, PPORT_MESSAGE ReplyMessage);
    NTSTATUS WINAPI NtReplyWaitReceivePort(HANDLE PortHandle, PVOID* PortContext, PPORT_MESSAGE ReplyMessage, PPORT_MESSAGE ReceiveMessage);
    NTSTATUS WINAPI NtReplyWaitReceivePortEx(HANDLE PortHandle, PVOID* PortContext, PPORT_MESSAGE ReplyMessage, PPORT_MESSAGE ReceiveMessage, PLARGE_INTEGER Timeout);
    NTSTATUS WINAPI NtReplyWaitReplyPort(HANDLE PortHandle, PPORT_MESSAGE ReplyMessage);
    NTSTATUS WINAPI NtRequestPort(HANDLE PortHandle, PPORT_MESSAGE RequestMessage);
    NTSTATUS WINAPI NtRequestWaitReplyPort(HANDLE PortHandle, PPORT_MESSAGE RequestMessage, PPORT_MESSAGE ReplyMessage);
    NTSTATUS WINAPI NtResetEvent(HANDLE EventHandle, PLONG PreviousState);
    NTSTATUS WINAPI NtResetWriteWatch(HANDLE ProcessHandle, PVOID BaseAddress, SIZE_T RegionSize);
    NTSTATUS WINAPI NtRestoreKey(HANDLE KeyHandle, HANDLE FileHandle, ULONG Flags);
    NTSTATUS WINAPI NtResumeProcess(HANDLE ProcessHandle);
    NTSTATUS WINAPI NtResumeThread(HANDLE ThreadHandle, PULONG PreviousSuspendCount);
    NTSTATUS WINAPI NtRevertContainerImpersonation();
    NTSTATUS WINAPI NtRollbackComplete(HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);
    NTSTATUS WINAPI NtRollbackEnlistment(HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);
    NTSTATUS WINAPI NtRollbackTransaction(HANDLE TransactionHandle, BOOLEAN Wait);
    NTSTATUS WINAPI NtRollforwardTransactionManager(HANDLE TransactionManagerHandle, PLARGE_INTEGER TmVirtualClock);
    NTSTATUS WINAPI NtSaveKey(HANDLE KeyHandle, HANDLE FileHandle);
    NTSTATUS WINAPI NtSaveKeyEx(HANDLE KeyHandle, HANDLE FileHandle, ULONG Format);
    NTSTATUS WINAPI NtSaveMergedKeys(HANDLE HighPrecedenceKeyHandle, HANDLE LowPrecedenceKeyHandle, HANDLE FileHandle);
    NTSTATUS WINAPI NtSecureConnectPort(PHANDLE PortHandle, PUNICODE_STRING PortName, PSECURITY_QUALITY_OF_SERVICE SecurityQos, PPORT_VIEW ClientView, PSID RequiredServerSid, PREMOTE_PORT_VIEW ServerView, PULONG MaxMessageLength, PVOID ConnectionInformation, PULONG ConnectionInformationLength);
    NTSTATUS WINAPI NtSerializeBoot();
    NTSTATUS WINAPI NtSetBootEntryOrder(PULONG Ids, ULONG Count);
    NTSTATUS WINAPI NtSetBootOptions(PBOOT_OPTIONS BootOptions, ULONG FieldsToChange);
    NTSTATUS WINAPI NtSetCachedSigningLevel(ULONG Flags, SE_SIGNING_LEVEL InputSigningLevel, PHANDLE SourceFiles, ULONG SourceFileCount, HANDLE TargetFile);
    NTSTATUS WINAPI NtSetContextThread(HANDLE ThreadHandle, PCONTEXT ThreadContext);
    NTSTATUS WINAPI NtSetDebugFilterState(ULONG ComponentId, ULONG Level, BOOLEAN State);
    NTSTATUS WINAPI NtSetDefaultHardErrorPort(HANDLE DefaultHardErrorPort);
    NTSTATUS WINAPI NtSetDefaultLocale(BOOLEAN UserProfile, LCID DefaultLocaleId);
    NTSTATUS WINAPI NtSetDefaultUILanguage(LANGID DefaultUILanguageId);
    NTSTATUS WINAPI NtSetDriverEntryOrder(PULONG Ids, ULONG Count);
    NTSTATUS WINAPI NtSetEaFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length);
    NTSTATUS WINAPI NtSetEvent(HANDLE EventHandle, PLONG PreviousState);
    NTSTATUS WINAPI NtSetEventBoostPriority(HANDLE EventHandle);
    NTSTATUS WINAPI NtSetHighEventPair(HANDLE EventPairHandle);
    NTSTATUS WINAPI NtSetHighWaitLowEventPair(HANDLE EventPairHandle);
    NTSTATUS WINAPI NtSetIRTimer(HANDLE TimerHandle, PLARGE_INTEGER DueTime);
    NTSTATUS WINAPI NtSetInformationDebugObject(HANDLE DebugObjectHandle, DEBUGOBJECTINFOCLASS DebugObjectInformationClass, PVOID DebugInformation, ULONG DebugInformationLength, PULONG ReturnLength);
    NTSTATUS WINAPI NtSetInformationEnlistment(HANDLE EnlistmentHandle, ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass, PVOID EnlistmentInformation, ULONG EnlistmentInformationLength);
    NTSTATUS WINAPI NtSetInformationFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);
    NTSTATUS WINAPI NtSetInformationJobObject(HANDLE JobHandle, JOBOBJECTINFOCLASS JobObjectInformationClass, PVOID JobObjectInformation, ULONG JobObjectInformationLength);
    NTSTATUS WINAPI NtSetInformationKey(HANDLE KeyHandle, KEY_SET_INFORMATION_CLASS KeySetInformationClass, PVOID KeySetInformation, ULONG KeySetInformationLength);
    NTSTATUS WINAPI NtSetInformationObject(HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength);
    NTSTATUS WINAPI NtSetInformationProcess(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength);
    NTSTATUS WINAPI NtSetInformationResourceManager(HANDLE ResourceManagerHandle, RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass, PVOID ResourceManagerInformation, ULONG ResourceManagerInformationLength);
    NTSTATUS WINAPI NtSetInformationThread(HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength);
    NTSTATUS WINAPI NtSetInformationToken(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, PVOID TokenInformation, ULONG TokenInformationLength);
    NTSTATUS WINAPI NtSetInformationTransaction(HANDLE TransactionHandle, TRANSACTION_INFORMATION_CLASS TransactionInformationClass, PVOID TransactionInformation, ULONG TransactionInformationLength);
    NTSTATUS WINAPI NtSetInformationTransactionManager(HANDLE TmHandle, TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass, PVOID TransactionManagerInformation, ULONG TransactionManagerInformationLength);
    NTSTATUS WINAPI NtSetInformationVirtualMemory(HANDLE ProcessHandle, VIRTUAL_MEMORY_INFORMATION_CLASS VmInformationClass, ULONG_PTR NumberOfEntries, PMEMORY_RANGE_ENTRY VirtualAddresses, PVOID VmInformation, ULONG VmInformationLength);
    NTSTATUS WINAPI NtSetInformationWorkerFactory(HANDLE WorkerFactoryHandle, WORKERFACTORYINFOCLASS WorkerFactoryInformationClass, PVOID WorkerFactoryInformation, ULONG WorkerFactoryInformationLength);
    NTSTATUS WINAPI NtSetIntervalProfile(ULONG Interval, KPROFILE_SOURCE Source);
    NTSTATUS WINAPI NtSetIoCompletion(HANDLE IoCompletionHandle, PVOID KeyContext, PVOID ApcContext, NTSTATUS IoStatus, ULONG_PTR IoStatusInformation);
    NTSTATUS WINAPI NtSetIoCompletionEx(HANDLE IoCompletionHandle, HANDLE IoCompletionPacketHandle, PVOID KeyContext, PVOID ApcContext, NTSTATUS IoStatus, ULONG_PTR IoStatusInformation);
    NTSTATUS WINAPI NtSetLdtEntries(ULONG Selector0, ULONG Entry0Low, ULONG Entry0Hi, ULONG Selector1, ULONG Entry1Low, ULONG Entry1Hi);
    NTSTATUS WINAPI NtSetLowEventPair(HANDLE EventPairHandle);
    NTSTATUS WINAPI NtSetLowWaitHighEventPair(HANDLE EventPairHandle);
    NTSTATUS WINAPI NtSetQuotaInformationFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length);
    NTSTATUS WINAPI NtSetSecurityObject(HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor);
    NTSTATUS WINAPI NtSetSystemEnvironmentValue(PUNICODE_STRING VariableName, PUNICODE_STRING VariableValue);
    NTSTATUS WINAPI NtSetSystemEnvironmentValueEx(PUNICODE_STRING VariableName, LPGUID VendorGuid, PVOID Value, ULONG ValueLength, ULONG Attributes);
    NTSTATUS WINAPI NtSetSystemInformation(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength);
    NTSTATUS WINAPI NtSetSystemPowerState(POWER_ACTION SystemAction, SYSTEM_POWER_STATE LightestSystemState, ULONG Flags);
    NTSTATUS WINAPI NtSetSystemTime(PLARGE_INTEGER SystemTime, PLARGE_INTEGER PreviousTime);
    NTSTATUS WINAPI NtSetThreadExecutionState(EXECUTION_STATE NewFlags, EXECUTION_STATE* PreviousFlags);
    NTSTATUS WINAPI NtSetTimer(HANDLE TimerHandle, PLARGE_INTEGER DueTime, PTIMER_APC_ROUTINE TimerApcRoutine, PVOID TimerContext, BOOLEAN ResumeTimer, LONG Period, PBOOLEAN PreviousState);
    NTSTATUS WINAPI NtSetTimer2(HANDLE TimerHandle, PLARGE_INTEGER DueTime, PLARGE_INTEGER Period, PT2_SET_PARAMETERS Parameters);
    NTSTATUS WINAPI NtSetTimerEx(HANDLE TimerHandle, TIMER_SET_INFORMATION_CLASS TimerSetInformationClass, PVOID TimerSetInformation, ULONG TimerSetInformationLength);
    NTSTATUS WINAPI NtSetTimerResolution(ULONG DesiredTime, BOOLEAN SetResolution, PULONG ActualTime);
    NTSTATUS WINAPI NtSetUuidSeed(PCHAR Seed);
    NTSTATUS WINAPI NtSetValueKey(HANDLE KeyHandle, PUNICODE_STRING ValueName, ULONG TitleIndex, ULONG Type, PVOID Data, ULONG DataSize);
    NTSTATUS WINAPI NtSetVolumeInformationFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FsInformation, ULONG Length, FSINFOCLASS FsInformationClass);
    NTSTATUS WINAPI NtSetWnfProcessNotificationEvent(HANDLE NotificationEvent);
    NTSTATUS WINAPI NtShutdownSystem(SHUTDOWN_ACTION Action);
    NTSTATUS WINAPI NtShutdownWorkerFactory(HANDLE WorkerFactoryHandle, LONG volatile* PendingWorkerCount);
    NTSTATUS WINAPI NtSignalAndWaitForSingleObject(HANDLE SignalHandle, HANDLE WaitHandle, BOOLEAN Alertable, PLARGE_INTEGER Timeout);
    NTSTATUS WINAPI NtSinglePhaseReject(HANDLE EnlistmentHandle, PLARGE_INTEGER TmVirtualClock);
    NTSTATUS WINAPI NtStartProfile(HANDLE ProfileHandle);
    NTSTATUS WINAPI NtStopProfile(HANDLE ProfileHandle);
    NTSTATUS WINAPI NtSubscribeWnfStateChange(PCWNF_STATE_NAME StateName, WNF_CHANGE_STAMP ChangeStamp, ULONG EventMask, PULONG64 SubscriptionId);
    NTSTATUS WINAPI NtSuspendProcess(HANDLE ProcessHandle);
    NTSTATUS WINAPI NtSuspendThread(HANDLE ThreadHandle, PULONG PreviousSuspendCount);
    NTSTATUS WINAPI NtSystemDebugControl(SYSDBG_COMMAND Command, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength, PULONG ReturnLength);
    NTSTATUS WINAPI NtTerminateEnclave(PVOID BaseAddress, BOOLEAN WaitForThread);
    NTSTATUS WINAPI NtTerminateJobObject(HANDLE JobHandle, NTSTATUS ExitStatus);
    NTSTATUS WINAPI NtTerminateProcess(HANDLE ProcessHandle, NTSTATUS ExitStatus);
    NTSTATUS WINAPI NtTerminateThread(HANDLE ThreadHandle, NTSTATUS ExitStatus);
    NTSTATUS WINAPI NtTestAlert();
    NTSTATUS WINAPI NtThawRegistry();
    NTSTATUS WINAPI NtThawTransactions();
    NTSTATUS WINAPI NtTraceControl(TRACE_CONTROL_INFORMATION_CLASS TraceInformationClass, PVOID InputBuffer, ULONG InputBufferLength, PVOID TraceInformation, ULONG TraceInformationLength, PULONG ReturnLength);
    NTSTATUS WINAPI NtTraceEvent(HANDLE TraceHandle, ULONG Flags, ULONG FieldSize, PVOID Fields);
    NTSTATUS WINAPI NtTranslateFilePath(PFILE_PATH InputFilePath, ULONG OutputType, PFILE_PATH OutputFilePath, PULONG OutputFilePathLength);
    NTSTATUS WINAPI NtUmsThreadYield(PVOID SchedulerParam);
    NTSTATUS WINAPI NtUnloadDriver(PUNICODE_STRING DriverServiceName);
    NTSTATUS WINAPI NtUnloadKey(POBJECT_ATTRIBUTES TargetKey);
    NTSTATUS WINAPI NtUnloadKey2(POBJECT_ATTRIBUTES TargetKey, ULONG Flags);
    NTSTATUS WINAPI NtUnloadKeyEx(POBJECT_ATTRIBUTES TargetKey, HANDLE Event);
    NTSTATUS WINAPI NtUnlockFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER ByteOffset, PLARGE_INTEGER Length, ULONG Key);
    NTSTATUS WINAPI NtUnlockVirtualMemory(HANDLE ProcessHandle, PVOID* BaseAddress, PSIZE_T RegionSize, ULONG MapType);
    NTSTATUS WINAPI NtUnmapViewOfSection(HANDLE ProcessHandle, PVOID BaseAddress);
    NTSTATUS WINAPI NtUnmapViewOfSectionEx(HANDLE ProcessHandle, PVOID BaseAddress, ULONG Flags);
    NTSTATUS WINAPI NtUnsubscribeWnfStateChange(PCWNF_STATE_NAME StateName);
    NTSTATUS WINAPI NtUpdateWnfStateData(PCWNF_STATE_NAME StateName, void const* Buffer, ULONG Length, PCWNF_TYPE_ID TypeId, void const* ExplicitScope, WNF_CHANGE_STAMP MatchingChangeStamp, LOGICAL CheckStamp);
    NTSTATUS WINAPI NtVdmControl(VDMSERVICECLASS Service, PVOID ServiceData);
    NTSTATUS WINAPI NtWaitForAlertByThreadId(PVOID Address, PLARGE_INTEGER Timeout);
    NTSTATUS WINAPI NtWaitForDebugEvent(HANDLE DebugObjectHandle, BOOLEAN Alertable, PLARGE_INTEGER Timeout, PDBGUI_WAIT_STATE_CHANGE WaitStateChange);
    NTSTATUS WINAPI NtWaitForKeyedEvent(HANDLE KeyedEventHandle, PVOID KeyValue, BOOLEAN Alertable, PLARGE_INTEGER Timeout);
    NTSTATUS WINAPI NtWaitForMultipleObjects(ULONG Count, HANDLE* Handles, WAIT_TYPE WaitType, BOOLEAN Alertable, PLARGE_INTEGER Timeout);
    NTSTATUS WINAPI NtWaitForMultipleObjects32(ULONG Count, LONG* Handles, WAIT_TYPE WaitType, BOOLEAN Alertable, PLARGE_INTEGER Timeout);
    NTSTATUS WINAPI NtWaitForSingleObject(HANDLE Handle, BOOLEAN Alertable, PLARGE_INTEGER Timeout);
    NTSTATUS WINAPI NtWaitForWorkViaWorkerFactory(HANDLE WorkerFactoryHandle, struct ::_FILE_IO_COMPLETION_INFORMATION* MiniPacket);
    NTSTATUS WINAPI NtWaitHighEventPair(HANDLE EventPairHandle);
    NTSTATUS WINAPI NtWaitLowEventPair(HANDLE EventPairHandle);
    NTSTATUS WINAPI NtWorkerFactoryWorkerReady(HANDLE WorkerFactoryHandle);
    NTSTATUS WINAPI NtWriteFile(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);
    NTSTATUS WINAPI NtWriteFileGather(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PFILE_SEGMENT_ELEMENT SegmentArray, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);
    NTSTATUS WINAPI NtWriteRequestData(HANDLE PortHandle, PPORT_MESSAGE Message, ULONG DataEntryIndex, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesWritten);
    NTSTATUS WINAPI NtWriteVirtualMemory(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesWritten);
    NTSTATUS WINAPI NtYieldExecution();

#ifdef _M_IX86
    NTSTATUS WINAPI NtWow64NtAllocateVirtualMemory64(HANDLE ProcessHandle, PULONGLONG BaseAddress, ULONGLONG ZeroBits, PULONGLONG RegionSize, ULONG AllocationType, ULONG Protect);
    NTSTATUS WINAPI NtWow64NtFreeVirtualMemory64(HANDLE ProcessHandle, ULONGLONG BaseAddress, PULONGLONG RegionSize, ULONG FreeType);
    NTSTATUS WINAPI NtWow64ReadVirtualMemory64(HANDLE ProcessHandle, ULONGLONG BaseAddress, ULONGLONG Buffer, ULONGLONG BufferSize, PULONGLONG NumberOfBytesRead);
    NTSTATUS WINAPI NtWow64WriteVirtualMemory64(HANDLE ProcessHandle, ULONGLONG BaseAddress, ULONGLONG Buffer, ULONGLONG BufferSize, PULONGLONG NumberOfBytesWritten);
    NTSTATUS WINAPI NtWow64NtProtectVirtualMemory64(HANDLE ProcessHandle, ULONGLONG BaseAddress, PULONGLONG RegionSize, ULONG NewProtect, PULONG OldProtect);
#endif

#ifdef __cplusplus
};
#endif

#pragma warning(pop)

```

`src/HIGU_ntcall/pch.cpp`:

```cpp
#include "pch.h"
```

`src/HIGU_ntcall/pch.h`:

```h
#ifndef PCH_H
#define PCH_H

#include "higu_ntcall.h"


#endif //PCH_H

```

`src/HIGU_ntcall/syscall_table.cpp`:

```cpp
#include "pch.h"
#include "syscall_table.h"


static const char* syscall_table_names[SYSCALL_TABLE_MAX] = {
   "NtAcceptConnectPort",
   "NtAccessCheck",
   "NtAccessCheckAndAuditAlarm",
   "NtAccessCheckByType",
   "NtAccessCheckByTypeAndAuditAlarm",
   "NtAccessCheckByTypeResultList",
   "NtAccessCheckByTypeResultListAndAuditAlarm",
   "NtAccessCheckByTypeResultListAndAuditAlarmByHandle",
   "NtAcquireProcessActivityReference",
   "NtAddAtom",
   "NtAddAtomEx",
   "NtAddBootEntry",
   "NtAddDriverEntry",
   "NtAdjustGroupsToken",
   "NtAdjustPrivilegesToken",
   "NtAdjustTokenClaimsAndDeviceGroups",
   "NtAlertResumeThread",
   "NtAlertThread",
   "NtAlertThreadByThreadId",
   "NtAllocateLocallyUniqueId",
   "NtAllocateReserveObject",
   "NtAllocateUserPhysicalPages",
   "NtAllocateUuids",
   "NtAllocateVirtualMemory",
   "NtAllocateVirtualMemoryEx",
   "NtAlpcAcceptConnectPort",
   "NtAlpcCancelMessage",
   "NtAlpcConnectPort",
   "NtAlpcConnectPortEx",
   "NtAlpcCreatePort",
   "NtAlpcCreatePortSection",
   "NtAlpcCreateResourceReserve",
   "NtAlpcCreateSectionView",
   "NtAlpcCreateSecurityContext",
   "NtAlpcDeletePortSection",
   "NtAlpcDeleteResourceReserve",
   "NtAlpcDeleteSectionView",
   "NtAlpcDeleteSecurityContext",
   "NtAlpcDisconnectPort",
   "NtAlpcImpersonateClientContainerOfPort",
   "NtAlpcImpersonateClientOfPort",
   "NtAlpcOpenSenderProcess",
   "NtAlpcOpenSenderThread",
   "NtAlpcQueryInformation",
   "NtAlpcQueryInformationMessage",
   "NtAlpcRevokeSecurityContext",
   "NtAlpcSendWaitReceivePort",
   "NtAlpcSetInformation",
   "NtApphelpCacheControl",
   "NtAreMappedFilesTheSame",
   "NtAssignProcessToJobObject",
   "NtAssociateWaitCompletionPacket",
   "NtCallEnclave",
   "NtCallbackReturn",
   "NtCancelIoFile",
   "NtCancelIoFileEx",
   "NtCancelSynchronousIoFile",
   "NtCancelTimer",
   "NtCancelTimer2",
   "NtCancelWaitCompletionPacket",
   "NtClearEvent",
   "NtClose",
   "NtCloseObjectAuditAlarm",
   "NtCommitComplete",
   "NtCommitEnlistment",
   "NtCommitRegistryTransaction",
   "NtCommitTransaction",
   "NtCompactKeys",
   "NtCompareObjects",
   "NtCompareSigningLevels",
   "NtCompareTokens",
   "NtCompleteConnectPort",
   "NtCompressKey",
   "NtConnectPort",
   "NtContinue",
   "NtConvertBetweenAuxiliaryCounterAndPerformanceCounter",
   "NtCreateCrossVmEvent",
   "NtCreateDebugObject",
   "NtCreateDirectoryObject",
   "NtCreateDirectoryObjectEx",
   "NtCreateEnclave",
   "NtCreateEnlistment",
   "NtCreateEvent",
   "NtCreateEventPair",
   "NtCreateFile",
   "NtCreateIRTimer",
   "NtCreateIoCompletion",
   "NtCreateJobObject",
   "NtCreateJobSet",
   "NtCreateKey",
   "NtCreateKeyTransacted",
   "NtCreateKeyedEvent",
   "NtCreateLowBoxToken",
   "NtCreateMailslotFile",
   "NtCreateMutant",
   "NtCreateNamedPipeFile",
   "NtCreatePagingFile",
   "NtCreatePartition",
   "NtCreatePort",
   "NtCreatePrivateNamespace",
   "NtCreateProcess",
   "NtCreateProcessEx",
   "NtCreateProfile",
   "NtCreateProfileEx",
   "NtCreateRegistryTransaction",
   "NtCreateResourceManager",
   "NtCreateSection",
   "NtCreateSectionEx",
   "NtCreateSemaphore",
   "NtCreateSymbolicLinkObject",
   "NtCreateThread",
   "NtCreateThreadEx",
   "NtCreateTimer",
   "NtCreateTimer2",
   "NtCreateToken",
   "NtCreateTokenEx",
   "NtCreateTransaction",
   "NtCreateTransactionManager",
   "NtCreateUserProcess",
   "NtCreateWaitCompletionPacket",
   "NtCreateWaitablePort",
   "NtCreateWnfStateName",
   "NtCreateWorkerFactory",
   "NtDebugActiveProcess",
   "NtDebugContinue",
   "NtDelayExecution",
   "NtDeleteAtom",
   "NtDeleteBootEntry",
   "NtDeleteDriverEntry",
   "NtDeleteFile",
   "NtDeleteKey",
   "NtDeleteObjectAuditAlarm",
   "NtDeletePrivateNamespace",
   "NtDeleteValueKey",
   "NtDeleteWnfStateData",
   "NtDeleteWnfStateName",
   "NtDeviceIoControlFile",
   "NtDisableLastKnownGood",
   "NtDisplayString",
   "NtDrawText",
   "NtDuplicateObject",
   "NtDuplicateToken",
   "NtEnableLastKnownGood",
   "NtEnumerateBootEntries",
   "NtEnumerateDriverEntries",
   "NtEnumerateKey",
   "NtEnumerateSystemEnvironmentValuesEx",
   "NtEnumerateTransactionObject",
   "NtEnumerateValueKey",
   "NtExtendSection",
   "NtFilterBootOption",
   "NtFilterToken",
   "NtFilterTokenEx",
   "NtFindAtom",
   "NtFlushBuffersFile",
   "NtFlushBuffersFileEx",
   "NtFlushInstallUILanguage",
   "NtFlushInstructionCache",
   "NtFlushKey",
   "NtFlushProcessWriteBuffers",
   "NtFlushVirtualMemory",
   "NtFlushWriteBuffer",
   "NtFreeUserPhysicalPages",
   "NtFreeVirtualMemory",
   "NtFreezeRegistry",
   "NtFreezeTransactions",
   "NtFsControlFile",
   "NtGetCachedSigningLevel",
   "NtGetCompleteWnfStateSubscription",
   "NtGetContextThread",
   "NtGetCurrentProcessorNumber",
   "NtGetCurrentProcessorNumberEx",
   "NtGetDevicePowerState",
   "NtGetMUIRegistryInfo",
   "NtGetNextProcess",
   "NtGetNextThread",
   "NtGetNlsSectionPtr",
   "NtGetNotificationResourceManager",
   "NtGetWriteWatch",
   "NtImpersonateAnonymousToken",
   "NtImpersonateClientOfPort",
   "NtImpersonateThread",
   "NtInitializeEnclave",
   "NtInitializeNlsFiles",
   "NtInitializeRegistry",
   "NtInitiatePowerAction",
   "NtIsProcessInJob",
   "NtIsSystemResumeAutomatic",
   "NtIsUILanguageComitted",
   "NtListenPort",
   "NtLoadDriver",
   "NtLoadEnclaveData",
   "NtLoadKey",
   "NtLoadKey2",
   "NtLoadKeyEx",
   "NtLockFile",
   "NtLockProductActivationKeys",
   "NtLockRegistryKey",
   "NtLockVirtualMemory",
   "NtMakePermanentObject",
   "NtMakeTemporaryObject",
   "NtManageHotPatch",
   "NtManagePartition",
   "NtMapCMFModule",
   "NtMapUserPhysicalPages",
   "NtMapUserPhysicalPagesScatter",
   "NtMapViewOfSection",
   "NtMapViewOfSectionEx",
   "NtModifyBootEntry",
   "NtModifyDriverEntry",
   "NtNotifyChangeDirectoryFile",
   "NtNotifyChangeDirectoryFileEx",
   "NtNotifyChangeKey",
   "NtNotifyChangeMultipleKeys",
   "NtNotifyChangeSession",
   "NtOpenDirectoryObject",
   "NtOpenEnlistment",
   "NtOpenEvent",
   "NtOpenEventPair",
   "NtOpenFile",
   "NtOpenIoCompletion",
   "NtOpenJobObject",
   "NtOpenKey",
   "NtOpenKeyEx",
   "NtOpenKeyTransacted",
   "NtOpenKeyTransactedEx",
   "NtOpenKeyedEvent",
   "NtOpenMutant",
   "NtOpenObjectAuditAlarm",
   "NtOpenPartition",
   "NtOpenPrivateNamespace",
   "NtOpenProcess",
   "NtOpenProcessToken",
   "NtOpenProcessTokenEx",
   "NtOpenRegistryTransaction",
   "NtOpenResourceManager",
   "NtOpenSection",
   "NtOpenSemaphore",
   "NtOpenSession",
   "NtOpenSymbolicLinkObject",
   "NtOpenThread",
   "NtOpenThreadToken",
   "NtOpenThreadTokenEx",
   "NtOpenTimer",
   "NtOpenTransaction",
   "NtOpenTransactionManager",
   "NtPlugPlayControl",
   "NtPowerInformation",
   "NtPrePrepareComplete",
   "NtPrePrepareEnlistment",
   "NtPrepareComplete",
   "NtPrepareEnlistment",
   "NtPrivilegeCheck",
   "NtPrivilegeObjectAuditAlarm",
   "NtPrivilegedServiceAuditAlarm",
   "NtPropagationComplete",
   "NtPropagationFailed",
   "NtProtectVirtualMemory",
   "NtPulseEvent",
   "NtQueryAttributesFile",
   "NtQueryAuxiliaryCounterFrequency",
   "NtQueryBootEntryOrder",
   "NtQueryBootOptions",
   "NtQueryDebugFilterState",
   "NtQueryDefaultLocale",
   "NtQueryDefaultUILanguage",
   "NtQueryDirectoryFile",
   "NtQueryDirectoryFileEx",
   "NtQueryDirectoryObject",
   "NtQueryDriverEntryOrder",
   "NtQueryEaFile",
   "NtQueryEvent",
   "NtQueryFullAttributesFile",
   "NtQueryInformationAtom",
   "NtQueryInformationByName",
   "NtQueryInformationEnlistment",
   "NtQueryInformationFile",
   "NtQueryInformationJobObject",
   "NtQueryInformationPort",
   "NtQueryInformationProcess",
   "NtQueryInformationResourceManager",
   "NtQueryInformationThread",
   "NtQueryInformationToken",
   "NtQueryInformationTransaction",
   "NtQueryInformationTransactionManager",
   "NtQueryInformationWorkerFactory",
   "NtQueryInstallUILanguage",
   "NtQueryIntervalProfile",
   "NtQueryIoCompletion",
   "NtQueryKey",
   "NtQueryLicenseValue",
   "NtQueryMultipleValueKey",
   "NtQueryMutant",
   "NtQueryObject",
   "NtQueryOpenSubKeys",
   "NtQueryOpenSubKeysEx",
   "NtQueryPerformanceCounter",
   "NtQueryPortInformationProcess",
   "NtQueryQuotaInformationFile",
   "NtQuerySection",
   "NtQuerySecurityAttributesToken",
   "NtQuerySecurityObject",
   "NtQuerySecurityPolicy",
   "NtQuerySemaphore",
   "NtQuerySymbolicLinkObject",
   "NtQuerySystemEnvironmentValue",
   "NtQuerySystemEnvironmentValueEx",
   "NtQuerySystemInformation",
   "NtQuerySystemInformationEx",
   "NtQueryTimer",
   "NtQueryTimerResolution",
   "NtQueryValueKey",
   "NtQueryVirtualMemory",
   "NtQueryVolumeInformationFile",
   "NtQueryWnfStateData",
   "NtQueryWnfStateNameInformation",
   "NtQueueApcThread",
   "NtQueueApcThreadEx",
   "NtRaiseException",
   "NtRaiseHardError",
   "NtReadFile",
   "NtReadFileScatter",
   "NtReadOnlyEnlistment",
   "NtReadRequestData",
   "NtReadVirtualMemory",
   "NtRecoverEnlistment",
   "NtRecoverResourceManager",
   "NtRecoverTransactionManager",
   "NtRegisterProtocolAddressInformation",
   "NtRegisterThreadTerminatePort",
   "NtReleaseKeyedEvent",
   "NtReleaseMutant",
   "NtReleaseSemaphore",
   "NtReleaseWorkerFactoryWorker",
   "NtRemoveIoCompletion",
   "NtRemoveIoCompletionEx",
   "NtRemoveProcessDebug",
   "NtRenameKey",
   "NtRenameTransactionManager",
   "NtReplaceKey",
   "NtReplacePartitionUnit",
   "NtReplyPort",
   "NtReplyWaitReceivePort",
   "NtReplyWaitReceivePortEx",
   "NtReplyWaitReplyPort",
   "NtRequestPort",
   "NtRequestWaitReplyPort",
   "NtResetEvent",
   "NtResetWriteWatch",
   "NtRestoreKey",
   "NtResumeProcess",
   "NtResumeThread",
   "NtRevertContainerImpersonation",
   "NtRollbackComplete",
   "NtRollbackEnlistment",
   "NtRollbackRegistryTransaction",
   "NtRollbackTransaction",
   "NtRollforwardTransactionManager",
   "NtSaveKey",
   "NtSaveKeyEx",
   "NtSaveMergedKeys",
   "NtSecureConnectPort",
   "NtSerializeBoot",
   "NtSetBootEntryOrder",
   "NtSetBootOptions",
   "NtSetCachedSigningLevel",
   "NtSetCachedSigningLevel2",
   "NtSetContextThread",
   "NtSetDebugFilterState",
   "NtSetDefaultHardErrorPort",
   "NtSetDefaultLocale",
   "NtSetDefaultUILanguage",
   "NtSetDriverEntryOrder",
   "NtSetEaFile",
   "NtSetEvent",
   "NtSetEventBoostPriority",
   "NtSetHighEventPair",
   "NtSetHighWaitLowEventPair",
   "NtSetIRTimer",
   "NtSetInformationDebugObject",
   "NtSetInformationEnlistment",
   "NtSetInformationFile",
   "NtSetInformationJobObject",
   "NtSetInformationKey",
   "NtSetInformationObject",
   "NtSetInformationProcess",
   "NtSetInformationResourceManager",
   "NtSetInformationSymbolicLink",
   "NtSetInformationThread",
   "NtSetInformationToken",
   "NtSetInformationTransaction",
   "NtSetInformationTransactionManager",
   "NtSetInformationVirtualMemory",
   "NtSetInformationWorkerFactory",
   "NtSetIntervalProfile",
   "NtSetIoCompletion",
   "NtSetIoCompletionEx",
   "NtSetLdtEntries",
   "NtSetLowEventPair",
   "NtSetLowWaitHighEventPair",
   "NtSetQuotaInformationFile",
   "NtSetSecurityObject",
   "NtSetSystemEnvironmentValue",
   "NtSetSystemEnvironmentValueEx",
   "NtSetSystemInformation",
   "NtSetSystemPowerState",
   "NtSetSystemTime",
   "NtSetThreadExecutionState",
   "NtSetTimer",
   "NtSetTimer2",
   "NtSetTimerEx",
   "NtSetTimerResolution",
   "NtSetUuidSeed",
   "NtSetValueKey",
   "NtSetVolumeInformationFile",
   "NtSetWnfProcessNotificationEvent",
   "NtShutdownSystem",
   "NtShutdownWorkerFactory",
   "NtSignalAndWaitForSingleObject",
   "NtSinglePhaseReject",
   "NtStartProfile",
   "NtStopProfile",
   "NtSubscribeWnfStateChange",
   "NtSuspendProcess",
   "NtSuspendThread",
   "NtSystemDebugControl",
   "NtTerminateEnclave",
   "NtTerminateJobObject",
   "NtTerminateProcess",
   "NtTerminateThread",
   "NtTestAlert",
   "NtThawRegistry",
   "NtThawTransactions",
   "NtTraceControl",
   "NtTraceEvent",
   "NtTranslateFilePath",
   "NtUmsThreadYield",
   "NtUnloadDriver",
   "NtUnloadKey",
   "NtUnloadKey2",
   "NtUnloadKeyEx",
   "NtUnlockFile",
   "NtUnlockVirtualMemory",
   "NtUnmapViewOfSection",
   "NtUnmapViewOfSectionEx",
   "NtUnsubscribeWnfStateChange",
   "NtUpdateWnfStateData",
   "NtVdmControl",
   "NtWaitForAlertByThreadId",
   "NtWaitForDebugEvent",
   "NtWaitForKeyedEvent",
   "NtWaitForMultipleObjects",
   "NtWaitForMultipleObjects32",
   "NtWaitForSingleObject",
   "NtWaitForWorkViaWorkerFactory",
   "NtWaitHighEventPair",
   "NtWaitLowEventPair",
   "NtWorkerFactoryWorkerReady",
   "NtWriteFile",
   "NtWriteFileGather",
   "NtWriteRequestData",
   "NtWriteVirtualMemory",
   "NtYieldExecution"
};

uint32_t syscall_table[SYSCALL_TABLE_MAX] = { (uint32_t)-1 };

extern "C" uint32_t get_syscall_by_name(const char* name) {

    if (!is_syscall_table_initialized()) {

        return -1;
    }

    for (size_t idx = 0; idx < SYSCALL_TABLE_MAX; idx++) {

        if (!strcmp(name, syscall_table_names[idx])) {

            return syscall_table[idx];
        }
    }

    return -1;
}

extern "C" uint32_t get_syscall_by_idx(syscall_table_enum idx) {

    return syscall_table[idx];
}

extern "C" const char* get_syscall_name_by_idx(syscall_table_enum idx) {

    return syscall_table_names[idx];
}

extern "C" void set_syscall_by_idx(syscall_table_enum idx, uint32_t syscall_idx) {

    syscall_table[idx] = syscall_idx;
}
```

`src/HIGU_ntcall/syscall_table.h`:

```h
#pragma once

#include <stdint.h>


 typedef enum _syscall_table_enum {

    SYSCALL_NtAcceptConnectPort,
    SYSCALL_NtAccessCheck,
    SYSCALL_NtAccessCheckAndAuditAlarm,
    SYSCALL_NtAccessCheckByType,
    SYSCALL_NtAccessCheckByTypeAndAuditAlarm,
    SYSCALL_NtAccessCheckByTypeResultList,
    SYSCALL_NtAccessCheckByTypeResultListAndAuditAlarm,
    SYSCALL_NtAccessCheckByTypeResultListAndAuditAlarmByHandle,
    SYSCALL_NtAcquireProcessActivityReference,
    SYSCALL_NtAddAtom,
    SYSCALL_NtAddAtomEx,
    SYSCALL_NtAddBootEntry,
    SYSCALL_NtAddDriverEntry,
    SYSCALL_NtAdjustGroupsToken,
    SYSCALL_NtAdjustPrivilegesToken,
    SYSCALL_NtAdjustTokenClaimsAndDeviceGroups,
    SYSCALL_NtAlertResumeThread,
    SYSCALL_NtAlertThread,
    SYSCALL_NtAlertThreadByThreadId,
    SYSCALL_NtAllocateLocallyUniqueId,
    SYSCALL_NtAllocateReserveObject,
    SYSCALL_NtAllocateUserPhysicalPages,
    SYSCALL_NtAllocateUuids,
    SYSCALL_NtAllocateVirtualMemory,
    SYSCALL_NtAllocateVirtualMemoryEx,
    SYSCALL_NtAlpcAcceptConnectPort,
    SYSCALL_NtAlpcCancelMessage,
    SYSCALL_NtAlpcConnectPort,
    SYSCALL_NtAlpcConnectPortEx,
    SYSCALL_NtAlpcCreatePort,
    SYSCALL_NtAlpcCreatePortSection,
    SYSCALL_NtAlpcCreateResourceReserve,
    SYSCALL_NtAlpcCreateSectionView,
    SYSCALL_NtAlpcCreateSecurityContext,
    SYSCALL_NtAlpcDeletePortSection,
    SYSCALL_NtAlpcDeleteResourceReserve,
    SYSCALL_NtAlpcDeleteSectionView,
    SYSCALL_NtAlpcDeleteSecurityContext,
    SYSCALL_NtAlpcDisconnectPort,
    SYSCALL_NtAlpcImpersonateClientContainerOfPort,
    SYSCALL_NtAlpcImpersonateClientOfPort,
    SYSCALL_NtAlpcOpenSenderProcess,
    SYSCALL_NtAlpcOpenSenderThread,
    SYSCALL_NtAlpcQueryInformation,
    SYSCALL_NtAlpcQueryInformationMessage,
    SYSCALL_NtAlpcRevokeSecurityContext,
    SYSCALL_NtAlpcSendWaitReceivePort,
    SYSCALL_NtAlpcSetInformation,
    SYSCALL_NtApphelpCacheControl,
    SYSCALL_NtAreMappedFilesTheSame,
    SYSCALL_NtAssignProcessToJobObject,
    SYSCALL_NtAssociateWaitCompletionPacket,
    SYSCALL_NtCallEnclave,
    SYSCALL_NtCallbackReturn,
    SYSCALL_NtCancelIoFile,
    SYSCALL_NtCancelIoFileEx,
    SYSCALL_NtCancelSynchronousIoFile,
    SYSCALL_NtCancelTimer,
    SYSCALL_NtCancelTimer2,
    SYSCALL_NtCancelWaitCompletionPacket,
    SYSCALL_NtClearEvent,
    SYSCALL_NtClose,
    SYSCALL_NtCloseObjectAuditAlarm,
    SYSCALL_NtCommitComplete,
    SYSCALL_NtCommitEnlistment,
    SYSCALL_NtCommitRegistryTransaction,
    SYSCALL_NtCommitTransaction,
    SYSCALL_NtCompactKeys,
    SYSCALL_NtCompareObjects,
    SYSCALL_NtCompareSigningLevels,
    SYSCALL_NtCompareTokens,
    SYSCALL_NtCompleteConnectPort,
    SYSCALL_NtCompressKey,
    SYSCALL_NtConnectPort,
    SYSCALL_NtContinue,
    SYSCALL_NtConvertBetweenAuxiliaryCounterAndPerformanceCounter,
    SYSCALL_NtCreateCrossVmEvent,
    SYSCALL_NtCreateDebugObject,
    SYSCALL_NtCreateDirectoryObject,
    SYSCALL_NtCreateDirectoryObjectEx,
    SYSCALL_NtCreateEnclave,
    SYSCALL_NtCreateEnlistment,
    SYSCALL_NtCreateEvent,
    SYSCALL_NtCreateEventPair,
    SYSCALL_NtCreateFile,
    SYSCALL_NtCreateIRTimer,
    SYSCALL_NtCreateIoCompletion,
    SYSCALL_NtCreateJobObject,
    SYSCALL_NtCreateJobSet,
    SYSCALL_NtCreateKey,
    SYSCALL_NtCreateKeyTransacted,
    SYSCALL_NtCreateKeyedEvent,
    SYSCALL_NtCreateLowBoxToken,
    SYSCALL_NtCreateMailslotFile,
    SYSCALL_NtCreateMutant,
    SYSCALL_NtCreateNamedPipeFile,
    SYSCALL_NtCreatePagingFile,
    SYSCALL_NtCreatePartition,
    SYSCALL_NtCreatePort,
    SYSCALL_NtCreatePrivateNamespace,
    SYSCALL_NtCreateProcess,
    SYSCALL_NtCreateProcessEx,
    SYSCALL_NtCreateProfile,
    SYSCALL_NtCreateProfileEx,
    SYSCALL_NtCreateRegistryTransaction,
    SYSCALL_NtCreateResourceManager,
    SYSCALL_NtCreateSection,
    SYSCALL_NtCreateSectionEx,
    SYSCALL_NtCreateSemaphore,
    SYSCALL_NtCreateSymbolicLinkObject,
    SYSCALL_NtCreateThread,
    SYSCALL_NtCreateThreadEx,
    SYSCALL_NtCreateTimer,
    SYSCALL_NtCreateTimer2,
    SYSCALL_NtCreateToken,
    SYSCALL_NtCreateTokenEx,
    SYSCALL_NtCreateTransaction,
    SYSCALL_NtCreateTransactionManager,
    SYSCALL_NtCreateUserProcess,
    SYSCALL_NtCreateWaitCompletionPacket,
    SYSCALL_NtCreateWaitablePort,
    SYSCALL_NtCreateWnfStateName,
    SYSCALL_NtCreateWorkerFactory,
    SYSCALL_NtDebugActiveProcess,
    SYSCALL_NtDebugContinue,
    SYSCALL_NtDelayExecution,
    SYSCALL_NtDeleteAtom,
    SYSCALL_NtDeleteBootEntry,
    SYSCALL_NtDeleteDriverEntry,
    SYSCALL_NtDeleteFile,
    SYSCALL_NtDeleteKey,
    SYSCALL_NtDeleteObjectAuditAlarm,
    SYSCALL_NtDeletePrivateNamespace,
    SYSCALL_NtDeleteValueKey,
    SYSCALL_NtDeleteWnfStateData,
    SYSCALL_NtDeleteWnfStateName,
    SYSCALL_NtDeviceIoControlFile,
    SYSCALL_NtDisableLastKnownGood,
    SYSCALL_NtDisplayString,
    SYSCALL_NtDrawText,
    SYSCALL_NtDuplicateObject,
    SYSCALL_NtDuplicateToken,
    SYSCALL_NtEnableLastKnownGood,
    SYSCALL_NtEnumerateBootEntries,
    SYSCALL_NtEnumerateDriverEntries,
    SYSCALL_NtEnumerateKey,
    SYSCALL_NtEnumerateSystemEnvironmentValuesEx,
    SYSCALL_NtEnumerateTransactionObject,
    SYSCALL_NtEnumerateValueKey,
    SYSCALL_NtExtendSection,
    SYSCALL_NtFilterBootOption,
    SYSCALL_NtFilterToken,
    SYSCALL_NtFilterTokenEx,
    SYSCALL_NtFindAtom,
    SYSCALL_NtFlushBuffersFile,
    SYSCALL_NtFlushBuffersFileEx,
    SYSCALL_NtFlushInstallUILanguage,
    SYSCALL_NtFlushInstructionCache,
    SYSCALL_NtFlushKey,
    SYSCALL_NtFlushProcessWriteBuffers,
    SYSCALL_NtFlushVirtualMemory,
    SYSCALL_NtFlushWriteBuffer,
    SYSCALL_NtFreeUserPhysicalPages,
    SYSCALL_NtFreeVirtualMemory,
    SYSCALL_NtFreezeRegistry,
    SYSCALL_NtFreezeTransactions,
    SYSCALL_NtFsControlFile,
    SYSCALL_NtGetCachedSigningLevel,
    SYSCALL_NtGetCompleteWnfStateSubscription,
    SYSCALL_NtGetContextThread,
    SYSCALL_NtGetCurrentProcessorNumber,
    SYSCALL_NtGetCurrentProcessorNumberEx,
    SYSCALL_NtGetDevicePowerState,
    SYSCALL_NtGetMUIRegistryInfo,
    SYSCALL_NtGetNextProcess,
    SYSCALL_NtGetNextThread,
    SYSCALL_NtGetNlsSectionPtr,
    SYSCALL_NtGetNotificationResourceManager,
    SYSCALL_NtGetWriteWatch,
    SYSCALL_NtImpersonateAnonymousToken,
    SYSCALL_NtImpersonateClientOfPort,
    SYSCALL_NtImpersonateThread,
    SYSCALL_NtInitializeEnclave,
    SYSCALL_NtInitializeNlsFiles,
    SYSCALL_NtInitializeRegistry,
    SYSCALL_NtInitiatePowerAction,
    SYSCALL_NtIsProcessInJob,
    SYSCALL_NtIsSystemResumeAutomatic,
    SYSCALL_NtIsUILanguageComitted,
    SYSCALL_NtListenPort,
    SYSCALL_NtLoadDriver,
    SYSCALL_NtLoadEnclaveData,
    SYSCALL_NtLoadKey,
    SYSCALL_NtLoadKey2,
    SYSCALL_NtLoadKeyEx,
    SYSCALL_NtLockFile,
    SYSCALL_NtLockProductActivationKeys,
    SYSCALL_NtLockRegistryKey,
    SYSCALL_NtLockVirtualMemory,
    SYSCALL_NtMakePermanentObject,
    SYSCALL_NtMakeTemporaryObject,
    SYSCALL_NtManageHotPatch,
    SYSCALL_NtManagePartition,
    SYSCALL_NtMapCMFModule,
    SYSCALL_NtMapUserPhysicalPages,
    SYSCALL_NtMapUserPhysicalPagesScatter,
    SYSCALL_NtMapViewOfSection,
    SYSCALL_NtMapViewOfSectionEx,
    SYSCALL_NtModifyBootEntry,
    SYSCALL_NtModifyDriverEntry,
    SYSCALL_NtNotifyChangeDirectoryFile,
    SYSCALL_NtNotifyChangeDirectoryFileEx,
    SYSCALL_NtNotifyChangeKey,
    SYSCALL_NtNotifyChangeMultipleKeys,
    SYSCALL_NtNotifyChangeSession,
    SYSCALL_NtOpenDirectoryObject,
    SYSCALL_NtOpenEnlistment,
    SYSCALL_NtOpenEvent,
    SYSCALL_NtOpenEventPair,
    SYSCALL_NtOpenFile,
    SYSCALL_NtOpenIoCompletion,
    SYSCALL_NtOpenJobObject,
    SYSCALL_NtOpenKey,
    SYSCALL_NtOpenKeyEx,
    SYSCALL_NtOpenKeyTransacted,
    SYSCALL_NtOpenKeyTransactedEx,
    SYSCALL_NtOpenKeyedEvent,
    SYSCALL_NtOpenMutant,
    SYSCALL_NtOpenObjectAuditAlarm,
    SYSCALL_NtOpenPartition,
    SYSCALL_NtOpenPrivateNamespace,
    SYSCALL_NtOpenProcess,
    SYSCALL_NtOpenProcessToken,
    SYSCALL_NtOpenProcessTokenEx,
    SYSCALL_NtOpenRegistryTransaction,
    SYSCALL_NtOpenResourceManager,
    SYSCALL_NtOpenSection,
    SYSCALL_NtOpenSemaphore,
    SYSCALL_NtOpenSession,
    SYSCALL_NtOpenSymbolicLinkObject,
    SYSCALL_NtOpenThread,
    SYSCALL_NtOpenThreadToken,
    SYSCALL_NtOpenThreadTokenEx,
    SYSCALL_NtOpenTimer,
    SYSCALL_NtOpenTransaction,
    SYSCALL_NtOpenTransactionManager,
    SYSCALL_NtPlugPlayControl,
    SYSCALL_NtPowerInformation,
    SYSCALL_NtPrePrepareComplete,
    SYSCALL_NtPrePrepareEnlistment,
    SYSCALL_NtPrepareComplete,
    SYSCALL_NtPrepareEnlistment,
    SYSCALL_NtPrivilegeCheck,
    SYSCALL_NtPrivilegeObjectAuditAlarm,
    SYSCALL_NtPrivilegedServiceAuditAlarm,
    SYSCALL_NtPropagationComplete,
    SYSCALL_NtPropagationFailed,
    SYSCALL_NtProtectVirtualMemory,
    SYSCALL_NtPulseEvent,
    SYSCALL_NtQueryAttributesFile,
    SYSCALL_NtQueryAuxiliaryCounterFrequency,
    SYSCALL_NtQueryBootEntryOrder,
    SYSCALL_NtQueryBootOptions,
    SYSCALL_NtQueryDebugFilterState,
    SYSCALL_NtQueryDefaultLocale,
    SYSCALL_NtQueryDefaultUILanguage,
    SYSCALL_NtQueryDirectoryFile,
    SYSCALL_NtQueryDirectoryFileEx,
    SYSCALL_NtQueryDirectoryObject,
    SYSCALL_NtQueryDriverEntryOrder,
    SYSCALL_NtQueryEaFile,
    SYSCALL_NtQueryEvent,
    SYSCALL_NtQueryFullAttributesFile,
    SYSCALL_NtQueryInformationAtom,
    SYSCALL_NtQueryInformationByName,
    SYSCALL_NtQueryInformationEnlistment,
    SYSCALL_NtQueryInformationFile,
    SYSCALL_NtQueryInformationJobObject,
    SYSCALL_NtQueryInformationPort,
    SYSCALL_NtQueryInformationProcess,
    SYSCALL_NtQueryInformationResourceManager,
    SYSCALL_NtQueryInformationThread,
    SYSCALL_NtQueryInformationToken,
    SYSCALL_NtQueryInformationTransaction,
    SYSCALL_NtQueryInformationTransactionManager,
    SYSCALL_NtQueryInformationWorkerFactory,
    SYSCALL_NtQueryInstallUILanguage,
    SYSCALL_NtQueryIntervalProfile,
    SYSCALL_NtQueryIoCompletion,
    SYSCALL_NtQueryKey,
    SYSCALL_NtQueryLicenseValue,
    SYSCALL_NtQueryMultipleValueKey,
    SYSCALL_NtQueryMutant,
    SYSCALL_NtQueryObject,
    SYSCALL_NtQueryOpenSubKeys,
    SYSCALL_NtQueryOpenSubKeysEx,
    SYSCALL_NtQueryPerformanceCounter,
    SYSCALL_NtQueryPortInformationProcess,
    SYSCALL_NtQueryQuotaInformationFile,
    SYSCALL_NtQuerySection,
    SYSCALL_NtQuerySecurityAttributesToken,
    SYSCALL_NtQuerySecurityObject,
    SYSCALL_NtQuerySecurityPolicy,
    SYSCALL_NtQuerySemaphore,
    SYSCALL_NtQuerySymbolicLinkObject,
    SYSCALL_NtQuerySystemEnvironmentValue,
    SYSCALL_NtQuerySystemEnvironmentValueEx,
    SYSCALL_NtQuerySystemInformation,
    SYSCALL_NtQuerySystemInformationEx,
    SYSCALL_NtQueryTimer,
    SYSCALL_NtQueryTimerResolution,
    SYSCALL_NtQueryValueKey,
    SYSCALL_NtQueryVirtualMemory,
    SYSCALL_NtQueryVolumeInformationFile,
    SYSCALL_NtQueryWnfStateData,
    SYSCALL_NtQueryWnfStateNameInformation,
    SYSCALL_NtQueueApcThread,
    SYSCALL_NtQueueApcThreadEx,
    SYSCALL_NtRaiseException,
    SYSCALL_NtRaiseHardError,
    SYSCALL_NtReadFile,
    SYSCALL_NtReadFileScatter,
    SYSCALL_NtReadOnlyEnlistment,
    SYSCALL_NtReadRequestData,
    SYSCALL_NtReadVirtualMemory,
    SYSCALL_NtRecoverEnlistment,
    SYSCALL_NtRecoverResourceManager,
    SYSCALL_NtRecoverTransactionManager,
    SYSCALL_NtRegisterProtocolAddressInformation,
    SYSCALL_NtRegisterThreadTerminatePort,
    SYSCALL_NtReleaseKeyedEvent,
    SYSCALL_NtReleaseMutant,
    SYSCALL_NtReleaseSemaphore,
    SYSCALL_NtReleaseWorkerFactoryWorker,
    SYSCALL_NtRemoveIoCompletion,
    SYSCALL_NtRemoveIoCompletionEx,
    SYSCALL_NtRemoveProcessDebug,
    SYSCALL_NtRenameKey,
    SYSCALL_NtRenameTransactionManager,
    SYSCALL_NtReplaceKey,
    SYSCALL_NtReplacePartitionUnit,
    SYSCALL_NtReplyPort,
    SYSCALL_NtReplyWaitReceivePort,
    SYSCALL_NtReplyWaitReceivePortEx,
    SYSCALL_NtReplyWaitReplyPort,
    SYSCALL_NtRequestPort,
    SYSCALL_NtRequestWaitReplyPort,
    SYSCALL_NtResetEvent,
    SYSCALL_NtResetWriteWatch,
    SYSCALL_NtRestoreKey,
    SYSCALL_NtResumeProcess,
    SYSCALL_NtResumeThread,
    SYSCALL_NtRevertContainerImpersonation,
    SYSCALL_NtRollbackComplete,
    SYSCALL_NtRollbackEnlistment,
    SYSCALL_NtRollbackRegistryTransaction,
    SYSCALL_NtRollbackTransaction,
    SYSCALL_NtRollforwardTransactionManager,
    SYSCALL_NtSaveKey,
    SYSCALL_NtSaveKeyEx,
    SYSCALL_NtSaveMergedKeys,
    SYSCALL_NtSecureConnectPort,
    SYSCALL_NtSerializeBoot,
    SYSCALL_NtSetBootEntryOrder,
    SYSCALL_NtSetBootOptions,
    SYSCALL_NtSetCachedSigningLevel,
    SYSCALL_NtSetCachedSigningLevel2,
    SYSCALL_NtSetContextThread,
    SYSCALL_NtSetDebugFilterState,
    SYSCALL_NtSetDefaultHardErrorPort,
    SYSCALL_NtSetDefaultLocale,
    SYSCALL_NtSetDefaultUILanguage,
    SYSCALL_NtSetDriverEntryOrder,
    SYSCALL_NtSetEaFile,
    SYSCALL_NtSetEvent,
    SYSCALL_NtSetEventBoostPriority,
    SYSCALL_NtSetHighEventPair,
    SYSCALL_NtSetHighWaitLowEventPair,
    SYSCALL_NtSetIRTimer,
    SYSCALL_NtSetInformationDebugObject,
    SYSCALL_NtSetInformationEnlistment,
    SYSCALL_NtSetInformationFile,
    SYSCALL_NtSetInformationJobObject,
    SYSCALL_NtSetInformationKey,
    SYSCALL_NtSetInformationObject,
    SYSCALL_NtSetInformationProcess,
    SYSCALL_NtSetInformationResourceManager,
    SYSCALL_NtSetInformationSymbolicLink,
    SYSCALL_NtSetInformationThread,
    SYSCALL_NtSetInformationToken,
    SYSCALL_NtSetInformationTransaction,
    SYSCALL_NtSetInformationTransactionManager,
    SYSCALL_NtSetInformationVirtualMemory,
    SYSCALL_NtSetInformationWorkerFactory,
    SYSCALL_NtSetIntervalProfile,
    SYSCALL_NtSetIoCompletion,
    SYSCALL_NtSetIoCompletionEx,
    SYSCALL_NtSetLdtEntries,
    SYSCALL_NtSetLowEventPair,
    SYSCALL_NtSetLowWaitHighEventPair,
    SYSCALL_NtSetQuotaInformationFile,
    SYSCALL_NtSetSecurityObject,
    SYSCALL_NtSetSystemEnvironmentValue,
    SYSCALL_NtSetSystemEnvironmentValueEx,
    SYSCALL_NtSetSystemInformation,
    SYSCALL_NtSetSystemPowerState,
    SYSCALL_NtSetSystemTime,
    SYSCALL_NtSetThreadExecutionState,
    SYSCALL_NtSetTimer,
    SYSCALL_NtSetTimer2,
    SYSCALL_NtSetTimerEx,
    SYSCALL_NtSetTimerResolution,
    SYSCALL_NtSetUuidSeed,
    SYSCALL_NtSetValueKey,
    SYSCALL_NtSetVolumeInformationFile,
    SYSCALL_NtSetWnfProcessNotificationEvent,
    SYSCALL_NtShutdownSystem,
    SYSCALL_NtShutdownWorkerFactory,
    SYSCALL_NtSignalAndWaitForSingleObject,
    SYSCALL_NtSinglePhaseReject,
    SYSCALL_NtStartProfile,
    SYSCALL_NtStopProfile,
    SYSCALL_NtSubscribeWnfStateChange,
    SYSCALL_NtSuspendProcess,
    SYSCALL_NtSuspendThread,
    SYSCALL_NtSystemDebugControl,
    SYSCALL_NtTerminateEnclave,
    SYSCALL_NtTerminateJobObject,
    SYSCALL_NtTerminateProcess,
    SYSCALL_NtTerminateThread,
    SYSCALL_NtTestAlert,
    SYSCALL_NtThawRegistry,
    SYSCALL_NtThawTransactions,
    SYSCALL_NtTraceControl,
    SYSCALL_NtTraceEvent,
    SYSCALL_NtTranslateFilePath,
    SYSCALL_NtUmsThreadYield,
    SYSCALL_NtUnloadDriver,
    SYSCALL_NtUnloadKey,
    SYSCALL_NtUnloadKey2,
    SYSCALL_NtUnloadKeyEx,
    SYSCALL_NtUnlockFile,
    SYSCALL_NtUnlockVirtualMemory,
    SYSCALL_NtUnmapViewOfSection,
    SYSCALL_NtUnmapViewOfSectionEx,
    SYSCALL_NtUnsubscribeWnfStateChange,
    SYSCALL_NtUpdateWnfStateData,
    SYSCALL_NtVdmControl,
    SYSCALL_NtWaitForAlertByThreadId,
    SYSCALL_NtWaitForDebugEvent,
    SYSCALL_NtWaitForKeyedEvent,
    SYSCALL_NtWaitForMultipleObjects,
    SYSCALL_NtWaitForMultipleObjects32,
    SYSCALL_NtWaitForSingleObject,
    SYSCALL_NtWaitForWorkViaWorkerFactory,
    SYSCALL_NtWaitHighEventPair,
    SYSCALL_NtWaitLowEventPair,
    SYSCALL_NtWorkerFactoryWorkerReady,
    SYSCALL_NtWriteFile,
    SYSCALL_NtWriteFileGather,
    SYSCALL_NtWriteRequestData,
    SYSCALL_NtWriteVirtualMemory,
    SYSCALL_NtYieldExecution,

    SYSCALL_TABLE_MAX

} syscall_table_enum;


extern "C" {

    uint32_t get_syscall_by_name(const char* name); // return -1 if failed

    uint32_t get_syscall_by_idx(syscall_table_enum idx); // return -1 if failed
    
    const char* get_syscall_name_by_idx(syscall_table_enum idx);
    
    void set_syscall_by_idx(syscall_table_enum idx, uint32_t syscall_idx);
};


```

`src/HIGU_ntcall/syscall_table_initialize.cpp`:

```cpp
#include "pch.h"
#include "syscall_table_initialize.h"

static bool syscall_table_initialized = false;

extern "C" bool is_syscall_table_initialized() {
    return syscall_table_initialized;
}

extern "C" bool initialize_syscall_table_auto() {

    if (!syscall_table_initialized) {

        initialize_syscall_table_by_mapped(
            CONTAINING_RECORD(NtCurrentPeb()->Ldr->InLoadOrderModuleList.Flink->Flink, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks)->DllBase //get ntdll by peb Ldr List
        );

        syscall_table_initialized = true;
    }

    return syscall_table_initialized;
}

extern "C" bool initialize_syscall_table_by_mapped(void* ntdll_handle) {

    syscall_table_initialized = false;

    IMAGE_DOS_HEADER* dos_header = (IMAGE_DOS_HEADER*)ntdll_handle;

    if (dos_header->e_magic != IMAGE_DOS_SIGNATURE) {

        return false;
    }


    IMAGE_NT_HEADERS32* nt_header32 = (IMAGE_NT_HEADERS32*)&((uint8_t*)ntdll_handle)[dos_header->e_lfanew];
    IMAGE_NT_HEADERS64* nt_header64 = (IMAGE_NT_HEADERS64*)nt_header32;

    if (nt_header32->Signature != IMAGE_NT_SIGNATURE) {

        return false;
    }

    bool is_x32 = nt_header32->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC;
    

    IMAGE_DATA_DIRECTORY export_data_dir =
        is_x32 ? nt_header32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]
        : nt_header64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];

    if (!export_data_dir.VirtualAddress || !export_data_dir.Size) {

        return false;
    }

    IMAGE_EXPORT_DIRECTORY* export_dir =
        (IMAGE_EXPORT_DIRECTORY*)&((uint8_t*)ntdll_handle)[export_data_dir.VirtualAddress];


    if (!export_dir->AddressOfFunctions ||
        !export_dir->AddressOfNames ||
        !export_dir->AddressOfNameOrdinals ||
        !export_dir->NumberOfNames ||
        !export_dir->NumberOfFunctions) {

        return false;
    }

    uint32_t* functions = (uint32_t*)&((uint8_t*)ntdll_handle)[export_dir->AddressOfFunctions];
    uint32_t* names = (uint32_t*)&((uint8_t*)ntdll_handle)[export_dir->AddressOfNames];
    uint16_t* names_ordinals = (uint16_t*)&((uint8_t*)ntdll_handle)[export_dir->AddressOfNameOrdinals];

    size_t totaly_initialized = 0;

    for (size_t idx = 0; idx < SYSCALL_TABLE_MAX; idx++) {

        for (size_t name_idx = 0; name_idx < export_dir->NumberOfNames; name_idx++) {

            if (!strcmp((char*)&((uint8_t*)ntdll_handle)[names[name_idx]], get_syscall_name_by_idx((syscall_table_enum)idx))) {

                uint8_t* func = (uint8_t *)&((uint8_t*)ntdll_handle)[functions[names_ordinals[name_idx]]];

                if (func[0] == 0x4C && //mov r10,rcx
                    func[1] == 0x8B &&
                    func[2] == 0xD1 &&
                    func[3] == 0xB8) { //mov eax, syscall_index

                    set_syscall_by_idx((syscall_table_enum)idx, *(uint32_t*)&func[4]);
                }
                else if(func[0] == 0xB8) { //mov eax, syscall_index

                    set_syscall_by_idx((syscall_table_enum)idx, *(uint32_t*)&func[1]);
                }
                else {

                    set_syscall_by_idx((syscall_table_enum)idx, -1);
                    break;
                }

                totaly_initialized++;
                break;
            }
        }
    }

    syscall_table_initialized = true;

    return syscall_table_initialized;
}

extern "C" bool initialize_syscall_table_by_pre_init_table(uint32_t table[SYSCALL_TABLE_MAX]) {

    for (size_t idx = 0; idx < SYSCALL_TABLE_MAX; idx++) {

        set_syscall_by_idx((syscall_table_enum)idx, table[idx]);
    }

    syscall_table_initialized = true;

    return syscall_table_initialized;
}


```

`src/HIGU_ntcall/syscall_table_initialize.h`:

```h
#pragma once

#include <stdint.h>

#include "syscall_table.h"

extern "C" {

    bool is_syscall_table_initialized();

    bool initialize_syscall_table_auto();
    bool initialize_syscall_table_by_mapped(void* ntdll_handle);
    bool initialize_syscall_table_by_pre_init_table(uint32_t table[SYSCALL_TABLE_MAX]);

};
```

`src/HIGU_ntcall_3264/HIGU_ntcall_3264.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ntcall3264.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ntcall_stuff.h" />
    <ClInclude Include="thunk64_convertors32to64.h" />
    <ClInclude Include="thunk64_convertors64to32.h" />
    <ClInclude Include="thunk64_functions.h" />
    <ClInclude Include="thunk64_structures32.h" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="impl_syscall.asm" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{57798e33-0084-4f84-810d-e5e81b527464}</ProjectGuid>
    <RootNamespace>HIGUntcall3264</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\$(Configuration)$(PlatformArchitecture)\</OutDir>
    <IntDir>$(SolutionDir)tmp\$(ProjectName)_$(Configuration)$(PlatformArchitecture)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\$(Configuration)$(PlatformArchitecture)\</OutDir>
    <IntDir>$(SolutionDir)tmp\$(ProjectName)_$(Configuration)$(PlatformArchitecture)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>false</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>$(SolutionDir)phnt;</AdditionalIncludeDirectories>
      <SupportJustMyCode>false</SupportJustMyCode>
      <ExceptionHandling>false</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <BasicRuntimeChecks />
    </ClCompile>
    <Link>
      <SubSystem>
      </SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <Lib>
      <LinkTimeCodeGeneration>false</LinkTimeCodeGeneration>
    </Lib>
    <PostBuildEvent>
      <Command>$(OutDir)object_cvt64to32.exe $(IntDir)ntcall3264.obj
$(OutDir)object_cvt64to32.exe $(IntDir)impl_syscall.obj</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>false</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>$(SolutionDir)phnt;</AdditionalIncludeDirectories>
      <WholeProgramOptimization>false</WholeProgramOptimization>
      <ExceptionHandling>false</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <Optimization>MaxSpeed</Optimization>
      <BasicRuntimeChecks />
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>
      </SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <Lib>
      <LinkTimeCodeGeneration>false</LinkTimeCodeGeneration>
    </Lib>
    <PostBuildEvent>
      <Command>$(OutDir)object_cvt64to32.exe $(IntDir)ntcall3264.obj
$(OutDir)object_cvt64to32.exe $(IntDir)impl_syscall.obj</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`src/HIGU_ntcall_3264/HIGU_ntcall_3264.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ntcall3264.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="thunk64_functions.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="thunk64_structures32.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="thunk64_convertors32to64.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="thunk64_convertors64to32.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="ntcall_stuff.h">
      <Filter>Source Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="impl_syscall.asm">
      <Filter>Source Files</Filter>
    </MASM>
  </ItemGroup>
</Project>
```

`src/HIGU_ntcall_3264/impl_syscall.asm`:

```asm
.CODE

EXTERN _intrnl__ntcallmalloc32: PROC 

intrnl__syscall64 PROC


sub rsp, 020h ; save regs
mov [rsp],        rsi
mov [rsp + 8],    rdi
mov [rsp + 010h], rbx
mov [rsp + 018h], r12

mov eax,  ecx ; syscall index 
mov esi,  edx ; params count
mov rdi,  r8  ; param table
xor rbx, rbx

cmp rsi, 0
je  make_call

mov rcx, [rdi] ;fill 1st arg
add rdi, 8

dec rsi
je  make_call

mov rdx, [rdi] ;fill 2st arg
add rdi, 8

dec rsi
je  make_call

mov r8, [rdi] ;fill 3st arg
add rdi, 8

dec rsi
je  make_call

mov r9, [rdi] ;fill 4st arg
add rdi, 8

dec rsi
je  make_call

lea rbx, [rsi * 8]
sub rsp, rbx  ;if more we push it on stack
mov rbx, 0 

push_argument:
 mov r12, [rdi]
 mov [rsp + rbx], r12
 add rbx, 8
 add rdi, 8
 dec rsi
 jnz push_argument

make_call:

sub rsp, 028h

mov r10, rcx 
syscall

add rsp, 028h
add rsp, rbx

mov r12, [rsp + 018h] 
mov rbx, [rsp + 010h]
mov rdi, [rsp + 8]
mov rsi, [rsp]

add rsp, 20h

ret

intrnl__syscall64 ENDP

intrnl__ntcallmalloc PROC
 push rbx
 push rax
 mov dword ptr [rsp + 4], 023h
 mov dword ptr [rsp], end_context_in_64mode
 mov ebx, start_context_in_64mode
 retf

end_context_in_64mode:
 
 push rdx
 push rcx
 call _intrnl__ntcallmalloc32
 add esp, 8

 push 033h
 push rbx
 retf

start_context_in_64mode:

 pop rbx
 ret

intrnl__ntcallmalloc ENDP


END
```

`src/HIGU_ntcall_3264/ntcall3264.cpp`:

```cpp

typedef enum _RTL_PATH_TYPE {
    RtlPathTypeUnknown,         // 0
    RtlPathTypeUncAbsolute,     // 1
    RtlPathTypeDriveAbsolute,   // 2
    RtlPathTypeDriveRelative,   // 3
    RtlPathTypeRooted,          // 4
    RtlPathTypeRelative,        // 5
    RtlPathTypeLocalDevice,     // 6
    RtlPathTypeRootLocalDevice  // 7
} RTL_PATH_TYPE;

#pragma warning(push)
#pragma warning(disable: 4005 4201)

#include <phnt_windows.h>
#include <phnt.h>

#pragma warning(pop)

#include <stdint.h>


#define X32_PVOID uint32_t
#define X32_SIZE_T uint32_t
#define X32_HANDLE X32_PVOID
#define X32_ULONG_PTR X32_PVOID
#define X32_ALPC_HANDLE X32_HANDLE
#define X32_PSID X32_PVOID
#define X32_KAFFINITY X32_PVOID


#pragma warning(push)
#pragma warning(disable: 4302 4311 4312) //silent pointer cvt
#pragma warning(disable: 4091) //silent struct typedef

extern "C" {
    #include "ntcall_stuff.h"
    #include "thunk64_structures32.h"
    #include "thunk64_convertors32to64.h"
    #include "thunk64_convertors64to32.h"
    #include "thunk64_functions.h"
};

#pragma warning(pop)
```

`src/HIGU_ntcall_3264/ntcall_stuff.h`:

```h
extern int64_t __fastcall intrnl__syscall64(uint32_t syscall_idx, uint32_t args_count, uint64_t* arg_table);

__forceinline int64_t __syscall64(uint32_t syscall_idx, uint32_t arg_count, ...) {

    uint64_t arg_table[20];

    va_list variadic_arg;

    va_start(variadic_arg, arg_count);

    for (uint32_t idx = 0; idx < arg_count; idx++) {

        arg_table[idx] = va_arg(variadic_arg, uint64_t);
    }

    va_end(variadic_arg);

    return intrnl__syscall64(syscall_idx, arg_count, arg_table);
}


extern void* intrnl__ntcallmalloc(void* ctx, uint32_t size);


```

`src/HIGU_ntcall_3264/thunk64_convertors32to64.h`:

```h

#define NESTED_CVT_32TO64(type, var_name) \
	{\
		type * var_name = &(*ptr64)->##var_name;\
		convert_##type##_32TO64(ctx, &##var_name, (uint32_t)&x32_used_ptr->##var_name);\
	}

#define NESTED_CVT_32TO64_WITH_ALLOC(type, var_name) \
	{\
		if (x32_used_ptr->##var_name) {\
			type * var_name = (##type##*)intrnl__ntcallmalloc(ctx, sizeof(##type##));\
			convert_##type##_32TO64(ctx, &##var_name, (uint32_t)x32_used_ptr->##var_name);\
			(*ptr64)->##var_name = var_name ;\
		} else {\
			(*ptr64)->##var_name = 0;\
		}\
	}

#define CVT_COPY_STRING(type, var_name, var_len_name) __movsb((PBYTE)&(*ptr64)->##var_name[0], (PBYTE)&x32_used_ptr->##var_name[0], x32_used_ptr->##var_len_name);



void convert__SYSTEM_POOL_INFORMATION_32TO64(void* ctx, _SYSTEM_POOL_INFORMATION**, uint32_t ptr32);
void convert__SYSTEM_FILECACHE_INFORMATION_32TO64(void* ctx, _SYSTEM_FILECACHE_INFORMATION**, uint32_t ptr32);
void convert__SYSTEM_REGISTRY_QUOTA_INFORMATION_32TO64(void* ctx, _SYSTEM_REGISTRY_QUOTA_INFORMATION**, uint32_t ptr32);
void convert__SYSTEM_VERIFIER_INFORMATION_32TO64(void* ctx, _SYSTEM_VERIFIER_INFORMATION**, uint32_t ptr32);
void convert__SYSTEM_REF_TRACE_INFORMATION_32TO64(void* ctx, _SYSTEM_REF_TRACE_INFORMATION**, uint32_t ptr32);
void convert__SYSTEM_VERIFIER_INFORMATION_EX_32TO64(void* ctx, _SYSTEM_VERIFIER_INFORMATION_EX**, uint32_t ptr32);
void convert__SYSTEM_POLICY_INFORMATION_32TO64(void* ctx, _SYSTEM_POLICY_INFORMATION**, uint32_t ptr32);
void convert__SYSTEM_LOGICAL_PROCESSOR_INFORMATION_32TO64(void* ctx, _SYSTEM_LOGICAL_PROCESSOR_INFORMATION**, uint32_t ptr32);
void convert__SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX_32TO64(void* ctx, _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX**, uint32_t ptr32);
void convert__SYSTEM_FEATURE_CONFIGURATION_INFORMATION_32TO64(void* ctx, _SYSTEM_FEATURE_CONFIGURATION_INFORMATION**, uint32_t ptr32);
void convert__UNICODE_STRING_32TO64(void* ctx, _UNICODE_STRING**, uint32_t ptr32);
void convert__SYSTEM_THREAD_CID_PRIORITY_INFORMATION_32TO64(void* ctx, _SYSTEM_THREAD_CID_PRIORITY_INFORMATION**, uint32_t ptr32);
void convert__SYSTEM_VERIFIER_FAULTS_INFORMATION_32TO64(void* ctx, _SYSTEM_VERIFIER_FAULTS_INFORMATION**, uint32_t ptr32);
void convert__SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS_32TO64(void* ctx, _SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS**, uint32_t ptr32);
void convert__SYSTEM_ELAM_CERTIFICATE_INFORMATION_32TO64(void* ctx, _SYSTEM_ELAM_CERTIFICATE_INFORMATION**, uint32_t ptr32);
void convert__SYSTEM_ACTIVITY_MODERATION_EXE_STATE_32TO64(void* ctx, _SYSTEM_ACTIVITY_MODERATION_EXE_STATE**, uint32_t ptr32);
void convert__QUOTA_LIMITS_32TO64(void* ctx, _QUOTA_LIMITS**, uint32_t ptr32);
void convert__PROCESS_EXCEPTION_PORT_32TO64(void* ctx, _PROCESS_EXCEPTION_PORT**, uint32_t ptr32);
void convert__PROCESS_ACCESS_TOKEN_32TO64(void* ctx, _PROCESS_ACCESS_TOKEN**, uint32_t ptr32);
void convert__PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION_32TO64(void* ctx, _PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION**, uint32_t ptr32);
void convert__PROCESS_STACK_ALLOCATION_INFORMATION_32TO64(void* ctx, _PROCESS_STACK_ALLOCATION_INFORMATION**, uint32_t ptr32);
void convert__PROCESS_MEMORY_EXHAUSTION_INFO_32TO64(void* ctx, _PROCESS_MEMORY_EXHAUSTION_INFO**, uint32_t ptr32);
void convert__PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION_32TO64(void* ctx, _PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION**, uint32_t ptr32);
void convert__GROUP_AFFINITY_32TO64(void* ctx, _GROUP_AFFINITY**, uint32_t ptr32);
void convert__THREAD_PROFILING_INFORMATION_32TO64(void* ctx, _THREAD_PROFILING_INFORMATION**, uint32_t ptr32);
void convert__THREAD_NAME_INFORMATION_32TO64(void* ctx, _THREAD_NAME_INFORMATION**, uint32_t ptr32);
void convert__FILE_RENAME_INFORMATION_32TO64(void* ctx, _FILE_RENAME_INFORMATION**, uint32_t ptr32);
void convert__FILE_LINK_INFORMATION_32TO64(void* ctx, _FILE_LINK_INFORMATION**, uint32_t ptr32);
void convert__FILE_MAILSLOT_SET_INFORMATION_32TO64(void* ctx, _FILE_MAILSLOT_SET_INFORMATION**, uint32_t ptr32);
void convert__FILE_COMPLETION_INFORMATION_32TO64(void* ctx, _FILE_COMPLETION_INFORMATION**, uint32_t ptr32);
void convert__FILE_MOVE_CLUSTER_INFORMATION_32TO64(void* ctx, _FILE_MOVE_CLUSTER_INFORMATION**, uint32_t ptr32);
void convert__FILE_TRACKING_INFORMATION_32TO64(void* ctx, _FILE_TRACKING_INFORMATION**, uint32_t ptr32);
void convert__FILE_IOSTATUSBLOCK_RANGE_INFORMATION_32TO64(void* ctx, _FILE_IOSTATUSBLOCK_RANGE_INFORMATION**, uint32_t ptr32);
void convert__FILE_RENAME_INFORMATION_EX_32TO64(void* ctx, _FILE_RENAME_INFORMATION_EX**, uint32_t ptr32);
void convert__FILE_MEMORY_PARTITION_INFORMATION_32TO64(void* ctx, _FILE_MEMORY_PARTITION_INFORMATION**, uint32_t ptr32);
void convert__FILE_LINK_INFORMATION_EX_32TO64(void* ctx, _FILE_LINK_INFORMATION_EX**, uint32_t ptr32);
void convert__ALPC_BASIC_INFORMATION_32TO64(void* ctx, _ALPC_BASIC_INFORMATION**, uint32_t ptr32);
void convert__ALPC_PORT_ATTRIBUTES_32TO64(void* ctx, _ALPC_PORT_ATTRIBUTES**, uint32_t ptr32);
void convert__ALPC_PORT_ASSOCIATE_COMPLETION_PORT_32TO64(void* ctx, _ALPC_PORT_ASSOCIATE_COMPLETION_PORT**, uint32_t ptr32);
void convert__ALPC_PORT_MESSAGE_ZONE_INFORMATION_32TO64(void* ctx, _ALPC_PORT_MESSAGE_ZONE_INFORMATION**, uint32_t ptr32);
void convert__ALPC_PORT_COMPLETION_LIST_INFORMATION_32TO64(void* ctx, _ALPC_PORT_COMPLETION_LIST_INFORMATION**, uint32_t ptr32);
void convert_MEM_EXTENDED_PARAMETER_32TO64(void* ctx, MEM_EXTENDED_PARAMETER**, uint32_t ptr32);
void convert__OBJECT_ATTRIBUTES_32TO64(void* ctx, _OBJECT_ATTRIBUTES**, uint32_t ptr32);
void convert_HANDLE_32TO64(void* ctx, HANDLE**, uint32_t ptr32);
void convert__MEMORY_RANGE_ENTRY_32TO64(void* ctx, _MEMORY_RANGE_ENTRY**, uint32_t ptr32);
void convert__CLIENT_ID_32TO64(void* ctx, _CLIENT_ID**, uint32_t ptr32);
void convert__INITIAL_TEB_32TO64(void* ctx, _INITIAL_TEB**, uint32_t ptr32);
void convert__PS_CREATE_INFO_32TO64(void* ctx, _PS_CREATE_INFO**, uint32_t ptr32);
void convert__PS_ATTRIBUTE_LIST_32TO64(void* ctx, _PS_ATTRIBUTE_LIST**, uint32_t ptr32);
void convert__JOB_SET_ARRAY_32TO64(void* ctx, _JOB_SET_ARRAY**, uint32_t ptr32);
void convert__IO_STATUS_BLOCK_32TO64(void* ctx, _IO_STATUS_BLOCK**, uint32_t ptr32);
void convert__FILE_SEGMENT_ELEMENT_32TO64(void* ctx, _FILE_SEGMENT_ELEMENT**, uint32_t ptr32);
void convert__PORT_VIEW_32TO64(void* ctx, _PORT_VIEW**, uint32_t ptr32);
void convert__REMOTE_PORT_VIEW_32TO64(void* ctx, _REMOTE_PORT_VIEW**, uint32_t ptr32);
void convert__PORT_MESSAGE_32TO64(void* ctx, _PORT_MESSAGE**, uint32_t ptr32);
void convert__ALPC_DATA_VIEW_ATTR_32TO64(void* ctx, _ALPC_DATA_VIEW_ATTR**, uint32_t ptr32);
void convert__ALPC_SECURITY_ATTR_32TO64(void* ctx, _ALPC_SECURITY_ATTR**, uint32_t ptr32);
void convert__ALPC_CONTEXT_ATTR_32TO64(void* ctx, _ALPC_CONTEXT_ATTR**, uint32_t ptr32);
void convert__KEY_VALUE_ENTRY_32TO64(void* ctx, _KEY_VALUE_ENTRY**, uint32_t ptr32);
void convert__TOKEN_USER_32TO64(void* ctx, _TOKEN_USER**, uint32_t ptr32);
void convert__TOKEN_GROUPS_32TO64(void* ctx, _TOKEN_GROUPS**, uint32_t ptr32);
void convert__TOKEN_OWNER_32TO64(void* ctx, _TOKEN_OWNER**, uint32_t ptr32);
void convert__TOKEN_PRIMARY_GROUP_32TO64(void* ctx, _TOKEN_PRIMARY_GROUP**, uint32_t ptr32);
void convert__TOKEN_DEFAULT_DACL_32TO64(void* ctx, _TOKEN_DEFAULT_DACL**, uint32_t ptr32);
void convert__SID_AND_ATTRIBUTES_32TO64(void* ctx, _SID_AND_ATTRIBUTES**, uint32_t ptr32);
void convert__TOKEN_SECURITY_ATTRIBUTES_INFORMATION_32TO64(void* ctx, _TOKEN_SECURITY_ATTRIBUTES_INFORMATION**, uint32_t ptr32);
void convert__OBJECT_TYPE_LIST_32TO64(void* ctx, _OBJECT_TYPE_LIST**, uint32_t ptr32);
void convert__EXCEPTION_RECORD_32TO64(void* ctx, _EXCEPTION_RECORD**, uint32_t ptr32);


void convert__SYSTEM_POOL_INFORMATION_32TO64(void* ctx, _SYSTEM_POOL_INFORMATION** ptr64, uint32_t ptr32) {
	X32__SYSTEM_POOL_INFORMATION* x32_used_ptr = (X32__SYSTEM_POOL_INFORMATION*)ptr32;
	(*ptr64)->TotalSize = (long long unsigned int)x32_used_ptr->TotalSize;
	(*ptr64)->FirstEntry = (void*)x32_used_ptr->FirstEntry;
	(*ptr64)->EntryOverhead = (short unsigned int)x32_used_ptr->EntryOverhead;
	(*ptr64)->PoolTagPresent = (unsigned char)x32_used_ptr->PoolTagPresent;
	(*ptr64)->Spare0 = (unsigned char)x32_used_ptr->Spare0;
	(*ptr64)->NumberOfEntries = (long unsigned int)x32_used_ptr->NumberOfEntries;


	//(*ptr64)->Entries = (_SYSTEM_POOL_ENTRY[1])x32_used_ptr->Entries;
};

void convert__SYSTEM_FILECACHE_INFORMATION_32TO64(void* ctx, _SYSTEM_FILECACHE_INFORMATION** ptr64, uint32_t ptr32) {
	X32__SYSTEM_FILECACHE_INFORMATION* x32_used_ptr = (X32__SYSTEM_FILECACHE_INFORMATION*)ptr32;
	(*ptr64)->CurrentSize = (long long unsigned int)x32_used_ptr->CurrentSize;
	(*ptr64)->PeakSize = (long long unsigned int)x32_used_ptr->PeakSize;
	(*ptr64)->PageFaultCount = (long unsigned int)x32_used_ptr->PageFaultCount;
	(*ptr64)->MinimumWorkingSet = (long long unsigned int)x32_used_ptr->MinimumWorkingSet;
	(*ptr64)->MaximumWorkingSet = (long long unsigned int)x32_used_ptr->MaximumWorkingSet;
	(*ptr64)->CurrentSizeIncludingTransitionInPages = (long long unsigned int)x32_used_ptr->CurrentSizeIncludingTransitionInPages;
	(*ptr64)->PeakSizeIncludingTransitionInPages = (long long unsigned int)x32_used_ptr->PeakSizeIncludingTransitionInPages;
	(*ptr64)->TransitionRePurposeCount = (long unsigned int)x32_used_ptr->TransitionRePurposeCount;
	(*ptr64)->Flags = (long unsigned int)x32_used_ptr->Flags;
};

void convert__SYSTEM_REGISTRY_QUOTA_INFORMATION_32TO64(void* ctx, _SYSTEM_REGISTRY_QUOTA_INFORMATION** ptr64, uint32_t ptr32) {
	X32__SYSTEM_REGISTRY_QUOTA_INFORMATION* x32_used_ptr = (X32__SYSTEM_REGISTRY_QUOTA_INFORMATION*)ptr32;
	(*ptr64)->RegistryQuotaAllowed = (long unsigned int)x32_used_ptr->RegistryQuotaAllowed;
	(*ptr64)->RegistryQuotaUsed = (long unsigned int)x32_used_ptr->RegistryQuotaUsed;
	(*ptr64)->PagedPoolSize = (long long unsigned int)x32_used_ptr->PagedPoolSize;
};

void convert__SYSTEM_VERIFIER_INFORMATION_32TO64(void* ctx, _SYSTEM_VERIFIER_INFORMATION** ptr64, uint32_t ptr32) {
	X32__SYSTEM_VERIFIER_INFORMATION* x32_used_ptr = (X32__SYSTEM_VERIFIER_INFORMATION*)ptr32;
	(*ptr64)->NextEntryOffset = (long unsigned int)x32_used_ptr->NextEntryOffset;
	(*ptr64)->Level = (long unsigned int)x32_used_ptr->Level;
	
	(*ptr64)->RuleClasses[0] = (long unsigned int)x32_used_ptr->RuleClasses[0];
	(*ptr64)->RuleClasses[1] = (long unsigned int)x32_used_ptr->RuleClasses[1];

	(*ptr64)->TriageContext = (long unsigned int)x32_used_ptr->TriageContext;
	(*ptr64)->AreAllDriversBeingVerified = (long unsigned int)x32_used_ptr->AreAllDriversBeingVerified;
	
	NESTED_CVT_32TO64(_UNICODE_STRING, DriverName);

	(*ptr64)->RaiseIrqls = (long unsigned int)x32_used_ptr->RaiseIrqls;
	(*ptr64)->AcquireSpinLocks = (long unsigned int)x32_used_ptr->AcquireSpinLocks;
	(*ptr64)->SynchronizeExecutions = (long unsigned int)x32_used_ptr->SynchronizeExecutions;
	(*ptr64)->AllocationsAttempted = (long unsigned int)x32_used_ptr->AllocationsAttempted;
	(*ptr64)->AllocationsSucceeded = (long unsigned int)x32_used_ptr->AllocationsSucceeded;
	(*ptr64)->AllocationsSucceededSpecialPool = (long unsigned int)x32_used_ptr->AllocationsSucceededSpecialPool;
	(*ptr64)->AllocationsWithNoTag = (long unsigned int)x32_used_ptr->AllocationsWithNoTag;
	(*ptr64)->TrimRequests = (long unsigned int)x32_used_ptr->TrimRequests;
	(*ptr64)->Trims = (long unsigned int)x32_used_ptr->Trims;
	(*ptr64)->AllocationsFailed = (long unsigned int)x32_used_ptr->AllocationsFailed;
	(*ptr64)->AllocationsFailedDeliberately = (long unsigned int)x32_used_ptr->AllocationsFailedDeliberately;
	(*ptr64)->Loads = (long unsigned int)x32_used_ptr->Loads;
	(*ptr64)->Unloads = (long unsigned int)x32_used_ptr->Unloads;
	(*ptr64)->UnTrackedPool = (long unsigned int)x32_used_ptr->UnTrackedPool;
	(*ptr64)->CurrentPagedPoolAllocations = (long unsigned int)x32_used_ptr->CurrentPagedPoolAllocations;
	(*ptr64)->CurrentNonPagedPoolAllocations = (long unsigned int)x32_used_ptr->CurrentNonPagedPoolAllocations;
	(*ptr64)->PeakPagedPoolAllocations = (long unsigned int)x32_used_ptr->PeakPagedPoolAllocations;
	(*ptr64)->PeakNonPagedPoolAllocations = (long unsigned int)x32_used_ptr->PeakNonPagedPoolAllocations;
	(*ptr64)->PagedPoolUsageInBytes = (long long unsigned int)x32_used_ptr->PagedPoolUsageInBytes;
	(*ptr64)->NonPagedPoolUsageInBytes = (long long unsigned int)x32_used_ptr->NonPagedPoolUsageInBytes;
	(*ptr64)->PeakPagedPoolUsageInBytes = (long long unsigned int)x32_used_ptr->PeakPagedPoolUsageInBytes;
	(*ptr64)->PeakNonPagedPoolUsageInBytes = (long long unsigned int)x32_used_ptr->PeakNonPagedPoolUsageInBytes;
};

void convert__SYSTEM_REF_TRACE_INFORMATION_32TO64(void* ctx, _SYSTEM_REF_TRACE_INFORMATION** ptr64, uint32_t ptr32) {
	X32__SYSTEM_REF_TRACE_INFORMATION* x32_used_ptr = (X32__SYSTEM_REF_TRACE_INFORMATION*)ptr32;
	(*ptr64)->TraceEnable = (unsigned char)x32_used_ptr->TraceEnable;
	(*ptr64)->TracePermanent = (unsigned char)x32_used_ptr->TracePermanent;

	NESTED_CVT_32TO64(_UNICODE_STRING, TraceProcessName);
	NESTED_CVT_32TO64(_UNICODE_STRING, TracePoolTags);
};

void convert__SYSTEM_VERIFIER_INFORMATION_EX_32TO64(void* ctx, _SYSTEM_VERIFIER_INFORMATION_EX** ptr64, uint32_t ptr32) {
	X32__SYSTEM_VERIFIER_INFORMATION_EX* x32_used_ptr = (X32__SYSTEM_VERIFIER_INFORMATION_EX*)ptr32;
	(*ptr64)->VerifyMode = (long unsigned int)x32_used_ptr->VerifyMode;
	(*ptr64)->OptionChanges = (long unsigned int)x32_used_ptr->OptionChanges;
	NESTED_CVT_32TO64(_UNICODE_STRING, PreviousBucketName);
	(*ptr64)->IrpCancelTimeoutMsec = (long unsigned int)x32_used_ptr->IrpCancelTimeoutMsec;
	(*ptr64)->VerifierExtensionEnabled = (long unsigned int)x32_used_ptr->VerifierExtensionEnabled;
	//(*ptr64)->Reserved = (long unsigned int[1])x32_used_ptr->Reserved;
};

void convert__SYSTEM_POLICY_INFORMATION_32TO64(void* ctx, _SYSTEM_POLICY_INFORMATION** ptr64, uint32_t ptr32) {
	X32__SYSTEM_POLICY_INFORMATION* x32_used_ptr = (X32__SYSTEM_POLICY_INFORMATION*)ptr32;
	(*ptr64)->InputData = (void*)x32_used_ptr->InputData;
	(*ptr64)->OutputData = (void*)x32_used_ptr->OutputData;
	(*ptr64)->InputDataSize = (long unsigned int)x32_used_ptr->InputDataSize;
	(*ptr64)->OutputDataSize = (long unsigned int)x32_used_ptr->OutputDataSize;
	(*ptr64)->Version = (long unsigned int)x32_used_ptr->Version;
};

void convert__SYSTEM_LOGICAL_PROCESSOR_INFORMATION_32TO64(void* ctx, _SYSTEM_LOGICAL_PROCESSOR_INFORMATION** ptr64, uint32_t ptr32) {
	X32__SYSTEM_LOGICAL_PROCESSOR_INFORMATION* x32_used_ptr = (X32__SYSTEM_LOGICAL_PROCESSOR_INFORMATION*)ptr32;
	(*ptr64)->ProcessorMask = (long long unsigned int)x32_used_ptr->ProcessorMask;
	(*ptr64)->Relationship = (_LOGICAL_PROCESSOR_RELATIONSHIP)x32_used_ptr->Relationship;
//#pragma error('Here Ignored union fix it')
	//(*ptr64)-> = (_SYSTEM_LOGICAL_PROCESSOR_INFORMATION)x32_used_ptr->;
};

void convert__SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX_32TO64(void* ctx, _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX** ptr64, uint32_t ptr32) {
	X32__SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX* x32_used_ptr = (X32__SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX*)ptr32;
	(*ptr64)->Relationship = (_LOGICAL_PROCESSOR_RELATIONSHIP)x32_used_ptr->Relationship;
	(*ptr64)->Size = (long unsigned int)x32_used_ptr->Size;
//#pragma error('Here Ignored union fix it')
	//(*ptr64)-> = (_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX)x32_used_ptr->;
};

void convert__SYSTEM_FEATURE_CONFIGURATION_INFORMATION_32TO64(void* ctx, _SYSTEM_FEATURE_CONFIGURATION_INFORMATION** ptr64, uint32_t ptr32) {
	X32__SYSTEM_FEATURE_CONFIGURATION_INFORMATION* x32_used_ptr = (X32__SYSTEM_FEATURE_CONFIGURATION_INFORMATION*)ptr32;
	(*ptr64)->ChangeStamp = (long long unsigned int)x32_used_ptr->ChangeStamp;
	(*ptr64)->Configuration = (_RTL_FEATURE_CONFIGURATION*)x32_used_ptr->Configuration;
};

void convert__UNICODE_STRING_32TO64(void* ctx, _UNICODE_STRING** ptr64, uint32_t ptr32) {
	X32__UNICODE_STRING* x32_used_ptr = (X32__UNICODE_STRING*)ptr32;
	(*ptr64)->Length = (short unsigned int)x32_used_ptr->Length;
	(*ptr64)->MaximumLength = (short unsigned int)x32_used_ptr->MaximumLength;
	(*ptr64)->Buffer = (wchar_t*)x32_used_ptr->Buffer;
};

void convert__SYSTEM_THREAD_CID_PRIORITY_INFORMATION_32TO64(void* ctx, _SYSTEM_THREAD_CID_PRIORITY_INFORMATION** ptr64, uint32_t ptr32) {
	X32__SYSTEM_THREAD_CID_PRIORITY_INFORMATION* x32_used_ptr = (X32__SYSTEM_THREAD_CID_PRIORITY_INFORMATION*)ptr32;
	NESTED_CVT_32TO64(_CLIENT_ID, ClientId);
	(*ptr64)->Priority = (long int)x32_used_ptr->Priority;
};

void convert__SYSTEM_VERIFIER_FAULTS_INFORMATION_32TO64(void* ctx, _SYSTEM_VERIFIER_FAULTS_INFORMATION** ptr64, uint32_t ptr32) {
	X32__SYSTEM_VERIFIER_FAULTS_INFORMATION* x32_used_ptr = (X32__SYSTEM_VERIFIER_FAULTS_INFORMATION*)ptr32;
	(*ptr64)->Probability = (long unsigned int)x32_used_ptr->Probability;
	(*ptr64)->MaxProbability = (long unsigned int)x32_used_ptr->MaxProbability;

	NESTED_CVT_32TO64(_UNICODE_STRING, PoolTags);
	NESTED_CVT_32TO64(_UNICODE_STRING, Applications);
};

void convert__SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS_32TO64(void* ctx, _SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS** ptr64, uint32_t ptr32) {
	X32__SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS* x32_used_ptr = (X32__SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS*)ptr32;
	(*ptr64)->KeyHandle = (void*)x32_used_ptr->KeyHandle;
	
	NESTED_CVT_32TO64_WITH_ALLOC(_UNICODE_STRING, ValueNamePointer);

	(*ptr64)->RequiredLengthPointer = (long unsigned int*)x32_used_ptr->RequiredLengthPointer;
	(*ptr64)->Buffer = (unsigned char*)x32_used_ptr->Buffer;
	(*ptr64)->BufferLength = (long unsigned int)x32_used_ptr->BufferLength;
	(*ptr64)->Type = (long unsigned int)x32_used_ptr->Type;
	(*ptr64)->AppendBuffer = (unsigned char*)x32_used_ptr->AppendBuffer;
	(*ptr64)->AppendBufferLength = (long unsigned int)x32_used_ptr->AppendBufferLength;
	(*ptr64)->CreateIfDoesntExist = (unsigned char)x32_used_ptr->CreateIfDoesntExist;
	(*ptr64)->TruncateExistingValue = (unsigned char)x32_used_ptr->TruncateExistingValue;
};

void convert__SYSTEM_ELAM_CERTIFICATE_INFORMATION_32TO64(void* ctx, _SYSTEM_ELAM_CERTIFICATE_INFORMATION** ptr64, uint32_t ptr32) {
	X32__SYSTEM_ELAM_CERTIFICATE_INFORMATION* x32_used_ptr = (X32__SYSTEM_ELAM_CERTIFICATE_INFORMATION*)ptr32;
	(*ptr64)->ElamDriverFile = (void*)x32_used_ptr->ElamDriverFile;
};

void convert__SYSTEM_ACTIVITY_MODERATION_EXE_STATE_32TO64(void* ctx, _SYSTEM_ACTIVITY_MODERATION_EXE_STATE** ptr64, uint32_t ptr32) {
	X32__SYSTEM_ACTIVITY_MODERATION_EXE_STATE* x32_used_ptr = (X32__SYSTEM_ACTIVITY_MODERATION_EXE_STATE*)ptr32;
	
	NESTED_CVT_32TO64(_UNICODE_STRING, ExePathNt);

	(*ptr64)->ModerationState = (_SYSTEM_ACTIVITY_MODERATION_STATE)x32_used_ptr->ModerationState;
};

void convert__QUOTA_LIMITS_32TO64(void* ctx, _QUOTA_LIMITS** ptr64, uint32_t ptr32) {
	X32__QUOTA_LIMITS* x32_used_ptr = (X32__QUOTA_LIMITS*)ptr32;
	(*ptr64)->PagedPoolLimit = (long long unsigned int)x32_used_ptr->PagedPoolLimit;
	(*ptr64)->NonPagedPoolLimit = (long long unsigned int)x32_used_ptr->NonPagedPoolLimit;
	(*ptr64)->MinimumWorkingSetSize = (long long unsigned int)x32_used_ptr->MinimumWorkingSetSize;
	(*ptr64)->MaximumWorkingSetSize = (long long unsigned int)x32_used_ptr->MaximumWorkingSetSize;
	(*ptr64)->PagefileLimit = (long long unsigned int)x32_used_ptr->PagefileLimit;
	(*ptr64)->TimeLimit = (LARGE_INTEGER)x32_used_ptr->TimeLimit;
};

void convert__PROCESS_EXCEPTION_PORT_32TO64(void* ctx, _PROCESS_EXCEPTION_PORT** ptr64, uint32_t ptr32) {
	X32__PROCESS_EXCEPTION_PORT* x32_used_ptr = (X32__PROCESS_EXCEPTION_PORT*)ptr32;
	(*ptr64)->ExceptionPortHandle = (void*)x32_used_ptr->ExceptionPortHandle;
	(*ptr64)->StateFlags = (long unsigned int)x32_used_ptr->StateFlags;
};

void convert__PROCESS_ACCESS_TOKEN_32TO64(void* ctx, _PROCESS_ACCESS_TOKEN** ptr64, uint32_t ptr32) {
	X32__PROCESS_ACCESS_TOKEN* x32_used_ptr = (X32__PROCESS_ACCESS_TOKEN*)ptr32;
	(*ptr64)->Token = (void*)x32_used_ptr->Token;
	(*ptr64)->Thread = (void*)x32_used_ptr->Thread;
};

void convert__PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION_32TO64(void* ctx, _PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION** ptr64, uint32_t ptr32) {
	X32__PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION* x32_used_ptr = (X32__PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION*)ptr32;
	(*ptr64)->Version = (long unsigned int)x32_used_ptr->Version;
	(*ptr64)->Reserved = (long unsigned int)x32_used_ptr->Reserved;
	(*ptr64)->Callback = (void*)x32_used_ptr->Callback;
};

void convert__PROCESS_STACK_ALLOCATION_INFORMATION_32TO64(void* ctx, _PROCESS_STACK_ALLOCATION_INFORMATION** ptr64, uint32_t ptr32) {
	X32__PROCESS_STACK_ALLOCATION_INFORMATION* x32_used_ptr = (X32__PROCESS_STACK_ALLOCATION_INFORMATION*)ptr32;
	(*ptr64)->ReserveSize = (long long unsigned int)x32_used_ptr->ReserveSize;
	(*ptr64)->ZeroBits = (long long unsigned int)x32_used_ptr->ZeroBits;
	(*ptr64)->StackBase = (void*)x32_used_ptr->StackBase;
};

void convert__PROCESS_MEMORY_EXHAUSTION_INFO_32TO64(void* ctx, _PROCESS_MEMORY_EXHAUSTION_INFO** ptr64, uint32_t ptr32) {
	X32__PROCESS_MEMORY_EXHAUSTION_INFO* x32_used_ptr = (X32__PROCESS_MEMORY_EXHAUSTION_INFO*)ptr32;
	(*ptr64)->Version = (short unsigned int)x32_used_ptr->Version;
	(*ptr64)->Reserved = (short unsigned int)x32_used_ptr->Reserved;
	(*ptr64)->Type = (_PROCESS_MEMORY_EXHAUSTION_TYPE)x32_used_ptr->Type;
	(*ptr64)->Value = (long long unsigned int)x32_used_ptr->Value;
};

void convert__PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION_32TO64(void* ctx, _PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION** ptr64, uint32_t ptr32) {
	X32__PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION* x32_used_ptr = (X32__PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION*)ptr32;
	(*ptr64)->ProcessHandle = (void*)x32_used_ptr->ProcessHandle;
};

void convert__GROUP_AFFINITY_32TO64(void* ctx, _GROUP_AFFINITY** ptr64, uint32_t ptr32) {
	X32__GROUP_AFFINITY* x32_used_ptr = (X32__GROUP_AFFINITY*)ptr32;
	(*ptr64)->Mask = (long long unsigned int)x32_used_ptr->Mask;
	(*ptr64)->Group = (short unsigned int)x32_used_ptr->Group;
	(*ptr64)->Reserved[0] = (short unsigned int)x32_used_ptr->Reserved[0];
	(*ptr64)->Reserved[1] = (short unsigned int)x32_used_ptr->Reserved[1];
	(*ptr64)->Reserved[2] = (short unsigned int)x32_used_ptr->Reserved[2];

};

void convert__THREAD_PROFILING_INFORMATION_32TO64(void* ctx, _THREAD_PROFILING_INFORMATION** ptr64, uint32_t ptr32) {
	X32__THREAD_PROFILING_INFORMATION* x32_used_ptr = (X32__THREAD_PROFILING_INFORMATION*)ptr32;
	(*ptr64)->HardwareCounters = (long long unsigned int)x32_used_ptr->HardwareCounters;
	(*ptr64)->Flags = (long unsigned int)x32_used_ptr->Flags;
	(*ptr64)->Enable = (long unsigned int)x32_used_ptr->Enable;
	(*ptr64)->PerformanceData = (_THREAD_PERFORMANCE_DATA*)x32_used_ptr->PerformanceData;
};

void convert__THREAD_NAME_INFORMATION_32TO64(void* ctx, _THREAD_NAME_INFORMATION** ptr64, uint32_t ptr32) {
	X32__THREAD_NAME_INFORMATION* x32_used_ptr = (X32__THREAD_NAME_INFORMATION*)ptr32;

	NESTED_CVT_32TO64(_UNICODE_STRING, ThreadName);
};

void convert__FILE_RENAME_INFORMATION_32TO64(void* ctx, _FILE_RENAME_INFORMATION** ptr64, uint32_t ptr32) {
	X32__FILE_RENAME_INFORMATION* x32_used_ptr = (X32__FILE_RENAME_INFORMATION*)ptr32;
	(*ptr64)->ReplaceIfExists = (unsigned char)x32_used_ptr->ReplaceIfExists;
	(*ptr64)->RootDirectory = (void*)x32_used_ptr->RootDirectory;
	(*ptr64)->FileNameLength = (long unsigned int)x32_used_ptr->FileNameLength;
	
	CVT_COPY_STRING(wchar_t, FileName, FileNameLength);
};

void convert__FILE_LINK_INFORMATION_32TO64(void* ctx, _FILE_LINK_INFORMATION** ptr64, uint32_t ptr32) {
	X32__FILE_LINK_INFORMATION* x32_used_ptr = (X32__FILE_LINK_INFORMATION*)ptr32;
	(*ptr64)->ReplaceIfExists = (unsigned char)x32_used_ptr->ReplaceIfExists;
	(*ptr64)->RootDirectory = (void*)x32_used_ptr->RootDirectory;
	(*ptr64)->FileNameLength = (long unsigned int)x32_used_ptr->FileNameLength;

	CVT_COPY_STRING(wchar_t, FileName, FileNameLength);
};

void convert__FILE_MAILSLOT_SET_INFORMATION_32TO64(void* ctx, _FILE_MAILSLOT_SET_INFORMATION** ptr64, uint32_t ptr32) {
	X32__FILE_MAILSLOT_SET_INFORMATION* x32_used_ptr = (X32__FILE_MAILSLOT_SET_INFORMATION*)ptr32;
	(*ptr64)->ReadTimeout = (_LARGE_INTEGER*)x32_used_ptr->ReadTimeout;
};

void convert__FILE_COMPLETION_INFORMATION_32TO64(void* ctx, _FILE_COMPLETION_INFORMATION** ptr64, uint32_t ptr32) {
	X32__FILE_COMPLETION_INFORMATION* x32_used_ptr = (X32__FILE_COMPLETION_INFORMATION*)ptr32;
	(*ptr64)->Port = (void*)x32_used_ptr->Port;
	(*ptr64)->Key = (void*)x32_used_ptr->Key;
};

void convert__FILE_MOVE_CLUSTER_INFORMATION_32TO64(void* ctx, _FILE_MOVE_CLUSTER_INFORMATION** ptr64, uint32_t ptr32) {
	X32__FILE_MOVE_CLUSTER_INFORMATION* x32_used_ptr = (X32__FILE_MOVE_CLUSTER_INFORMATION*)ptr32;
	(*ptr64)->ClusterCount = (long unsigned int)x32_used_ptr->ClusterCount;
	(*ptr64)->RootDirectory = (void*)x32_used_ptr->RootDirectory;
	(*ptr64)->FileNameLength = (long unsigned int)x32_used_ptr->FileNameLength;

	CVT_COPY_STRING(wchar_t, FileName, FileNameLength);
};

void convert__FILE_TRACKING_INFORMATION_32TO64(void* ctx, _FILE_TRACKING_INFORMATION** ptr64, uint32_t ptr32) {
	X32__FILE_TRACKING_INFORMATION* x32_used_ptr = (X32__FILE_TRACKING_INFORMATION*)ptr32;
	(*ptr64)->DestinationFile = (void*)x32_used_ptr->DestinationFile;
	(*ptr64)->ObjectInformationLength = (long unsigned int)x32_used_ptr->ObjectInformationLength;

//	(*ptr64)->ObjectInformation = (char[1])x32_used_ptr->ObjectInformation;
};

void convert__FILE_IOSTATUSBLOCK_RANGE_INFORMATION_32TO64(void* ctx, _FILE_IOSTATUSBLOCK_RANGE_INFORMATION** ptr64, uint32_t ptr32) {
	X32__FILE_IOSTATUSBLOCK_RANGE_INFORMATION* x32_used_ptr = (X32__FILE_IOSTATUSBLOCK_RANGE_INFORMATION*)ptr32;
	(*ptr64)->IoStatusBlockRange = (unsigned char*)x32_used_ptr->IoStatusBlockRange;
	(*ptr64)->Length = (long unsigned int)x32_used_ptr->Length;
};

void convert__FILE_RENAME_INFORMATION_EX_32TO64(void* ctx, _FILE_RENAME_INFORMATION_EX** ptr64, uint32_t ptr32) {
	X32__FILE_RENAME_INFORMATION_EX* x32_used_ptr = (X32__FILE_RENAME_INFORMATION_EX*)ptr32;
	(*ptr64)->Flags = (long unsigned int)x32_used_ptr->Flags;
	(*ptr64)->RootDirectory = (void*)x32_used_ptr->RootDirectory;
	(*ptr64)->FileNameLength = (long unsigned int)x32_used_ptr->FileNameLength;
	
	CVT_COPY_STRING(wchar_t, FileName, FileNameLength);
};

void convert__FILE_MEMORY_PARTITION_INFORMATION_32TO64(void* ctx, _FILE_MEMORY_PARTITION_INFORMATION** ptr64, uint32_t ptr32) {
	X32__FILE_MEMORY_PARTITION_INFORMATION* x32_used_ptr = (X32__FILE_MEMORY_PARTITION_INFORMATION*)ptr32;
	(*ptr64)->OwnerPartitionHandle = (void*)x32_used_ptr->OwnerPartitionHandle;

//#pragma error('Here Ignored union fix it')
	//(*ptr64)->Flags = (_FILE_MEMORY_PARTITION_INFORMATION)x32_used_ptr->Flags;
};

void convert__FILE_LINK_INFORMATION_EX_32TO64(void* ctx, _FILE_LINK_INFORMATION_EX** ptr64, uint32_t ptr32) {
	X32__FILE_LINK_INFORMATION_EX* x32_used_ptr = (X32__FILE_LINK_INFORMATION_EX*)ptr32;
	(*ptr64)->Flags = (long unsigned int)x32_used_ptr->Flags;
	(*ptr64)->RootDirectory = (void*)x32_used_ptr->RootDirectory;
	(*ptr64)->FileNameLength = (long unsigned int)x32_used_ptr->FileNameLength;

	CVT_COPY_STRING(wchar_t, FileName, FileNameLength);
};

void convert__ALPC_BASIC_INFORMATION_32TO64(void* ctx, _ALPC_BASIC_INFORMATION** ptr64, uint32_t ptr32) {
	X32__ALPC_BASIC_INFORMATION* x32_used_ptr = (X32__ALPC_BASIC_INFORMATION*)ptr32;
	(*ptr64)->Flags = (long unsigned int)x32_used_ptr->Flags;
	(*ptr64)->SequenceNo = (long unsigned int)x32_used_ptr->SequenceNo;
	(*ptr64)->PortContext = (void*)x32_used_ptr->PortContext;
};

void convert__ALPC_PORT_ATTRIBUTES_32TO64(void* ctx, _ALPC_PORT_ATTRIBUTES** ptr64, uint32_t ptr32) {
	X32__ALPC_PORT_ATTRIBUTES* x32_used_ptr = (X32__ALPC_PORT_ATTRIBUTES*)ptr32;
	(*ptr64)->Flags = (long unsigned int)x32_used_ptr->Flags;
	(*ptr64)->SecurityQos = (_SECURITY_QUALITY_OF_SERVICE)x32_used_ptr->SecurityQos;
	(*ptr64)->MaxMessageLength = (long long unsigned int)x32_used_ptr->MaxMessageLength;
	(*ptr64)->MemoryBandwidth = (long long unsigned int)x32_used_ptr->MemoryBandwidth;
	(*ptr64)->MaxPoolUsage = (long long unsigned int)x32_used_ptr->MaxPoolUsage;
	(*ptr64)->MaxSectionSize = (long long unsigned int)x32_used_ptr->MaxSectionSize;
	(*ptr64)->MaxViewSize = (long long unsigned int)x32_used_ptr->MaxViewSize;
	(*ptr64)->MaxTotalSectionSize = (long long unsigned int)x32_used_ptr->MaxTotalSectionSize;
	(*ptr64)->DupObjectTypes = (long unsigned int)x32_used_ptr->DupObjectTypes;
	(*ptr64)->Reserved = (long unsigned int)x32_used_ptr->Reserved;
};

void convert__ALPC_PORT_ASSOCIATE_COMPLETION_PORT_32TO64(void* ctx, _ALPC_PORT_ASSOCIATE_COMPLETION_PORT** ptr64, uint32_t ptr32) {
	X32__ALPC_PORT_ASSOCIATE_COMPLETION_PORT* x32_used_ptr = (X32__ALPC_PORT_ASSOCIATE_COMPLETION_PORT*)ptr32;
	(*ptr64)->CompletionKey = (void*)x32_used_ptr->CompletionKey;
	(*ptr64)->CompletionPort = (void*)x32_used_ptr->CompletionPort;
};

void convert__ALPC_PORT_MESSAGE_ZONE_INFORMATION_32TO64(void* ctx, _ALPC_PORT_MESSAGE_ZONE_INFORMATION** ptr64, uint32_t ptr32) {
	X32__ALPC_PORT_MESSAGE_ZONE_INFORMATION* x32_used_ptr = (X32__ALPC_PORT_MESSAGE_ZONE_INFORMATION*)ptr32;
	(*ptr64)->Buffer = (void*)x32_used_ptr->Buffer;
	(*ptr64)->Size = (long unsigned int)x32_used_ptr->Size;
};

void convert__ALPC_PORT_COMPLETION_LIST_INFORMATION_32TO64(void* ctx, _ALPC_PORT_COMPLETION_LIST_INFORMATION** ptr64, uint32_t ptr32) {
	X32__ALPC_PORT_COMPLETION_LIST_INFORMATION* x32_used_ptr = (X32__ALPC_PORT_COMPLETION_LIST_INFORMATION*)ptr32;
	(*ptr64)->Buffer = (void*)x32_used_ptr->Buffer;
	(*ptr64)->Size = (long unsigned int)x32_used_ptr->Size;
	(*ptr64)->ConcurrencyCount = (long unsigned int)x32_used_ptr->ConcurrencyCount;
	(*ptr64)->AttributeFlags = (long unsigned int)x32_used_ptr->AttributeFlags;
};

void convert_MEM_EXTENDED_PARAMETER_32TO64(void* ctx, MEM_EXTENDED_PARAMETER** ptr64, uint32_t ptr32) {
	X32_MEM_EXTENDED_PARAMETER* x32_used_ptr = (X32_MEM_EXTENDED_PARAMETER*)ptr32;
//#pragma error('Here Ignored struct fix it')
//	(*ptr64)-> = (MEM_EXTENDED_PARAMETER)x32_used_ptr->;
//#pragma error('Here Ignored union fix it')
//	(*ptr64)-> = (MEM_EXTENDED_PARAMETER)x32_used_ptr->;
};

void convert__OBJECT_ATTRIBUTES_32TO64(void* ctx, _OBJECT_ATTRIBUTES** ptr64, uint32_t ptr32) {
	X32__OBJECT_ATTRIBUTES* x32_used_ptr = (X32__OBJECT_ATTRIBUTES*)ptr32;

	(*ptr64)->Length = sizeof(_OBJECT_ATTRIBUTES);
	(*ptr64)->RootDirectory = (void*)x32_used_ptr->RootDirectory;

	NESTED_CVT_32TO64_WITH_ALLOC(_UNICODE_STRING, ObjectName);

	(*ptr64)->Attributes = (long unsigned int)x32_used_ptr->Attributes;
	(*ptr64)->SecurityDescriptor = (void*)x32_used_ptr->SecurityDescriptor;
	(*ptr64)->SecurityQualityOfService = (void*)x32_used_ptr->SecurityQualityOfService;
};

void convert_HANDLE_32TO64(void* ctx, HANDLE** ptr64, uint32_t ptr32) {
	X32_HANDLE* x32_used_ptr = (X32_HANDLE*)ptr32;
	*(*ptr64) = Handle32ToHandle((const void* __ptr32) * x32_used_ptr);
};

void convert__MEMORY_RANGE_ENTRY_32TO64(void* ctx, _MEMORY_RANGE_ENTRY** ptr64, uint32_t ptr32) {
	X32__MEMORY_RANGE_ENTRY* x32_used_ptr = (X32__MEMORY_RANGE_ENTRY*)ptr32;
	(*ptr64)->VirtualAddress = (void*)x32_used_ptr->VirtualAddress;
	(*ptr64)->NumberOfBytes = (long long unsigned int)x32_used_ptr->NumberOfBytes;
};

void convert__CLIENT_ID_32TO64(void* ctx, _CLIENT_ID** ptr64, uint32_t ptr32) {
	X32__CLIENT_ID* x32_used_ptr = (X32__CLIENT_ID*)ptr32;
	(*ptr64)->UniqueProcess = (void*)x32_used_ptr->UniqueProcess;
	(*ptr64)->UniqueThread = (void*)x32_used_ptr->UniqueThread;
};

void convert__INITIAL_TEB_32TO64(void* ctx, _INITIAL_TEB** ptr64, uint32_t ptr32) {
	X32__INITIAL_TEB* x32_used_ptr = (X32__INITIAL_TEB*)ptr32;
//#pragma error('Here Ignored struct fix it')
//	(*ptr64)->OldInitialTeb = (_INITIAL_TEB)x32_used_ptr->OldInitialTeb;
	(*ptr64)->StackBase = (void*)x32_used_ptr->StackBase;
	(*ptr64)->StackLimit = (void*)x32_used_ptr->StackLimit;
	(*ptr64)->StackAllocationBase = (void*)x32_used_ptr->StackAllocationBase;
};

void convert__PS_CREATE_INFO_32TO64(void* ctx, _PS_CREATE_INFO** ptr64, uint32_t ptr32) {
	X32__PS_CREATE_INFO* x32_used_ptr = (X32__PS_CREATE_INFO*)ptr32;
	(*ptr64)->Size = (long long unsigned int)x32_used_ptr->Size;
	(*ptr64)->State = (_PS_CREATE_STATE)x32_used_ptr->State;

//#pragma error('Here Ignored union fix it')
//	(*ptr64)-> = (_PS_CREATE_INFO)x32_used_ptr->;
};

void convert__PS_ATTRIBUTE_LIST_32TO64(void* ctx, _PS_ATTRIBUTE_LIST** ptr64, uint32_t ptr32) {
	X32__PS_ATTRIBUTE_LIST* x32_used_ptr = (X32__PS_ATTRIBUTE_LIST*)ptr32;
	(*ptr64)->TotalLength = (long long unsigned int)x32_used_ptr->TotalLength;

//	(*ptr64)->Attributes = (_PS_ATTRIBUTE[1])x32_used_ptr->Attributes;
};

void convert__JOB_SET_ARRAY_32TO64(void* ctx, _JOB_SET_ARRAY** ptr64, uint32_t ptr32) {
	X32__JOB_SET_ARRAY* x32_used_ptr = (X32__JOB_SET_ARRAY*)ptr32;
	(*ptr64)->JobHandle = (void*)x32_used_ptr->JobHandle;
	(*ptr64)->MemberLevel = (long unsigned int)x32_used_ptr->MemberLevel;
	(*ptr64)->Flags = (long unsigned int)x32_used_ptr->Flags;
};

void convert__IO_STATUS_BLOCK_32TO64(void* ctx, _IO_STATUS_BLOCK** ptr64, uint32_t ptr32) {
	X32__IO_STATUS_BLOCK* x32_used_ptr = (X32__IO_STATUS_BLOCK*)ptr32;
	(*ptr64)->Pointer = (PVOID)x32_used_ptr->Pointer;
	(*ptr64)->Information = (long long unsigned int)x32_used_ptr->Information;
};

void convert__FILE_SEGMENT_ELEMENT_32TO64(void* ctx, _FILE_SEGMENT_ELEMENT** ptr64, uint32_t ptr32) {
	X32__FILE_SEGMENT_ELEMENT* x32_used_ptr = (X32__FILE_SEGMENT_ELEMENT*)ptr32;
	(*ptr64)->Buffer = (void*)x32_used_ptr->Buffer;
	(*ptr64)->Alignment = (long long unsigned int)x32_used_ptr->Alignment;
};

void convert__PORT_VIEW_32TO64(void* ctx, _PORT_VIEW** ptr64, uint32_t ptr32) {
	X32__PORT_VIEW* x32_used_ptr = (X32__PORT_VIEW*)ptr32;
	(*ptr64)->Length = (long unsigned int)x32_used_ptr->Length;
	(*ptr64)->SectionHandle = (void*)x32_used_ptr->SectionHandle;
	(*ptr64)->SectionOffset = (long unsigned int)x32_used_ptr->SectionOffset;
	(*ptr64)->ViewSize = (long long unsigned int)x32_used_ptr->ViewSize;
	(*ptr64)->ViewBase = (void*)x32_used_ptr->ViewBase;
	(*ptr64)->ViewRemoteBase = (void*)x32_used_ptr->ViewRemoteBase;
};

void convert__REMOTE_PORT_VIEW_32TO64(void* ctx, _REMOTE_PORT_VIEW** ptr64, uint32_t ptr32) {
	X32__REMOTE_PORT_VIEW* x32_used_ptr = (X32__REMOTE_PORT_VIEW*)ptr32;
	(*ptr64)->Length = (long unsigned int)x32_used_ptr->Length;
	(*ptr64)->ViewSize = (long long unsigned int)x32_used_ptr->ViewSize;
	(*ptr64)->ViewBase = (void*)x32_used_ptr->ViewBase;
};

void convert__PORT_MESSAGE_32TO64(void* ctx, _PORT_MESSAGE** ptr64, uint32_t ptr32) {
	X32__PORT_MESSAGE* x32_used_ptr = (X32__PORT_MESSAGE*)ptr32;

	/*
#pragma error('Here Ignored union fix it')
	(*ptr64)->u1 = (_PORT_MESSAGE)x32_used_ptr->u1;
#pragma error('Here Ignored union fix it')
	(*ptr64)->u2 = (_PORT_MESSAGE)x32_used_ptr->u2;
#pragma error('Here Ignored union fix it')
	(*ptr64)-> = (_PORT_MESSAGE)x32_used_ptr->;
	(*ptr64)->MessageId = (long unsigned int)x32_used_ptr->MessageId;
#pragma error('Here Ignored union fix it')
	(*ptr64)-> = (_PORT_MESSAGE)x32_used_ptr->;
	*/
};

void convert__ALPC_DATA_VIEW_ATTR_32TO64(void* ctx, _ALPC_DATA_VIEW_ATTR** ptr64, uint32_t ptr32) {
	X32__ALPC_DATA_VIEW_ATTR* x32_used_ptr = (X32__ALPC_DATA_VIEW_ATTR*)ptr32;
	(*ptr64)->Flags = (long unsigned int)x32_used_ptr->Flags;
	(*ptr64)->SectionHandle = (void*)x32_used_ptr->SectionHandle;
	(*ptr64)->ViewBase = (void*)x32_used_ptr->ViewBase;
	(*ptr64)->ViewSize = (long long unsigned int)x32_used_ptr->ViewSize;
};

void convert__ALPC_SECURITY_ATTR_32TO64(void* ctx, _ALPC_SECURITY_ATTR** ptr64, uint32_t ptr32) {
	X32__ALPC_SECURITY_ATTR* x32_used_ptr = (X32__ALPC_SECURITY_ATTR*)ptr32;
	(*ptr64)->Flags = (long unsigned int)x32_used_ptr->Flags;
	(*ptr64)->QoS = (_SECURITY_QUALITY_OF_SERVICE*)x32_used_ptr->QoS;
	(*ptr64)->ContextHandle = (void*)x32_used_ptr->ContextHandle;
};

void convert__ALPC_CONTEXT_ATTR_32TO64(void* ctx, _ALPC_CONTEXT_ATTR** ptr64, uint32_t ptr32) {
	X32__ALPC_CONTEXT_ATTR* x32_used_ptr = (X32__ALPC_CONTEXT_ATTR*)ptr32;
	(*ptr64)->PortContext = (void*)x32_used_ptr->PortContext;
	(*ptr64)->MessageContext = (void*)x32_used_ptr->MessageContext;
	(*ptr64)->Sequence = (long unsigned int)x32_used_ptr->Sequence;
	(*ptr64)->MessageId = (long unsigned int)x32_used_ptr->MessageId;
	(*ptr64)->CallbackId = (long unsigned int)x32_used_ptr->CallbackId;
};

void convert__KEY_VALUE_ENTRY_32TO64(void* ctx, _KEY_VALUE_ENTRY** ptr64, uint32_t ptr32) {
	X32__KEY_VALUE_ENTRY* x32_used_ptr = (X32__KEY_VALUE_ENTRY*)ptr32;
	NESTED_CVT_32TO64_WITH_ALLOC(_UNICODE_STRING, ValueName);
	(*ptr64)->DataLength = (long unsigned int)x32_used_ptr->DataLength;
	(*ptr64)->DataOffset = (long unsigned int)x32_used_ptr->DataOffset;
	(*ptr64)->Type = (long unsigned int)x32_used_ptr->Type;
};

void convert__TOKEN_USER_32TO64(void* ctx, _TOKEN_USER** ptr64, uint32_t ptr32) {
	X32__TOKEN_USER* x32_used_ptr = (X32__TOKEN_USER*)ptr32;
	NESTED_CVT_32TO64(_SID_AND_ATTRIBUTES, User);
};

void convert__TOKEN_GROUPS_32TO64(void* ctx, _TOKEN_GROUPS** ptr64, uint32_t ptr32) {
	X32__TOKEN_GROUPS* x32_used_ptr = (X32__TOKEN_GROUPS*)ptr32;
	(*ptr64)->GroupCount = (long unsigned int)x32_used_ptr->GroupCount;

//	(*ptr64)->Groups = (_SID_AND_ATTRIBUTES[1])x32_used_ptr->Groups;
};

void convert__TOKEN_OWNER_32TO64(void* ctx, _TOKEN_OWNER** ptr64, uint32_t ptr32) {
	X32__TOKEN_OWNER* x32_used_ptr = (X32__TOKEN_OWNER*)ptr32;
	(*ptr64)->Owner = (void*)x32_used_ptr->Owner;
};

void convert__TOKEN_PRIMARY_GROUP_32TO64(void* ctx, _TOKEN_PRIMARY_GROUP** ptr64, uint32_t ptr32) {
	X32__TOKEN_PRIMARY_GROUP* x32_used_ptr = (X32__TOKEN_PRIMARY_GROUP*)ptr32;
	(*ptr64)->PrimaryGroup = (void*)x32_used_ptr->PrimaryGroup;
};

void convert__TOKEN_DEFAULT_DACL_32TO64(void* ctx, _TOKEN_DEFAULT_DACL** ptr64, uint32_t ptr32) {
	X32__TOKEN_DEFAULT_DACL* x32_used_ptr = (X32__TOKEN_DEFAULT_DACL*)ptr32;
	(*ptr64)->DefaultDacl = (_ACL*)x32_used_ptr->DefaultDacl;
};

void convert__SID_AND_ATTRIBUTES_32TO64(void* ctx, _SID_AND_ATTRIBUTES** ptr64, uint32_t ptr32) {
	X32__SID_AND_ATTRIBUTES* x32_used_ptr = (X32__SID_AND_ATTRIBUTES*)ptr32;
	(*ptr64)->Sid = (void*)x32_used_ptr->Sid;
	(*ptr64)->Attributes = (long unsigned int)x32_used_ptr->Attributes;
};

void convert__TOKEN_SECURITY_ATTRIBUTES_INFORMATION_32TO64(void* ctx, _TOKEN_SECURITY_ATTRIBUTES_INFORMATION** ptr64, uint32_t ptr32) {
	X32__TOKEN_SECURITY_ATTRIBUTES_INFORMATION* x32_used_ptr = (X32__TOKEN_SECURITY_ATTRIBUTES_INFORMATION*)ptr32;
	(*ptr64)->Version = (short unsigned int)x32_used_ptr->Version;
	(*ptr64)->Reserved = (short unsigned int)x32_used_ptr->Reserved;
	(*ptr64)->AttributeCount = (long unsigned int)x32_used_ptr->AttributeCount;
//#pragma error('Here Ignored union fix it')
//	(*ptr64)->Attribute = (_TOKEN_SECURITY_ATTRIBUTES_INFORMATION)x32_used_ptr->Attribute;
};

void convert__OBJECT_TYPE_LIST_32TO64(void* ctx, _OBJECT_TYPE_LIST** ptr64, uint32_t ptr32) {
	X32__OBJECT_TYPE_LIST* x32_used_ptr = (X32__OBJECT_TYPE_LIST*)ptr32;
	(*ptr64)->Level = (short unsigned int)x32_used_ptr->Level;
	(*ptr64)->Sbz = (short unsigned int)x32_used_ptr->Sbz;
	(*ptr64)->ObjectType = (_GUID*)x32_used_ptr->ObjectType;
};

void convert__EXCEPTION_RECORD_32TO64(void* ctx, _EXCEPTION_RECORD** ptr64, uint32_t ptr32) {
	X32__EXCEPTION_RECORD* x32_used_ptr = (X32__EXCEPTION_RECORD*)ptr32;
	(*ptr64)->ExceptionCode = (long unsigned int)x32_used_ptr->ExceptionCode;
	(*ptr64)->ExceptionFlags = (long unsigned int)x32_used_ptr->ExceptionFlags;
	(*ptr64)->ExceptionRecord = (_EXCEPTION_RECORD*)x32_used_ptr->ExceptionRecord;
	(*ptr64)->ExceptionAddress = (void*)x32_used_ptr->ExceptionAddress;
	(*ptr64)->NumberParameters = (long unsigned int)x32_used_ptr->NumberParameters;

	//	(*ptr64)->ExceptionInformation = (long long unsigned int[15])x32_used_ptr->ExceptionInformation;
};

#undef CVT_COPY_STRING
```

`src/HIGU_ntcall_3264/thunk64_convertors64to32.h`:

```h

#pragma warning(push)
#pragma warning(disable: 4244)


#define NESTED_CVT_64TO32(type, var_name) \
	{\
		convert_##type##_64TO32(ctx, &ptr64->##var_name, (uint32_t)&x32_used_ptr->##var_name);\
	}

#define CVT_COPY_STRING(type, var_name, var_len_name) __movsb((PBYTE)&x32_used_ptr->##var_name[0], (PBYTE)&(*ptr64)->##var_name[0], x32_used_ptr->##var_len_name);

#define CVT_UNICODE_STRING_OFFSETABLE(base_name, var_name) \
	{\
		convert__UNICODE_STRING_64TO32(ctx, &(ptr64)->##var_name, (uint32_t)&x32_used_ptr->##var_name);\
		x32_used_ptr->##var_name.Buffer = (ULONG)ptr32 + (((uint64_t)(ptr64)->##var_name.Buffer) - ((uint64_t)base_name));\
		__movsb((PBYTE)x32_used_ptr->##var_name.Buffer, (PBYTE)&(ptr64)->##var_name.Buffer[0], (ptr64)->##var_name.Length);\
	}

#define CVT_UNICODE_STRING_OFFSETABLE_FUNC64TO32(ptr64, ptr32) \
	{\
		convert__UNICODE_STRING_64TO32(ctx, ptr64, (uint32_t)ptr32);\
		((X32__UNICODE_STRING*)ptr32)->Buffer = (ULONG)ptr32 + (((uint64_t)(ptr64)->Buffer) - ((uint64_t)ptr64));\
		__movsb((PBYTE)((X32__UNICODE_STRING*)ptr32)->Buffer, (PBYTE)&(ptr64)->Buffer[0], (ptr64)->Length);\
	}

void convert__SYSTEM_BASIC_INFORMATION_64TO32(void* ctx, _SYSTEM_BASIC_INFORMATION*, uint32_t ptr32);
void convert__SYSTEM_PROCESS_INFORMATION_64TO32(void* ctx, _SYSTEM_PROCESS_INFORMATION*, uint32_t ptr32);
void convert__SYSTEM_POOL_INFORMATION_64TO32(void* ctx, _SYSTEM_POOL_INFORMATION*, uint32_t ptr32);
void convert__SYSTEM_PAGEFILE_INFORMATION_64TO32(void* ctx, _SYSTEM_PAGEFILE_INFORMATION*, uint32_t ptr32);
void convert__SYSTEM_FILECACHE_INFORMATION_64TO32(void* ctx, _SYSTEM_FILECACHE_INFORMATION*, uint32_t ptr32);
void convert__SYSTEM_REGISTRY_QUOTA_INFORMATION_64TO32(void* ctx, _SYSTEM_REGISTRY_QUOTA_INFORMATION*, uint32_t ptr32);
void convert__SYSTEM_LEGACY_DRIVER_INFORMATION_64TO32(void* ctx, _SYSTEM_LEGACY_DRIVER_INFORMATION*, uint32_t ptr32);
void convert__SYSTEM_VERIFIER_INFORMATION_64TO32(void* ctx, _SYSTEM_VERIFIER_INFORMATION*, uint32_t ptr32);
void convert__SYSTEM_SESSION_PROCESS_INFORMATION_64TO32(void* ctx, _SYSTEM_SESSION_PROCESS_INFORMATION*, uint32_t ptr32);
void convert__SYSTEM_HANDLE_INFORMATION_EX_64TO32(void* ctx, _SYSTEM_HANDLE_INFORMATION_EX*, uint32_t ptr32);
void convert__SYSTEM_SESSION_POOLTAG_INFORMATION_64TO32(void* ctx, _SYSTEM_SESSION_POOLTAG_INFORMATION*, uint32_t ptr32);
void convert__SYSTEM_SESSION_MAPPED_VIEW_INFORMATION_64TO32(void* ctx, _SYSTEM_SESSION_MAPPED_VIEW_INFORMATION*, uint32_t ptr32);
void convert__SYSTEM_FIRMWARE_TABLE_HANDLER_64TO32(void* ctx, _SYSTEM_FIRMWARE_TABLE_HANDLER*, uint32_t ptr32);
void convert__RTL_PROCESS_MODULE_INFORMATION_EX_64TO32(void* ctx, _RTL_PROCESS_MODULE_INFORMATION_EX*, uint32_t ptr32);
void convert__SUPERFETCH_INFORMATION_64TO32(void* ctx, _SUPERFETCH_INFORMATION*, uint32_t ptr32);
void convert__SYSTEM_MEMORY_LIST_INFORMATION_64TO32(void* ctx, _SYSTEM_MEMORY_LIST_INFORMATION*, uint32_t ptr32);
void convert__SYSTEM_REF_TRACE_INFORMATION_64TO32(void* ctx, _SYSTEM_REF_TRACE_INFORMATION*, uint32_t ptr32);
void convert__SYSTEM_PROCESS_ID_INFORMATION_64TO32(void* ctx, _SYSTEM_PROCESS_ID_INFORMATION*, uint32_t ptr32);
void convert__SYSTEM_VERIFIER_INFORMATION_EX_64TO32(void* ctx, _SYSTEM_VERIFIER_INFORMATION_EX*, uint32_t ptr32);
void convert__SYSTEM_SYSTEM_PARTITION_INFORMATION_64TO32(void* ctx, _SYSTEM_SYSTEM_PARTITION_INFORMATION*, uint32_t ptr32);
void convert__SYSTEM_SYSTEM_DISK_INFORMATION_64TO32(void* ctx, _SYSTEM_SYSTEM_DISK_INFORMATION*, uint32_t ptr32);
void convert__SYSTEM_BASIC_PERFORMANCE_INFORMATION_64TO32(void* ctx, _SYSTEM_BASIC_PERFORMANCE_INFORMATION*, uint32_t ptr32);
void convert__SYSTEM_POLICY_INFORMATION_64TO32(void* ctx, _SYSTEM_POLICY_INFORMATION*, uint32_t ptr32);
void convert__SYSTEM_MANUFACTURING_INFORMATION_64TO32(void* ctx, _SYSTEM_MANUFACTURING_INFORMATION*, uint32_t ptr32);
void convert__SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS_64TO32(void* ctx, _SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS*, uint32_t ptr32);
void convert__SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION_64TO32(void* ctx, _SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION*, uint32_t ptr32);
void convert__UNICODE_STRING_64TO32(void* ctx, _UNICODE_STRING*, uint32_t ptr32);
void convert__MEMORY_BASIC_INFORMATION_64TO32(void* ctx, _MEMORY_BASIC_INFORMATION*, uint32_t ptr32);
void convert__MEMORY_WORKING_SET_INFORMATION_64TO32(void* ctx, _MEMORY_WORKING_SET_INFORMATION*, uint32_t ptr32);
void convert__MEMORY_REGION_INFORMATION_64TO32(void* ctx, _MEMORY_REGION_INFORMATION*, uint32_t ptr32);
void convert__MEMORY_WORKING_SET_EX_INFORMATION_64TO32(void* ctx, _MEMORY_WORKING_SET_EX_INFORMATION*, uint32_t ptr32);
void convert__SECTION_BASIC_INFORMATION_64TO32(void* ctx, _SECTION_BASIC_INFORMATION*, uint32_t ptr32);
void convert__SECTION_IMAGE_INFORMATION_64TO32(void* ctx, _SECTION_IMAGE_INFORMATION*, uint32_t ptr32);
void convert__OBJECT_NAME_INFORMATION_64TO32(void* ctx, _OBJECT_NAME_INFORMATION*, uint32_t ptr32);
void convert__OBJECT_TYPE_INFORMATION_64TO32(void* ctx, _OBJECT_TYPE_INFORMATION*, uint32_t ptr32);
void convert__PROCESS_BASIC_INFORMATION_64TO32(void* ctx, _PROCESS_BASIC_INFORMATION*, uint32_t ptr32);
void convert__QUOTA_LIMITS_64TO32(void* ctx, _QUOTA_LIMITS*, uint32_t ptr32);
void convert__VM_COUNTERS_64TO32(void* ctx, _VM_COUNTERS*, uint32_t ptr32);
void convert__POOLED_USAGE_AND_LIMITS_64TO32(void* ctx, _POOLED_USAGE_AND_LIMITS*, uint32_t ptr32);
void convert__PROCESS_WS_WATCH_INFORMATION_64TO32(void* ctx, _PROCESS_WS_WATCH_INFORMATION*, uint32_t ptr32);
void convert__PROCESS_DEVICEMAP_INFORMATION_64TO32(void* ctx, _PROCESS_DEVICEMAP_INFORMATION*, uint32_t ptr32);
void convert__PROCESS_HANDLE_TRACING_QUERY_64TO32(void* ctx, _PROCESS_HANDLE_TRACING_QUERY*, uint32_t ptr32);
void convert__PROCESS_WS_WATCH_INFORMATION_EX_64TO32(void* ctx, _PROCESS_WS_WATCH_INFORMATION_EX*, uint32_t ptr32);
void convert__PROCESS_HANDLE_SNAPSHOT_INFORMATION_64TO32(void* ctx, _PROCESS_HANDLE_SNAPSHOT_INFORMATION*, uint32_t ptr32);
void convert__THREAD_BASIC_INFORMATION_64TO32(void* ctx, _THREAD_BASIC_INFORMATION*, uint32_t ptr32);
void convert__THREAD_LAST_SYSCALL_INFORMATION_64TO32(void* ctx, _THREAD_LAST_SYSCALL_INFORMATION*, uint32_t ptr32);
void convert__THREAD_TEB_INFORMATION_64TO32(void* ctx, _THREAD_TEB_INFORMATION*, uint32_t ptr32);
void convert__GROUP_AFFINITY_64TO32(void* ctx, _GROUP_AFFINITY*, uint32_t ptr32);
void convert__THREAD_PROFILING_INFORMATION_64TO32(void* ctx, _THREAD_PROFILING_INFORMATION*, uint32_t ptr32);
void convert__THREAD_NAME_INFORMATION_64TO32(void* ctx, _THREAD_NAME_INFORMATION*, uint32_t ptr32);
void convert__ALPC_BASIC_INFORMATION_64TO32(void* ctx, _ALPC_BASIC_INFORMATION*, uint32_t ptr32);
void convert__ALPC_SERVER_INFORMATION_64TO32(void* ctx, _ALPC_SERVER_INFORMATION*, uint32_t ptr32);
void convert_MEM_EXTENDED_PARAMETER_64TO32(void* ctx, MEM_EXTENDED_PARAMETER*, uint32_t ptr32);
void convert_HANDLE_64TO32(void* ctx, HANDLE*, uint32_t ptr32);
void convert__FILE_IO_COMPLETION_INFORMATION_64TO32(void* ctx, _FILE_IO_COMPLETION_INFORMATION*, uint32_t ptr32);
void convert__CLIENT_ID_64TO32(void* ctx, _CLIENT_ID*, uint32_t ptr32);
void convert__PS_CREATE_INFO_64TO32(void* ctx, _PS_CREATE_INFO*, uint32_t ptr32);
void convert__DBGUI_WAIT_STATE_CHANGE_64TO32(void* ctx, _DBGUI_WAIT_STATE_CHANGE*, uint32_t ptr32);
void convert__IO_STATUS_BLOCK_64TO32(void* ctx, _IO_STATUS_BLOCK*, uint32_t ptr32);
void convert__PORT_VIEW_64TO32(void* ctx, _PORT_VIEW*, uint32_t ptr32);
void convert__REMOTE_PORT_VIEW_64TO32(void* ctx, _REMOTE_PORT_VIEW*, uint32_t ptr32);
void convert__PORT_MESSAGE_64TO32(void* ctx, _PORT_MESSAGE*, uint32_t ptr32);
void convert__ALPC_DATA_VIEW_ATTR_64TO32(void* ctx, _ALPC_DATA_VIEW_ATTR*, uint32_t ptr32);
void convert__ALPC_SECURITY_ATTR_64TO32(void* ctx, _ALPC_SECURITY_ATTR*, uint32_t ptr32);
void convert__KEY_VALUE_ENTRY_64TO32(void* ctx, _KEY_VALUE_ENTRY*, uint32_t ptr32);
void convert__TOKEN_GROUPS_64TO32(void* ctx, _TOKEN_GROUPS*, uint32_t ptr32);
void convert__TOKEN_SECURITY_ATTRIBUTES_INFORMATION_64TO32(void* ctx, _TOKEN_SECURITY_ATTRIBUTES_INFORMATION*, uint32_t ptr32);
void convert__TRANSACTION_NOTIFICATION_64TO32(void* ctx, _TRANSACTION_NOTIFICATION*, uint32_t ptr32);


void convert__SYSTEM_BASIC_INFORMATION_64TO32(void* ctx, _SYSTEM_BASIC_INFORMATION* ptr64, uint32_t ptr32) {
	X32__SYSTEM_BASIC_INFORMATION* x32_used_ptr = (X32__SYSTEM_BASIC_INFORMATION*)ptr32;
	x32_used_ptr->Reserved = (long unsigned int)ptr64->Reserved;
	x32_used_ptr->TimerResolution = (long unsigned int)ptr64->TimerResolution;
	x32_used_ptr->PageSize = (long unsigned int)ptr64->PageSize;
	x32_used_ptr->NumberOfPhysicalPages = (long unsigned int)ptr64->NumberOfPhysicalPages;
	x32_used_ptr->LowestPhysicalPageNumber = (long unsigned int)ptr64->LowestPhysicalPageNumber;
	x32_used_ptr->HighestPhysicalPageNumber = (long unsigned int)ptr64->HighestPhysicalPageNumber;
	x32_used_ptr->AllocationGranularity = (long unsigned int)ptr64->AllocationGranularity;
	x32_used_ptr->MinimumUserModeAddress = (long long unsigned int)ptr64->MinimumUserModeAddress;
	x32_used_ptr->MaximumUserModeAddress = (long long unsigned int)ptr64->MaximumUserModeAddress;
	x32_used_ptr->ActiveProcessorsAffinityMask = (long long unsigned int)ptr64->ActiveProcessorsAffinityMask;
	x32_used_ptr->NumberOfProcessors = (char)ptr64->NumberOfProcessors;
};

void convert__SYSTEM_THREAD_INFORMATION_64TO32(void* ctx, _SYSTEM_THREAD_INFORMATION* ptr64, uint32_t ptr32) {
	X32_SYSTEM_THREAD_INFORMATION* x32_used_ptr = (X32__SYSTEM_THREAD_INFORMATION*)ptr32;
	x32_used_ptr->KernelTime = ptr64->KernelTime;
	x32_used_ptr->UserTime = ptr64->UserTime;
	x32_used_ptr->CreateTime = ptr64->CreateTime;
	x32_used_ptr->WaitTime = ptr64->WaitTime;
	x32_used_ptr->StartAddress = (X32_PVOID)ptr64->StartAddress;
	NESTED_CVT_64TO32(_CLIENT_ID, ClientId);
	x32_used_ptr->Priority = ptr64->Priority;
	x32_used_ptr->BasePriority = ptr64->BasePriority;
	x32_used_ptr->ContextSwitches = ptr64->ContextSwitches;
	x32_used_ptr->ThreadState = ptr64->ThreadState;
	x32_used_ptr->WaitReason = ptr64->WaitReason;
}


void convert__SYSTEM_PROCESS_INFORMATION_64TO32(void* ctx, _SYSTEM_PROCESS_INFORMATION* ptr64, uint32_t ptr32) {
	X32__SYSTEM_PROCESS_INFORMATION* x32_used_ptr = (X32__SYSTEM_PROCESS_INFORMATION*)ptr32;

	_SYSTEM_PROCESS_INFORMATION* ptr64_original = ptr64;

	do {

		x32_used_ptr->NextEntryOffset = (long unsigned int)ptr64->NextEntryOffset;
		x32_used_ptr->NumberOfThreads = (long unsigned int)ptr64->NumberOfThreads;
		x32_used_ptr->WorkingSetPrivateSize = (_LARGE_INTEGER)ptr64->WorkingSetPrivateSize;
		x32_used_ptr->HardFaultCount = (long unsigned int)ptr64->HardFaultCount;
		x32_used_ptr->NumberOfThreadsHighWatermark = (long unsigned int)ptr64->NumberOfThreadsHighWatermark;
		x32_used_ptr->CycleTime = (long long unsigned int)ptr64->CycleTime;
		x32_used_ptr->CreateTime = (_LARGE_INTEGER)ptr64->CreateTime;
		x32_used_ptr->UserTime = (_LARGE_INTEGER)ptr64->UserTime;
		x32_used_ptr->KernelTime = (_LARGE_INTEGER)ptr64->KernelTime;

		CVT_UNICODE_STRING_OFFSETABLE(ptr64_original, ImageName);

		x32_used_ptr->BasePriority = (long int)ptr64->BasePriority;
		x32_used_ptr->UniqueProcessId = (X32_PVOID)ptr64->UniqueProcessId;
		x32_used_ptr->InheritedFromUniqueProcessId = (X32_PVOID)ptr64->InheritedFromUniqueProcessId;
		x32_used_ptr->HandleCount = (long unsigned int)ptr64->HandleCount;
		x32_used_ptr->SessionId = (long unsigned int)ptr64->SessionId;
		x32_used_ptr->UniqueProcessKey = (long long unsigned int)ptr64->UniqueProcessKey;
		x32_used_ptr->PeakVirtualSize = (long long unsigned int)ptr64->PeakVirtualSize;
		x32_used_ptr->VirtualSize = (long long unsigned int)ptr64->VirtualSize;
		x32_used_ptr->PageFaultCount = (long unsigned int)ptr64->PageFaultCount;
		x32_used_ptr->PeakWorkingSetSize = (long long unsigned int)ptr64->PeakWorkingSetSize;
		x32_used_ptr->WorkingSetSize = (long long unsigned int)ptr64->WorkingSetSize;
		x32_used_ptr->QuotaPeakPagedPoolUsage = (long long unsigned int)ptr64->QuotaPeakPagedPoolUsage;
		x32_used_ptr->QuotaPagedPoolUsage = (long long unsigned int)ptr64->QuotaPagedPoolUsage;
		x32_used_ptr->QuotaPeakNonPagedPoolUsage = (long long unsigned int)ptr64->QuotaPeakNonPagedPoolUsage;
		x32_used_ptr->QuotaNonPagedPoolUsage = (long long unsigned int)ptr64->QuotaNonPagedPoolUsage;
		x32_used_ptr->PagefileUsage = (long long unsigned int)ptr64->PagefileUsage;
		x32_used_ptr->PeakPagefileUsage = (long long unsigned int)ptr64->PeakPagefileUsage;
		x32_used_ptr->PrivatePageCount = (long long unsigned int)ptr64->PrivatePageCount;
		x32_used_ptr->ReadOperationCount = (_LARGE_INTEGER)ptr64->ReadOperationCount;
		x32_used_ptr->WriteOperationCount = (_LARGE_INTEGER)ptr64->WriteOperationCount;
		x32_used_ptr->OtherOperationCount = (_LARGE_INTEGER)ptr64->OtherOperationCount;
		x32_used_ptr->ReadTransferCount = (_LARGE_INTEGER)ptr64->ReadTransferCount;
		x32_used_ptr->WriteTransferCount = (_LARGE_INTEGER)ptr64->WriteTransferCount;
		x32_used_ptr->OtherTransferCount = (_LARGE_INTEGER)ptr64->OtherTransferCount;

		for (size_t idx = 0; idx < x32_used_ptr->NumberOfThreads; idx++) {
			NESTED_CVT_64TO32(_SYSTEM_THREAD_INFORMATION, Threads[idx]);
		}

	} while (ptr64->NextEntryOffset ? 
			((x32_used_ptr = (X32__SYSTEM_PROCESS_INFORMATION*)((LPBYTE)x32_used_ptr + ptr64->NextEntryOffset)) &&
			(ptr64 = (_SYSTEM_PROCESS_INFORMATION*)((LPBYTE)ptr64 + ptr64->NextEntryOffset)))
		: FALSE);
};

void convert__SYSTEM_POOL_ENTRY_64TO32(void* ctx, _SYSTEM_POOL_ENTRY* ptr64, uint32_t ptr32) {
	X32__SYSTEM_POOL_ENTRY* x32_used_ptr = (X32__SYSTEM_POOL_ENTRY*)ptr32;
	///////////////////
}

void convert__SYSTEM_POOL_INFORMATION_64TO32(void* ctx, _SYSTEM_POOL_INFORMATION* ptr64, uint32_t ptr32) {
	X32__SYSTEM_POOL_INFORMATION* x32_used_ptr = (X32__SYSTEM_POOL_INFORMATION*)ptr32;
	x32_used_ptr->TotalSize = (long long unsigned int)ptr64->TotalSize;
	x32_used_ptr->FirstEntry = (X32_PVOID)ptr64->FirstEntry;
	x32_used_ptr->EntryOverhead = (short unsigned int)ptr64->EntryOverhead;
	x32_used_ptr->PoolTagPresent = (unsigned char)ptr64->PoolTagPresent;
	x32_used_ptr->Spare0 = (unsigned char)ptr64->Spare0;
	x32_used_ptr->NumberOfEntries = (long unsigned int)ptr64->NumberOfEntries;
	
	for (size_t idx = 0; idx < x32_used_ptr->NumberOfEntries; idx++) {
		NESTED_CVT_64TO32(_SYSTEM_POOL_ENTRY, Entries[idx]);
	}
};

void convert__SYSTEM_PAGEFILE_INFORMATION_64TO32(void* ctx, _SYSTEM_PAGEFILE_INFORMATION* ptr64, uint32_t ptr32) {
	X32__SYSTEM_PAGEFILE_INFORMATION* x32_used_ptr = (X32__SYSTEM_PAGEFILE_INFORMATION*)ptr32;
	x32_used_ptr->NextEntryOffset = (long unsigned int)ptr64->NextEntryOffset;
	x32_used_ptr->TotalSize = (long unsigned int)ptr64->TotalSize;
	x32_used_ptr->TotalInUse = (long unsigned int)ptr64->TotalInUse;
	x32_used_ptr->PeakUsage = (long unsigned int)ptr64->PeakUsage;
	CVT_UNICODE_STRING_OFFSETABLE(ptr64, PageFileName);
};

void convert__SYSTEM_FILECACHE_INFORMATION_64TO32(void* ctx, _SYSTEM_FILECACHE_INFORMATION* ptr64, uint32_t ptr32) {
	X32__SYSTEM_FILECACHE_INFORMATION* x32_used_ptr = (X32__SYSTEM_FILECACHE_INFORMATION*)ptr32;
	x32_used_ptr->CurrentSize = (long long unsigned int)ptr64->CurrentSize;
	x32_used_ptr->PeakSize = (long long unsigned int)ptr64->PeakSize;
	x32_used_ptr->PageFaultCount = (long unsigned int)ptr64->PageFaultCount;
	x32_used_ptr->MinimumWorkingSet = (long long unsigned int)ptr64->MinimumWorkingSet;
	x32_used_ptr->MaximumWorkingSet = (long long unsigned int)ptr64->MaximumWorkingSet;
	x32_used_ptr->CurrentSizeIncludingTransitionInPages = (long long unsigned int)ptr64->CurrentSizeIncludingTransitionInPages;
	x32_used_ptr->PeakSizeIncludingTransitionInPages = (long long unsigned int)ptr64->PeakSizeIncludingTransitionInPages;
	x32_used_ptr->TransitionRePurposeCount = (long unsigned int)ptr64->TransitionRePurposeCount;
	x32_used_ptr->Flags = (long unsigned int)ptr64->Flags;
};

void convert__SYSTEM_REGISTRY_QUOTA_INFORMATION_64TO32(void* ctx, _SYSTEM_REGISTRY_QUOTA_INFORMATION* ptr64, uint32_t ptr32) {
	X32__SYSTEM_REGISTRY_QUOTA_INFORMATION* x32_used_ptr = (X32__SYSTEM_REGISTRY_QUOTA_INFORMATION*)ptr32;
	x32_used_ptr->RegistryQuotaAllowed = (long unsigned int)ptr64->RegistryQuotaAllowed;
	x32_used_ptr->RegistryQuotaUsed = (long unsigned int)ptr64->RegistryQuotaUsed;
	x32_used_ptr->PagedPoolSize = (long long unsigned int)ptr64->PagedPoolSize;
};

void convert__SYSTEM_LEGACY_DRIVER_INFORMATION_64TO32(void* ctx, _SYSTEM_LEGACY_DRIVER_INFORMATION* ptr64, uint32_t ptr32) {
	X32__SYSTEM_LEGACY_DRIVER_INFORMATION* x32_used_ptr = (X32__SYSTEM_LEGACY_DRIVER_INFORMATION*)ptr32;
	x32_used_ptr->VetoType = (long unsigned int)ptr64->VetoType;
	CVT_UNICODE_STRING_OFFSETABLE(ptr64, VetoList);
};

void convert__SYSTEM_VERIFIER_INFORMATION_64TO32(void* ctx, _SYSTEM_VERIFIER_INFORMATION* ptr64, uint32_t ptr32) {
	X32__SYSTEM_VERIFIER_INFORMATION* x32_used_ptr = (X32__SYSTEM_VERIFIER_INFORMATION*)ptr32;
	x32_used_ptr->NextEntryOffset = (long unsigned int)ptr64->NextEntryOffset;
	x32_used_ptr->Level = (long unsigned int)ptr64->Level;
	x32_used_ptr->RuleClasses[0] = (long unsigned int)ptr64->RuleClasses[0];
	x32_used_ptr->RuleClasses[1] = (long unsigned int)ptr64->RuleClasses[1];
	x32_used_ptr->TriageContext = (long unsigned int)ptr64->TriageContext;
	x32_used_ptr->AreAllDriversBeingVerified = (long unsigned int)ptr64->AreAllDriversBeingVerified;
	CVT_UNICODE_STRING_OFFSETABLE(ptr64, DriverName);
	x32_used_ptr->RaiseIrqls = (long unsigned int)ptr64->RaiseIrqls;
	x32_used_ptr->AcquireSpinLocks = (long unsigned int)ptr64->AcquireSpinLocks;
	x32_used_ptr->SynchronizeExecutions = (long unsigned int)ptr64->SynchronizeExecutions;
	x32_used_ptr->AllocationsAttempted = (long unsigned int)ptr64->AllocationsAttempted;
	x32_used_ptr->AllocationsSucceeded = (long unsigned int)ptr64->AllocationsSucceeded;
	x32_used_ptr->AllocationsSucceededSpecialPool = (long unsigned int)ptr64->AllocationsSucceededSpecialPool;
	x32_used_ptr->AllocationsWithNoTag = (long unsigned int)ptr64->AllocationsWithNoTag;
	x32_used_ptr->TrimRequests = (long unsigned int)ptr64->TrimRequests;
	x32_used_ptr->Trims = (long unsigned int)ptr64->Trims;
	x32_used_ptr->AllocationsFailed = (long unsigned int)ptr64->AllocationsFailed;
	x32_used_ptr->AllocationsFailedDeliberately = (long unsigned int)ptr64->AllocationsFailedDeliberately;
	x32_used_ptr->Loads = (long unsigned int)ptr64->Loads;
	x32_used_ptr->Unloads = (long unsigned int)ptr64->Unloads;
	x32_used_ptr->UnTrackedPool = (long unsigned int)ptr64->UnTrackedPool;
	x32_used_ptr->CurrentPagedPoolAllocations = (long unsigned int)ptr64->CurrentPagedPoolAllocations;
	x32_used_ptr->CurrentNonPagedPoolAllocations = (long unsigned int)ptr64->CurrentNonPagedPoolAllocations;
	x32_used_ptr->PeakPagedPoolAllocations = (long unsigned int)ptr64->PeakPagedPoolAllocations;
	x32_used_ptr->PeakNonPagedPoolAllocations = (long unsigned int)ptr64->PeakNonPagedPoolAllocations;
	x32_used_ptr->PagedPoolUsageInBytes = (long long unsigned int)ptr64->PagedPoolUsageInBytes;
	x32_used_ptr->NonPagedPoolUsageInBytes = (long long unsigned int)ptr64->NonPagedPoolUsageInBytes;
	x32_used_ptr->PeakPagedPoolUsageInBytes = (long long unsigned int)ptr64->PeakPagedPoolUsageInBytes;
	x32_used_ptr->PeakNonPagedPoolUsageInBytes = (long long unsigned int)ptr64->PeakNonPagedPoolUsageInBytes;
};

void convert__SYSTEM_SESSION_PROCESS_INFORMATION_64TO32(void* ctx, _SYSTEM_SESSION_PROCESS_INFORMATION* ptr64, uint32_t ptr32) {
	X32__SYSTEM_SESSION_PROCESS_INFORMATION* x32_used_ptr = (X32__SYSTEM_SESSION_PROCESS_INFORMATION*)ptr32;
	x32_used_ptr->SessionId = (long unsigned int)ptr64->SessionId;
	x32_used_ptr->SizeOfBuf = (long unsigned int)ptr64->SizeOfBuf;
	x32_used_ptr->Buffer = (X32_PVOID)ptr64->Buffer;
};


void convert__SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX_64TO32(void* ctx, _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX* ptr64, uint32_t ptr32) {
	X32__SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX* x32_used_ptr = (X32__SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX*)ptr32;

	NESTED_CVT_64TO32(HANDLE, Object);
	x32_used_ptr->UniqueProcessId = ptr64->UniqueProcessId;
	x32_used_ptr->HandleValue = ptr64->HandleValue;
	x32_used_ptr->GrantedAccess = ptr64->GrantedAccess;
	x32_used_ptr->CreatorBackTraceIndex = ptr64->CreatorBackTraceIndex;
	x32_used_ptr->ObjectTypeIndex = ptr64->ObjectTypeIndex;
	x32_used_ptr->HandleAttributes = ptr64->HandleAttributes;
	x32_used_ptr->Reserved = ptr64->Reserved;
}

void convert__SYSTEM_HANDLE_INFORMATION_EX_64TO32(void* ctx, _SYSTEM_HANDLE_INFORMATION_EX* ptr64, uint32_t ptr32) {
	X32__SYSTEM_HANDLE_INFORMATION_EX* x32_used_ptr = (X32__SYSTEM_HANDLE_INFORMATION_EX*)ptr32;
	x32_used_ptr->NumberOfHandles = (long long unsigned int)ptr64->NumberOfHandles;
	x32_used_ptr->Reserved = (long long unsigned int)ptr64->Reserved;

	for (size_t idx = 0; idx < x32_used_ptr->NumberOfHandles; idx++) {
		NESTED_CVT_64TO32(_SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX, Handles[idx]);
	}
};

void convert__SYSTEM_SESSION_POOLTAG_INFORMATION_64TO32(void* ctx, _SYSTEM_SESSION_POOLTAG_INFORMATION* ptr64, uint32_t ptr32) {
	X32__SYSTEM_SESSION_POOLTAG_INFORMATION* x32_used_ptr = (X32__SYSTEM_SESSION_POOLTAG_INFORMATION*)ptr32;
	x32_used_ptr->NextEntryOffset = (long long unsigned int)ptr64->NextEntryOffset;
	x32_used_ptr->SessionId = (long unsigned int)ptr64->SessionId;
	x32_used_ptr->Count = (long unsigned int)ptr64->Count;

//	x32_used_ptr->TagInfo = (_SYSTEM_POOLTAG[1])ptr64->TagInfo;
};

void convert__SYSTEM_SESSION_MAPPED_VIEW_INFORMATION_64TO32(void* ctx, _SYSTEM_SESSION_MAPPED_VIEW_INFORMATION* ptr64, uint32_t ptr32) {
	X32__SYSTEM_SESSION_MAPPED_VIEW_INFORMATION* x32_used_ptr = (X32__SYSTEM_SESSION_MAPPED_VIEW_INFORMATION*)ptr32;
	x32_used_ptr->NextEntryOffset = (long long unsigned int)ptr64->NextEntryOffset;
	x32_used_ptr->SessionId = (long unsigned int)ptr64->SessionId;
	x32_used_ptr->ViewFailures = (long unsigned int)ptr64->ViewFailures;
	x32_used_ptr->NumberOfBytesAvailable = (long long unsigned int)ptr64->NumberOfBytesAvailable;
	x32_used_ptr->NumberOfBytesAvailableContiguous = (long long unsigned int)ptr64->NumberOfBytesAvailableContiguous;
};

void convert__SYSTEM_FIRMWARE_TABLE_HANDLER_64TO32(void* ctx, _SYSTEM_FIRMWARE_TABLE_HANDLER* ptr64, uint32_t ptr32) {
	X32__SYSTEM_FIRMWARE_TABLE_HANDLER* x32_used_ptr = (X32__SYSTEM_FIRMWARE_TABLE_HANDLER*)ptr32;
	x32_used_ptr->ProviderSignature = (long unsigned int)ptr64->ProviderSignature;
	x32_used_ptr->Register = (unsigned char)ptr64->Register;

//	x32_used_ptr->FirmwareTableHandler = (NTSTATUS(*)(::PSYSTEM_FIRMWARE_TABLE_INFORMATION))ptr64->FirmwareTableHandler;
//	x32_used_ptr->DriverObject = (void*)ptr64->DriverObject;
};

void convert__RTL_PROCESS_MODULE_INFORMATION_EX_64TO32(void* ctx, _RTL_PROCESS_MODULE_INFORMATION_EX* ptr64, uint32_t ptr32) {
	X32__RTL_PROCESS_MODULE_INFORMATION_EX* x32_used_ptr = (X32__RTL_PROCESS_MODULE_INFORMATION_EX*)ptr32;
	x32_used_ptr->NextOffset = (short unsigned int)ptr64->NextOffset;
	//NESTED_CVT_64TO32(_RTL_PROCESS_MODULE_INFORMATION, BaseInfo);
	//x32_used_ptr->BaseInfo = (_RTL_PROCESS_MODULE_INFORMATION)ptr64->BaseInfo;
	x32_used_ptr->ImageChecksum = (long unsigned int)ptr64->ImageChecksum;
	x32_used_ptr->TimeDateStamp = (long unsigned int)ptr64->TimeDateStamp;
	x32_used_ptr->DefaultBase = (X32_PVOID)ptr64->DefaultBase;
};

void convert__SUPERFETCH_INFORMATION_64TO32(void* ctx, _SUPERFETCH_INFORMATION* ptr64, uint32_t ptr32) {
	X32__SUPERFETCH_INFORMATION* x32_used_ptr = (X32__SUPERFETCH_INFORMATION*)ptr32;
	x32_used_ptr->Version	= (long unsigned int)ptr64->Version;
	x32_used_ptr->Magic		= (long unsigned int)ptr64->Magic;
	x32_used_ptr->InfoClass = (_SUPERFETCH_INFORMATION_CLASS)ptr64->InfoClass;
	x32_used_ptr->Data		= (X32_PVOID)ptr64->Data;
	x32_used_ptr->Length	= (long unsigned int)ptr64->Length;
};

void convert__SYSTEM_MEMORY_LIST_INFORMATION_64TO32(void* ctx, _SYSTEM_MEMORY_LIST_INFORMATION* ptr64, uint32_t ptr32) {
	X32__SYSTEM_MEMORY_LIST_INFORMATION* x32_used_ptr = (X32__SYSTEM_MEMORY_LIST_INFORMATION*)ptr32;
	x32_used_ptr->ZeroPageCount = (long long unsigned int)ptr64->ZeroPageCount;
	x32_used_ptr->FreePageCount = (long long unsigned int)ptr64->FreePageCount;
	x32_used_ptr->ModifiedPageCount = (long long unsigned int)ptr64->ModifiedPageCount;
	x32_used_ptr->ModifiedNoWritePageCount = (long long unsigned int)ptr64->ModifiedNoWritePageCount;
	x32_used_ptr->BadPageCount = (long long unsigned int)ptr64->BadPageCount;
//	x32_used_ptr->PageCountByPriority = (long long unsigned int[8])ptr64->PageCountByPriority;
//	x32_used_ptr->RepurposedPagesByPriority = (long long unsigned int[8])ptr64->RepurposedPagesByPriority;
	x32_used_ptr->ModifiedPageCountPageFile = (long long unsigned int)ptr64->ModifiedPageCountPageFile;
};

void convert__SYSTEM_REF_TRACE_INFORMATION_64TO32(void* ctx, _SYSTEM_REF_TRACE_INFORMATION* ptr64, uint32_t ptr32) {
	X32__SYSTEM_REF_TRACE_INFORMATION* x32_used_ptr = (X32__SYSTEM_REF_TRACE_INFORMATION*)ptr32;
	x32_used_ptr->TraceEnable = (unsigned char)ptr64->TraceEnable;
	x32_used_ptr->TracePermanent = (unsigned char)ptr64->TracePermanent;
	CVT_UNICODE_STRING_OFFSETABLE(ptr64, TraceProcessName);
	CVT_UNICODE_STRING_OFFSETABLE(ptr64, TracePoolTags);
};

void convert__SYSTEM_PROCESS_ID_INFORMATION_64TO32(void* ctx, _SYSTEM_PROCESS_ID_INFORMATION* ptr64, uint32_t ptr32) {
	X32__SYSTEM_PROCESS_ID_INFORMATION* x32_used_ptr = (X32__SYSTEM_PROCESS_ID_INFORMATION*)ptr32;
	x32_used_ptr->ProcessId = (X32_HANDLE)ptr64->ProcessId;
	CVT_UNICODE_STRING_OFFSETABLE(ptr64, ImageName);
};

void convert__SYSTEM_VERIFIER_INFORMATION_EX_64TO32(void* ctx, _SYSTEM_VERIFIER_INFORMATION_EX* ptr64, uint32_t ptr32) {
	X32__SYSTEM_VERIFIER_INFORMATION_EX* x32_used_ptr = (X32__SYSTEM_VERIFIER_INFORMATION_EX*)ptr32;
	x32_used_ptr->VerifyMode = (long unsigned int)ptr64->VerifyMode;
	x32_used_ptr->OptionChanges = (long unsigned int)ptr64->OptionChanges;
	CVT_UNICODE_STRING_OFFSETABLE(ptr64, PreviousBucketName);
	x32_used_ptr->IrpCancelTimeoutMsec = (long unsigned int)ptr64->IrpCancelTimeoutMsec;
	x32_used_ptr->VerifierExtensionEnabled = (long unsigned int)ptr64->VerifierExtensionEnabled;
	x32_used_ptr->Reserved[0] = (long unsigned int)ptr64->Reserved[0];
};

void convert__SYSTEM_SYSTEM_PARTITION_INFORMATION_64TO32(void* ctx, _SYSTEM_SYSTEM_PARTITION_INFORMATION* ptr64, uint32_t ptr32) {
	X32__SYSTEM_SYSTEM_PARTITION_INFORMATION* x32_used_ptr = (X32__SYSTEM_SYSTEM_PARTITION_INFORMATION*)ptr32;
	CVT_UNICODE_STRING_OFFSETABLE(ptr64, SystemPartition);
};

void convert__SYSTEM_SYSTEM_DISK_INFORMATION_64TO32(void* ctx, _SYSTEM_SYSTEM_DISK_INFORMATION* ptr64, uint32_t ptr32) {
	X32__SYSTEM_SYSTEM_DISK_INFORMATION* x32_used_ptr = (X32__SYSTEM_SYSTEM_DISK_INFORMATION*)ptr32;
	CVT_UNICODE_STRING_OFFSETABLE(ptr64, SystemDisk);
};

void convert__SYSTEM_BASIC_PERFORMANCE_INFORMATION_64TO32(void* ctx, _SYSTEM_BASIC_PERFORMANCE_INFORMATION* ptr64, uint32_t ptr32) {
	X32__SYSTEM_BASIC_PERFORMANCE_INFORMATION* x32_used_ptr = (X32__SYSTEM_BASIC_PERFORMANCE_INFORMATION*)ptr32;
	x32_used_ptr->AvailablePages = (long long unsigned int)ptr64->AvailablePages;
	x32_used_ptr->CommittedPages = (long long unsigned int)ptr64->CommittedPages;
	x32_used_ptr->CommitLimit = (long long unsigned int)ptr64->CommitLimit;
	x32_used_ptr->PeakCommitment = (long long unsigned int)ptr64->PeakCommitment;
};

void convert__SYSTEM_POLICY_INFORMATION_64TO32(void* ctx, _SYSTEM_POLICY_INFORMATION* ptr64, uint32_t ptr32) {
	X32__SYSTEM_POLICY_INFORMATION* x32_used_ptr = (X32__SYSTEM_POLICY_INFORMATION*)ptr32;
	x32_used_ptr->InputData = (X32_PVOID)ptr64->InputData;
	x32_used_ptr->OutputData = (X32_PVOID)ptr64->OutputData;
	x32_used_ptr->InputDataSize = (long unsigned int)ptr64->InputDataSize;
	x32_used_ptr->OutputDataSize = (long unsigned int)ptr64->OutputDataSize;
	x32_used_ptr->Version = (long unsigned int)ptr64->Version;
};

void convert__SYSTEM_MANUFACTURING_INFORMATION_64TO32(void* ctx, _SYSTEM_MANUFACTURING_INFORMATION* ptr64, uint32_t ptr32) {
	X32__SYSTEM_MANUFACTURING_INFORMATION* x32_used_ptr = (X32__SYSTEM_MANUFACTURING_INFORMATION*)ptr32;
	x32_used_ptr->Options = (long unsigned int)ptr64->Options;
	CVT_UNICODE_STRING_OFFSETABLE(ptr64, ProfileName);
};

void convert__SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS_64TO32(void* ctx, _SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS* ptr64, uint32_t ptr32) {
	X32__SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS* x32_used_ptr = (X32__SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS*)ptr32;
	NESTED_CVT_64TO32(HANDLE, UserKeyHandle);
};

void convert__SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION_64TO32(void* ctx, _SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION* ptr64, uint32_t ptr32) {
	X32__SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION* x32_used_ptr = (X32__SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION*)ptr32;
	x32_used_ptr->HypervisorSharedUserVa = (X32_PVOID)ptr64->HypervisorSharedUserVa;
};

void convert__UNICODE_STRING_64TO32(void* ctx, _UNICODE_STRING* ptr64, uint32_t ptr32) {
	X32__UNICODE_STRING* x32_used_ptr = (X32__UNICODE_STRING*)ptr32;
	x32_used_ptr->Length = (short unsigned int)ptr64->Length;
	x32_used_ptr->MaximumLength = (short unsigned int)ptr64->MaximumLength;
	x32_used_ptr->Buffer = (WOW64_POINTER(wchar_t*))ptr64->Buffer;
};

void convert__MEMORY_BASIC_INFORMATION_64TO32(void* ctx, _MEMORY_BASIC_INFORMATION* ptr64, uint32_t ptr32) {
	X32__MEMORY_BASIC_INFORMATION* x32_used_ptr = (X32__MEMORY_BASIC_INFORMATION*)ptr32;
	x32_used_ptr->BaseAddress = (X32_PVOID)ptr64->BaseAddress;
	x32_used_ptr->AllocationBase = (X32_PVOID)ptr64->AllocationBase;
	x32_used_ptr->AllocationProtect = (long unsigned int)ptr64->AllocationProtect;
	x32_used_ptr->RegionSize = (long long unsigned int)ptr64->RegionSize;
	x32_used_ptr->State = (long unsigned int)ptr64->State;
	x32_used_ptr->Protect = (long unsigned int)ptr64->Protect;
	x32_used_ptr->Type = (long unsigned int)ptr64->Type;
};

void convert__MEMORY_WORKING_SET_INFORMATION_64TO32(void* ctx, _MEMORY_WORKING_SET_INFORMATION* ptr64, uint32_t ptr32) {
	X32__MEMORY_WORKING_SET_INFORMATION* x32_used_ptr = (X32__MEMORY_WORKING_SET_INFORMATION*)ptr32;
	x32_used_ptr->NumberOfEntries = (long long unsigned int)ptr64->NumberOfEntries;
	
	//x32_used_ptr->WorkingSetInfo = (_MEMORY_WORKING_SET_BLOCK[1])ptr64->WorkingSetInfo;
};

void convert__MEMORY_REGION_INFORMATION_64TO32(void* ctx, _MEMORY_REGION_INFORMATION* ptr64, uint32_t ptr32) {
	X32__MEMORY_REGION_INFORMATION* x32_used_ptr = (X32__MEMORY_REGION_INFORMATION*)ptr32;
	x32_used_ptr->AllocationBase = (X32_PVOID)ptr64->AllocationBase;
	x32_used_ptr->AllocationProtect = (long unsigned int)ptr64->AllocationProtect;
	x32_used_ptr->RegionType = ptr64->RegionType;
	x32_used_ptr->RegionSize = (long long unsigned int)ptr64->RegionSize;
	x32_used_ptr->CommitSize = (long long unsigned int)ptr64->CommitSize;
	x32_used_ptr->PartitionId = (long long unsigned int)ptr64->PartitionId;
};

void convert__MEMORY_WORKING_SET_EX_INFORMATION_64TO32(void* ctx, _MEMORY_WORKING_SET_EX_INFORMATION* ptr64, uint32_t ptr32) {
	X32__MEMORY_WORKING_SET_EX_INFORMATION* x32_used_ptr = (X32__MEMORY_WORKING_SET_EX_INFORMATION*)ptr32;
	x32_used_ptr->VirtualAddress = (X32_PVOID)ptr64->VirtualAddress;

//#pragma error('Here Ignored union fix it')
//	x32_used_ptr->u1 = (_MEMORY_WORKING_SET_EX_INFORMATION)ptr64->u1;
};

void convert__SECTION_BASIC_INFORMATION_64TO32(void* ctx, _SECTION_BASIC_INFORMATION* ptr64, uint32_t ptr32) {
	X32__SECTION_BASIC_INFORMATION* x32_used_ptr = (X32__SECTION_BASIC_INFORMATION*)ptr32;
	x32_used_ptr->BaseAddress = (X32_PVOID)ptr64->BaseAddress;
	x32_used_ptr->AllocationAttributes = (long unsigned int)ptr64->AllocationAttributes;
	x32_used_ptr->MaximumSize = (_LARGE_INTEGER)ptr64->MaximumSize;
};

void convert__SECTION_IMAGE_INFORMATION_64TO32(void* ctx, _SECTION_IMAGE_INFORMATION* ptr64, uint32_t ptr32) {
	X32__SECTION_IMAGE_INFORMATION* x32_used_ptr = (X32__SECTION_IMAGE_INFORMATION*)ptr32;
	x32_used_ptr->TransferAddress = (X32_PVOID)ptr64->TransferAddress;
	x32_used_ptr->ZeroBits = (long unsigned int)ptr64->ZeroBits;
	x32_used_ptr->MaximumStackSize = (long long unsigned int)ptr64->MaximumStackSize;
	x32_used_ptr->CommittedStackSize = (long long unsigned int)ptr64->CommittedStackSize;
	x32_used_ptr->SubSystemType = (long unsigned int)ptr64->SubSystemType;
	x32_used_ptr->SubSystemVersion = ptr64->SubSystemVersion;
	x32_used_ptr->OperatingSystemVersion = ptr64->OperatingSystemVersion;
	x32_used_ptr->ImageCharacteristics = (short unsigned int)ptr64->ImageCharacteristics;
	x32_used_ptr->DllCharacteristics = (short unsigned int)ptr64->DllCharacteristics;
	x32_used_ptr->Machine = (short unsigned int)ptr64->Machine;
	x32_used_ptr->ImageContainsCode = (unsigned char)ptr64->ImageContainsCode;
	x32_used_ptr->ImageFlags = ptr64->ImageFlags;
	x32_used_ptr->LoaderFlags = (long unsigned int)ptr64->LoaderFlags;
	x32_used_ptr->ImageFileSize = (long unsigned int)ptr64->ImageFileSize;
	x32_used_ptr->CheckSum = (long unsigned int)ptr64->CheckSum;
};

void convert__OBJECT_NAME_INFORMATION_64TO32(void* ctx, _OBJECT_NAME_INFORMATION* ptr64, uint32_t ptr32) {
	X32__OBJECT_NAME_INFORMATION* x32_used_ptr = (X32__OBJECT_NAME_INFORMATION*)ptr32;
	NESTED_CVT_64TO32(_UNICODE_STRING, Name);
};

void convert__OBJECT_TYPE_INFORMATION_64TO32(void* ctx, _OBJECT_TYPE_INFORMATION* ptr64, uint32_t ptr32) {
	X32__OBJECT_TYPE_INFORMATION* x32_used_ptr = (X32__OBJECT_TYPE_INFORMATION*)ptr32;
	CVT_UNICODE_STRING_OFFSETABLE(ptr64, TypeName);
	x32_used_ptr->TotalNumberOfObjects = (long unsigned int)ptr64->TotalNumberOfObjects;
	x32_used_ptr->TotalNumberOfHandles = (long unsigned int)ptr64->TotalNumberOfHandles;
	x32_used_ptr->TotalPagedPoolUsage = (long unsigned int)ptr64->TotalPagedPoolUsage;
	x32_used_ptr->TotalNonPagedPoolUsage = (long unsigned int)ptr64->TotalNonPagedPoolUsage;
	x32_used_ptr->TotalNamePoolUsage = (long unsigned int)ptr64->TotalNamePoolUsage;
	x32_used_ptr->TotalHandleTableUsage = (long unsigned int)ptr64->TotalHandleTableUsage;
	x32_used_ptr->HighWaterNumberOfObjects = (long unsigned int)ptr64->HighWaterNumberOfObjects;
	x32_used_ptr->HighWaterNumberOfHandles = (long unsigned int)ptr64->HighWaterNumberOfHandles;
	x32_used_ptr->HighWaterPagedPoolUsage = (long unsigned int)ptr64->HighWaterPagedPoolUsage;
	x32_used_ptr->HighWaterNonPagedPoolUsage = (long unsigned int)ptr64->HighWaterNonPagedPoolUsage;
	x32_used_ptr->HighWaterNamePoolUsage = (long unsigned int)ptr64->HighWaterNamePoolUsage;
	x32_used_ptr->HighWaterHandleTableUsage = (long unsigned int)ptr64->HighWaterHandleTableUsage;
	x32_used_ptr->InvalidAttributes = (long unsigned int)ptr64->InvalidAttributes;
	x32_used_ptr->GenericMapping = (_GENERIC_MAPPING)ptr64->GenericMapping;
	x32_used_ptr->ValidAccessMask = (long unsigned int)ptr64->ValidAccessMask;
	x32_used_ptr->SecurityRequired = (unsigned char)ptr64->SecurityRequired;
	x32_used_ptr->MaintainHandleCount = (unsigned char)ptr64->MaintainHandleCount;
	x32_used_ptr->TypeIndex = (unsigned char)ptr64->TypeIndex;
	x32_used_ptr->ReservedByte = (char)ptr64->ReservedByte;
	x32_used_ptr->PoolType = (long unsigned int)ptr64->PoolType;
	x32_used_ptr->DefaultPagedPoolCharge = (long unsigned int)ptr64->DefaultPagedPoolCharge;
	x32_used_ptr->DefaultNonPagedPoolCharge = (long unsigned int)ptr64->DefaultNonPagedPoolCharge;
};

void convert__PROCESS_BASIC_INFORMATION_64TO32(void* ctx, _PROCESS_BASIC_INFORMATION* ptr64, uint32_t ptr32) {
	X32__PROCESS_BASIC_INFORMATION* x32_used_ptr = (X32__PROCESS_BASIC_INFORMATION*)ptr32;
	x32_used_ptr->ExitStatus = (long int)ptr64->ExitStatus;
	x32_used_ptr->PebBaseAddress = (WOW64_POINTER(_PEB*))ptr64->PebBaseAddress;
	x32_used_ptr->AffinityMask = (long long unsigned int)ptr64->AffinityMask;
	x32_used_ptr->BasePriority = (long int)ptr64->BasePriority;
	x32_used_ptr->UniqueProcessId = (X32_HANDLE)ptr64->UniqueProcessId;
	x32_used_ptr->InheritedFromUniqueProcessId = (X32_HANDLE)ptr64->InheritedFromUniqueProcessId;
};

void convert__QUOTA_LIMITS_64TO32(void* ctx, _QUOTA_LIMITS* ptr64, uint32_t ptr32) {
	X32__QUOTA_LIMITS* x32_used_ptr = (X32__QUOTA_LIMITS*)ptr32;
	x32_used_ptr->PagedPoolLimit = (long long unsigned int)ptr64->PagedPoolLimit;
	x32_used_ptr->NonPagedPoolLimit = (long long unsigned int)ptr64->NonPagedPoolLimit;
	x32_used_ptr->MinimumWorkingSetSize = (long long unsigned int)ptr64->MinimumWorkingSetSize;
	x32_used_ptr->MaximumWorkingSetSize = (long long unsigned int)ptr64->MaximumWorkingSetSize;
	x32_used_ptr->PagefileLimit = (long long unsigned int)ptr64->PagefileLimit;
	x32_used_ptr->TimeLimit = (LARGE_INTEGER)ptr64->TimeLimit;
};

void convert__VM_COUNTERS_64TO32(void* ctx, _VM_COUNTERS* ptr64, uint32_t ptr32) {
	X32__VM_COUNTERS* x32_used_ptr = (X32__VM_COUNTERS*)ptr32;
	x32_used_ptr->PeakVirtualSize = (long long unsigned int)ptr64->PeakVirtualSize;
	x32_used_ptr->VirtualSize = (long long unsigned int)ptr64->VirtualSize;
	x32_used_ptr->PageFaultCount = (long unsigned int)ptr64->PageFaultCount;
	x32_used_ptr->PeakWorkingSetSize = (long long unsigned int)ptr64->PeakWorkingSetSize;
	x32_used_ptr->WorkingSetSize = (long long unsigned int)ptr64->WorkingSetSize;
	x32_used_ptr->QuotaPeakPagedPoolUsage = (long long unsigned int)ptr64->QuotaPeakPagedPoolUsage;
	x32_used_ptr->QuotaPagedPoolUsage = (long long unsigned int)ptr64->QuotaPagedPoolUsage;
	x32_used_ptr->QuotaPeakNonPagedPoolUsage = (long long unsigned int)ptr64->QuotaPeakNonPagedPoolUsage;
	x32_used_ptr->QuotaNonPagedPoolUsage = (long long unsigned int)ptr64->QuotaNonPagedPoolUsage;
	x32_used_ptr->PagefileUsage = (long long unsigned int)ptr64->PagefileUsage;
	x32_used_ptr->PeakPagefileUsage = (long long unsigned int)ptr64->PeakPagefileUsage;
};

void convert__POOLED_USAGE_AND_LIMITS_64TO32(void* ctx, _POOLED_USAGE_AND_LIMITS* ptr64, uint32_t ptr32) {
	X32__POOLED_USAGE_AND_LIMITS* x32_used_ptr = (X32__POOLED_USAGE_AND_LIMITS*)ptr32;
	x32_used_ptr->PeakPagedPoolUsage = (long long unsigned int)ptr64->PeakPagedPoolUsage;
	x32_used_ptr->PagedPoolUsage = (long long unsigned int)ptr64->PagedPoolUsage;
	x32_used_ptr->PagedPoolLimit = (long long unsigned int)ptr64->PagedPoolLimit;
	x32_used_ptr->PeakNonPagedPoolUsage = (long long unsigned int)ptr64->PeakNonPagedPoolUsage;
	x32_used_ptr->NonPagedPoolUsage = (long long unsigned int)ptr64->NonPagedPoolUsage;
	x32_used_ptr->NonPagedPoolLimit = (long long unsigned int)ptr64->NonPagedPoolLimit;
	x32_used_ptr->PeakPagefileUsage = (long long unsigned int)ptr64->PeakPagefileUsage;
	x32_used_ptr->PagefileUsage = (long long unsigned int)ptr64->PagefileUsage;
	x32_used_ptr->PagefileLimit = (long long unsigned int)ptr64->PagefileLimit;
};

void convert__PROCESS_WS_WATCH_INFORMATION_64TO32(void* ctx, _PROCESS_WS_WATCH_INFORMATION* ptr64, uint32_t ptr32) {
	X32__PROCESS_WS_WATCH_INFORMATION* x32_used_ptr = (X32__PROCESS_WS_WATCH_INFORMATION*)ptr32;
	x32_used_ptr->FaultingPc = (X32_PVOID)ptr64->FaultingPc;
	x32_used_ptr->FaultingVa = (X32_PVOID)ptr64->FaultingVa;
};

void convert__PROCESS_DEVICEMAP_INFORMATION_64TO32(void* ctx, _PROCESS_DEVICEMAP_INFORMATION* ptr64, uint32_t ptr32) {
	X32__PROCESS_DEVICEMAP_INFORMATION* x32_used_ptr = (X32__PROCESS_DEVICEMAP_INFORMATION*)ptr32;

//#pragma error('Here Ignored union fix it')
//	x32_used_ptr-> = (_PROCESS_DEVICEMAP_INFORMATION)ptr64->;
};

void convert__PROCESS_HANDLE_TRACING_QUERY_64TO32(void* ctx, _PROCESS_HANDLE_TRACING_QUERY* ptr64, uint32_t ptr32) {
	X32__PROCESS_HANDLE_TRACING_QUERY* x32_used_ptr = (X32__PROCESS_HANDLE_TRACING_QUERY*)ptr32;
	NESTED_CVT_64TO32(HANDLE, Handle);
	x32_used_ptr->TotalTraces = (long unsigned int)ptr64->TotalTraces;

//	x32_used_ptr->HandleTrace = (_PROCESS_HANDLE_TRACING_ENTRY[1])ptr64->HandleTrace;
};

void convert__PROCESS_WS_WATCH_INFORMATION_EX_64TO32(void* ctx, _PROCESS_WS_WATCH_INFORMATION_EX* ptr64, uint32_t ptr32) {
	X32__PROCESS_WS_WATCH_INFORMATION_EX* x32_used_ptr = (X32__PROCESS_WS_WATCH_INFORMATION_EX*)ptr32;
	NESTED_CVT_64TO32(_PROCESS_WS_WATCH_INFORMATION, BasicInfo);
	x32_used_ptr->FaultingThreadId = (long long unsigned int)ptr64->FaultingThreadId;
	x32_used_ptr->Flags = (long long unsigned int)ptr64->Flags;
};

void convert__PROCESS_HANDLE_SNAPSHOT_INFORMATION_64TO32(void* ctx, _PROCESS_HANDLE_SNAPSHOT_INFORMATION* ptr64, uint32_t ptr32) {
	X32__PROCESS_HANDLE_SNAPSHOT_INFORMATION* x32_used_ptr = (X32__PROCESS_HANDLE_SNAPSHOT_INFORMATION*)ptr32;
	x32_used_ptr->NumberOfHandles = (long long unsigned int)ptr64->NumberOfHandles;
	x32_used_ptr->Reserved = (long long unsigned int)ptr64->Reserved;

//	x32_used_ptr->Handles = (_PROCESS_HANDLE_TABLE_ENTRY_INFO[1])ptr64->Handles;
};

void convert__THREAD_BASIC_INFORMATION_64TO32(void* ctx, _THREAD_BASIC_INFORMATION* ptr64, uint32_t ptr32) {
	X32__THREAD_BASIC_INFORMATION* x32_used_ptr = (X32__THREAD_BASIC_INFORMATION*)ptr32;
	x32_used_ptr->ExitStatus = (long int)ptr64->ExitStatus;
	x32_used_ptr->TebBaseAddress = (WOW64_POINTER(_TEB*))ptr64->TebBaseAddress + 0x2000;
	NESTED_CVT_64TO32(_CLIENT_ID, ClientId);
	x32_used_ptr->AffinityMask = (long long unsigned int)ptr64->AffinityMask;
	x32_used_ptr->Priority = (long int)ptr64->Priority;
	x32_used_ptr->BasePriority = (long int)ptr64->BasePriority;
};

void convert__THREAD_LAST_SYSCALL_INFORMATION_64TO32(void* ctx, _THREAD_LAST_SYSCALL_INFORMATION* ptr64, uint32_t ptr32) {
	X32__THREAD_LAST_SYSCALL_INFORMATION* x32_used_ptr = (X32__THREAD_LAST_SYSCALL_INFORMATION*)ptr32;
	x32_used_ptr->FirstArgument = (X32_PVOID)ptr64->FirstArgument;
	x32_used_ptr->SystemCallNumber = (short unsigned int)ptr64->SystemCallNumber;
	x32_used_ptr->Pad[0] = (short unsigned int)ptr64->Pad[0];
	x32_used_ptr->WaitTime = (long long unsigned int)ptr64->WaitTime;
};

void convert__THREAD_TEB_INFORMATION_64TO32(void* ctx, _THREAD_TEB_INFORMATION* ptr64, uint32_t ptr32) {
	X32__THREAD_TEB_INFORMATION* x32_used_ptr = (X32__THREAD_TEB_INFORMATION*)ptr32;
	x32_used_ptr->TebInformation = (X32_PVOID)ptr64->TebInformation;
	x32_used_ptr->TebOffset = (long unsigned int)ptr64->TebOffset;
	x32_used_ptr->BytesToRead = (long unsigned int)ptr64->BytesToRead;
};

void convert__GROUP_AFFINITY_64TO32(void* ctx, _GROUP_AFFINITY* ptr64, uint32_t ptr32) {
	X32__GROUP_AFFINITY* x32_used_ptr = (X32__GROUP_AFFINITY*)ptr32;
	x32_used_ptr->Mask = (long long unsigned int)ptr64->Mask;
	x32_used_ptr->Group = (short unsigned int)ptr64->Group;
	x32_used_ptr->Reserved[0] = (short unsigned int)ptr64->Reserved[0];
	x32_used_ptr->Reserved[1] = (short unsigned int)ptr64->Reserved[1];
	x32_used_ptr->Reserved[2] = (short unsigned int)ptr64->Reserved[2];
};

void convert__THREAD_PROFILING_INFORMATION_64TO32(void* ctx, _THREAD_PROFILING_INFORMATION* ptr64, uint32_t ptr32) {
	X32__THREAD_PROFILING_INFORMATION* x32_used_ptr = (X32__THREAD_PROFILING_INFORMATION*)ptr32;
	x32_used_ptr->HardwareCounters = (long long unsigned int)ptr64->HardwareCounters;
	x32_used_ptr->Flags = (long unsigned int)ptr64->Flags;
	x32_used_ptr->Enable = (long unsigned int)ptr64->Enable;
	x32_used_ptr->PerformanceData = (WOW64_POINTER(_THREAD_PERFORMANCE_DATA*))ptr64->PerformanceData;
};

void convert__THREAD_NAME_INFORMATION_64TO32(void* ctx, _THREAD_NAME_INFORMATION* ptr64, uint32_t ptr32) {
	X32__THREAD_NAME_INFORMATION* x32_used_ptr = (X32__THREAD_NAME_INFORMATION*)ptr32;
	CVT_UNICODE_STRING_OFFSETABLE(ptr64, ThreadName);
};

void convert__ALPC_BASIC_INFORMATION_64TO32(void* ctx, _ALPC_BASIC_INFORMATION* ptr64, uint32_t ptr32) {
	X32__ALPC_BASIC_INFORMATION* x32_used_ptr = (X32__ALPC_BASIC_INFORMATION*)ptr32;
	x32_used_ptr->Flags = (long unsigned int)ptr64->Flags;
	x32_used_ptr->SequenceNo = (long unsigned int)ptr64->SequenceNo;
	x32_used_ptr->PortContext = (X32_PVOID)ptr64->PortContext;
};

void convert__ALPC_SERVER_INFORMATION_64TO32(void* ctx, _ALPC_SERVER_INFORMATION* ptr64, uint32_t ptr32) {
	X32__ALPC_SERVER_INFORMATION* x32_used_ptr = (X32__ALPC_SERVER_INFORMATION*)ptr32;

//#pragma error('Here Ignored union fix it')
//	x32_used_ptr-> = (_ALPC_SERVER_INFORMATION)ptr64->;
};

void convert_MEM_EXTENDED_PARAMETER_64TO32(void* ctx, MEM_EXTENDED_PARAMETER* ptr64, uint32_t ptr32) {
	X32_MEM_EXTENDED_PARAMETER* x32_used_ptr = (X32_MEM_EXTENDED_PARAMETER*)ptr32;
	x32_used_ptr->Type = ptr64->Type;
	x32_used_ptr->Reserved = ptr64->Reserved;
	x32_used_ptr->ULong64 = ptr64->ULong64;
};

void convert_HANDLE_64TO32(void* ctx, HANDLE* ptr64, uint32_t ptr32) {
	X32_HANDLE* x32_used_ptr = (X32_HANDLE*)ptr32;
	*x32_used_ptr = (X32_HANDLE)HandleToHandle32(*ptr64);
};

void convert__FILE_IO_COMPLETION_INFORMATION_64TO32(void* ctx, _FILE_IO_COMPLETION_INFORMATION* ptr64, uint32_t ptr32) {
	X32__FILE_IO_COMPLETION_INFORMATION* x32_used_ptr = (X32__FILE_IO_COMPLETION_INFORMATION*)ptr32;
	x32_used_ptr->KeyContext = (X32_PVOID)ptr64->KeyContext;
	x32_used_ptr->ApcContext = (X32_PVOID)ptr64->ApcContext;
	NESTED_CVT_64TO32(_IO_STATUS_BLOCK, IoStatusBlock);
};

void convert__CLIENT_ID_64TO32(void* ctx, _CLIENT_ID* ptr64, uint32_t ptr32) {
	X32__CLIENT_ID* x32_used_ptr = (X32__CLIENT_ID*)ptr32;
	x32_used_ptr->UniqueProcess = (X32_PVOID)ptr64->UniqueProcess;
	x32_used_ptr->UniqueThread = (X32_PVOID)ptr64->UniqueThread;
};

void convert__PS_CREATE_INFO_64TO32(void* ctx, _PS_CREATE_INFO* ptr64, uint32_t ptr32) {
	X32__PS_CREATE_INFO* x32_used_ptr = (X32__PS_CREATE_INFO*)ptr32;
	x32_used_ptr->Size = (long long unsigned int)ptr64->Size;
	x32_used_ptr->State = (_PS_CREATE_STATE)ptr64->State;

//#pragma error('Here Ignored union fix it')
//	x32_used_ptr-> = (_PS_CREATE_INFO)ptr64->;
};

void convert__DBGUI_WAIT_STATE_CHANGE_64TO32(void* ctx, _DBGUI_WAIT_STATE_CHANGE* ptr64, uint32_t ptr32) {
	X32__DBGUI_WAIT_STATE_CHANGE* x32_used_ptr = (X32__DBGUI_WAIT_STATE_CHANGE*)ptr32;
	x32_used_ptr->NewState = (_DBG_STATE)ptr64->NewState;
	NESTED_CVT_64TO32(_CLIENT_ID, AppClientId);

//#pragma error('Here Ignored union fix it')
//	x32_used_ptr->StateInfo = (_DBGUI_WAIT_STATE_CHANGE)ptr64->StateInfo;
};

void convert__IO_STATUS_BLOCK_64TO32(void* ctx, _IO_STATUS_BLOCK* ptr64, uint32_t ptr32) {
	X32__IO_STATUS_BLOCK* x32_used_ptr = (X32__IO_STATUS_BLOCK*)ptr32;
	x32_used_ptr->Status = ptr64->Status;
	x32_used_ptr->Information = (long long unsigned int)ptr64->Information;
};

void convert__PORT_VIEW_64TO32(void* ctx, _PORT_VIEW* ptr64, uint32_t ptr32) {
	X32__PORT_VIEW* x32_used_ptr = (X32__PORT_VIEW*)ptr32;
	x32_used_ptr->Length = (long unsigned int)ptr64->Length;
	x32_used_ptr->SectionHandle = (X32_PVOID)ptr64->SectionHandle;
	x32_used_ptr->SectionOffset = (long unsigned int)ptr64->SectionOffset;
	x32_used_ptr->ViewSize = (long long unsigned int)ptr64->ViewSize;
	x32_used_ptr->ViewBase = (X32_PVOID)ptr64->ViewBase;
	x32_used_ptr->ViewRemoteBase = (X32_PVOID)ptr64->ViewRemoteBase;
};

void convert__REMOTE_PORT_VIEW_64TO32(void* ctx, _REMOTE_PORT_VIEW* ptr64, uint32_t ptr32) {
	X32__REMOTE_PORT_VIEW* x32_used_ptr = (X32__REMOTE_PORT_VIEW*)ptr32;
	x32_used_ptr->Length = (long unsigned int)ptr64->Length;
	x32_used_ptr->ViewSize = (long long unsigned int)ptr64->ViewSize;
	x32_used_ptr->ViewBase = (X32_PVOID)ptr64->ViewBase;
};

void convert__PORT_MESSAGE_64TO32(void* ctx, _PORT_MESSAGE* ptr64, uint32_t ptr32) {
	X32__PORT_MESSAGE* x32_used_ptr = (X32__PORT_MESSAGE*)ptr32;
	/*
#pragma error('Here Ignored union fix it')
	x32_used_ptr->u1 = (_PORT_MESSAGE)ptr64->u1;
#pragma error('Here Ignored union fix it')
	x32_used_ptr->u2 = (_PORT_MESSAGE)ptr64->u2;
#pragma error('Here Ignored union fix it')
	x32_used_ptr-> = (_PORT_MESSAGE)ptr64->;
	x32_used_ptr->MessageId = (long unsigned int)ptr64->MessageId;
#pragma error('Here Ignored union fix it')
	x32_used_ptr-> = (_PORT_MESSAGE)ptr64->;
	*/
};

void convert__ALPC_DATA_VIEW_ATTR_64TO32(void* ctx, _ALPC_DATA_VIEW_ATTR* ptr64, uint32_t ptr32) {
	X32__ALPC_DATA_VIEW_ATTR* x32_used_ptr = (X32__ALPC_DATA_VIEW_ATTR*)ptr32;
	x32_used_ptr->Flags = (long unsigned int)ptr64->Flags;
	x32_used_ptr->SectionHandle = (X32_PVOID)ptr64->SectionHandle;
	x32_used_ptr->ViewBase = (X32_PVOID)ptr64->ViewBase;
	x32_used_ptr->ViewSize = (long long unsigned int)ptr64->ViewSize;
};

void convert__ALPC_SECURITY_ATTR_64TO32(void* ctx, _ALPC_SECURITY_ATTR* ptr64, uint32_t ptr32) {
	X32__ALPC_SECURITY_ATTR* x32_used_ptr = (X32__ALPC_SECURITY_ATTR*)ptr32;
	x32_used_ptr->Flags = (long unsigned int)ptr64->Flags;
	//x32_used_ptr->QoS = (_SECURITY_QUALITY_OF_SERVICE*)ptr64->QoS;
	NESTED_CVT_64TO32(HANDLE, ContextHandle);
};

void convert__KEY_VALUE_ENTRY_64TO32(void* ctx, _KEY_VALUE_ENTRY* ptr64, uint32_t ptr32) {
	X32__KEY_VALUE_ENTRY* x32_used_ptr = (X32__KEY_VALUE_ENTRY*)ptr32;
//	x32_used_ptr->ValueName = (_UNICODE_STRING*)ptr64->ValueName;
	x32_used_ptr->DataLength = (long unsigned int)ptr64->DataLength;
	x32_used_ptr->DataOffset = (long unsigned int)ptr64->DataOffset;
	x32_used_ptr->Type = (long unsigned int)ptr64->Type;
};

void convert__TOKEN_GROUPS_64TO32(void* ctx, _TOKEN_GROUPS* ptr64, uint32_t ptr32) {
	X32__TOKEN_GROUPS* x32_used_ptr = (X32__TOKEN_GROUPS*)ptr32;
	x32_used_ptr->GroupCount = (long unsigned int)ptr64->GroupCount;

//	x32_used_ptr->Groups = (_SID_AND_ATTRIBUTES[1])ptr64->Groups;
};

void convert__TOKEN_SECURITY_ATTRIBUTES_INFORMATION_64TO32(void* ctx, _TOKEN_SECURITY_ATTRIBUTES_INFORMATION* ptr64, uint32_t ptr32) {
	X32__TOKEN_SECURITY_ATTRIBUTES_INFORMATION* x32_used_ptr = (X32__TOKEN_SECURITY_ATTRIBUTES_INFORMATION*)ptr32;
	x32_used_ptr->Version = (short unsigned int)ptr64->Version;
	x32_used_ptr->Reserved = (short unsigned int)ptr64->Reserved;
	x32_used_ptr->AttributeCount = (long unsigned int)ptr64->AttributeCount;

	//#pragma error('Here Ignored union fix it')
//	x32_used_ptr->Attribute = (_TOKEN_SECURITY_ATTRIBUTES_INFORMATION)ptr64->Attribute;
};

void convert__TRANSACTION_NOTIFICATION_64TO32(void* ctx, _TRANSACTION_NOTIFICATION* ptr64, uint32_t ptr32) {
	X32__TRANSACTION_NOTIFICATION* x32_used_ptr = (X32__TRANSACTION_NOTIFICATION*)ptr32;
	x32_used_ptr->TransactionKey = (X32_PVOID)ptr64->TransactionKey;
	x32_used_ptr->TransactionNotification = (long unsigned int)ptr64->TransactionNotification;
	x32_used_ptr->TmVirtualClock = (LARGE_INTEGER)ptr64->TmVirtualClock;
	x32_used_ptr->ArgumentLength = (long unsigned int)ptr64->ArgumentLength;
};


#pragma warning(pop)
```

`src/HIGU_ntcall_3264/thunk64_functions.h`:

```h
#pragma warning(push)
#pragma warning(disable: 4312 4065 4302 4311 4244)

static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemBasicInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_BASIC_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemProcessInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_PROCESS_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemPagedPoolInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_POOL_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemNonPagedPoolInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_POOL_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemPageFileInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_PAGEFILE_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemFileCacheInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_FILECACHE_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemRegistryQuotaInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_REGISTRY_QUOTA_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemLegacyDriverInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_LEGACY_DRIVER_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemVerifierInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_VERIFIER_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemSessionProcessInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_SESSION_PROCESS_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemExtendedProcessInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_PROCESS_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemEmulationBasicInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_BASIC_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemExtendedHandleInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_HANDLE_INFORMATION_EX* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemSessionPoolTagInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_SESSION_POOLTAG_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemSessionMappedViewInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_SESSION_MAPPED_VIEW_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemRegisterFirmwareTableInformationHandler(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_FIRMWARE_TABLE_HANDLER* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemModuleInformationEx(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ RTL_PROCESS_MODULE_INFORMATION_EX* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemSuperfetchInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SUPERFETCH_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemMemoryListInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_MEMORY_LIST_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemFileCacheInformationEx(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_FILECACHE_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemRefTraceInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_REF_TRACE_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemProcessIdInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_PROCESS_ID_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemVerifierInformationEx(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_VERIFIER_INFORMATION_EX* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemSystemPartitionInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_SYSTEM_PARTITION_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemSystemDiskInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_SYSTEM_DISK_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemPagedPoolInformationEx(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_FILECACHE_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemSystemPtesInformationEx(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_FILECACHE_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemBasicPerformanceInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_BASIC_PERFORMANCE_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemPolicyInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_POLICY_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemManufacturingInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_MANUFACTURING_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemActivityModerationUserSettings(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemHypervisorSharedPageInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQuerySystemInformationEx_SystemLogicalProcessorInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _In_ SYSTEM_LOGICAL_PROCESSOR_INFORMATION* InputBuffer, _In_ ULONG InputBufferLength, _Out_ PVOID SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQuerySystemInformationEx_SystemLogicalProcessorAndGroupInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _In_ SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX* InputBuffer, _In_ ULONG InputBufferLength, _Out_ PVOID SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQuerySystemInformationEx_SystemFeatureConfigurationInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _In_ SYSTEM_FEATURE_CONFIGURATION_INFORMATION* InputBuffer, _In_ ULONG InputBufferLength, _Out_ PVOID SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtSetSystemInformation_SystemPagedPoolInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _In_ SYSTEM_POOL_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength);
static NTSTATUS WINAPI _w32_NtSetSystemInformation_SystemRegistryQuotaInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _In_ SYSTEM_REGISTRY_QUOTA_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength);
static NTSTATUS WINAPI _w32_NtSetSystemInformation_SystemExtendServiceTableInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _In_ UNICODE_STRING* SystemInformation, _In_ ULONG SystemInformationLength);
static NTSTATUS WINAPI _w32_NtSetSystemInformation_SystemVerifierInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _In_ SYSTEM_VERIFIER_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength);
static NTSTATUS WINAPI _w32_NtSetSystemInformation_SystemThreadPriorityClientIdInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _In_ SYSTEM_THREAD_CID_PRIORITY_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength);
static NTSTATUS WINAPI _w32_NtSetSystemInformation_SystemRefTraceInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _In_ SYSTEM_REF_TRACE_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength);
static NTSTATUS WINAPI _w32_NtSetSystemInformation_SystemVerifierInformationEx(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _In_ SYSTEM_VERIFIER_INFORMATION_EX* SystemInformation, _In_ ULONG SystemInformationLength);
static NTSTATUS WINAPI _w32_NtSetSystemInformation_SystemVerifierFaultsInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _In_ SYSTEM_VERIFIER_FAULTS_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength);
static NTSTATUS WINAPI _w32_NtSetSystemInformation_SystemRegistryAppendString(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _In_ SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS* SystemInformation, _In_ ULONG SystemInformationLength);
static NTSTATUS WINAPI _w32_NtSetSystemInformation_SystemPagedPoolInformationEx(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _In_ SYSTEM_FILECACHE_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength);
static NTSTATUS WINAPI _w32_NtSetSystemInformation_SystemPolicyInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _In_ SYSTEM_POLICY_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength);
static NTSTATUS WINAPI _w32_NtSetSystemInformation_SystemElamCertificateInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _In_ SYSTEM_ELAM_CERTIFICATE_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength);
static NTSTATUS WINAPI _w32_NtSetSystemInformation_SystemActivityModerationExeState(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _In_ SYSTEM_ACTIVITY_MODERATION_EXE_STATE* SystemInformation, _In_ ULONG SystemInformationLength);
static NTSTATUS WINAPI _w32_NtSetSystemInformation_SystemFeatureConfigurationInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _In_ SYSTEM_FEATURE_CONFIGURATION_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength);
static NTSTATUS WINAPI _w32_NtQueryVirtualMemory_MemoryBasicInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PVOID BaseAddress, _In_ MEMORY_INFORMATION_CLASS MemoryInformationClass, _Out_ MEMORY_BASIC_INFORMATION* MemoryInformation, _In_ SIZE_T MemoryInformationLength, _Out_ PSIZE_T ReturnLength);
static NTSTATUS WINAPI _w32_NtQueryVirtualMemory_MemoryWorkingSetInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PVOID BaseAddress, _In_ MEMORY_INFORMATION_CLASS MemoryInformationClass, _Out_ MEMORY_WORKING_SET_INFORMATION* MemoryInformation, _In_ SIZE_T MemoryInformationLength, _Out_ PSIZE_T ReturnLength);
static NTSTATUS WINAPI _w32_NtQueryVirtualMemory_MemoryMappedFilenameInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PVOID BaseAddress, _In_ MEMORY_INFORMATION_CLASS MemoryInformationClass, _Out_ UNICODE_STRING* MemoryInformation, _In_ SIZE_T MemoryInformationLength, _Out_ PSIZE_T ReturnLength);
static NTSTATUS WINAPI _w32_NtQueryVirtualMemory_MemoryRegionInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PVOID BaseAddress, _In_ MEMORY_INFORMATION_CLASS MemoryInformationClass, _Out_ MEMORY_REGION_INFORMATION* MemoryInformation, _In_ SIZE_T MemoryInformationLength, _Out_ PSIZE_T ReturnLength);
static NTSTATUS WINAPI _w32_NtQueryVirtualMemory_MemoryWorkingSetExInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PVOID BaseAddress, _In_ MEMORY_INFORMATION_CLASS MemoryInformationClass, _Out_ MEMORY_WORKING_SET_EX_INFORMATION* MemoryInformation, _In_ SIZE_T MemoryInformationLength, _Out_ PSIZE_T ReturnLength);
static NTSTATUS WINAPI _w32_NtQueryVirtualMemory_MemoryRegionInformationEx(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PVOID BaseAddress, _In_ MEMORY_INFORMATION_CLASS MemoryInformationClass, _Out_ MEMORY_REGION_INFORMATION* MemoryInformation, _In_ SIZE_T MemoryInformationLength, _Out_ PSIZE_T ReturnLength);
static NTSTATUS WINAPI _w32_NtQuerySection_SectionBasicInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE SectionHandle, _In_ SECTION_INFORMATION_CLASS SectionInformationClass, _Out_ SECTION_BASIC_INFORMATION* SectionInformation, _In_ SIZE_T SectionInformationLength, _Out_ PSIZE_T ReturnLength);
static NTSTATUS WINAPI _w32_NtQuerySection_SectionImageInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE SectionHandle, _In_ SECTION_INFORMATION_CLASS SectionInformationClass, _Out_ SECTION_IMAGE_INFORMATION* SectionInformation, _In_ SIZE_T SectionInformationLength, _Out_ PSIZE_T ReturnLength);
static NTSTATUS WINAPI _w32_NtQueryObject_ObjectNameInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE Handle, _In_ OBJECT_INFORMATION_CLASS ObjectInformationClass, _Out_ OBJECT_NAME_INFORMATION* ObjectInformation, _In_ ULONG ObjectInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQueryObject_ObjectTypeInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE Handle, _In_ OBJECT_INFORMATION_CLASS ObjectInformationClass, _Out_ OBJECT_TYPE_INFORMATION* ObjectInformation, _In_ ULONG ObjectInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQueryInformationProcess_ProcessBasicInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _Out_ PROCESS_BASIC_INFORMATION* ProcessInformation, _In_ ULONG ProcessInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQueryInformationProcess_ProcessQuotaLimits(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _Out_ QUOTA_LIMITS* ProcessInformation, _In_ ULONG ProcessInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQueryInformationProcess_ProcessVmCounters(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _Out_ VM_COUNTERS* ProcessInformation, _In_ ULONG ProcessInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQueryInformationProcess_ProcessPooledUsageAndLimits(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _Out_ POOLED_USAGE_AND_LIMITS* ProcessInformation, _In_ ULONG ProcessInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQueryInformationProcess_ProcessWorkingSetWatch(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _Out_ PROCESS_WS_WATCH_INFORMATION* ProcessInformation, _In_ ULONG ProcessInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQueryInformationProcess_ProcessDeviceMap(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _Out_ PROCESS_DEVICEMAP_INFORMATION* ProcessInformation, _In_ ULONG ProcessInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQueryInformationProcess_ProcessImageFileName(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _Out_ UNICODE_STRING* ProcessInformation, _In_ ULONG ProcessInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQueryInformationProcess_ProcessHandleTracing(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _Out_ PROCESS_HANDLE_TRACING_QUERY* ProcessInformation, _In_ ULONG ProcessInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQueryInformationProcess_ProcessImageInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _Out_ SECTION_IMAGE_INFORMATION* ProcessInformation, _In_ ULONG ProcessInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQueryInformationProcess_ProcessWorkingSetWatchEx(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _Out_ PROCESS_WS_WATCH_INFORMATION_EX* ProcessInformation, _In_ ULONG ProcessInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQueryInformationProcess_ProcessImageFileNameWin32(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _Out_ UNICODE_STRING* ProcessInformation, _In_ ULONG ProcessInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQueryInformationProcess_ProcessHandleInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _Out_ PROCESS_HANDLE_SNAPSHOT_INFORMATION* ProcessInformation, _In_ ULONG ProcessInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQueryInformationProcess_ProcessCommandLineInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _Out_ UNICODE_STRING* ProcessInformation, _In_ ULONG ProcessInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtSetInformationProcess_ProcessQuotaLimits(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _In_ QUOTA_LIMITS* ProcessInformation, _In_ ULONG ProcessInformationLength);
static NTSTATUS WINAPI _w32_NtSetInformationProcess_ProcessExceptionPort(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _In_ PROCESS_EXCEPTION_PORT* ProcessInformation, _In_ ULONG ProcessInformationLength);
static NTSTATUS WINAPI _w32_NtSetInformationProcess_ProcessAccessToken(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _In_ PROCESS_ACCESS_TOKEN* ProcessInformation, _In_ ULONG ProcessInformationLength);
static NTSTATUS WINAPI _w32_NtSetInformationProcess_ProcessAffinityMask(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _In_ KAFFINITY* ProcessInformation, _In_ ULONG ProcessInformationLength);
static NTSTATUS WINAPI _w32_NtSetInformationProcess_ProcessInstrumentationCallback(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _In_ PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION* ProcessInformation, _In_ ULONG ProcessInformationLength);
static NTSTATUS WINAPI _w32_NtSetInformationProcess_ProcessThreadStackAllocation(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _In_ PROCESS_STACK_ALLOCATION_INFORMATION* ProcessInformation, _In_ ULONG ProcessInformationLength);
static NTSTATUS WINAPI _w32_NtSetInformationProcess_ProcessMemoryExhaustion(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _In_ PROCESS_MEMORY_EXHAUSTION_INFO* ProcessInformation, _In_ ULONG ProcessInformationLength);
static NTSTATUS WINAPI _w32_NtSetInformationProcess_ProcessCombineSecurityDomainsInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _In_ PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION* ProcessInformation, _In_ ULONG ProcessInformationLength);
static NTSTATUS WINAPI _w32_NtQueryInformationThread_ThreadBasicInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE ThreadHandle, _In_ THREADINFOCLASS ThreadInformationClass, _Out_ THREAD_BASIC_INFORMATION* ThreadInformation, _In_ ULONG ThreadInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQueryInformationThread_ThreadLastSystemCall(void* ctx, uint32_t syscall_idx, _In_ HANDLE ThreadHandle, _In_ THREADINFOCLASS ThreadInformationClass, _Out_ THREAD_LAST_SYSCALL_INFORMATION* ThreadInformation, _In_ ULONG ThreadInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQueryInformationThread_ThreadTebInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE ThreadHandle, _In_ THREADINFOCLASS ThreadInformationClass, _Out_ THREAD_TEB_INFORMATION* ThreadInformation, _In_ ULONG ThreadInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQueryInformationThread_ThreadGroupInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE ThreadHandle, _In_ THREADINFOCLASS ThreadInformationClass, _Out_ GROUP_AFFINITY* ThreadInformation, _In_ ULONG ThreadInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQueryInformationThread_ThreadCounterProfiling(void* ctx, uint32_t syscall_idx, _In_ HANDLE ThreadHandle, _In_ THREADINFOCLASS ThreadInformationClass, _Out_ THREAD_PROFILING_INFORMATION* ThreadInformation, _In_ ULONG ThreadInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtQueryInformationThread_ThreadNameInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE ThreadHandle, _In_ THREADINFOCLASS ThreadInformationClass, _Out_ THREAD_NAME_INFORMATION* ThreadInformation, _In_ ULONG ThreadInformationLength, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtSetInformationThread_ThreadAffinityMask(void* ctx, uint32_t syscall_idx, _In_ HANDLE ThreadHandle, _In_ THREADINFOCLASS ThreadInformationClass, _In_ KAFFINITY* ThreadInformation, _In_ ULONG ThreadInformationLength);
static NTSTATUS WINAPI _w32_NtSetInformationThread_ThreadGroupInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE ThreadHandle, _In_ THREADINFOCLASS ThreadInformationClass, _In_ GROUP_AFFINITY* ThreadInformation, _In_ ULONG ThreadInformationLength);
static NTSTATUS WINAPI _w32_NtSetInformationThread_ThreadCounterProfiling(void* ctx, uint32_t syscall_idx, _In_ HANDLE ThreadHandle, _In_ THREADINFOCLASS ThreadInformationClass, _In_ THREAD_PROFILING_INFORMATION* ThreadInformation, _In_ ULONG ThreadInformationLength);
static NTSTATUS WINAPI _w32_NtSetInformationThread_ThreadNameInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE ThreadHandle, _In_ THREADINFOCLASS ThreadInformationClass, _In_ THREAD_NAME_INFORMATION* ThreadInformation, _In_ ULONG ThreadInformationLength);
static NTSTATUS WINAPI _w32_NtSetInformationFile_FileRenameInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE FileHandle, _Out_ PIO_STATUS_BLOCK IoStatusBlock, _In_ FILE_RENAME_INFORMATION* FileInformation, _In_ ULONG Length, _In_ FILE_INFORMATION_CLASS FileInformationClass);
static NTSTATUS WINAPI _w32_NtSetInformationFile_FileLinkInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE FileHandle, _Out_ PIO_STATUS_BLOCK IoStatusBlock, _In_ FILE_LINK_INFORMATION* FileInformation, _In_ ULONG Length, _In_ FILE_INFORMATION_CLASS FileInformationClass);
static NTSTATUS WINAPI _w32_NtSetInformationFile_FileMailslotSetInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE FileHandle, _Out_ PIO_STATUS_BLOCK IoStatusBlock, _In_ FILE_MAILSLOT_SET_INFORMATION* FileInformation, _In_ ULONG Length, _In_ FILE_INFORMATION_CLASS FileInformationClass);
static NTSTATUS WINAPI _w32_NtSetInformationFile_FileCompletionInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE FileHandle, _Out_ PIO_STATUS_BLOCK IoStatusBlock, _In_ FILE_COMPLETION_INFORMATION* FileInformation, _In_ ULONG Length, _In_ FILE_INFORMATION_CLASS FileInformationClass);
static NTSTATUS WINAPI _w32_NtSetInformationFile_FileMoveClusterInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE FileHandle, _Out_ PIO_STATUS_BLOCK IoStatusBlock, _In_ FILE_MOVE_CLUSTER_INFORMATION* FileInformation, _In_ ULONG Length, _In_ FILE_INFORMATION_CLASS FileInformationClass);
static NTSTATUS WINAPI _w32_NtSetInformationFile_FileTrackingInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE FileHandle, _Out_ PIO_STATUS_BLOCK IoStatusBlock, _In_ FILE_TRACKING_INFORMATION* FileInformation, _In_ ULONG Length, _In_ FILE_INFORMATION_CLASS FileInformationClass);
static NTSTATUS WINAPI _w32_NtSetInformationFile_FileIoStatusBlockRangeInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE FileHandle, _Out_ PIO_STATUS_BLOCK IoStatusBlock, _In_ FILE_IOSTATUSBLOCK_RANGE_INFORMATION* FileInformation, _In_ ULONG Length, _In_ FILE_INFORMATION_CLASS FileInformationClass);
static NTSTATUS WINAPI _w32_NtSetInformationFile_FileReplaceCompletionInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE FileHandle, _Out_ PIO_STATUS_BLOCK IoStatusBlock, _In_ FILE_COMPLETION_INFORMATION* FileInformation, _In_ ULONG Length, _In_ FILE_INFORMATION_CLASS FileInformationClass);
static NTSTATUS WINAPI _w32_NtSetInformationFile_FileRenameInformationEx(void* ctx, uint32_t syscall_idx, _In_ HANDLE FileHandle, _Out_ PIO_STATUS_BLOCK IoStatusBlock, _In_ FILE_RENAME_INFORMATION_EX* FileInformation, _In_ ULONG Length, _In_ FILE_INFORMATION_CLASS FileInformationClass);
static NTSTATUS WINAPI _w32_NtSetInformationFile_FileMemoryPartitionInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE FileHandle, _Out_ PIO_STATUS_BLOCK IoStatusBlock, _In_ FILE_MEMORY_PARTITION_INFORMATION* FileInformation, _In_ ULONG Length, _In_ FILE_INFORMATION_CLASS FileInformationClass);
static NTSTATUS WINAPI _w32_NtSetInformationFile_FileLinkInformationEx(void* ctx, uint32_t syscall_idx, _In_ HANDLE FileHandle, _Out_ PIO_STATUS_BLOCK IoStatusBlock, _In_ FILE_LINK_INFORMATION_EX* FileInformation, _In_ ULONG Length, _In_ FILE_INFORMATION_CLASS FileInformationClass);
static NTSTATUS WINAPI _w32_NtAlpcQueryInformation_AlpcBasicInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE PortHandle, _In_ ALPC_PORT_INFORMATION_CLASS PortInformationClass, _Out_ ALPC_BASIC_INFORMATION* PortInformation, _In_ ULONG Length, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtAlpcQueryInformation_AlpcServerInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE PortHandle, _In_ ALPC_PORT_INFORMATION_CLASS PortInformationClass, _Out_ ALPC_SERVER_INFORMATION* PortInformation, _In_ ULONG Length, _Out_ PULONG ReturnLength);
static NTSTATUS WINAPI _w32_NtAlpcSetInformation_AlpcBasicInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE PortHandle, _In_ ALPC_PORT_INFORMATION_CLASS PortInformationClass, _In_ ALPC_BASIC_INFORMATION* PortInformation, _In_ ULONG Length);
static NTSTATUS WINAPI _w32_NtAlpcSetInformation_AlpcPortInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE PortHandle, _In_ ALPC_PORT_INFORMATION_CLASS PortInformationClass, _In_ ALPC_PORT_ATTRIBUTES* PortInformation, _In_ ULONG Length);
static NTSTATUS WINAPI _w32_NtAlpcSetInformation_AlpcAssociateCompletionPortInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE PortHandle, _In_ ALPC_PORT_INFORMATION_CLASS PortInformationClass, _In_ ALPC_PORT_ASSOCIATE_COMPLETION_PORT* PortInformation, _In_ ULONG Length);
static NTSTATUS WINAPI _w32_NtAlpcSetInformation_AlpcMessageZoneInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE PortHandle, _In_ ALPC_PORT_INFORMATION_CLASS PortInformationClass, _In_ ALPC_PORT_MESSAGE_ZONE_INFORMATION* PortInformation, _In_ ULONG Length);
static NTSTATUS WINAPI _w32_NtAlpcSetInformation_AlpcRegisterCompletionListInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE PortHandle, _In_ ALPC_PORT_INFORMATION_CLASS PortInformationClass, _In_ ALPC_PORT_COMPLETION_LIST_INFORMATION* PortInformation, _In_ ULONG Length);

NTSTATUS WINAPI _w32_NtMapViewOfSectionEx(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCallbackReturn(uint32_t* x32based_args);
void WINAPI _w32_NtFlushProcessWriteBuffers(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryDebugFilterState(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetDebugFilterState(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtYieldExecution(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtDelayExecution(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQuerySystemEnvironmentValue(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetSystemEnvironmentValue(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQuerySystemEnvironmentValueEx(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetSystemEnvironmentValueEx(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtEnumerateSystemEnvironmentValuesEx(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAddBootEntry(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtDeleteBootEntry(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtModifyBootEntry(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtEnumerateBootEntries(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryBootEntryOrder(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetBootEntryOrder(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryBootOptions(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetBootOptions(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtTranslateFilePath(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAddDriverEntry(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtDeleteDriverEntry(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtModifyDriverEntry(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtEnumerateDriverEntries(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryDriverEntryOrder(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetDriverEntryOrder(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtFilterBootOption(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateEvent(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtOpenEvent(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetEvent(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetEventBoostPriority(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtClearEvent(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtResetEvent(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtPulseEvent(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryEvent(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateEventPair(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtOpenEventPair(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetLowEventPair(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetHighEventPair(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtWaitLowEventPair(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtWaitHighEventPair(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetLowWaitHighEventPair(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetHighWaitLowEventPair(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateMutant(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtOpenMutant(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtReleaseMutant(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryMutant(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateSemaphore(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtOpenSemaphore(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtReleaseSemaphore(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQuerySemaphore(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateTimer(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtOpenTimer(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetTimer(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetTimerEx(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCancelTimer(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryTimer(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateIRTimer(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetIRTimer(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateTimer2(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetTimer2(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCancelTimer2(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateProfile(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateProfileEx(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtStartProfile(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtStopProfile(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryIntervalProfile(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetIntervalProfile(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateKeyedEvent(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtOpenKeyedEvent(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtReleaseKeyedEvent(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtWaitForKeyedEvent(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtUmsThreadYield(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateWnfStateName(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtDeleteWnfStateName(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtUpdateWnfStateData(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtDeleteWnfStateData(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryWnfStateData(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryWnfStateNameInformation(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSubscribeWnfStateChange(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtUnsubscribeWnfStateChange(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtGetCompleteWnfStateSubscription(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetWnfProcessNotificationEvent(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateWorkerFactory(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryInformationWorkerFactory(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetInformationWorkerFactory(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtShutdownWorkerFactory(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtReleaseWorkerFactoryWorker(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtWorkerFactoryWorkerReady(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtWaitForWorkViaWorkerFactory(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetSystemTime(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryTimerResolution(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetTimerResolution(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryPerformanceCounter(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAllocateLocallyUniqueId(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetUuidSeed(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAllocateUuids(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQuerySystemInformation(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQuerySystemInformationEx(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetSystemInformation(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSystemDebugControl(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtRaiseHardError(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryDefaultLocale(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetDefaultLocale(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryInstallUILanguage(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtFlushInstallUILanguage(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryDefaultUILanguage(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetDefaultUILanguage(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtIsUILanguageComitted(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtInitializeNlsFiles(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtGetNlsSectionPtr(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtMapCMFModule(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtGetMUIRegistryInfo(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAddAtom(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAddAtomEx(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtFindAtom(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtDeleteAtom(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryInformationAtom(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryLicenseValue(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetDefaultHardErrorPort(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtShutdownSystem(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtDisplayString(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtDrawText(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAllocateVirtualMemory(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtFreeVirtualMemory(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtReadVirtualMemory(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtWriteVirtualMemory(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtProtectVirtualMemory(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryVirtualMemory(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetInformationVirtualMemory(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtLockVirtualMemory(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtUnlockVirtualMemory(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateSection(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateSectionEx(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtOpenSection(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtMapViewOfSection(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtUnmapViewOfSection(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtUnmapViewOfSectionEx(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtExtendSection(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQuerySection(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAreMappedFilesTheSame(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreatePartition(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtOpenPartition(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtManagePartition(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtMapUserPhysicalPages(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtMapUserPhysicalPagesScatter(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAllocateUserPhysicalPages(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtFreeUserPhysicalPages(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtGetWriteWatch(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtResetWriteWatch(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreatePagingFile(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtFlushInstructionCache(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtFlushWriteBuffer(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateEnclave(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtLoadEnclaveData(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtInitializeEnclave(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtTerminateEnclave(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCallEnclave(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryObject(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetInformationObject(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtDuplicateObject(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtMakeTemporaryObject(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtMakePermanentObject(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSignalAndWaitForSingleObject(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtWaitForSingleObject(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtWaitForMultipleObjects(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtWaitForMultipleObjects32(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetSecurityObject(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQuerySecurityObject(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtClose(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCompareObjects(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateDirectoryObject(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateDirectoryObjectEx(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtOpenDirectoryObject(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryDirectoryObject(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreatePrivateNamespace(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtOpenPrivateNamespace(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtDeletePrivateNamespace(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateSymbolicLinkObject(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtOpenSymbolicLinkObject(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQuerySymbolicLinkObject(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateProcess(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateProcessEx(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtOpenProcess(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtTerminateProcess(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSuspendProcess(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtResumeProcess(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryInformationProcess(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtGetNextProcess(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtGetNextThread(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetInformationProcess(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryPortInformationProcess(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateThread(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtOpenThread(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtTerminateThread(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSuspendThread(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtResumeThread(uint32_t* x32based_args);
ULONG WINAPI _w32_NtGetCurrentProcessorNumber(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtGetContextThread(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetContextThread(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryInformationThread(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetInformationThread(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAlertThread(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAlertResumeThread(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtTestAlert(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtImpersonateThread(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtRegisterThreadTerminatePort(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetLdtEntries(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueueApcThread(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueueApcThreadEx(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAlertThreadByThreadId(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtWaitForAlertByThreadId(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateUserProcess(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateThreadEx(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateJobObject(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtOpenJobObject(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAssignProcessToJobObject(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtTerminateJobObject(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtIsProcessInJob(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryInformationJobObject(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetInformationJobObject(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateJobSet(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtRevertContainerImpersonation(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAllocateReserveObject(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateDebugObject(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtDebugActiveProcess(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtDebugContinue(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtRemoveProcessDebug(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetInformationDebugObject(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtWaitForDebugEvent(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateFile(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateNamedPipeFile(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateMailslotFile(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtOpenFile(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtDeleteFile(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtFlushBuffersFile(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtFlushBuffersFileEx(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryInformationFile(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryInformationByName(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetInformationFile(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryDirectoryFile(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryDirectoryFileEx(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryEaFile(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetEaFile(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryQuotaInformationFile(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetQuotaInformationFile(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryVolumeInformationFile(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetVolumeInformationFile(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCancelIoFile(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCancelIoFileEx(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCancelSynchronousIoFile(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtDeviceIoControlFile(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtFsControlFile(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtReadFile(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtWriteFile(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtReadFileScatter(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtWriteFileGather(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtLockFile(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtUnlockFile(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryAttributesFile(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryFullAttributesFile(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtNotifyChangeDirectoryFile(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtNotifyChangeDirectoryFileEx(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtLoadDriver(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtUnloadDriver(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateIoCompletion(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtOpenIoCompletion(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryIoCompletion(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetIoCompletion(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetIoCompletionEx(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtRemoveIoCompletion(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtRemoveIoCompletionEx(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateWaitCompletionPacket(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAssociateWaitCompletionPacket(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCancelWaitCompletionPacket(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtOpenSession(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtNotifyChangeSession(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreatePort(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateWaitablePort(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtConnectPort(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSecureConnectPort(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtListenPort(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAcceptConnectPort(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCompleteConnectPort(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtRequestPort(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtRequestWaitReplyPort(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtReplyPort(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtReplyWaitReplyPort(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtReplyWaitReceivePort(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtReplyWaitReceivePortEx(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtImpersonateClientOfPort(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtReadRequestData(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtWriteRequestData(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryInformationPort(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAlpcCreatePort(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAlpcDisconnectPort(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAlpcQueryInformation(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAlpcSetInformation(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAlpcCreatePortSection(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAlpcDeletePortSection(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAlpcCreateResourceReserve(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAlpcDeleteResourceReserve(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAlpcCreateSectionView(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAlpcDeleteSectionView(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAlpcCreateSecurityContext(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAlpcDeleteSecurityContext(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAlpcRevokeSecurityContext(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAlpcQueryInformationMessage(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAlpcConnectPort(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAlpcConnectPortEx(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAlpcAcceptConnectPort(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAlpcSendWaitReceivePort(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAlpcCancelMessage(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAlpcImpersonateClientOfPort(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAlpcImpersonateClientContainerOfPort(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAlpcOpenSenderProcess(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAlpcOpenSenderThread(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtPlugPlayControl(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSerializeBoot(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtEnableLastKnownGood(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtDisableLastKnownGood(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtReplacePartitionUnit(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtPowerInformation(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetThreadExecutionState(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtInitiatePowerAction(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetSystemPowerState(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtGetDevicePowerState(uint32_t* x32based_args);
BOOLEAN WINAPI _w32_NtIsSystemResumeAutomatic(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateKey(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateKeyTransacted(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtOpenKey(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtOpenKeyTransacted(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtOpenKeyEx(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtOpenKeyTransactedEx(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtDeleteKey(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtRenameKey(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtDeleteValueKey(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryKey(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetInformationKey(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryValueKey(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetValueKey(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryMultipleValueKey(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtEnumerateKey(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtEnumerateValueKey(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtFlushKey(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCompactKeys(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCompressKey(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtLoadKey(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtLoadKey2(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtLoadKeyEx(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtReplaceKey(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSaveKey(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSaveKeyEx(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSaveMergedKeys(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtRestoreKey(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtUnloadKey(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtUnloadKey2(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtUnloadKeyEx(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtNotifyChangeKey(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtNotifyChangeMultipleKeys(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryOpenSubKeys(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryOpenSubKeysEx(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtInitializeRegistry(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtLockRegistryKey(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtLockProductActivationKeys(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtFreezeRegistry(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtThawRegistry(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateToken(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateLowBoxToken(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateTokenEx(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtOpenProcessToken(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtOpenProcessTokenEx(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtOpenThreadToken(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtOpenThreadTokenEx(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtDuplicateToken(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryInformationToken(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetInformationToken(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAdjustPrivilegesToken(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAdjustGroupsToken(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAdjustTokenClaimsAndDeviceGroups(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtFilterToken(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtFilterTokenEx(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCompareTokens(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtPrivilegeCheck(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtImpersonateAnonymousToken(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQuerySecurityAttributesToken(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAccessCheck(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAccessCheckByType(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAccessCheckByTypeResultList(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetCachedSigningLevel(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtGetCachedSigningLevel(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAccessCheckAndAuditAlarm(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAccessCheckByTypeAndAuditAlarm(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAccessCheckByTypeResultListAndAuditAlarm(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtAccessCheckByTypeResultListAndAuditAlarmByHandle(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtOpenObjectAuditAlarm(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtPrivilegeObjectAuditAlarm(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCloseObjectAuditAlarm(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtDeleteObjectAuditAlarm(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtPrivilegedServiceAuditAlarm(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateTransactionManager(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtOpenTransactionManager(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtRenameTransactionManager(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtRollforwardTransactionManager(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtRecoverTransactionManager(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryInformationTransactionManager(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetInformationTransactionManager(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtEnumerateTransactionObject(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateTransaction(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtOpenTransaction(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryInformationTransaction(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetInformationTransaction(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCommitTransaction(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtRollbackTransaction(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateEnlistment(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtOpenEnlistment(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryInformationEnlistment(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetInformationEnlistment(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtRecoverEnlistment(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtPrePrepareEnlistment(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtPrepareEnlistment(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCommitEnlistment(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtRollbackEnlistment(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtPrePrepareComplete(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtPrepareComplete(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCommitComplete(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtReadOnlyEnlistment(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtRollbackComplete(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSinglePhaseReject(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtCreateResourceManager(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtOpenResourceManager(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtRecoverResourceManager(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtGetNotificationResourceManager(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtQueryInformationResourceManager(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtSetInformationResourceManager(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtRegisterProtocolAddressInformation(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtPropagationComplete(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtPropagationFailed(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtFreezeTransactions(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtThawTransactions(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtContinue(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtRaiseException(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtVdmControl(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtTraceEvent(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtTraceControl(uint32_t* x32based_args);
NTSTATUS WINAPI _w32_NtFlushVirtualMemory(uint32_t* x32based_args);

static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemBasicInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_BASIC_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_BASIC_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SystemInformation_holder[sizeof(_SYSTEM_BASIC_INFORMATION)];
	SYSTEM_BASIC_INFORMATION* SystemInformation_used = (SYSTEM_BASIC_INFORMATION*)&SystemInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_SystemInformation == NULL) {
		SystemInformation_used = 0;
	}
	else {
		SystemInformationLength = sizeof(_SYSTEM_BASIC_INFORMATION);
	}

	ret_value = __syscall64(syscall_idx, 4, SystemInformationClass, SystemInformation_used, SystemInformationLength, ReturnLength); // NtQuerySystemInformation_SystemBasicInformation

	if (NT_SUCCESS(ret_value) && SystemInformation_used != NULL) {
		convert__SYSTEM_BASIC_INFORMATION_64TO32(ctx, (_SYSTEM_BASIC_INFORMATION*)SystemInformation_used, x32based_SystemInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemProcessInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_PROCESS_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_PROCESS_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	SYSTEM_PROCESS_INFORMATION* SystemInformation_used = 0;

	if (x32based_SystemInformation != NULL && SystemInformationLength != 0) {
		SystemInformation_used = (SYSTEM_PROCESS_INFORMATION*)intrnl__ntcallmalloc(ctx, SystemInformationLength);
	}

	// Convert parameters from x32 to x64

	ret_value = __syscall64(syscall_idx, 4, SystemInformationClass, SystemInformation_used, SystemInformationLength, ReturnLength); // NtQuerySystemInformation_SystemProcessInformation

	if (NT_SUCCESS(ret_value) && SystemInformation_used != NULL) {
		convert__SYSTEM_PROCESS_INFORMATION_64TO32(ctx, (_SYSTEM_PROCESS_INFORMATION*)SystemInformation_used, x32based_SystemInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemPagedPoolInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_POOL_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_POOL_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	SYSTEM_POOL_INFORMATION* SystemInformation_used = 0;

	if (x32based_SystemInformation != NULL && SystemInformationLength != 0) {
		SystemInformation_used = (SYSTEM_POOL_INFORMATION*)intrnl__ntcallmalloc(ctx, SystemInformationLength);
	}

	// Convert parameters from x32 to x64

	ret_value = __syscall64(syscall_idx, 4, SystemInformationClass, SystemInformation_used, SystemInformationLength, ReturnLength); // NtQuerySystemInformation_SystemPagedPoolInformation

	if (NT_SUCCESS(ret_value) && SystemInformation_used != NULL) {
		convert__SYSTEM_POOL_INFORMATION_64TO32(ctx, (_SYSTEM_POOL_INFORMATION*)SystemInformation_used, x32based_SystemInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemNonPagedPoolInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_POOL_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_POOL_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	SYSTEM_POOL_INFORMATION* SystemInformation_used = 0;

	if (x32based_SystemInformation != NULL && SystemInformationLength != 0) {
		SystemInformation_used = (SYSTEM_POOL_INFORMATION*)intrnl__ntcallmalloc(ctx, SystemInformationLength);
	}

	ret_value = __syscall64(syscall_idx, 4, SystemInformationClass, SystemInformation_used, SystemInformationLength, ReturnLength); // NtQuerySystemInformation_SystemNonPagedPoolInformation

	if (NT_SUCCESS(ret_value) && SystemInformation_used != NULL) {
		convert__SYSTEM_POOL_INFORMATION_64TO32(ctx, (_SYSTEM_POOL_INFORMATION*)SystemInformation_used, x32based_SystemInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemPageFileInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_PAGEFILE_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_PAGEFILE_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	SYSTEM_PAGEFILE_INFORMATION* SystemInformation_used = 0;

	if (x32based_SystemInformation != NULL && SystemInformationLength != 0) {
		SystemInformation_used = (SYSTEM_PAGEFILE_INFORMATION*)intrnl__ntcallmalloc(ctx, SystemInformationLength);
	}

	ret_value = __syscall64(syscall_idx, 4, SystemInformationClass, SystemInformation_used, SystemInformationLength, ReturnLength); // NtQuerySystemInformation_SystemPageFileInformation

	if (NT_SUCCESS(ret_value) && SystemInformation_used != NULL) {
		convert__SYSTEM_PAGEFILE_INFORMATION_64TO32(ctx, (_SYSTEM_PAGEFILE_INFORMATION*)SystemInformation_used, x32based_SystemInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemFileCacheInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_FILECACHE_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_FILECACHE_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	SYSTEM_FILECACHE_INFORMATION* SystemInformation_used = 0;

	if (x32based_SystemInformation != NULL && SystemInformationLength != 0) {
		SystemInformation_used = (SYSTEM_FILECACHE_INFORMATION*)intrnl__ntcallmalloc(ctx, SystemInformationLength);
	}

	ret_value = __syscall64(syscall_idx, 4, SystemInformationClass, SystemInformation_used, SystemInformationLength, ReturnLength); // NtQuerySystemInformation_SystemFileCacheInformation

	if (NT_SUCCESS(ret_value) && SystemInformation_used != NULL) {
		convert__SYSTEM_FILECACHE_INFORMATION_64TO32(ctx, (_SYSTEM_FILECACHE_INFORMATION*)SystemInformation_used, x32based_SystemInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemRegistryQuotaInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_REGISTRY_QUOTA_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_REGISTRY_QUOTA_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SystemInformation_holder[sizeof(_SYSTEM_REGISTRY_QUOTA_INFORMATION)];
	SYSTEM_REGISTRY_QUOTA_INFORMATION* SystemInformation_used = (SYSTEM_REGISTRY_QUOTA_INFORMATION*)&SystemInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_SystemInformation == NULL) {
		SystemInformation_used = 0;
	}
	else {
		SystemInformationLength = sizeof(_SYSTEM_REGISTRY_QUOTA_INFORMATION);
	}

	ret_value = __syscall64(syscall_idx, 4, SystemInformationClass, SystemInformation_used, SystemInformationLength, ReturnLength); // NtQuerySystemInformation_SystemRegistryQuotaInformation

	if (NT_SUCCESS(ret_value) && SystemInformation_used != NULL) {
		convert__SYSTEM_REGISTRY_QUOTA_INFORMATION_64TO32(ctx, (_SYSTEM_REGISTRY_QUOTA_INFORMATION*)SystemInformation_used, x32based_SystemInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemLegacyDriverInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_LEGACY_DRIVER_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_LEGACY_DRIVER_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	SYSTEM_LEGACY_DRIVER_INFORMATION* SystemInformation_used = 0;

	if (x32based_SystemInformation != NULL && SystemInformationLength != 0) {
		SystemInformation_used = (SYSTEM_LEGACY_DRIVER_INFORMATION*)intrnl__ntcallmalloc(ctx, SystemInformationLength);
	}

	ret_value = __syscall64(syscall_idx, 4, SystemInformationClass, SystemInformation_used, SystemInformationLength, ReturnLength); // NtQuerySystemInformation_SystemLegacyDriverInformation

	if (NT_SUCCESS(ret_value) && SystemInformation_used != NULL) {
		convert__SYSTEM_LEGACY_DRIVER_INFORMATION_64TO32(ctx, (_SYSTEM_LEGACY_DRIVER_INFORMATION*)SystemInformation_used, x32based_SystemInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemVerifierInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_VERIFIER_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_VERIFIER_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	SYSTEM_VERIFIER_INFORMATION* SystemInformation_used = 0;

	if (x32based_SystemInformation != NULL && SystemInformationLength != 0) {
		SystemInformation_used = (SYSTEM_VERIFIER_INFORMATION*)intrnl__ntcallmalloc(ctx, SystemInformationLength);
	}

	ret_value = __syscall64(syscall_idx, 4, SystemInformationClass, SystemInformation_used, SystemInformationLength, ReturnLength); // NtQuerySystemInformation_SystemVerifierInformation

	if (NT_SUCCESS(ret_value) && SystemInformation_used != NULL) {
		convert__SYSTEM_VERIFIER_INFORMATION_64TO32(ctx, (_SYSTEM_VERIFIER_INFORMATION*)SystemInformation_used, x32based_SystemInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemSessionProcessInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_SESSION_PROCESS_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_SESSION_PROCESS_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	SYSTEM_SESSION_PROCESS_INFORMATION* SystemInformation_used = 0;

	if (x32based_SystemInformation != NULL && SystemInformationLength != 0) {
		SystemInformation_used = (SYSTEM_SESSION_PROCESS_INFORMATION*)intrnl__ntcallmalloc(ctx, SystemInformationLength);
	}

	ret_value = __syscall64(syscall_idx, 4, SystemInformationClass, SystemInformation_used, SystemInformationLength, ReturnLength); // NtQuerySystemInformation_SystemSessionProcessInformation

	if (NT_SUCCESS(ret_value) && SystemInformation_used != NULL) {
		convert__SYSTEM_SESSION_PROCESS_INFORMATION_64TO32(ctx, (_SYSTEM_SESSION_PROCESS_INFORMATION*)SystemInformation_used, x32based_SystemInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemExtendedProcessInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_PROCESS_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_PROCESS_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	SYSTEM_PROCESS_INFORMATION* SystemInformation_used = (SYSTEM_PROCESS_INFORMATION*)SystemInformation;

	// Convert parameters from x32 to x64

	ret_value = __syscall64(syscall_idx, 4, SystemInformationClass, SystemInformation_used, SystemInformationLength, ReturnLength); // NtQuerySystemInformation_SystemExtendedProcessInformation

	if (NT_SUCCESS(ret_value) && SystemInformation_used != NULL) {
		convert__SYSTEM_PROCESS_INFORMATION_64TO32(ctx, (_SYSTEM_PROCESS_INFORMATION*)SystemInformation_used, x32based_SystemInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemEmulationBasicInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_BASIC_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_BASIC_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SystemInformation_holder[sizeof(_SYSTEM_BASIC_INFORMATION)];
	SYSTEM_BASIC_INFORMATION* SystemInformation_used = (SYSTEM_BASIC_INFORMATION*)&SystemInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_SystemInformation == NULL) {
		SystemInformation_used = 0;
	}
	else {
		SystemInformationLength = sizeof(_SYSTEM_BASIC_INFORMATION);
	}

	ret_value = __syscall64(syscall_idx, 4, SystemInformationClass, SystemInformation_used, SystemInformationLength, ReturnLength); // NtQuerySystemInformation_SystemEmulationBasicInformation

	if (NT_SUCCESS(ret_value) && SystemInformation_used != NULL) {
		convert__SYSTEM_BASIC_INFORMATION_64TO32(ctx, (_SYSTEM_BASIC_INFORMATION*)SystemInformation_used, x32based_SystemInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemExtendedHandleInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_HANDLE_INFORMATION_EX* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_HANDLE_INFORMATION_EX *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	SYSTEM_HANDLE_INFORMATION_EX* SystemInformation_used = 0;

	// Convert parameters from x32 to x64
	if (x32based_SystemInformation != NULL && SystemInformationLength != 0) {
		SystemInformation_used = (SYSTEM_HANDLE_INFORMATION_EX*)intrnl__ntcallmalloc(ctx, SystemInformationLength);
	}

	ret_value = __syscall64(syscall_idx, 4, SystemInformationClass, SystemInformation_used, SystemInformationLength, ReturnLength); // NtQuerySystemInformation_SystemExtendedHandleInformation

	if (NT_SUCCESS(ret_value) && SystemInformation_used != NULL) {
		convert__SYSTEM_HANDLE_INFORMATION_EX_64TO32(ctx, (_SYSTEM_HANDLE_INFORMATION_EX*)SystemInformation_used, x32based_SystemInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemSessionPoolTagInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_SESSION_POOLTAG_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_SESSION_POOLTAG_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	SYSTEM_SESSION_POOLTAG_INFORMATION* SystemInformation_used = (SYSTEM_SESSION_POOLTAG_INFORMATION*)SystemInformation;

	// Convert parameters from x32 to x64
	if (x32based_SystemInformation == NULL) {
		SystemInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, SystemInformationClass, SystemInformation_used, SystemInformationLength, ReturnLength); // NtQuerySystemInformation_SystemSessionPoolTagInformation

	if (NT_SUCCESS(ret_value) && SystemInformation_used != NULL) {
		convert__SYSTEM_SESSION_POOLTAG_INFORMATION_64TO32(ctx, (_SYSTEM_SESSION_POOLTAG_INFORMATION*)SystemInformation_used, x32based_SystemInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemSessionMappedViewInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_SESSION_MAPPED_VIEW_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_SESSION_MAPPED_VIEW_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	SYSTEM_SESSION_MAPPED_VIEW_INFORMATION* SystemInformation_used = (SYSTEM_SESSION_MAPPED_VIEW_INFORMATION*)SystemInformation;

	// Convert parameters from x32 to x64
	if (x32based_SystemInformation == NULL) {
		SystemInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, SystemInformationClass, SystemInformation_used, SystemInformationLength, ReturnLength); // NtQuerySystemInformation_SystemSessionMappedViewInformation

	if (NT_SUCCESS(ret_value) && SystemInformation_used != NULL) {
		convert__SYSTEM_SESSION_MAPPED_VIEW_INFORMATION_64TO32(ctx, (_SYSTEM_SESSION_MAPPED_VIEW_INFORMATION*)SystemInformation_used, x32based_SystemInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemRegisterFirmwareTableInformationHandler(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_FIRMWARE_TABLE_HANDLER* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_FIRMWARE_TABLE_HANDLER *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SystemInformation_holder[sizeof(_SYSTEM_FIRMWARE_TABLE_HANDLER)];
	SYSTEM_FIRMWARE_TABLE_HANDLER* SystemInformation_used = (SYSTEM_FIRMWARE_TABLE_HANDLER*)&SystemInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_SystemInformation == NULL) {
		SystemInformation_used = 0;
	}
	else {
		SystemInformationLength = sizeof(_SYSTEM_FIRMWARE_TABLE_HANDLER);
	}

	ret_value = __syscall64(syscall_idx, 4, SystemInformationClass, SystemInformation_used, SystemInformationLength, ReturnLength); // NtQuerySystemInformation_SystemRegisterFirmwareTableInformationHandler

	if (NT_SUCCESS(ret_value) && SystemInformation_used != NULL) {
		convert__SYSTEM_FIRMWARE_TABLE_HANDLER_64TO32(ctx, (_SYSTEM_FIRMWARE_TABLE_HANDLER*)SystemInformation_used, x32based_SystemInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemModuleInformationEx(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ RTL_PROCESS_MODULE_INFORMATION_EX* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // RTL_PROCESS_MODULE_INFORMATION_EX *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SystemInformation_holder[sizeof(_RTL_PROCESS_MODULE_INFORMATION_EX)];
	RTL_PROCESS_MODULE_INFORMATION_EX* SystemInformation_used = (RTL_PROCESS_MODULE_INFORMATION_EX*)&SystemInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_SystemInformation == NULL) {
		SystemInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, SystemInformationClass, SystemInformation_used, SystemInformationLength, ReturnLength); // NtQuerySystemInformation_SystemModuleInformationEx

	if (NT_SUCCESS(ret_value) && SystemInformation_used != NULL) {
		convert__RTL_PROCESS_MODULE_INFORMATION_EX_64TO32(ctx, (_RTL_PROCESS_MODULE_INFORMATION_EX*)SystemInformation_used, x32based_SystemInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemSuperfetchInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SUPERFETCH_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SUPERFETCH_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SystemInformation_holder[sizeof(_SUPERFETCH_INFORMATION)];
	SUPERFETCH_INFORMATION* SystemInformation_used = (SUPERFETCH_INFORMATION*)&SystemInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_SystemInformation == NULL) {
		SystemInformation_used = 0;
	}
	else {
		SystemInformationLength = sizeof(_SUPERFETCH_INFORMATION);
	}

	ret_value = __syscall64(syscall_idx, 4, SystemInformationClass, SystemInformation_used, SystemInformationLength, ReturnLength); // NtQuerySystemInformation_SystemSuperfetchInformation

	if (NT_SUCCESS(ret_value) && SystemInformation_used != NULL) {
		convert__SUPERFETCH_INFORMATION_64TO32(ctx, (_SUPERFETCH_INFORMATION*)SystemInformation_used, x32based_SystemInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemMemoryListInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_MEMORY_LIST_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_MEMORY_LIST_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SystemInformation_holder[sizeof(_SYSTEM_MEMORY_LIST_INFORMATION)];
	SYSTEM_MEMORY_LIST_INFORMATION* SystemInformation_used = (SYSTEM_MEMORY_LIST_INFORMATION*)&SystemInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_SystemInformation == NULL) {
		SystemInformation_used = 0;
	}
	else {
		SystemInformationLength = sizeof(_SYSTEM_MEMORY_LIST_INFORMATION);
	}

	ret_value = __syscall64(syscall_idx, 4, SystemInformationClass, SystemInformation_used, SystemInformationLength, ReturnLength); // NtQuerySystemInformation_SystemMemoryListInformation

	if (NT_SUCCESS(ret_value) && SystemInformation_used != NULL) {
		convert__SYSTEM_MEMORY_LIST_INFORMATION_64TO32(ctx, (_SYSTEM_MEMORY_LIST_INFORMATION*)SystemInformation_used, x32based_SystemInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemFileCacheInformationEx(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_FILECACHE_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_FILECACHE_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SystemInformation_holder[sizeof(_SYSTEM_FILECACHE_INFORMATION)];
	SYSTEM_FILECACHE_INFORMATION* SystemInformation_used = (SYSTEM_FILECACHE_INFORMATION*)&SystemInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_SystemInformation == NULL) {
		SystemInformation_used = 0;
	}
	else {
		SystemInformationLength = sizeof(_SYSTEM_FILECACHE_INFORMATION);
	}

	ret_value = __syscall64(syscall_idx, 4, SystemInformationClass, SystemInformation_used, SystemInformationLength, ReturnLength); // NtQuerySystemInformation_SystemFileCacheInformationEx

	if (NT_SUCCESS(ret_value) && SystemInformation_used != NULL) {
		convert__SYSTEM_FILECACHE_INFORMATION_64TO32(ctx, (_SYSTEM_FILECACHE_INFORMATION*)SystemInformation_used, x32based_SystemInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemRefTraceInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_REF_TRACE_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_REF_TRACE_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SystemInformation_holder[sizeof(_SYSTEM_REF_TRACE_INFORMATION)];
	SYSTEM_REF_TRACE_INFORMATION* SystemInformation_used = (SYSTEM_REF_TRACE_INFORMATION*)&SystemInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_SystemInformation == NULL) {
		SystemInformation_used = 0;
	}
	else {
		SystemInformationLength = sizeof(_SYSTEM_REF_TRACE_INFORMATION);
	}

	ret_value = __syscall64(syscall_idx, 4, SystemInformationClass, SystemInformation_used, SystemInformationLength, ReturnLength); // NtQuerySystemInformation_SystemRefTraceInformation

	if (NT_SUCCESS(ret_value) && SystemInformation_used != NULL) {
		convert__SYSTEM_REF_TRACE_INFORMATION_64TO32(ctx, (_SYSTEM_REF_TRACE_INFORMATION*)SystemInformation_used, x32based_SystemInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemProcessIdInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_PROCESS_ID_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_PROCESS_ID_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SystemInformation_holder[sizeof(_SYSTEM_PROCESS_ID_INFORMATION)];
	SYSTEM_PROCESS_ID_INFORMATION* SystemInformation_used = (SYSTEM_PROCESS_ID_INFORMATION*)&SystemInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_SystemInformation == NULL) {
		SystemInformation_used = 0;
	}
	else {
		SystemInformationLength = sizeof(_SYSTEM_PROCESS_ID_INFORMATION);
	}

	ret_value = __syscall64(syscall_idx, 4, SystemInformationClass, SystemInformation_used, SystemInformationLength, ReturnLength); // NtQuerySystemInformation_SystemProcessIdInformation

	if (NT_SUCCESS(ret_value) && SystemInformation_used != NULL) {
		convert__SYSTEM_PROCESS_ID_INFORMATION_64TO32(ctx, (_SYSTEM_PROCESS_ID_INFORMATION*)SystemInformation_used, x32based_SystemInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemVerifierInformationEx(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_VERIFIER_INFORMATION_EX* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_VERIFIER_INFORMATION_EX *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SystemInformation_holder[sizeof(_SYSTEM_VERIFIER_INFORMATION_EX)];
	SYSTEM_VERIFIER_INFORMATION_EX* SystemInformation_used = (SYSTEM_VERIFIER_INFORMATION_EX*)&SystemInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_SystemInformation == NULL) {
		SystemInformation_used = 0;
	}
	else {
		SystemInformationLength = sizeof(_SYSTEM_VERIFIER_INFORMATION_EX);
	}

	ret_value = __syscall64(syscall_idx, 4, SystemInformationClass, SystemInformation_used, SystemInformationLength, ReturnLength); // NtQuerySystemInformation_SystemVerifierInformationEx

	if (NT_SUCCESS(ret_value) && SystemInformation_used != NULL) {
		convert__SYSTEM_VERIFIER_INFORMATION_EX_64TO32(ctx, (_SYSTEM_VERIFIER_INFORMATION_EX*)SystemInformation_used, x32based_SystemInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemSystemPartitionInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_SYSTEM_PARTITION_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_SYSTEM_PARTITION_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SystemInformation_holder[sizeof(_SYSTEM_SYSTEM_PARTITION_INFORMATION)];
	SYSTEM_SYSTEM_PARTITION_INFORMATION* SystemInformation_used = (SYSTEM_SYSTEM_PARTITION_INFORMATION*)&SystemInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_SystemInformation == NULL) {
		SystemInformation_used = 0;
	}
	else {
		SystemInformationLength = sizeof(_SYSTEM_SYSTEM_PARTITION_INFORMATION);
	}

	ret_value = __syscall64(syscall_idx, 4, SystemInformationClass, SystemInformation_used, SystemInformationLength, ReturnLength); // NtQuerySystemInformation_SystemSystemPartitionInformation

	if (NT_SUCCESS(ret_value) && SystemInformation_used != NULL) {
		convert__SYSTEM_SYSTEM_PARTITION_INFORMATION_64TO32(ctx, (_SYSTEM_SYSTEM_PARTITION_INFORMATION*)SystemInformation_used, x32based_SystemInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemSystemDiskInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_SYSTEM_DISK_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_SYSTEM_DISK_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SystemInformation_holder[sizeof(_SYSTEM_SYSTEM_DISK_INFORMATION)];
	SYSTEM_SYSTEM_DISK_INFORMATION* SystemInformation_used = (SYSTEM_SYSTEM_DISK_INFORMATION*)&SystemInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_SystemInformation == NULL) {
		SystemInformation_used = 0;
	}
	else {
		SystemInformationLength = sizeof(_SYSTEM_SYSTEM_DISK_INFORMATION);
	}

	ret_value = __syscall64(syscall_idx, 4, SystemInformationClass, SystemInformation_used, SystemInformationLength, ReturnLength); // NtQuerySystemInformation_SystemSystemDiskInformation

	if (NT_SUCCESS(ret_value) && SystemInformation_used != NULL) {
		convert__SYSTEM_SYSTEM_DISK_INFORMATION_64TO32(ctx, (_SYSTEM_SYSTEM_DISK_INFORMATION*)SystemInformation_used, x32based_SystemInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemPagedPoolInformationEx(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_FILECACHE_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_FILECACHE_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SystemInformation_holder[sizeof(_SYSTEM_FILECACHE_INFORMATION)];
	SYSTEM_FILECACHE_INFORMATION* SystemInformation_used = (SYSTEM_FILECACHE_INFORMATION*)&SystemInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_SystemInformation == NULL) {
		SystemInformation_used = 0;
	}
	else {
		SystemInformationLength = sizeof(_SYSTEM_FILECACHE_INFORMATION);
	}

	ret_value = __syscall64(syscall_idx, 4, SystemInformationClass, SystemInformation_used, SystemInformationLength, ReturnLength); // NtQuerySystemInformation_SystemPagedPoolInformationEx

	if (NT_SUCCESS(ret_value) && SystemInformation_used != NULL) {
		convert__SYSTEM_FILECACHE_INFORMATION_64TO32(ctx, (_SYSTEM_FILECACHE_INFORMATION*)SystemInformation_used, x32based_SystemInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemSystemPtesInformationEx(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_FILECACHE_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_FILECACHE_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SystemInformation_holder[sizeof(_SYSTEM_FILECACHE_INFORMATION)];
	SYSTEM_FILECACHE_INFORMATION* SystemInformation_used = (SYSTEM_FILECACHE_INFORMATION*)&SystemInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_SystemInformation == NULL) {
		SystemInformation_used = 0;
	}
	else {
		SystemInformationLength = sizeof(_SYSTEM_FILECACHE_INFORMATION);
	}

	ret_value = __syscall64(syscall_idx, 4, SystemInformationClass, SystemInformation_used, SystemInformationLength, ReturnLength); // NtQuerySystemInformation_SystemSystemPtesInformationEx

	if (NT_SUCCESS(ret_value) && SystemInformation_used != NULL) {
		convert__SYSTEM_FILECACHE_INFORMATION_64TO32(ctx, (_SYSTEM_FILECACHE_INFORMATION*)SystemInformation_used, x32based_SystemInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemBasicPerformanceInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_BASIC_PERFORMANCE_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_BASIC_PERFORMANCE_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SystemInformation_holder[sizeof(_SYSTEM_BASIC_PERFORMANCE_INFORMATION)];
	SYSTEM_BASIC_PERFORMANCE_INFORMATION* SystemInformation_used = (SYSTEM_BASIC_PERFORMANCE_INFORMATION*)&SystemInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_SystemInformation == NULL) {
		SystemInformation_used = 0;
	}
	else {
		SystemInformationLength = sizeof(_SYSTEM_BASIC_PERFORMANCE_INFORMATION);
	}

	ret_value = __syscall64(syscall_idx, 4, SystemInformationClass, SystemInformation_used, SystemInformationLength, ReturnLength); // NtQuerySystemInformation_SystemBasicPerformanceInformation

	if (NT_SUCCESS(ret_value) && SystemInformation_used != NULL) {
		convert__SYSTEM_BASIC_PERFORMANCE_INFORMATION_64TO32(ctx, (_SYSTEM_BASIC_PERFORMANCE_INFORMATION*)SystemInformation_used, x32based_SystemInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemPolicyInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_POLICY_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_POLICY_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SystemInformation_holder[sizeof(_SYSTEM_POLICY_INFORMATION)];
	SYSTEM_POLICY_INFORMATION* SystemInformation_used = (SYSTEM_POLICY_INFORMATION*)&SystemInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_SystemInformation == NULL) {
		SystemInformation_used = 0;
	}
	else {
		SystemInformationLength = sizeof(_SYSTEM_POLICY_INFORMATION);
	}

	ret_value = __syscall64(syscall_idx, 4, SystemInformationClass, SystemInformation_used, SystemInformationLength, ReturnLength); // NtQuerySystemInformation_SystemPolicyInformation

	if (NT_SUCCESS(ret_value) && SystemInformation_used != NULL) {
		convert__SYSTEM_POLICY_INFORMATION_64TO32(ctx, (_SYSTEM_POLICY_INFORMATION*)SystemInformation_used, x32based_SystemInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemManufacturingInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_MANUFACTURING_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_MANUFACTURING_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SystemInformation_holder[sizeof(_SYSTEM_MANUFACTURING_INFORMATION)];
	SYSTEM_MANUFACTURING_INFORMATION* SystemInformation_used = (SYSTEM_MANUFACTURING_INFORMATION*)&SystemInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_SystemInformation == NULL) {
		SystemInformation_used = 0;
	}
	else {
		SystemInformationLength = sizeof(_SYSTEM_MANUFACTURING_INFORMATION);
	}

	ret_value = __syscall64(syscall_idx, 4, SystemInformationClass, SystemInformation_used, SystemInformationLength, ReturnLength); // NtQuerySystemInformation_SystemManufacturingInformation

	if (NT_SUCCESS(ret_value) && SystemInformation_used != NULL) {
		convert__SYSTEM_MANUFACTURING_INFORMATION_64TO32(ctx, (_SYSTEM_MANUFACTURING_INFORMATION*)SystemInformation_used, x32based_SystemInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemActivityModerationUserSettings(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SystemInformation_holder[sizeof(_SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS)];
	SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS* SystemInformation_used = (SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS*)&SystemInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_SystemInformation == NULL) {
		SystemInformation_used = 0;
	}
	else {
		SystemInformationLength = sizeof(_SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS);
	}

	ret_value = __syscall64(syscall_idx, 4, SystemInformationClass, SystemInformation_used, SystemInformationLength, ReturnLength); // NtQuerySystemInformation_SystemActivityModerationUserSettings

	if (NT_SUCCESS(ret_value) && SystemInformation_used != NULL) {
		convert__SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS_64TO32(ctx, (_SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS*)SystemInformation_used, x32based_SystemInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQuerySystemInformation_SystemHypervisorSharedPageInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Out_ SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SystemInformation_holder[sizeof(_SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION)];
	SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION* SystemInformation_used = (SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION*)&SystemInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_SystemInformation == NULL) {
		SystemInformation_used = 0;
	}
	else {
		SystemInformationLength = sizeof(_SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION);
	}

	ret_value = __syscall64(syscall_idx, 4, SystemInformationClass, SystemInformation_used, SystemInformationLength, ReturnLength); // NtQuerySystemInformation_SystemHypervisorSharedPageInformation

	if (NT_SUCCESS(ret_value) && SystemInformation_used != NULL) {
		convert__SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION_64TO32(ctx, (_SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION*)SystemInformation_used, x32based_SystemInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQuerySystemInformationEx_SystemLogicalProcessorInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _In_ SYSTEM_LOGICAL_PROCESSOR_INFORMATION* InputBuffer, _In_ ULONG InputBufferLength, _Out_ PVOID SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_InputBuffer = (uint32_t)(InputBuffer); // SYSTEM_LOGICAL_PROCESSOR_INFORMATION *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t InputBuffer_holder[sizeof(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION)];
	SYSTEM_LOGICAL_PROCESSOR_INFORMATION* InputBuffer_used = (SYSTEM_LOGICAL_PROCESSOR_INFORMATION*)&InputBuffer_holder;

	// Convert parameters from x32 to x64
	if (x32based_InputBuffer != NULL) {
		convert__SYSTEM_LOGICAL_PROCESSOR_INFORMATION_32TO64(ctx, (_SYSTEM_LOGICAL_PROCESSOR_INFORMATION**)&InputBuffer_used, x32based_InputBuffer);

	}
	else {
		InputBuffer_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 6, SystemInformationClass, InputBuffer_used, InputBufferLength, SystemInformation, SystemInformationLength, ReturnLength); // NtQuerySystemInformationEx_SystemLogicalProcessorInformation

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQuerySystemInformationEx_SystemLogicalProcessorAndGroupInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _In_ SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX* InputBuffer, _In_ ULONG InputBufferLength, _Out_ PVOID SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_InputBuffer = (uint32_t)(InputBuffer); // SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t InputBuffer_holder[sizeof(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX)];
	SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX* InputBuffer_used = (SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX*)&InputBuffer_holder;

	// Convert parameters from x32 to x64
	if (x32based_InputBuffer != NULL) {
		convert__SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX_32TO64(ctx, (_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX**)&InputBuffer_used, x32based_InputBuffer);
	}
	else {
		InputBuffer_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 6, SystemInformationClass, InputBuffer_used, InputBufferLength, SystemInformation, SystemInformationLength, ReturnLength); // NtQuerySystemInformationEx_SystemLogicalProcessorAndGroupInformation

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQuerySystemInformationEx_SystemFeatureConfigurationInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _In_ SYSTEM_FEATURE_CONFIGURATION_INFORMATION* InputBuffer, _In_ ULONG InputBufferLength, _Out_ PVOID SystemInformation, _In_ ULONG SystemInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_InputBuffer = (uint32_t)(InputBuffer); // SYSTEM_FEATURE_CONFIGURATION_INFORMATION *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t InputBuffer_holder[sizeof(_SYSTEM_FEATURE_CONFIGURATION_INFORMATION)];
	SYSTEM_FEATURE_CONFIGURATION_INFORMATION* InputBuffer_used = (SYSTEM_FEATURE_CONFIGURATION_INFORMATION*)&InputBuffer_holder;

	// Convert parameters from x32 to x64
	if (x32based_InputBuffer != NULL) {
		convert__SYSTEM_FEATURE_CONFIGURATION_INFORMATION_32TO64(ctx, (_SYSTEM_FEATURE_CONFIGURATION_INFORMATION**)&InputBuffer_used, x32based_InputBuffer);
	}
	else {
		InputBuffer_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 6, SystemInformationClass, InputBuffer_used, InputBufferLength, SystemInformation, SystemInformationLength, ReturnLength); // NtQuerySystemInformationEx_SystemFeatureConfigurationInformation

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtSetSystemInformation_SystemPagedPoolInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _In_ SYSTEM_POOL_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_POOL_INFORMATION *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SystemInformation_holder[sizeof(_SYSTEM_POOL_INFORMATION)];
	SYSTEM_POOL_INFORMATION* SystemInformation_used = (SYSTEM_POOL_INFORMATION*)&SystemInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_SystemInformation != NULL) {
		convert__SYSTEM_POOL_INFORMATION_32TO64(ctx, (_SYSTEM_POOL_INFORMATION**)&SystemInformation_used, x32based_SystemInformation);
		SystemInformationLength = sizeof(_SYSTEM_POOL_INFORMATION);
	}
	else {
		SystemInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, SystemInformationClass, SystemInformation_used, SystemInformationLength); // NtSetSystemInformation_SystemPagedPoolInformation

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtSetSystemInformation_SystemRegistryQuotaInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _In_ SYSTEM_REGISTRY_QUOTA_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_REGISTRY_QUOTA_INFORMATION *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SystemInformation_holder[sizeof(_SYSTEM_REGISTRY_QUOTA_INFORMATION)];
	SYSTEM_REGISTRY_QUOTA_INFORMATION* SystemInformation_used = (SYSTEM_REGISTRY_QUOTA_INFORMATION*)&SystemInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_SystemInformation != NULL) {
		convert__SYSTEM_REGISTRY_QUOTA_INFORMATION_32TO64(ctx, (_SYSTEM_REGISTRY_QUOTA_INFORMATION**)&SystemInformation_used, x32based_SystemInformation);
		SystemInformationLength = sizeof(_SYSTEM_REGISTRY_QUOTA_INFORMATION);
	}
	else {
		SystemInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, SystemInformationClass, SystemInformation_used, SystemInformationLength); // NtSetSystemInformation_SystemRegistryQuotaInformation

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtSetSystemInformation_SystemExtendServiceTableInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _In_ UNICODE_STRING* SystemInformation, _In_ ULONG SystemInformationLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // UNICODE_STRING *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SystemInformation_holder[sizeof(_UNICODE_STRING)];
	UNICODE_STRING* SystemInformation_used = (UNICODE_STRING*)&SystemInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_SystemInformation != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&SystemInformation_used, x32based_SystemInformation);
		SystemInformationLength = sizeof(_UNICODE_STRING);
	}
	else {
		SystemInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, SystemInformationClass, SystemInformation_used, SystemInformationLength); // NtSetSystemInformation_SystemExtendServiceTableInformation

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtSetSystemInformation_SystemVerifierInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _In_ SYSTEM_VERIFIER_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_VERIFIER_INFORMATION *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SystemInformation_holder[sizeof(_SYSTEM_VERIFIER_INFORMATION)];
	SYSTEM_VERIFIER_INFORMATION* SystemInformation_used = (SYSTEM_VERIFIER_INFORMATION*)&SystemInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_SystemInformation != NULL) {
		convert__SYSTEM_VERIFIER_INFORMATION_32TO64(ctx, (_SYSTEM_VERIFIER_INFORMATION**)&SystemInformation_used, x32based_SystemInformation);
		SystemInformationLength = sizeof(_SYSTEM_VERIFIER_INFORMATION);
	}
	else {
		SystemInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, SystemInformationClass, SystemInformation_used, SystemInformationLength); // NtSetSystemInformation_SystemVerifierInformation

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtSetSystemInformation_SystemThreadPriorityClientIdInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _In_ SYSTEM_THREAD_CID_PRIORITY_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_THREAD_CID_PRIORITY_INFORMATION *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SystemInformation_holder[sizeof(_SYSTEM_THREAD_CID_PRIORITY_INFORMATION)];
	SYSTEM_THREAD_CID_PRIORITY_INFORMATION* SystemInformation_used = (SYSTEM_THREAD_CID_PRIORITY_INFORMATION*)&SystemInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_SystemInformation != NULL) {
		convert__SYSTEM_THREAD_CID_PRIORITY_INFORMATION_32TO64(ctx, (_SYSTEM_THREAD_CID_PRIORITY_INFORMATION**)&SystemInformation_used, x32based_SystemInformation);
		SystemInformationLength = sizeof(_SYSTEM_THREAD_CID_PRIORITY_INFORMATION);
	}
	else {
		SystemInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, SystemInformationClass, SystemInformation_used, SystemInformationLength); // NtSetSystemInformation_SystemThreadPriorityClientIdInformation

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtSetSystemInformation_SystemRefTraceInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _In_ SYSTEM_REF_TRACE_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_REF_TRACE_INFORMATION *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SystemInformation_holder[sizeof(_SYSTEM_REF_TRACE_INFORMATION)];
	SYSTEM_REF_TRACE_INFORMATION* SystemInformation_used = (SYSTEM_REF_TRACE_INFORMATION*)&SystemInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_SystemInformation != NULL) {
		convert__SYSTEM_REF_TRACE_INFORMATION_32TO64(ctx, (_SYSTEM_REF_TRACE_INFORMATION**)&SystemInformation_used, x32based_SystemInformation);
		SystemInformationLength = sizeof(_SYSTEM_REF_TRACE_INFORMATION);
	}
	else {
		SystemInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, SystemInformationClass, SystemInformation_used, SystemInformationLength); // NtSetSystemInformation_SystemRefTraceInformation

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtSetSystemInformation_SystemVerifierInformationEx(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _In_ SYSTEM_VERIFIER_INFORMATION_EX* SystemInformation, _In_ ULONG SystemInformationLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_VERIFIER_INFORMATION_EX *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SystemInformation_holder[sizeof(_SYSTEM_VERIFIER_INFORMATION_EX)];
	SYSTEM_VERIFIER_INFORMATION_EX* SystemInformation_used = (SYSTEM_VERIFIER_INFORMATION_EX*)&SystemInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_SystemInformation != NULL) {
		convert__SYSTEM_VERIFIER_INFORMATION_EX_32TO64(ctx, (_SYSTEM_VERIFIER_INFORMATION_EX**)&SystemInformation_used, x32based_SystemInformation);
		SystemInformationLength = sizeof(_SYSTEM_VERIFIER_INFORMATION_EX);
	}
	else {
		SystemInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, SystemInformationClass, SystemInformation_used, SystemInformationLength); // NtSetSystemInformation_SystemVerifierInformationEx

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtSetSystemInformation_SystemVerifierFaultsInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _In_ SYSTEM_VERIFIER_FAULTS_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_VERIFIER_FAULTS_INFORMATION *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SystemInformation_holder[sizeof(_SYSTEM_VERIFIER_FAULTS_INFORMATION)];
	SYSTEM_VERIFIER_FAULTS_INFORMATION* SystemInformation_used = (SYSTEM_VERIFIER_FAULTS_INFORMATION*)&SystemInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_SystemInformation != NULL) {
		convert__SYSTEM_VERIFIER_FAULTS_INFORMATION_32TO64(ctx, (_SYSTEM_VERIFIER_FAULTS_INFORMATION**)&SystemInformation_used, x32based_SystemInformation);
		SystemInformationLength = sizeof(_SYSTEM_VERIFIER_FAULTS_INFORMATION);
	}
	else {
		SystemInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, SystemInformationClass, SystemInformation_used, SystemInformationLength); // NtSetSystemInformation_SystemVerifierFaultsInformation

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtSetSystemInformation_SystemRegistryAppendString(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _In_ SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS* SystemInformation, _In_ ULONG SystemInformationLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SystemInformation_holder[sizeof(_SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS)];
	SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS* SystemInformation_used = (SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS*)&SystemInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_SystemInformation != NULL) {
		convert__SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS_32TO64(ctx, (_SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS**)&SystemInformation_used, x32based_SystemInformation);
		SystemInformationLength = sizeof(_SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS);
	}
	else {
		SystemInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, SystemInformationClass, SystemInformation_used, SystemInformationLength); // NtSetSystemInformation_SystemRegistryAppendString

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtSetSystemInformation_SystemPagedPoolInformationEx(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _In_ SYSTEM_FILECACHE_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_FILECACHE_INFORMATION *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SystemInformation_holder[sizeof(_SYSTEM_FILECACHE_INFORMATION)];
	SYSTEM_FILECACHE_INFORMATION* SystemInformation_used = (SYSTEM_FILECACHE_INFORMATION*)&SystemInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_SystemInformation != NULL) {
		convert__SYSTEM_FILECACHE_INFORMATION_32TO64(ctx, (_SYSTEM_FILECACHE_INFORMATION**)&SystemInformation_used, x32based_SystemInformation);
		SystemInformationLength = sizeof(_SYSTEM_FILECACHE_INFORMATION);
	}
	else {
		SystemInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, SystemInformationClass, SystemInformation_used, SystemInformationLength); // NtSetSystemInformation_SystemPagedPoolInformationEx

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtSetSystemInformation_SystemPolicyInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _In_ SYSTEM_POLICY_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_POLICY_INFORMATION *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SystemInformation_holder[sizeof(_SYSTEM_POLICY_INFORMATION)];
	SYSTEM_POLICY_INFORMATION* SystemInformation_used = (SYSTEM_POLICY_INFORMATION*)&SystemInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_SystemInformation != NULL) {
		convert__SYSTEM_POLICY_INFORMATION_32TO64(ctx, (_SYSTEM_POLICY_INFORMATION**)&SystemInformation_used, x32based_SystemInformation);
		SystemInformationLength = sizeof(_SYSTEM_POLICY_INFORMATION);
	}
	else {
		SystemInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, SystemInformationClass, SystemInformation_used, SystemInformationLength); // NtSetSystemInformation_SystemPolicyInformation

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtSetSystemInformation_SystemElamCertificateInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _In_ SYSTEM_ELAM_CERTIFICATE_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_ELAM_CERTIFICATE_INFORMATION *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SystemInformation_holder[sizeof(_SYSTEM_ELAM_CERTIFICATE_INFORMATION)];
	SYSTEM_ELAM_CERTIFICATE_INFORMATION* SystemInformation_used = (SYSTEM_ELAM_CERTIFICATE_INFORMATION*)&SystemInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_SystemInformation != NULL) {
		convert__SYSTEM_ELAM_CERTIFICATE_INFORMATION_32TO64(ctx, (_SYSTEM_ELAM_CERTIFICATE_INFORMATION**)&SystemInformation_used, x32based_SystemInformation);
	}
	else {
		SystemInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, SystemInformationClass, SystemInformation_used, SystemInformationLength); // NtSetSystemInformation_SystemElamCertificateInformation

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtSetSystemInformation_SystemActivityModerationExeState(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _In_ SYSTEM_ACTIVITY_MODERATION_EXE_STATE* SystemInformation, _In_ ULONG SystemInformationLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_ACTIVITY_MODERATION_EXE_STATE *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SystemInformation_holder[sizeof(_SYSTEM_ACTIVITY_MODERATION_EXE_STATE)];
	SYSTEM_ACTIVITY_MODERATION_EXE_STATE* SystemInformation_used = (SYSTEM_ACTIVITY_MODERATION_EXE_STATE*)&SystemInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_SystemInformation != NULL) {
		convert__SYSTEM_ACTIVITY_MODERATION_EXE_STATE_32TO64(ctx, (_SYSTEM_ACTIVITY_MODERATION_EXE_STATE**)&SystemInformation_used, x32based_SystemInformation);
	}
	else {
		SystemInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, SystemInformationClass, SystemInformation_used, SystemInformationLength); // NtSetSystemInformation_SystemActivityModerationExeState

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtSetSystemInformation_SystemFeatureConfigurationInformation(void* ctx, uint32_t syscall_idx, _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _In_ SYSTEM_FEATURE_CONFIGURATION_INFORMATION* SystemInformation, _In_ ULONG SystemInformationLength) {

	// Declare parameters from stack
	uint32_t x32based_SystemInformation = (uint32_t)(SystemInformation); // SYSTEM_FEATURE_CONFIGURATION_INFORMATION *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SystemInformation_holder[sizeof(_SYSTEM_FEATURE_CONFIGURATION_INFORMATION)];
	SYSTEM_FEATURE_CONFIGURATION_INFORMATION* SystemInformation_used = (SYSTEM_FEATURE_CONFIGURATION_INFORMATION*)&SystemInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_SystemInformation != NULL) {
		convert__SYSTEM_FEATURE_CONFIGURATION_INFORMATION_32TO64(ctx, (_SYSTEM_FEATURE_CONFIGURATION_INFORMATION**)&SystemInformation_used, x32based_SystemInformation);
	}
	else {
		SystemInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, SystemInformationClass, SystemInformation_used, SystemInformationLength); // NtSetSystemInformation_SystemFeatureConfigurationInformation

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQueryVirtualMemory_MemoryBasicInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PVOID BaseAddress, _In_ MEMORY_INFORMATION_CLASS MemoryInformationClass, _Out_ MEMORY_BASIC_INFORMATION* MemoryInformation, _In_ SIZE_T MemoryInformationLength, _Out_ PSIZE_T ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_MemoryInformation = (uint32_t)(MemoryInformation); // MEMORY_BASIC_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t MemoryInformation_holder[sizeof(_MEMORY_BASIC_INFORMATION)];
	MEMORY_BASIC_INFORMATION* MemoryInformation_used = (MEMORY_BASIC_INFORMATION*)&MemoryInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_MemoryInformation == NULL) {
		MemoryInformation_used = 0;
	}
	else {
		MemoryInformationLength = sizeof(_MEMORY_BASIC_INFORMATION);
	}

	ret_value = __syscall64(syscall_idx, 6, ProcessHandle, BaseAddress, MemoryInformationClass, MemoryInformation_used, MemoryInformationLength, ReturnLength); // NtQueryVirtualMemory_MemoryBasicInformation

	if (NT_SUCCESS(ret_value) && MemoryInformation_used != NULL) {
		convert__MEMORY_BASIC_INFORMATION_64TO32(ctx, (_MEMORY_BASIC_INFORMATION*)MemoryInformation_used, x32based_MemoryInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQueryVirtualMemory_MemoryWorkingSetInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PVOID BaseAddress, _In_ MEMORY_INFORMATION_CLASS MemoryInformationClass, _Out_ MEMORY_WORKING_SET_INFORMATION* MemoryInformation, _In_ SIZE_T MemoryInformationLength, _Out_ PSIZE_T ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_MemoryInformation = (uint32_t)(MemoryInformation); // MEMORY_WORKING_SET_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t MemoryInformation_holder[sizeof(_MEMORY_WORKING_SET_INFORMATION)];
	MEMORY_WORKING_SET_INFORMATION* MemoryInformation_used = (MEMORY_WORKING_SET_INFORMATION*)&MemoryInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_MemoryInformation == NULL) {
		MemoryInformation_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 6, ProcessHandle, BaseAddress, MemoryInformationClass, MemoryInformation_used, MemoryInformationLength, ReturnLength); // NtQueryVirtualMemory_MemoryWorkingSetInformation

	if (NT_SUCCESS(ret_value) && MemoryInformation_used != NULL) {
		convert__MEMORY_WORKING_SET_INFORMATION_64TO32(ctx, (_MEMORY_WORKING_SET_INFORMATION*)MemoryInformation_used, x32based_MemoryInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQueryVirtualMemory_MemoryMappedFilenameInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PVOID BaseAddress, _In_ MEMORY_INFORMATION_CLASS MemoryInformationClass, _Out_ UNICODE_STRING* MemoryInformation, _In_ SIZE_T MemoryInformationLength, _Out_ PSIZE_T ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_MemoryInformation = (uint32_t)(MemoryInformation); // UNICODE_STRING *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	UNICODE_STRING* MemoryInformation_used = 0;

	if (x32based_MemoryInformation != NULL && MemoryInformationLength != 0) {
		MemoryInformation_used = (UNICODE_STRING*)intrnl__ntcallmalloc(ctx, MemoryInformationLength);
	}

	// Convert parameters from x32 to x64

	ret_value = __syscall64(syscall_idx, 6, ProcessHandle, BaseAddress, MemoryInformationClass, MemoryInformation_used, MemoryInformationLength, ReturnLength); // NtQueryVirtualMemory_MemoryMappedFilenameInformation

	if (NT_SUCCESS(ret_value) && MemoryInformation_used != NULL) {
		CVT_UNICODE_STRING_OFFSETABLE_FUNC64TO32(MemoryInformation_used, x32based_MemoryInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQueryVirtualMemory_MemoryRegionInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PVOID BaseAddress, _In_ MEMORY_INFORMATION_CLASS MemoryInformationClass, _Out_ MEMORY_REGION_INFORMATION* MemoryInformation, _In_ SIZE_T MemoryInformationLength, _Out_ PSIZE_T ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_MemoryInformation = (uint32_t)(MemoryInformation); // MEMORY_REGION_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t MemoryInformation_holder[sizeof(_MEMORY_REGION_INFORMATION)];
	MEMORY_REGION_INFORMATION* MemoryInformation_used = (MEMORY_REGION_INFORMATION*)&MemoryInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_MemoryInformation == NULL) {
		MemoryInformation_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 6, ProcessHandle, BaseAddress, MemoryInformationClass, MemoryInformation_used, MemoryInformationLength, ReturnLength); // NtQueryVirtualMemory_MemoryRegionInformation

	if (NT_SUCCESS(ret_value) && MemoryInformation_used != NULL) {
		convert__MEMORY_REGION_INFORMATION_64TO32(ctx, (_MEMORY_REGION_INFORMATION*)MemoryInformation_used, x32based_MemoryInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQueryVirtualMemory_MemoryWorkingSetExInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PVOID BaseAddress, _In_ MEMORY_INFORMATION_CLASS MemoryInformationClass, _Out_ MEMORY_WORKING_SET_EX_INFORMATION* MemoryInformation, _In_ SIZE_T MemoryInformationLength, _Out_ PSIZE_T ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_MemoryInformation = (uint32_t)(MemoryInformation); // MEMORY_WORKING_SET_EX_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t MemoryInformation_holder[sizeof(_MEMORY_WORKING_SET_EX_INFORMATION)];
	MEMORY_WORKING_SET_EX_INFORMATION* MemoryInformation_used = (MEMORY_WORKING_SET_EX_INFORMATION*)&MemoryInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_MemoryInformation == NULL) {
		MemoryInformation_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 6, ProcessHandle, BaseAddress, MemoryInformationClass, MemoryInformation_used, MemoryInformationLength, ReturnLength); // NtQueryVirtualMemory_MemoryWorkingSetExInformation

	if (NT_SUCCESS(ret_value) && MemoryInformation_used != NULL) {
		convert__MEMORY_WORKING_SET_EX_INFORMATION_64TO32(ctx, (_MEMORY_WORKING_SET_EX_INFORMATION*)MemoryInformation_used, x32based_MemoryInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQueryVirtualMemory_MemoryRegionInformationEx(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PVOID BaseAddress, _In_ MEMORY_INFORMATION_CLASS MemoryInformationClass, _Out_ MEMORY_REGION_INFORMATION* MemoryInformation, _In_ SIZE_T MemoryInformationLength, _Out_ PSIZE_T ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_MemoryInformation = (uint32_t)(MemoryInformation); // MEMORY_REGION_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t MemoryInformation_holder[sizeof(_MEMORY_REGION_INFORMATION)];
	MEMORY_REGION_INFORMATION* MemoryInformation_used = (MEMORY_REGION_INFORMATION*)&MemoryInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_MemoryInformation == NULL) {
		MemoryInformation_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 6, ProcessHandle, BaseAddress, MemoryInformationClass, MemoryInformation_used, MemoryInformationLength, ReturnLength); // NtQueryVirtualMemory_MemoryRegionInformationEx

	if (NT_SUCCESS(ret_value) && MemoryInformation_used != NULL) {
		convert__MEMORY_REGION_INFORMATION_64TO32(ctx, (_MEMORY_REGION_INFORMATION*)MemoryInformation_used, x32based_MemoryInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQuerySection_SectionBasicInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE SectionHandle, _In_ SECTION_INFORMATION_CLASS SectionInformationClass, _Out_ SECTION_BASIC_INFORMATION* SectionInformation, _In_ SIZE_T SectionInformationLength, _Out_ PSIZE_T ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_SectionInformation = (uint32_t)(SectionInformation); // SECTION_BASIC_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SectionInformation_holder[sizeof(_SECTION_BASIC_INFORMATION)];
	SECTION_BASIC_INFORMATION* SectionInformation_used = (SECTION_BASIC_INFORMATION*)&SectionInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_SectionInformation == NULL) {
		SectionInformation_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 5, SectionHandle, SectionInformationClass, SectionInformation_used, SectionInformationLength, ReturnLength); // NtQuerySection_SectionBasicInformation

	if (NT_SUCCESS(ret_value) && SectionInformation_used != NULL) {
		convert__SECTION_BASIC_INFORMATION_64TO32(ctx, (_SECTION_BASIC_INFORMATION*)SectionInformation_used, x32based_SectionInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQuerySection_SectionImageInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE SectionHandle, _In_ SECTION_INFORMATION_CLASS SectionInformationClass, _Out_ SECTION_IMAGE_INFORMATION* SectionInformation, _In_ SIZE_T SectionInformationLength, _Out_ PSIZE_T ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_SectionInformation = (uint32_t)(SectionInformation); // SECTION_IMAGE_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SectionInformation_holder[sizeof(_SECTION_IMAGE_INFORMATION)];
	SECTION_IMAGE_INFORMATION* SectionInformation_used = (SECTION_IMAGE_INFORMATION*)&SectionInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_SectionInformation == NULL) {
		SectionInformation_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 5, SectionHandle, SectionInformationClass, SectionInformation_used, SectionInformationLength, ReturnLength); // NtQuerySection_SectionImageInformation

	if (NT_SUCCESS(ret_value) && SectionInformation_used != NULL) {
		convert__SECTION_IMAGE_INFORMATION_64TO32(ctx, (_SECTION_IMAGE_INFORMATION*)SectionInformation_used, x32based_SectionInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQueryObject_ObjectNameInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE Handle, _In_ OBJECT_INFORMATION_CLASS ObjectInformationClass, _Out_ OBJECT_NAME_INFORMATION* ObjectInformation, _In_ ULONG ObjectInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_ObjectInformation = (uint32_t)(ObjectInformation); // OBJECT_NAME_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ObjectInformation_holder[sizeof(_OBJECT_NAME_INFORMATION)];
	OBJECT_NAME_INFORMATION* ObjectInformation_used = (OBJECT_NAME_INFORMATION*)&ObjectInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_ObjectInformation == NULL) {
		ObjectInformation_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 5, Handle, ObjectInformationClass, ObjectInformation_used, ObjectInformationLength, ReturnLength); // NtQueryObject_ObjectNameInformation

	if (NT_SUCCESS(ret_value) && ObjectInformation_used != NULL) {
		convert__OBJECT_NAME_INFORMATION_64TO32(ctx, (_OBJECT_NAME_INFORMATION*)ObjectInformation_used, x32based_ObjectInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQueryObject_ObjectTypeInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE Handle, _In_ OBJECT_INFORMATION_CLASS ObjectInformationClass, _Out_ OBJECT_TYPE_INFORMATION* ObjectInformation, _In_ ULONG ObjectInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_ObjectInformation = (uint32_t)(ObjectInformation); // OBJECT_TYPE_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ObjectInformation_holder[sizeof(_OBJECT_TYPE_INFORMATION)];
	OBJECT_TYPE_INFORMATION* ObjectInformation_used = (OBJECT_TYPE_INFORMATION*)&ObjectInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_ObjectInformation == NULL) {
		ObjectInformation_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 5, Handle, ObjectInformationClass, ObjectInformation_used, ObjectInformationLength, ReturnLength); // NtQueryObject_ObjectTypeInformation

	if (NT_SUCCESS(ret_value) && ObjectInformation_used != NULL) {
		convert__OBJECT_TYPE_INFORMATION_64TO32(ctx, (_OBJECT_TYPE_INFORMATION*)ObjectInformation_used, x32based_ObjectInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQueryInformationProcess_ProcessBasicInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _Out_ PROCESS_BASIC_INFORMATION* ProcessInformation, _In_ ULONG ProcessInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_ProcessInformation = (uint32_t)(ProcessInformation); // PROCESS_BASIC_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ProcessInformation_holder[sizeof(_PROCESS_BASIC_INFORMATION)];
	PROCESS_BASIC_INFORMATION* ProcessInformation_used = (PROCESS_BASIC_INFORMATION*)&ProcessInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_ProcessInformation == NULL) {
		ProcessInformation_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 5, ProcessHandle, ProcessInformationClass, ProcessInformation_used, ProcessInformationLength, ReturnLength); // NtQueryInformationProcess_ProcessBasicInformation

	if (NT_SUCCESS(ret_value) && ProcessInformation_used != NULL) {
		convert__PROCESS_BASIC_INFORMATION_64TO32(ctx, (_PROCESS_BASIC_INFORMATION*)ProcessInformation_used, x32based_ProcessInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQueryInformationProcess_ProcessQuotaLimits(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _Out_ QUOTA_LIMITS* ProcessInformation, _In_ ULONG ProcessInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_ProcessInformation = (uint32_t)(ProcessInformation); // QUOTA_LIMITS *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ProcessInformation_holder[sizeof(_QUOTA_LIMITS)];
	QUOTA_LIMITS* ProcessInformation_used = (QUOTA_LIMITS*)&ProcessInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_ProcessInformation == NULL) {
		ProcessInformation_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 5, ProcessHandle, ProcessInformationClass, ProcessInformation_used, ProcessInformationLength, ReturnLength); // NtQueryInformationProcess_ProcessQuotaLimits

	if (NT_SUCCESS(ret_value) && ProcessInformation_used != NULL) {
		convert__QUOTA_LIMITS_64TO32(ctx, (_QUOTA_LIMITS*)ProcessInformation_used, x32based_ProcessInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQueryInformationProcess_ProcessVmCounters(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _Out_ VM_COUNTERS* ProcessInformation, _In_ ULONG ProcessInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_ProcessInformation = (uint32_t)(ProcessInformation); // VM_COUNTERS *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ProcessInformation_holder[sizeof(_VM_COUNTERS)];
	VM_COUNTERS* ProcessInformation_used = (VM_COUNTERS*)&ProcessInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_ProcessInformation == NULL) {
		ProcessInformation_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 5, ProcessHandle, ProcessInformationClass, ProcessInformation_used, ProcessInformationLength, ReturnLength); // NtQueryInformationProcess_ProcessVmCounters

	if (NT_SUCCESS(ret_value) && ProcessInformation_used != NULL) {
		convert__VM_COUNTERS_64TO32(ctx, (_VM_COUNTERS*)ProcessInformation_used, x32based_ProcessInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQueryInformationProcess_ProcessPooledUsageAndLimits(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _Out_ POOLED_USAGE_AND_LIMITS* ProcessInformation, _In_ ULONG ProcessInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_ProcessInformation = (uint32_t)(ProcessInformation); // POOLED_USAGE_AND_LIMITS *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ProcessInformation_holder[sizeof(_POOLED_USAGE_AND_LIMITS)];
	POOLED_USAGE_AND_LIMITS* ProcessInformation_used = (POOLED_USAGE_AND_LIMITS*)&ProcessInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_ProcessInformation == NULL) {
		ProcessInformation_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 5, ProcessHandle, ProcessInformationClass, ProcessInformation_used, ProcessInformationLength, ReturnLength); // NtQueryInformationProcess_ProcessPooledUsageAndLimits

	if (NT_SUCCESS(ret_value) && ProcessInformation_used != NULL) {
		convert__POOLED_USAGE_AND_LIMITS_64TO32(ctx, (_POOLED_USAGE_AND_LIMITS*)ProcessInformation_used, x32based_ProcessInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQueryInformationProcess_ProcessWorkingSetWatch(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _Out_ PROCESS_WS_WATCH_INFORMATION* ProcessInformation, _In_ ULONG ProcessInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_ProcessInformation = (uint32_t)(ProcessInformation); // PROCESS_WS_WATCH_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ProcessInformation_holder[sizeof(_PROCESS_WS_WATCH_INFORMATION)];
	PROCESS_WS_WATCH_INFORMATION* ProcessInformation_used = (PROCESS_WS_WATCH_INFORMATION*)&ProcessInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_ProcessInformation == NULL) {
		ProcessInformation_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 5, ProcessHandle, ProcessInformationClass, ProcessInformation_used, ProcessInformationLength, ReturnLength); // NtQueryInformationProcess_ProcessWorkingSetWatch

	if (NT_SUCCESS(ret_value) && ProcessInformation_used != NULL) {
		convert__PROCESS_WS_WATCH_INFORMATION_64TO32(ctx, (_PROCESS_WS_WATCH_INFORMATION*)ProcessInformation_used, x32based_ProcessInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQueryInformationProcess_ProcessDeviceMap(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _Out_ PROCESS_DEVICEMAP_INFORMATION* ProcessInformation, _In_ ULONG ProcessInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_ProcessInformation = (uint32_t)(ProcessInformation); // PROCESS_DEVICEMAP_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ProcessInformation_holder[sizeof(_PROCESS_DEVICEMAP_INFORMATION)];
	PROCESS_DEVICEMAP_INFORMATION* ProcessInformation_used = (PROCESS_DEVICEMAP_INFORMATION*)&ProcessInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_ProcessInformation == NULL) {
		ProcessInformation_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 5, ProcessHandle, ProcessInformationClass, ProcessInformation_used, ProcessInformationLength, ReturnLength); // NtQueryInformationProcess_ProcessDeviceMap

	if (NT_SUCCESS(ret_value) && ProcessInformation_used != NULL) {
		convert__PROCESS_DEVICEMAP_INFORMATION_64TO32(ctx, (_PROCESS_DEVICEMAP_INFORMATION*)ProcessInformation_used, x32based_ProcessInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQueryInformationProcess_ProcessImageFileName(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _Out_ UNICODE_STRING* ProcessInformation, _In_ ULONG ProcessInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_ProcessInformation = (uint32_t)(ProcessInformation); // UNICODE_STRING *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	UNICODE_STRING* ProcessInformation_used = 0;

	if (x32based_ProcessInformation != NULL && ProcessInformationLength != 0) {
		ProcessInformation_used = (UNICODE_STRING*)intrnl__ntcallmalloc(ctx, ProcessInformationLength);
	}

	ret_value = __syscall64(syscall_idx, 5, ProcessHandle, ProcessInformationClass, ProcessInformation_used, ProcessInformationLength, ReturnLength); // NtQueryInformationProcess_ProcessImageFileName

	if (NT_SUCCESS(ret_value) && ProcessInformation_used != NULL) {
		CVT_UNICODE_STRING_OFFSETABLE_FUNC64TO32(ProcessInformation_used, x32based_ProcessInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQueryInformationProcess_ProcessHandleTracing(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _Out_ PROCESS_HANDLE_TRACING_QUERY* ProcessInformation, _In_ ULONG ProcessInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_ProcessInformation = (uint32_t)(ProcessInformation); // PROCESS_HANDLE_TRACING_QUERY *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ProcessInformation_holder[sizeof(_PROCESS_HANDLE_TRACING_QUERY)];
	PROCESS_HANDLE_TRACING_QUERY* ProcessInformation_used = (PROCESS_HANDLE_TRACING_QUERY*)&ProcessInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_ProcessInformation == NULL) {
		ProcessInformation_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 5, ProcessHandle, ProcessInformationClass, ProcessInformation_used, ProcessInformationLength, ReturnLength); // NtQueryInformationProcess_ProcessHandleTracing

	if (NT_SUCCESS(ret_value) && ProcessInformation_used != NULL) {
		convert__PROCESS_HANDLE_TRACING_QUERY_64TO32(ctx, (_PROCESS_HANDLE_TRACING_QUERY*)ProcessInformation_used, x32based_ProcessInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQueryInformationProcess_ProcessImageInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _Out_ SECTION_IMAGE_INFORMATION* ProcessInformation, _In_ ULONG ProcessInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_ProcessInformation = (uint32_t)(ProcessInformation); // SECTION_IMAGE_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ProcessInformation_holder[sizeof(_SECTION_IMAGE_INFORMATION)];
	SECTION_IMAGE_INFORMATION* ProcessInformation_used = (SECTION_IMAGE_INFORMATION*)&ProcessInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_ProcessInformation == NULL) {
		ProcessInformation_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 5, ProcessHandle, ProcessInformationClass, ProcessInformation_used, ProcessInformationLength, ReturnLength); // NtQueryInformationProcess_ProcessImageInformation

	if (NT_SUCCESS(ret_value) && ProcessInformation_used != NULL) {
		convert__SECTION_IMAGE_INFORMATION_64TO32(ctx, (_SECTION_IMAGE_INFORMATION*)ProcessInformation_used, x32based_ProcessInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQueryInformationProcess_ProcessWorkingSetWatchEx(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _Out_ PROCESS_WS_WATCH_INFORMATION_EX* ProcessInformation, _In_ ULONG ProcessInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_ProcessInformation = (uint32_t)(ProcessInformation); // PROCESS_WS_WATCH_INFORMATION_EX *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ProcessInformation_holder[sizeof(_PROCESS_WS_WATCH_INFORMATION_EX)];
	PROCESS_WS_WATCH_INFORMATION_EX* ProcessInformation_used = (PROCESS_WS_WATCH_INFORMATION_EX*)&ProcessInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_ProcessInformation == NULL) {
		ProcessInformation_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 5, ProcessHandle, ProcessInformationClass, ProcessInformation_used, ProcessInformationLength, ReturnLength); // NtQueryInformationProcess_ProcessWorkingSetWatchEx

	if (NT_SUCCESS(ret_value) && ProcessInformation_used != NULL) {
		convert__PROCESS_WS_WATCH_INFORMATION_EX_64TO32(ctx, (_PROCESS_WS_WATCH_INFORMATION_EX*)ProcessInformation_used, x32based_ProcessInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQueryInformationProcess_ProcessImageFileNameWin32(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _Out_ UNICODE_STRING* ProcessInformation, _In_ ULONG ProcessInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_ProcessInformation = (uint32_t)(ProcessInformation); // UNICODE_STRING *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	UNICODE_STRING* ProcessInformation_used = 0;

	if (x32based_ProcessInformation != NULL && ProcessInformationLength != 0) {
		ProcessInformation_used = (UNICODE_STRING*)intrnl__ntcallmalloc(ctx, ProcessInformationLength);
	}

	ret_value = __syscall64(syscall_idx, 5, ProcessHandle, ProcessInformationClass, ProcessInformation_used, ProcessInformationLength, ReturnLength); // NtQueryInformationProcess_ProcessImageFileNameWin32

	if (NT_SUCCESS(ret_value) && ProcessInformation_used != NULL) {
		CVT_UNICODE_STRING_OFFSETABLE_FUNC64TO32(ProcessInformation_used, x32based_ProcessInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQueryInformationProcess_ProcessHandleInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _Out_ PROCESS_HANDLE_SNAPSHOT_INFORMATION* ProcessInformation, _In_ ULONG ProcessInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_ProcessInformation = (uint32_t)(ProcessInformation); // PROCESS_HANDLE_SNAPSHOT_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ProcessInformation_holder[sizeof(_PROCESS_HANDLE_SNAPSHOT_INFORMATION)];
	PROCESS_HANDLE_SNAPSHOT_INFORMATION* ProcessInformation_used = (PROCESS_HANDLE_SNAPSHOT_INFORMATION*)&ProcessInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_ProcessInformation == NULL) {
		ProcessInformation_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 5, ProcessHandle, ProcessInformationClass, ProcessInformation_used, ProcessInformationLength, ReturnLength); // NtQueryInformationProcess_ProcessHandleInformation

	if (NT_SUCCESS(ret_value) && ProcessInformation_used != NULL) {
		convert__PROCESS_HANDLE_SNAPSHOT_INFORMATION_64TO32(ctx, (_PROCESS_HANDLE_SNAPSHOT_INFORMATION*)ProcessInformation_used, x32based_ProcessInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQueryInformationProcess_ProcessCommandLineInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _Out_ UNICODE_STRING* ProcessInformation, _In_ ULONG ProcessInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_ProcessInformation = (uint32_t)(ProcessInformation); // UNICODE_STRING *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	UNICODE_STRING* ProcessInformation_used = 0;

	if (x32based_ProcessInformation != NULL && ProcessInformationLength != 0) {
		ProcessInformation_used = (UNICODE_STRING*)intrnl__ntcallmalloc(ctx, ProcessInformationLength);
	}

	ret_value = __syscall64(syscall_idx, 5, ProcessHandle, ProcessInformationClass, ProcessInformation_used, ProcessInformationLength, ReturnLength); // NtQueryInformationProcess_ProcessCommandLineInformation

	if (NT_SUCCESS(ret_value) && ProcessInformation_used != NULL) {
		CVT_UNICODE_STRING_OFFSETABLE_FUNC64TO32(ProcessInformation_used, x32based_ProcessInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtSetInformationProcess_ProcessQuotaLimits(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _In_ QUOTA_LIMITS* ProcessInformation, _In_ ULONG ProcessInformationLength) {

	// Declare parameters from stack
	uint32_t x32based_ProcessInformation = (uint32_t)(ProcessInformation); // QUOTA_LIMITS *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ProcessInformation_holder[sizeof(_QUOTA_LIMITS)];
	QUOTA_LIMITS* ProcessInformation_used = (QUOTA_LIMITS*)&ProcessInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_ProcessInformation != NULL) {
		convert__QUOTA_LIMITS_32TO64(ctx, (_QUOTA_LIMITS**)&ProcessInformation_used, x32based_ProcessInformation);
	}
	else {
		ProcessInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, ProcessHandle, ProcessInformationClass, ProcessInformation_used, ProcessInformationLength); // NtSetInformationProcess_ProcessQuotaLimits

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtSetInformationProcess_ProcessExceptionPort(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _In_ PROCESS_EXCEPTION_PORT* ProcessInformation, _In_ ULONG ProcessInformationLength) {

	// Declare parameters from stack
	uint32_t x32based_ProcessInformation = (uint32_t)(ProcessInformation); // PROCESS_EXCEPTION_PORT *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ProcessInformation_holder[sizeof(_PROCESS_EXCEPTION_PORT)];
	PROCESS_EXCEPTION_PORT* ProcessInformation_used = (PROCESS_EXCEPTION_PORT*)&ProcessInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_ProcessInformation != NULL) {
		convert__PROCESS_EXCEPTION_PORT_32TO64(ctx, (_PROCESS_EXCEPTION_PORT**)&ProcessInformation_used, x32based_ProcessInformation);
	}
	else {
		ProcessInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, ProcessHandle, ProcessInformationClass, ProcessInformation_used, ProcessInformationLength); // NtSetInformationProcess_ProcessExceptionPort

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtSetInformationProcess_ProcessAccessToken(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _In_ PROCESS_ACCESS_TOKEN* ProcessInformation, _In_ ULONG ProcessInformationLength) {

	// Declare parameters from stack
	uint32_t x32based_ProcessInformation = (uint32_t)(ProcessInformation); // PROCESS_ACCESS_TOKEN *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ProcessInformation_holder[sizeof(_PROCESS_ACCESS_TOKEN)];
	PROCESS_ACCESS_TOKEN* ProcessInformation_used = (PROCESS_ACCESS_TOKEN*)&ProcessInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_ProcessInformation != NULL) {
		convert__PROCESS_ACCESS_TOKEN_32TO64(ctx, (_PROCESS_ACCESS_TOKEN**)&ProcessInformation_used, x32based_ProcessInformation);
	}
	else {
		ProcessInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, ProcessHandle, ProcessInformationClass, ProcessInformation_used, ProcessInformationLength); // NtSetInformationProcess_ProcessAccessToken

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtSetInformationProcess_ProcessAffinityMask(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _In_ KAFFINITY* ProcessInformation, _In_ ULONG ProcessInformationLength) {

	// Declare parameters from stack
	uint32_t x32based_ProcessInformation = (uint32_t)(ProcessInformation); // KAFFINITY *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ProcessInformation_holder[sizeof(long long unsigned int)];
	KAFFINITY* ProcessInformation_used = (KAFFINITY*)&ProcessInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_ProcessInformation != NULL) {
		*((SIZE_T*)ProcessInformation_holder) = (SIZE_T)(*((X32_SIZE_T*)x32based_ProcessInformation));
	}
	else {
		ProcessInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, ProcessHandle, ProcessInformationClass, ProcessInformation_used, ProcessInformationLength); // NtSetInformationProcess_ProcessAffinityMask

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtSetInformationProcess_ProcessInstrumentationCallback(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _In_ PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION* ProcessInformation, _In_ ULONG ProcessInformationLength) {

	// Declare parameters from stack
	uint32_t x32based_ProcessInformation = (uint32_t)(ProcessInformation); // PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ProcessInformation_holder[sizeof(_PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION)];
	PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION* ProcessInformation_used = (PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION*)&ProcessInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_ProcessInformation != NULL) {
		convert__PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION_32TO64(ctx, (_PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION**)&ProcessInformation_used, x32based_ProcessInformation);
	}
	else {
		ProcessInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, ProcessHandle, ProcessInformationClass, ProcessInformation_used, ProcessInformationLength); // NtSetInformationProcess_ProcessInstrumentationCallback

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtSetInformationProcess_ProcessThreadStackAllocation(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _In_ PROCESS_STACK_ALLOCATION_INFORMATION* ProcessInformation, _In_ ULONG ProcessInformationLength) {

	// Declare parameters from stack
	uint32_t x32based_ProcessInformation = (uint32_t)(ProcessInformation); // PROCESS_STACK_ALLOCATION_INFORMATION *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ProcessInformation_holder[sizeof(_PROCESS_STACK_ALLOCATION_INFORMATION)];
	PROCESS_STACK_ALLOCATION_INFORMATION* ProcessInformation_used = (PROCESS_STACK_ALLOCATION_INFORMATION*)&ProcessInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_ProcessInformation != NULL) {
		convert__PROCESS_STACK_ALLOCATION_INFORMATION_32TO64(ctx, (_PROCESS_STACK_ALLOCATION_INFORMATION**)&ProcessInformation_used, x32based_ProcessInformation);
	}
	else {
		ProcessInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, ProcessHandle, ProcessInformationClass, ProcessInformation_used, ProcessInformationLength); // NtSetInformationProcess_ProcessThreadStackAllocation

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtSetInformationProcess_ProcessMemoryExhaustion(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _In_ PROCESS_MEMORY_EXHAUSTION_INFO* ProcessInformation, _In_ ULONG ProcessInformationLength) {

	// Declare parameters from stack
	uint32_t x32based_ProcessInformation = (uint32_t)(ProcessInformation); // PROCESS_MEMORY_EXHAUSTION_INFO *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ProcessInformation_holder[sizeof(_PROCESS_MEMORY_EXHAUSTION_INFO)];
	PROCESS_MEMORY_EXHAUSTION_INFO* ProcessInformation_used = (PROCESS_MEMORY_EXHAUSTION_INFO*)&ProcessInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_ProcessInformation != NULL) {
		convert__PROCESS_MEMORY_EXHAUSTION_INFO_32TO64(ctx, (_PROCESS_MEMORY_EXHAUSTION_INFO**)&ProcessInformation_used, x32based_ProcessInformation);
	}
	else {
		ProcessInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, ProcessHandle, ProcessInformationClass, ProcessInformation_used, ProcessInformationLength); // NtSetInformationProcess_ProcessMemoryExhaustion

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtSetInformationProcess_ProcessCombineSecurityDomainsInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _In_ PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION* ProcessInformation, _In_ ULONG ProcessInformationLength) {

	// Declare parameters from stack
	uint32_t x32based_ProcessInformation = (uint32_t)(ProcessInformation); // PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ProcessInformation_holder[sizeof(_PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION)];
	PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION* ProcessInformation_used = (PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION*)&ProcessInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_ProcessInformation != NULL) {
		convert__PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION_32TO64(ctx, (_PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION**)&ProcessInformation_used, x32based_ProcessInformation);
	}
	else {
		ProcessInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, ProcessHandle, ProcessInformationClass, ProcessInformation_used, ProcessInformationLength); // NtSetInformationProcess_ProcessCombineSecurityDomainsInformation

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQueryInformationThread_ThreadBasicInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE ThreadHandle, _In_ THREADINFOCLASS ThreadInformationClass, _Out_ THREAD_BASIC_INFORMATION* ThreadInformation, _In_ ULONG ThreadInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_ThreadInformation = (uint32_t)(ThreadInformation); // THREAD_BASIC_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ThreadInformation_holder[sizeof(_THREAD_BASIC_INFORMATION)];
	THREAD_BASIC_INFORMATION* ThreadInformation_used = (THREAD_BASIC_INFORMATION*)&ThreadInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_ThreadInformation == NULL) {
		ThreadInformation_used = 0;
	}
	else {
		ThreadInformationLength = sizeof(THREAD_BASIC_INFORMATION);
	}

	ret_value = __syscall64(syscall_idx, 5, ThreadHandle, ThreadInformationClass, ThreadInformation_used, ThreadInformationLength, ReturnLength); // NtQueryInformationThread_ThreadBasicInformation

	if (NT_SUCCESS(ret_value) && ThreadInformation_used != NULL) {
		convert__THREAD_BASIC_INFORMATION_64TO32(ctx, (_THREAD_BASIC_INFORMATION*)ThreadInformation_used, x32based_ThreadInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQueryInformationThread_ThreadLastSystemCall(void* ctx, uint32_t syscall_idx, _In_ HANDLE ThreadHandle, _In_ THREADINFOCLASS ThreadInformationClass, _Out_ THREAD_LAST_SYSCALL_INFORMATION* ThreadInformation, _In_ ULONG ThreadInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_ThreadInformation = (uint32_t)(ThreadInformation); // THREAD_LAST_SYSCALL_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ThreadInformation_holder[sizeof(_THREAD_LAST_SYSCALL_INFORMATION)];
	THREAD_LAST_SYSCALL_INFORMATION* ThreadInformation_used = (THREAD_LAST_SYSCALL_INFORMATION*)&ThreadInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_ThreadInformation == NULL) {
		ThreadInformation_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 5, ThreadHandle, ThreadInformationClass, ThreadInformation_used, ThreadInformationLength, ReturnLength); // NtQueryInformationThread_ThreadLastSystemCall

	if (NT_SUCCESS(ret_value) && ThreadInformation_used != NULL) {
		convert__THREAD_LAST_SYSCALL_INFORMATION_64TO32(ctx, (_THREAD_LAST_SYSCALL_INFORMATION*)ThreadInformation_used, x32based_ThreadInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQueryInformationThread_ThreadTebInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE ThreadHandle, _In_ THREADINFOCLASS ThreadInformationClass, _Out_ THREAD_TEB_INFORMATION* ThreadInformation, _In_ ULONG ThreadInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_ThreadInformation = (uint32_t)(ThreadInformation); // THREAD_TEB_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ThreadInformation_holder[sizeof(_THREAD_TEB_INFORMATION)];
	THREAD_TEB_INFORMATION* ThreadInformation_used = (THREAD_TEB_INFORMATION*)&ThreadInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_ThreadInformation == NULL) {
		ThreadInformation_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 5, ThreadHandle, ThreadInformationClass, ThreadInformation_used, ThreadInformationLength, ReturnLength); // NtQueryInformationThread_ThreadTebInformation

	if (NT_SUCCESS(ret_value) && ThreadInformation_used != NULL) {
		convert__THREAD_TEB_INFORMATION_64TO32(ctx, (_THREAD_TEB_INFORMATION*)ThreadInformation_used, x32based_ThreadInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQueryInformationThread_ThreadGroupInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE ThreadHandle, _In_ THREADINFOCLASS ThreadInformationClass, _Out_ GROUP_AFFINITY* ThreadInformation, _In_ ULONG ThreadInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_ThreadInformation = (uint32_t)(ThreadInformation); // GROUP_AFFINITY *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ThreadInformation_holder[sizeof(_GROUP_AFFINITY)];
	GROUP_AFFINITY* ThreadInformation_used = (GROUP_AFFINITY*)&ThreadInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_ThreadInformation == NULL) {
		ThreadInformation_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 5, ThreadHandle, ThreadInformationClass, ThreadInformation_used, ThreadInformationLength, ReturnLength); // NtQueryInformationThread_ThreadGroupInformation

	if (NT_SUCCESS(ret_value) && ThreadInformation_used != NULL) {
		convert__GROUP_AFFINITY_64TO32(ctx, (_GROUP_AFFINITY*)ThreadInformation_used, x32based_ThreadInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQueryInformationThread_ThreadCounterProfiling(void* ctx, uint32_t syscall_idx, _In_ HANDLE ThreadHandle, _In_ THREADINFOCLASS ThreadInformationClass, _Out_ THREAD_PROFILING_INFORMATION* ThreadInformation, _In_ ULONG ThreadInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_ThreadInformation = (uint32_t)(ThreadInformation); // THREAD_PROFILING_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ThreadInformation_holder[sizeof(_THREAD_PROFILING_INFORMATION)];
	THREAD_PROFILING_INFORMATION* ThreadInformation_used = (THREAD_PROFILING_INFORMATION*)&ThreadInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_ThreadInformation == NULL) {
		ThreadInformation_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 5, ThreadHandle, ThreadInformationClass, ThreadInformation_used, ThreadInformationLength, ReturnLength); // NtQueryInformationThread_ThreadCounterProfiling

	if (NT_SUCCESS(ret_value) && ThreadInformation_used != NULL) {
		convert__THREAD_PROFILING_INFORMATION_64TO32(ctx, (_THREAD_PROFILING_INFORMATION*)ThreadInformation_used, x32based_ThreadInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtQueryInformationThread_ThreadNameInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE ThreadHandle, _In_ THREADINFOCLASS ThreadInformationClass, _Out_ THREAD_NAME_INFORMATION* ThreadInformation, _In_ ULONG ThreadInformationLength, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack

	uint32_t x32based_ThreadInformation = (uint32_t)(ThreadInformation); // THREAD_NAME_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters

	uint8_t ThreadInformation_holder[sizeof(_THREAD_NAME_INFORMATION)];
	THREAD_NAME_INFORMATION* ThreadInformation_used = (THREAD_NAME_INFORMATION*)&ThreadInformation_holder;

	// Convert parameters from x32 to x64

	if (x32based_ThreadInformation == NULL) {
		ThreadInformation_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 5, ThreadHandle, ThreadInformationClass, ThreadInformation_used, ThreadInformationLength, ReturnLength); // NtQueryInformationThread_ThreadNameInformation


	if (NT_SUCCESS(ret_value) && ThreadInformation_used != NULL) {
		convert__THREAD_NAME_INFORMATION_64TO32(ctx, (_THREAD_NAME_INFORMATION*)ThreadInformation_used, x32based_ThreadInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtSetInformationThread_ThreadAffinityMask(void* ctx, uint32_t syscall_idx, _In_ HANDLE ThreadHandle, _In_ THREADINFOCLASS ThreadInformationClass, _In_ KAFFINITY* ThreadInformation, _In_ ULONG ThreadInformationLength) {

	// Declare parameters from stack
	uint32_t x32based_ThreadInformation = (uint32_t)(ThreadInformation); // KAFFINITY *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ThreadInformation_holder[sizeof(long long unsigned int)];
	KAFFINITY* ThreadInformation_used = (KAFFINITY*)&ThreadInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_ThreadInformation != NULL) {
		*((SIZE_T*)ThreadInformation_holder) = (SIZE_T)(*((X32_SIZE_T*)x32based_ThreadInformation));
	}
	else {
		ThreadInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, ThreadHandle, ThreadInformationClass, ThreadInformation_used, ThreadInformationLength); // NtSetInformationThread_ThreadAffinityMask

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtSetInformationThread_ThreadGroupInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE ThreadHandle, _In_ THREADINFOCLASS ThreadInformationClass, _In_ GROUP_AFFINITY* ThreadInformation, _In_ ULONG ThreadInformationLength) {

	// Declare parameters from stack
	uint32_t x32based_ThreadInformation = (uint32_t)(ThreadInformation); // GROUP_AFFINITY *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ThreadInformation_holder[sizeof(_GROUP_AFFINITY)];
	GROUP_AFFINITY* ThreadInformation_used = (GROUP_AFFINITY*)&ThreadInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_ThreadInformation != NULL) {
		convert__GROUP_AFFINITY_32TO64(ctx, (_GROUP_AFFINITY**)&ThreadInformation_used, x32based_ThreadInformation);
	}
	else {
		ThreadInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, ThreadHandle, ThreadInformationClass, ThreadInformation_used, ThreadInformationLength); // NtSetInformationThread_ThreadGroupInformation

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtSetInformationThread_ThreadCounterProfiling(void* ctx, uint32_t syscall_idx, _In_ HANDLE ThreadHandle, _In_ THREADINFOCLASS ThreadInformationClass, _In_ THREAD_PROFILING_INFORMATION* ThreadInformation, _In_ ULONG ThreadInformationLength) {

	// Declare parameters from stack
	uint32_t x32based_ThreadInformation = (uint32_t)(ThreadInformation); // THREAD_PROFILING_INFORMATION *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ThreadInformation_holder[sizeof(_THREAD_PROFILING_INFORMATION)];
	THREAD_PROFILING_INFORMATION* ThreadInformation_used = (THREAD_PROFILING_INFORMATION*)&ThreadInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_ThreadInformation != NULL) {
		convert__THREAD_PROFILING_INFORMATION_32TO64(ctx, (_THREAD_PROFILING_INFORMATION**)&ThreadInformation_used, x32based_ThreadInformation);
	}
	else {
		ThreadInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, ThreadHandle, ThreadInformationClass, ThreadInformation_used, ThreadInformationLength); // NtSetInformationThread_ThreadCounterProfiling

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtSetInformationThread_ThreadNameInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE ThreadHandle, _In_ THREADINFOCLASS ThreadInformationClass, _In_ THREAD_NAME_INFORMATION* ThreadInformation, _In_ ULONG ThreadInformationLength) {

	// Declare parameters from stack

	uint32_t x32based_ThreadInformation = (uint32_t)(ThreadInformation); // THREAD_NAME_INFORMATION *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters

	uint8_t ThreadInformation_holder[sizeof(_THREAD_NAME_INFORMATION)];
	THREAD_NAME_INFORMATION* ThreadInformation_used = (THREAD_NAME_INFORMATION*)&ThreadInformation_holder;

	// Convert parameters from x32 to x64

	if (x32based_ThreadInformation != NULL) {
		convert__THREAD_NAME_INFORMATION_32TO64(ctx, (_THREAD_NAME_INFORMATION**)&ThreadInformation_used, x32based_ThreadInformation);
	}
	else {
		ThreadInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, ThreadHandle, ThreadInformationClass, ThreadInformation_used, ThreadInformationLength); // NtSetInformationThread_ThreadNameInformation

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtSetInformationFile_FileRenameInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE FileHandle, _Out_ PIO_STATUS_BLOCK IoStatusBlock, _In_ FILE_RENAME_INFORMATION* FileInformation, _In_ ULONG Length, _In_ FILE_INFORMATION_CLASS FileInformationClass) {

	// Declare parameters from stack
	uint32_t x32based_FileInformation = (uint32_t)(FileInformation); // FILE_RENAME_INFORMATION *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t FileInformation_holder[sizeof(_FILE_RENAME_INFORMATION)];
	FILE_RENAME_INFORMATION* FileInformation_used = (FILE_RENAME_INFORMATION*)&FileInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_FileInformation != NULL) {
		convert__FILE_RENAME_INFORMATION_32TO64(ctx, (_FILE_RENAME_INFORMATION**)&FileInformation_used, x32based_FileInformation);
	}
	else {
		FileInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 5, FileHandle, IoStatusBlock, FileInformation_used, Length, FileInformationClass); // NtSetInformationFile_FileRenameInformation

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtSetInformationFile_FileLinkInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE FileHandle, _Out_ PIO_STATUS_BLOCK IoStatusBlock, _In_ FILE_LINK_INFORMATION* FileInformation, _In_ ULONG Length, _In_ FILE_INFORMATION_CLASS FileInformationClass) {

	// Declare parameters from stack
	uint32_t x32based_FileInformation = (uint32_t)(FileInformation); // FILE_LINK_INFORMATION *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t FileInformation_holder[sizeof(_FILE_LINK_INFORMATION)];
	FILE_LINK_INFORMATION* FileInformation_used = (FILE_LINK_INFORMATION*)&FileInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_FileInformation != NULL) {
		convert__FILE_LINK_INFORMATION_32TO64(ctx, (_FILE_LINK_INFORMATION**)&FileInformation_used, x32based_FileInformation);
	}
	else {
		FileInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 5, FileHandle, IoStatusBlock, FileInformation_used, Length, FileInformationClass); // NtSetInformationFile_FileLinkInformation

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtSetInformationFile_FileMailslotSetInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE FileHandle, _Out_ PIO_STATUS_BLOCK IoStatusBlock, _In_ FILE_MAILSLOT_SET_INFORMATION* FileInformation, _In_ ULONG Length, _In_ FILE_INFORMATION_CLASS FileInformationClass) {

	// Declare parameters from stack
	uint32_t x32based_FileInformation = (uint32_t)(FileInformation); // FILE_MAILSLOT_SET_INFORMATION *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t FileInformation_holder[sizeof(_FILE_MAILSLOT_SET_INFORMATION)];
	FILE_MAILSLOT_SET_INFORMATION* FileInformation_used = (FILE_MAILSLOT_SET_INFORMATION*)&FileInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_FileInformation != NULL) {
		convert__FILE_MAILSLOT_SET_INFORMATION_32TO64(ctx, (_FILE_MAILSLOT_SET_INFORMATION**)&FileInformation_used, x32based_FileInformation);
	}
	else {
		FileInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 5, FileHandle, IoStatusBlock, FileInformation_used, Length, FileInformationClass); // NtSetInformationFile_FileMailslotSetInformation

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtSetInformationFile_FileCompletionInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE FileHandle, _Out_ PIO_STATUS_BLOCK IoStatusBlock, _In_ FILE_COMPLETION_INFORMATION* FileInformation, _In_ ULONG Length, _In_ FILE_INFORMATION_CLASS FileInformationClass) {

	// Declare parameters from stack
	uint32_t x32based_FileInformation = (uint32_t)(FileInformation); // FILE_COMPLETION_INFORMATION *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t FileInformation_holder[sizeof(_FILE_COMPLETION_INFORMATION)];
	FILE_COMPLETION_INFORMATION* FileInformation_used = (FILE_COMPLETION_INFORMATION*)&FileInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_FileInformation != NULL) {
		convert__FILE_COMPLETION_INFORMATION_32TO64(ctx, (_FILE_COMPLETION_INFORMATION**)&FileInformation_used, x32based_FileInformation);
	}
	else {
		FileInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 5, FileHandle, IoStatusBlock, FileInformation_used, Length, FileInformationClass); // NtSetInformationFile_FileCompletionInformation

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtSetInformationFile_FileMoveClusterInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE FileHandle, _Out_ PIO_STATUS_BLOCK IoStatusBlock, _In_ FILE_MOVE_CLUSTER_INFORMATION* FileInformation, _In_ ULONG Length, _In_ FILE_INFORMATION_CLASS FileInformationClass) {

	// Declare parameters from stack
	uint32_t x32based_FileInformation = (uint32_t)(FileInformation); // FILE_MOVE_CLUSTER_INFORMATION *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t FileInformation_holder[sizeof(_FILE_MOVE_CLUSTER_INFORMATION)];
	FILE_MOVE_CLUSTER_INFORMATION* FileInformation_used = (FILE_MOVE_CLUSTER_INFORMATION*)&FileInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_FileInformation != NULL) {
		convert__FILE_MOVE_CLUSTER_INFORMATION_32TO64(ctx, (_FILE_MOVE_CLUSTER_INFORMATION**)&FileInformation_used, x32based_FileInformation);
	}
	else {
		FileInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 5, FileHandle, IoStatusBlock, FileInformation_used, Length, FileInformationClass); // NtSetInformationFile_FileMoveClusterInformation

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtSetInformationFile_FileTrackingInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE FileHandle, _Out_ PIO_STATUS_BLOCK IoStatusBlock, _In_ FILE_TRACKING_INFORMATION* FileInformation, _In_ ULONG Length, _In_ FILE_INFORMATION_CLASS FileInformationClass) {

	// Declare parameters from stack
	uint32_t x32based_FileInformation = (uint32_t)(FileInformation); // FILE_TRACKING_INFORMATION *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t FileInformation_holder[sizeof(_FILE_TRACKING_INFORMATION)];
	FILE_TRACKING_INFORMATION* FileInformation_used = (FILE_TRACKING_INFORMATION*)&FileInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_FileInformation != NULL) {
		convert__FILE_TRACKING_INFORMATION_32TO64(ctx, (_FILE_TRACKING_INFORMATION**)&FileInformation_used, x32based_FileInformation);
	}
	else {
		FileInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 5, FileHandle, IoStatusBlock, FileInformation_used, Length, FileInformationClass); // NtSetInformationFile_FileTrackingInformation

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtSetInformationFile_FileIoStatusBlockRangeInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE FileHandle, _Out_ PIO_STATUS_BLOCK IoStatusBlock, _In_ FILE_IOSTATUSBLOCK_RANGE_INFORMATION* FileInformation, _In_ ULONG Length, _In_ FILE_INFORMATION_CLASS FileInformationClass) {

	// Declare parameters from stack
	uint32_t x32based_FileInformation = (uint32_t)(FileInformation); // FILE_IOSTATUSBLOCK_RANGE_INFORMATION *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t FileInformation_holder[sizeof(_FILE_IOSTATUSBLOCK_RANGE_INFORMATION)];
	FILE_IOSTATUSBLOCK_RANGE_INFORMATION* FileInformation_used = (FILE_IOSTATUSBLOCK_RANGE_INFORMATION*)&FileInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_FileInformation != NULL) {
		convert__FILE_IOSTATUSBLOCK_RANGE_INFORMATION_32TO64(ctx, (_FILE_IOSTATUSBLOCK_RANGE_INFORMATION**)&FileInformation_used, x32based_FileInformation);
	}
	else {
		FileInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 5, FileHandle, IoStatusBlock, FileInformation_used, Length, FileInformationClass); // NtSetInformationFile_FileIoStatusBlockRangeInformation

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtSetInformationFile_FileReplaceCompletionInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE FileHandle, _Out_ PIO_STATUS_BLOCK IoStatusBlock, _In_ FILE_COMPLETION_INFORMATION* FileInformation, _In_ ULONG Length, _In_ FILE_INFORMATION_CLASS FileInformationClass) {

	// Declare parameters from stack
	uint32_t x32based_FileInformation = (uint32_t)(FileInformation); // FILE_COMPLETION_INFORMATION *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t FileInformation_holder[sizeof(_FILE_COMPLETION_INFORMATION)];
	FILE_COMPLETION_INFORMATION* FileInformation_used = (FILE_COMPLETION_INFORMATION*)&FileInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_FileInformation != NULL) {
		convert__FILE_COMPLETION_INFORMATION_32TO64(ctx, (_FILE_COMPLETION_INFORMATION**)&FileInformation_used, x32based_FileInformation);
	}
	else {
		FileInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 5, FileHandle, IoStatusBlock, FileInformation_used, Length, FileInformationClass); // NtSetInformationFile_FileReplaceCompletionInformation

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtSetInformationFile_FileRenameInformationEx(void* ctx, uint32_t syscall_idx, _In_ HANDLE FileHandle, _Out_ PIO_STATUS_BLOCK IoStatusBlock, _In_ FILE_RENAME_INFORMATION_EX* FileInformation, _In_ ULONG Length, _In_ FILE_INFORMATION_CLASS FileInformationClass) {

	// Declare parameters from stack
	uint32_t x32based_FileInformation = (uint32_t)(FileInformation); // FILE_RENAME_INFORMATION_EX *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t FileInformation_holder[sizeof(_FILE_RENAME_INFORMATION_EX)];
	FILE_RENAME_INFORMATION_EX* FileInformation_used = (FILE_RENAME_INFORMATION_EX*)&FileInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_FileInformation != NULL) {
		convert__FILE_RENAME_INFORMATION_EX_32TO64(ctx, (_FILE_RENAME_INFORMATION_EX**)&FileInformation_used, x32based_FileInformation);
	}
	else {
		FileInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 5, FileHandle, IoStatusBlock, FileInformation_used, Length, FileInformationClass); // NtSetInformationFile_FileRenameInformationEx

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtSetInformationFile_FileMemoryPartitionInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE FileHandle, _Out_ PIO_STATUS_BLOCK IoStatusBlock, _In_ FILE_MEMORY_PARTITION_INFORMATION* FileInformation, _In_ ULONG Length, _In_ FILE_INFORMATION_CLASS FileInformationClass) {

	// Declare parameters from stack
	uint32_t x32based_FileInformation = (uint32_t)(FileInformation); // FILE_MEMORY_PARTITION_INFORMATION *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t FileInformation_holder[sizeof(_FILE_MEMORY_PARTITION_INFORMATION)];
	FILE_MEMORY_PARTITION_INFORMATION* FileInformation_used = (FILE_MEMORY_PARTITION_INFORMATION*)&FileInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_FileInformation != NULL) {
		convert__FILE_MEMORY_PARTITION_INFORMATION_32TO64(ctx, (_FILE_MEMORY_PARTITION_INFORMATION**)&FileInformation_used, x32based_FileInformation);
	}
	else {
		FileInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 5, FileHandle, IoStatusBlock, FileInformation_used, Length, FileInformationClass); // NtSetInformationFile_FileMemoryPartitionInformation

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtSetInformationFile_FileLinkInformationEx(void* ctx, uint32_t syscall_idx, _In_ HANDLE FileHandle, _Out_ PIO_STATUS_BLOCK IoStatusBlock, _In_ FILE_LINK_INFORMATION_EX* FileInformation, _In_ ULONG Length, _In_ FILE_INFORMATION_CLASS FileInformationClass) {

	// Declare parameters from stack
	uint32_t x32based_FileInformation = (uint32_t)(FileInformation); // FILE_LINK_INFORMATION_EX *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t FileInformation_holder[sizeof(_FILE_LINK_INFORMATION_EX)];
	FILE_LINK_INFORMATION_EX* FileInformation_used = (FILE_LINK_INFORMATION_EX*)&FileInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_FileInformation != NULL) {
		convert__FILE_LINK_INFORMATION_EX_32TO64(ctx, (_FILE_LINK_INFORMATION_EX**)&FileInformation_used, x32based_FileInformation);
	}
	else {
		FileInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 5, FileHandle, IoStatusBlock, FileInformation_used, Length, FileInformationClass); // NtSetInformationFile_FileLinkInformationEx

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtAlpcQueryInformation_AlpcBasicInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE PortHandle, _In_ ALPC_PORT_INFORMATION_CLASS PortInformationClass, _Out_ ALPC_BASIC_INFORMATION* PortInformation, _In_ ULONG Length, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_PortInformation = (uint32_t)(PortInformation); // ALPC_BASIC_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t PortInformation_holder[sizeof(_ALPC_BASIC_INFORMATION)];
	ALPC_BASIC_INFORMATION* PortInformation_used = (ALPC_BASIC_INFORMATION*)&PortInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_PortInformation == NULL) {
		PortInformation_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 5, PortHandle, PortInformationClass, PortInformation_used, Length, ReturnLength); // NtAlpcQueryInformation_AlpcBasicInformation

	if (NT_SUCCESS(ret_value) && PortInformation_used != NULL) {
		convert__ALPC_BASIC_INFORMATION_64TO32(ctx, (_ALPC_BASIC_INFORMATION*)PortInformation_used, x32based_PortInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtAlpcQueryInformation_AlpcServerInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE PortHandle, _In_ ALPC_PORT_INFORMATION_CLASS PortInformationClass, _Out_ ALPC_SERVER_INFORMATION* PortInformation, _In_ ULONG Length, _Out_ PULONG ReturnLength) {

	// Declare parameters from stack
	uint32_t x32based_PortInformation = (uint32_t)(PortInformation); // ALPC_SERVER_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t PortInformation_holder[sizeof(_ALPC_SERVER_INFORMATION)];
	ALPC_SERVER_INFORMATION* PortInformation_used = (ALPC_SERVER_INFORMATION*)&PortInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_PortInformation == NULL) {
		PortInformation_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 5, PortHandle, PortInformationClass, PortInformation_used, Length, ReturnLength); // NtAlpcQueryInformation_AlpcServerInformation

	if (NT_SUCCESS(ret_value) && PortInformation_used != NULL) {
		convert__ALPC_SERVER_INFORMATION_64TO32(ctx, (_ALPC_SERVER_INFORMATION*)PortInformation_used, x32based_PortInformation);
	}

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtAlpcSetInformation_AlpcBasicInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE PortHandle, _In_ ALPC_PORT_INFORMATION_CLASS PortInformationClass, _In_ ALPC_BASIC_INFORMATION* PortInformation, _In_ ULONG Length) {

	// Declare parameters from stack
	uint32_t x32based_PortInformation = (uint32_t)(PortInformation); // ALPC_BASIC_INFORMATION *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t PortInformation_holder[sizeof(_ALPC_BASIC_INFORMATION)];
	ALPC_BASIC_INFORMATION* PortInformation_used = (ALPC_BASIC_INFORMATION*)&PortInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_PortInformation != NULL) {
		convert__ALPC_BASIC_INFORMATION_32TO64(ctx, (_ALPC_BASIC_INFORMATION**)&PortInformation_used, x32based_PortInformation);
	}
	else {
		PortInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, PortHandle, PortInformationClass, PortInformation_used, Length); // NtAlpcSetInformation_AlpcBasicInformation

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtAlpcSetInformation_AlpcPortInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE PortHandle, _In_ ALPC_PORT_INFORMATION_CLASS PortInformationClass, _In_ ALPC_PORT_ATTRIBUTES* PortInformation, _In_ ULONG Length) {

	// Declare parameters from stack
	uint32_t x32based_PortInformation = (uint32_t)(PortInformation); // ALPC_PORT_ATTRIBUTES *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t PortInformation_holder[sizeof(_ALPC_PORT_ATTRIBUTES)];
	ALPC_PORT_ATTRIBUTES* PortInformation_used = (ALPC_PORT_ATTRIBUTES*)&PortInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_PortInformation != NULL) {
		convert__ALPC_PORT_ATTRIBUTES_32TO64(ctx, (_ALPC_PORT_ATTRIBUTES**)&PortInformation_used, x32based_PortInformation);
	}
	else {
		PortInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, PortHandle, PortInformationClass, PortInformation_used, Length); // NtAlpcSetInformation_AlpcPortInformation

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtAlpcSetInformation_AlpcAssociateCompletionPortInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE PortHandle, _In_ ALPC_PORT_INFORMATION_CLASS PortInformationClass, _In_ ALPC_PORT_ASSOCIATE_COMPLETION_PORT* PortInformation, _In_ ULONG Length) {

	// Declare parameters from stack
	uint32_t x32based_PortInformation = (uint32_t)(PortInformation); // ALPC_PORT_ASSOCIATE_COMPLETION_PORT *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t PortInformation_holder[sizeof(_ALPC_PORT_ASSOCIATE_COMPLETION_PORT)];
	ALPC_PORT_ASSOCIATE_COMPLETION_PORT* PortInformation_used = (ALPC_PORT_ASSOCIATE_COMPLETION_PORT*)&PortInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_PortInformation != NULL) {
		convert__ALPC_PORT_ASSOCIATE_COMPLETION_PORT_32TO64(ctx, (_ALPC_PORT_ASSOCIATE_COMPLETION_PORT**)&PortInformation_used, x32based_PortInformation);
	}
	else {
		PortInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, PortHandle, PortInformationClass, PortInformation_used, Length); // NtAlpcSetInformation_AlpcAssociateCompletionPortInformation

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtAlpcSetInformation_AlpcMessageZoneInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE PortHandle, _In_ ALPC_PORT_INFORMATION_CLASS PortInformationClass, _In_ ALPC_PORT_MESSAGE_ZONE_INFORMATION* PortInformation, _In_ ULONG Length) {

	// Declare parameters from stack
	uint32_t x32based_PortInformation = (uint32_t)(PortInformation); // ALPC_PORT_MESSAGE_ZONE_INFORMATION *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t PortInformation_holder[sizeof(_ALPC_PORT_MESSAGE_ZONE_INFORMATION)];
	ALPC_PORT_MESSAGE_ZONE_INFORMATION* PortInformation_used = (ALPC_PORT_MESSAGE_ZONE_INFORMATION*)&PortInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_PortInformation != NULL) {
		convert__ALPC_PORT_MESSAGE_ZONE_INFORMATION_32TO64(ctx, (_ALPC_PORT_MESSAGE_ZONE_INFORMATION**)&PortInformation_used, x32based_PortInformation);
	}
	else {
		PortInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, PortHandle, PortInformationClass, PortInformation_used, Length); // NtAlpcSetInformation_AlpcMessageZoneInformation

	return ret_value;
}


static NTSTATUS WINAPI _w32_NtAlpcSetInformation_AlpcRegisterCompletionListInformation(void* ctx, uint32_t syscall_idx, _In_ HANDLE PortHandle, _In_ ALPC_PORT_INFORMATION_CLASS PortInformationClass, _In_ ALPC_PORT_COMPLETION_LIST_INFORMATION* PortInformation, _In_ ULONG Length) {

	// Declare parameters from stack
	uint32_t x32based_PortInformation = (uint32_t)(PortInformation); // ALPC_PORT_COMPLETION_LIST_INFORMATION *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t PortInformation_holder[sizeof(_ALPC_PORT_COMPLETION_LIST_INFORMATION)];
	ALPC_PORT_COMPLETION_LIST_INFORMATION* PortInformation_used = (ALPC_PORT_COMPLETION_LIST_INFORMATION*)&PortInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_PortInformation != NULL) {
		convert__ALPC_PORT_COMPLETION_LIST_INFORMATION_32TO64(ctx, (_ALPC_PORT_COMPLETION_LIST_INFORMATION**)&PortInformation_used, x32based_PortInformation);
	}
	else {
		PortInformation_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, PortHandle, PortInformationClass, PortInformation_used, Length); // NtAlpcSetInformation_AlpcRegisterCompletionListInformation

	return ret_value;
}



NTSTATUS WINAPI _w32_NtMapViewOfSectionEx(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_SectionHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[3]); // HANDLE  IN 
	uint32_t x32based_BaseAddress = (uint32_t)(x32based_args[4]); // PVOID *  IN  OUT 
	PLARGE_INTEGER SectionOffset_used = (PLARGE_INTEGER)(x32based_args[5]); // PLARGE_INTEGER  IN  OUT 
	uint32_t x32based_ViewSize = (uint32_t)(x32based_args[6]); // PSIZE_T  IN  OUT 
	ULONG AllocationType_used = (ULONG)(x32based_args[7]); // ULONG  IN 
	ULONG Win32Protect_used = (ULONG)(x32based_args[8]); // ULONG  IN 
	uint32_t x32based_Parameters = (uint32_t)(x32based_args[9]); // MEM_EXTENDED_PARAMETER *  IN  OUT 
	ULONG ParameterCount_used = (ULONG)(x32based_args[10]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE SectionHandle_used = Handle32ToHandle((const void* __ptr32)x32based_SectionHandle);
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);
	uint8_t BaseAddress_holder[sizeof(PVOID)];
	PVOID* BaseAddress_used = (PVOID*)&BaseAddress_holder;
	uint8_t ViewSize_holder[sizeof(long long unsigned int)];
	PSIZE_T ViewSize_used = (PSIZE_T)&ViewSize_holder;
	uint8_t Parameters_holder[sizeof(MEM_EXTENDED_PARAMETER)];
	MEM_EXTENDED_PARAMETER* Parameters_used = (MEM_EXTENDED_PARAMETER*)&Parameters_holder;

	// Convert parameters from x32 to x64
	if (x32based_BaseAddress != NULL) {
		*((SIZE_T*)BaseAddress_holder) = (SIZE_T)(*((X32_SIZE_T*)x32based_BaseAddress));
	}
	else {
		BaseAddress_used = 0;
	}
	if (x32based_ViewSize != NULL) {
		*((SIZE_T*)ViewSize_holder) = (SIZE_T)(*((X32_SIZE_T*)x32based_ViewSize));
	}
	else {
		ViewSize_used = 0;
	}
	if (x32based_Parameters != NULL) {
		convert_MEM_EXTENDED_PARAMETER_32TO64(ctx, (MEM_EXTENDED_PARAMETER**)&Parameters_used, x32based_Parameters);
	}
	else {
		Parameters_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 9, SectionHandle_used, ProcessHandle_used, BaseAddress_used, SectionOffset_used, ViewSize_used, AllocationType_used, Win32Protect_used, Parameters_used, ParameterCount_used); // NtMapViewOfSectionEx

	if (x32based_BaseAddress != NULL) {
		*((X32_SIZE_T*)x32based_BaseAddress) = (X32_SIZE_T)(*(SIZE_T*)BaseAddress_used);
	}
	if (x32based_ViewSize != NULL) {
		*((X32_SIZE_T*)x32based_ViewSize) = (X32_SIZE_T)(*(SIZE_T*)ViewSize_used);
	}
	if (Parameters_used != NULL) {
		convert_MEM_EXTENDED_PARAMETER_64TO32(ctx, (MEM_EXTENDED_PARAMETER*)Parameters_used, x32based_Parameters);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCallbackReturn(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PVOID OutputBuffer_used = (PVOID)(x32based_args[2]); // PVOID  IN  OUT 
	ULONG OutputLength_used = (ULONG)(x32based_args[3]); // ULONG  IN 
	NTSTATUS Status_used = (NTSTATUS)(x32based_args[4]); // NTSTATUS  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 3, OutputBuffer_used, OutputLength_used, Status_used); // NtCallbackReturn

	return ret_value;
}


void WINAPI _w32_NtFlushProcessWriteBuffers(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	// Declare space used in parameters
	// Convert parameters from x32 to x64
	__syscall64(syscall_idx, 0); // NtFlushProcessWriteBuffers

}


NTSTATUS WINAPI _w32_NtQueryDebugFilterState(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	ULONG ComponentId_used = (ULONG)(x32based_args[2]); // ULONG  IN 
	ULONG Level_used = (ULONG)(x32based_args[3]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, ComponentId_used, Level_used); // NtQueryDebugFilterState

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetDebugFilterState(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	ULONG ComponentId_used = (ULONG)(x32based_args[2]); // ULONG  IN 
	ULONG Level_used = (ULONG)(x32based_args[3]); // ULONG  IN 
	BOOLEAN State_used = (BOOLEAN)(x32based_args[4]); // BOOLEAN  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 3, ComponentId_used, Level_used, State_used); // NtSetDebugFilterState

	return ret_value;
}


NTSTATUS WINAPI _w32_NtYieldExecution(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 0); // NtYieldExecution

	return ret_value;
}


NTSTATUS WINAPI _w32_NtDelayExecution(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	BOOLEAN Alertable_used = (BOOLEAN)(x32based_args[2]); // BOOLEAN  IN 
	PLARGE_INTEGER DelayInterval_used = (PLARGE_INTEGER)(x32based_args[3]); // PLARGE_INTEGER  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, Alertable_used, DelayInterval_used); // NtDelayExecution

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQuerySystemEnvironmentValue(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_VariableName = (uint32_t)(x32based_args[2]); // PUNICODE_STRING  IN 
	PWSTR VariableValue_used = (PWSTR)(x32based_args[3]); // PWSTR  OUT 
	USHORT ValueLength_used = (USHORT)(x32based_args[4]); // USHORT  IN 
	PUSHORT ReturnLength_used = (PUSHORT)(x32based_args[5]); // PUSHORT  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t VariableName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING VariableName_used = (PUNICODE_STRING)&VariableName_holder;

	// Convert parameters from x32 to x64
	if (x32based_VariableName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&VariableName_used, x32based_VariableName);
	}
	else {
		VariableName_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, VariableName_used, VariableValue_used, ValueLength_used, ReturnLength_used); // NtQuerySystemEnvironmentValue

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetSystemEnvironmentValue(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_VariableName = (uint32_t)(x32based_args[2]); // PUNICODE_STRING  IN 
	uint32_t x32based_VariableValue = (uint32_t)(x32based_args[3]); // PUNICODE_STRING  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t VariableName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING VariableName_used = (PUNICODE_STRING)&VariableName_holder;
	uint8_t VariableValue_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING VariableValue_used = (PUNICODE_STRING)&VariableValue_holder;

	// Convert parameters from x32 to x64
	if (x32based_VariableName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&VariableName_used, x32based_VariableName);
	}
	else {
		VariableName_used = 0;
	}
	if (x32based_VariableValue != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&VariableValue_used, x32based_VariableValue);
	}
	else {
		VariableValue_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 2, VariableName_used, VariableValue_used); // NtSetSystemEnvironmentValue

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQuerySystemEnvironmentValueEx(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_VariableName = (uint32_t)(x32based_args[2]); // PUNICODE_STRING  IN 
	LPGUID VendorGuid_used = (LPGUID)(x32based_args[3]); // LPGUID  IN 
	PVOID Value_used = (PVOID)(x32based_args[4]); // PVOID  OUT 
	PULONG ValueLength_used = (PULONG)(x32based_args[5]); // PULONG  IN  OUT 
	PULONG Attributes_used = (PULONG)(x32based_args[6]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t VariableName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING VariableName_used = (PUNICODE_STRING)&VariableName_holder;

	// Convert parameters from x32 to x64
	if (x32based_VariableName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&VariableName_used, x32based_VariableName);
	}
	else {
		VariableName_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 5, VariableName_used, VendorGuid_used, Value_used, ValueLength_used, Attributes_used); // NtQuerySystemEnvironmentValueEx

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetSystemEnvironmentValueEx(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_VariableName = (uint32_t)(x32based_args[2]); // PUNICODE_STRING  IN 
	LPGUID VendorGuid_used = (LPGUID)(x32based_args[3]); // LPGUID  IN 
	PVOID Value_used = (PVOID)(x32based_args[4]); // PVOID  IN 
	ULONG ValueLength_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	ULONG Attributes_used = (ULONG)(x32based_args[6]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t VariableName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING VariableName_used = (PUNICODE_STRING)&VariableName_holder;

	// Convert parameters from x32 to x64
	if (x32based_VariableName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&VariableName_used, x32based_VariableName);
	}
	else {
		VariableName_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 5, VariableName_used, VendorGuid_used, Value_used, ValueLength_used, Attributes_used); // NtSetSystemEnvironmentValueEx

	return ret_value;
}


NTSTATUS WINAPI _w32_NtEnumerateSystemEnvironmentValuesEx(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	ULONG InformationClass_used = (ULONG)(x32based_args[2]); // ULONG  IN 
	PVOID Buffer_used = (PVOID)(x32based_args[3]); // PVOID  OUT 
	PULONG BufferLength_used = (PULONG)(x32based_args[4]); // PULONG  IN  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 3, InformationClass_used, Buffer_used, BufferLength_used); // NtEnumerateSystemEnvironmentValuesEx

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAddBootEntry(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PBOOT_ENTRY BootEntry_used = (PBOOT_ENTRY)(x32based_args[2]); // PBOOT_ENTRY  IN 
	PULONG Id_used = (PULONG)(x32based_args[3]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, BootEntry_used, Id_used); // NtAddBootEntry

	return ret_value;
}


NTSTATUS WINAPI _w32_NtDeleteBootEntry(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	ULONG Id_used = (ULONG)(x32based_args[2]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, Id_used); // NtDeleteBootEntry

	return ret_value;
}


NTSTATUS WINAPI _w32_NtModifyBootEntry(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PBOOT_ENTRY BootEntry_used = (PBOOT_ENTRY)(x32based_args[2]); // PBOOT_ENTRY  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, BootEntry_used); // NtModifyBootEntry

	return ret_value;
}


NTSTATUS WINAPI _w32_NtEnumerateBootEntries(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PVOID Buffer_used = (PVOID)(x32based_args[2]); // PVOID  OUT 
	PULONG BufferLength_used = (PULONG)(x32based_args[3]); // PULONG  IN  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, Buffer_used, BufferLength_used); // NtEnumerateBootEntries

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryBootEntryOrder(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PULONG Ids_used = (PULONG)(x32based_args[2]); // PULONG  OUT 
	PULONG Count_used = (PULONG)(x32based_args[3]); // PULONG  IN  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, Ids_used, Count_used); // NtQueryBootEntryOrder

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetBootEntryOrder(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PULONG Ids_used = (PULONG)(x32based_args[2]); // PULONG  IN 
	ULONG Count_used = (ULONG)(x32based_args[3]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, Ids_used, Count_used); // NtSetBootEntryOrder

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryBootOptions(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PBOOT_OPTIONS BootOptions_used = (PBOOT_OPTIONS)(x32based_args[2]); // PBOOT_OPTIONS  OUT 
	PULONG BootOptionsLength_used = (PULONG)(x32based_args[3]); // PULONG  IN  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, BootOptions_used, BootOptionsLength_used); // NtQueryBootOptions

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetBootOptions(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PBOOT_OPTIONS BootOptions_used = (PBOOT_OPTIONS)(x32based_args[2]); // PBOOT_OPTIONS  IN 
	ULONG FieldsToChange_used = (ULONG)(x32based_args[3]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, BootOptions_used, FieldsToChange_used); // NtSetBootOptions

	return ret_value;
}


NTSTATUS WINAPI _w32_NtTranslateFilePath(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PFILE_PATH InputFilePath_used = (PFILE_PATH)(x32based_args[2]); // PFILE_PATH  IN 
	ULONG OutputType_used = (ULONG)(x32based_args[3]); // ULONG  IN 
	PFILE_PATH OutputFilePath_used = (PFILE_PATH)(x32based_args[4]); // PFILE_PATH  OUT 
	PULONG OutputFilePathLength_used = (PULONG)(x32based_args[5]); // PULONG  IN  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 4, InputFilePath_used, OutputType_used, OutputFilePath_used, OutputFilePathLength_used); // NtTranslateFilePath

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAddDriverEntry(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PEFI_DRIVER_ENTRY DriverEntry_used = (PEFI_DRIVER_ENTRY)(x32based_args[2]); // PEFI_DRIVER_ENTRY  IN 
	PULONG Id_used = (PULONG)(x32based_args[3]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, DriverEntry_used, Id_used); // NtAddDriverEntry

	return ret_value;
}


NTSTATUS WINAPI _w32_NtDeleteDriverEntry(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	ULONG Id_used = (ULONG)(x32based_args[2]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, Id_used); // NtDeleteDriverEntry

	return ret_value;
}


NTSTATUS WINAPI _w32_NtModifyDriverEntry(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PEFI_DRIVER_ENTRY DriverEntry_used = (PEFI_DRIVER_ENTRY)(x32based_args[2]); // PEFI_DRIVER_ENTRY  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, DriverEntry_used); // NtModifyDriverEntry

	return ret_value;
}


NTSTATUS WINAPI _w32_NtEnumerateDriverEntries(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PVOID Buffer_used = (PVOID)(x32based_args[2]); // PVOID  OUT 
	PULONG BufferLength_used = (PULONG)(x32based_args[3]); // PULONG  IN  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, Buffer_used, BufferLength_used); // NtEnumerateDriverEntries

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryDriverEntryOrder(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PULONG Ids_used = (PULONG)(x32based_args[2]); // PULONG  OUT 
	PULONG Count_used = (PULONG)(x32based_args[3]); // PULONG  IN  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, Ids_used, Count_used); // NtQueryDriverEntryOrder

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetDriverEntryOrder(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PULONG Ids_used = (PULONG)(x32based_args[2]); // PULONG  IN 
	ULONG Count_used = (ULONG)(x32based_args[3]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, Ids_used, Count_used); // NtSetDriverEntryOrder

	return ret_value;
}


NTSTATUS WINAPI _w32_NtFilterBootOption(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	FILTER_BOOT_OPTION_OPERATION FilterOperation_used = (FILTER_BOOT_OPTION_OPERATION)(x32based_args[2]); // FILTER_BOOT_OPTION_OPERATION  IN 
	ULONG ObjectType_used = (ULONG)(x32based_args[3]); // ULONG  IN 
	ULONG ElementType_used = (ULONG)(x32based_args[4]); // ULONG  IN 
	PVOID Data_used = (PVOID)(x32based_args[5]); // PVOID  IN 
	ULONG DataSize_used = (ULONG)(x32based_args[6]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 5, FilterOperation_used, ObjectType_used, ElementType_used, Data_used, DataSize_used); // NtFilterBootOption

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateEvent(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_EventHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	EVENT_TYPE EventType_used = (EVENT_TYPE)(x32based_args[5]); // EVENT_TYPE  IN 
	BOOLEAN InitialState_used = (BOOLEAN)(x32based_args[6]); // BOOLEAN  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t EventHandle_holder[sizeof(PVOID)];
	PHANDLE EventHandle_used = (PHANDLE)&EventHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_EventHandle == NULL) {
		EventHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 5, EventHandle_used, DesiredAccess_used, ObjectAttributes_used, EventType_used, InitialState_used); // NtCreateEvent

	if (EventHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)EventHandle_used, x32based_EventHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtOpenEvent(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_EventHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t EventHandle_holder[sizeof(PVOID)];
	PHANDLE EventHandle_used = (PHANDLE)&EventHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_EventHandle == NULL) {
		EventHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, EventHandle_used, DesiredAccess_used, ObjectAttributes_used); // NtOpenEvent

	if (EventHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)EventHandle_used, x32based_EventHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetEvent(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_EventHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PLONG PreviousState_used = (PLONG)(x32based_args[3]); // PLONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE EventHandle_used = Handle32ToHandle((const void* __ptr32)x32based_EventHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, EventHandle_used, PreviousState_used); // NtSetEvent

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetEventBoostPriority(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_EventHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE EventHandle_used = Handle32ToHandle((const void* __ptr32)x32based_EventHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, EventHandle_used); // NtSetEventBoostPriority

	return ret_value;
}


NTSTATUS WINAPI _w32_NtClearEvent(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_EventHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE EventHandle_used = Handle32ToHandle((const void* __ptr32)x32based_EventHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, EventHandle_used); // NtClearEvent

	return ret_value;
}


NTSTATUS WINAPI _w32_NtResetEvent(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_EventHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PLONG PreviousState_used = (PLONG)(x32based_args[3]); // PLONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE EventHandle_used = Handle32ToHandle((const void* __ptr32)x32based_EventHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, EventHandle_used, PreviousState_used); // NtResetEvent

	return ret_value;
}


NTSTATUS WINAPI _w32_NtPulseEvent(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_EventHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PLONG PreviousState_used = (PLONG)(x32based_args[3]); // PLONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE EventHandle_used = Handle32ToHandle((const void* __ptr32)x32based_EventHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, EventHandle_used, PreviousState_used); // NtPulseEvent

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryEvent(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_EventHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	EVENT_INFORMATION_CLASS EventInformationClass_used = (EVENT_INFORMATION_CLASS)(x32based_args[3]); // EVENT_INFORMATION_CLASS  IN 
	PVOID EventInformation_used = (PVOID)(x32based_args[4]); // PVOID  IN  OUT 
	ULONG EventInformationLength_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	PULONG ReturnLength_used = (PULONG)(x32based_args[6]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE EventHandle_used = Handle32ToHandle((const void* __ptr32)x32based_EventHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 5, EventHandle_used, EventInformationClass_used, EventInformation_used, EventInformationLength_used, ReturnLength_used); // NtQueryEvent

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateEventPair(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_EventPairHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t EventPairHandle_holder[sizeof(PVOID)];
	PHANDLE EventPairHandle_used = (PHANDLE)&EventPairHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_EventPairHandle == NULL) {
		EventPairHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, EventPairHandle_used, DesiredAccess_used, ObjectAttributes_used); // NtCreateEventPair

	if (EventPairHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)EventPairHandle_used, x32based_EventPairHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtOpenEventPair(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_EventPairHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t EventPairHandle_holder[sizeof(PVOID)];
	PHANDLE EventPairHandle_used = (PHANDLE)&EventPairHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_EventPairHandle == NULL) {
		EventPairHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, EventPairHandle_used, DesiredAccess_used, ObjectAttributes_used); // NtOpenEventPair

	if (EventPairHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)EventPairHandle_used, x32based_EventPairHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetLowEventPair(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_EventPairHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE EventPairHandle_used = Handle32ToHandle((const void* __ptr32)x32based_EventPairHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, EventPairHandle_used); // NtSetLowEventPair

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetHighEventPair(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_EventPairHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE EventPairHandle_used = Handle32ToHandle((const void* __ptr32)x32based_EventPairHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, EventPairHandle_used); // NtSetHighEventPair

	return ret_value;
}


NTSTATUS WINAPI _w32_NtWaitLowEventPair(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_EventPairHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE EventPairHandle_used = Handle32ToHandle((const void* __ptr32)x32based_EventPairHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, EventPairHandle_used); // NtWaitLowEventPair

	return ret_value;
}


NTSTATUS WINAPI _w32_NtWaitHighEventPair(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_EventPairHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE EventPairHandle_used = Handle32ToHandle((const void* __ptr32)x32based_EventPairHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, EventPairHandle_used); // NtWaitHighEventPair

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetLowWaitHighEventPair(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_EventPairHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE EventPairHandle_used = Handle32ToHandle((const void* __ptr32)x32based_EventPairHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, EventPairHandle_used); // NtSetLowWaitHighEventPair

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetHighWaitLowEventPair(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_EventPairHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE EventPairHandle_used = Handle32ToHandle((const void* __ptr32)x32based_EventPairHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, EventPairHandle_used); // NtSetHighWaitLowEventPair

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateMutant(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_MutantHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	BOOLEAN InitialOwner_used = (BOOLEAN)(x32based_args[5]); // BOOLEAN  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t MutantHandle_holder[sizeof(PVOID)];
	PHANDLE MutantHandle_used = (PHANDLE)&MutantHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_MutantHandle == NULL) {
		MutantHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, MutantHandle_used, DesiredAccess_used, ObjectAttributes_used, InitialOwner_used); // NtCreateMutant

	if (MutantHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)MutantHandle_used, x32based_MutantHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtOpenMutant(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_MutantHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t MutantHandle_holder[sizeof(PVOID)];
	PHANDLE MutantHandle_used = (PHANDLE)&MutantHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_MutantHandle == NULL) {
		MutantHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, MutantHandle_used, DesiredAccess_used, ObjectAttributes_used); // NtOpenMutant

	if (MutantHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)MutantHandle_used, x32based_MutantHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtReleaseMutant(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_MutantHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PLONG PreviousCount_used = (PLONG)(x32based_args[3]); // PLONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE MutantHandle_used = Handle32ToHandle((const void* __ptr32)x32based_MutantHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, MutantHandle_used, PreviousCount_used); // NtReleaseMutant

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryMutant(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_MutantHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	MUTANT_INFORMATION_CLASS MutantInformationClass_used = (MUTANT_INFORMATION_CLASS)(x32based_args[3]); // MUTANT_INFORMATION_CLASS  IN 
	PVOID MutantInformation_used = (PVOID)(x32based_args[4]); // PVOID  IN  OUT 
	ULONG MutantInformationLength_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	PULONG ReturnLength_used = (PULONG)(x32based_args[6]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE MutantHandle_used = Handle32ToHandle((const void* __ptr32)x32based_MutantHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 5, MutantHandle_used, MutantInformationClass_used, MutantInformation_used, MutantInformationLength_used, ReturnLength_used); // NtQueryMutant

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateSemaphore(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_SemaphoreHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	LONG InitialCount_used = (LONG)(x32based_args[5]); // LONG  IN 
	LONG MaximumCount_used = (LONG)(x32based_args[6]); // LONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SemaphoreHandle_holder[sizeof(PVOID)];
	PHANDLE SemaphoreHandle_used = (PHANDLE)&SemaphoreHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_SemaphoreHandle == NULL) {
		SemaphoreHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 5, SemaphoreHandle_used, DesiredAccess_used, ObjectAttributes_used, InitialCount_used, MaximumCount_used); // NtCreateSemaphore

	if (SemaphoreHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)SemaphoreHandle_used, x32based_SemaphoreHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtOpenSemaphore(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_SemaphoreHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SemaphoreHandle_holder[sizeof(PVOID)];
	PHANDLE SemaphoreHandle_used = (PHANDLE)&SemaphoreHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_SemaphoreHandle == NULL) {
		SemaphoreHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, SemaphoreHandle_used, DesiredAccess_used, ObjectAttributes_used); // NtOpenSemaphore

	if (SemaphoreHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)SemaphoreHandle_used, x32based_SemaphoreHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtReleaseSemaphore(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_SemaphoreHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	LONG ReleaseCount_used = (LONG)(x32based_args[3]); // LONG  IN 
	PLONG PreviousCount_used = (PLONG)(x32based_args[4]); // PLONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE SemaphoreHandle_used = Handle32ToHandle((const void* __ptr32)x32based_SemaphoreHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 3, SemaphoreHandle_used, ReleaseCount_used, PreviousCount_used); // NtReleaseSemaphore

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQuerySemaphore(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_SemaphoreHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass_used = (SEMAPHORE_INFORMATION_CLASS)(x32based_args[3]); // SEMAPHORE_INFORMATION_CLASS  IN 
	PVOID SemaphoreInformation_used = (PVOID)(x32based_args[4]); // PVOID  IN  OUT 
	ULONG SemaphoreInformationLength_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	PULONG ReturnLength_used = (PULONG)(x32based_args[6]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE SemaphoreHandle_used = Handle32ToHandle((const void* __ptr32)x32based_SemaphoreHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 5, SemaphoreHandle_used, SemaphoreInformationClass_used, SemaphoreInformation_used, SemaphoreInformationLength_used, ReturnLength_used); // NtQuerySemaphore

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateTimer(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TimerHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	TIMER_TYPE TimerType_used = (TIMER_TYPE)(x32based_args[5]); // TIMER_TYPE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t TimerHandle_holder[sizeof(PVOID)];
	PHANDLE TimerHandle_used = (PHANDLE)&TimerHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_TimerHandle == NULL) {
		TimerHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, TimerHandle_used, DesiredAccess_used, ObjectAttributes_used, TimerType_used); // NtCreateTimer

	if (TimerHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)TimerHandle_used, x32based_TimerHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtOpenTimer(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TimerHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t TimerHandle_holder[sizeof(PVOID)];
	PHANDLE TimerHandle_used = (PHANDLE)&TimerHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_TimerHandle == NULL) {
		TimerHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, TimerHandle_used, DesiredAccess_used, ObjectAttributes_used); // NtOpenTimer

	if (TimerHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)TimerHandle_used, x32based_TimerHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetTimer(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TimerHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PLARGE_INTEGER DueTime_used = (PLARGE_INTEGER)(x32based_args[3]); // PLARGE_INTEGER  IN 
	PTIMER_APC_ROUTINE TimerApcRoutine_used = (PTIMER_APC_ROUTINE)(x32based_args[4]); // PTIMER_APC_ROUTINE  IN 
	PVOID TimerContext_used = (PVOID)(x32based_args[5]); // PVOID  IN 
	BOOLEAN ResumeTimer_used = (BOOLEAN)(x32based_args[6]); // BOOLEAN  IN 
	LONG Period_used = (LONG)(x32based_args[7]); // LONG  IN 
	PBOOLEAN PreviousState_used = (PBOOLEAN)(x32based_args[8]); // PBOOLEAN  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE TimerHandle_used = Handle32ToHandle((const void* __ptr32)x32based_TimerHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 7, TimerHandle_used, DueTime_used, TimerApcRoutine_used, TimerContext_used, ResumeTimer_used, Period_used, PreviousState_used); // NtSetTimer

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetTimerEx(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TimerHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	TIMER_SET_INFORMATION_CLASS TimerSetInformationClass_used = (TIMER_SET_INFORMATION_CLASS)(x32based_args[3]); // TIMER_SET_INFORMATION_CLASS  IN 
	PVOID TimerSetInformation_used = (PVOID)(x32based_args[4]); // PVOID  IN  OUT 
	ULONG TimerSetInformationLength_used = (ULONG)(x32based_args[5]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE TimerHandle_used = Handle32ToHandle((const void* __ptr32)x32based_TimerHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 4, TimerHandle_used, TimerSetInformationClass_used, TimerSetInformation_used, TimerSetInformationLength_used); // NtSetTimerEx

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCancelTimer(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TimerHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PBOOLEAN CurrentState_used = (PBOOLEAN)(x32based_args[3]); // PBOOLEAN  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE TimerHandle_used = Handle32ToHandle((const void* __ptr32)x32based_TimerHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, TimerHandle_used, CurrentState_used); // NtCancelTimer

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryTimer(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TimerHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	TIMER_INFORMATION_CLASS TimerInformationClass_used = (TIMER_INFORMATION_CLASS)(x32based_args[3]); // TIMER_INFORMATION_CLASS  IN 
	PVOID TimerInformation_used = (PVOID)(x32based_args[4]); // PVOID  IN  OUT 
	ULONG TimerInformationLength_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	PULONG ReturnLength_used = (PULONG)(x32based_args[6]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE TimerHandle_used = Handle32ToHandle((const void* __ptr32)x32based_TimerHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 5, TimerHandle_used, TimerInformationClass_used, TimerInformation_used, TimerInformationLength_used, ReturnLength_used); // NtQueryTimer

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateIRTimer(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TimerHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t TimerHandle_holder[sizeof(PVOID)];
	PHANDLE TimerHandle_used = (PHANDLE)&TimerHandle_holder;

	// Convert parameters from x32 to x64
	if (x32based_TimerHandle == NULL) {
		TimerHandle_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 2, TimerHandle_used, DesiredAccess_used); // NtCreateIRTimer

	if (TimerHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)TimerHandle_used, x32based_TimerHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetIRTimer(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TimerHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PLARGE_INTEGER DueTime_used = (PLARGE_INTEGER)(x32based_args[3]); // PLARGE_INTEGER  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE TimerHandle_used = Handle32ToHandle((const void* __ptr32)x32based_TimerHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, TimerHandle_used, DueTime_used); // NtSetIRTimer

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateTimer2(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TimerHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	PVOID Reserved1_used = (PVOID)(x32based_args[3]); // PVOID  IN 
	PVOID Reserved2_used = (PVOID)(x32based_args[4]); // PVOID  IN 
	ULONG Attributes_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[6]); // ACCESS_MASK  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t TimerHandle_holder[sizeof(PVOID)];
	PHANDLE TimerHandle_used = (PHANDLE)&TimerHandle_holder;

	// Convert parameters from x32 to x64
	if (x32based_TimerHandle == NULL) {
		TimerHandle_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 5, TimerHandle_used, Reserved1_used, Reserved2_used, Attributes_used, DesiredAccess_used); // NtCreateTimer2

	if (TimerHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)TimerHandle_used, x32based_TimerHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetTimer2(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TimerHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PLARGE_INTEGER DueTime_used = (PLARGE_INTEGER)(x32based_args[3]); // PLARGE_INTEGER  IN 
	PLARGE_INTEGER Period_used = (PLARGE_INTEGER)(x32based_args[4]); // PLARGE_INTEGER  IN 
	PT2_SET_PARAMETERS Parameters_used = (PT2_SET_PARAMETERS)(x32based_args[5]); // PT2_SET_PARAMETERS  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE TimerHandle_used = Handle32ToHandle((const void* __ptr32)x32based_TimerHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 4, TimerHandle_used, DueTime_used, Period_used, Parameters_used); // NtSetTimer2

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCancelTimer2(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TimerHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PT2_CANCEL_PARAMETERS Parameters_used = (PT2_CANCEL_PARAMETERS)(x32based_args[3]); // PT2_CANCEL_PARAMETERS  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE TimerHandle_used = Handle32ToHandle((const void* __ptr32)x32based_TimerHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, TimerHandle_used, Parameters_used); // NtCancelTimer2

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateProfile(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProfileHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	uint32_t x32based_Process = (uint32_t)(x32based_args[3]); // HANDLE  IN 
	PVOID ProfileBase_used = (PVOID)(x32based_args[4]); // PVOID  IN 
	SIZE_T ProfileSize_used = (SIZE_T)(x32based_args[5]); // SIZE_T  IN 
	ULONG BucketSize_used = (ULONG)(x32based_args[6]); // ULONG  IN 
	PULONG Buffer_used = (PULONG)(x32based_args[7]); // PULONG  IN 
	ULONG BufferSize_used = (ULONG)(x32based_args[8]); // ULONG  IN 
	KPROFILE_SOURCE ProfileSource_used = (KPROFILE_SOURCE)(x32based_args[9]); // KPROFILE_SOURCE  IN 
	uint32_t x32based_Affinity = (uint32_t)(x32based_args[10]); // KAFFINITY  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ProfileHandle_holder[sizeof(PVOID)];
	PHANDLE ProfileHandle_used = (PHANDLE)&ProfileHandle_holder;
	HANDLE Process_used = Handle32ToHandle((const void* __ptr32)x32based_Process);
	uint8_t Affinity_holder[sizeof(long long unsigned int)];
	KAFFINITY Affinity_used = (KAFFINITY)&Affinity_holder;

	// Convert parameters from x32 to x64
	if (x32based_ProfileHandle == NULL) {
		ProfileHandle_used = 0;
	}
	if (x32based_Affinity != NULL) {
		*((SIZE_T*)Affinity_holder) = (SIZE_T)(*((X32_SIZE_T*)x32based_Affinity));
	}
	else {
		Affinity_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 9, ProfileHandle_used, Process_used, ProfileBase_used, ProfileSize_used, BucketSize_used, Buffer_used, BufferSize_used, ProfileSource_used, Affinity_used); // NtCreateProfile

	if (ProfileHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)ProfileHandle_used, x32based_ProfileHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateProfileEx(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProfileHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	uint32_t x32based_Process = (uint32_t)(x32based_args[3]); // HANDLE  IN 
	PVOID ProfileBase_used = (PVOID)(x32based_args[4]); // PVOID  IN 
	SIZE_T ProfileSize_used = (SIZE_T)(x32based_args[5]); // SIZE_T  IN 
	ULONG BucketSize_used = (ULONG)(x32based_args[6]); // ULONG  IN 
	PULONG Buffer_used = (PULONG)(x32based_args[7]); // PULONG  IN 
	ULONG BufferSize_used = (ULONG)(x32based_args[8]); // ULONG  IN 
	KPROFILE_SOURCE ProfileSource_used = (KPROFILE_SOURCE)(x32based_args[9]); // KPROFILE_SOURCE  IN 
	USHORT GroupCount_used = (USHORT)(x32based_args[10]); // USHORT  IN 
	uint32_t x32based_GroupAffinity = (uint32_t)(x32based_args[11]); // PGROUP_AFFINITY  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ProfileHandle_holder[sizeof(PVOID)];
	PHANDLE ProfileHandle_used = (PHANDLE)&ProfileHandle_holder;
	HANDLE Process_used = Handle32ToHandle((const void* __ptr32)x32based_Process);
	uint8_t GroupAffinity_holder[sizeof(_GROUP_AFFINITY)];
	PGROUP_AFFINITY GroupAffinity_used = (PGROUP_AFFINITY)&GroupAffinity_holder;

	// Convert parameters from x32 to x64
	if (x32based_ProfileHandle == NULL) {
		ProfileHandle_used = 0;
	}
	if (x32based_GroupAffinity != NULL) {
		convert__GROUP_AFFINITY_32TO64(ctx, (_GROUP_AFFINITY**)&GroupAffinity_used, x32based_GroupAffinity);
	}
	else {
		GroupAffinity_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 10, ProfileHandle_used, Process_used, ProfileBase_used, ProfileSize_used, BucketSize_used, Buffer_used, BufferSize_used, ProfileSource_used, GroupCount_used, GroupAffinity_used); // NtCreateProfileEx

	if (ProfileHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)ProfileHandle_used, x32based_ProfileHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtStartProfile(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProfileHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProfileHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProfileHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, ProfileHandle_used); // NtStartProfile

	return ret_value;
}


NTSTATUS WINAPI _w32_NtStopProfile(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProfileHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProfileHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProfileHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, ProfileHandle_used); // NtStopProfile

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryIntervalProfile(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	KPROFILE_SOURCE ProfileSource_used = (KPROFILE_SOURCE)(x32based_args[2]); // KPROFILE_SOURCE  IN 
	PULONG Interval_used = (PULONG)(x32based_args[3]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, ProfileSource_used, Interval_used); // NtQueryIntervalProfile

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetIntervalProfile(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	ULONG Interval_used = (ULONG)(x32based_args[2]); // ULONG  IN 
	KPROFILE_SOURCE Source_used = (KPROFILE_SOURCE)(x32based_args[3]); // KPROFILE_SOURCE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, Interval_used, Source_used); // NtSetIntervalProfile

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateKeyedEvent(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_KeyedEventHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	ULONG Flags_used = (ULONG)(x32based_args[5]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t KeyedEventHandle_holder[sizeof(PVOID)];
	PHANDLE KeyedEventHandle_used = (PHANDLE)&KeyedEventHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_KeyedEventHandle == NULL) {
		KeyedEventHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, KeyedEventHandle_used, DesiredAccess_used, ObjectAttributes_used, Flags_used); // NtCreateKeyedEvent

	if (KeyedEventHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)KeyedEventHandle_used, x32based_KeyedEventHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtOpenKeyedEvent(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_KeyedEventHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t KeyedEventHandle_holder[sizeof(PVOID)];
	PHANDLE KeyedEventHandle_used = (PHANDLE)&KeyedEventHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_KeyedEventHandle == NULL) {
		KeyedEventHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, KeyedEventHandle_used, DesiredAccess_used, ObjectAttributes_used); // NtOpenKeyedEvent

	if (KeyedEventHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)KeyedEventHandle_used, x32based_KeyedEventHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtReleaseKeyedEvent(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_KeyedEventHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PVOID KeyValue_used = (PVOID)(x32based_args[3]); // PVOID  IN 
	BOOLEAN Alertable_used = (BOOLEAN)(x32based_args[4]); // BOOLEAN  IN 
	PLARGE_INTEGER Timeout_used = (PLARGE_INTEGER)(x32based_args[5]); // PLARGE_INTEGER  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE KeyedEventHandle_used = Handle32ToHandle((const void* __ptr32)x32based_KeyedEventHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 4, KeyedEventHandle_used, KeyValue_used, Alertable_used, Timeout_used); // NtReleaseKeyedEvent

	return ret_value;
}


NTSTATUS WINAPI _w32_NtWaitForKeyedEvent(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_KeyedEventHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PVOID KeyValue_used = (PVOID)(x32based_args[3]); // PVOID  IN 
	BOOLEAN Alertable_used = (BOOLEAN)(x32based_args[4]); // BOOLEAN  IN 
	PLARGE_INTEGER Timeout_used = (PLARGE_INTEGER)(x32based_args[5]); // PLARGE_INTEGER  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE KeyedEventHandle_used = Handle32ToHandle((const void* __ptr32)x32based_KeyedEventHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 4, KeyedEventHandle_used, KeyValue_used, Alertable_used, Timeout_used); // NtWaitForKeyedEvent

	return ret_value;
}


NTSTATUS WINAPI _w32_NtUmsThreadYield(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PVOID SchedulerParam_used = (PVOID)(x32based_args[2]); // PVOID  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, SchedulerParam_used); // NtUmsThreadYield

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateWnfStateName(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PWNF_STATE_NAME StateName_used = (PWNF_STATE_NAME)(x32based_args[2]); // PWNF_STATE_NAME  OUT 
	WNF_STATE_NAME_LIFETIME NameLifetime_used = (WNF_STATE_NAME_LIFETIME)(x32based_args[3]); // WNF_STATE_NAME_LIFETIME  IN 
	WNF_DATA_SCOPE DataScope_used = (WNF_DATA_SCOPE)(x32based_args[4]); // WNF_DATA_SCOPE  IN 
	BOOLEAN PersistData_used = (BOOLEAN)(x32based_args[5]); // BOOLEAN  IN 
	PCWNF_TYPE_ID TypeId_used = (PCWNF_TYPE_ID)(x32based_args[6]); // PCWNF_TYPE_ID  IN 
	ULONG MaximumStateSize_used = (ULONG)(x32based_args[7]); // ULONG  IN 
	uint32_t x32based_SecurityDescriptor = (uint32_t)(x32based_args[8]); // PSECURITY_DESCRIPTOR  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SecurityDescriptor_holder[sizeof(PVOID)];
	PSECURITY_DESCRIPTOR SecurityDescriptor_used = (PSECURITY_DESCRIPTOR)&SecurityDescriptor_holder;

	// Convert parameters from x32 to x64
	if (x32based_SecurityDescriptor != NULL) {
		convert_HANDLE_32TO64(ctx, (HANDLE**)&SecurityDescriptor_used, x32based_SecurityDescriptor);
	}
	else {
		SecurityDescriptor_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 7, StateName_used, NameLifetime_used, DataScope_used, PersistData_used, TypeId_used, MaximumStateSize_used, SecurityDescriptor_used); // NtCreateWnfStateName

	return ret_value;
}


NTSTATUS WINAPI _w32_NtDeleteWnfStateName(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PCWNF_STATE_NAME StateName_used = (PCWNF_STATE_NAME)(x32based_args[2]); // PCWNF_STATE_NAME  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, StateName_used); // NtDeleteWnfStateName

	return ret_value;
}


NTSTATUS WINAPI _w32_NtUpdateWnfStateData(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PCWNF_STATE_NAME StateName_used = (PCWNF_STATE_NAME)(x32based_args[2]); // PCWNF_STATE_NAME  IN 
	void const* Buffer_used = (void const*)(x32based_args[3]); // void const *  IN 
	ULONG Length_used = (ULONG)(x32based_args[4]); // ULONG  IN 
	PCWNF_TYPE_ID TypeId_used = (PCWNF_TYPE_ID)(x32based_args[5]); // PCWNF_TYPE_ID  IN 
	void const* ExplicitScope_used = (void const*)(x32based_args[6]); // void const *  IN 
	WNF_CHANGE_STAMP MatchingChangeStamp_used = (WNF_CHANGE_STAMP)(x32based_args[7]); // WNF_CHANGE_STAMP  IN 
	LOGICAL CheckStamp_used = (LOGICAL)(x32based_args[8]); // LOGICAL  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 7, StateName_used, Buffer_used, Length_used, TypeId_used, ExplicitScope_used, MatchingChangeStamp_used, CheckStamp_used); // NtUpdateWnfStateData

	return ret_value;
}


NTSTATUS WINAPI _w32_NtDeleteWnfStateData(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PCWNF_STATE_NAME StateName_used = (PCWNF_STATE_NAME)(x32based_args[2]); // PCWNF_STATE_NAME  IN 
	void const* ExplicitScope_used = (void const*)(x32based_args[3]); // void const *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, StateName_used, ExplicitScope_used); // NtDeleteWnfStateData

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryWnfStateData(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PCWNF_STATE_NAME StateName_used = (PCWNF_STATE_NAME)(x32based_args[2]); // PCWNF_STATE_NAME  IN 
	PCWNF_TYPE_ID TypeId_used = (PCWNF_TYPE_ID)(x32based_args[3]); // PCWNF_TYPE_ID  IN 
	void const* ExplicitScope_used = (void const*)(x32based_args[4]); // void const *  IN 
	PWNF_CHANGE_STAMP ChangeStamp_used = (PWNF_CHANGE_STAMP)(x32based_args[5]); // PWNF_CHANGE_STAMP  OUT 
	PVOID Buffer_used = (PVOID)(x32based_args[6]); // PVOID  OUT 
	PULONG BufferSize_used = (PULONG)(x32based_args[7]); // PULONG  IN  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 6, StateName_used, TypeId_used, ExplicitScope_used, ChangeStamp_used, Buffer_used, BufferSize_used); // NtQueryWnfStateData

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryWnfStateNameInformation(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PCWNF_STATE_NAME StateName_used = (PCWNF_STATE_NAME)(x32based_args[2]); // PCWNF_STATE_NAME  IN 
	WNF_STATE_NAME_INFORMATION NameInfoClass_used = (WNF_STATE_NAME_INFORMATION)(x32based_args[3]); // WNF_STATE_NAME_INFORMATION  IN 
	void const* ExplicitScope_used = (void const*)(x32based_args[4]); // void const *  IN 
	PVOID InfoBuffer_used = (PVOID)(x32based_args[5]); // PVOID  IN  OUT 
	ULONG InfoBufferSize_used = (ULONG)(x32based_args[6]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 5, StateName_used, NameInfoClass_used, ExplicitScope_used, InfoBuffer_used, InfoBufferSize_used); // NtQueryWnfStateNameInformation

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSubscribeWnfStateChange(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PCWNF_STATE_NAME StateName_used = (PCWNF_STATE_NAME)(x32based_args[2]); // PCWNF_STATE_NAME  IN 
	WNF_CHANGE_STAMP ChangeStamp_used = (WNF_CHANGE_STAMP)(x32based_args[3]); // WNF_CHANGE_STAMP  IN 
	ULONG EventMask_used = (ULONG)(x32based_args[4]); // ULONG  IN 
	PULONG64 SubscriptionId_used = (PULONG64)(x32based_args[5]); // PULONG64  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 4, StateName_used, ChangeStamp_used, EventMask_used, SubscriptionId_used); // NtSubscribeWnfStateChange

	return ret_value;
}


NTSTATUS WINAPI _w32_NtUnsubscribeWnfStateChange(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PCWNF_STATE_NAME StateName_used = (PCWNF_STATE_NAME)(x32based_args[2]); // PCWNF_STATE_NAME  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, StateName_used); // NtUnsubscribeWnfStateChange

	return ret_value;
}


NTSTATUS WINAPI _w32_NtGetCompleteWnfStateSubscription(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PWNF_STATE_NAME OldDescriptorStateName_used = (PWNF_STATE_NAME)(x32based_args[2]); // PWNF_STATE_NAME  IN 
	ULONG64* OldSubscriptionId_used = (ULONG64*)(x32based_args[3]); // ULONG64 *  IN 
	ULONG OldDescriptorEventMask_used = (ULONG)(x32based_args[4]); // ULONG  IN 
	ULONG OldDescriptorStatus_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	PWNF_DELIVERY_DESCRIPTOR NewDeliveryDescriptor_used = (PWNF_DELIVERY_DESCRIPTOR)(x32based_args[6]); // PWNF_DELIVERY_DESCRIPTOR  OUT 
	ULONG DescriptorSize_used = (ULONG)(x32based_args[7]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 6, OldDescriptorStateName_used, OldSubscriptionId_used, OldDescriptorEventMask_used, OldDescriptorStatus_used, NewDeliveryDescriptor_used, DescriptorSize_used); // NtGetCompleteWnfStateSubscription

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetWnfProcessNotificationEvent(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_NotificationEvent = (uint32_t)(x32based_args[2]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE NotificationEvent_used = Handle32ToHandle((const void* __ptr32)x32based_NotificationEvent);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, NotificationEvent_used); // NtSetWnfProcessNotificationEvent

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateWorkerFactory(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_WorkerFactoryHandleReturn = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	uint32_t x32based_CompletionPortHandle = (uint32_t)(x32based_args[5]); // HANDLE  IN 
	uint32_t x32based_WorkerProcessHandle = (uint32_t)(x32based_args[6]); // HANDLE  IN 
	PVOID StartRoutine_used = (PVOID)(x32based_args[7]); // PVOID  IN 
	PVOID StartParameter_used = (PVOID)(x32based_args[8]); // PVOID  IN 
	ULONG MaxThreadCount_used = (ULONG)(x32based_args[9]); // ULONG  IN 
	SIZE_T StackReserve_used = (SIZE_T)(x32based_args[10]); // SIZE_T  IN 
	SIZE_T StackCommit_used = (SIZE_T)(x32based_args[11]); // SIZE_T  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t WorkerFactoryHandleReturn_holder[sizeof(PVOID)];
	PHANDLE WorkerFactoryHandleReturn_used = (PHANDLE)&WorkerFactoryHandleReturn_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;
	HANDLE CompletionPortHandle_used = Handle32ToHandle((const void* __ptr32)x32based_CompletionPortHandle);
	HANDLE WorkerProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_WorkerProcessHandle);

	// Convert parameters from x32 to x64
	if (x32based_WorkerFactoryHandleReturn == NULL) {
		WorkerFactoryHandleReturn_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 10, WorkerFactoryHandleReturn_used, DesiredAccess_used, ObjectAttributes_used, CompletionPortHandle_used, WorkerProcessHandle_used, StartRoutine_used, StartParameter_used, MaxThreadCount_used, StackReserve_used, StackCommit_used); // NtCreateWorkerFactory

	if (WorkerFactoryHandleReturn_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)WorkerFactoryHandleReturn_used, x32based_WorkerFactoryHandleReturn);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryInformationWorkerFactory(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_WorkerFactoryHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	WORKERFACTORYINFOCLASS WorkerFactoryInformationClass_used = (WORKERFACTORYINFOCLASS)(x32based_args[3]); // WORKERFACTORYINFOCLASS  IN 
	PVOID WorkerFactoryInformation_used = (PVOID)(x32based_args[4]); // PVOID  IN  OUT 
	ULONG WorkerFactoryInformationLength_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	PULONG ReturnLength_used = (PULONG)(x32based_args[6]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE WorkerFactoryHandle_used = Handle32ToHandle((const void* __ptr32)x32based_WorkerFactoryHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 5, WorkerFactoryHandle_used, WorkerFactoryInformationClass_used, WorkerFactoryInformation_used, WorkerFactoryInformationLength_used, ReturnLength_used); // NtQueryInformationWorkerFactory

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetInformationWorkerFactory(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_WorkerFactoryHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	WORKERFACTORYINFOCLASS WorkerFactoryInformationClass_used = (WORKERFACTORYINFOCLASS)(x32based_args[3]); // WORKERFACTORYINFOCLASS  IN 
	PVOID WorkerFactoryInformation_used = (PVOID)(x32based_args[4]); // PVOID  IN 
	ULONG WorkerFactoryInformationLength_used = (ULONG)(x32based_args[5]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE WorkerFactoryHandle_used = Handle32ToHandle((const void* __ptr32)x32based_WorkerFactoryHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 4, WorkerFactoryHandle_used, WorkerFactoryInformationClass_used, WorkerFactoryInformation_used, WorkerFactoryInformationLength_used); // NtSetInformationWorkerFactory

	return ret_value;
}


NTSTATUS WINAPI _w32_NtShutdownWorkerFactory(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_WorkerFactoryHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	LONG volatile* PendingWorkerCount_used = (LONG volatile*)(x32based_args[3]); // LONG volatile *  IN  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE WorkerFactoryHandle_used = Handle32ToHandle((const void* __ptr32)x32based_WorkerFactoryHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, WorkerFactoryHandle_used, PendingWorkerCount_used); // NtShutdownWorkerFactory

	return ret_value;
}


NTSTATUS WINAPI _w32_NtReleaseWorkerFactoryWorker(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_WorkerFactoryHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE WorkerFactoryHandle_used = Handle32ToHandle((const void* __ptr32)x32based_WorkerFactoryHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, WorkerFactoryHandle_used); // NtReleaseWorkerFactoryWorker

	return ret_value;
}


NTSTATUS WINAPI _w32_NtWorkerFactoryWorkerReady(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_WorkerFactoryHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE WorkerFactoryHandle_used = Handle32ToHandle((const void* __ptr32)x32based_WorkerFactoryHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, WorkerFactoryHandle_used); // NtWorkerFactoryWorkerReady

	return ret_value;
}


NTSTATUS WINAPI _w32_NtWaitForWorkViaWorkerFactory(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_WorkerFactoryHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_MiniPacket = (uint32_t)(x32based_args[3]); // _FILE_IO_COMPLETION_INFORMATION *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE WorkerFactoryHandle_used = Handle32ToHandle((const void* __ptr32)x32based_WorkerFactoryHandle);
	uint8_t MiniPacket_holder[sizeof(_FILE_IO_COMPLETION_INFORMATION)];
	_FILE_IO_COMPLETION_INFORMATION* MiniPacket_used = (_FILE_IO_COMPLETION_INFORMATION*)&MiniPacket_holder;

	// Convert parameters from x32 to x64
	if (x32based_MiniPacket == NULL) {
		MiniPacket_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 2, WorkerFactoryHandle_used, MiniPacket_used); // NtWaitForWorkViaWorkerFactory

	if (MiniPacket_used != NULL) {
		convert__FILE_IO_COMPLETION_INFORMATION_64TO32(ctx, (_FILE_IO_COMPLETION_INFORMATION*)MiniPacket_used, x32based_MiniPacket);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetSystemTime(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PLARGE_INTEGER SystemTime_used = (PLARGE_INTEGER)(x32based_args[2]); // PLARGE_INTEGER  IN 
	PLARGE_INTEGER PreviousTime_used = (PLARGE_INTEGER)(x32based_args[3]); // PLARGE_INTEGER  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, SystemTime_used, PreviousTime_used); // NtSetSystemTime

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryTimerResolution(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PULONG MaximumTime_used = (PULONG)(x32based_args[2]); // PULONG  OUT 
	PULONG MinimumTime_used = (PULONG)(x32based_args[3]); // PULONG  OUT 
	PULONG CurrentTime_used = (PULONG)(x32based_args[4]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 3, MaximumTime_used, MinimumTime_used, CurrentTime_used); // NtQueryTimerResolution

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetTimerResolution(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	ULONG DesiredTime_used = (ULONG)(x32based_args[2]); // ULONG  IN 
	BOOLEAN SetResolution_used = (BOOLEAN)(x32based_args[3]); // BOOLEAN  IN 
	PULONG ActualTime_used = (PULONG)(x32based_args[4]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 3, DesiredTime_used, SetResolution_used, ActualTime_used); // NtSetTimerResolution

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryPerformanceCounter(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PLARGE_INTEGER PerformanceCounter_used = (PLARGE_INTEGER)(x32based_args[2]); // PLARGE_INTEGER  OUT 
	PLARGE_INTEGER PerformanceFrequency_used = (PLARGE_INTEGER)(x32based_args[3]); // PLARGE_INTEGER  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, PerformanceCounter_used, PerformanceFrequency_used); // NtQueryPerformanceCounter

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAllocateLocallyUniqueId(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PLUID Luid_used = (PLUID)(x32based_args[2]); // PLUID  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, Luid_used); // NtAllocateLocallyUniqueId

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetUuidSeed(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PCHAR Seed_used = (PCHAR)(x32based_args[2]); // PCHAR  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, Seed_used); // NtSetUuidSeed

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAllocateUuids(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PULARGE_INTEGER Time_used = (PULARGE_INTEGER)(x32based_args[2]); // PULARGE_INTEGER  OUT 
	PULONG Range_used = (PULONG)(x32based_args[3]); // PULONG  OUT 
	PULONG Sequence_used = (PULONG)(x32based_args[4]); // PULONG  OUT 
	PCHAR Seed_used = (PCHAR)(x32based_args[5]); // PCHAR  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 4, Time_used, Range_used, Sequence_used, Seed_used); // NtAllocateUuids

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQuerySystemInformation(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	SYSTEM_INFORMATION_CLASS SystemInformationClass_used = (SYSTEM_INFORMATION_CLASS)(x32based_args[2]); // SYSTEM_INFORMATION_CLASS  IN 
	PVOID SystemInformation_used = (PVOID)(x32based_args[3]); // PVOID  IN  OUT 
	ULONG SystemInformationLength_used = (ULONG)(x32based_args[4]); // ULONG  IN 
	PULONG ReturnLength_used = (PULONG)(x32based_args[5]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	switch (SystemInformationClass_used) {
	case SystemBasicInformation: {
		ret_value = _w32_NtQuerySystemInformation_SystemBasicInformation(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_BASIC_INFORMATION*)SystemInformation_used, SystemInformationLength_used, ReturnLength_used);
		break;
	}
	case SystemProcessInformation: {
		ret_value = _w32_NtQuerySystemInformation_SystemProcessInformation(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_PROCESS_INFORMATION*)SystemInformation_used, SystemInformationLength_used, ReturnLength_used);
		break;
	}
	case SystemPagedPoolInformation: {
		ret_value = _w32_NtQuerySystemInformation_SystemPagedPoolInformation(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_POOL_INFORMATION*)SystemInformation_used, SystemInformationLength_used, ReturnLength_used);
		break;
	}
	case SystemNonPagedPoolInformation: {
		ret_value = _w32_NtQuerySystemInformation_SystemNonPagedPoolInformation(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_POOL_INFORMATION*)SystemInformation_used, SystemInformationLength_used, ReturnLength_used);
		break;
	}
	case SystemPageFileInformation: {
		ret_value = _w32_NtQuerySystemInformation_SystemPageFileInformation(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_PAGEFILE_INFORMATION*)SystemInformation_used, SystemInformationLength_used, ReturnLength_used);
		break;
	}
	case SystemFileCacheInformation: {
		ret_value = _w32_NtQuerySystemInformation_SystemFileCacheInformation(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_FILECACHE_INFORMATION*)SystemInformation_used, SystemInformationLength_used, ReturnLength_used);
		break;
	}
	case SystemRegistryQuotaInformation: {
		ret_value = _w32_NtQuerySystemInformation_SystemRegistryQuotaInformation(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_REGISTRY_QUOTA_INFORMATION*)SystemInformation_used, SystemInformationLength_used, ReturnLength_used);
		break;
	}
	case SystemLegacyDriverInformation: {
		ret_value = _w32_NtQuerySystemInformation_SystemLegacyDriverInformation(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_LEGACY_DRIVER_INFORMATION*)SystemInformation_used, SystemInformationLength_used, ReturnLength_used);
		break;
	}
	case SystemVerifierInformation: {
		ret_value = _w32_NtQuerySystemInformation_SystemVerifierInformation(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_VERIFIER_INFORMATION*)SystemInformation_used, SystemInformationLength_used, ReturnLength_used);
		break;
	}
	case SystemSessionProcessInformation: {
		ret_value = _w32_NtQuerySystemInformation_SystemSessionProcessInformation(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_SESSION_PROCESS_INFORMATION*)SystemInformation_used, SystemInformationLength_used, ReturnLength_used);
		break;
	}
	case SystemExtendedProcessInformation: {
		ret_value = _w32_NtQuerySystemInformation_SystemExtendedProcessInformation(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_PROCESS_INFORMATION*)SystemInformation_used, SystemInformationLength_used, ReturnLength_used);
		break;
	}
	case SystemEmulationBasicInformation: {
		ret_value = _w32_NtQuerySystemInformation_SystemEmulationBasicInformation(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_BASIC_INFORMATION*)SystemInformation_used, SystemInformationLength_used, ReturnLength_used);
		break;
	}
	case SystemExtendedHandleInformation: {
		ret_value = _w32_NtQuerySystemInformation_SystemExtendedHandleInformation(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_HANDLE_INFORMATION_EX*)SystemInformation_used, SystemInformationLength_used, ReturnLength_used);
		break;
	}
	case SystemSessionPoolTagInformation: {
		ret_value = _w32_NtQuerySystemInformation_SystemSessionPoolTagInformation(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_SESSION_POOLTAG_INFORMATION*)SystemInformation_used, SystemInformationLength_used, ReturnLength_used);
		break;
	}
	case SystemSessionMappedViewInformation: {
		ret_value = _w32_NtQuerySystemInformation_SystemSessionMappedViewInformation(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_SESSION_MAPPED_VIEW_INFORMATION*)SystemInformation_used, SystemInformationLength_used, ReturnLength_used);
		break;
	}
	case SystemRegisterFirmwareTableInformationHandler: {
		ret_value = _w32_NtQuerySystemInformation_SystemRegisterFirmwareTableInformationHandler(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_FIRMWARE_TABLE_HANDLER*)SystemInformation_used, SystemInformationLength_used, ReturnLength_used);
		break;
	}
	case SystemModuleInformationEx: {
		ret_value = _w32_NtQuerySystemInformation_SystemModuleInformationEx(ctx, syscall_idx, SystemInformationClass_used, (RTL_PROCESS_MODULE_INFORMATION_EX*)SystemInformation_used, SystemInformationLength_used, ReturnLength_used);
		break;
	}
	case SystemSuperfetchInformation: {
		ret_value = _w32_NtQuerySystemInformation_SystemSuperfetchInformation(ctx, syscall_idx, SystemInformationClass_used, (SUPERFETCH_INFORMATION*)SystemInformation_used, SystemInformationLength_used, ReturnLength_used);
		break;
	}
	case SystemMemoryListInformation: {
		ret_value = _w32_NtQuerySystemInformation_SystemMemoryListInformation(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_MEMORY_LIST_INFORMATION*)SystemInformation_used, SystemInformationLength_used, ReturnLength_used);
		break;
	}
	case SystemFileCacheInformationEx: {
		ret_value = _w32_NtQuerySystemInformation_SystemFileCacheInformationEx(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_FILECACHE_INFORMATION*)SystemInformation_used, SystemInformationLength_used, ReturnLength_used);
		break;
	}
	case SystemRefTraceInformation: {
		ret_value = _w32_NtQuerySystemInformation_SystemRefTraceInformation(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_REF_TRACE_INFORMATION*)SystemInformation_used, SystemInformationLength_used, ReturnLength_used);
		break;
	}
	case SystemProcessIdInformation: {
		ret_value = _w32_NtQuerySystemInformation_SystemProcessIdInformation(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_PROCESS_ID_INFORMATION*)SystemInformation_used, SystemInformationLength_used, ReturnLength_used);
		break;
	}
	case SystemVerifierInformationEx: {
		ret_value = _w32_NtQuerySystemInformation_SystemVerifierInformationEx(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_VERIFIER_INFORMATION_EX*)SystemInformation_used, SystemInformationLength_used, ReturnLength_used);
		break;
	}
	case SystemSystemPartitionInformation: {
		ret_value = _w32_NtQuerySystemInformation_SystemSystemPartitionInformation(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_SYSTEM_PARTITION_INFORMATION*)SystemInformation_used, SystemInformationLength_used, ReturnLength_used);
		break;
	}
	case SystemSystemDiskInformation: {
		ret_value = _w32_NtQuerySystemInformation_SystemSystemDiskInformation(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_SYSTEM_DISK_INFORMATION*)SystemInformation_used, SystemInformationLength_used, ReturnLength_used);
		break;
	}
	case SystemPagedPoolInformationEx: {
		ret_value = _w32_NtQuerySystemInformation_SystemPagedPoolInformationEx(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_FILECACHE_INFORMATION*)SystemInformation_used, SystemInformationLength_used, ReturnLength_used);
		break;
	}
	case SystemSystemPtesInformationEx: {
		ret_value = _w32_NtQuerySystemInformation_SystemSystemPtesInformationEx(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_FILECACHE_INFORMATION*)SystemInformation_used, SystemInformationLength_used, ReturnLength_used);
		break;
	}
	case SystemBasicPerformanceInformation: {
		ret_value = _w32_NtQuerySystemInformation_SystemBasicPerformanceInformation(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_BASIC_PERFORMANCE_INFORMATION*)SystemInformation_used, SystemInformationLength_used, ReturnLength_used);
		break;
	}
	case SystemPolicyInformation: {
		ret_value = _w32_NtQuerySystemInformation_SystemPolicyInformation(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_POLICY_INFORMATION*)SystemInformation_used, SystemInformationLength_used, ReturnLength_used);
		break;
	}
	case SystemManufacturingInformation: {
		ret_value = _w32_NtQuerySystemInformation_SystemManufacturingInformation(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_MANUFACTURING_INFORMATION*)SystemInformation_used, SystemInformationLength_used, ReturnLength_used);
		break;
	}
	case SystemActivityModerationUserSettings: {
		ret_value = _w32_NtQuerySystemInformation_SystemActivityModerationUserSettings(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS*)SystemInformation_used, SystemInformationLength_used, ReturnLength_used);
		break;
	}
	case SystemHypervisorSharedPageInformation: {
		ret_value = _w32_NtQuerySystemInformation_SystemHypervisorSharedPageInformation(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION*)SystemInformation_used, SystemInformationLength_used, ReturnLength_used);
		break;
	}
	default: {
		ret_value = __syscall64(syscall_idx, 4, SystemInformationClass_used, SystemInformation_used, SystemInformationLength_used, ReturnLength_used); // NtQuerySystemInformation
		break;
	}
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQuerySystemInformationEx(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	SYSTEM_INFORMATION_CLASS SystemInformationClass_used = (SYSTEM_INFORMATION_CLASS)(x32based_args[2]); // SYSTEM_INFORMATION_CLASS  IN 
	PVOID InputBuffer_used = (PVOID)(x32based_args[3]); // PVOID  IN 
	ULONG InputBufferLength_used = (ULONG)(x32based_args[4]); // ULONG  IN 
	PVOID SystemInformation_used = (PVOID)(x32based_args[5]); // PVOID  IN  OUT 
	ULONG SystemInformationLength_used = (ULONG)(x32based_args[6]); // ULONG  IN 
	PULONG ReturnLength_used = (PULONG)(x32based_args[7]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	switch (SystemInformationClass_used) {
	case SystemLogicalProcessorInformation: {
		ret_value = _w32_NtQuerySystemInformationEx_SystemLogicalProcessorInformation(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_LOGICAL_PROCESSOR_INFORMATION*)InputBuffer_used, InputBufferLength_used, SystemInformation_used, SystemInformationLength_used, ReturnLength_used);
		break;
	}
	case SystemLogicalProcessorAndGroupInformation: {
		ret_value = _w32_NtQuerySystemInformationEx_SystemLogicalProcessorAndGroupInformation(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX*)InputBuffer_used, InputBufferLength_used, SystemInformation_used, SystemInformationLength_used, ReturnLength_used);
		break;
	}
	case SystemFeatureConfigurationInformation: {
		ret_value = _w32_NtQuerySystemInformationEx_SystemFeatureConfigurationInformation(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_FEATURE_CONFIGURATION_INFORMATION*)InputBuffer_used, InputBufferLength_used, SystemInformation_used, SystemInformationLength_used, ReturnLength_used);
		break;
	}
	default: {
		ret_value = __syscall64(syscall_idx, 6, SystemInformationClass_used, InputBuffer_used, InputBufferLength_used, SystemInformation_used, SystemInformationLength_used, ReturnLength_used); // NtQuerySystemInformationEx
		break;
	}
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetSystemInformation(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	SYSTEM_INFORMATION_CLASS SystemInformationClass_used = (SYSTEM_INFORMATION_CLASS)(x32based_args[2]); // SYSTEM_INFORMATION_CLASS  IN 
	PVOID SystemInformation_used = (PVOID)(x32based_args[3]); // PVOID  IN 
	ULONG SystemInformationLength_used = (ULONG)(x32based_args[4]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	switch (SystemInformationClass_used) {
	case SystemPagedPoolInformation: {
		ret_value = _w32_NtSetSystemInformation_SystemPagedPoolInformation(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_POOL_INFORMATION*)SystemInformation_used, SystemInformationLength_used);
		break;
	}
	case SystemRegistryQuotaInformation: {
		ret_value = _w32_NtSetSystemInformation_SystemRegistryQuotaInformation(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_REGISTRY_QUOTA_INFORMATION*)SystemInformation_used, SystemInformationLength_used);
		break;
	}
	case SystemExtendServiceTableInformation: {
		ret_value = _w32_NtSetSystemInformation_SystemExtendServiceTableInformation(ctx, syscall_idx, SystemInformationClass_used, (UNICODE_STRING*)SystemInformation_used, SystemInformationLength_used);
		break;
	}
	case SystemVerifierInformation: {
		ret_value = _w32_NtSetSystemInformation_SystemVerifierInformation(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_VERIFIER_INFORMATION*)SystemInformation_used, SystemInformationLength_used);
		break;
	}
	case SystemThreadPriorityClientIdInformation: {
		ret_value = _w32_NtSetSystemInformation_SystemThreadPriorityClientIdInformation(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_THREAD_CID_PRIORITY_INFORMATION*)SystemInformation_used, SystemInformationLength_used);
		break;
	}
	case SystemRefTraceInformation: {
		ret_value = _w32_NtSetSystemInformation_SystemRefTraceInformation(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_REF_TRACE_INFORMATION*)SystemInformation_used, SystemInformationLength_used);
		break;
	}
	case SystemVerifierInformationEx: {
		ret_value = _w32_NtSetSystemInformation_SystemVerifierInformationEx(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_VERIFIER_INFORMATION_EX*)SystemInformation_used, SystemInformationLength_used);
		break;
	}
	case SystemVerifierFaultsInformation: {
		ret_value = _w32_NtSetSystemInformation_SystemVerifierFaultsInformation(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_VERIFIER_FAULTS_INFORMATION*)SystemInformation_used, SystemInformationLength_used);
		break;
	}
	case SystemRegistryAppendString: {
		ret_value = _w32_NtSetSystemInformation_SystemRegistryAppendString(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS*)SystemInformation_used, SystemInformationLength_used);
		break;
	}
	case SystemPagedPoolInformationEx: {
		ret_value = _w32_NtSetSystemInformation_SystemPagedPoolInformationEx(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_FILECACHE_INFORMATION*)SystemInformation_used, SystemInformationLength_used);
		break;
	}
	case SystemPolicyInformation: {
		ret_value = _w32_NtSetSystemInformation_SystemPolicyInformation(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_POLICY_INFORMATION*)SystemInformation_used, SystemInformationLength_used);
		break;
	}
	case SystemElamCertificateInformation: {
		ret_value = _w32_NtSetSystemInformation_SystemElamCertificateInformation(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_ELAM_CERTIFICATE_INFORMATION*)SystemInformation_used, SystemInformationLength_used);
		break;
	}
	case SystemActivityModerationExeState: {
		ret_value = _w32_NtSetSystemInformation_SystemActivityModerationExeState(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_ACTIVITY_MODERATION_EXE_STATE*)SystemInformation_used, SystemInformationLength_used);
		break;
	}
	case SystemFeatureConfigurationInformation: {
		ret_value = _w32_NtSetSystemInformation_SystemFeatureConfigurationInformation(ctx, syscall_idx, SystemInformationClass_used, (SYSTEM_FEATURE_CONFIGURATION_INFORMATION*)SystemInformation_used, SystemInformationLength_used);
		break;
	}
	default: {
		ret_value = __syscall64(syscall_idx, 3, SystemInformationClass_used, SystemInformation_used, SystemInformationLength_used); // NtSetSystemInformation
		break;
	}
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSystemDebugControl(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	SYSDBG_COMMAND Command_used = (SYSDBG_COMMAND)(x32based_args[2]); // SYSDBG_COMMAND  IN 
	PVOID InputBuffer_used = (PVOID)(x32based_args[3]); // PVOID  IN  OUT 
	ULONG InputBufferLength_used = (ULONG)(x32based_args[4]); // ULONG  IN 
	PVOID OutputBuffer_used = (PVOID)(x32based_args[5]); // PVOID  OUT 
	ULONG OutputBufferLength_used = (ULONG)(x32based_args[6]); // ULONG  IN 
	PULONG ReturnLength_used = (PULONG)(x32based_args[7]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 6, Command_used, InputBuffer_used, InputBufferLength_used, OutputBuffer_used, OutputBufferLength_used, ReturnLength_used); // NtSystemDebugControl

	return ret_value;
}


NTSTATUS WINAPI _w32_NtRaiseHardError(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	NTSTATUS ErrorStatus_used = (NTSTATUS)(x32based_args[2]); // NTSTATUS  IN 
	ULONG NumberOfParameters_used = (ULONG)(x32based_args[3]); // ULONG  IN 
	ULONG UnicodeStringParameterMask_used = (ULONG)(x32based_args[4]); // ULONG  IN 
	uint32_t x32based_Parameters = (uint32_t)(x32based_args[5]); // PULONG_PTR  IN 
	ULONG ValidResponseOptions_used = (ULONG)(x32based_args[6]); // ULONG  IN 
	PULONG Response_used = (PULONG)(x32based_args[7]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t Parameters_holder[sizeof(long long unsigned int)];
	PULONG_PTR Parameters_used = (PULONG_PTR)&Parameters_holder;

	// Convert parameters from x32 to x64
	if (x32based_Parameters != NULL) {
		*((SIZE_T*)Parameters_holder) = (SIZE_T)(*((X32_SIZE_T*)x32based_Parameters));
	}
	else {
		Parameters_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 6, ErrorStatus_used, NumberOfParameters_used, UnicodeStringParameterMask_used, Parameters_used, ValidResponseOptions_used, Response_used); // NtRaiseHardError

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryDefaultLocale(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	BOOLEAN UserProfile_used = (BOOLEAN)(x32based_args[2]); // BOOLEAN  IN 
	PLCID DefaultLocaleId_used = (PLCID)(x32based_args[3]); // PLCID  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, UserProfile_used, DefaultLocaleId_used); // NtQueryDefaultLocale

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetDefaultLocale(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	BOOLEAN UserProfile_used = (BOOLEAN)(x32based_args[2]); // BOOLEAN  IN 
	LCID DefaultLocaleId_used = (LCID)(x32based_args[3]); // LCID  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, UserProfile_used, DefaultLocaleId_used); // NtSetDefaultLocale

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryInstallUILanguage(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	LANGID* InstallUILanguageId_used = (LANGID*)(x32based_args[2]); // LANGID *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, InstallUILanguageId_used); // NtQueryInstallUILanguage

	return ret_value;
}


NTSTATUS WINAPI _w32_NtFlushInstallUILanguage(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	LANGID InstallUILanguage_used = (LANGID)(x32based_args[2]); // LANGID  IN 
	ULONG SetComittedFlag_used = (ULONG)(x32based_args[3]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, InstallUILanguage_used, SetComittedFlag_used); // NtFlushInstallUILanguage

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryDefaultUILanguage(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	LANGID* DefaultUILanguageId_used = (LANGID*)(x32based_args[2]); // LANGID *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, DefaultUILanguageId_used); // NtQueryDefaultUILanguage

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetDefaultUILanguage(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	LANGID DefaultUILanguageId_used = (LANGID)(x32based_args[2]); // LANGID  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, DefaultUILanguageId_used); // NtSetDefaultUILanguage

	return ret_value;
}


NTSTATUS WINAPI _w32_NtIsUILanguageComitted(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 0); // NtIsUILanguageComitted

	return ret_value;
}


NTSTATUS WINAPI _w32_NtInitializeNlsFiles(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_BaseAddress = (uint32_t)(x32based_args[2]); // PVOID *  OUT 
	PLCID DefaultLocaleId_used = (PLCID)(x32based_args[3]); // PLCID  OUT 
	PLARGE_INTEGER DefaultCasingTableSize_used = (PLARGE_INTEGER)(x32based_args[4]); // PLARGE_INTEGER  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t BaseAddress_holder[sizeof(PVOID)];
	PVOID* BaseAddress_used = (PVOID*)&BaseAddress_holder;

	// Convert parameters from x32 to x64
	if (x32based_BaseAddress == NULL) {
		BaseAddress_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 3, BaseAddress_used, DefaultLocaleId_used, DefaultCasingTableSize_used); // NtInitializeNlsFiles

	if (x32based_BaseAddress != NULL) {
		*((X32_SIZE_T*)x32based_BaseAddress) = (X32_SIZE_T)(*(SIZE_T*)BaseAddress_used);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtGetNlsSectionPtr(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	ULONG SectionType_used = (ULONG)(x32based_args[2]); // ULONG  IN 
	ULONG SectionData_used = (ULONG)(x32based_args[3]); // ULONG  IN 
	PVOID ContextData_used = (PVOID)(x32based_args[4]); // PVOID  IN 
	uint32_t x32based_SectionPointer = (uint32_t)(x32based_args[5]); // PVOID *  OUT 
	PULONG SectionSize_used = (PULONG)(x32based_args[6]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SectionPointer_holder[sizeof(PVOID)];
	PVOID* SectionPointer_used = (PVOID*)&SectionPointer_holder;

	// Convert parameters from x32 to x64
	if (x32based_SectionPointer == NULL) {
		SectionPointer_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 5, SectionType_used, SectionData_used, ContextData_used, SectionPointer_used, SectionSize_used); // NtGetNlsSectionPtr

	if (x32based_SectionPointer != NULL) {
		*((X32_SIZE_T*)x32based_SectionPointer) = (X32_SIZE_T)(*(SIZE_T*)SectionPointer_used);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtMapCMFModule(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	ULONG What_used = (ULONG)(x32based_args[2]); // ULONG  IN 
	ULONG Index_used = (ULONG)(x32based_args[3]); // ULONG  IN 
	PULONG CacheIndexOut_used = (PULONG)(x32based_args[4]); // PULONG  OUT 
	PULONG CacheFlagsOut_used = (PULONG)(x32based_args[5]); // PULONG  OUT 
	PULONG ViewSizeOut_used = (PULONG)(x32based_args[6]); // PULONG  OUT 
	uint32_t x32based_BaseAddress = (uint32_t)(x32based_args[7]); // PVOID *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t BaseAddress_holder[sizeof(PVOID)];
	PVOID* BaseAddress_used = (PVOID*)&BaseAddress_holder;

	// Convert parameters from x32 to x64
	if (x32based_BaseAddress == NULL) {
		BaseAddress_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 6, What_used, Index_used, CacheIndexOut_used, CacheFlagsOut_used, ViewSizeOut_used, BaseAddress_used); // NtMapCMFModule

	if (x32based_BaseAddress != NULL) {
		*((X32_SIZE_T*)x32based_BaseAddress) = (X32_SIZE_T)(*(SIZE_T*)BaseAddress_used);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtGetMUIRegistryInfo(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	ULONG Flags_used = (ULONG)(x32based_args[2]); // ULONG  IN 
	PULONG DataSize_used = (PULONG)(x32based_args[3]); // PULONG  IN  OUT 
	PVOID Data_used = (PVOID)(x32based_args[4]); // PVOID  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 3, Flags_used, DataSize_used, Data_used); // NtGetMUIRegistryInfo

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAddAtom(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PWSTR AtomName_used = (PWSTR)(x32based_args[2]); // PWSTR  IN 
	ULONG Length_used = (ULONG)(x32based_args[3]); // ULONG  IN 
	PRTL_ATOM Atom_used = (PRTL_ATOM)(x32based_args[4]); // PRTL_ATOM  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 3, AtomName_used, Length_used, Atom_used); // NtAddAtom

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAddAtomEx(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PWSTR AtomName_used = (PWSTR)(x32based_args[2]); // PWSTR  IN 
	ULONG Length_used = (ULONG)(x32based_args[3]); // ULONG  IN 
	PRTL_ATOM Atom_used = (PRTL_ATOM)(x32based_args[4]); // PRTL_ATOM  OUT 
	ULONG Flags_used = (ULONG)(x32based_args[5]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 4, AtomName_used, Length_used, Atom_used, Flags_used); // NtAddAtomEx

	return ret_value;
}


NTSTATUS WINAPI _w32_NtFindAtom(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PWSTR AtomName_used = (PWSTR)(x32based_args[2]); // PWSTR  IN 
	ULONG Length_used = (ULONG)(x32based_args[3]); // ULONG  IN 
	PRTL_ATOM Atom_used = (PRTL_ATOM)(x32based_args[4]); // PRTL_ATOM  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 3, AtomName_used, Length_used, Atom_used); // NtFindAtom

	return ret_value;
}


NTSTATUS WINAPI _w32_NtDeleteAtom(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	RTL_ATOM Atom_used = (RTL_ATOM)(x32based_args[2]); // RTL_ATOM  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, Atom_used); // NtDeleteAtom

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryInformationAtom(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	RTL_ATOM Atom_used = (RTL_ATOM)(x32based_args[2]); // RTL_ATOM  IN 
	ATOM_INFORMATION_CLASS AtomInformationClass_used = (ATOM_INFORMATION_CLASS)(x32based_args[3]); // ATOM_INFORMATION_CLASS  IN 
	PVOID AtomInformation_used = (PVOID)(x32based_args[4]); // PVOID  IN  OUT 
	ULONG AtomInformationLength_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	PULONG ReturnLength_used = (PULONG)(x32based_args[6]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 5, Atom_used, AtomInformationClass_used, AtomInformation_used, AtomInformationLength_used, ReturnLength_used); // NtQueryInformationAtom

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryLicenseValue(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ValueName = (uint32_t)(x32based_args[2]); // PUNICODE_STRING  IN 
	PULONG Type_used = (PULONG)(x32based_args[3]); // PULONG  OUT 
	PVOID Data_used = (PVOID)(x32based_args[4]); // PVOID  OUT 
	ULONG DataSize_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	PULONG ResultDataSize_used = (PULONG)(x32based_args[6]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ValueName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING ValueName_used = (PUNICODE_STRING)&ValueName_holder;

	// Convert parameters from x32 to x64
	if (x32based_ValueName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&ValueName_used, x32based_ValueName);
	}
	else {
		ValueName_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 5, ValueName_used, Type_used, Data_used, DataSize_used, ResultDataSize_used); // NtQueryLicenseValue

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetDefaultHardErrorPort(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_DefaultHardErrorPort = (uint32_t)(x32based_args[2]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE DefaultHardErrorPort_used = Handle32ToHandle((const void* __ptr32)x32based_DefaultHardErrorPort);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, DefaultHardErrorPort_used); // NtSetDefaultHardErrorPort

	return ret_value;
}


NTSTATUS WINAPI _w32_NtShutdownSystem(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	SHUTDOWN_ACTION Action_used = (SHUTDOWN_ACTION)(x32based_args[2]); // SHUTDOWN_ACTION  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, Action_used); // NtShutdownSystem

	return ret_value;
}


NTSTATUS WINAPI _w32_NtDisplayString(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_String = (uint32_t)(x32based_args[2]); // PUNICODE_STRING  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t String_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING String_used = (PUNICODE_STRING)&String_holder;

	// Convert parameters from x32 to x64
	if (x32based_String != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&String_used, x32based_String);
	}
	else {
		String_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 1, String_used); // NtDisplayString

	return ret_value;
}


NTSTATUS WINAPI _w32_NtDrawText(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_Text = (uint32_t)(x32based_args[2]); // PUNICODE_STRING  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t Text_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING Text_used = (PUNICODE_STRING)&Text_holder;

	// Convert parameters from x32 to x64
	if (x32based_Text != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&Text_used, x32based_Text);
	}
	else {
		Text_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 1, Text_used); // NtDrawText

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAllocateVirtualMemory(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_BaseAddress = (uint32_t)(x32based_args[3]); // PVOID *  IN  OUT 
	ULONG_PTR ZeroBits_used = (ULONG_PTR)(x32based_args[4]); // ULONG_PTR  IN 
	uint32_t x32based_RegionSize = (uint32_t)(x32based_args[5]); // PSIZE_T  IN  OUT 
	ULONG AllocationType_used = (ULONG)(x32based_args[6]); // ULONG  IN 
	ULONG Protect_used = (ULONG)(x32based_args[7]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);
	uint8_t BaseAddress_holder[sizeof(PVOID)];
	PVOID* BaseAddress_used = (PVOID*)&BaseAddress_holder;
	uint8_t RegionSize_holder[sizeof(long long unsigned int)];
	PSIZE_T RegionSize_used = (PSIZE_T)&RegionSize_holder;

	// Convert parameters from x32 to x64
	if (x32based_BaseAddress != NULL) {
		*((SIZE_T*)BaseAddress_holder) = (SIZE_T)(*((X32_SIZE_T*)x32based_BaseAddress));
	}
	else {
		BaseAddress_used = 0;
	}
	if (x32based_RegionSize != NULL) {
		*((SIZE_T*)RegionSize_holder) = (SIZE_T)(*((X32_SIZE_T*)x32based_RegionSize));
	}
	else {
		RegionSize_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 6, ProcessHandle_used, BaseAddress_used, ZeroBits_used, RegionSize_used, AllocationType_used, Protect_used); // NtAllocateVirtualMemory

	if (x32based_BaseAddress != NULL) {
		*((X32_SIZE_T*)x32based_BaseAddress) = (X32_SIZE_T)(*(SIZE_T*)BaseAddress_used);
	}
	if (x32based_RegionSize != NULL) {
		*((X32_SIZE_T*)x32based_RegionSize) = (X32_SIZE_T)(*(SIZE_T*)RegionSize_used);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtFreeVirtualMemory(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_BaseAddress = (uint32_t)(x32based_args[3]); // PVOID *  IN  OUT 
	uint32_t x32based_RegionSize = (uint32_t)(x32based_args[4]); // PSIZE_T  IN  OUT 
	ULONG FreeType_used = (ULONG)(x32based_args[5]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);
	uint8_t BaseAddress_holder[sizeof(PVOID)];
	PVOID* BaseAddress_used = (PVOID*)&BaseAddress_holder;
	uint8_t RegionSize_holder[sizeof(long long unsigned int)];
	PSIZE_T RegionSize_used = (PSIZE_T)&RegionSize_holder;

	// Convert parameters from x32 to x64
	if (x32based_BaseAddress != NULL) {
		*((SIZE_T*)BaseAddress_holder) = (SIZE_T)(*((X32_SIZE_T*)x32based_BaseAddress));
	}
	else {
		BaseAddress_used = 0;
	}
	if (x32based_RegionSize != NULL) {
		*((SIZE_T*)RegionSize_holder) = (SIZE_T)(*((X32_SIZE_T*)x32based_RegionSize));
	}
	else {
		RegionSize_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, ProcessHandle_used, BaseAddress_used, RegionSize_used, FreeType_used); // NtFreeVirtualMemory

	if (x32based_BaseAddress != NULL) {
		*((X32_SIZE_T*)x32based_BaseAddress) = (X32_SIZE_T)(*(SIZE_T*)BaseAddress_used);
	}
	if (x32based_RegionSize != NULL) {
		*((X32_SIZE_T*)x32based_RegionSize) = (X32_SIZE_T)(*(SIZE_T*)RegionSize_used);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtReadVirtualMemory(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PVOID BaseAddress_used = (PVOID)(x32based_args[3]); // PVOID  IN 
	PVOID Buffer_used = (PVOID)(x32based_args[4]); // PVOID  OUT 
	SIZE_T BufferSize_used = (SIZE_T)(x32based_args[5]); // SIZE_T  IN 
	uint32_t x32based_NumberOfBytesRead = (uint32_t)(x32based_args[6]); // PSIZE_T  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);
	uint8_t NumberOfBytesRead_holder[sizeof(long long unsigned int)];
	PSIZE_T NumberOfBytesRead_used = (PSIZE_T)&NumberOfBytesRead_holder;

	// Convert parameters from x32 to x64
	if (x32based_NumberOfBytesRead == NULL) {
		NumberOfBytesRead_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 5, ProcessHandle_used, BaseAddress_used, Buffer_used, BufferSize_used, NumberOfBytesRead_used); // NtReadVirtualMemory

	if (x32based_NumberOfBytesRead != NULL) {
		*((X32_SIZE_T*)x32based_NumberOfBytesRead) = (X32_SIZE_T)(*(SIZE_T*)NumberOfBytesRead_used);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtWriteVirtualMemory(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PVOID BaseAddress_used = (PVOID)(x32based_args[3]); // PVOID  IN 
	PVOID Buffer_used = (PVOID)(x32based_args[4]); // PVOID  IN 
	SIZE_T BufferSize_used = (SIZE_T)(x32based_args[5]); // SIZE_T  IN 
	uint32_t x32based_NumberOfBytesWritten = (uint32_t)(x32based_args[6]); // PSIZE_T  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);
	uint8_t NumberOfBytesWritten_holder[sizeof(long long unsigned int)];
	PSIZE_T NumberOfBytesWritten_used = (PSIZE_T)&NumberOfBytesWritten_holder;

	// Convert parameters from x32 to x64
	if (x32based_NumberOfBytesWritten == NULL) {
		NumberOfBytesWritten_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 5, ProcessHandle_used, BaseAddress_used, Buffer_used, BufferSize_used, NumberOfBytesWritten_used); // NtWriteVirtualMemory

	if (x32based_NumberOfBytesWritten != NULL) {
		*((X32_SIZE_T*)x32based_NumberOfBytesWritten) = (X32_SIZE_T)(*(SIZE_T*)NumberOfBytesWritten_used);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtProtectVirtualMemory(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_BaseAddress = (uint32_t)(x32based_args[3]); // PVOID *  IN  OUT 
	uint32_t x32based_RegionSize = (uint32_t)(x32based_args[4]); // PSIZE_T  IN  OUT 
	ULONG NewProtect_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	PULONG OldProtect_used = (PULONG)(x32based_args[6]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);
	uint8_t BaseAddress_holder[sizeof(PVOID)];
	PVOID* BaseAddress_used = (PVOID*)&BaseAddress_holder;
	uint8_t RegionSize_holder[sizeof(long long unsigned int)];
	PSIZE_T RegionSize_used = (PSIZE_T)&RegionSize_holder;

	// Convert parameters from x32 to x64
	if (x32based_BaseAddress != NULL) {
		*((SIZE_T*)BaseAddress_holder) = (SIZE_T)(*((X32_SIZE_T*)x32based_BaseAddress));
	}
	else {
		BaseAddress_used = 0;
	}
	if (x32based_RegionSize != NULL) {
		*((SIZE_T*)RegionSize_holder) = (SIZE_T)(*((X32_SIZE_T*)x32based_RegionSize));
	}
	else {
		RegionSize_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 5, ProcessHandle_used, BaseAddress_used, RegionSize_used, NewProtect_used, OldProtect_used); // NtProtectVirtualMemory

	if (x32based_BaseAddress != NULL) {
		*((X32_SIZE_T*)x32based_BaseAddress) = (X32_SIZE_T)(*(SIZE_T*)BaseAddress_used);
	}
	if (x32based_RegionSize != NULL) {
		*((X32_SIZE_T*)x32based_RegionSize) = (X32_SIZE_T)(*(SIZE_T*)RegionSize_used);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryVirtualMemory(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PVOID BaseAddress_used = (PVOID)(x32based_args[3]); // PVOID  IN 
	MEMORY_INFORMATION_CLASS MemoryInformationClass_used = (MEMORY_INFORMATION_CLASS)(x32based_args[4]); // MEMORY_INFORMATION_CLASS  IN 
	PVOID MemoryInformation_used = (PVOID)(x32based_args[5]); // PVOID  IN  OUT 
	SIZE_T MemoryInformationLength_used = (SIZE_T)(x32based_args[6]); // SIZE_T  IN 
	uint32_t x32based_ReturnLength = (uint32_t)(x32based_args[7]); // PSIZE_T  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);
	uint8_t ReturnLength_holder[sizeof(long long unsigned int)];
	PSIZE_T ReturnLength_used = (PSIZE_T)&ReturnLength_holder;

	// Convert parameters from x32 to x64
	if (x32based_ReturnLength == NULL) {
		ReturnLength_used = 0;
	}
	switch (MemoryInformationClass_used) {
	case MemoryBasicInformation: {
		ret_value = _w32_NtQueryVirtualMemory_MemoryBasicInformation(ctx, syscall_idx, ProcessHandle_used, BaseAddress_used, MemoryInformationClass_used, (MEMORY_BASIC_INFORMATION*)MemoryInformation_used, MemoryInformationLength_used, ReturnLength_used);
		break;
	}
	case MemoryWorkingSetInformation: {
		ret_value = _w32_NtQueryVirtualMemory_MemoryWorkingSetInformation(ctx, syscall_idx, ProcessHandle_used, BaseAddress_used, MemoryInformationClass_used, (MEMORY_WORKING_SET_INFORMATION*)MemoryInformation_used, MemoryInformationLength_used, ReturnLength_used);
		break;
	}
	case MemoryMappedFilenameInformation: {
		ret_value = _w32_NtQueryVirtualMemory_MemoryMappedFilenameInformation(ctx, syscall_idx, ProcessHandle_used, BaseAddress_used, MemoryInformationClass_used, (UNICODE_STRING*)MemoryInformation_used, MemoryInformationLength_used, ReturnLength_used);
		break;
	}
	case MemoryRegionInformation: {
		ret_value = _w32_NtQueryVirtualMemory_MemoryRegionInformation(ctx, syscall_idx, ProcessHandle_used, BaseAddress_used, MemoryInformationClass_used, (MEMORY_REGION_INFORMATION*)MemoryInformation_used, MemoryInformationLength_used, ReturnLength_used);
		break;
	}
	case MemoryWorkingSetExInformation: {
		ret_value = _w32_NtQueryVirtualMemory_MemoryWorkingSetExInformation(ctx, syscall_idx, ProcessHandle_used, BaseAddress_used, MemoryInformationClass_used, (MEMORY_WORKING_SET_EX_INFORMATION*)MemoryInformation_used, MemoryInformationLength_used, ReturnLength_used);
		break;
	}
	case MemoryRegionInformationEx: {
		ret_value = _w32_NtQueryVirtualMemory_MemoryRegionInformationEx(ctx, syscall_idx, ProcessHandle_used, BaseAddress_used, MemoryInformationClass_used, (MEMORY_REGION_INFORMATION*)MemoryInformation_used, MemoryInformationLength_used, ReturnLength_used);
		break;
	}
	default: {
		ret_value = __syscall64(syscall_idx, 6, ProcessHandle_used, BaseAddress_used, MemoryInformationClass_used, MemoryInformation_used, MemoryInformationLength_used, ReturnLength_used); // NtQueryVirtualMemory
		break;
	}
	}

	if (x32based_ReturnLength != NULL) {
		*((X32_SIZE_T*)x32based_ReturnLength) = (X32_SIZE_T)(*(SIZE_T*)ReturnLength_used);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetInformationVirtualMemory(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	VIRTUAL_MEMORY_INFORMATION_CLASS VmInformationClass_used = (VIRTUAL_MEMORY_INFORMATION_CLASS)(x32based_args[3]); // VIRTUAL_MEMORY_INFORMATION_CLASS  IN 
	ULONG_PTR NumberOfEntries_used = (ULONG_PTR)(x32based_args[4]); // ULONG_PTR  IN 
	uint32_t x32based_VirtualAddresses = (uint32_t)(x32based_args[5]); // PMEMORY_RANGE_ENTRY  IN 
	PVOID VmInformation_used = (PVOID)(x32based_args[6]); // PVOID  IN 
	ULONG VmInformationLength_used = (ULONG)(x32based_args[7]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);
	uint8_t VirtualAddresses_holder[sizeof(_MEMORY_RANGE_ENTRY)];
	PMEMORY_RANGE_ENTRY VirtualAddresses_used = (PMEMORY_RANGE_ENTRY)&VirtualAddresses_holder;

	// Convert parameters from x32 to x64
	if (x32based_VirtualAddresses != NULL) {
		convert__MEMORY_RANGE_ENTRY_32TO64(ctx, (_MEMORY_RANGE_ENTRY**)&VirtualAddresses_used, x32based_VirtualAddresses);
	}
	else {
		VirtualAddresses_used = 0;
	}

	switch (VmInformationClass_used) {
	default: {
		ret_value = __syscall64(syscall_idx, 6, ProcessHandle_used, VmInformationClass_used, NumberOfEntries_used, VirtualAddresses_used, VmInformation_used, VmInformationLength_used); // NtSetInformationVirtualMemory
		break;
	}
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtLockVirtualMemory(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_BaseAddress = (uint32_t)(x32based_args[3]); // PVOID *  IN  OUT 
	uint32_t x32based_RegionSize = (uint32_t)(x32based_args[4]); // PSIZE_T  IN  OUT 
	ULONG MapType_used = (ULONG)(x32based_args[5]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);
	uint8_t BaseAddress_holder[sizeof(PVOID)];
	PVOID* BaseAddress_used = (PVOID*)&BaseAddress_holder;
	uint8_t RegionSize_holder[sizeof(long long unsigned int)];
	PSIZE_T RegionSize_used = (PSIZE_T)&RegionSize_holder;

	// Convert parameters from x32 to x64
	if (x32based_BaseAddress != NULL) {
		*((SIZE_T*)BaseAddress_holder) = (SIZE_T)(*((X32_SIZE_T*)x32based_BaseAddress));
	}
	else {
		BaseAddress_used = 0;
	}
	if (x32based_RegionSize != NULL) {
		*((SIZE_T*)RegionSize_holder) = (SIZE_T)(*((X32_SIZE_T*)x32based_RegionSize));
	}
	else {
		RegionSize_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, ProcessHandle_used, BaseAddress_used, RegionSize_used, MapType_used); // NtLockVirtualMemory

	if (x32based_BaseAddress != NULL) {
		*((X32_SIZE_T*)x32based_BaseAddress) = (X32_SIZE_T)(*(SIZE_T*)BaseAddress_used);
	}
	if (x32based_RegionSize != NULL) {
		*((X32_SIZE_T*)x32based_RegionSize) = (X32_SIZE_T)(*(SIZE_T*)RegionSize_used);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtUnlockVirtualMemory(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_BaseAddress = (uint32_t)(x32based_args[3]); // PVOID *  IN  OUT 
	uint32_t x32based_RegionSize = (uint32_t)(x32based_args[4]); // PSIZE_T  IN  OUT 
	ULONG MapType_used = (ULONG)(x32based_args[5]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);
	uint8_t BaseAddress_holder[sizeof(PVOID)];
	PVOID* BaseAddress_used = (PVOID*)&BaseAddress_holder;
	uint8_t RegionSize_holder[sizeof(long long unsigned int)];
	PSIZE_T RegionSize_used = (PSIZE_T)&RegionSize_holder;

	// Convert parameters from x32 to x64
	if (x32based_BaseAddress != NULL) {
		*((SIZE_T*)BaseAddress_holder) = (SIZE_T)(*((X32_SIZE_T*)x32based_BaseAddress));
	}
	else {
		BaseAddress_used = 0;
	}
	if (x32based_RegionSize != NULL) {
		*((SIZE_T*)RegionSize_holder) = (SIZE_T)(*((X32_SIZE_T*)x32based_RegionSize));
	}
	else {
		RegionSize_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, ProcessHandle_used, BaseAddress_used, RegionSize_used, MapType_used); // NtUnlockVirtualMemory

	if (x32based_BaseAddress != NULL) {
		*((X32_SIZE_T*)x32based_BaseAddress) = (X32_SIZE_T)(*(SIZE_T*)BaseAddress_used);
	}
	if (x32based_RegionSize != NULL) {
		*((X32_SIZE_T*)x32based_RegionSize) = (X32_SIZE_T)(*(SIZE_T*)RegionSize_used);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateSection(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_SectionHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	PLARGE_INTEGER MaximumSize_used = (PLARGE_INTEGER)(x32based_args[5]); // PLARGE_INTEGER  IN 
	ULONG SectionPageProtection_used = (ULONG)(x32based_args[6]); // ULONG  IN 
	ULONG AllocationAttributes_used = (ULONG)(x32based_args[7]); // ULONG  IN 
	uint32_t x32based_FileHandle = (uint32_t)(x32based_args[8]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SectionHandle_holder[sizeof(PVOID)];
	PHANDLE SectionHandle_used = (PHANDLE)&SectionHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;
	HANDLE FileHandle_used = Handle32ToHandle((const void* __ptr32)x32based_FileHandle);

	// Convert parameters from x32 to x64
	if (x32based_SectionHandle == NULL) {
		SectionHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 7, SectionHandle_used, DesiredAccess_used, ObjectAttributes_used, MaximumSize_used, SectionPageProtection_used, AllocationAttributes_used, FileHandle_used); // NtCreateSection

	if (SectionHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)SectionHandle_used, x32based_SectionHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateSectionEx(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_SectionHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	PLARGE_INTEGER MaximumSize_used = (PLARGE_INTEGER)(x32based_args[5]); // PLARGE_INTEGER  IN 
	ULONG SectionPageProtection_used = (ULONG)(x32based_args[6]); // ULONG  IN 
	ULONG AllocationAttributes_used = (ULONG)(x32based_args[7]); // ULONG  IN 
	uint32_t x32based_FileHandle = (uint32_t)(x32based_args[8]); // HANDLE  IN 
	uint32_t x32based_ExtendedParameters = (uint32_t)(x32based_args[9]); // PMEM_EXTENDED_PARAMETER  IN  OUT 
	ULONG ExtendedParameterCount_used = (ULONG)(x32based_args[10]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SectionHandle_holder[sizeof(PVOID)];
	PHANDLE SectionHandle_used = (PHANDLE)&SectionHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;
	HANDLE FileHandle_used = Handle32ToHandle((const void* __ptr32)x32based_FileHandle);
	uint8_t ExtendedParameters_holder[sizeof(MEM_EXTENDED_PARAMETER)];
	PMEM_EXTENDED_PARAMETER ExtendedParameters_used = (PMEM_EXTENDED_PARAMETER)&ExtendedParameters_holder;

	// Convert parameters from x32 to x64
	if (x32based_SectionHandle == NULL) {
		SectionHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}
	if (x32based_ExtendedParameters != NULL) {
		convert_MEM_EXTENDED_PARAMETER_32TO64(ctx, (MEM_EXTENDED_PARAMETER**)&ExtendedParameters_used, x32based_ExtendedParameters);
	}
	else {
		ExtendedParameters_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 9, SectionHandle_used, DesiredAccess_used, ObjectAttributes_used, MaximumSize_used, SectionPageProtection_used, AllocationAttributes_used, FileHandle_used, ExtendedParameters_used, ExtendedParameterCount_used); // NtCreateSectionEx

	if (SectionHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)SectionHandle_used, x32based_SectionHandle);
	}
	if (ExtendedParameters_used != NULL) {
		convert_MEM_EXTENDED_PARAMETER_64TO32(ctx, (MEM_EXTENDED_PARAMETER*)ExtendedParameters_used, x32based_ExtendedParameters);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtOpenSection(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_SectionHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SectionHandle_holder[sizeof(PVOID)];
	PHANDLE SectionHandle_used = (PHANDLE)&SectionHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_SectionHandle == NULL) {
		SectionHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, SectionHandle_used, DesiredAccess_used, ObjectAttributes_used); // NtOpenSection

	if (SectionHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)SectionHandle_used, x32based_SectionHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtMapViewOfSection(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_SectionHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[3]); // HANDLE  IN 
	uint32_t x32based_BaseAddress = (uint32_t)(x32based_args[4]); // PVOID *  IN  OUT 
	ULONG_PTR ZeroBits_used = (ULONG_PTR)(x32based_args[5]); // ULONG_PTR  IN 
	SIZE_T CommitSize_used = (SIZE_T)(x32based_args[6]); // SIZE_T  IN 
	PLARGE_INTEGER SectionOffset_used = (PLARGE_INTEGER)(x32based_args[7]); // PLARGE_INTEGER  IN  OUT 
	uint32_t x32based_ViewSize = (uint32_t)(x32based_args[8]); // PSIZE_T  IN  OUT 
	SECTION_INHERIT InheritDisposition_used = (SECTION_INHERIT)(x32based_args[9]); // SECTION_INHERIT  IN 
	ULONG AllocationType_used = (ULONG)(x32based_args[10]); // ULONG  IN 
	ULONG Win32Protect_used = (ULONG)(x32based_args[11]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE SectionHandle_used = Handle32ToHandle((const void* __ptr32)x32based_SectionHandle);
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);
	uint8_t BaseAddress_holder[sizeof(PVOID)];
	PVOID* BaseAddress_used = (PVOID*)&BaseAddress_holder;
	uint8_t ViewSize_holder[sizeof(long long unsigned int)];
	PSIZE_T ViewSize_used = (PSIZE_T)&ViewSize_holder;

	// Convert parameters from x32 to x64
	if (x32based_BaseAddress != NULL) {
		*((SIZE_T*)BaseAddress_holder) = (SIZE_T)(*((X32_SIZE_T*)x32based_BaseAddress));
	}
	else {
		BaseAddress_used = 0;
	}
	if (x32based_ViewSize != NULL) {
		*((SIZE_T*)ViewSize_holder) = (SIZE_T)(*((X32_SIZE_T*)x32based_ViewSize));
	}
	else {
		ViewSize_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 10, SectionHandle_used, ProcessHandle_used, BaseAddress_used, ZeroBits_used, CommitSize_used, SectionOffset_used, ViewSize_used, InheritDisposition_used, AllocationType_used, Win32Protect_used); // NtMapViewOfSection

	if (x32based_BaseAddress != NULL) {
		*((X32_SIZE_T*)x32based_BaseAddress) = (X32_SIZE_T)(*(SIZE_T*)BaseAddress_used);
	}
	if (x32based_ViewSize != NULL) {
		*((X32_SIZE_T*)x32based_ViewSize) = (X32_SIZE_T)(*(SIZE_T*)ViewSize_used);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtUnmapViewOfSection(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PVOID BaseAddress_used = (PVOID)(x32based_args[3]); // PVOID  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, ProcessHandle_used, BaseAddress_used); // NtUnmapViewOfSection

	return ret_value;
}


NTSTATUS WINAPI _w32_NtUnmapViewOfSectionEx(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PVOID BaseAddress_used = (PVOID)(x32based_args[3]); // PVOID  IN 
	ULONG Flags_used = (ULONG)(x32based_args[4]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 3, ProcessHandle_used, BaseAddress_used, Flags_used); // NtUnmapViewOfSectionEx

	return ret_value;
}


NTSTATUS WINAPI _w32_NtExtendSection(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_SectionHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PLARGE_INTEGER NewSectionSize_used = (PLARGE_INTEGER)(x32based_args[3]); // PLARGE_INTEGER  IN  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE SectionHandle_used = Handle32ToHandle((const void* __ptr32)x32based_SectionHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, SectionHandle_used, NewSectionSize_used); // NtExtendSection

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQuerySection(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_SectionHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	SECTION_INFORMATION_CLASS SectionInformationClass_used = (SECTION_INFORMATION_CLASS)(x32based_args[3]); // SECTION_INFORMATION_CLASS  IN 
	PVOID SectionInformation_used = (PVOID)(x32based_args[4]); // PVOID  IN  OUT 
	SIZE_T SectionInformationLength_used = (SIZE_T)(x32based_args[5]); // SIZE_T  IN 
	uint32_t x32based_ReturnLength = (uint32_t)(x32based_args[6]); // PSIZE_T  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE SectionHandle_used = Handle32ToHandle((const void* __ptr32)x32based_SectionHandle);
	uint8_t ReturnLength_holder[sizeof(long long unsigned int)];
	PSIZE_T ReturnLength_used = (PSIZE_T)&ReturnLength_holder;

	// Convert parameters from x32 to x64
	if (x32based_ReturnLength == NULL) {
		ReturnLength_used = 0;
	}
	switch (SectionInformationClass_used) {
	case SectionBasicInformation: {
		ret_value = _w32_NtQuerySection_SectionBasicInformation(ctx, syscall_idx, SectionHandle_used, SectionInformationClass_used, (SECTION_BASIC_INFORMATION*)SectionInformation_used, SectionInformationLength_used, ReturnLength_used);
		break;
	}
	case SectionImageInformation: {
		ret_value = _w32_NtQuerySection_SectionImageInformation(ctx, syscall_idx, SectionHandle_used, SectionInformationClass_used, (SECTION_IMAGE_INFORMATION*)SectionInformation_used, SectionInformationLength_used, ReturnLength_used);
		break;
	}
	default: {
		ret_value = __syscall64(syscall_idx, 5, SectionHandle_used, SectionInformationClass_used, SectionInformation_used, SectionInformationLength_used, ReturnLength_used); // NtQuerySection
		break;
	}
	}

	if (x32based_ReturnLength != NULL) {
		*((X32_SIZE_T*)x32based_ReturnLength) = (X32_SIZE_T)(*(SIZE_T*)ReturnLength_used);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAreMappedFilesTheSame(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PVOID File1MappedAsAnImage_used = (PVOID)(x32based_args[2]); // PVOID  IN 
	PVOID File2MappedAsFile_used = (PVOID)(x32based_args[3]); // PVOID  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, File1MappedAsAnImage_used, File2MappedAsFile_used); // NtAreMappedFilesTheSame

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreatePartition(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PartitionHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	ULONG PreferredNode_used = (ULONG)(x32based_args[5]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t PartitionHandle_holder[sizeof(PVOID)];
	PHANDLE PartitionHandle_used = (PHANDLE)&PartitionHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_PartitionHandle == NULL) {
		PartitionHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, PartitionHandle_used, DesiredAccess_used, ObjectAttributes_used, PreferredNode_used); // NtCreatePartition

	if (PartitionHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)PartitionHandle_used, x32based_PartitionHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtOpenPartition(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PartitionHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t PartitionHandle_holder[sizeof(PVOID)];
	PHANDLE PartitionHandle_used = (PHANDLE)&PartitionHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_PartitionHandle == NULL) {
		PartitionHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, PartitionHandle_used, DesiredAccess_used, ObjectAttributes_used); // NtOpenPartition

	if (PartitionHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)PartitionHandle_used, x32based_PartitionHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtManagePartition(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	MEMORY_PARTITION_INFORMATION_CLASS PartitionInformationClass_used = (MEMORY_PARTITION_INFORMATION_CLASS)(x32based_args[2]); // MEMORY_PARTITION_INFORMATION_CLASS  IN 
	PVOID PartitionInformation_used = (PVOID)(x32based_args[3]); // PVOID  IN 
	ULONG PartitionInformationLength_used = (ULONG)(x32based_args[4]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	switch (PartitionInformationClass_used) {
	default: {
		ret_value = __syscall64(syscall_idx, 3, PartitionInformationClass_used, PartitionInformation_used, PartitionInformationLength_used); // NtManagePartition
		break;
	}
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtMapUserPhysicalPages(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PVOID VirtualAddress_used = (PVOID)(x32based_args[2]); // PVOID  IN 
	ULONG_PTR NumberOfPages_used = (ULONG_PTR)(x32based_args[3]); // ULONG_PTR  IN 
	uint32_t x32based_UserPfnArray = (uint32_t)(x32based_args[4]); // PULONG_PTR  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t UserPfnArray_holder[sizeof(long long unsigned int)];
	PULONG_PTR UserPfnArray_used = (PULONG_PTR)&UserPfnArray_holder;

	// Convert parameters from x32 to x64
	if (x32based_UserPfnArray != NULL) {
		*((SIZE_T*)UserPfnArray_holder) = (SIZE_T)(*((X32_SIZE_T*)x32based_UserPfnArray));
	}
	else {
		UserPfnArray_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, VirtualAddress_used, NumberOfPages_used, UserPfnArray_used); // NtMapUserPhysicalPages

	return ret_value;
}


NTSTATUS WINAPI _w32_NtMapUserPhysicalPagesScatter(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_VirtualAddresses = (uint32_t)(x32based_args[2]); // PVOID *  IN 
	ULONG_PTR NumberOfPages_used = (ULONG_PTR)(x32based_args[3]); // ULONG_PTR  IN 
	uint32_t x32based_UserPfnArray = (uint32_t)(x32based_args[4]); // PULONG_PTR  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t VirtualAddresses_holder[sizeof(PVOID)];
	PVOID* VirtualAddresses_used = (PVOID*)&VirtualAddresses_holder;
	uint8_t UserPfnArray_holder[sizeof(long long unsigned int)];
	PULONG_PTR UserPfnArray_used = (PULONG_PTR)&UserPfnArray_holder;

	// Convert parameters from x32 to x64
	if (x32based_VirtualAddresses != NULL) {
		*((SIZE_T*)VirtualAddresses_holder) = (SIZE_T)(*((X32_SIZE_T*)x32based_VirtualAddresses));
	}
	else {
		VirtualAddresses_used = 0;
	}
	if (x32based_UserPfnArray != NULL) {
		*((SIZE_T*)UserPfnArray_holder) = (SIZE_T)(*((X32_SIZE_T*)x32based_UserPfnArray));
	}
	else {
		UserPfnArray_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, VirtualAddresses_used, NumberOfPages_used, UserPfnArray_used); // NtMapUserPhysicalPagesScatter

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAllocateUserPhysicalPages(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_NumberOfPages = (uint32_t)(x32based_args[3]); // PULONG_PTR  IN  OUT 
	uint32_t x32based_UserPfnArray = (uint32_t)(x32based_args[4]); // PULONG_PTR  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);
	uint8_t NumberOfPages_holder[sizeof(long long unsigned int)];
	PULONG_PTR NumberOfPages_used = (PULONG_PTR)&NumberOfPages_holder;
	uint8_t UserPfnArray_holder[sizeof(long long unsigned int)];
	PULONG_PTR UserPfnArray_used = (PULONG_PTR)&UserPfnArray_holder;

	// Convert parameters from x32 to x64
	if (x32based_NumberOfPages != NULL) {
		*((SIZE_T*)NumberOfPages_holder) = (SIZE_T)(*((X32_SIZE_T*)x32based_NumberOfPages));
	}
	else {
		NumberOfPages_used = 0;
	}
	if (x32based_UserPfnArray == NULL) {
		UserPfnArray_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, ProcessHandle_used, NumberOfPages_used, UserPfnArray_used); // NtAllocateUserPhysicalPages

	if (x32based_NumberOfPages != NULL) {
		*((X32_SIZE_T*)x32based_NumberOfPages) = (X32_SIZE_T)(*(SIZE_T*)NumberOfPages_used);
	}
	if (x32based_UserPfnArray != NULL) {
		*((X32_SIZE_T*)x32based_UserPfnArray) = (X32_SIZE_T)(*(SIZE_T*)UserPfnArray_used);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtFreeUserPhysicalPages(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_NumberOfPages = (uint32_t)(x32based_args[3]); // PULONG_PTR  IN  OUT 
	uint32_t x32based_UserPfnArray = (uint32_t)(x32based_args[4]); // PULONG_PTR  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);
	uint8_t NumberOfPages_holder[sizeof(long long unsigned int)];
	PULONG_PTR NumberOfPages_used = (PULONG_PTR)&NumberOfPages_holder;
	uint8_t UserPfnArray_holder[sizeof(long long unsigned int)];
	PULONG_PTR UserPfnArray_used = (PULONG_PTR)&UserPfnArray_holder;

	// Convert parameters from x32 to x64
	if (x32based_NumberOfPages != NULL) {
		*((SIZE_T*)NumberOfPages_holder) = (SIZE_T)(*((X32_SIZE_T*)x32based_NumberOfPages));
	}
	else {
		NumberOfPages_used = 0;
	}
	if (x32based_UserPfnArray != NULL) {
		*((SIZE_T*)UserPfnArray_holder) = (SIZE_T)(*((X32_SIZE_T*)x32based_UserPfnArray));
	}
	else {
		UserPfnArray_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, ProcessHandle_used, NumberOfPages_used, UserPfnArray_used); // NtFreeUserPhysicalPages

	if (x32based_NumberOfPages != NULL) {
		*((X32_SIZE_T*)x32based_NumberOfPages) = (X32_SIZE_T)(*(SIZE_T*)NumberOfPages_used);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtGetWriteWatch(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	ULONG Flags_used = (ULONG)(x32based_args[3]); // ULONG  IN 
	PVOID BaseAddress_used = (PVOID)(x32based_args[4]); // PVOID  IN 
	SIZE_T RegionSize_used = (SIZE_T)(x32based_args[5]); // SIZE_T  IN 
	uint32_t x32based_UserAddressArray = (uint32_t)(x32based_args[6]); // PVOID *  IN  OUT 
	uint32_t x32based_EntriesInUserAddressArray = (uint32_t)(x32based_args[7]); // PULONG_PTR  IN  OUT 
	PULONG Granularity_used = (PULONG)(x32based_args[8]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);
	uint8_t UserAddressArray_holder[sizeof(PVOID)];
	PVOID* UserAddressArray_used = (PVOID*)&UserAddressArray_holder;
	uint8_t EntriesInUserAddressArray_holder[sizeof(long long unsigned int)];
	PULONG_PTR EntriesInUserAddressArray_used = (PULONG_PTR)&EntriesInUserAddressArray_holder;

	// Convert parameters from x32 to x64
	if (x32based_UserAddressArray != NULL) {
		*((SIZE_T*)UserAddressArray_holder) = (SIZE_T)(*((X32_SIZE_T*)x32based_UserAddressArray));
	}
	else {
		UserAddressArray_used = 0;
	}
	if (x32based_EntriesInUserAddressArray != NULL) {
		*((SIZE_T*)EntriesInUserAddressArray_holder) = (SIZE_T)(*((X32_SIZE_T*)x32based_EntriesInUserAddressArray));
	}
	else {
		EntriesInUserAddressArray_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 7, ProcessHandle_used, Flags_used, BaseAddress_used, RegionSize_used, UserAddressArray_used, EntriesInUserAddressArray_used, Granularity_used); // NtGetWriteWatch

	if (x32based_UserAddressArray != NULL) {
		*((X32_SIZE_T*)x32based_UserAddressArray) = (X32_SIZE_T)(*(SIZE_T*)UserAddressArray_used);
	}
	if (x32based_EntriesInUserAddressArray != NULL) {
		*((X32_SIZE_T*)x32based_EntriesInUserAddressArray) = (X32_SIZE_T)(*(SIZE_T*)EntriesInUserAddressArray_used);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtResetWriteWatch(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PVOID BaseAddress_used = (PVOID)(x32based_args[3]); // PVOID  IN 
	SIZE_T RegionSize_used = (SIZE_T)(x32based_args[4]); // SIZE_T  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 3, ProcessHandle_used, BaseAddress_used, RegionSize_used); // NtResetWriteWatch

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreatePagingFile(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PageFileName = (uint32_t)(x32based_args[2]); // PUNICODE_STRING  IN 
	PLARGE_INTEGER MinimumSize_used = (PLARGE_INTEGER)(x32based_args[3]); // PLARGE_INTEGER  IN 
	PLARGE_INTEGER MaximumSize_used = (PLARGE_INTEGER)(x32based_args[4]); // PLARGE_INTEGER  IN 
	ULONG Priority_used = (ULONG)(x32based_args[5]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t PageFileName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING PageFileName_used = (PUNICODE_STRING)&PageFileName_holder;

	// Convert parameters from x32 to x64
	if (x32based_PageFileName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&PageFileName_used, x32based_PageFileName);
	}
	else {
		PageFileName_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, PageFileName_used, MinimumSize_used, MaximumSize_used, Priority_used); // NtCreatePagingFile

	return ret_value;
}


NTSTATUS WINAPI _w32_NtFlushInstructionCache(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PVOID BaseAddress_used = (PVOID)(x32based_args[3]); // PVOID  IN 
	SIZE_T Length_used = (SIZE_T)(x32based_args[4]); // SIZE_T  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 3, ProcessHandle_used, BaseAddress_used, Length_used); // NtFlushInstructionCache

	return ret_value;
}


NTSTATUS WINAPI _w32_NtFlushWriteBuffer(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 0); // NtFlushWriteBuffer

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateEnclave(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_BaseAddress = (uint32_t)(x32based_args[3]); // PVOID *  IN  OUT 
	ULONG_PTR ZeroBits_used = (ULONG_PTR)(x32based_args[4]); // ULONG_PTR  IN 
	SIZE_T Size_used = (SIZE_T)(x32based_args[5]); // SIZE_T  IN 
	SIZE_T InitialCommitment_used = (SIZE_T)(x32based_args[6]); // SIZE_T  IN 
	ULONG EnclaveType_used = (ULONG)(x32based_args[7]); // ULONG  IN 
	PVOID EnclaveInformation_used = (PVOID)(x32based_args[8]); // PVOID  IN 
	ULONG EnclaveInformationLength_used = (ULONG)(x32based_args[9]); // ULONG  IN 
	PULONG EnclaveError_used = (PULONG)(x32based_args[10]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);
	uint8_t BaseAddress_holder[sizeof(PVOID)];
	PVOID* BaseAddress_used = (PVOID*)&BaseAddress_holder;

	// Convert parameters from x32 to x64
	if (x32based_BaseAddress != NULL) {
		*((SIZE_T*)BaseAddress_holder) = (SIZE_T)(*((X32_SIZE_T*)x32based_BaseAddress));
	}
	else {
		BaseAddress_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 9, ProcessHandle_used, BaseAddress_used, ZeroBits_used, Size_used, InitialCommitment_used, EnclaveType_used, EnclaveInformation_used, EnclaveInformationLength_used, EnclaveError_used); // NtCreateEnclave

	if (x32based_BaseAddress != NULL) {
		*((X32_SIZE_T*)x32based_BaseAddress) = (X32_SIZE_T)(*(SIZE_T*)BaseAddress_used);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtLoadEnclaveData(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PVOID BaseAddress_used = (PVOID)(x32based_args[3]); // PVOID  IN 
	PVOID Buffer_used = (PVOID)(x32based_args[4]); // PVOID  IN 
	SIZE_T BufferSize_used = (SIZE_T)(x32based_args[5]); // SIZE_T  IN 
	ULONG Protect_used = (ULONG)(x32based_args[6]); // ULONG  IN 
	PVOID PageInformation_used = (PVOID)(x32based_args[7]); // PVOID  IN 
	ULONG PageInformationLength_used = (ULONG)(x32based_args[8]); // ULONG  IN 
	uint32_t x32based_NumberOfBytesWritten = (uint32_t)(x32based_args[9]); // PSIZE_T  OUT 
	PULONG EnclaveError_used = (PULONG)(x32based_args[10]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);
	uint8_t NumberOfBytesWritten_holder[sizeof(long long unsigned int)];
	PSIZE_T NumberOfBytesWritten_used = (PSIZE_T)&NumberOfBytesWritten_holder;

	// Convert parameters from x32 to x64
	if (x32based_NumberOfBytesWritten == NULL) {
		NumberOfBytesWritten_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 9, ProcessHandle_used, BaseAddress_used, Buffer_used, BufferSize_used, Protect_used, PageInformation_used, PageInformationLength_used, NumberOfBytesWritten_used, EnclaveError_used); // NtLoadEnclaveData

	if (x32based_NumberOfBytesWritten != NULL) {
		*((X32_SIZE_T*)x32based_NumberOfBytesWritten) = (X32_SIZE_T)(*(SIZE_T*)NumberOfBytesWritten_used);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtInitializeEnclave(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PVOID BaseAddress_used = (PVOID)(x32based_args[3]); // PVOID  IN 
	PVOID EnclaveInformation_used = (PVOID)(x32based_args[4]); // PVOID  IN 
	ULONG EnclaveInformationLength_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	PULONG EnclaveError_used = (PULONG)(x32based_args[6]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 5, ProcessHandle_used, BaseAddress_used, EnclaveInformation_used, EnclaveInformationLength_used, EnclaveError_used); // NtInitializeEnclave

	return ret_value;
}


NTSTATUS WINAPI _w32_NtTerminateEnclave(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PVOID BaseAddress_used = (PVOID)(x32based_args[2]); // PVOID  IN 
	BOOLEAN WaitForThread_used = (BOOLEAN)(x32based_args[3]); // BOOLEAN  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, BaseAddress_used, WaitForThread_used); // NtTerminateEnclave

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCallEnclave(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PENCLAVE_ROUTINE Routine_used = (PENCLAVE_ROUTINE)(x32based_args[2]); // PENCLAVE_ROUTINE  IN 
	PVOID Parameter_used = (PVOID)(x32based_args[3]); // PVOID  IN 
	BOOLEAN WaitForThread_used = (BOOLEAN)(x32based_args[4]); // BOOLEAN  IN 
	uint32_t x32based_ReturnValue = (uint32_t)(x32based_args[5]); // PVOID *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ReturnValue_holder[sizeof(PVOID)];
	PVOID* ReturnValue_used = (PVOID*)&ReturnValue_holder;

	// Convert parameters from x32 to x64
	if (x32based_ReturnValue == NULL) {
		ReturnValue_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 4, Routine_used, Parameter_used, WaitForThread_used, ReturnValue_used); // NtCallEnclave

	if (x32based_ReturnValue != NULL) {
		*((X32_SIZE_T*)x32based_ReturnValue) = (X32_SIZE_T)(*(SIZE_T*)ReturnValue_used);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryObject(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_Handle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	OBJECT_INFORMATION_CLASS ObjectInformationClass_used = (OBJECT_INFORMATION_CLASS)(x32based_args[3]); // OBJECT_INFORMATION_CLASS  IN 
	PVOID ObjectInformation_used = (PVOID)(x32based_args[4]); // PVOID  IN  OUT 
	ULONG ObjectInformationLength_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	PULONG ReturnLength_used = (PULONG)(x32based_args[6]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE Handle_used = Handle32ToHandle((const void* __ptr32)x32based_Handle);

	// Convert parameters from x32 to x64
	switch (ObjectInformationClass_used) {
	case ObjectNameInformation: {
		ret_value = _w32_NtQueryObject_ObjectNameInformation(ctx, syscall_idx, Handle_used, ObjectInformationClass_used, (OBJECT_NAME_INFORMATION*)ObjectInformation_used, ObjectInformationLength_used, ReturnLength_used);
		break;
	}
	case ObjectTypeInformation: {
		ret_value = _w32_NtQueryObject_ObjectTypeInformation(ctx, syscall_idx, Handle_used, ObjectInformationClass_used, (OBJECT_TYPE_INFORMATION*)ObjectInformation_used, ObjectInformationLength_used, ReturnLength_used);
		break;
	}
	default: {
		ret_value = __syscall64(syscall_idx, 5, Handle_used, ObjectInformationClass_used, ObjectInformation_used, ObjectInformationLength_used, ReturnLength_used); // NtQueryObject
		break;
	}
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetInformationObject(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_Handle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	OBJECT_INFORMATION_CLASS ObjectInformationClass_used = (OBJECT_INFORMATION_CLASS)(x32based_args[3]); // OBJECT_INFORMATION_CLASS  IN 
	PVOID ObjectInformation_used = (PVOID)(x32based_args[4]); // PVOID  IN 
	ULONG ObjectInformationLength_used = (ULONG)(x32based_args[5]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE Handle_used = Handle32ToHandle((const void* __ptr32)x32based_Handle);

	// Convert parameters from x32 to x64
	switch (ObjectInformationClass_used) {
	default: {
		ret_value = __syscall64(syscall_idx, 4, Handle_used, ObjectInformationClass_used, ObjectInformation_used, ObjectInformationLength_used); // NtSetInformationObject
		break;
	}
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtDuplicateObject(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_SourceProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_SourceHandle = (uint32_t)(x32based_args[3]); // HANDLE  IN 
	uint32_t x32based_TargetProcessHandle = (uint32_t)(x32based_args[4]); // HANDLE  IN 
	uint32_t x32based_TargetHandle = (uint32_t)(x32based_args[5]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[6]); // ACCESS_MASK  IN 
	ULONG HandleAttributes_used = (ULONG)(x32based_args[7]); // ULONG  IN 
	ULONG Options_used = (ULONG)(x32based_args[8]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE SourceProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_SourceProcessHandle);
	HANDLE SourceHandle_used = Handle32ToHandle((const void* __ptr32)x32based_SourceHandle);
	HANDLE TargetProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_TargetProcessHandle);
	uint8_t TargetHandle_holder[sizeof(PVOID)];
	PHANDLE TargetHandle_used = (PHANDLE)&TargetHandle_holder;

	// Convert parameters from x32 to x64
	if (x32based_TargetHandle == NULL) {
		TargetHandle_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 7, SourceProcessHandle_used, SourceHandle_used, TargetProcessHandle_used, TargetHandle_used, DesiredAccess_used, HandleAttributes_used, Options_used); // NtDuplicateObject

	if (TargetHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)TargetHandle_used, x32based_TargetHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtMakeTemporaryObject(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_Handle = (uint32_t)(x32based_args[2]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE Handle_used = Handle32ToHandle((const void* __ptr32)x32based_Handle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, Handle_used); // NtMakeTemporaryObject

	return ret_value;
}


NTSTATUS WINAPI _w32_NtMakePermanentObject(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_Handle = (uint32_t)(x32based_args[2]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE Handle_used = Handle32ToHandle((const void* __ptr32)x32based_Handle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, Handle_used); // NtMakePermanentObject

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSignalAndWaitForSingleObject(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_SignalHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_WaitHandle = (uint32_t)(x32based_args[3]); // HANDLE  IN 
	BOOLEAN Alertable_used = (BOOLEAN)(x32based_args[4]); // BOOLEAN  IN 
	PLARGE_INTEGER Timeout_used = (PLARGE_INTEGER)(x32based_args[5]); // PLARGE_INTEGER  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE SignalHandle_used = Handle32ToHandle((const void* __ptr32)x32based_SignalHandle);
	HANDLE WaitHandle_used = Handle32ToHandle((const void* __ptr32)x32based_WaitHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 4, SignalHandle_used, WaitHandle_used, Alertable_used, Timeout_used); // NtSignalAndWaitForSingleObject

	return ret_value;
}


NTSTATUS WINAPI _w32_NtWaitForSingleObject(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_Handle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	BOOLEAN Alertable_used = (BOOLEAN)(x32based_args[3]); // BOOLEAN  IN 
	PLARGE_INTEGER Timeout_used = (PLARGE_INTEGER)(x32based_args[4]); // PLARGE_INTEGER  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE Handle_used = Handle32ToHandle((const void* __ptr32)x32based_Handle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 3, Handle_used, Alertable_used, Timeout_used); // NtWaitForSingleObject

	return ret_value;
}


NTSTATUS WINAPI _w32_NtWaitForMultipleObjects(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	ULONG Count_used = (ULONG)(x32based_args[2]); // ULONG  IN 
	uint32_t x32based_Handles = (uint32_t)(x32based_args[3]); // HANDLE *  IN 
	WAIT_TYPE WaitType_used = (WAIT_TYPE)(x32based_args[4]); // WAIT_TYPE  IN 
	BOOLEAN Alertable_used = (BOOLEAN)(x32based_args[5]); // BOOLEAN  IN 
	PLARGE_INTEGER Timeout_used = (PLARGE_INTEGER)(x32based_args[6]); // PLARGE_INTEGER  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t Handles_holder[sizeof(PVOID)];
	HANDLE* Handles_used = (HANDLE*)&Handles_holder;

	// Convert parameters from x32 to x64
	if (x32based_Handles != NULL) {
		convert_HANDLE_32TO64(ctx, (HANDLE**)&Handles_used, x32based_Handles);
	}
	else {
		Handles_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 5, Count_used, Handles_used, WaitType_used, Alertable_used, Timeout_used); // NtWaitForMultipleObjects

	return ret_value;
}


NTSTATUS WINAPI _w32_NtWaitForMultipleObjects32(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	ULONG Count_used = (ULONG)(x32based_args[2]); // ULONG  IN 
	LONG* Handles_used = (LONG*)(x32based_args[3]); // LONG *  IN 
	WAIT_TYPE WaitType_used = (WAIT_TYPE)(x32based_args[4]); // WAIT_TYPE  IN 
	BOOLEAN Alertable_used = (BOOLEAN)(x32based_args[5]); // BOOLEAN  IN 
	PLARGE_INTEGER Timeout_used = (PLARGE_INTEGER)(x32based_args[6]); // PLARGE_INTEGER  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 5, Count_used, Handles_used, WaitType_used, Alertable_used, Timeout_used); // NtWaitForMultipleObjects32

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetSecurityObject(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_Handle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	SECURITY_INFORMATION SecurityInformation_used = (SECURITY_INFORMATION)(x32based_args[3]); // SECURITY_INFORMATION  IN 
	uint32_t x32based_SecurityDescriptor = (uint32_t)(x32based_args[4]); // PSECURITY_DESCRIPTOR  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE Handle_used = Handle32ToHandle((const void* __ptr32)x32based_Handle);
	uint8_t SecurityDescriptor_holder[sizeof(PVOID)];
	PSECURITY_DESCRIPTOR SecurityDescriptor_used = (PSECURITY_DESCRIPTOR)&SecurityDescriptor_holder;

	// Convert parameters from x32 to x64
	if (x32based_SecurityDescriptor != NULL) {
		convert_HANDLE_32TO64(ctx, (HANDLE**)&SecurityDescriptor_used, x32based_SecurityDescriptor);
	}
	else {
		SecurityDescriptor_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, Handle_used, SecurityInformation_used, SecurityDescriptor_used); // NtSetSecurityObject

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQuerySecurityObject(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_Handle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	SECURITY_INFORMATION SecurityInformation_used = (SECURITY_INFORMATION)(x32based_args[3]); // SECURITY_INFORMATION  IN 
	uint32_t x32based_SecurityDescriptor = (uint32_t)(x32based_args[4]); // PSECURITY_DESCRIPTOR  OUT 
	ULONG Length_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	PULONG LengthNeeded_used = (PULONG)(x32based_args[6]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE Handle_used = Handle32ToHandle((const void* __ptr32)x32based_Handle);
	uint8_t SecurityDescriptor_holder[sizeof(PVOID)];
	PSECURITY_DESCRIPTOR SecurityDescriptor_used = (PSECURITY_DESCRIPTOR)&SecurityDescriptor_holder;

	// Convert parameters from x32 to x64
	if (x32based_SecurityDescriptor == NULL) {
		SecurityDescriptor_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 5, Handle_used, SecurityInformation_used, SecurityDescriptor_used, Length_used, LengthNeeded_used); // NtQuerySecurityObject

	if (SecurityDescriptor_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)SecurityDescriptor_used, x32based_SecurityDescriptor);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtClose(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_Handle = (uint32_t)(x32based_args[2]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE Handle_used = Handle32ToHandle((const void* __ptr32)x32based_Handle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, Handle_used); // NtClose

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCompareObjects(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_FirstObjectHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_SecondObjectHandle = (uint32_t)(x32based_args[3]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE FirstObjectHandle_used = Handle32ToHandle((const void* __ptr32)x32based_FirstObjectHandle);
	HANDLE SecondObjectHandle_used = Handle32ToHandle((const void* __ptr32)x32based_SecondObjectHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, FirstObjectHandle_used, SecondObjectHandle_used); // NtCompareObjects

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateDirectoryObject(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_DirectoryHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t DirectoryHandle_holder[sizeof(PVOID)];
	PHANDLE DirectoryHandle_used = (PHANDLE)&DirectoryHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_DirectoryHandle == NULL) {
		DirectoryHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, DirectoryHandle_used, DesiredAccess_used, ObjectAttributes_used); // NtCreateDirectoryObject

	if (DirectoryHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)DirectoryHandle_used, x32based_DirectoryHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateDirectoryObjectEx(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_DirectoryHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	uint32_t x32based_ShadowDirectoryHandle = (uint32_t)(x32based_args[5]); // HANDLE  IN 
	ULONG Flags_used = (ULONG)(x32based_args[6]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t DirectoryHandle_holder[sizeof(PVOID)];
	PHANDLE DirectoryHandle_used = (PHANDLE)&DirectoryHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;
	HANDLE ShadowDirectoryHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ShadowDirectoryHandle);

	// Convert parameters from x32 to x64
	if (x32based_DirectoryHandle == NULL) {
		DirectoryHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 5, DirectoryHandle_used, DesiredAccess_used, ObjectAttributes_used, ShadowDirectoryHandle_used, Flags_used); // NtCreateDirectoryObjectEx

	if (DirectoryHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)DirectoryHandle_used, x32based_DirectoryHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtOpenDirectoryObject(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_DirectoryHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t DirectoryHandle_holder[sizeof(PVOID)];
	PHANDLE DirectoryHandle_used = (PHANDLE)&DirectoryHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_DirectoryHandle == NULL) {
		DirectoryHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, DirectoryHandle_used, DesiredAccess_used, ObjectAttributes_used); // NtOpenDirectoryObject

	if (DirectoryHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)DirectoryHandle_used, x32based_DirectoryHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryDirectoryObject(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_DirectoryHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PVOID Buffer_used = (PVOID)(x32based_args[3]); // PVOID  OUT 
	ULONG Length_used = (ULONG)(x32based_args[4]); // ULONG  IN 
	BOOLEAN ReturnSingleEntry_used = (BOOLEAN)(x32based_args[5]); // BOOLEAN  IN 
	BOOLEAN RestartScan_used = (BOOLEAN)(x32based_args[6]); // BOOLEAN  IN 
	PULONG Context_used = (PULONG)(x32based_args[7]); // PULONG  IN  OUT 
	PULONG ReturnLength_used = (PULONG)(x32based_args[8]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE DirectoryHandle_used = Handle32ToHandle((const void* __ptr32)x32based_DirectoryHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 7, DirectoryHandle_used, Buffer_used, Length_used, ReturnSingleEntry_used, RestartScan_used, Context_used, ReturnLength_used); // NtQueryDirectoryObject

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreatePrivateNamespace(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_NamespaceHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	PVOID BoundaryDescriptor_used = (PVOID)(x32based_args[5]); // PVOID  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t NamespaceHandle_holder[sizeof(PVOID)];
	PHANDLE NamespaceHandle_used = (PHANDLE)&NamespaceHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_NamespaceHandle == NULL) {
		NamespaceHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, NamespaceHandle_used, DesiredAccess_used, ObjectAttributes_used, BoundaryDescriptor_used); // NtCreatePrivateNamespace

	if (NamespaceHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)NamespaceHandle_used, x32based_NamespaceHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtOpenPrivateNamespace(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_NamespaceHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	PVOID BoundaryDescriptor_used = (PVOID)(x32based_args[5]); // PVOID  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t NamespaceHandle_holder[sizeof(PVOID)];
	PHANDLE NamespaceHandle_used = (PHANDLE)&NamespaceHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_NamespaceHandle == NULL) {
		NamespaceHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, NamespaceHandle_used, DesiredAccess_used, ObjectAttributes_used, BoundaryDescriptor_used); // NtOpenPrivateNamespace

	if (NamespaceHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)NamespaceHandle_used, x32based_NamespaceHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtDeletePrivateNamespace(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_NamespaceHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE NamespaceHandle_used = Handle32ToHandle((const void* __ptr32)x32based_NamespaceHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, NamespaceHandle_used); // NtDeletePrivateNamespace

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateSymbolicLinkObject(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_LinkHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	uint32_t x32based_LinkTarget = (uint32_t)(x32based_args[5]); // PUNICODE_STRING  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t LinkHandle_holder[sizeof(PVOID)];
	PHANDLE LinkHandle_used = (PHANDLE)&LinkHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;
	uint8_t LinkTarget_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING LinkTarget_used = (PUNICODE_STRING)&LinkTarget_holder;

	// Convert parameters from x32 to x64
	if (x32based_LinkHandle == NULL) {
		LinkHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}
	if (x32based_LinkTarget != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&LinkTarget_used, x32based_LinkTarget);
	}
	else {
		LinkTarget_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, LinkHandle_used, DesiredAccess_used, ObjectAttributes_used, LinkTarget_used); // NtCreateSymbolicLinkObject

	if (LinkHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)LinkHandle_used, x32based_LinkHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtOpenSymbolicLinkObject(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_LinkHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t LinkHandle_holder[sizeof(PVOID)];
	PHANDLE LinkHandle_used = (PHANDLE)&LinkHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_LinkHandle == NULL) {
		LinkHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, LinkHandle_used, DesiredAccess_used, ObjectAttributes_used); // NtOpenSymbolicLinkObject

	if (LinkHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)LinkHandle_used, x32based_LinkHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQuerySymbolicLinkObject(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_LinkHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_LinkTarget = (uint32_t)(x32based_args[3]); // PUNICODE_STRING  IN  OUT 
	PULONG ReturnedLength_used = (PULONG)(x32based_args[4]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE LinkHandle_used = Handle32ToHandle((const void* __ptr32)x32based_LinkHandle);
	uint8_t LinkTarget_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING LinkTarget_used = (PUNICODE_STRING)&LinkTarget_holder;

	// Convert parameters from x32 to x64
	if (x32based_LinkTarget != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&LinkTarget_used, x32based_LinkTarget);
	}
	else {
		LinkTarget_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, LinkHandle_used, LinkTarget_used, ReturnedLength_used); // NtQuerySymbolicLinkObject

	if (LinkTarget_used != NULL) {
		convert__UNICODE_STRING_64TO32(ctx, (_UNICODE_STRING*)LinkTarget_used, x32based_LinkTarget);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateProcess(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	uint32_t x32based_ParentProcess = (uint32_t)(x32based_args[5]); // HANDLE  IN 
	BOOLEAN InheritObjectTable_used = (BOOLEAN)(x32based_args[6]); // BOOLEAN  IN 
	uint32_t x32based_SectionHandle = (uint32_t)(x32based_args[7]); // HANDLE  IN 
	uint32_t x32based_DebugPort = (uint32_t)(x32based_args[8]); // HANDLE  IN 
	uint32_t x32based_ExceptionPort = (uint32_t)(x32based_args[9]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ProcessHandle_holder[sizeof(PVOID)];
	PHANDLE ProcessHandle_used = (PHANDLE)&ProcessHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;
	HANDLE ParentProcess_used = Handle32ToHandle((const void* __ptr32)x32based_ParentProcess);
	HANDLE SectionHandle_used = Handle32ToHandle((const void* __ptr32)x32based_SectionHandle);
	HANDLE DebugPort_used = Handle32ToHandle((const void* __ptr32)x32based_DebugPort);
	HANDLE ExceptionPort_used = Handle32ToHandle((const void* __ptr32)x32based_ExceptionPort);

	// Convert parameters from x32 to x64
	if (x32based_ProcessHandle == NULL) {
		ProcessHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 8, ProcessHandle_used, DesiredAccess_used, ObjectAttributes_used, ParentProcess_used, InheritObjectTable_used, SectionHandle_used, DebugPort_used, ExceptionPort_used); // NtCreateProcess

	if (ProcessHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)ProcessHandle_used, x32based_ProcessHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateProcessEx(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	uint32_t x32based_ParentProcess = (uint32_t)(x32based_args[5]); // HANDLE  IN 
	ULONG Flags_used = (ULONG)(x32based_args[6]); // ULONG  IN 
	uint32_t x32based_SectionHandle = (uint32_t)(x32based_args[7]); // HANDLE  IN 
	uint32_t x32based_DebugPort = (uint32_t)(x32based_args[8]); // HANDLE  IN 
	uint32_t x32based_ExceptionPort = (uint32_t)(x32based_args[9]); // HANDLE  IN 
	ULONG JobMemberLevel_used = (ULONG)(x32based_args[10]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ProcessHandle_holder[sizeof(PVOID)];
	PHANDLE ProcessHandle_used = (PHANDLE)&ProcessHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;
	HANDLE ParentProcess_used = Handle32ToHandle((const void* __ptr32)x32based_ParentProcess);
	HANDLE SectionHandle_used = Handle32ToHandle((const void* __ptr32)x32based_SectionHandle);
	HANDLE DebugPort_used = Handle32ToHandle((const void* __ptr32)x32based_DebugPort);
	HANDLE ExceptionPort_used = Handle32ToHandle((const void* __ptr32)x32based_ExceptionPort);

	// Convert parameters from x32 to x64
	if (x32based_ProcessHandle == NULL) {
		ProcessHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 9, ProcessHandle_used, DesiredAccess_used, ObjectAttributes_used, ParentProcess_used, Flags_used, SectionHandle_used, DebugPort_used, ExceptionPort_used, JobMemberLevel_used); // NtCreateProcessEx

	if (ProcessHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)ProcessHandle_used, x32based_ProcessHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtOpenProcess(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	uint32_t x32based_ClientId = (uint32_t)(x32based_args[5]); // PCLIENT_ID  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ProcessHandle_holder[sizeof(PVOID)];
	PHANDLE ProcessHandle_used = (PHANDLE)&ProcessHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;
	uint8_t ClientId_holder[sizeof(_CLIENT_ID)];
	PCLIENT_ID ClientId_used = (PCLIENT_ID)&ClientId_holder;

	// Convert parameters from x32 to x64
	if (x32based_ProcessHandle == NULL) {
		ProcessHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}
	if (x32based_ClientId != NULL) {
		convert__CLIENT_ID_32TO64(ctx, (_CLIENT_ID**)&ClientId_used, x32based_ClientId);
	}
	else {
		ClientId_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, ProcessHandle_used, DesiredAccess_used, ObjectAttributes_used, ClientId_used); // NtOpenProcess

	if (ProcessHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)ProcessHandle_used, x32based_ProcessHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtTerminateProcess(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	NTSTATUS ExitStatus_used = (NTSTATUS)(x32based_args[3]); // NTSTATUS  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, ProcessHandle_used, ExitStatus_used); // NtTerminateProcess

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSuspendProcess(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, ProcessHandle_used); // NtSuspendProcess

	return ret_value;
}


NTSTATUS WINAPI _w32_NtResumeProcess(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, ProcessHandle_used); // NtResumeProcess

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryInformationProcess(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PROCESSINFOCLASS ProcessInformationClass_used = (PROCESSINFOCLASS)(x32based_args[3]); // PROCESSINFOCLASS  IN 
	PVOID ProcessInformation_used = (PVOID)(x32based_args[4]); // PVOID  IN  OUT 
	ULONG ProcessInformationLength_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	PULONG ReturnLength_used = (PULONG)(x32based_args[6]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);

	// Convert parameters from x32 to x64
	switch (ProcessInformationClass_used) {
	case ProcessBasicInformation: {
		ret_value = _w32_NtQueryInformationProcess_ProcessBasicInformation(ctx, syscall_idx, ProcessHandle_used, ProcessInformationClass_used, (PROCESS_BASIC_INFORMATION*)ProcessInformation_used, ProcessInformationLength_used, ReturnLength_used);
		break;
	}
	case ProcessQuotaLimits: {
		ret_value = _w32_NtQueryInformationProcess_ProcessQuotaLimits(ctx, syscall_idx, ProcessHandle_used, ProcessInformationClass_used, (QUOTA_LIMITS*)ProcessInformation_used, ProcessInformationLength_used, ReturnLength_used);
		break;
	}
	case ProcessVmCounters: {
		ret_value = _w32_NtQueryInformationProcess_ProcessVmCounters(ctx, syscall_idx, ProcessHandle_used, ProcessInformationClass_used, (VM_COUNTERS*)ProcessInformation_used, ProcessInformationLength_used, ReturnLength_used);
		break;
	}
	case ProcessPooledUsageAndLimits: {
		ret_value = _w32_NtQueryInformationProcess_ProcessPooledUsageAndLimits(ctx, syscall_idx, ProcessHandle_used, ProcessInformationClass_used, (POOLED_USAGE_AND_LIMITS*)ProcessInformation_used, ProcessInformationLength_used, ReturnLength_used);
		break;
	}
	case ProcessWorkingSetWatch: {
		ret_value = _w32_NtQueryInformationProcess_ProcessWorkingSetWatch(ctx, syscall_idx, ProcessHandle_used, ProcessInformationClass_used, (PROCESS_WS_WATCH_INFORMATION*)ProcessInformation_used, ProcessInformationLength_used, ReturnLength_used);
		break;
	}
	case ProcessDeviceMap: {
		ret_value = _w32_NtQueryInformationProcess_ProcessDeviceMap(ctx, syscall_idx, ProcessHandle_used, ProcessInformationClass_used, (PROCESS_DEVICEMAP_INFORMATION*)ProcessInformation_used, ProcessInformationLength_used, ReturnLength_used);
		break;
	}
	case ProcessImageFileName: {
		ret_value = _w32_NtQueryInformationProcess_ProcessImageFileName(ctx, syscall_idx, ProcessHandle_used, ProcessInformationClass_used, (UNICODE_STRING*)ProcessInformation_used, ProcessInformationLength_used, ReturnLength_used);
		break;
	}
	case ProcessHandleTracing: {
		ret_value = _w32_NtQueryInformationProcess_ProcessHandleTracing(ctx, syscall_idx, ProcessHandle_used, ProcessInformationClass_used, (PROCESS_HANDLE_TRACING_QUERY*)ProcessInformation_used, ProcessInformationLength_used, ReturnLength_used);
		break;
	}
	case ProcessImageInformation: {
		ret_value = _w32_NtQueryInformationProcess_ProcessImageInformation(ctx, syscall_idx, ProcessHandle_used, ProcessInformationClass_used, (SECTION_IMAGE_INFORMATION*)ProcessInformation_used, ProcessInformationLength_used, ReturnLength_used);
		break;
	}
	case ProcessWorkingSetWatchEx: {
		ret_value = _w32_NtQueryInformationProcess_ProcessWorkingSetWatchEx(ctx, syscall_idx, ProcessHandle_used, ProcessInformationClass_used, (PROCESS_WS_WATCH_INFORMATION_EX*)ProcessInformation_used, ProcessInformationLength_used, ReturnLength_used);
		break;
	}
	case ProcessImageFileNameWin32: {
		ret_value = _w32_NtQueryInformationProcess_ProcessImageFileNameWin32(ctx, syscall_idx, ProcessHandle_used, ProcessInformationClass_used, (UNICODE_STRING*)ProcessInformation_used, ProcessInformationLength_used, ReturnLength_used);
		break;
	}
	case ProcessHandleInformation: {
		ret_value = _w32_NtQueryInformationProcess_ProcessHandleInformation(ctx, syscall_idx, ProcessHandle_used, ProcessInformationClass_used, (PROCESS_HANDLE_SNAPSHOT_INFORMATION*)ProcessInformation_used, ProcessInformationLength_used, ReturnLength_used);
		break;
	}
	case ProcessCommandLineInformation: {
		ret_value = _w32_NtQueryInformationProcess_ProcessCommandLineInformation(ctx, syscall_idx, ProcessHandle_used, ProcessInformationClass_used, (UNICODE_STRING*)ProcessInformation_used, ProcessInformationLength_used, ReturnLength_used);
		break;
	}
	default: {
		ret_value = __syscall64(syscall_idx, 5, ProcessHandle_used, ProcessInformationClass_used, ProcessInformation_used, ProcessInformationLength_used, ReturnLength_used); // NtQueryInformationProcess
		break;
	}
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtGetNextProcess(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	ULONG HandleAttributes_used = (ULONG)(x32based_args[4]); // ULONG  IN 
	ULONG Flags_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	uint32_t x32based_NewProcessHandle = (uint32_t)(x32based_args[6]); // PHANDLE  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);
	uint8_t NewProcessHandle_holder[sizeof(PVOID)];
	PHANDLE NewProcessHandle_used = (PHANDLE)&NewProcessHandle_holder;

	// Convert parameters from x32 to x64
	if (x32based_NewProcessHandle == NULL) {
		NewProcessHandle_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 5, ProcessHandle_used, DesiredAccess_used, HandleAttributes_used, Flags_used, NewProcessHandle_used); // NtGetNextProcess

	if (NewProcessHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)NewProcessHandle_used, x32based_NewProcessHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtGetNextThread(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_ThreadHandle = (uint32_t)(x32based_args[3]); // HANDLE  IN 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[4]); // ACCESS_MASK  IN 
	ULONG HandleAttributes_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	ULONG Flags_used = (ULONG)(x32based_args[6]); // ULONG  IN 
	uint32_t x32based_NewThreadHandle = (uint32_t)(x32based_args[7]); // PHANDLE  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);
	HANDLE ThreadHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ThreadHandle);
	uint8_t NewThreadHandle_holder[sizeof(PVOID)];
	PHANDLE NewThreadHandle_used = (PHANDLE)&NewThreadHandle_holder;

	// Convert parameters from x32 to x64
	if (x32based_NewThreadHandle == NULL) {
		NewThreadHandle_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 6, ProcessHandle_used, ThreadHandle_used, DesiredAccess_used, HandleAttributes_used, Flags_used, NewThreadHandle_used); // NtGetNextThread

	if (NewThreadHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)NewThreadHandle_used, x32based_NewThreadHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetInformationProcess(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PROCESSINFOCLASS ProcessInformationClass_used = (PROCESSINFOCLASS)(x32based_args[3]); // PROCESSINFOCLASS  IN 
	PVOID ProcessInformation_used = (PVOID)(x32based_args[4]); // PVOID  IN 
	ULONG ProcessInformationLength_used = (ULONG)(x32based_args[5]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);

	// Convert parameters from x32 to x64
	switch (ProcessInformationClass_used) {
	case ProcessQuotaLimits: {
		ret_value = _w32_NtSetInformationProcess_ProcessQuotaLimits(ctx, syscall_idx, ProcessHandle_used, ProcessInformationClass_used, (QUOTA_LIMITS*)ProcessInformation_used, ProcessInformationLength_used);
		break;
	}
	case ProcessExceptionPort: {
		ret_value = _w32_NtSetInformationProcess_ProcessExceptionPort(ctx, syscall_idx, ProcessHandle_used, ProcessInformationClass_used, (PROCESS_EXCEPTION_PORT*)ProcessInformation_used, ProcessInformationLength_used);
		break;
	}
	case ProcessAccessToken: {
		ret_value = _w32_NtSetInformationProcess_ProcessAccessToken(ctx, syscall_idx, ProcessHandle_used, ProcessInformationClass_used, (PROCESS_ACCESS_TOKEN*)ProcessInformation_used, ProcessInformationLength_used);
		break;
	}
	case ProcessAffinityMask: {
		ret_value = _w32_NtSetInformationProcess_ProcessAffinityMask(ctx, syscall_idx, ProcessHandle_used, ProcessInformationClass_used, (KAFFINITY*)ProcessInformation_used, ProcessInformationLength_used);
		break;
	}
	case ProcessInstrumentationCallback: {
		ret_value = _w32_NtSetInformationProcess_ProcessInstrumentationCallback(ctx, syscall_idx, ProcessHandle_used, ProcessInformationClass_used, (PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION*)ProcessInformation_used, ProcessInformationLength_used);
		break;
	}
	case ProcessThreadStackAllocation: {
		ret_value = _w32_NtSetInformationProcess_ProcessThreadStackAllocation(ctx, syscall_idx, ProcessHandle_used, ProcessInformationClass_used, (PROCESS_STACK_ALLOCATION_INFORMATION*)ProcessInformation_used, ProcessInformationLength_used);
		break;
	}
	case ProcessMemoryExhaustion: {
		ret_value = _w32_NtSetInformationProcess_ProcessMemoryExhaustion(ctx, syscall_idx, ProcessHandle_used, ProcessInformationClass_used, (PROCESS_MEMORY_EXHAUSTION_INFO*)ProcessInformation_used, ProcessInformationLength_used);
		break;
	}
	case ProcessCombineSecurityDomainsInformation: {
		ret_value = _w32_NtSetInformationProcess_ProcessCombineSecurityDomainsInformation(ctx, syscall_idx, ProcessHandle_used, ProcessInformationClass_used, (PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION*)ProcessInformation_used, ProcessInformationLength_used);
		break;
	}
	default: {
		ret_value = __syscall64(syscall_idx, 4, ProcessHandle_used, ProcessInformationClass_used, ProcessInformation_used, ProcessInformationLength_used); // NtSetInformationProcess
		break;
	}
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryPortInformationProcess(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 0); // NtQueryPortInformationProcess

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateThread(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ThreadHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[5]); // HANDLE  IN 
	uint32_t x32based_ClientId = (uint32_t)(x32based_args[6]); // PCLIENT_ID  OUT 
	PCONTEXT ThreadContext_used = (PCONTEXT)(x32based_args[7]); // PCONTEXT  IN 
	uint32_t x32based_InitialTeb = (uint32_t)(x32based_args[8]); // PINITIAL_TEB  IN 
	BOOLEAN CreateSuspended_used = (BOOLEAN)(x32based_args[9]); // BOOLEAN  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ThreadHandle_holder[sizeof(PVOID)];
	PHANDLE ThreadHandle_used = (PHANDLE)&ThreadHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);
	uint8_t ClientId_holder[sizeof(_CLIENT_ID)];
	PCLIENT_ID ClientId_used = (PCLIENT_ID)&ClientId_holder;
	uint8_t InitialTeb_holder[sizeof(_INITIAL_TEB)];
	PINITIAL_TEB InitialTeb_used = (PINITIAL_TEB)&InitialTeb_holder;

	// Convert parameters from x32 to x64
	if (x32based_ThreadHandle == NULL) {
		ThreadHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}
	if (x32based_ClientId == NULL) {
		ClientId_used = 0;
	}
	if (x32based_InitialTeb != NULL) {
		convert__INITIAL_TEB_32TO64(ctx, (_INITIAL_TEB**)&InitialTeb_used, x32based_InitialTeb);
	}
	else {
		InitialTeb_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 8, ThreadHandle_used, DesiredAccess_used, ObjectAttributes_used, ProcessHandle_used, ClientId_used, ThreadContext_used, InitialTeb_used, CreateSuspended_used); // NtCreateThread

	if (ThreadHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)ThreadHandle_used, x32based_ThreadHandle);
	}
	if (ClientId_used != NULL) {
		convert__CLIENT_ID_64TO32(ctx, (_CLIENT_ID*)ClientId_used, x32based_ClientId);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtOpenThread(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ThreadHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	uint32_t x32based_ClientId = (uint32_t)(x32based_args[5]); // PCLIENT_ID  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ThreadHandle_holder[sizeof(PVOID)];
	PHANDLE ThreadHandle_used = (PHANDLE)&ThreadHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;
	uint8_t ClientId_holder[sizeof(_CLIENT_ID)];
	PCLIENT_ID ClientId_used = (PCLIENT_ID)&ClientId_holder;

	// Convert parameters from x32 to x64
	if (x32based_ThreadHandle == NULL) {
		ThreadHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}
	if (x32based_ClientId != NULL) {
		convert__CLIENT_ID_32TO64(ctx, (_CLIENT_ID**)&ClientId_used, x32based_ClientId);
	}
	else {
		ClientId_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, ThreadHandle_used, DesiredAccess_used, ObjectAttributes_used, ClientId_used); // NtOpenThread

	if (ThreadHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)ThreadHandle_used, x32based_ThreadHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtTerminateThread(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ThreadHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	NTSTATUS ExitStatus_used = (NTSTATUS)(x32based_args[3]); // NTSTATUS  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ThreadHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ThreadHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, ThreadHandle_used, ExitStatus_used); // NtTerminateThread

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSuspendThread(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ThreadHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PULONG PreviousSuspendCount_used = (PULONG)(x32based_args[3]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ThreadHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ThreadHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, ThreadHandle_used, PreviousSuspendCount_used); // NtSuspendThread

	return ret_value;
}


NTSTATUS WINAPI _w32_NtResumeThread(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ThreadHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PULONG PreviousSuspendCount_used = (PULONG)(x32based_args[3]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ThreadHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ThreadHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, ThreadHandle_used, PreviousSuspendCount_used); // NtResumeThread

	return ret_value;
}


ULONG WINAPI _w32_NtGetCurrentProcessorNumber(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	// Declare space used in parameters
	// Convert parameters from x32 to x64
	return (ULONG)__syscall64(syscall_idx, 0); // NtGetCurrentProcessorNumber
}


NTSTATUS WINAPI _w32_NtGetContextThread(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ThreadHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PCONTEXT ThreadContext_used = (PCONTEXT)(x32based_args[3]); // PCONTEXT  IN  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ThreadHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ThreadHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, ThreadHandle_used, ThreadContext_used); // NtGetContextThread

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetContextThread(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ThreadHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PCONTEXT ThreadContext_used = (PCONTEXT)(x32based_args[3]); // PCONTEXT  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ThreadHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ThreadHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, ThreadHandle_used, ThreadContext_used); // NtSetContextThread

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryInformationThread(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ThreadHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	THREADINFOCLASS ThreadInformationClass_used = (THREADINFOCLASS)(x32based_args[3]); // THREADINFOCLASS  IN 
	PVOID ThreadInformation_used = (PVOID)(x32based_args[4]); // PVOID  IN  OUT 
	ULONG ThreadInformationLength_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	PULONG ReturnLength_used = (PULONG)(x32based_args[6]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ThreadHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ThreadHandle);

	// Convert parameters from x32 to x64
	switch (ThreadInformationClass_used) {
	case ThreadBasicInformation: {
		ret_value = _w32_NtQueryInformationThread_ThreadBasicInformation(ctx, syscall_idx, ThreadHandle_used, ThreadInformationClass_used, (THREAD_BASIC_INFORMATION*)ThreadInformation_used, ThreadInformationLength_used, ReturnLength_used);
		break;
	}
	case ThreadLastSystemCall: {
		ret_value = _w32_NtQueryInformationThread_ThreadLastSystemCall(ctx, syscall_idx, ThreadHandle_used, ThreadInformationClass_used, (THREAD_LAST_SYSCALL_INFORMATION*)ThreadInformation_used, ThreadInformationLength_used, ReturnLength_used);
		break;
	}
	case ThreadTebInformation: {
		ret_value = _w32_NtQueryInformationThread_ThreadTebInformation(ctx, syscall_idx, ThreadHandle_used, ThreadInformationClass_used, (THREAD_TEB_INFORMATION*)ThreadInformation_used, ThreadInformationLength_used, ReturnLength_used);
		break;
	}
	case ThreadGroupInformation: {
		ret_value = _w32_NtQueryInformationThread_ThreadGroupInformation(ctx, syscall_idx, ThreadHandle_used, ThreadInformationClass_used, (GROUP_AFFINITY*)ThreadInformation_used, ThreadInformationLength_used, ReturnLength_used);
		break;
	}
	case ThreadCounterProfiling: {
		ret_value = _w32_NtQueryInformationThread_ThreadCounterProfiling(ctx, syscall_idx, ThreadHandle_used, ThreadInformationClass_used, (THREAD_PROFILING_INFORMATION*)ThreadInformation_used, ThreadInformationLength_used, ReturnLength_used);
		break;
	}

	case ThreadNameInformation: {
		ret_value = _w32_NtQueryInformationThread_ThreadNameInformation(ctx, syscall_idx, ThreadHandle_used, ThreadInformationClass_used, (THREAD_NAME_INFORMATION*)ThreadInformation_used, ThreadInformationLength_used, ReturnLength_used);
		break;
	}
	default: {
		ret_value = __syscall64(syscall_idx, 5, ThreadHandle_used, ThreadInformationClass_used, ThreadInformation_used, ThreadInformationLength_used, ReturnLength_used); // NtQueryInformationThread
		break;
	}
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetInformationThread(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ThreadHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	THREADINFOCLASS ThreadInformationClass_used = (THREADINFOCLASS)(x32based_args[3]); // THREADINFOCLASS  IN 
	PVOID ThreadInformation_used = (PVOID)(x32based_args[4]); // PVOID  IN 
	ULONG ThreadInformationLength_used = (ULONG)(x32based_args[5]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ThreadHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ThreadHandle);

	// Convert parameters from x32 to x64
	switch (ThreadInformationClass_used) {
	case ThreadAffinityMask: {
		ret_value = _w32_NtSetInformationThread_ThreadAffinityMask(ctx, syscall_idx, ThreadHandle_used, ThreadInformationClass_used, (KAFFINITY*)ThreadInformation_used, ThreadInformationLength_used);
		break;
	}
	case ThreadGroupInformation: {
		ret_value = _w32_NtSetInformationThread_ThreadGroupInformation(ctx, syscall_idx, ThreadHandle_used, ThreadInformationClass_used, (GROUP_AFFINITY*)ThreadInformation_used, ThreadInformationLength_used);
		break;
	}
	case ThreadCounterProfiling: {
		ret_value = _w32_NtSetInformationThread_ThreadCounterProfiling(ctx, syscall_idx, ThreadHandle_used, ThreadInformationClass_used, (THREAD_PROFILING_INFORMATION*)ThreadInformation_used, ThreadInformationLength_used);
		break;
	}

	case ThreadNameInformation: {
		ret_value = _w32_NtSetInformationThread_ThreadNameInformation(ctx, syscall_idx, ThreadHandle_used, ThreadInformationClass_used, (THREAD_NAME_INFORMATION*)ThreadInformation_used, ThreadInformationLength_used);
		break;
	}
	default: {
		ret_value = __syscall64(syscall_idx, 4, ThreadHandle_used, ThreadInformationClass_used, ThreadInformation_used, ThreadInformationLength_used); // NtSetInformationThread
		break;
	}
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAlertThread(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ThreadHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ThreadHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ThreadHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, ThreadHandle_used); // NtAlertThread

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAlertResumeThread(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ThreadHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PULONG PreviousSuspendCount_used = (PULONG)(x32based_args[3]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ThreadHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ThreadHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, ThreadHandle_used, PreviousSuspendCount_used); // NtAlertResumeThread

	return ret_value;
}


NTSTATUS WINAPI _w32_NtTestAlert(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 0); // NtTestAlert

	return ret_value;
}


NTSTATUS WINAPI _w32_NtImpersonateThread(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ServerThreadHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_ClientThreadHandle = (uint32_t)(x32based_args[3]); // HANDLE  IN 
	PSECURITY_QUALITY_OF_SERVICE SecurityQos_used = (PSECURITY_QUALITY_OF_SERVICE)(x32based_args[4]); // PSECURITY_QUALITY_OF_SERVICE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ServerThreadHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ServerThreadHandle);
	HANDLE ClientThreadHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ClientThreadHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 3, ServerThreadHandle_used, ClientThreadHandle_used, SecurityQos_used); // NtImpersonateThread

	return ret_value;
}


NTSTATUS WINAPI _w32_NtRegisterThreadTerminatePort(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE PortHandle_used = Handle32ToHandle((const void* __ptr32)x32based_PortHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, PortHandle_used); // NtRegisterThreadTerminatePort

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetLdtEntries(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	ULONG Selector0_used = (ULONG)(x32based_args[2]); // ULONG  IN 
	ULONG Entry0Low_used = (ULONG)(x32based_args[3]); // ULONG  IN 
	ULONG Entry0Hi_used = (ULONG)(x32based_args[4]); // ULONG  IN 
	ULONG Selector1_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	ULONG Entry1Low_used = (ULONG)(x32based_args[6]); // ULONG  IN 
	ULONG Entry1Hi_used = (ULONG)(x32based_args[7]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 6, Selector0_used, Entry0Low_used, Entry0Hi_used, Selector1_used, Entry1Low_used, Entry1Hi_used); // NtSetLdtEntries

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueueApcThread(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ThreadHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PPS_APC_ROUTINE ApcRoutine_used = (PPS_APC_ROUTINE)(x32based_args[3]); // PPS_APC_ROUTINE  IN 
	PVOID ApcArgument1_used = (PVOID)(x32based_args[4]); // PVOID  IN 
	PVOID ApcArgument2_used = (PVOID)(x32based_args[5]); // PVOID  IN 
	PVOID ApcArgument3_used = (PVOID)(x32based_args[6]); // PVOID  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ThreadHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ThreadHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 5, ThreadHandle_used, ApcRoutine_used, ApcArgument1_used, ApcArgument2_used, ApcArgument3_used); // NtQueueApcThread

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueueApcThreadEx(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ThreadHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_UserApcReserveHandle = (uint32_t)(x32based_args[3]); // HANDLE  IN 
	PPS_APC_ROUTINE ApcRoutine_used = (PPS_APC_ROUTINE)(x32based_args[4]); // PPS_APC_ROUTINE  IN 
	PVOID ApcArgument1_used = (PVOID)(x32based_args[5]); // PVOID  IN 
	PVOID ApcArgument2_used = (PVOID)(x32based_args[6]); // PVOID  IN 
	PVOID ApcArgument3_used = (PVOID)(x32based_args[7]); // PVOID  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ThreadHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ThreadHandle);
	HANDLE UserApcReserveHandle_used = Handle32ToHandle((const void* __ptr32)x32based_UserApcReserveHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 6, ThreadHandle_used, UserApcReserveHandle_used, ApcRoutine_used, ApcArgument1_used, ApcArgument2_used, ApcArgument3_used); // NtQueueApcThreadEx

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAlertThreadByThreadId(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ThreadId = (uint32_t)(x32based_args[2]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ThreadId_used = Handle32ToHandle((const void* __ptr32)x32based_ThreadId);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, ThreadId_used); // NtAlertThreadByThreadId

	return ret_value;
}


NTSTATUS WINAPI _w32_NtWaitForAlertByThreadId(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PVOID Address_used = (PVOID)(x32based_args[2]); // PVOID  IN 
	PLARGE_INTEGER Timeout_used = (PLARGE_INTEGER)(x32based_args[3]); // PLARGE_INTEGER  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, Address_used, Timeout_used); // NtWaitForAlertByThreadId

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateUserProcess(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	uint32_t x32based_ThreadHandle = (uint32_t)(x32based_args[3]); // PHANDLE  OUT 
	ACCESS_MASK ProcessDesiredAccess_used = (ACCESS_MASK)(x32based_args[4]); // ACCESS_MASK  IN 
	ACCESS_MASK ThreadDesiredAccess_used = (ACCESS_MASK)(x32based_args[5]); // ACCESS_MASK  IN 
	uint32_t x32based_ProcessObjectAttributes = (uint32_t)(x32based_args[6]); // POBJECT_ATTRIBUTES  IN 
	uint32_t x32based_ThreadObjectAttributes = (uint32_t)(x32based_args[7]); // POBJECT_ATTRIBUTES  IN 
	ULONG ProcessFlags_used = (ULONG)(x32based_args[8]); // ULONG  IN 
	ULONG ThreadFlags_used = (ULONG)(x32based_args[9]); // ULONG  IN 
	PVOID ProcessParameters_used = (PVOID)(x32based_args[10]); // PVOID  IN 
	uint32_t x32based_CreateInfo = (uint32_t)(x32based_args[11]); // PPS_CREATE_INFO  IN  OUT 
	uint32_t x32based_AttributeList = (uint32_t)(x32based_args[12]); // PPS_ATTRIBUTE_LIST  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ProcessHandle_holder[sizeof(PVOID)];
	PHANDLE ProcessHandle_used = (PHANDLE)&ProcessHandle_holder;
	uint8_t ThreadHandle_holder[sizeof(PVOID)];
	PHANDLE ThreadHandle_used = (PHANDLE)&ThreadHandle_holder;
	uint8_t ProcessObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ProcessObjectAttributes_used = (POBJECT_ATTRIBUTES)&ProcessObjectAttributes_holder;
	uint8_t ThreadObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ThreadObjectAttributes_used = (POBJECT_ATTRIBUTES)&ThreadObjectAttributes_holder;
	uint8_t CreateInfo_holder[sizeof(_PS_CREATE_INFO)];
	PPS_CREATE_INFO CreateInfo_used = (PPS_CREATE_INFO)&CreateInfo_holder;
	uint8_t AttributeList_holder[sizeof(_PS_ATTRIBUTE_LIST)];
	PPS_ATTRIBUTE_LIST AttributeList_used = (PPS_ATTRIBUTE_LIST)&AttributeList_holder;

	// Convert parameters from x32 to x64
	if (x32based_ProcessHandle == NULL) {
		ProcessHandle_used = 0;
	}
	if (x32based_ThreadHandle == NULL) {
		ThreadHandle_used = 0;
	}
	if (x32based_ProcessObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ProcessObjectAttributes_used, x32based_ProcessObjectAttributes);
	}
	else {
		ProcessObjectAttributes_used = 0;
	}
	if (x32based_ThreadObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ThreadObjectAttributes_used, x32based_ThreadObjectAttributes);
	}
	else {
		ThreadObjectAttributes_used = 0;
	}
	if (x32based_CreateInfo != NULL) {
		convert__PS_CREATE_INFO_32TO64(ctx, (_PS_CREATE_INFO**)&CreateInfo_used, x32based_CreateInfo);
	}
	else {
		CreateInfo_used = 0;
	}
	if (x32based_AttributeList != NULL) {
		convert__PS_ATTRIBUTE_LIST_32TO64(ctx, (_PS_ATTRIBUTE_LIST**)&AttributeList_used, x32based_AttributeList);
	}
	else {
		AttributeList_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 11, ProcessHandle_used, ThreadHandle_used, ProcessDesiredAccess_used, ThreadDesiredAccess_used, ProcessObjectAttributes_used, ThreadObjectAttributes_used, ProcessFlags_used, ThreadFlags_used, ProcessParameters_used, CreateInfo_used, AttributeList_used); // NtCreateUserProcess

	if (ProcessHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)ProcessHandle_used, x32based_ProcessHandle);
	}
	if (ThreadHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)ThreadHandle_used, x32based_ThreadHandle);
	}
	if (CreateInfo_used != NULL) {
		convert__PS_CREATE_INFO_64TO32(ctx, (_PS_CREATE_INFO*)CreateInfo_used, x32based_CreateInfo);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateThreadEx(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ThreadHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[5]); // HANDLE  IN 
	PVOID StartRoutine_used = (PVOID)(x32based_args[6]); // PVOID  IN 
	PVOID Argument_used = (PVOID)(x32based_args[7]); // PVOID  IN 
	ULONG CreateFlags_used = (ULONG)(x32based_args[8]); // ULONG  IN 
	SIZE_T ZeroBits_used = (SIZE_T)(x32based_args[9]); // SIZE_T  IN 
	SIZE_T StackSize_used = (SIZE_T)(x32based_args[10]); // SIZE_T  IN 
	SIZE_T MaximumStackSize_used = (SIZE_T)(x32based_args[11]); // SIZE_T  IN 
	uint32_t x32based_AttributeList = (uint32_t)(x32based_args[12]); // PPS_ATTRIBUTE_LIST  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ThreadHandle_holder[sizeof(PVOID)];
	PHANDLE ThreadHandle_used = (PHANDLE)&ThreadHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);
	uint8_t AttributeList_holder[sizeof(_PS_ATTRIBUTE_LIST)];
	PPS_ATTRIBUTE_LIST AttributeList_used = (PPS_ATTRIBUTE_LIST)&AttributeList_holder;

	// Convert parameters from x32 to x64
	if (x32based_ThreadHandle == NULL) {
		ThreadHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}
	if (x32based_AttributeList != NULL) {
		convert__PS_ATTRIBUTE_LIST_32TO64(ctx, (_PS_ATTRIBUTE_LIST**)&AttributeList_used, x32based_AttributeList);
	}
	else {
		AttributeList_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 11, ThreadHandle_used, DesiredAccess_used, ObjectAttributes_used, ProcessHandle_used, StartRoutine_used, Argument_used, CreateFlags_used, ZeroBits_used, StackSize_used, MaximumStackSize_used, AttributeList_used); // NtCreateThreadEx

	if (ThreadHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)ThreadHandle_used, x32based_ThreadHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateJobObject(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_JobHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t JobHandle_holder[sizeof(PVOID)];
	PHANDLE JobHandle_used = (PHANDLE)&JobHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_JobHandle == NULL) {
		JobHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, JobHandle_used, DesiredAccess_used, ObjectAttributes_used); // NtCreateJobObject

	if (JobHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)JobHandle_used, x32based_JobHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtOpenJobObject(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_JobHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t JobHandle_holder[sizeof(PVOID)];
	PHANDLE JobHandle_used = (PHANDLE)&JobHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_JobHandle == NULL) {
		JobHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, JobHandle_used, DesiredAccess_used, ObjectAttributes_used); // NtOpenJobObject

	if (JobHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)JobHandle_used, x32based_JobHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAssignProcessToJobObject(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_JobHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[3]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE JobHandle_used = Handle32ToHandle((const void* __ptr32)x32based_JobHandle);
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, JobHandle_used, ProcessHandle_used); // NtAssignProcessToJobObject

	return ret_value;
}


NTSTATUS WINAPI _w32_NtTerminateJobObject(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_JobHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	NTSTATUS ExitStatus_used = (NTSTATUS)(x32based_args[3]); // NTSTATUS  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE JobHandle_used = Handle32ToHandle((const void* __ptr32)x32based_JobHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, JobHandle_used, ExitStatus_used); // NtTerminateJobObject

	return ret_value;
}


NTSTATUS WINAPI _w32_NtIsProcessInJob(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_JobHandle = (uint32_t)(x32based_args[3]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);
	HANDLE JobHandle_used = Handle32ToHandle((const void* __ptr32)x32based_JobHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, ProcessHandle_used, JobHandle_used); // NtIsProcessInJob

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryInformationJobObject(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_JobHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	JOBOBJECTINFOCLASS JobObjectInformationClass_used = (JOBOBJECTINFOCLASS)(x32based_args[3]); // JOBOBJECTINFOCLASS  IN 
	PVOID JobObjectInformation_used = (PVOID)(x32based_args[4]); // PVOID  IN  OUT 
	ULONG JobObjectInformationLength_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	PULONG ReturnLength_used = (PULONG)(x32based_args[6]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE JobHandle_used = Handle32ToHandle((const void* __ptr32)x32based_JobHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 5, JobHandle_used, JobObjectInformationClass_used, JobObjectInformation_used, JobObjectInformationLength_used, ReturnLength_used); // NtQueryInformationJobObject

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetInformationJobObject(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_JobHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	JOBOBJECTINFOCLASS JobObjectInformationClass_used = (JOBOBJECTINFOCLASS)(x32based_args[3]); // JOBOBJECTINFOCLASS  IN 
	PVOID JobObjectInformation_used = (PVOID)(x32based_args[4]); // PVOID  IN 
	ULONG JobObjectInformationLength_used = (ULONG)(x32based_args[5]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE JobHandle_used = Handle32ToHandle((const void* __ptr32)x32based_JobHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 4, JobHandle_used, JobObjectInformationClass_used, JobObjectInformation_used, JobObjectInformationLength_used); // NtSetInformationJobObject

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateJobSet(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	ULONG NumJob_used = (ULONG)(x32based_args[2]); // ULONG  IN 
	uint32_t x32based_UserJobSet = (uint32_t)(x32based_args[3]); // PJOB_SET_ARRAY  IN 
	ULONG Flags_used = (ULONG)(x32based_args[4]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t UserJobSet_holder[sizeof(_JOB_SET_ARRAY)];
	PJOB_SET_ARRAY UserJobSet_used = (PJOB_SET_ARRAY)&UserJobSet_holder;

	// Convert parameters from x32 to x64
	if (x32based_UserJobSet != NULL) {
		convert__JOB_SET_ARRAY_32TO64(ctx, (_JOB_SET_ARRAY**)&UserJobSet_used, x32based_UserJobSet);
	}
	else {
		UserJobSet_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, NumJob_used, UserJobSet_used, Flags_used); // NtCreateJobSet

	return ret_value;
}


NTSTATUS WINAPI _w32_NtRevertContainerImpersonation(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 0); // NtRevertContainerImpersonation

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAllocateReserveObject(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_MemoryReserveHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[3]); // POBJECT_ATTRIBUTES  IN 
	MEMORY_RESERVE_TYPE Type_used = (MEMORY_RESERVE_TYPE)(x32based_args[4]); // MEMORY_RESERVE_TYPE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t MemoryReserveHandle_holder[sizeof(PVOID)];
	PHANDLE MemoryReserveHandle_used = (PHANDLE)&MemoryReserveHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_MemoryReserveHandle == NULL) {
		MemoryReserveHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, MemoryReserveHandle_used, ObjectAttributes_used, Type_used); // NtAllocateReserveObject

	if (MemoryReserveHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)MemoryReserveHandle_used, x32based_MemoryReserveHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateDebugObject(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_DebugObjectHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	ULONG Flags_used = (ULONG)(x32based_args[5]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t DebugObjectHandle_holder[sizeof(PVOID)];
	PHANDLE DebugObjectHandle_used = (PHANDLE)&DebugObjectHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_DebugObjectHandle == NULL) {
		DebugObjectHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, DebugObjectHandle_used, DesiredAccess_used, ObjectAttributes_used, Flags_used); // NtCreateDebugObject

	if (DebugObjectHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)DebugObjectHandle_used, x32based_DebugObjectHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtDebugActiveProcess(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_DebugObjectHandle = (uint32_t)(x32based_args[3]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);
	HANDLE DebugObjectHandle_used = Handle32ToHandle((const void* __ptr32)x32based_DebugObjectHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, ProcessHandle_used, DebugObjectHandle_used); // NtDebugActiveProcess

	return ret_value;
}


NTSTATUS WINAPI _w32_NtDebugContinue(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_DebugObjectHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_ClientId = (uint32_t)(x32based_args[3]); // PCLIENT_ID  IN 
	NTSTATUS ContinueStatus_used = (NTSTATUS)(x32based_args[4]); // NTSTATUS  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE DebugObjectHandle_used = Handle32ToHandle((const void* __ptr32)x32based_DebugObjectHandle);
	uint8_t ClientId_holder[sizeof(_CLIENT_ID)];
	PCLIENT_ID ClientId_used = (PCLIENT_ID)&ClientId_holder;

	// Convert parameters from x32 to x64
	if (x32based_ClientId != NULL) {
		convert__CLIENT_ID_32TO64(ctx, (_CLIENT_ID**)&ClientId_used, x32based_ClientId);
	}
	else {
		ClientId_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, DebugObjectHandle_used, ClientId_used, ContinueStatus_used); // NtDebugContinue

	return ret_value;
}


NTSTATUS WINAPI _w32_NtRemoveProcessDebug(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_DebugObjectHandle = (uint32_t)(x32based_args[3]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);
	HANDLE DebugObjectHandle_used = Handle32ToHandle((const void* __ptr32)x32based_DebugObjectHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, ProcessHandle_used, DebugObjectHandle_used); // NtRemoveProcessDebug

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetInformationDebugObject(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_DebugObjectHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	DEBUGOBJECTINFOCLASS DebugObjectInformationClass_used = (DEBUGOBJECTINFOCLASS)(x32based_args[3]); // DEBUGOBJECTINFOCLASS  IN 
	PVOID DebugInformation_used = (PVOID)(x32based_args[4]); // PVOID  IN 
	ULONG DebugInformationLength_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	PULONG ReturnLength_used = (PULONG)(x32based_args[6]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE DebugObjectHandle_used = Handle32ToHandle((const void* __ptr32)x32based_DebugObjectHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 5, DebugObjectHandle_used, DebugObjectInformationClass_used, DebugInformation_used, DebugInformationLength_used, ReturnLength_used); // NtSetInformationDebugObject

	return ret_value;
}


NTSTATUS WINAPI _w32_NtWaitForDebugEvent(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_DebugObjectHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	BOOLEAN Alertable_used = (BOOLEAN)(x32based_args[3]); // BOOLEAN  IN 
	PLARGE_INTEGER Timeout_used = (PLARGE_INTEGER)(x32based_args[4]); // PLARGE_INTEGER  IN 
	uint32_t x32based_WaitStateChange = (uint32_t)(x32based_args[5]); // PDBGUI_WAIT_STATE_CHANGE  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE DebugObjectHandle_used = Handle32ToHandle((const void* __ptr32)x32based_DebugObjectHandle);
	uint8_t WaitStateChange_holder[sizeof(_DBGUI_WAIT_STATE_CHANGE)];
	PDBGUI_WAIT_STATE_CHANGE WaitStateChange_used = (PDBGUI_WAIT_STATE_CHANGE)&WaitStateChange_holder;

	// Convert parameters from x32 to x64
	if (x32based_WaitStateChange == NULL) {
		WaitStateChange_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 4, DebugObjectHandle_used, Alertable_used, Timeout_used, WaitStateChange_used); // NtWaitForDebugEvent

	if (WaitStateChange_used != NULL) {
		convert__DBGUI_WAIT_STATE_CHANGE_64TO32(ctx, (_DBGUI_WAIT_STATE_CHANGE*)WaitStateChange_used, x32based_WaitStateChange);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateFile(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_FileHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	uint32_t x32based_IoStatusBlock = (uint32_t)(x32based_args[5]); // PIO_STATUS_BLOCK  OUT 
	PLARGE_INTEGER AllocationSize_used = (PLARGE_INTEGER)(x32based_args[6]); // PLARGE_INTEGER  IN 
	ULONG FileAttributes_used = (ULONG)(x32based_args[7]); // ULONG  IN 
	ULONG ShareAccess_used = (ULONG)(x32based_args[8]); // ULONG  IN 
	ULONG CreateDisposition_used = (ULONG)(x32based_args[9]); // ULONG  IN 
	ULONG CreateOptions_used = (ULONG)(x32based_args[10]); // ULONG  IN 
	PVOID EaBuffer_used = (PVOID)(x32based_args[11]); // PVOID  IN 
	ULONG EaLength_used = (ULONG)(x32based_args[12]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t FileHandle_holder[sizeof(PVOID)];
	PHANDLE FileHandle_used = (PHANDLE)&FileHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;
	uint8_t IoStatusBlock_holder[sizeof(_IO_STATUS_BLOCK)];
	PIO_STATUS_BLOCK IoStatusBlock_used = (PIO_STATUS_BLOCK)&IoStatusBlock_holder;

	// Convert parameters from x32 to x64
	if (x32based_FileHandle == NULL) {
		FileHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}
	if (x32based_IoStatusBlock == NULL) {
		IoStatusBlock_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 11, FileHandle_used, DesiredAccess_used, ObjectAttributes_used, IoStatusBlock_used, AllocationSize_used, FileAttributes_used, ShareAccess_used, CreateDisposition_used, CreateOptions_used, EaBuffer_used, EaLength_used); // NtCreateFile

	if (FileHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)FileHandle_used, x32based_FileHandle);
	}
	if (IoStatusBlock_used != NULL) {
		convert__IO_STATUS_BLOCK_64TO32(ctx, (_IO_STATUS_BLOCK*)IoStatusBlock_used, x32based_IoStatusBlock);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateNamedPipeFile(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_FileHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ULONG DesiredAccess_used = (ULONG)(x32based_args[3]); // ULONG  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	uint32_t x32based_IoStatusBlock = (uint32_t)(x32based_args[5]); // PIO_STATUS_BLOCK  OUT 
	ULONG ShareAccess_used = (ULONG)(x32based_args[6]); // ULONG  IN 
	ULONG CreateDisposition_used = (ULONG)(x32based_args[7]); // ULONG  IN 
	ULONG CreateOptions_used = (ULONG)(x32based_args[8]); // ULONG  IN 
	ULONG NamedPipeType_used = (ULONG)(x32based_args[9]); // ULONG  IN 
	ULONG ReadMode_used = (ULONG)(x32based_args[10]); // ULONG  IN 
	ULONG CompletionMode_used = (ULONG)(x32based_args[11]); // ULONG  IN 
	ULONG MaximumInstances_used = (ULONG)(x32based_args[12]); // ULONG  IN 
	ULONG InboundQuota_used = (ULONG)(x32based_args[13]); // ULONG  IN 
	ULONG OutboundQuota_used = (ULONG)(x32based_args[14]); // ULONG  IN 
	PLARGE_INTEGER DefaultTimeout_used = (PLARGE_INTEGER)(x32based_args[15]); // PLARGE_INTEGER  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t FileHandle_holder[sizeof(PVOID)];
	PHANDLE FileHandle_used = (PHANDLE)&FileHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;
	uint8_t IoStatusBlock_holder[sizeof(_IO_STATUS_BLOCK)];
	PIO_STATUS_BLOCK IoStatusBlock_used = (PIO_STATUS_BLOCK)&IoStatusBlock_holder;

	// Convert parameters from x32 to x64
	if (x32based_FileHandle == NULL) {
		FileHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}
	if (x32based_IoStatusBlock == NULL) {
		IoStatusBlock_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 14, FileHandle_used, DesiredAccess_used, ObjectAttributes_used, IoStatusBlock_used, ShareAccess_used, CreateDisposition_used, CreateOptions_used, NamedPipeType_used, ReadMode_used, CompletionMode_used, MaximumInstances_used, InboundQuota_used, OutboundQuota_used, DefaultTimeout_used); // NtCreateNamedPipeFile

	if (FileHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)FileHandle_used, x32based_FileHandle);
	}
	if (IoStatusBlock_used != NULL) {
		convert__IO_STATUS_BLOCK_64TO32(ctx, (_IO_STATUS_BLOCK*)IoStatusBlock_used, x32based_IoStatusBlock);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateMailslotFile(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_FileHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ULONG DesiredAccess_used = (ULONG)(x32based_args[3]); // ULONG  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	uint32_t x32based_IoStatusBlock = (uint32_t)(x32based_args[5]); // PIO_STATUS_BLOCK  OUT 
	ULONG CreateOptions_used = (ULONG)(x32based_args[6]); // ULONG  IN 
	ULONG MailslotQuota_used = (ULONG)(x32based_args[7]); // ULONG  IN 
	ULONG MaximumMessageSize_used = (ULONG)(x32based_args[8]); // ULONG  IN 
	PLARGE_INTEGER ReadTimeout_used = (PLARGE_INTEGER)(x32based_args[9]); // PLARGE_INTEGER  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t FileHandle_holder[sizeof(PVOID)];
	PHANDLE FileHandle_used = (PHANDLE)&FileHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;
	uint8_t IoStatusBlock_holder[sizeof(_IO_STATUS_BLOCK)];
	PIO_STATUS_BLOCK IoStatusBlock_used = (PIO_STATUS_BLOCK)&IoStatusBlock_holder;

	// Convert parameters from x32 to x64
	if (x32based_FileHandle == NULL) {
		FileHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}
	if (x32based_IoStatusBlock == NULL) {
		IoStatusBlock_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 8, FileHandle_used, DesiredAccess_used, ObjectAttributes_used, IoStatusBlock_used, CreateOptions_used, MailslotQuota_used, MaximumMessageSize_used, ReadTimeout_used); // NtCreateMailslotFile

	if (FileHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)FileHandle_used, x32based_FileHandle);
	}
	if (IoStatusBlock_used != NULL) {
		convert__IO_STATUS_BLOCK_64TO32(ctx, (_IO_STATUS_BLOCK*)IoStatusBlock_used, x32based_IoStatusBlock);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtOpenFile(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_FileHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	uint32_t x32based_IoStatusBlock = (uint32_t)(x32based_args[5]); // PIO_STATUS_BLOCK  OUT 
	ULONG ShareAccess_used = (ULONG)(x32based_args[6]); // ULONG  IN 
	ULONG OpenOptions_used = (ULONG)(x32based_args[7]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t FileHandle_holder[sizeof(PVOID)];
	PHANDLE FileHandle_used = (PHANDLE)&FileHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;
	uint8_t IoStatusBlock_holder[sizeof(_IO_STATUS_BLOCK)];
	PIO_STATUS_BLOCK IoStatusBlock_used = (PIO_STATUS_BLOCK)&IoStatusBlock_holder;

	// Convert parameters from x32 to x64
	if (x32based_FileHandle == NULL) {
		FileHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}
	if (x32based_IoStatusBlock == NULL) {
		IoStatusBlock_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 6, FileHandle_used, DesiredAccess_used, ObjectAttributes_used, IoStatusBlock_used, ShareAccess_used, OpenOptions_used); // NtOpenFile

	if (FileHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)FileHandle_used, x32based_FileHandle);
	}
	if (IoStatusBlock_used != NULL) {
		convert__IO_STATUS_BLOCK_64TO32(ctx, (_IO_STATUS_BLOCK*)IoStatusBlock_used, x32based_IoStatusBlock);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtDeleteFile(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[2]); // POBJECT_ATTRIBUTES  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 1, ObjectAttributes_used); // NtDeleteFile

	return ret_value;
}


NTSTATUS WINAPI _w32_NtFlushBuffersFile(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_FileHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_IoStatusBlock = (uint32_t)(x32based_args[3]); // PIO_STATUS_BLOCK  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE FileHandle_used = Handle32ToHandle((const void* __ptr32)x32based_FileHandle);
	uint8_t IoStatusBlock_holder[sizeof(_IO_STATUS_BLOCK)];
	PIO_STATUS_BLOCK IoStatusBlock_used = (PIO_STATUS_BLOCK)&IoStatusBlock_holder;

	// Convert parameters from x32 to x64
	if (x32based_IoStatusBlock == NULL) {
		IoStatusBlock_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 2, FileHandle_used, IoStatusBlock_used); // NtFlushBuffersFile

	if (IoStatusBlock_used != NULL) {
		convert__IO_STATUS_BLOCK_64TO32(ctx, (_IO_STATUS_BLOCK*)IoStatusBlock_used, x32based_IoStatusBlock);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtFlushBuffersFileEx(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_FileHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	ULONG Flags_used = (ULONG)(x32based_args[3]); // ULONG  IN 
	PVOID Parameters_used = (PVOID)(x32based_args[4]); // PVOID  IN 
	ULONG ParametersSize_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	uint32_t x32based_IoStatusBlock = (uint32_t)(x32based_args[6]); // PIO_STATUS_BLOCK  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE FileHandle_used = Handle32ToHandle((const void* __ptr32)x32based_FileHandle);
	uint8_t IoStatusBlock_holder[sizeof(_IO_STATUS_BLOCK)];
	PIO_STATUS_BLOCK IoStatusBlock_used = (PIO_STATUS_BLOCK)&IoStatusBlock_holder;

	// Convert parameters from x32 to x64
	if (x32based_IoStatusBlock == NULL) {
		IoStatusBlock_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 5, FileHandle_used, Flags_used, Parameters_used, ParametersSize_used, IoStatusBlock_used); // NtFlushBuffersFileEx

	if (IoStatusBlock_used != NULL) {
		convert__IO_STATUS_BLOCK_64TO32(ctx, (_IO_STATUS_BLOCK*)IoStatusBlock_used, x32based_IoStatusBlock);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryInformationFile(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_FileHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_IoStatusBlock = (uint32_t)(x32based_args[3]); // PIO_STATUS_BLOCK  OUT 
	PVOID FileInformation_used = (PVOID)(x32based_args[4]); // PVOID  OUT 
	ULONG Length_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	FILE_INFORMATION_CLASS FileInformationClass_used = (FILE_INFORMATION_CLASS)(x32based_args[6]); // FILE_INFORMATION_CLASS  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE FileHandle_used = Handle32ToHandle((const void* __ptr32)x32based_FileHandle);
	uint8_t IoStatusBlock_holder[sizeof(_IO_STATUS_BLOCK)];
	PIO_STATUS_BLOCK IoStatusBlock_used = (PIO_STATUS_BLOCK)&IoStatusBlock_holder;

	// Convert parameters from x32 to x64
	if (x32based_IoStatusBlock == NULL) {
		IoStatusBlock_used = 0;
	}
	switch (FileInformationClass_used) {
	default: {
		ret_value = __syscall64(syscall_idx, 5, FileHandle_used, IoStatusBlock_used, FileInformation_used, Length_used, FileInformationClass_used); // NtQueryInformationFile
		break;
	}
	}

	if (IoStatusBlock_used != NULL) {
		convert__IO_STATUS_BLOCK_64TO32(ctx, (_IO_STATUS_BLOCK*)IoStatusBlock_used, x32based_IoStatusBlock);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryInformationByName(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[2]); // POBJECT_ATTRIBUTES  IN 
	uint32_t x32based_IoStatusBlock = (uint32_t)(x32based_args[3]); // PIO_STATUS_BLOCK  OUT 
	PVOID FileInformation_used = (PVOID)(x32based_args[4]); // PVOID  OUT 
	ULONG Length_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	FILE_INFORMATION_CLASS FileInformationClass_used = (FILE_INFORMATION_CLASS)(x32based_args[6]); // FILE_INFORMATION_CLASS  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;
	uint8_t IoStatusBlock_holder[sizeof(_IO_STATUS_BLOCK)];
	PIO_STATUS_BLOCK IoStatusBlock_used = (PIO_STATUS_BLOCK)&IoStatusBlock_holder;

	// Convert parameters from x32 to x64
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}
	if (x32based_IoStatusBlock == NULL) {
		IoStatusBlock_used = 0;
	}

	switch (FileInformationClass_used) {
	default: {
		ret_value = __syscall64(syscall_idx, 5, ObjectAttributes_used, IoStatusBlock_used, FileInformation_used, Length_used, FileInformationClass_used); // NtQueryInformationByName
		break;
	}
	}

	if (IoStatusBlock_used != NULL) {
		convert__IO_STATUS_BLOCK_64TO32(ctx, (_IO_STATUS_BLOCK*)IoStatusBlock_used, x32based_IoStatusBlock);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetInformationFile(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_FileHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_IoStatusBlock = (uint32_t)(x32based_args[3]); // PIO_STATUS_BLOCK  OUT 
	PVOID FileInformation_used = (PVOID)(x32based_args[4]); // PVOID  IN 
	ULONG Length_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	FILE_INFORMATION_CLASS FileInformationClass_used = (FILE_INFORMATION_CLASS)(x32based_args[6]); // FILE_INFORMATION_CLASS  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE FileHandle_used = Handle32ToHandle((const void* __ptr32)x32based_FileHandle);
	uint8_t IoStatusBlock_holder[sizeof(_IO_STATUS_BLOCK)];
	PIO_STATUS_BLOCK IoStatusBlock_used = (PIO_STATUS_BLOCK)&IoStatusBlock_holder;

	// Convert parameters from x32 to x64
	if (x32based_IoStatusBlock == NULL) {
		IoStatusBlock_used = 0;
	}
	switch (FileInformationClass_used) {
	case FileRenameInformation: {
		ret_value = _w32_NtSetInformationFile_FileRenameInformation(ctx, syscall_idx, FileHandle_used, IoStatusBlock_used, (FILE_RENAME_INFORMATION*)FileInformation_used, Length_used, FileInformationClass_used);
		break;
	}
	case FileLinkInformation: {
		ret_value = _w32_NtSetInformationFile_FileLinkInformation(ctx, syscall_idx, FileHandle_used, IoStatusBlock_used, (FILE_LINK_INFORMATION*)FileInformation_used, Length_used, FileInformationClass_used);
		break;
	}
	case FileMailslotSetInformation: {
		ret_value = _w32_NtSetInformationFile_FileMailslotSetInformation(ctx, syscall_idx, FileHandle_used, IoStatusBlock_used, (FILE_MAILSLOT_SET_INFORMATION*)FileInformation_used, Length_used, FileInformationClass_used);
		break;
	}
	case FileCompletionInformation: {
		ret_value = _w32_NtSetInformationFile_FileCompletionInformation(ctx, syscall_idx, FileHandle_used, IoStatusBlock_used, (FILE_COMPLETION_INFORMATION*)FileInformation_used, Length_used, FileInformationClass_used);
		break;
	}
	case FileMoveClusterInformation: {
		ret_value = _w32_NtSetInformationFile_FileMoveClusterInformation(ctx, syscall_idx, FileHandle_used, IoStatusBlock_used, (FILE_MOVE_CLUSTER_INFORMATION*)FileInformation_used, Length_used, FileInformationClass_used);
		break;
	}
	case FileTrackingInformation: {
		ret_value = _w32_NtSetInformationFile_FileTrackingInformation(ctx, syscall_idx, FileHandle_used, IoStatusBlock_used, (FILE_TRACKING_INFORMATION*)FileInformation_used, Length_used, FileInformationClass_used);
		break;
	}
	case FileIoStatusBlockRangeInformation: {
		ret_value = _w32_NtSetInformationFile_FileIoStatusBlockRangeInformation(ctx, syscall_idx, FileHandle_used, IoStatusBlock_used, (FILE_IOSTATUSBLOCK_RANGE_INFORMATION*)FileInformation_used, Length_used, FileInformationClass_used);
		break;
	}
	case FileReplaceCompletionInformation: {
		ret_value = _w32_NtSetInformationFile_FileReplaceCompletionInformation(ctx, syscall_idx, FileHandle_used, IoStatusBlock_used, (FILE_COMPLETION_INFORMATION*)FileInformation_used, Length_used, FileInformationClass_used);
		break;
	}
	case FileRenameInformationEx: {
		ret_value = _w32_NtSetInformationFile_FileRenameInformationEx(ctx, syscall_idx, FileHandle_used, IoStatusBlock_used, (FILE_RENAME_INFORMATION_EX*)FileInformation_used, Length_used, FileInformationClass_used);
		break;
	}
	case FileMemoryPartitionInformation: {
		ret_value = _w32_NtSetInformationFile_FileMemoryPartitionInformation(ctx, syscall_idx, FileHandle_used, IoStatusBlock_used, (FILE_MEMORY_PARTITION_INFORMATION*)FileInformation_used, Length_used, FileInformationClass_used);
		break;
	}
	case FileLinkInformationEx: {
		ret_value = _w32_NtSetInformationFile_FileLinkInformationEx(ctx, syscall_idx, FileHandle_used, IoStatusBlock_used, (FILE_LINK_INFORMATION_EX*)FileInformation_used, Length_used, FileInformationClass_used);
		break;
	}
	default: {
		ret_value = __syscall64(syscall_idx, 5, FileHandle_used, IoStatusBlock_used, FileInformation_used, Length_used, FileInformationClass_used); // NtSetInformationFile
		break;
	}
	}

	if (IoStatusBlock_used != NULL) {
		convert__IO_STATUS_BLOCK_64TO32(ctx, (_IO_STATUS_BLOCK*)IoStatusBlock_used, x32based_IoStatusBlock);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryDirectoryFile(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_FileHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_Event = (uint32_t)(x32based_args[3]); // HANDLE  IN 
	PIO_APC_ROUTINE ApcRoutine_used = (PIO_APC_ROUTINE)(x32based_args[4]); // PIO_APC_ROUTINE  IN 
	PVOID ApcContext_used = (PVOID)(x32based_args[5]); // PVOID  IN 
	uint32_t x32based_IoStatusBlock = (uint32_t)(x32based_args[6]); // PIO_STATUS_BLOCK  OUT 
	PVOID FileInformation_used = (PVOID)(x32based_args[7]); // PVOID  OUT 
	ULONG Length_used = (ULONG)(x32based_args[8]); // ULONG  IN 
	FILE_INFORMATION_CLASS FileInformationClass_used = (FILE_INFORMATION_CLASS)(x32based_args[9]); // FILE_INFORMATION_CLASS  IN 
	BOOLEAN ReturnSingleEntry_used = (BOOLEAN)(x32based_args[10]); // BOOLEAN  IN 
	uint32_t x32based_FileName = (uint32_t)(x32based_args[11]); // PUNICODE_STRING  IN 
	BOOLEAN RestartScan_used = (BOOLEAN)(x32based_args[12]); // BOOLEAN  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE FileHandle_used = Handle32ToHandle((const void* __ptr32)x32based_FileHandle);
	HANDLE Event_used = Handle32ToHandle((const void* __ptr32)x32based_Event);
	uint8_t IoStatusBlock_holder[sizeof(_IO_STATUS_BLOCK)];
	PIO_STATUS_BLOCK IoStatusBlock_used = (PIO_STATUS_BLOCK)&IoStatusBlock_holder;
	uint8_t FileName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING FileName_used = (PUNICODE_STRING)&FileName_holder;

	// Convert parameters from x32 to x64
	if (x32based_IoStatusBlock == NULL) {
		IoStatusBlock_used = 0;
	}
	if (x32based_FileName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&FileName_used, x32based_FileName);
	}
	else {
		FileName_used = 0;
	}

	switch (FileInformationClass_used) {
	default: {
		ret_value = __syscall64(syscall_idx, 11, FileHandle_used, Event_used, ApcRoutine_used, ApcContext_used, IoStatusBlock_used, FileInformation_used, Length_used, FileInformationClass_used, ReturnSingleEntry_used, FileName_used, RestartScan_used); // NtQueryDirectoryFile
		break;
	}
	}

	if (IoStatusBlock_used != NULL) {
		convert__IO_STATUS_BLOCK_64TO32(ctx, (_IO_STATUS_BLOCK*)IoStatusBlock_used, x32based_IoStatusBlock);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryDirectoryFileEx(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_FileHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_Event = (uint32_t)(x32based_args[3]); // HANDLE  IN 
	PIO_APC_ROUTINE ApcRoutine_used = (PIO_APC_ROUTINE)(x32based_args[4]); // PIO_APC_ROUTINE  IN 
	PVOID ApcContext_used = (PVOID)(x32based_args[5]); // PVOID  IN 
	uint32_t x32based_IoStatusBlock = (uint32_t)(x32based_args[6]); // PIO_STATUS_BLOCK  OUT 
	PVOID FileInformation_used = (PVOID)(x32based_args[7]); // PVOID  OUT 
	ULONG Length_used = (ULONG)(x32based_args[8]); // ULONG  IN 
	FILE_INFORMATION_CLASS FileInformationClass_used = (FILE_INFORMATION_CLASS)(x32based_args[9]); // FILE_INFORMATION_CLASS  IN 
	ULONG QueryFlags_used = (ULONG)(x32based_args[10]); // ULONG  IN 
	uint32_t x32based_FileName = (uint32_t)(x32based_args[11]); // PUNICODE_STRING  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE FileHandle_used = Handle32ToHandle((const void* __ptr32)x32based_FileHandle);
	HANDLE Event_used = Handle32ToHandle((const void* __ptr32)x32based_Event);
	uint8_t IoStatusBlock_holder[sizeof(_IO_STATUS_BLOCK)];
	PIO_STATUS_BLOCK IoStatusBlock_used = (PIO_STATUS_BLOCK)&IoStatusBlock_holder;
	uint8_t FileName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING FileName_used = (PUNICODE_STRING)&FileName_holder;

	// Convert parameters from x32 to x64
	if (x32based_IoStatusBlock == NULL) {
		IoStatusBlock_used = 0;
	}
	if (x32based_FileName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&FileName_used, x32based_FileName);
	}
	else {
		FileName_used = 0;
	}

	switch (FileInformationClass_used) {
	default: {
		ret_value = __syscall64(syscall_idx, 10, FileHandle_used, Event_used, ApcRoutine_used, ApcContext_used, IoStatusBlock_used, FileInformation_used, Length_used, FileInformationClass_used, QueryFlags_used, FileName_used); // NtQueryDirectoryFileEx
		break;
	}
	}

	if (IoStatusBlock_used != NULL) {
		convert__IO_STATUS_BLOCK_64TO32(ctx, (_IO_STATUS_BLOCK*)IoStatusBlock_used, x32based_IoStatusBlock);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryEaFile(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_FileHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_IoStatusBlock = (uint32_t)(x32based_args[3]); // PIO_STATUS_BLOCK  OUT 
	PVOID Buffer_used = (PVOID)(x32based_args[4]); // PVOID  OUT 
	ULONG Length_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	BOOLEAN ReturnSingleEntry_used = (BOOLEAN)(x32based_args[6]); // BOOLEAN  IN 
	PVOID EaList_used = (PVOID)(x32based_args[7]); // PVOID  IN 
	ULONG EaListLength_used = (ULONG)(x32based_args[8]); // ULONG  IN 
	PULONG EaIndex_used = (PULONG)(x32based_args[9]); // PULONG  IN 
	BOOLEAN RestartScan_used = (BOOLEAN)(x32based_args[10]); // BOOLEAN  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE FileHandle_used = Handle32ToHandle((const void* __ptr32)x32based_FileHandle);
	uint8_t IoStatusBlock_holder[sizeof(_IO_STATUS_BLOCK)];
	PIO_STATUS_BLOCK IoStatusBlock_used = (PIO_STATUS_BLOCK)&IoStatusBlock_holder;

	// Convert parameters from x32 to x64
	if (x32based_IoStatusBlock == NULL) {
		IoStatusBlock_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 9, FileHandle_used, IoStatusBlock_used, Buffer_used, Length_used, ReturnSingleEntry_used, EaList_used, EaListLength_used, EaIndex_used, RestartScan_used); // NtQueryEaFile

	if (IoStatusBlock_used != NULL) {
		convert__IO_STATUS_BLOCK_64TO32(ctx, (_IO_STATUS_BLOCK*)IoStatusBlock_used, x32based_IoStatusBlock);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetEaFile(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_FileHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_IoStatusBlock = (uint32_t)(x32based_args[3]); // PIO_STATUS_BLOCK  OUT 
	PVOID Buffer_used = (PVOID)(x32based_args[4]); // PVOID  IN 
	ULONG Length_used = (ULONG)(x32based_args[5]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE FileHandle_used = Handle32ToHandle((const void* __ptr32)x32based_FileHandle);
	uint8_t IoStatusBlock_holder[sizeof(_IO_STATUS_BLOCK)];
	PIO_STATUS_BLOCK IoStatusBlock_used = (PIO_STATUS_BLOCK)&IoStatusBlock_holder;

	// Convert parameters from x32 to x64
	if (x32based_IoStatusBlock == NULL) {
		IoStatusBlock_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 4, FileHandle_used, IoStatusBlock_used, Buffer_used, Length_used); // NtSetEaFile

	if (IoStatusBlock_used != NULL) {
		convert__IO_STATUS_BLOCK_64TO32(ctx, (_IO_STATUS_BLOCK*)IoStatusBlock_used, x32based_IoStatusBlock);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryQuotaInformationFile(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_FileHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_IoStatusBlock = (uint32_t)(x32based_args[3]); // PIO_STATUS_BLOCK  OUT 
	PVOID Buffer_used = (PVOID)(x32based_args[4]); // PVOID  OUT 
	ULONG Length_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	BOOLEAN ReturnSingleEntry_used = (BOOLEAN)(x32based_args[6]); // BOOLEAN  IN 
	PVOID SidList_used = (PVOID)(x32based_args[7]); // PVOID  IN 
	ULONG SidListLength_used = (ULONG)(x32based_args[8]); // ULONG  IN 
	uint32_t x32based_StartSid = (uint32_t)(x32based_args[9]); // PSID  IN 
	BOOLEAN RestartScan_used = (BOOLEAN)(x32based_args[10]); // BOOLEAN  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE FileHandle_used = Handle32ToHandle((const void* __ptr32)x32based_FileHandle);
	uint8_t IoStatusBlock_holder[sizeof(_IO_STATUS_BLOCK)];
	PIO_STATUS_BLOCK IoStatusBlock_used = (PIO_STATUS_BLOCK)&IoStatusBlock_holder;
	uint8_t StartSid_holder[sizeof(PVOID)];
	PSID StartSid_used = (PSID)&StartSid_holder;

	// Convert parameters from x32 to x64
	if (x32based_IoStatusBlock == NULL) {
		IoStatusBlock_used = 0;
	}
	if (x32based_StartSid != NULL) {
		convert_HANDLE_32TO64(ctx, (HANDLE**)&StartSid_used, x32based_StartSid);
	}
	else {
		StartSid_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 9, FileHandle_used, IoStatusBlock_used, Buffer_used, Length_used, ReturnSingleEntry_used, SidList_used, SidListLength_used, StartSid_used, RestartScan_used); // NtQueryQuotaInformationFile

	if (IoStatusBlock_used != NULL) {
		convert__IO_STATUS_BLOCK_64TO32(ctx, (_IO_STATUS_BLOCK*)IoStatusBlock_used, x32based_IoStatusBlock);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetQuotaInformationFile(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_FileHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_IoStatusBlock = (uint32_t)(x32based_args[3]); // PIO_STATUS_BLOCK  OUT 
	PVOID Buffer_used = (PVOID)(x32based_args[4]); // PVOID  IN 
	ULONG Length_used = (ULONG)(x32based_args[5]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE FileHandle_used = Handle32ToHandle((const void* __ptr32)x32based_FileHandle);
	uint8_t IoStatusBlock_holder[sizeof(_IO_STATUS_BLOCK)];
	PIO_STATUS_BLOCK IoStatusBlock_used = (PIO_STATUS_BLOCK)&IoStatusBlock_holder;

	// Convert parameters from x32 to x64
	if (x32based_IoStatusBlock == NULL) {
		IoStatusBlock_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 4, FileHandle_used, IoStatusBlock_used, Buffer_used, Length_used); // NtSetQuotaInformationFile

	if (IoStatusBlock_used != NULL) {
		convert__IO_STATUS_BLOCK_64TO32(ctx, (_IO_STATUS_BLOCK*)IoStatusBlock_used, x32based_IoStatusBlock);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryVolumeInformationFile(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_FileHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_IoStatusBlock = (uint32_t)(x32based_args[3]); // PIO_STATUS_BLOCK  OUT 
	PVOID FsInformation_used = (PVOID)(x32based_args[4]); // PVOID  OUT 
	ULONG Length_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	FSINFOCLASS FsInformationClass_used = (FSINFOCLASS)(x32based_args[6]); // FSINFOCLASS  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE FileHandle_used = Handle32ToHandle((const void* __ptr32)x32based_FileHandle);
	uint8_t IoStatusBlock_holder[sizeof(_IO_STATUS_BLOCK)];
	PIO_STATUS_BLOCK IoStatusBlock_used = (PIO_STATUS_BLOCK)&IoStatusBlock_holder;

	// Convert parameters from x32 to x64
	if (x32based_IoStatusBlock == NULL) {
		IoStatusBlock_used = 0;
	}
	switch (FsInformationClass_used) {
	default: {
		ret_value = __syscall64(syscall_idx, 5, FileHandle_used, IoStatusBlock_used, FsInformation_used, Length_used, FsInformationClass_used); // NtQueryVolumeInformationFile
		break;
	}
	}

	if (IoStatusBlock_used != NULL) {
		convert__IO_STATUS_BLOCK_64TO32(ctx, (_IO_STATUS_BLOCK*)IoStatusBlock_used, x32based_IoStatusBlock);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetVolumeInformationFile(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_FileHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_IoStatusBlock = (uint32_t)(x32based_args[3]); // PIO_STATUS_BLOCK  OUT 
	PVOID FsInformation_used = (PVOID)(x32based_args[4]); // PVOID  IN 
	ULONG Length_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	FSINFOCLASS FsInformationClass_used = (FSINFOCLASS)(x32based_args[6]); // FSINFOCLASS  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE FileHandle_used = Handle32ToHandle((const void* __ptr32)x32based_FileHandle);
	uint8_t IoStatusBlock_holder[sizeof(_IO_STATUS_BLOCK)];
	PIO_STATUS_BLOCK IoStatusBlock_used = (PIO_STATUS_BLOCK)&IoStatusBlock_holder;

	// Convert parameters from x32 to x64
	if (x32based_IoStatusBlock == NULL) {
		IoStatusBlock_used = 0;
	}
	switch (FsInformationClass_used) {
	default: {
		ret_value = __syscall64(syscall_idx, 5, FileHandle_used, IoStatusBlock_used, FsInformation_used, Length_used, FsInformationClass_used); // NtSetVolumeInformationFile
		break;
	}
	}

	if (IoStatusBlock_used != NULL) {
		convert__IO_STATUS_BLOCK_64TO32(ctx, (_IO_STATUS_BLOCK*)IoStatusBlock_used, x32based_IoStatusBlock);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCancelIoFile(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_FileHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_IoStatusBlock = (uint32_t)(x32based_args[3]); // PIO_STATUS_BLOCK  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE FileHandle_used = Handle32ToHandle((const void* __ptr32)x32based_FileHandle);
	uint8_t IoStatusBlock_holder[sizeof(_IO_STATUS_BLOCK)];
	PIO_STATUS_BLOCK IoStatusBlock_used = (PIO_STATUS_BLOCK)&IoStatusBlock_holder;

	// Convert parameters from x32 to x64
	if (x32based_IoStatusBlock == NULL) {
		IoStatusBlock_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 2, FileHandle_used, IoStatusBlock_used); // NtCancelIoFile

	if (IoStatusBlock_used != NULL) {
		convert__IO_STATUS_BLOCK_64TO32(ctx, (_IO_STATUS_BLOCK*)IoStatusBlock_used, x32based_IoStatusBlock);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCancelIoFileEx(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_FileHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_IoRequestToCancel = (uint32_t)(x32based_args[3]); // PIO_STATUS_BLOCK  IN 
	uint32_t x32based_IoStatusBlock = (uint32_t)(x32based_args[4]); // PIO_STATUS_BLOCK  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE FileHandle_used = Handle32ToHandle((const void* __ptr32)x32based_FileHandle);
	uint8_t IoRequestToCancel_holder[sizeof(_IO_STATUS_BLOCK)];
	PIO_STATUS_BLOCK IoRequestToCancel_used = (PIO_STATUS_BLOCK)&IoRequestToCancel_holder;
	uint8_t IoStatusBlock_holder[sizeof(_IO_STATUS_BLOCK)];
	PIO_STATUS_BLOCK IoStatusBlock_used = (PIO_STATUS_BLOCK)&IoStatusBlock_holder;

	// Convert parameters from x32 to x64
	if (x32based_IoRequestToCancel != NULL) {
		convert__IO_STATUS_BLOCK_32TO64(ctx, (_IO_STATUS_BLOCK**)&IoRequestToCancel_used, x32based_IoRequestToCancel);
	}
	else {
		IoRequestToCancel_used = 0;
	}
	if (x32based_IoStatusBlock == NULL) {
		IoStatusBlock_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, FileHandle_used, IoRequestToCancel_used, IoStatusBlock_used); // NtCancelIoFileEx

	if (IoStatusBlock_used != NULL) {
		convert__IO_STATUS_BLOCK_64TO32(ctx, (_IO_STATUS_BLOCK*)IoStatusBlock_used, x32based_IoStatusBlock);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCancelSynchronousIoFile(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ThreadHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_IoRequestToCancel = (uint32_t)(x32based_args[3]); // PIO_STATUS_BLOCK  IN 
	uint32_t x32based_IoStatusBlock = (uint32_t)(x32based_args[4]); // PIO_STATUS_BLOCK  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ThreadHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ThreadHandle);
	uint8_t IoRequestToCancel_holder[sizeof(_IO_STATUS_BLOCK)];
	PIO_STATUS_BLOCK IoRequestToCancel_used = (PIO_STATUS_BLOCK)&IoRequestToCancel_holder;
	uint8_t IoStatusBlock_holder[sizeof(_IO_STATUS_BLOCK)];
	PIO_STATUS_BLOCK IoStatusBlock_used = (PIO_STATUS_BLOCK)&IoStatusBlock_holder;

	// Convert parameters from x32 to x64
	if (x32based_IoRequestToCancel != NULL) {
		convert__IO_STATUS_BLOCK_32TO64(ctx, (_IO_STATUS_BLOCK**)&IoRequestToCancel_used, x32based_IoRequestToCancel);
	}
	else {
		IoRequestToCancel_used = 0;
	}
	if (x32based_IoStatusBlock == NULL) {
		IoStatusBlock_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, ThreadHandle_used, IoRequestToCancel_used, IoStatusBlock_used); // NtCancelSynchronousIoFile

	if (IoStatusBlock_used != NULL) {
		convert__IO_STATUS_BLOCK_64TO32(ctx, (_IO_STATUS_BLOCK*)IoStatusBlock_used, x32based_IoStatusBlock);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtDeviceIoControlFile(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_FileHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_Event = (uint32_t)(x32based_args[3]); // HANDLE  IN 
	PIO_APC_ROUTINE ApcRoutine_used = (PIO_APC_ROUTINE)(x32based_args[4]); // PIO_APC_ROUTINE  IN 
	PVOID ApcContext_used = (PVOID)(x32based_args[5]); // PVOID  IN 
	uint32_t x32based_IoStatusBlock = (uint32_t)(x32based_args[6]); // PIO_STATUS_BLOCK  OUT 
	ULONG IoControlCode_used = (ULONG)(x32based_args[7]); // ULONG  IN 
	PVOID InputBuffer_used = (PVOID)(x32based_args[8]); // PVOID  IN 
	ULONG InputBufferLength_used = (ULONG)(x32based_args[9]); // ULONG  IN 
	PVOID OutputBuffer_used = (PVOID)(x32based_args[10]); // PVOID  OUT 
	ULONG OutputBufferLength_used = (ULONG)(x32based_args[11]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE FileHandle_used = Handle32ToHandle((const void* __ptr32)x32based_FileHandle);
	HANDLE Event_used = Handle32ToHandle((const void* __ptr32)x32based_Event);
	uint8_t IoStatusBlock_holder[sizeof(_IO_STATUS_BLOCK)];
	PIO_STATUS_BLOCK IoStatusBlock_used = (PIO_STATUS_BLOCK)&IoStatusBlock_holder;

	// Convert parameters from x32 to x64
	if (x32based_IoStatusBlock == NULL) {
		IoStatusBlock_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 10, FileHandle_used, Event_used, ApcRoutine_used, ApcContext_used, IoStatusBlock_used, IoControlCode_used, InputBuffer_used, InputBufferLength_used, OutputBuffer_used, OutputBufferLength_used); // NtDeviceIoControlFile

	if (IoStatusBlock_used != NULL) {
		convert__IO_STATUS_BLOCK_64TO32(ctx, (_IO_STATUS_BLOCK*)IoStatusBlock_used, x32based_IoStatusBlock);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtFsControlFile(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_FileHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_Event = (uint32_t)(x32based_args[3]); // HANDLE  IN 
	PIO_APC_ROUTINE ApcRoutine_used = (PIO_APC_ROUTINE)(x32based_args[4]); // PIO_APC_ROUTINE  IN 
	PVOID ApcContext_used = (PVOID)(x32based_args[5]); // PVOID  IN 
	uint32_t x32based_IoStatusBlock = (uint32_t)(x32based_args[6]); // PIO_STATUS_BLOCK  OUT 
	ULONG FsControlCode_used = (ULONG)(x32based_args[7]); // ULONG  IN 
	PVOID InputBuffer_used = (PVOID)(x32based_args[8]); // PVOID  IN 
	ULONG InputBufferLength_used = (ULONG)(x32based_args[9]); // ULONG  IN 
	PVOID OutputBuffer_used = (PVOID)(x32based_args[10]); // PVOID  OUT 
	ULONG OutputBufferLength_used = (ULONG)(x32based_args[11]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE FileHandle_used = Handle32ToHandle((const void* __ptr32)x32based_FileHandle);
	HANDLE Event_used = Handle32ToHandle((const void* __ptr32)x32based_Event);
	uint8_t IoStatusBlock_holder[sizeof(_IO_STATUS_BLOCK)];
	PIO_STATUS_BLOCK IoStatusBlock_used = (PIO_STATUS_BLOCK)&IoStatusBlock_holder;

	// Convert parameters from x32 to x64
	if (x32based_IoStatusBlock == NULL) {
		IoStatusBlock_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 10, FileHandle_used, Event_used, ApcRoutine_used, ApcContext_used, IoStatusBlock_used, FsControlCode_used, InputBuffer_used, InputBufferLength_used, OutputBuffer_used, OutputBufferLength_used); // NtFsControlFile

	if (IoStatusBlock_used != NULL) {
		convert__IO_STATUS_BLOCK_64TO32(ctx, (_IO_STATUS_BLOCK*)IoStatusBlock_used, x32based_IoStatusBlock);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtReadFile(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_FileHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_Event = (uint32_t)(x32based_args[3]); // HANDLE  IN 
	PIO_APC_ROUTINE ApcRoutine_used = (PIO_APC_ROUTINE)(x32based_args[4]); // PIO_APC_ROUTINE  IN 
	PVOID ApcContext_used = (PVOID)(x32based_args[5]); // PVOID  IN 
	uint32_t x32based_IoStatusBlock = (uint32_t)(x32based_args[6]); // PIO_STATUS_BLOCK  OUT 
	PVOID Buffer_used = (PVOID)(x32based_args[7]); // PVOID  OUT 
	ULONG Length_used = (ULONG)(x32based_args[8]); // ULONG  IN 
	PLARGE_INTEGER ByteOffset_used = (PLARGE_INTEGER)(x32based_args[9]); // PLARGE_INTEGER  IN 
	PULONG Key_used = (PULONG)(x32based_args[10]); // PULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE FileHandle_used = Handle32ToHandle((const void* __ptr32)x32based_FileHandle);
	HANDLE Event_used = Handle32ToHandle((const void* __ptr32)x32based_Event);
	uint8_t IoStatusBlock_holder[sizeof(_IO_STATUS_BLOCK)];
	PIO_STATUS_BLOCK IoStatusBlock_used = (PIO_STATUS_BLOCK)&IoStatusBlock_holder;

	// Convert parameters from x32 to x64
	if (x32based_IoStatusBlock == NULL) {
		IoStatusBlock_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 9, FileHandle_used, Event_used, ApcRoutine_used, ApcContext_used, IoStatusBlock_used, Buffer_used, Length_used, ByteOffset_used, Key_used); // NtReadFile

	if (IoStatusBlock_used != NULL) {
		convert__IO_STATUS_BLOCK_64TO32(ctx, (_IO_STATUS_BLOCK*)IoStatusBlock_used, x32based_IoStatusBlock);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtWriteFile(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_FileHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_Event = (uint32_t)(x32based_args[3]); // HANDLE  IN 
	PIO_APC_ROUTINE ApcRoutine_used = (PIO_APC_ROUTINE)(x32based_args[4]); // PIO_APC_ROUTINE  IN 
	PVOID ApcContext_used = (PVOID)(x32based_args[5]); // PVOID  IN 
	uint32_t x32based_IoStatusBlock = (uint32_t)(x32based_args[6]); // PIO_STATUS_BLOCK  OUT 
	PVOID Buffer_used = (PVOID)(x32based_args[7]); // PVOID  IN 
	ULONG Length_used = (ULONG)(x32based_args[8]); // ULONG  IN 
	PLARGE_INTEGER ByteOffset_used = (PLARGE_INTEGER)(x32based_args[9]); // PLARGE_INTEGER  IN 
	PULONG Key_used = (PULONG)(x32based_args[10]); // PULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE FileHandle_used = Handle32ToHandle((const void* __ptr32)x32based_FileHandle);
	HANDLE Event_used = Handle32ToHandle((const void* __ptr32)x32based_Event);
	uint8_t IoStatusBlock_holder[sizeof(_IO_STATUS_BLOCK)];
	PIO_STATUS_BLOCK IoStatusBlock_used = (PIO_STATUS_BLOCK)&IoStatusBlock_holder;

	// Convert parameters from x32 to x64
	if (x32based_IoStatusBlock == NULL) {
		IoStatusBlock_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 9, FileHandle_used, Event_used, ApcRoutine_used, ApcContext_used, IoStatusBlock_used, Buffer_used, Length_used, ByteOffset_used, Key_used); // NtWriteFile

	if (IoStatusBlock_used != NULL) {
		convert__IO_STATUS_BLOCK_64TO32(ctx, (_IO_STATUS_BLOCK*)IoStatusBlock_used, x32based_IoStatusBlock);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtReadFileScatter(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_FileHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_Event = (uint32_t)(x32based_args[3]); // HANDLE  IN 
	PIO_APC_ROUTINE ApcRoutine_used = (PIO_APC_ROUTINE)(x32based_args[4]); // PIO_APC_ROUTINE  IN 
	PVOID ApcContext_used = (PVOID)(x32based_args[5]); // PVOID  IN 
	uint32_t x32based_IoStatusBlock = (uint32_t)(x32based_args[6]); // PIO_STATUS_BLOCK  OUT 
	uint32_t x32based_SegmentArray = (uint32_t)(x32based_args[7]); // PFILE_SEGMENT_ELEMENT  IN 
	ULONG Length_used = (ULONG)(x32based_args[8]); // ULONG  IN 
	PLARGE_INTEGER ByteOffset_used = (PLARGE_INTEGER)(x32based_args[9]); // PLARGE_INTEGER  IN 
	PULONG Key_used = (PULONG)(x32based_args[10]); // PULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE FileHandle_used = Handle32ToHandle((const void* __ptr32)x32based_FileHandle);
	HANDLE Event_used = Handle32ToHandle((const void* __ptr32)x32based_Event);
	uint8_t IoStatusBlock_holder[sizeof(_IO_STATUS_BLOCK)];
	PIO_STATUS_BLOCK IoStatusBlock_used = (PIO_STATUS_BLOCK)&IoStatusBlock_holder;
	uint8_t SegmentArray_holder[sizeof(_FILE_SEGMENT_ELEMENT)];
	PFILE_SEGMENT_ELEMENT SegmentArray_used = (PFILE_SEGMENT_ELEMENT)&SegmentArray_holder;

	// Convert parameters from x32 to x64
	if (x32based_IoStatusBlock == NULL) {
		IoStatusBlock_used = 0;
	}
	if (x32based_SegmentArray != NULL) {
		convert__FILE_SEGMENT_ELEMENT_32TO64(ctx, (_FILE_SEGMENT_ELEMENT**)&SegmentArray_used, x32based_SegmentArray);
	}
	else {
		SegmentArray_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 9, FileHandle_used, Event_used, ApcRoutine_used, ApcContext_used, IoStatusBlock_used, SegmentArray_used, Length_used, ByteOffset_used, Key_used); // NtReadFileScatter

	if (IoStatusBlock_used != NULL) {
		convert__IO_STATUS_BLOCK_64TO32(ctx, (_IO_STATUS_BLOCK*)IoStatusBlock_used, x32based_IoStatusBlock);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtWriteFileGather(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_FileHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_Event = (uint32_t)(x32based_args[3]); // HANDLE  IN 
	PIO_APC_ROUTINE ApcRoutine_used = (PIO_APC_ROUTINE)(x32based_args[4]); // PIO_APC_ROUTINE  IN 
	PVOID ApcContext_used = (PVOID)(x32based_args[5]); // PVOID  IN 
	uint32_t x32based_IoStatusBlock = (uint32_t)(x32based_args[6]); // PIO_STATUS_BLOCK  OUT 
	uint32_t x32based_SegmentArray = (uint32_t)(x32based_args[7]); // PFILE_SEGMENT_ELEMENT  IN 
	ULONG Length_used = (ULONG)(x32based_args[8]); // ULONG  IN 
	PLARGE_INTEGER ByteOffset_used = (PLARGE_INTEGER)(x32based_args[9]); // PLARGE_INTEGER  IN 
	PULONG Key_used = (PULONG)(x32based_args[10]); // PULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE FileHandle_used = Handle32ToHandle((const void* __ptr32)x32based_FileHandle);
	HANDLE Event_used = Handle32ToHandle((const void* __ptr32)x32based_Event);
	uint8_t IoStatusBlock_holder[sizeof(_IO_STATUS_BLOCK)];
	PIO_STATUS_BLOCK IoStatusBlock_used = (PIO_STATUS_BLOCK)&IoStatusBlock_holder;
	uint8_t SegmentArray_holder[sizeof(_FILE_SEGMENT_ELEMENT)];
	PFILE_SEGMENT_ELEMENT SegmentArray_used = (PFILE_SEGMENT_ELEMENT)&SegmentArray_holder;

	// Convert parameters from x32 to x64
	if (x32based_IoStatusBlock == NULL) {
		IoStatusBlock_used = 0;
	}
	if (x32based_SegmentArray != NULL) {
		convert__FILE_SEGMENT_ELEMENT_32TO64(ctx, (_FILE_SEGMENT_ELEMENT**)&SegmentArray_used, x32based_SegmentArray);
	}
	else {
		SegmentArray_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 9, FileHandle_used, Event_used, ApcRoutine_used, ApcContext_used, IoStatusBlock_used, SegmentArray_used, Length_used, ByteOffset_used, Key_used); // NtWriteFileGather

	if (IoStatusBlock_used != NULL) {
		convert__IO_STATUS_BLOCK_64TO32(ctx, (_IO_STATUS_BLOCK*)IoStatusBlock_used, x32based_IoStatusBlock);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtLockFile(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_FileHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_Event = (uint32_t)(x32based_args[3]); // HANDLE  IN 
	PIO_APC_ROUTINE ApcRoutine_used = (PIO_APC_ROUTINE)(x32based_args[4]); // PIO_APC_ROUTINE  IN 
	PVOID ApcContext_used = (PVOID)(x32based_args[5]); // PVOID  IN 
	uint32_t x32based_IoStatusBlock = (uint32_t)(x32based_args[6]); // PIO_STATUS_BLOCK  OUT 
	PLARGE_INTEGER ByteOffset_used = (PLARGE_INTEGER)(x32based_args[7]); // PLARGE_INTEGER  IN 
	PLARGE_INTEGER Length_used = (PLARGE_INTEGER)(x32based_args[8]); // PLARGE_INTEGER  IN 
	ULONG Key_used = (ULONG)(x32based_args[9]); // ULONG  IN 
	BOOLEAN FailImmediately_used = (BOOLEAN)(x32based_args[10]); // BOOLEAN  IN 
	BOOLEAN ExclusiveLock_used = (BOOLEAN)(x32based_args[11]); // BOOLEAN  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE FileHandle_used = Handle32ToHandle((const void* __ptr32)x32based_FileHandle);
	HANDLE Event_used = Handle32ToHandle((const void* __ptr32)x32based_Event);
	uint8_t IoStatusBlock_holder[sizeof(_IO_STATUS_BLOCK)];
	PIO_STATUS_BLOCK IoStatusBlock_used = (PIO_STATUS_BLOCK)&IoStatusBlock_holder;

	// Convert parameters from x32 to x64
	if (x32based_IoStatusBlock == NULL) {
		IoStatusBlock_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 10, FileHandle_used, Event_used, ApcRoutine_used, ApcContext_used, IoStatusBlock_used, ByteOffset_used, Length_used, Key_used, FailImmediately_used, ExclusiveLock_used); // NtLockFile

	if (IoStatusBlock_used != NULL) {
		convert__IO_STATUS_BLOCK_64TO32(ctx, (_IO_STATUS_BLOCK*)IoStatusBlock_used, x32based_IoStatusBlock);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtUnlockFile(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_FileHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_IoStatusBlock = (uint32_t)(x32based_args[3]); // PIO_STATUS_BLOCK  OUT 
	PLARGE_INTEGER ByteOffset_used = (PLARGE_INTEGER)(x32based_args[4]); // PLARGE_INTEGER  IN 
	PLARGE_INTEGER Length_used = (PLARGE_INTEGER)(x32based_args[5]); // PLARGE_INTEGER  IN 
	ULONG Key_used = (ULONG)(x32based_args[6]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE FileHandle_used = Handle32ToHandle((const void* __ptr32)x32based_FileHandle);
	uint8_t IoStatusBlock_holder[sizeof(_IO_STATUS_BLOCK)];
	PIO_STATUS_BLOCK IoStatusBlock_used = (PIO_STATUS_BLOCK)&IoStatusBlock_holder;

	// Convert parameters from x32 to x64
	if (x32based_IoStatusBlock == NULL) {
		IoStatusBlock_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 5, FileHandle_used, IoStatusBlock_used, ByteOffset_used, Length_used, Key_used); // NtUnlockFile

	if (IoStatusBlock_used != NULL) {
		convert__IO_STATUS_BLOCK_64TO32(ctx, (_IO_STATUS_BLOCK*)IoStatusBlock_used, x32based_IoStatusBlock);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryAttributesFile(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[2]); // POBJECT_ATTRIBUTES  IN 
	PFILE_BASIC_INFORMATION FileInformation_used = (PFILE_BASIC_INFORMATION)(x32based_args[3]); // PFILE_BASIC_INFORMATION  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 2, ObjectAttributes_used, FileInformation_used); // NtQueryAttributesFile

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryFullAttributesFile(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[2]); // POBJECT_ATTRIBUTES  IN 
	PFILE_NETWORK_OPEN_INFORMATION FileInformation_used = (PFILE_NETWORK_OPEN_INFORMATION)(x32based_args[3]); // PFILE_NETWORK_OPEN_INFORMATION  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 2, ObjectAttributes_used, FileInformation_used); // NtQueryFullAttributesFile

	return ret_value;
}


NTSTATUS WINAPI _w32_NtNotifyChangeDirectoryFile(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_FileHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_Event = (uint32_t)(x32based_args[3]); // HANDLE  IN 
	PIO_APC_ROUTINE ApcRoutine_used = (PIO_APC_ROUTINE)(x32based_args[4]); // PIO_APC_ROUTINE  IN 
	PVOID ApcContext_used = (PVOID)(x32based_args[5]); // PVOID  IN 
	uint32_t x32based_IoStatusBlock = (uint32_t)(x32based_args[6]); // PIO_STATUS_BLOCK  OUT 
	PVOID Buffer_used = (PVOID)(x32based_args[7]); // PVOID  OUT 
	ULONG Length_used = (ULONG)(x32based_args[8]); // ULONG  IN 
	ULONG CompletionFilter_used = (ULONG)(x32based_args[9]); // ULONG  IN 
	BOOLEAN WatchTree_used = (BOOLEAN)(x32based_args[10]); // BOOLEAN  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE FileHandle_used = Handle32ToHandle((const void* __ptr32)x32based_FileHandle);
	HANDLE Event_used = Handle32ToHandle((const void* __ptr32)x32based_Event);
	uint8_t IoStatusBlock_holder[sizeof(_IO_STATUS_BLOCK)];
	PIO_STATUS_BLOCK IoStatusBlock_used = (PIO_STATUS_BLOCK)&IoStatusBlock_holder;

	// Convert parameters from x32 to x64
	if (x32based_IoStatusBlock == NULL) {
		IoStatusBlock_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 9, FileHandle_used, Event_used, ApcRoutine_used, ApcContext_used, IoStatusBlock_used, Buffer_used, Length_used, CompletionFilter_used, WatchTree_used); // NtNotifyChangeDirectoryFile

	if (IoStatusBlock_used != NULL) {
		convert__IO_STATUS_BLOCK_64TO32(ctx, (_IO_STATUS_BLOCK*)IoStatusBlock_used, x32based_IoStatusBlock);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtNotifyChangeDirectoryFileEx(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_FileHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_Event = (uint32_t)(x32based_args[3]); // HANDLE  IN 
	PIO_APC_ROUTINE ApcRoutine_used = (PIO_APC_ROUTINE)(x32based_args[4]); // PIO_APC_ROUTINE  IN 
	PVOID ApcContext_used = (PVOID)(x32based_args[5]); // PVOID  IN 
	uint32_t x32based_IoStatusBlock = (uint32_t)(x32based_args[6]); // PIO_STATUS_BLOCK  OUT 
	PVOID Buffer_used = (PVOID)(x32based_args[7]); // PVOID  OUT 
	ULONG Length_used = (ULONG)(x32based_args[8]); // ULONG  IN 
	ULONG CompletionFilter_used = (ULONG)(x32based_args[9]); // ULONG  IN 
	BOOLEAN WatchTree_used = (BOOLEAN)(x32based_args[10]); // BOOLEAN  IN 
	DIRECTORY_NOTIFY_INFORMATION_CLASS DirectoryNotifyInformationClass_used = (DIRECTORY_NOTIFY_INFORMATION_CLASS)(x32based_args[11]); // DIRECTORY_NOTIFY_INFORMATION_CLASS  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE FileHandle_used = Handle32ToHandle((const void* __ptr32)x32based_FileHandle);
	HANDLE Event_used = Handle32ToHandle((const void* __ptr32)x32based_Event);
	uint8_t IoStatusBlock_holder[sizeof(_IO_STATUS_BLOCK)];
	PIO_STATUS_BLOCK IoStatusBlock_used = (PIO_STATUS_BLOCK)&IoStatusBlock_holder;

	// Convert parameters from x32 to x64
	if (x32based_IoStatusBlock == NULL) {
		IoStatusBlock_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 10, FileHandle_used, Event_used, ApcRoutine_used, ApcContext_used, IoStatusBlock_used, Buffer_used, Length_used, CompletionFilter_used, WatchTree_used, DirectoryNotifyInformationClass_used); // NtNotifyChangeDirectoryFileEx

	if (IoStatusBlock_used != NULL) {
		convert__IO_STATUS_BLOCK_64TO32(ctx, (_IO_STATUS_BLOCK*)IoStatusBlock_used, x32based_IoStatusBlock);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtLoadDriver(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_DriverServiceName = (uint32_t)(x32based_args[2]); // PUNICODE_STRING  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t DriverServiceName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING DriverServiceName_used = (PUNICODE_STRING)&DriverServiceName_holder;

	// Convert parameters from x32 to x64
	if (x32based_DriverServiceName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&DriverServiceName_used, x32based_DriverServiceName);
	}
	else {
		DriverServiceName_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 1, DriverServiceName_used); // NtLoadDriver

	return ret_value;
}


NTSTATUS WINAPI _w32_NtUnloadDriver(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_DriverServiceName = (uint32_t)(x32based_args[2]); // PUNICODE_STRING  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t DriverServiceName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING DriverServiceName_used = (PUNICODE_STRING)&DriverServiceName_holder;

	// Convert parameters from x32 to x64
	if (x32based_DriverServiceName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&DriverServiceName_used, x32based_DriverServiceName);
	}
	else {
		DriverServiceName_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 1, DriverServiceName_used); // NtUnloadDriver

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateIoCompletion(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_IoCompletionHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	ULONG Count_used = (ULONG)(x32based_args[5]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t IoCompletionHandle_holder[sizeof(PVOID)];
	PHANDLE IoCompletionHandle_used = (PHANDLE)&IoCompletionHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_IoCompletionHandle == NULL) {
		IoCompletionHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, IoCompletionHandle_used, DesiredAccess_used, ObjectAttributes_used, Count_used); // NtCreateIoCompletion

	if (IoCompletionHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)IoCompletionHandle_used, x32based_IoCompletionHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtOpenIoCompletion(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_IoCompletionHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t IoCompletionHandle_holder[sizeof(PVOID)];
	PHANDLE IoCompletionHandle_used = (PHANDLE)&IoCompletionHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_IoCompletionHandle == NULL) {
		IoCompletionHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, IoCompletionHandle_used, DesiredAccess_used, ObjectAttributes_used); // NtOpenIoCompletion

	if (IoCompletionHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)IoCompletionHandle_used, x32based_IoCompletionHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryIoCompletion(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_IoCompletionHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass_used = (IO_COMPLETION_INFORMATION_CLASS)(x32based_args[3]); // IO_COMPLETION_INFORMATION_CLASS  IN 
	PVOID IoCompletionInformation_used = (PVOID)(x32based_args[4]); // PVOID  IN  OUT 
	ULONG IoCompletionInformationLength_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	PULONG ReturnLength_used = (PULONG)(x32based_args[6]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE IoCompletionHandle_used = Handle32ToHandle((const void* __ptr32)x32based_IoCompletionHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 5, IoCompletionHandle_used, IoCompletionInformationClass_used, IoCompletionInformation_used, IoCompletionInformationLength_used, ReturnLength_used); // NtQueryIoCompletion

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetIoCompletion(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_IoCompletionHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PVOID KeyContext_used = (PVOID)(x32based_args[3]); // PVOID  IN 
	PVOID ApcContext_used = (PVOID)(x32based_args[4]); // PVOID  IN 
	NTSTATUS IoStatus_used = (NTSTATUS)(x32based_args[5]); // NTSTATUS  IN 
	ULONG_PTR IoStatusInformation_used = (ULONG_PTR)(x32based_args[6]); // ULONG_PTR  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE IoCompletionHandle_used = Handle32ToHandle((const void* __ptr32)x32based_IoCompletionHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 5, IoCompletionHandle_used, KeyContext_used, ApcContext_used, IoStatus_used, IoStatusInformation_used); // NtSetIoCompletion

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetIoCompletionEx(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_IoCompletionHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_IoCompletionPacketHandle = (uint32_t)(x32based_args[3]); // HANDLE  IN 
	PVOID KeyContext_used = (PVOID)(x32based_args[4]); // PVOID  IN 
	PVOID ApcContext_used = (PVOID)(x32based_args[5]); // PVOID  IN 
	NTSTATUS IoStatus_used = (NTSTATUS)(x32based_args[6]); // NTSTATUS  IN 
	ULONG_PTR IoStatusInformation_used = (ULONG_PTR)(x32based_args[7]); // ULONG_PTR  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE IoCompletionHandle_used = Handle32ToHandle((const void* __ptr32)x32based_IoCompletionHandle);
	HANDLE IoCompletionPacketHandle_used = Handle32ToHandle((const void* __ptr32)x32based_IoCompletionPacketHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 6, IoCompletionHandle_used, IoCompletionPacketHandle_used, KeyContext_used, ApcContext_used, IoStatus_used, IoStatusInformation_used); // NtSetIoCompletionEx

	return ret_value;
}


NTSTATUS WINAPI _w32_NtRemoveIoCompletion(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_IoCompletionHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_KeyContext = (uint32_t)(x32based_args[3]); // PVOID *  OUT 
	uint32_t x32based_ApcContext = (uint32_t)(x32based_args[4]); // PVOID *  OUT 
	uint32_t x32based_IoStatusBlock = (uint32_t)(x32based_args[5]); // PIO_STATUS_BLOCK  OUT 
	PLARGE_INTEGER Timeout_used = (PLARGE_INTEGER)(x32based_args[6]); // PLARGE_INTEGER  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE IoCompletionHandle_used = Handle32ToHandle((const void* __ptr32)x32based_IoCompletionHandle);
	uint8_t KeyContext_holder[sizeof(PVOID)];
	PVOID* KeyContext_used = (PVOID*)&KeyContext_holder;
	uint8_t ApcContext_holder[sizeof(PVOID)];
	PVOID* ApcContext_used = (PVOID*)&ApcContext_holder;
	uint8_t IoStatusBlock_holder[sizeof(_IO_STATUS_BLOCK)];
	PIO_STATUS_BLOCK IoStatusBlock_used = (PIO_STATUS_BLOCK)&IoStatusBlock_holder;

	// Convert parameters from x32 to x64
	if (x32based_KeyContext == NULL) {
		KeyContext_used = 0;
	}
	if (x32based_ApcContext == NULL) {
		ApcContext_used = 0;
	}
	if (x32based_IoStatusBlock == NULL) {
		IoStatusBlock_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 5, IoCompletionHandle_used, KeyContext_used, ApcContext_used, IoStatusBlock_used, Timeout_used); // NtRemoveIoCompletion

	if (x32based_KeyContext != NULL) {
		*((X32_SIZE_T*)x32based_KeyContext) = (X32_SIZE_T)(*(SIZE_T*)KeyContext_used);
	}
	if (x32based_ApcContext != NULL) {
		*((X32_SIZE_T*)x32based_ApcContext) = (X32_SIZE_T)(*(SIZE_T*)ApcContext_used);
	}
	if (IoStatusBlock_used != NULL) {
		convert__IO_STATUS_BLOCK_64TO32(ctx, (_IO_STATUS_BLOCK*)IoStatusBlock_used, x32based_IoStatusBlock);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtRemoveIoCompletionEx(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_IoCompletionHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_IoCompletionInformation = (uint32_t)(x32based_args[3]); // PFILE_IO_COMPLETION_INFORMATION  OUT 
	ULONG Count_used = (ULONG)(x32based_args[4]); // ULONG  IN 
	PULONG NumEntriesRemoved_used = (PULONG)(x32based_args[5]); // PULONG  OUT 
	PLARGE_INTEGER Timeout_used = (PLARGE_INTEGER)(x32based_args[6]); // PLARGE_INTEGER  IN 
	BOOLEAN Alertable_used = (BOOLEAN)(x32based_args[7]); // BOOLEAN  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE IoCompletionHandle_used = Handle32ToHandle((const void* __ptr32)x32based_IoCompletionHandle);
	uint8_t IoCompletionInformation_holder[sizeof(_FILE_IO_COMPLETION_INFORMATION)];
	PFILE_IO_COMPLETION_INFORMATION IoCompletionInformation_used = (PFILE_IO_COMPLETION_INFORMATION)&IoCompletionInformation_holder;

	// Convert parameters from x32 to x64
	if (x32based_IoCompletionInformation == NULL) {
		IoCompletionInformation_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 6, IoCompletionHandle_used, IoCompletionInformation_used, Count_used, NumEntriesRemoved_used, Timeout_used, Alertable_used); // NtRemoveIoCompletionEx

	if (IoCompletionInformation_used != NULL) {
		convert__FILE_IO_COMPLETION_INFORMATION_64TO32(ctx, (_FILE_IO_COMPLETION_INFORMATION*)IoCompletionInformation_used, x32based_IoCompletionInformation);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateWaitCompletionPacket(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_WaitCompletionPacketHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t WaitCompletionPacketHandle_holder[sizeof(PVOID)];
	PHANDLE WaitCompletionPacketHandle_used = (PHANDLE)&WaitCompletionPacketHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_WaitCompletionPacketHandle == NULL) {
		WaitCompletionPacketHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, WaitCompletionPacketHandle_used, DesiredAccess_used, ObjectAttributes_used); // NtCreateWaitCompletionPacket

	if (WaitCompletionPacketHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)WaitCompletionPacketHandle_used, x32based_WaitCompletionPacketHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAssociateWaitCompletionPacket(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_WaitCompletionPacketHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_IoCompletionHandle = (uint32_t)(x32based_args[3]); // HANDLE  IN 
	uint32_t x32based_TargetObjectHandle = (uint32_t)(x32based_args[4]); // HANDLE  IN 
	PVOID KeyContext_used = (PVOID)(x32based_args[5]); // PVOID  IN 
	PVOID ApcContext_used = (PVOID)(x32based_args[6]); // PVOID  IN 
	NTSTATUS IoStatus_used = (NTSTATUS)(x32based_args[7]); // NTSTATUS  IN 
	ULONG_PTR IoStatusInformation_used = (ULONG_PTR)(x32based_args[8]); // ULONG_PTR  IN 
	PBOOLEAN AlreadySignaled_used = (PBOOLEAN)(x32based_args[9]); // PBOOLEAN  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE WaitCompletionPacketHandle_used = Handle32ToHandle((const void* __ptr32)x32based_WaitCompletionPacketHandle);
	HANDLE IoCompletionHandle_used = Handle32ToHandle((const void* __ptr32)x32based_IoCompletionHandle);
	HANDLE TargetObjectHandle_used = Handle32ToHandle((const void* __ptr32)x32based_TargetObjectHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 8, WaitCompletionPacketHandle_used, IoCompletionHandle_used, TargetObjectHandle_used, KeyContext_used, ApcContext_used, IoStatus_used, IoStatusInformation_used, AlreadySignaled_used); // NtAssociateWaitCompletionPacket

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCancelWaitCompletionPacket(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_WaitCompletionPacketHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	BOOLEAN RemoveSignaledPacket_used = (BOOLEAN)(x32based_args[3]); // BOOLEAN  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE WaitCompletionPacketHandle_used = Handle32ToHandle((const void* __ptr32)x32based_WaitCompletionPacketHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, WaitCompletionPacketHandle_used, RemoveSignaledPacket_used); // NtCancelWaitCompletionPacket

	return ret_value;
}


NTSTATUS WINAPI _w32_NtOpenSession(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_SessionHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SessionHandle_holder[sizeof(PVOID)];
	PHANDLE SessionHandle_used = (PHANDLE)&SessionHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_SessionHandle == NULL) {
		SessionHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, SessionHandle_used, DesiredAccess_used, ObjectAttributes_used); // NtOpenSession

	if (SessionHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)SessionHandle_used, x32based_SessionHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtNotifyChangeSession(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_SessionHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	ULONG ChangeSequenceNumber_used = (ULONG)(x32based_args[3]); // ULONG  IN 
	PLARGE_INTEGER ChangeTimeStamp_used = (PLARGE_INTEGER)(x32based_args[4]); // PLARGE_INTEGER  IN 
	IO_SESSION_EVENT Event_used = (IO_SESSION_EVENT)(x32based_args[5]); // IO_SESSION_EVENT  IN 
	IO_SESSION_STATE NewState_used = (IO_SESSION_STATE)(x32based_args[6]); // IO_SESSION_STATE  IN 
	IO_SESSION_STATE PreviousState_used = (IO_SESSION_STATE)(x32based_args[7]); // IO_SESSION_STATE  IN 
	PVOID Payload_used = (PVOID)(x32based_args[8]); // PVOID  IN 
	ULONG PayloadSize_used = (ULONG)(x32based_args[9]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE SessionHandle_used = Handle32ToHandle((const void* __ptr32)x32based_SessionHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 8, SessionHandle_used, ChangeSequenceNumber_used, ChangeTimeStamp_used, Event_used, NewState_used, PreviousState_used, Payload_used, PayloadSize_used); // NtNotifyChangeSession

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreatePort(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[3]); // POBJECT_ATTRIBUTES  IN 
	ULONG MaxConnectionInfoLength_used = (ULONG)(x32based_args[4]); // ULONG  IN 
	ULONG MaxMessageLength_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	ULONG MaxPoolUsage_used = (ULONG)(x32based_args[6]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t PortHandle_holder[sizeof(PVOID)];
	PHANDLE PortHandle_used = (PHANDLE)&PortHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_PortHandle == NULL) {
		PortHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 5, PortHandle_used, ObjectAttributes_used, MaxConnectionInfoLength_used, MaxMessageLength_used, MaxPoolUsage_used); // NtCreatePort

	if (PortHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)PortHandle_used, x32based_PortHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateWaitablePort(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[3]); // POBJECT_ATTRIBUTES  IN 
	ULONG MaxConnectionInfoLength_used = (ULONG)(x32based_args[4]); // ULONG  IN 
	ULONG MaxMessageLength_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	ULONG MaxPoolUsage_used = (ULONG)(x32based_args[6]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t PortHandle_holder[sizeof(PVOID)];
	PHANDLE PortHandle_used = (PHANDLE)&PortHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_PortHandle == NULL) {
		PortHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 5, PortHandle_used, ObjectAttributes_used, MaxConnectionInfoLength_used, MaxMessageLength_used, MaxPoolUsage_used); // NtCreateWaitablePort

	if (PortHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)PortHandle_used, x32based_PortHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtConnectPort(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	uint32_t x32based_PortName = (uint32_t)(x32based_args[3]); // PUNICODE_STRING  IN 
	PSECURITY_QUALITY_OF_SERVICE SecurityQos_used = (PSECURITY_QUALITY_OF_SERVICE)(x32based_args[4]); // PSECURITY_QUALITY_OF_SERVICE  IN 
	uint32_t x32based_ClientView = (uint32_t)(x32based_args[5]); // PPORT_VIEW  IN  OUT 
	uint32_t x32based_ServerView = (uint32_t)(x32based_args[6]); // PREMOTE_PORT_VIEW  IN  OUT 
	PULONG MaxMessageLength_used = (PULONG)(x32based_args[7]); // PULONG  OUT 
	PVOID ConnectionInformation_used = (PVOID)(x32based_args[8]); // PVOID  IN  OUT 
	PULONG ConnectionInformationLength_used = (PULONG)(x32based_args[9]); // PULONG  IN  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t PortHandle_holder[sizeof(PVOID)];
	PHANDLE PortHandle_used = (PHANDLE)&PortHandle_holder;
	uint8_t PortName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING PortName_used = (PUNICODE_STRING)&PortName_holder;
	uint8_t ClientView_holder[sizeof(_PORT_VIEW)];
	PPORT_VIEW ClientView_used = (PPORT_VIEW)&ClientView_holder;
	uint8_t ServerView_holder[sizeof(_REMOTE_PORT_VIEW)];
	PREMOTE_PORT_VIEW ServerView_used = (PREMOTE_PORT_VIEW)&ServerView_holder;

	// Convert parameters from x32 to x64
	if (x32based_PortHandle == NULL) {
		PortHandle_used = 0;
	}
	if (x32based_PortName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&PortName_used, x32based_PortName);
	}
	else {
		PortName_used = 0;
	}
	if (x32based_ClientView != NULL) {
		convert__PORT_VIEW_32TO64(ctx, (_PORT_VIEW**)&ClientView_used, x32based_ClientView);
	}
	else {
		ClientView_used = 0;
	}
	if (x32based_ServerView != NULL) {
		convert__REMOTE_PORT_VIEW_32TO64(ctx, (_REMOTE_PORT_VIEW**)&ServerView_used, x32based_ServerView);
	}
	else {
		ServerView_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 8, PortHandle_used, PortName_used, SecurityQos_used, ClientView_used, ServerView_used, MaxMessageLength_used, ConnectionInformation_used, ConnectionInformationLength_used); // NtConnectPort

	if (PortHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)PortHandle_used, x32based_PortHandle);
	}
	if (ClientView_used != NULL) {
		convert__PORT_VIEW_64TO32(ctx, (_PORT_VIEW*)ClientView_used, x32based_ClientView);
	}
	if (ServerView_used != NULL) {
		convert__REMOTE_PORT_VIEW_64TO32(ctx, (_REMOTE_PORT_VIEW*)ServerView_used, x32based_ServerView);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSecureConnectPort(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	uint32_t x32based_PortName = (uint32_t)(x32based_args[3]); // PUNICODE_STRING  IN 
	PSECURITY_QUALITY_OF_SERVICE SecurityQos_used = (PSECURITY_QUALITY_OF_SERVICE)(x32based_args[4]); // PSECURITY_QUALITY_OF_SERVICE  IN 
	uint32_t x32based_ClientView = (uint32_t)(x32based_args[5]); // PPORT_VIEW  IN  OUT 
	uint32_t x32based_RequiredServerSid = (uint32_t)(x32based_args[6]); // PSID  IN 
	uint32_t x32based_ServerView = (uint32_t)(x32based_args[7]); // PREMOTE_PORT_VIEW  IN  OUT 
	PULONG MaxMessageLength_used = (PULONG)(x32based_args[8]); // PULONG  OUT 
	PVOID ConnectionInformation_used = (PVOID)(x32based_args[9]); // PVOID  IN  OUT 
	PULONG ConnectionInformationLength_used = (PULONG)(x32based_args[10]); // PULONG  IN  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t PortHandle_holder[sizeof(PVOID)];
	PHANDLE PortHandle_used = (PHANDLE)&PortHandle_holder;
	uint8_t PortName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING PortName_used = (PUNICODE_STRING)&PortName_holder;
	uint8_t ClientView_holder[sizeof(_PORT_VIEW)];
	PPORT_VIEW ClientView_used = (PPORT_VIEW)&ClientView_holder;
	uint8_t RequiredServerSid_holder[sizeof(PVOID)];
	PSID RequiredServerSid_used = (PSID)&RequiredServerSid_holder;
	uint8_t ServerView_holder[sizeof(_REMOTE_PORT_VIEW)];
	PREMOTE_PORT_VIEW ServerView_used = (PREMOTE_PORT_VIEW)&ServerView_holder;

	// Convert parameters from x32 to x64
	if (x32based_PortHandle == NULL) {
		PortHandle_used = 0;
	}
	if (x32based_PortName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&PortName_used, x32based_PortName);
	}
	else {
		PortName_used = 0;
	}
	if (x32based_ClientView != NULL) {
		convert__PORT_VIEW_32TO64(ctx, (_PORT_VIEW**)&ClientView_used, x32based_ClientView);
	}
	else {
		ClientView_used = 0;
	}
	if (x32based_RequiredServerSid != NULL) {
		convert_HANDLE_32TO64(ctx, (HANDLE**)&RequiredServerSid_used, x32based_RequiredServerSid);
	}
	else {
		RequiredServerSid_used = 0;
	}
	if (x32based_ServerView != NULL) {
		convert__REMOTE_PORT_VIEW_32TO64(ctx, (_REMOTE_PORT_VIEW**)&ServerView_used, x32based_ServerView);
	}
	else {
		ServerView_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 9, PortHandle_used, PortName_used, SecurityQos_used, ClientView_used, RequiredServerSid_used, ServerView_used, MaxMessageLength_used, ConnectionInformation_used, ConnectionInformationLength_used); // NtSecureConnectPort

	if (PortHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)PortHandle_used, x32based_PortHandle);
	}
	if (ClientView_used != NULL) {
		convert__PORT_VIEW_64TO32(ctx, (_PORT_VIEW*)ClientView_used, x32based_ClientView);
	}
	if (ServerView_used != NULL) {
		convert__REMOTE_PORT_VIEW_64TO32(ctx, (_REMOTE_PORT_VIEW*)ServerView_used, x32based_ServerView);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtListenPort(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_ConnectionRequest = (uint32_t)(x32based_args[3]); // PPORT_MESSAGE  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE PortHandle_used = Handle32ToHandle((const void* __ptr32)x32based_PortHandle);
	uint8_t ConnectionRequest_holder[sizeof(_PORT_MESSAGE)];
	PPORT_MESSAGE ConnectionRequest_used = (PPORT_MESSAGE)&ConnectionRequest_holder;

	// Convert parameters from x32 to x64
	if (x32based_ConnectionRequest == NULL) {
		ConnectionRequest_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 2, PortHandle_used, ConnectionRequest_used); // NtListenPort

	if (ConnectionRequest_used != NULL) {
		convert__PORT_MESSAGE_64TO32(ctx, (_PORT_MESSAGE*)ConnectionRequest_used, x32based_ConnectionRequest);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAcceptConnectPort(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	PVOID PortContext_used = (PVOID)(x32based_args[3]); // PVOID  IN 
	uint32_t x32based_ConnectionRequest = (uint32_t)(x32based_args[4]); // PPORT_MESSAGE  IN 
	BOOLEAN AcceptConnection_used = (BOOLEAN)(x32based_args[5]); // BOOLEAN  IN 
	uint32_t x32based_ServerView = (uint32_t)(x32based_args[6]); // PPORT_VIEW  IN  OUT 
	uint32_t x32based_ClientView = (uint32_t)(x32based_args[7]); // PREMOTE_PORT_VIEW  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t PortHandle_holder[sizeof(PVOID)];
	PHANDLE PortHandle_used = (PHANDLE)&PortHandle_holder;
	uint8_t ConnectionRequest_holder[sizeof(_PORT_MESSAGE)];
	PPORT_MESSAGE ConnectionRequest_used = (PPORT_MESSAGE)&ConnectionRequest_holder;
	uint8_t ServerView_holder[sizeof(_PORT_VIEW)];
	PPORT_VIEW ServerView_used = (PPORT_VIEW)&ServerView_holder;
	uint8_t ClientView_holder[sizeof(_REMOTE_PORT_VIEW)];
	PREMOTE_PORT_VIEW ClientView_used = (PREMOTE_PORT_VIEW)&ClientView_holder;

	// Convert parameters from x32 to x64
	if (x32based_PortHandle == NULL) {
		PortHandle_used = 0;
	}
	if (x32based_ConnectionRequest != NULL) {
		convert__PORT_MESSAGE_32TO64(ctx, (_PORT_MESSAGE**)&ConnectionRequest_used, x32based_ConnectionRequest);
	}
	else {
		ConnectionRequest_used = 0;
	}
	if (x32based_ServerView != NULL) {
		convert__PORT_VIEW_32TO64(ctx, (_PORT_VIEW**)&ServerView_used, x32based_ServerView);
	}
	else {
		ServerView_used = 0;
	}
	if (x32based_ClientView == NULL) {
		ClientView_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 6, PortHandle_used, PortContext_used, ConnectionRequest_used, AcceptConnection_used, ServerView_used, ClientView_used); // NtAcceptConnectPort

	if (PortHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)PortHandle_used, x32based_PortHandle);
	}
	if (ServerView_used != NULL) {
		convert__PORT_VIEW_64TO32(ctx, (_PORT_VIEW*)ServerView_used, x32based_ServerView);
	}
	if (ClientView_used != NULL) {
		convert__REMOTE_PORT_VIEW_64TO32(ctx, (_REMOTE_PORT_VIEW*)ClientView_used, x32based_ClientView);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCompleteConnectPort(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE PortHandle_used = Handle32ToHandle((const void* __ptr32)x32based_PortHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, PortHandle_used); // NtCompleteConnectPort

	return ret_value;
}


NTSTATUS WINAPI _w32_NtRequestPort(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_RequestMessage = (uint32_t)(x32based_args[3]); // PPORT_MESSAGE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE PortHandle_used = Handle32ToHandle((const void* __ptr32)x32based_PortHandle);
	uint8_t RequestMessage_holder[sizeof(_PORT_MESSAGE)];
	PPORT_MESSAGE RequestMessage_used = (PPORT_MESSAGE)&RequestMessage_holder;

	// Convert parameters from x32 to x64
	if (x32based_RequestMessage != NULL) {
		convert__PORT_MESSAGE_32TO64(ctx, (_PORT_MESSAGE**)&RequestMessage_used, x32based_RequestMessage);
	}
	else {
		RequestMessage_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 2, PortHandle_used, RequestMessage_used); // NtRequestPort

	return ret_value;
}


NTSTATUS WINAPI _w32_NtRequestWaitReplyPort(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_RequestMessage = (uint32_t)(x32based_args[3]); // PPORT_MESSAGE  IN 
	uint32_t x32based_ReplyMessage = (uint32_t)(x32based_args[4]); // PPORT_MESSAGE  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE PortHandle_used = Handle32ToHandle((const void* __ptr32)x32based_PortHandle);
	uint8_t RequestMessage_holder[sizeof(_PORT_MESSAGE)];
	PPORT_MESSAGE RequestMessage_used = (PPORT_MESSAGE)&RequestMessage_holder;
	uint8_t ReplyMessage_holder[sizeof(_PORT_MESSAGE)];
	PPORT_MESSAGE ReplyMessage_used = (PPORT_MESSAGE)&ReplyMessage_holder;

	// Convert parameters from x32 to x64
	if (x32based_RequestMessage != NULL) {
		convert__PORT_MESSAGE_32TO64(ctx, (_PORT_MESSAGE**)&RequestMessage_used, x32based_RequestMessage);
	}
	else {
		RequestMessage_used = 0;
	}
	if (x32based_ReplyMessage == NULL) {
		ReplyMessage_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, PortHandle_used, RequestMessage_used, ReplyMessage_used); // NtRequestWaitReplyPort

	if (ReplyMessage_used != NULL) {
		convert__PORT_MESSAGE_64TO32(ctx, (_PORT_MESSAGE*)ReplyMessage_used, x32based_ReplyMessage);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtReplyPort(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_ReplyMessage = (uint32_t)(x32based_args[3]); // PPORT_MESSAGE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE PortHandle_used = Handle32ToHandle((const void* __ptr32)x32based_PortHandle);
	uint8_t ReplyMessage_holder[sizeof(_PORT_MESSAGE)];
	PPORT_MESSAGE ReplyMessage_used = (PPORT_MESSAGE)&ReplyMessage_holder;

	// Convert parameters from x32 to x64
	if (x32based_ReplyMessage != NULL) {
		convert__PORT_MESSAGE_32TO64(ctx, (_PORT_MESSAGE**)&ReplyMessage_used, x32based_ReplyMessage);
	}
	else {
		ReplyMessage_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 2, PortHandle_used, ReplyMessage_used); // NtReplyPort

	return ret_value;
}


NTSTATUS WINAPI _w32_NtReplyWaitReplyPort(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_ReplyMessage = (uint32_t)(x32based_args[3]); // PPORT_MESSAGE  IN  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE PortHandle_used = Handle32ToHandle((const void* __ptr32)x32based_PortHandle);
	uint8_t ReplyMessage_holder[sizeof(_PORT_MESSAGE)];
	PPORT_MESSAGE ReplyMessage_used = (PPORT_MESSAGE)&ReplyMessage_holder;

	// Convert parameters from x32 to x64
	if (x32based_ReplyMessage != NULL) {
		convert__PORT_MESSAGE_32TO64(ctx, (_PORT_MESSAGE**)&ReplyMessage_used, x32based_ReplyMessage);
	}
	else {
		ReplyMessage_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 2, PortHandle_used, ReplyMessage_used); // NtReplyWaitReplyPort

	if (ReplyMessage_used != NULL) {
		convert__PORT_MESSAGE_64TO32(ctx, (_PORT_MESSAGE*)ReplyMessage_used, x32based_ReplyMessage);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtReplyWaitReceivePort(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_PortContext = (uint32_t)(x32based_args[3]); // PVOID *  OUT 
	uint32_t x32based_ReplyMessage = (uint32_t)(x32based_args[4]); // PPORT_MESSAGE  IN 
	uint32_t x32based_ReceiveMessage = (uint32_t)(x32based_args[5]); // PPORT_MESSAGE  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE PortHandle_used = Handle32ToHandle((const void* __ptr32)x32based_PortHandle);
	uint8_t PortContext_holder[sizeof(PVOID)];
	PVOID* PortContext_used = (PVOID*)&PortContext_holder;
	uint8_t ReplyMessage_holder[sizeof(_PORT_MESSAGE)];
	PPORT_MESSAGE ReplyMessage_used = (PPORT_MESSAGE)&ReplyMessage_holder;
	uint8_t ReceiveMessage_holder[sizeof(_PORT_MESSAGE)];
	PPORT_MESSAGE ReceiveMessage_used = (PPORT_MESSAGE)&ReceiveMessage_holder;

	// Convert parameters from x32 to x64
	if (x32based_PortContext == NULL) {
		PortContext_used = 0;
	}
	if (x32based_ReplyMessage != NULL) {
		convert__PORT_MESSAGE_32TO64(ctx, (_PORT_MESSAGE**)&ReplyMessage_used, x32based_ReplyMessage);
	}
	else {
		ReplyMessage_used = 0;
	}
	if (x32based_ReceiveMessage == NULL) {
		ReceiveMessage_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, PortHandle_used, PortContext_used, ReplyMessage_used, ReceiveMessage_used); // NtReplyWaitReceivePort

	if (x32based_PortContext != NULL) {
		*((X32_SIZE_T*)x32based_PortContext) = (X32_SIZE_T)(*(SIZE_T*)PortContext_used);
	}
	if (ReceiveMessage_used != NULL) {
		convert__PORT_MESSAGE_64TO32(ctx, (_PORT_MESSAGE*)ReceiveMessage_used, x32based_ReceiveMessage);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtReplyWaitReceivePortEx(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_PortContext = (uint32_t)(x32based_args[3]); // PVOID *  OUT 
	uint32_t x32based_ReplyMessage = (uint32_t)(x32based_args[4]); // PPORT_MESSAGE  IN 
	uint32_t x32based_ReceiveMessage = (uint32_t)(x32based_args[5]); // PPORT_MESSAGE  OUT 
	PLARGE_INTEGER Timeout_used = (PLARGE_INTEGER)(x32based_args[6]); // PLARGE_INTEGER  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE PortHandle_used = Handle32ToHandle((const void* __ptr32)x32based_PortHandle);
	uint8_t PortContext_holder[sizeof(PVOID)];
	PVOID* PortContext_used = (PVOID*)&PortContext_holder;
	uint8_t ReplyMessage_holder[sizeof(_PORT_MESSAGE)];
	PPORT_MESSAGE ReplyMessage_used = (PPORT_MESSAGE)&ReplyMessage_holder;
	uint8_t ReceiveMessage_holder[sizeof(_PORT_MESSAGE)];
	PPORT_MESSAGE ReceiveMessage_used = (PPORT_MESSAGE)&ReceiveMessage_holder;

	// Convert parameters from x32 to x64
	if (x32based_PortContext == NULL) {
		PortContext_used = 0;
	}
	if (x32based_ReplyMessage != NULL) {
		convert__PORT_MESSAGE_32TO64(ctx, (_PORT_MESSAGE**)&ReplyMessage_used, x32based_ReplyMessage);
	}
	else {
		ReplyMessage_used = 0;
	}
	if (x32based_ReceiveMessage == NULL) {
		ReceiveMessage_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 5, PortHandle_used, PortContext_used, ReplyMessage_used, ReceiveMessage_used, Timeout_used); // NtReplyWaitReceivePortEx

	if (x32based_PortContext != NULL) {
		*((X32_SIZE_T*)x32based_PortContext) = (X32_SIZE_T)(*(SIZE_T*)PortContext_used);
	}
	if (ReceiveMessage_used != NULL) {
		convert__PORT_MESSAGE_64TO32(ctx, (_PORT_MESSAGE*)ReceiveMessage_used, x32based_ReceiveMessage);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtImpersonateClientOfPort(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_Message = (uint32_t)(x32based_args[3]); // PPORT_MESSAGE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE PortHandle_used = Handle32ToHandle((const void* __ptr32)x32based_PortHandle);
	uint8_t Message_holder[sizeof(_PORT_MESSAGE)];
	PPORT_MESSAGE Message_used = (PPORT_MESSAGE)&Message_holder;

	// Convert parameters from x32 to x64
	if (x32based_Message != NULL) {
		convert__PORT_MESSAGE_32TO64(ctx, (_PORT_MESSAGE**)&Message_used, x32based_Message);
	}
	else {
		Message_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 2, PortHandle_used, Message_used); // NtImpersonateClientOfPort

	return ret_value;
}


NTSTATUS WINAPI _w32_NtReadRequestData(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_Message = (uint32_t)(x32based_args[3]); // PPORT_MESSAGE  IN 
	ULONG DataEntryIndex_used = (ULONG)(x32based_args[4]); // ULONG  IN 
	PVOID Buffer_used = (PVOID)(x32based_args[5]); // PVOID  OUT 
	SIZE_T BufferSize_used = (SIZE_T)(x32based_args[6]); // SIZE_T  IN 
	uint32_t x32based_NumberOfBytesRead = (uint32_t)(x32based_args[7]); // PSIZE_T  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE PortHandle_used = Handle32ToHandle((const void* __ptr32)x32based_PortHandle);
	uint8_t Message_holder[sizeof(_PORT_MESSAGE)];
	PPORT_MESSAGE Message_used = (PPORT_MESSAGE)&Message_holder;
	uint8_t NumberOfBytesRead_holder[sizeof(long long unsigned int)];
	PSIZE_T NumberOfBytesRead_used = (PSIZE_T)&NumberOfBytesRead_holder;

	// Convert parameters from x32 to x64
	if (x32based_Message != NULL) {
		convert__PORT_MESSAGE_32TO64(ctx, (_PORT_MESSAGE**)&Message_used, x32based_Message);
	}
	else {
		Message_used = 0;
	}
	if (x32based_NumberOfBytesRead == NULL) {
		NumberOfBytesRead_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 6, PortHandle_used, Message_used, DataEntryIndex_used, Buffer_used, BufferSize_used, NumberOfBytesRead_used); // NtReadRequestData

	if (x32based_NumberOfBytesRead != NULL) {
		*((X32_SIZE_T*)x32based_NumberOfBytesRead) = (X32_SIZE_T)(*(SIZE_T*)NumberOfBytesRead_used);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtWriteRequestData(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_Message = (uint32_t)(x32based_args[3]); // PPORT_MESSAGE  IN 
	ULONG DataEntryIndex_used = (ULONG)(x32based_args[4]); // ULONG  IN 
	PVOID Buffer_used = (PVOID)(x32based_args[5]); // PVOID  IN 
	SIZE_T BufferSize_used = (SIZE_T)(x32based_args[6]); // SIZE_T  IN 
	uint32_t x32based_NumberOfBytesWritten = (uint32_t)(x32based_args[7]); // PSIZE_T  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE PortHandle_used = Handle32ToHandle((const void* __ptr32)x32based_PortHandle);
	uint8_t Message_holder[sizeof(_PORT_MESSAGE)];
	PPORT_MESSAGE Message_used = (PPORT_MESSAGE)&Message_holder;
	uint8_t NumberOfBytesWritten_holder[sizeof(long long unsigned int)];
	PSIZE_T NumberOfBytesWritten_used = (PSIZE_T)&NumberOfBytesWritten_holder;

	// Convert parameters from x32 to x64
	if (x32based_Message != NULL) {
		convert__PORT_MESSAGE_32TO64(ctx, (_PORT_MESSAGE**)&Message_used, x32based_Message);
	}
	else {
		Message_used = 0;
	}
	if (x32based_NumberOfBytesWritten == NULL) {
		NumberOfBytesWritten_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 6, PortHandle_used, Message_used, DataEntryIndex_used, Buffer_used, BufferSize_used, NumberOfBytesWritten_used); // NtWriteRequestData

	if (x32based_NumberOfBytesWritten != NULL) {
		*((X32_SIZE_T*)x32based_NumberOfBytesWritten) = (X32_SIZE_T)(*(SIZE_T*)NumberOfBytesWritten_used);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryInformationPort(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PORT_INFORMATION_CLASS PortInformationClass_used = (PORT_INFORMATION_CLASS)(x32based_args[3]); // PORT_INFORMATION_CLASS  IN 
	PVOID PortInformation_used = (PVOID)(x32based_args[4]); // PVOID  OUT 
	ULONG Length_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	PULONG ReturnLength_used = (PULONG)(x32based_args[6]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE PortHandle_used = Handle32ToHandle((const void* __ptr32)x32based_PortHandle);

	// Convert parameters from x32 to x64
	switch (PortInformationClass_used) {
	default: {
		ret_value = __syscall64(syscall_idx, 5, PortHandle_used, PortInformationClass_used, PortInformation_used, Length_used, ReturnLength_used); // NtQueryInformationPort
		break;
	}
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAlpcCreatePort(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[3]); // POBJECT_ATTRIBUTES  IN 
	uint32_t x32based_PortAttributes = (uint32_t)(x32based_args[4]); // PALPC_PORT_ATTRIBUTES  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t PortHandle_holder[sizeof(PVOID)];
	PHANDLE PortHandle_used = (PHANDLE)&PortHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;
	uint8_t PortAttributes_holder[sizeof(_ALPC_PORT_ATTRIBUTES)];
	PALPC_PORT_ATTRIBUTES PortAttributes_used = (PALPC_PORT_ATTRIBUTES)&PortAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_PortHandle == NULL) {
		PortHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}
	if (x32based_PortAttributes != NULL) {
		convert__ALPC_PORT_ATTRIBUTES_32TO64(ctx, (_ALPC_PORT_ATTRIBUTES**)&PortAttributes_used, x32based_PortAttributes);
	}
	else {
		PortAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, PortHandle_used, ObjectAttributes_used, PortAttributes_used); // NtAlpcCreatePort

	if (PortHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)PortHandle_used, x32based_PortHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAlpcDisconnectPort(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	ULONG Flags_used = (ULONG)(x32based_args[3]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE PortHandle_used = Handle32ToHandle((const void* __ptr32)x32based_PortHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, PortHandle_used, Flags_used); // NtAlpcDisconnectPort

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAlpcQueryInformation(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	ALPC_PORT_INFORMATION_CLASS PortInformationClass_used = (ALPC_PORT_INFORMATION_CLASS)(x32based_args[3]); // ALPC_PORT_INFORMATION_CLASS  IN 
	PVOID PortInformation_used = (PVOID)(x32based_args[4]); // PVOID  IN  OUT 
	ULONG Length_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	PULONG ReturnLength_used = (PULONG)(x32based_args[6]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE PortHandle_used = Handle32ToHandle((const void* __ptr32)x32based_PortHandle);

	// Convert parameters from x32 to x64
	switch (PortInformationClass_used) {
	case AlpcBasicInformation: {
		ret_value = _w32_NtAlpcQueryInformation_AlpcBasicInformation(ctx, syscall_idx, PortHandle_used, PortInformationClass_used, (ALPC_BASIC_INFORMATION*)PortInformation_used, Length_used, ReturnLength_used);
		break;
	}
	case AlpcServerInformation: {
		ret_value = _w32_NtAlpcQueryInformation_AlpcServerInformation(ctx, syscall_idx, PortHandle_used, PortInformationClass_used, (ALPC_SERVER_INFORMATION*)PortInformation_used, Length_used, ReturnLength_used);
		break;
	}
	default: {
		ret_value = __syscall64(syscall_idx, 5, PortHandle_used, PortInformationClass_used, PortInformation_used, Length_used, ReturnLength_used); // NtAlpcQueryInformation
		break;
	}
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAlpcSetInformation(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	ALPC_PORT_INFORMATION_CLASS PortInformationClass_used = (ALPC_PORT_INFORMATION_CLASS)(x32based_args[3]); // ALPC_PORT_INFORMATION_CLASS  IN 
	PVOID PortInformation_used = (PVOID)(x32based_args[4]); // PVOID  IN 
	ULONG Length_used = (ULONG)(x32based_args[5]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE PortHandle_used = Handle32ToHandle((const void* __ptr32)x32based_PortHandle);

	// Convert parameters from x32 to x64
	switch (PortInformationClass_used) {
	case AlpcBasicInformation: {
		ret_value = _w32_NtAlpcSetInformation_AlpcBasicInformation(ctx, syscall_idx, PortHandle_used, PortInformationClass_used, (ALPC_BASIC_INFORMATION*)PortInformation_used, Length_used);
		break;
	}
	case AlpcPortInformation: {
		ret_value = _w32_NtAlpcSetInformation_AlpcPortInformation(ctx, syscall_idx, PortHandle_used, PortInformationClass_used, (ALPC_PORT_ATTRIBUTES*)PortInformation_used, Length_used);
		break;
	}
	case AlpcAssociateCompletionPortInformation: {
		ret_value = _w32_NtAlpcSetInformation_AlpcAssociateCompletionPortInformation(ctx, syscall_idx, PortHandle_used, PortInformationClass_used, (ALPC_PORT_ASSOCIATE_COMPLETION_PORT*)PortInformation_used, Length_used);
		break;
	}
	case AlpcMessageZoneInformation: {
		ret_value = _w32_NtAlpcSetInformation_AlpcMessageZoneInformation(ctx, syscall_idx, PortHandle_used, PortInformationClass_used, (ALPC_PORT_MESSAGE_ZONE_INFORMATION*)PortInformation_used, Length_used);
		break;
	}
	case AlpcRegisterCompletionListInformation: {
		ret_value = _w32_NtAlpcSetInformation_AlpcRegisterCompletionListInformation(ctx, syscall_idx, PortHandle_used, PortInformationClass_used, (ALPC_PORT_COMPLETION_LIST_INFORMATION*)PortInformation_used, Length_used);
		break;
	}
	default: {
		ret_value = __syscall64(syscall_idx, 4, PortHandle_used, PortInformationClass_used, PortInformation_used, Length_used); // NtAlpcSetInformation
		break;
	}
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAlpcCreatePortSection(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	ULONG Flags_used = (ULONG)(x32based_args[3]); // ULONG  IN 
	uint32_t x32based_SectionHandle = (uint32_t)(x32based_args[4]); // HANDLE  IN 
	SIZE_T SectionSize_used = (SIZE_T)(x32based_args[5]); // SIZE_T  IN 
	uint32_t x32based_AlpcSectionHandle = (uint32_t)(x32based_args[6]); // PALPC_HANDLE  OUT 
	uint32_t x32based_ActualSectionSize = (uint32_t)(x32based_args[7]); // PSIZE_T  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE PortHandle_used = Handle32ToHandle((const void* __ptr32)x32based_PortHandle);
	HANDLE SectionHandle_used = Handle32ToHandle((const void* __ptr32)x32based_SectionHandle);
	uint8_t AlpcSectionHandle_holder[sizeof(PVOID)];
	PALPC_HANDLE AlpcSectionHandle_used = (PALPC_HANDLE)&AlpcSectionHandle_holder;
	uint8_t ActualSectionSize_holder[sizeof(long long unsigned int)];
	PSIZE_T ActualSectionSize_used = (PSIZE_T)&ActualSectionSize_holder;

	// Convert parameters from x32 to x64
	if (x32based_AlpcSectionHandle == NULL) {
		AlpcSectionHandle_used = 0;
	}
	if (x32based_ActualSectionSize == NULL) {
		ActualSectionSize_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 6, PortHandle_used, Flags_used, SectionHandle_used, SectionSize_used, AlpcSectionHandle_used, ActualSectionSize_used); // NtAlpcCreatePortSection

	if (AlpcSectionHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)AlpcSectionHandle_used, x32based_AlpcSectionHandle);
	}
	if (x32based_ActualSectionSize != NULL) {
		*((X32_SIZE_T*)x32based_ActualSectionSize) = (X32_SIZE_T)(*(SIZE_T*)ActualSectionSize_used);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAlpcDeletePortSection(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	ULONG Flags_used = (ULONG)(x32based_args[3]); // ULONG 
	ALPC_HANDLE SectionHandle_used = (ALPC_HANDLE)(x32based_args[4]); // ALPC_HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE PortHandle_used = Handle32ToHandle((const void* __ptr32)x32based_PortHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 3, PortHandle_used, Flags_used, SectionHandle_used); // NtAlpcDeletePortSection

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAlpcCreateResourceReserve(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	ULONG Flags_used = (ULONG)(x32based_args[3]); // ULONG 
	SIZE_T MessageSize_used = (SIZE_T)(x32based_args[4]); // SIZE_T  IN 
	uint32_t x32based_ResourceId = (uint32_t)(x32based_args[5]); // PALPC_HANDLE  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE PortHandle_used = Handle32ToHandle((const void* __ptr32)x32based_PortHandle);
	uint8_t ResourceId_holder[sizeof(PVOID)];
	PALPC_HANDLE ResourceId_used = (PALPC_HANDLE)&ResourceId_holder;

	// Convert parameters from x32 to x64
	if (x32based_ResourceId == NULL) {
		ResourceId_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 4, PortHandle_used, Flags_used, MessageSize_used, ResourceId_used); // NtAlpcCreateResourceReserve

	if (ResourceId_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)ResourceId_used, x32based_ResourceId);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAlpcDeleteResourceReserve(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	ULONG Flags_used = (ULONG)(x32based_args[3]); // ULONG 
	ALPC_HANDLE ResourceId_used = (ALPC_HANDLE)(x32based_args[4]); // ALPC_HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE PortHandle_used = Handle32ToHandle((const void* __ptr32)x32based_PortHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 3, PortHandle_used, Flags_used, ResourceId_used); // NtAlpcDeleteResourceReserve

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAlpcCreateSectionView(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	ULONG Flags_used = (ULONG)(x32based_args[3]); // ULONG 
	uint32_t x32based_ViewAttributes = (uint32_t)(x32based_args[4]); // PALPC_DATA_VIEW_ATTR  IN  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE PortHandle_used = Handle32ToHandle((const void* __ptr32)x32based_PortHandle);
	uint8_t ViewAttributes_holder[sizeof(_ALPC_DATA_VIEW_ATTR)];
	PALPC_DATA_VIEW_ATTR ViewAttributes_used = (PALPC_DATA_VIEW_ATTR)&ViewAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_ViewAttributes != NULL) {
		convert__ALPC_DATA_VIEW_ATTR_32TO64(ctx, (_ALPC_DATA_VIEW_ATTR**)&ViewAttributes_used, x32based_ViewAttributes);
	}
	else {
		ViewAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, PortHandle_used, Flags_used, ViewAttributes_used); // NtAlpcCreateSectionView

	if (ViewAttributes_used != NULL) {
		convert__ALPC_DATA_VIEW_ATTR_64TO32(ctx, (_ALPC_DATA_VIEW_ATTR*)ViewAttributes_used, x32based_ViewAttributes);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAlpcDeleteSectionView(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	ULONG Flags_used = (ULONG)(x32based_args[3]); // ULONG 
	PVOID ViewBase_used = (PVOID)(x32based_args[4]); // PVOID  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE PortHandle_used = Handle32ToHandle((const void* __ptr32)x32based_PortHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 3, PortHandle_used, Flags_used, ViewBase_used); // NtAlpcDeleteSectionView

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAlpcCreateSecurityContext(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	ULONG Flags_used = (ULONG)(x32based_args[3]); // ULONG 
	uint32_t x32based_SecurityAttribute = (uint32_t)(x32based_args[4]); // PALPC_SECURITY_ATTR  IN  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE PortHandle_used = Handle32ToHandle((const void* __ptr32)x32based_PortHandle);
	uint8_t SecurityAttribute_holder[sizeof(_ALPC_SECURITY_ATTR)];
	PALPC_SECURITY_ATTR SecurityAttribute_used = (PALPC_SECURITY_ATTR)&SecurityAttribute_holder;

	// Convert parameters from x32 to x64
	if (x32based_SecurityAttribute != NULL) {
		convert__ALPC_SECURITY_ATTR_32TO64(ctx, (_ALPC_SECURITY_ATTR**)&SecurityAttribute_used, x32based_SecurityAttribute);
	}
	else {
		SecurityAttribute_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, PortHandle_used, Flags_used, SecurityAttribute_used); // NtAlpcCreateSecurityContext

	if (SecurityAttribute_used != NULL) {
		convert__ALPC_SECURITY_ATTR_64TO32(ctx, (_ALPC_SECURITY_ATTR*)SecurityAttribute_used, x32based_SecurityAttribute);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAlpcDeleteSecurityContext(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	ULONG Flags_used = (ULONG)(x32based_args[3]); // ULONG 
	ALPC_HANDLE ContextHandle_used = (ALPC_HANDLE)(x32based_args[4]); // ALPC_HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE PortHandle_used = Handle32ToHandle((const void* __ptr32)x32based_PortHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 3, PortHandle_used, Flags_used, ContextHandle_used); // NtAlpcDeleteSecurityContext

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAlpcRevokeSecurityContext(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	ULONG Flags_used = (ULONG)(x32based_args[3]); // ULONG 
	ALPC_HANDLE ContextHandle_used = (ALPC_HANDLE)(x32based_args[4]); // ALPC_HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE PortHandle_used = Handle32ToHandle((const void* __ptr32)x32based_PortHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 3, PortHandle_used, Flags_used, ContextHandle_used); // NtAlpcRevokeSecurityContext

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAlpcQueryInformationMessage(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_PortMessage = (uint32_t)(x32based_args[3]); // PPORT_MESSAGE  IN 
	ALPC_MESSAGE_INFORMATION_CLASS MessageInformationClass_used = (ALPC_MESSAGE_INFORMATION_CLASS)(x32based_args[4]); // ALPC_MESSAGE_INFORMATION_CLASS  IN 
	PVOID MessageInformation_used = (PVOID)(x32based_args[5]); // PVOID  OUT 
	ULONG Length_used = (ULONG)(x32based_args[6]); // ULONG  IN 
	PULONG ReturnLength_used = (PULONG)(x32based_args[7]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE PortHandle_used = Handle32ToHandle((const void* __ptr32)x32based_PortHandle);
	uint8_t PortMessage_holder[sizeof(_PORT_MESSAGE)];
	PPORT_MESSAGE PortMessage_used = (PPORT_MESSAGE)&PortMessage_holder;

	// Convert parameters from x32 to x64
	if (x32based_PortMessage != NULL) {
		convert__PORT_MESSAGE_32TO64(ctx, (_PORT_MESSAGE**)&PortMessage_used, x32based_PortMessage);
	}
	else {
		PortMessage_used = 0;
	}

	switch (MessageInformationClass_used) {
	default: {
		ret_value = __syscall64(syscall_idx, 6, PortHandle_used, PortMessage_used, MessageInformationClass_used, MessageInformation_used, Length_used, ReturnLength_used); // NtAlpcQueryInformationMessage
		break;
	}
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAlpcConnectPort(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	uint32_t x32based_PortName = (uint32_t)(x32based_args[3]); // PUNICODE_STRING  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	uint32_t x32based_PortAttributes = (uint32_t)(x32based_args[5]); // PALPC_PORT_ATTRIBUTES  IN 
	ULONG Flags_used = (ULONG)(x32based_args[6]); // ULONG  IN 
	uint32_t x32based_RequiredServerSid = (uint32_t)(x32based_args[7]); // PSID  IN 
	uint32_t x32based_ConnectionMessage = (uint32_t)(x32based_args[8]); // PPORT_MESSAGE  IN  OUT 
	PULONG BufferLength_used = (PULONG)(x32based_args[9]); // PULONG  IN  OUT 
	PALPC_MESSAGE_ATTRIBUTES OutMessageAttributes_used = (PALPC_MESSAGE_ATTRIBUTES)(x32based_args[10]); // PALPC_MESSAGE_ATTRIBUTES  IN  OUT 
	PALPC_MESSAGE_ATTRIBUTES InMessageAttributes_used = (PALPC_MESSAGE_ATTRIBUTES)(x32based_args[11]); // PALPC_MESSAGE_ATTRIBUTES  IN  OUT 
	PLARGE_INTEGER Timeout_used = (PLARGE_INTEGER)(x32based_args[12]); // PLARGE_INTEGER  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t PortHandle_holder[sizeof(PVOID)];
	PHANDLE PortHandle_used = (PHANDLE)&PortHandle_holder;
	uint8_t PortName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING PortName_used = (PUNICODE_STRING)&PortName_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;
	uint8_t PortAttributes_holder[sizeof(_ALPC_PORT_ATTRIBUTES)];
	PALPC_PORT_ATTRIBUTES PortAttributes_used = (PALPC_PORT_ATTRIBUTES)&PortAttributes_holder;
	uint8_t RequiredServerSid_holder[sizeof(PVOID)];
	PSID RequiredServerSid_used = (PSID)&RequiredServerSid_holder;
	uint8_t ConnectionMessage_holder[sizeof(_PORT_MESSAGE)];
	PPORT_MESSAGE ConnectionMessage_used = (PPORT_MESSAGE)&ConnectionMessage_holder;

	// Convert parameters from x32 to x64
	if (x32based_PortHandle == NULL) {
		PortHandle_used = 0;
	}
	if (x32based_PortName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&PortName_used, x32based_PortName);
	}
	else {
		PortName_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}
	if (x32based_PortAttributes != NULL) {
		convert__ALPC_PORT_ATTRIBUTES_32TO64(ctx, (_ALPC_PORT_ATTRIBUTES**)&PortAttributes_used, x32based_PortAttributes);
	}
	else {
		PortAttributes_used = 0;
	}
	if (x32based_RequiredServerSid != NULL) {
		convert_HANDLE_32TO64(ctx, (HANDLE**)&RequiredServerSid_used, x32based_RequiredServerSid);
	}
	else {
		RequiredServerSid_used = 0;
	}
	if (x32based_ConnectionMessage != NULL) {
		convert__PORT_MESSAGE_32TO64(ctx, (_PORT_MESSAGE**)&ConnectionMessage_used, x32based_ConnectionMessage);
	}
	else {
		ConnectionMessage_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 11, PortHandle_used, PortName_used, ObjectAttributes_used, PortAttributes_used, Flags_used, RequiredServerSid_used, ConnectionMessage_used, BufferLength_used, OutMessageAttributes_used, InMessageAttributes_used, Timeout_used); // NtAlpcConnectPort

	if (PortHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)PortHandle_used, x32based_PortHandle);
	}
	if (ConnectionMessage_used != NULL) {
		convert__PORT_MESSAGE_64TO32(ctx, (_PORT_MESSAGE*)ConnectionMessage_used, x32based_ConnectionMessage);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAlpcConnectPortEx(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	uint32_t x32based_ConnectionPortObjectAttributes = (uint32_t)(x32based_args[3]); // POBJECT_ATTRIBUTES  IN 
	uint32_t x32based_ClientPortObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	uint32_t x32based_PortAttributes = (uint32_t)(x32based_args[5]); // PALPC_PORT_ATTRIBUTES  IN 
	ULONG Flags_used = (ULONG)(x32based_args[6]); // ULONG  IN 
	uint32_t x32based_ServerSecurityRequirements = (uint32_t)(x32based_args[7]); // PSECURITY_DESCRIPTOR  IN 
	uint32_t x32based_ConnectionMessage = (uint32_t)(x32based_args[8]); // PPORT_MESSAGE  IN  OUT 
	uint32_t x32based_BufferLength = (uint32_t)(x32based_args[9]); // PSIZE_T  IN  OUT 
	PALPC_MESSAGE_ATTRIBUTES OutMessageAttributes_used = (PALPC_MESSAGE_ATTRIBUTES)(x32based_args[10]); // PALPC_MESSAGE_ATTRIBUTES  IN  OUT 
	PALPC_MESSAGE_ATTRIBUTES InMessageAttributes_used = (PALPC_MESSAGE_ATTRIBUTES)(x32based_args[11]); // PALPC_MESSAGE_ATTRIBUTES  IN  OUT 
	PLARGE_INTEGER Timeout_used = (PLARGE_INTEGER)(x32based_args[12]); // PLARGE_INTEGER  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t PortHandle_holder[sizeof(PVOID)];
	PHANDLE PortHandle_used = (PHANDLE)&PortHandle_holder;
	uint8_t ConnectionPortObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ConnectionPortObjectAttributes_used = (POBJECT_ATTRIBUTES)&ConnectionPortObjectAttributes_holder;
	uint8_t ClientPortObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ClientPortObjectAttributes_used = (POBJECT_ATTRIBUTES)&ClientPortObjectAttributes_holder;
	uint8_t PortAttributes_holder[sizeof(_ALPC_PORT_ATTRIBUTES)];
	PALPC_PORT_ATTRIBUTES PortAttributes_used = (PALPC_PORT_ATTRIBUTES)&PortAttributes_holder;
	uint8_t ServerSecurityRequirements_holder[sizeof(PVOID)];
	PSECURITY_DESCRIPTOR ServerSecurityRequirements_used = (PSECURITY_DESCRIPTOR)&ServerSecurityRequirements_holder;
	uint8_t ConnectionMessage_holder[sizeof(_PORT_MESSAGE)];
	PPORT_MESSAGE ConnectionMessage_used = (PPORT_MESSAGE)&ConnectionMessage_holder;
	uint8_t BufferLength_holder[sizeof(long long unsigned int)];
	PSIZE_T BufferLength_used = (PSIZE_T)&BufferLength_holder;

	// Convert parameters from x32 to x64
	if (x32based_PortHandle == NULL) {
		PortHandle_used = 0;
	}
	if (x32based_ConnectionPortObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ConnectionPortObjectAttributes_used, x32based_ConnectionPortObjectAttributes);
	}
	else {
		ConnectionPortObjectAttributes_used = 0;
	}
	if (x32based_ClientPortObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ClientPortObjectAttributes_used, x32based_ClientPortObjectAttributes);
	}
	else {
		ClientPortObjectAttributes_used = 0;
	}
	if (x32based_PortAttributes != NULL) {
		convert__ALPC_PORT_ATTRIBUTES_32TO64(ctx, (_ALPC_PORT_ATTRIBUTES**)&PortAttributes_used, x32based_PortAttributes);
	}
	else {
		PortAttributes_used = 0;
	}
	if (x32based_ServerSecurityRequirements != NULL) {
		convert_HANDLE_32TO64(ctx, (HANDLE**)&ServerSecurityRequirements_used, x32based_ServerSecurityRequirements);
	}
	else {
		ServerSecurityRequirements_used = 0;
	}
	if (x32based_ConnectionMessage != NULL) {
		convert__PORT_MESSAGE_32TO64(ctx, (_PORT_MESSAGE**)&ConnectionMessage_used, x32based_ConnectionMessage);
	}
	else {
		ConnectionMessage_used = 0;
	}
	if (x32based_BufferLength != NULL) {
		*((SIZE_T*)BufferLength_holder) = (SIZE_T)(*((X32_SIZE_T*)x32based_BufferLength));
	}
	else {
		BufferLength_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 11, PortHandle_used, ConnectionPortObjectAttributes_used, ClientPortObjectAttributes_used, PortAttributes_used, Flags_used, ServerSecurityRequirements_used, ConnectionMessage_used, BufferLength_used, OutMessageAttributes_used, InMessageAttributes_used, Timeout_used); // NtAlpcConnectPortEx

	if (PortHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)PortHandle_used, x32based_PortHandle);
	}
	if (ConnectionMessage_used != NULL) {
		convert__PORT_MESSAGE_64TO32(ctx, (_PORT_MESSAGE*)ConnectionMessage_used, x32based_ConnectionMessage);
	}
	if (x32based_BufferLength != NULL) {
		*((X32_SIZE_T*)x32based_BufferLength) = (X32_SIZE_T)(*(SIZE_T*)BufferLength_used);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAlpcAcceptConnectPort(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	uint32_t x32based_ConnectionPortHandle = (uint32_t)(x32based_args[3]); // HANDLE  IN 
	ULONG Flags_used = (ULONG)(x32based_args[4]); // ULONG  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[5]); // POBJECT_ATTRIBUTES  IN 
	uint32_t x32based_PortAttributes = (uint32_t)(x32based_args[6]); // PALPC_PORT_ATTRIBUTES  IN 
	PVOID PortContext_used = (PVOID)(x32based_args[7]); // PVOID  IN 
	uint32_t x32based_ConnectionRequest = (uint32_t)(x32based_args[8]); // PPORT_MESSAGE  IN 
	PALPC_MESSAGE_ATTRIBUTES ConnectionMessageAttributes_used = (PALPC_MESSAGE_ATTRIBUTES)(x32based_args[9]); // PALPC_MESSAGE_ATTRIBUTES  IN  OUT 
	BOOLEAN AcceptConnection_used = (BOOLEAN)(x32based_args[10]); // BOOLEAN  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t PortHandle_holder[sizeof(PVOID)];
	PHANDLE PortHandle_used = (PHANDLE)&PortHandle_holder;
	HANDLE ConnectionPortHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ConnectionPortHandle);
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;
	uint8_t PortAttributes_holder[sizeof(_ALPC_PORT_ATTRIBUTES)];
	PALPC_PORT_ATTRIBUTES PortAttributes_used = (PALPC_PORT_ATTRIBUTES)&PortAttributes_holder;
	uint8_t ConnectionRequest_holder[sizeof(_PORT_MESSAGE)];
	PPORT_MESSAGE ConnectionRequest_used = (PPORT_MESSAGE)&ConnectionRequest_holder;

	// Convert parameters from x32 to x64
	if (x32based_PortHandle == NULL) {
		PortHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}
	if (x32based_PortAttributes != NULL) {
		convert__ALPC_PORT_ATTRIBUTES_32TO64(ctx, (_ALPC_PORT_ATTRIBUTES**)&PortAttributes_used, x32based_PortAttributes);
	}
	else {
		PortAttributes_used = 0;
	}
	if (x32based_ConnectionRequest != NULL) {
		convert__PORT_MESSAGE_32TO64(ctx, (_PORT_MESSAGE**)&ConnectionRequest_used, x32based_ConnectionRequest);
	}
	else {
		ConnectionRequest_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 9, PortHandle_used, ConnectionPortHandle_used, Flags_used, ObjectAttributes_used, PortAttributes_used, PortContext_used, ConnectionRequest_used, ConnectionMessageAttributes_used, AcceptConnection_used); // NtAlpcAcceptConnectPort

	if (PortHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)PortHandle_used, x32based_PortHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAlpcSendWaitReceivePort(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	ULONG Flags_used = (ULONG)(x32based_args[3]); // ULONG  IN 
	uint32_t x32based_SendMessageA = (uint32_t)(x32based_args[4]); // PPORT_MESSAGE  IN 
	PALPC_MESSAGE_ATTRIBUTES SendMessageAttributes_used = (PALPC_MESSAGE_ATTRIBUTES)(x32based_args[5]); // PALPC_MESSAGE_ATTRIBUTES  IN  OUT 
	uint32_t x32based_ReceiveMessage = (uint32_t)(x32based_args[6]); // PPORT_MESSAGE  OUT 
	uint32_t x32based_BufferLength = (uint32_t)(x32based_args[7]); // PSIZE_T  IN  OUT 
	PALPC_MESSAGE_ATTRIBUTES ReceiveMessageAttributes_used = (PALPC_MESSAGE_ATTRIBUTES)(x32based_args[8]); // PALPC_MESSAGE_ATTRIBUTES  IN  OUT 
	PLARGE_INTEGER Timeout_used = (PLARGE_INTEGER)(x32based_args[9]); // PLARGE_INTEGER  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE PortHandle_used = Handle32ToHandle((const void* __ptr32)x32based_PortHandle);
	uint8_t SendMessageA_holder[sizeof(_PORT_MESSAGE)];
	PPORT_MESSAGE SendMessageA_used = (PPORT_MESSAGE)&SendMessageA_holder;
	uint8_t ReceiveMessage_holder[sizeof(_PORT_MESSAGE)];
	PPORT_MESSAGE ReceiveMessage_used = (PPORT_MESSAGE)&ReceiveMessage_holder;
	uint8_t BufferLength_holder[sizeof(long long unsigned int)];
	PSIZE_T BufferLength_used = (PSIZE_T)&BufferLength_holder;

	// Convert parameters from x32 to x64
	if (x32based_SendMessageA != NULL) {
		convert__PORT_MESSAGE_32TO64(ctx, (_PORT_MESSAGE**)&SendMessageA_used, x32based_SendMessageA);
	}
	else {
		SendMessageA_used = 0;
	}
	if (x32based_ReceiveMessage == NULL) {
		ReceiveMessage_used = 0;
	}
	if (x32based_BufferLength != NULL) {
		*((SIZE_T*)BufferLength_holder) = (SIZE_T)(*((X32_SIZE_T*)x32based_BufferLength));
	}
	else {
		BufferLength_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 8, PortHandle_used, Flags_used, SendMessageA_used, SendMessageAttributes_used, ReceiveMessage_used, BufferLength_used, ReceiveMessageAttributes_used, Timeout_used); // NtAlpcSendWaitReceivePort

	if (ReceiveMessage_used != NULL) {
		convert__PORT_MESSAGE_64TO32(ctx, (_PORT_MESSAGE*)ReceiveMessage_used, x32based_ReceiveMessage);
	}
	if (x32based_BufferLength != NULL) {
		*((X32_SIZE_T*)x32based_BufferLength) = (X32_SIZE_T)(*(SIZE_T*)BufferLength_used);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAlpcCancelMessage(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	ULONG Flags_used = (ULONG)(x32based_args[3]); // ULONG  IN 
	uint32_t x32based_MessageContext = (uint32_t)(x32based_args[4]); // PALPC_CONTEXT_ATTR  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE PortHandle_used = Handle32ToHandle((const void* __ptr32)x32based_PortHandle);
	uint8_t MessageContext_holder[sizeof(_ALPC_CONTEXT_ATTR)];
	PALPC_CONTEXT_ATTR MessageContext_used = (PALPC_CONTEXT_ATTR)&MessageContext_holder;

	// Convert parameters from x32 to x64
	if (x32based_MessageContext != NULL) {
		convert__ALPC_CONTEXT_ATTR_32TO64(ctx, (_ALPC_CONTEXT_ATTR**)&MessageContext_used, x32based_MessageContext);
	}
	else {
		MessageContext_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, PortHandle_used, Flags_used, MessageContext_used); // NtAlpcCancelMessage

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAlpcImpersonateClientOfPort(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_Message = (uint32_t)(x32based_args[3]); // PPORT_MESSAGE  IN 
	PVOID Flags_used = (PVOID)(x32based_args[4]); // PVOID  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE PortHandle_used = Handle32ToHandle((const void* __ptr32)x32based_PortHandle);
	uint8_t Message_holder[sizeof(_PORT_MESSAGE)];
	PPORT_MESSAGE Message_used = (PPORT_MESSAGE)&Message_holder;

	// Convert parameters from x32 to x64
	if (x32based_Message != NULL) {
		convert__PORT_MESSAGE_32TO64(ctx, (_PORT_MESSAGE**)&Message_used, x32based_Message);
	}
	else {
		Message_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, PortHandle_used, Message_used, Flags_used); // NtAlpcImpersonateClientOfPort

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAlpcImpersonateClientContainerOfPort(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_Message = (uint32_t)(x32based_args[3]); // PPORT_MESSAGE  IN 
	ULONG Flags_used = (ULONG)(x32based_args[4]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE PortHandle_used = Handle32ToHandle((const void* __ptr32)x32based_PortHandle);
	uint8_t Message_holder[sizeof(_PORT_MESSAGE)];
	PPORT_MESSAGE Message_used = (PPORT_MESSAGE)&Message_holder;

	// Convert parameters from x32 to x64
	if (x32based_Message != NULL) {
		convert__PORT_MESSAGE_32TO64(ctx, (_PORT_MESSAGE**)&Message_used, x32based_Message);
	}
	else {
		Message_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, PortHandle_used, Message_used, Flags_used); // NtAlpcImpersonateClientContainerOfPort

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAlpcOpenSenderProcess(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[3]); // HANDLE  IN 
	uint32_t x32based_PortMessage = (uint32_t)(x32based_args[4]); // PPORT_MESSAGE  IN 
	ULONG Flags_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[6]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[7]); // POBJECT_ATTRIBUTES  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ProcessHandle_holder[sizeof(PVOID)];
	PHANDLE ProcessHandle_used = (PHANDLE)&ProcessHandle_holder;
	HANDLE PortHandle_used = Handle32ToHandle((const void* __ptr32)x32based_PortHandle);
	uint8_t PortMessage_holder[sizeof(_PORT_MESSAGE)];
	PPORT_MESSAGE PortMessage_used = (PPORT_MESSAGE)&PortMessage_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_ProcessHandle == NULL) {
		ProcessHandle_used = 0;
	}
	if (x32based_PortMessage != NULL) {
		convert__PORT_MESSAGE_32TO64(ctx, (_PORT_MESSAGE**)&PortMessage_used, x32based_PortMessage);
	}
	else {
		PortMessage_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 6, ProcessHandle_used, PortHandle_used, PortMessage_used, Flags_used, DesiredAccess_used, ObjectAttributes_used); // NtAlpcOpenSenderProcess

	if (ProcessHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)ProcessHandle_used, x32based_ProcessHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAlpcOpenSenderThread(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ThreadHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	uint32_t x32based_PortHandle = (uint32_t)(x32based_args[3]); // HANDLE  IN 
	uint32_t x32based_PortMessage = (uint32_t)(x32based_args[4]); // PPORT_MESSAGE  IN 
	ULONG Flags_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[6]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[7]); // POBJECT_ATTRIBUTES  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ThreadHandle_holder[sizeof(PVOID)];
	PHANDLE ThreadHandle_used = (PHANDLE)&ThreadHandle_holder;
	HANDLE PortHandle_used = Handle32ToHandle((const void* __ptr32)x32based_PortHandle);
	uint8_t PortMessage_holder[sizeof(_PORT_MESSAGE)];
	PPORT_MESSAGE PortMessage_used = (PPORT_MESSAGE)&PortMessage_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_ThreadHandle == NULL) {
		ThreadHandle_used = 0;
	}
	if (x32based_PortMessage != NULL) {
		convert__PORT_MESSAGE_32TO64(ctx, (_PORT_MESSAGE**)&PortMessage_used, x32based_PortMessage);
	}
	else {
		PortMessage_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 6, ThreadHandle_used, PortHandle_used, PortMessage_used, Flags_used, DesiredAccess_used, ObjectAttributes_used); // NtAlpcOpenSenderThread

	if (ThreadHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)ThreadHandle_used, x32based_ThreadHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtPlugPlayControl(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PLUGPLAY_CONTROL_CLASS PnPControlClass_used = (PLUGPLAY_CONTROL_CLASS)(x32based_args[2]); // PLUGPLAY_CONTROL_CLASS  IN 
	PVOID PnPControlData_used = (PVOID)(x32based_args[3]); // PVOID  IN  OUT 
	ULONG PnPControlDataLength_used = (ULONG)(x32based_args[4]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 3, PnPControlClass_used, PnPControlData_used, PnPControlDataLength_used); // NtPlugPlayControl

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSerializeBoot(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 0); // NtSerializeBoot

	return ret_value;
}


NTSTATUS WINAPI _w32_NtEnableLastKnownGood(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 0); // NtEnableLastKnownGood

	return ret_value;
}


NTSTATUS WINAPI _w32_NtDisableLastKnownGood(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 0); // NtDisableLastKnownGood

	return ret_value;
}


NTSTATUS WINAPI _w32_NtReplacePartitionUnit(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TargetInstancePath = (uint32_t)(x32based_args[2]); // PUNICODE_STRING  IN 
	uint32_t x32based_SpareInstancePath = (uint32_t)(x32based_args[3]); // PUNICODE_STRING  IN 
	ULONG Flags_used = (ULONG)(x32based_args[4]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t TargetInstancePath_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING TargetInstancePath_used = (PUNICODE_STRING)&TargetInstancePath_holder;
	uint8_t SpareInstancePath_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING SpareInstancePath_used = (PUNICODE_STRING)&SpareInstancePath_holder;

	// Convert parameters from x32 to x64
	if (x32based_TargetInstancePath != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&TargetInstancePath_used, x32based_TargetInstancePath);
	}
	else {
		TargetInstancePath_used = 0;
	}
	if (x32based_SpareInstancePath != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&SpareInstancePath_used, x32based_SpareInstancePath);
	}
	else {
		SpareInstancePath_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, TargetInstancePath_used, SpareInstancePath_used, Flags_used); // NtReplacePartitionUnit

	return ret_value;
}


NTSTATUS WINAPI _w32_NtPowerInformation(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	POWER_INFORMATION_LEVEL InformationLevel_used = (POWER_INFORMATION_LEVEL)(x32based_args[2]); // POWER_INFORMATION_LEVEL  IN 
	PVOID InputBuffer_used = (PVOID)(x32based_args[3]); // PVOID  IN 
	ULONG InputBufferLength_used = (ULONG)(x32based_args[4]); // ULONG  IN 
	PVOID OutputBuffer_used = (PVOID)(x32based_args[5]); // PVOID  OUT 
	ULONG OutputBufferLength_used = (ULONG)(x32based_args[6]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 5, InformationLevel_used, InputBuffer_used, InputBufferLength_used, OutputBuffer_used, OutputBufferLength_used); // NtPowerInformation

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetThreadExecutionState(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	EXECUTION_STATE NewFlags_used = (EXECUTION_STATE)(x32based_args[2]); // EXECUTION_STATE  IN 
	EXECUTION_STATE* PreviousFlags_used = (EXECUTION_STATE*)(x32based_args[3]); // EXECUTION_STATE *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, NewFlags_used, PreviousFlags_used); // NtSetThreadExecutionState

	return ret_value;
}


NTSTATUS WINAPI _w32_NtInitiatePowerAction(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	POWER_ACTION SystemAction_used = (POWER_ACTION)(x32based_args[2]); // POWER_ACTION  IN 
	SYSTEM_POWER_STATE LightestSystemState_used = (SYSTEM_POWER_STATE)(x32based_args[3]); // SYSTEM_POWER_STATE  IN 
	ULONG Flags_used = (ULONG)(x32based_args[4]); // ULONG  IN 
	BOOLEAN Asynchronous_used = (BOOLEAN)(x32based_args[5]); // BOOLEAN  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 4, SystemAction_used, LightestSystemState_used, Flags_used, Asynchronous_used); // NtInitiatePowerAction

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetSystemPowerState(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	POWER_ACTION SystemAction_used = (POWER_ACTION)(x32based_args[2]); // POWER_ACTION  IN 
	SYSTEM_POWER_STATE LightestSystemState_used = (SYSTEM_POWER_STATE)(x32based_args[3]); // SYSTEM_POWER_STATE  IN 
	ULONG Flags_used = (ULONG)(x32based_args[4]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 3, SystemAction_used, LightestSystemState_used, Flags_used); // NtSetSystemPowerState

	return ret_value;
}


NTSTATUS WINAPI _w32_NtGetDevicePowerState(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_Device = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PDEVICE_POWER_STATE State_used = (PDEVICE_POWER_STATE)(x32based_args[3]); // PDEVICE_POWER_STATE  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE Device_used = Handle32ToHandle((const void* __ptr32)x32based_Device);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, Device_used, State_used); // NtGetDevicePowerState

	return ret_value;
}


BOOLEAN WINAPI _w32_NtIsSystemResumeAutomatic(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	// Declare space used in parameters
	// Convert parameters from x32 to x64
	return (BOOLEAN)__syscall64(syscall_idx, 0); // NtIsSystemResumeAutomatic
}


NTSTATUS WINAPI _w32_NtCreateKey(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_KeyHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	ULONG TitleIndex_used = (ULONG)(x32based_args[5]); // ULONG 
	uint32_t x32based_Class = (uint32_t)(x32based_args[6]); // PUNICODE_STRING  IN 
	ULONG CreateOptions_used = (ULONG)(x32based_args[7]); // ULONG  IN 
	PULONG Disposition_used = (PULONG)(x32based_args[8]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t KeyHandle_holder[sizeof(PVOID)];
	PHANDLE KeyHandle_used = (PHANDLE)&KeyHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;
	uint8_t Class_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING Class_used = (PUNICODE_STRING)&Class_holder;

	// Convert parameters from x32 to x64
	if (x32based_KeyHandle == NULL) {
		KeyHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}
	if (x32based_Class != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&Class_used, x32based_Class);
	}
	else {
		Class_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 7, KeyHandle_used, DesiredAccess_used, ObjectAttributes_used, TitleIndex_used, Class_used, CreateOptions_used, Disposition_used); // NtCreateKey

	if (KeyHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)KeyHandle_used, x32based_KeyHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateKeyTransacted(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_KeyHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	ULONG TitleIndex_used = (ULONG)(x32based_args[5]); // ULONG 
	uint32_t x32based_Class = (uint32_t)(x32based_args[6]); // PUNICODE_STRING  IN 
	ULONG CreateOptions_used = (ULONG)(x32based_args[7]); // ULONG  IN 
	uint32_t x32based_TransactionHandle = (uint32_t)(x32based_args[8]); // HANDLE  IN 
	PULONG Disposition_used = (PULONG)(x32based_args[9]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t KeyHandle_holder[sizeof(PVOID)];
	PHANDLE KeyHandle_used = (PHANDLE)&KeyHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;
	uint8_t Class_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING Class_used = (PUNICODE_STRING)&Class_holder;
	HANDLE TransactionHandle_used = Handle32ToHandle((const void* __ptr32)x32based_TransactionHandle);

	// Convert parameters from x32 to x64
	if (x32based_KeyHandle == NULL) {
		KeyHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}
	if (x32based_Class != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&Class_used, x32based_Class);
	}
	else {
		Class_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 8, KeyHandle_used, DesiredAccess_used, ObjectAttributes_used, TitleIndex_used, Class_used, CreateOptions_used, TransactionHandle_used, Disposition_used); // NtCreateKeyTransacted

	if (KeyHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)KeyHandle_used, x32based_KeyHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtOpenKey(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_KeyHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t KeyHandle_holder[sizeof(PVOID)];
	PHANDLE KeyHandle_used = (PHANDLE)&KeyHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_KeyHandle == NULL) {
		KeyHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, KeyHandle_used, DesiredAccess_used, ObjectAttributes_used); // NtOpenKey

	if (KeyHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)KeyHandle_used, x32based_KeyHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtOpenKeyTransacted(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_KeyHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	uint32_t x32based_TransactionHandle = (uint32_t)(x32based_args[5]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t KeyHandle_holder[sizeof(PVOID)];
	PHANDLE KeyHandle_used = (PHANDLE)&KeyHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;
	HANDLE TransactionHandle_used = Handle32ToHandle((const void* __ptr32)x32based_TransactionHandle);

	// Convert parameters from x32 to x64
	if (x32based_KeyHandle == NULL) {
		KeyHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, KeyHandle_used, DesiredAccess_used, ObjectAttributes_used, TransactionHandle_used); // NtOpenKeyTransacted

	if (KeyHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)KeyHandle_used, x32based_KeyHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtOpenKeyEx(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_KeyHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	ULONG OpenOptions_used = (ULONG)(x32based_args[5]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t KeyHandle_holder[sizeof(PVOID)];
	PHANDLE KeyHandle_used = (PHANDLE)&KeyHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_KeyHandle == NULL) {
		KeyHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, KeyHandle_used, DesiredAccess_used, ObjectAttributes_used, OpenOptions_used); // NtOpenKeyEx

	if (KeyHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)KeyHandle_used, x32based_KeyHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtOpenKeyTransactedEx(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_KeyHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	ULONG OpenOptions_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	uint32_t x32based_TransactionHandle = (uint32_t)(x32based_args[6]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t KeyHandle_holder[sizeof(PVOID)];
	PHANDLE KeyHandle_used = (PHANDLE)&KeyHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;
	HANDLE TransactionHandle_used = Handle32ToHandle((const void* __ptr32)x32based_TransactionHandle);

	// Convert parameters from x32 to x64
	if (x32based_KeyHandle == NULL) {
		KeyHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 5, KeyHandle_used, DesiredAccess_used, ObjectAttributes_used, OpenOptions_used, TransactionHandle_used); // NtOpenKeyTransactedEx

	if (KeyHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)KeyHandle_used, x32based_KeyHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtDeleteKey(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_KeyHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE KeyHandle_used = Handle32ToHandle((const void* __ptr32)x32based_KeyHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, KeyHandle_used); // NtDeleteKey

	return ret_value;
}


NTSTATUS WINAPI _w32_NtRenameKey(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_KeyHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_NewName = (uint32_t)(x32based_args[3]); // PUNICODE_STRING  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE KeyHandle_used = Handle32ToHandle((const void* __ptr32)x32based_KeyHandle);
	uint8_t NewName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING NewName_used = (PUNICODE_STRING)&NewName_holder;

	// Convert parameters from x32 to x64
	if (x32based_NewName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&NewName_used, x32based_NewName);
	}
	else {
		NewName_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 2, KeyHandle_used, NewName_used); // NtRenameKey

	return ret_value;
}


NTSTATUS WINAPI _w32_NtDeleteValueKey(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_KeyHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_ValueName = (uint32_t)(x32based_args[3]); // PUNICODE_STRING  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE KeyHandle_used = Handle32ToHandle((const void* __ptr32)x32based_KeyHandle);
	uint8_t ValueName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING ValueName_used = (PUNICODE_STRING)&ValueName_holder;

	// Convert parameters from x32 to x64
	if (x32based_ValueName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&ValueName_used, x32based_ValueName);
	}
	else {
		ValueName_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 2, KeyHandle_used, ValueName_used); // NtDeleteValueKey

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryKey(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_KeyHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	KEY_INFORMATION_CLASS KeyInformationClass_used = (KEY_INFORMATION_CLASS)(x32based_args[3]); // KEY_INFORMATION_CLASS  IN 
	PVOID KeyInformation_used = (PVOID)(x32based_args[4]); // PVOID  OUT 
	ULONG Length_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	PULONG ResultLength_used = (PULONG)(x32based_args[6]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE KeyHandle_used = Handle32ToHandle((const void* __ptr32)x32based_KeyHandle);

	// Convert parameters from x32 to x64
	switch (KeyInformationClass_used) {
	default: {
		ret_value = __syscall64(syscall_idx, 5, KeyHandle_used, KeyInformationClass_used, KeyInformation_used, Length_used, ResultLength_used); // NtQueryKey
		break;
	}
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetInformationKey(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_KeyHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	KEY_SET_INFORMATION_CLASS KeySetInformationClass_used = (KEY_SET_INFORMATION_CLASS)(x32based_args[3]); // KEY_SET_INFORMATION_CLASS  IN 
	PVOID KeySetInformation_used = (PVOID)(x32based_args[4]); // PVOID  IN 
	ULONG KeySetInformationLength_used = (ULONG)(x32based_args[5]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE KeyHandle_used = Handle32ToHandle((const void* __ptr32)x32based_KeyHandle);

	// Convert parameters from x32 to x64
	switch (KeySetInformationClass_used) {
	default: {
		ret_value = __syscall64(syscall_idx, 4, KeyHandle_used, KeySetInformationClass_used, KeySetInformation_used, KeySetInformationLength_used); // NtSetInformationKey
		break;
	}
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryValueKey(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_KeyHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_ValueName = (uint32_t)(x32based_args[3]); // PUNICODE_STRING  IN 
	KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass_used = (KEY_VALUE_INFORMATION_CLASS)(x32based_args[4]); // KEY_VALUE_INFORMATION_CLASS  IN 
	PVOID KeyValueInformation_used = (PVOID)(x32based_args[5]); // PVOID  OUT 
	ULONG Length_used = (ULONG)(x32based_args[6]); // ULONG  IN 
	PULONG ResultLength_used = (PULONG)(x32based_args[7]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE KeyHandle_used = Handle32ToHandle((const void* __ptr32)x32based_KeyHandle);
	uint8_t ValueName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING ValueName_used = (PUNICODE_STRING)&ValueName_holder;

	// Convert parameters from x32 to x64
	if (x32based_ValueName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&ValueName_used, x32based_ValueName);
	}
	else {
		ValueName_used = 0;
	}

	switch (KeyValueInformationClass_used) {
	default: {
		ret_value = __syscall64(syscall_idx, 6, KeyHandle_used, ValueName_used, KeyValueInformationClass_used, KeyValueInformation_used, Length_used, ResultLength_used); // NtQueryValueKey
		break;
	}
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetValueKey(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_KeyHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_ValueName = (uint32_t)(x32based_args[3]); // PUNICODE_STRING  IN 
	ULONG TitleIndex_used = (ULONG)(x32based_args[4]); // ULONG  IN 
	ULONG Type_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	PVOID Data_used = (PVOID)(x32based_args[6]); // PVOID  IN 
	ULONG DataSize_used = (ULONG)(x32based_args[7]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE KeyHandle_used = Handle32ToHandle((const void* __ptr32)x32based_KeyHandle);
	uint8_t ValueName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING ValueName_used = (PUNICODE_STRING)&ValueName_holder;

	// Convert parameters from x32 to x64
	if (x32based_ValueName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&ValueName_used, x32based_ValueName);
	}
	else {
		ValueName_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 6, KeyHandle_used, ValueName_used, TitleIndex_used, Type_used, Data_used, DataSize_used); // NtSetValueKey

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryMultipleValueKey(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_KeyHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_ValueEntries = (uint32_t)(x32based_args[3]); // PKEY_VALUE_ENTRY  IN  OUT 
	ULONG EntryCount_used = (ULONG)(x32based_args[4]); // ULONG  IN 
	PVOID ValueBuffer_used = (PVOID)(x32based_args[5]); // PVOID  OUT 
	PULONG BufferLength_used = (PULONG)(x32based_args[6]); // PULONG  IN  OUT 
	PULONG RequiredBufferLength_used = (PULONG)(x32based_args[7]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE KeyHandle_used = Handle32ToHandle((const void* __ptr32)x32based_KeyHandle);
	uint8_t ValueEntries_holder[sizeof(_KEY_VALUE_ENTRY)];
	PKEY_VALUE_ENTRY ValueEntries_used = (PKEY_VALUE_ENTRY)&ValueEntries_holder;

	// Convert parameters from x32 to x64
	if (x32based_ValueEntries != NULL) {
		convert__KEY_VALUE_ENTRY_32TO64(ctx, (_KEY_VALUE_ENTRY**)&ValueEntries_used, x32based_ValueEntries);
	}
	else {
		ValueEntries_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 6, KeyHandle_used, ValueEntries_used, EntryCount_used, ValueBuffer_used, BufferLength_used, RequiredBufferLength_used); // NtQueryMultipleValueKey

	if (ValueEntries_used != NULL) {
		convert__KEY_VALUE_ENTRY_64TO32(ctx, (_KEY_VALUE_ENTRY*)ValueEntries_used, x32based_ValueEntries);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtEnumerateKey(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_KeyHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	ULONG Index_used = (ULONG)(x32based_args[3]); // ULONG  IN 
	KEY_INFORMATION_CLASS KeyInformationClass_used = (KEY_INFORMATION_CLASS)(x32based_args[4]); // KEY_INFORMATION_CLASS  IN 
	PVOID KeyInformation_used = (PVOID)(x32based_args[5]); // PVOID  OUT 
	ULONG Length_used = (ULONG)(x32based_args[6]); // ULONG  IN 
	PULONG ResultLength_used = (PULONG)(x32based_args[7]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE KeyHandle_used = Handle32ToHandle((const void* __ptr32)x32based_KeyHandle);

	// Convert parameters from x32 to x64
	switch (KeyInformationClass_used) {
	default: {
		ret_value = __syscall64(syscall_idx, 6, KeyHandle_used, Index_used, KeyInformationClass_used, KeyInformation_used, Length_used, ResultLength_used); // NtEnumerateKey
		break;
	}
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtEnumerateValueKey(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_KeyHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	ULONG Index_used = (ULONG)(x32based_args[3]); // ULONG  IN 
	KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass_used = (KEY_VALUE_INFORMATION_CLASS)(x32based_args[4]); // KEY_VALUE_INFORMATION_CLASS  IN 
	PVOID KeyValueInformation_used = (PVOID)(x32based_args[5]); // PVOID  OUT 
	ULONG Length_used = (ULONG)(x32based_args[6]); // ULONG  IN 
	PULONG ResultLength_used = (PULONG)(x32based_args[7]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE KeyHandle_used = Handle32ToHandle((const void* __ptr32)x32based_KeyHandle);

	// Convert parameters from x32 to x64
	switch (KeyValueInformationClass_used) {
	default: {
		ret_value = __syscall64(syscall_idx, 6, KeyHandle_used, Index_used, KeyValueInformationClass_used, KeyValueInformation_used, Length_used, ResultLength_used); // NtEnumerateValueKey
		break;
	}
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtFlushKey(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_KeyHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE KeyHandle_used = Handle32ToHandle((const void* __ptr32)x32based_KeyHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, KeyHandle_used); // NtFlushKey

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCompactKeys(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	ULONG Count_used = (ULONG)(x32based_args[2]); // ULONG  IN 
	uint32_t x32based_KeyArray = (uint32_t)(x32based_args[3]); // HANDLE *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t KeyArray_holder[sizeof(PVOID)];
	HANDLE* KeyArray_used = (HANDLE*)&KeyArray_holder;

	// Convert parameters from x32 to x64
	if (x32based_KeyArray != NULL) {
		convert_HANDLE_32TO64(ctx, (HANDLE**)&KeyArray_used, x32based_KeyArray);
	}
	else {
		KeyArray_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 2, Count_used, KeyArray_used); // NtCompactKeys

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCompressKey(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_Key = (uint32_t)(x32based_args[2]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE Key_used = Handle32ToHandle((const void* __ptr32)x32based_Key);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, Key_used); // NtCompressKey

	return ret_value;
}


NTSTATUS WINAPI _w32_NtLoadKey(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TargetKey = (uint32_t)(x32based_args[2]); // POBJECT_ATTRIBUTES  IN 
	uint32_t x32based_SourceFile = (uint32_t)(x32based_args[3]); // POBJECT_ATTRIBUTES  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t TargetKey_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES TargetKey_used = (POBJECT_ATTRIBUTES)&TargetKey_holder;
	uint8_t SourceFile_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES SourceFile_used = (POBJECT_ATTRIBUTES)&SourceFile_holder;

	// Convert parameters from x32 to x64
	if (x32based_TargetKey != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&TargetKey_used, x32based_TargetKey);
	}
	else {
		TargetKey_used = 0;
	}
	if (x32based_SourceFile != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&SourceFile_used, x32based_SourceFile);
	}
	else {
		SourceFile_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 2, TargetKey_used, SourceFile_used); // NtLoadKey

	return ret_value;
}


NTSTATUS WINAPI _w32_NtLoadKey2(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TargetKey = (uint32_t)(x32based_args[2]); // POBJECT_ATTRIBUTES  IN 
	uint32_t x32based_SourceFile = (uint32_t)(x32based_args[3]); // POBJECT_ATTRIBUTES  IN 
	ULONG Flags_used = (ULONG)(x32based_args[4]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t TargetKey_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES TargetKey_used = (POBJECT_ATTRIBUTES)&TargetKey_holder;
	uint8_t SourceFile_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES SourceFile_used = (POBJECT_ATTRIBUTES)&SourceFile_holder;

	// Convert parameters from x32 to x64
	if (x32based_TargetKey != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&TargetKey_used, x32based_TargetKey);
	}
	else {
		TargetKey_used = 0;
	}
	if (x32based_SourceFile != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&SourceFile_used, x32based_SourceFile);
	}
	else {
		SourceFile_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, TargetKey_used, SourceFile_used, Flags_used); // NtLoadKey2

	return ret_value;
}


NTSTATUS WINAPI _w32_NtLoadKeyEx(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TargetKey = (uint32_t)(x32based_args[2]); // POBJECT_ATTRIBUTES  IN 
	uint32_t x32based_SourceFile = (uint32_t)(x32based_args[3]); // POBJECT_ATTRIBUTES  IN 
	ULONG Flags_used = (ULONG)(x32based_args[4]); // ULONG  IN 
	uint32_t x32based_TrustClassKey = (uint32_t)(x32based_args[5]); // HANDLE  IN 
	uint32_t x32based_Event = (uint32_t)(x32based_args[6]); // HANDLE  IN 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[7]); // ACCESS_MASK  IN 
	uint32_t x32based_RootHandle = (uint32_t)(x32based_args[8]); // PHANDLE  OUT 
	uint32_t x32based_IoStatus = (uint32_t)(x32based_args[9]); // PIO_STATUS_BLOCK  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t TargetKey_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES TargetKey_used = (POBJECT_ATTRIBUTES)&TargetKey_holder;
	uint8_t SourceFile_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES SourceFile_used = (POBJECT_ATTRIBUTES)&SourceFile_holder;
	HANDLE TrustClassKey_used = Handle32ToHandle((const void* __ptr32)x32based_TrustClassKey);
	HANDLE Event_used = Handle32ToHandle((const void* __ptr32)x32based_Event);
	uint8_t RootHandle_holder[sizeof(PVOID)];
	PHANDLE RootHandle_used = (PHANDLE)&RootHandle_holder;
	uint8_t IoStatus_holder[sizeof(_IO_STATUS_BLOCK)];
	PIO_STATUS_BLOCK IoStatus_used = (PIO_STATUS_BLOCK)&IoStatus_holder;

	// Convert parameters from x32 to x64
	if (x32based_TargetKey != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&TargetKey_used, x32based_TargetKey);
	}
	else {
		TargetKey_used = 0;
	}
	if (x32based_SourceFile != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&SourceFile_used, x32based_SourceFile);
	}
	else {
		SourceFile_used = 0;
	}
	if (x32based_RootHandle == NULL) {
		RootHandle_used = 0;
	}
	if (x32based_IoStatus == NULL) {
		IoStatus_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 8, TargetKey_used, SourceFile_used, Flags_used, TrustClassKey_used, Event_used, DesiredAccess_used, RootHandle_used, IoStatus_used); // NtLoadKeyEx

	if (RootHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)RootHandle_used, x32based_RootHandle);
	}
	if (IoStatus_used != NULL) {
		convert__IO_STATUS_BLOCK_64TO32(ctx, (_IO_STATUS_BLOCK*)IoStatus_used, x32based_IoStatus);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtReplaceKey(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_NewFile = (uint32_t)(x32based_args[2]); // POBJECT_ATTRIBUTES  IN 
	uint32_t x32based_TargetHandle = (uint32_t)(x32based_args[3]); // HANDLE  IN 
	uint32_t x32based_OldFile = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t NewFile_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES NewFile_used = (POBJECT_ATTRIBUTES)&NewFile_holder;
	HANDLE TargetHandle_used = Handle32ToHandle((const void* __ptr32)x32based_TargetHandle);
	uint8_t OldFile_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES OldFile_used = (POBJECT_ATTRIBUTES)&OldFile_holder;

	// Convert parameters from x32 to x64
	if (x32based_NewFile != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&NewFile_used, x32based_NewFile);
	}
	else {
		NewFile_used = 0;
	}
	if (x32based_OldFile != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&OldFile_used, x32based_OldFile);
	}
	else {
		OldFile_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, NewFile_used, TargetHandle_used, OldFile_used); // NtReplaceKey

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSaveKey(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_KeyHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_FileHandle = (uint32_t)(x32based_args[3]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE KeyHandle_used = Handle32ToHandle((const void* __ptr32)x32based_KeyHandle);
	HANDLE FileHandle_used = Handle32ToHandle((const void* __ptr32)x32based_FileHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, KeyHandle_used, FileHandle_used); // NtSaveKey

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSaveKeyEx(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_KeyHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_FileHandle = (uint32_t)(x32based_args[3]); // HANDLE  IN 
	ULONG Format_used = (ULONG)(x32based_args[4]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE KeyHandle_used = Handle32ToHandle((const void* __ptr32)x32based_KeyHandle);
	HANDLE FileHandle_used = Handle32ToHandle((const void* __ptr32)x32based_FileHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 3, KeyHandle_used, FileHandle_used, Format_used); // NtSaveKeyEx

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSaveMergedKeys(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_HighPrecedenceKeyHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_LowPrecedenceKeyHandle = (uint32_t)(x32based_args[3]); // HANDLE  IN 
	uint32_t x32based_FileHandle = (uint32_t)(x32based_args[4]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE HighPrecedenceKeyHandle_used = Handle32ToHandle((const void* __ptr32)x32based_HighPrecedenceKeyHandle);
	HANDLE LowPrecedenceKeyHandle_used = Handle32ToHandle((const void* __ptr32)x32based_LowPrecedenceKeyHandle);
	HANDLE FileHandle_used = Handle32ToHandle((const void* __ptr32)x32based_FileHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 3, HighPrecedenceKeyHandle_used, LowPrecedenceKeyHandle_used, FileHandle_used); // NtSaveMergedKeys

	return ret_value;
}


NTSTATUS WINAPI _w32_NtRestoreKey(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_KeyHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_FileHandle = (uint32_t)(x32based_args[3]); // HANDLE  IN 
	ULONG Flags_used = (ULONG)(x32based_args[4]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE KeyHandle_used = Handle32ToHandle((const void* __ptr32)x32based_KeyHandle);
	HANDLE FileHandle_used = Handle32ToHandle((const void* __ptr32)x32based_FileHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 3, KeyHandle_used, FileHandle_used, Flags_used); // NtRestoreKey

	return ret_value;
}


NTSTATUS WINAPI _w32_NtUnloadKey(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TargetKey = (uint32_t)(x32based_args[2]); // POBJECT_ATTRIBUTES  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t TargetKey_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES TargetKey_used = (POBJECT_ATTRIBUTES)&TargetKey_holder;

	// Convert parameters from x32 to x64
	if (x32based_TargetKey != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&TargetKey_used, x32based_TargetKey);
	}
	else {
		TargetKey_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 1, TargetKey_used); // NtUnloadKey

	return ret_value;
}


NTSTATUS WINAPI _w32_NtUnloadKey2(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TargetKey = (uint32_t)(x32based_args[2]); // POBJECT_ATTRIBUTES  IN 
	ULONG Flags_used = (ULONG)(x32based_args[3]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t TargetKey_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES TargetKey_used = (POBJECT_ATTRIBUTES)&TargetKey_holder;

	// Convert parameters from x32 to x64
	if (x32based_TargetKey != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&TargetKey_used, x32based_TargetKey);
	}
	else {
		TargetKey_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 2, TargetKey_used, Flags_used); // NtUnloadKey2

	return ret_value;
}


NTSTATUS WINAPI _w32_NtUnloadKeyEx(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TargetKey = (uint32_t)(x32based_args[2]); // POBJECT_ATTRIBUTES  IN 
	uint32_t x32based_Event = (uint32_t)(x32based_args[3]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t TargetKey_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES TargetKey_used = (POBJECT_ATTRIBUTES)&TargetKey_holder;
	HANDLE Event_used = Handle32ToHandle((const void* __ptr32)x32based_Event);

	// Convert parameters from x32 to x64
	if (x32based_TargetKey != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&TargetKey_used, x32based_TargetKey);
	}
	else {
		TargetKey_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 2, TargetKey_used, Event_used); // NtUnloadKeyEx

	return ret_value;
}


NTSTATUS WINAPI _w32_NtNotifyChangeKey(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_KeyHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_Event = (uint32_t)(x32based_args[3]); // HANDLE  IN 
	PIO_APC_ROUTINE ApcRoutine_used = (PIO_APC_ROUTINE)(x32based_args[4]); // PIO_APC_ROUTINE  IN 
	PVOID ApcContext_used = (PVOID)(x32based_args[5]); // PVOID  IN 
	uint32_t x32based_IoStatusBlock = (uint32_t)(x32based_args[6]); // PIO_STATUS_BLOCK  OUT 
	ULONG CompletionFilter_used = (ULONG)(x32based_args[7]); // ULONG  IN 
	BOOLEAN WatchTree_used = (BOOLEAN)(x32based_args[8]); // BOOLEAN  IN 
	PVOID Buffer_used = (PVOID)(x32based_args[9]); // PVOID  OUT 
	ULONG BufferSize_used = (ULONG)(x32based_args[10]); // ULONG  IN 
	BOOLEAN Asynchronous_used = (BOOLEAN)(x32based_args[11]); // BOOLEAN  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE KeyHandle_used = Handle32ToHandle((const void* __ptr32)x32based_KeyHandle);
	HANDLE Event_used = Handle32ToHandle((const void* __ptr32)x32based_Event);
	uint8_t IoStatusBlock_holder[sizeof(_IO_STATUS_BLOCK)];
	PIO_STATUS_BLOCK IoStatusBlock_used = (PIO_STATUS_BLOCK)&IoStatusBlock_holder;

	// Convert parameters from x32 to x64
	if (x32based_IoStatusBlock == NULL) {
		IoStatusBlock_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 10, KeyHandle_used, Event_used, ApcRoutine_used, ApcContext_used, IoStatusBlock_used, CompletionFilter_used, WatchTree_used, Buffer_used, BufferSize_used, Asynchronous_used); // NtNotifyChangeKey

	if (IoStatusBlock_used != NULL) {
		convert__IO_STATUS_BLOCK_64TO32(ctx, (_IO_STATUS_BLOCK*)IoStatusBlock_used, x32based_IoStatusBlock);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtNotifyChangeMultipleKeys(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_MasterKeyHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	ULONG Count_used = (ULONG)(x32based_args[3]); // ULONG  IN 
	uint32_t x32based_SubordinateObjects = (uint32_t)(x32based_args[4]); // OBJECT_ATTRIBUTES *  IN 
	uint32_t x32based_Event = (uint32_t)(x32based_args[5]); // HANDLE  IN 
	PIO_APC_ROUTINE ApcRoutine_used = (PIO_APC_ROUTINE)(x32based_args[6]); // PIO_APC_ROUTINE  IN 
	PVOID ApcContext_used = (PVOID)(x32based_args[7]); // PVOID  IN 
	uint32_t x32based_IoStatusBlock = (uint32_t)(x32based_args[8]); // PIO_STATUS_BLOCK  OUT 
	ULONG CompletionFilter_used = (ULONG)(x32based_args[9]); // ULONG  IN 
	BOOLEAN WatchTree_used = (BOOLEAN)(x32based_args[10]); // BOOLEAN  IN 
	PVOID Buffer_used = (PVOID)(x32based_args[11]); // PVOID  OUT 
	ULONG BufferSize_used = (ULONG)(x32based_args[12]); // ULONG  IN 
	BOOLEAN Asynchronous_used = (BOOLEAN)(x32based_args[13]); // BOOLEAN  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE MasterKeyHandle_used = Handle32ToHandle((const void* __ptr32)x32based_MasterKeyHandle);
	uint8_t SubordinateObjects_holder[sizeof(_OBJECT_ATTRIBUTES)];
	OBJECT_ATTRIBUTES* SubordinateObjects_used = (OBJECT_ATTRIBUTES*)&SubordinateObjects_holder;
	HANDLE Event_used = Handle32ToHandle((const void* __ptr32)x32based_Event);
	uint8_t IoStatusBlock_holder[sizeof(_IO_STATUS_BLOCK)];
	PIO_STATUS_BLOCK IoStatusBlock_used = (PIO_STATUS_BLOCK)&IoStatusBlock_holder;

	// Convert parameters from x32 to x64
	if (x32based_SubordinateObjects != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&SubordinateObjects_used, x32based_SubordinateObjects);
	}
	else {
		SubordinateObjects_used = 0;
	}
	if (x32based_IoStatusBlock == NULL) {
		IoStatusBlock_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 12, MasterKeyHandle_used, Count_used, SubordinateObjects_used, Event_used, ApcRoutine_used, ApcContext_used, IoStatusBlock_used, CompletionFilter_used, WatchTree_used, Buffer_used, BufferSize_used, Asynchronous_used); // NtNotifyChangeMultipleKeys

	if (IoStatusBlock_used != NULL) {
		convert__IO_STATUS_BLOCK_64TO32(ctx, (_IO_STATUS_BLOCK*)IoStatusBlock_used, x32based_IoStatusBlock);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryOpenSubKeys(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TargetKey = (uint32_t)(x32based_args[2]); // POBJECT_ATTRIBUTES  IN 
	PULONG HandleCount_used = (PULONG)(x32based_args[3]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t TargetKey_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES TargetKey_used = (POBJECT_ATTRIBUTES)&TargetKey_holder;

	// Convert parameters from x32 to x64
	if (x32based_TargetKey != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&TargetKey_used, x32based_TargetKey);
	}
	else {
		TargetKey_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 2, TargetKey_used, HandleCount_used); // NtQueryOpenSubKeys

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryOpenSubKeysEx(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TargetKey = (uint32_t)(x32based_args[2]); // POBJECT_ATTRIBUTES  IN 
	ULONG BufferLength_used = (ULONG)(x32based_args[3]); // ULONG  IN 
	PVOID Buffer_used = (PVOID)(x32based_args[4]); // PVOID  OUT 
	PULONG RequiredSize_used = (PULONG)(x32based_args[5]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t TargetKey_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES TargetKey_used = (POBJECT_ATTRIBUTES)&TargetKey_holder;

	// Convert parameters from x32 to x64
	if (x32based_TargetKey != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&TargetKey_used, x32based_TargetKey);
	}
	else {
		TargetKey_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, TargetKey_used, BufferLength_used, Buffer_used, RequiredSize_used); // NtQueryOpenSubKeysEx

	return ret_value;
}


NTSTATUS WINAPI _w32_NtInitializeRegistry(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	USHORT BootCondition_used = (USHORT)(x32based_args[2]); // USHORT  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, BootCondition_used); // NtInitializeRegistry

	return ret_value;
}


NTSTATUS WINAPI _w32_NtLockRegistryKey(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_KeyHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE KeyHandle_used = Handle32ToHandle((const void* __ptr32)x32based_KeyHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, KeyHandle_used); // NtLockRegistryKey

	return ret_value;
}


NTSTATUS WINAPI _w32_NtLockProductActivationKeys(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	ULONG* pPrivateVer_used = (ULONG*)(x32based_args[2]); // ULONG *  IN  OUT 
	ULONG* pSafeMode_used = (ULONG*)(x32based_args[3]); // ULONG *  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, pPrivateVer_used, pSafeMode_used); // NtLockProductActivationKeys

	return ret_value;
}


NTSTATUS WINAPI _w32_NtFreezeRegistry(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	ULONG TimeOutInSeconds_used = (ULONG)(x32based_args[2]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, TimeOutInSeconds_used); // NtFreezeRegistry

	return ret_value;
}


NTSTATUS WINAPI _w32_NtThawRegistry(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 0); // NtThawRegistry

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateToken(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TokenHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	TOKEN_TYPE TokenType_used = (TOKEN_TYPE)(x32based_args[5]); // TOKEN_TYPE  IN 
	PLUID AuthenticationId_used = (PLUID)(x32based_args[6]); // PLUID  IN 
	PLARGE_INTEGER ExpirationTime_used = (PLARGE_INTEGER)(x32based_args[7]); // PLARGE_INTEGER  IN 
	uint32_t x32based_User = (uint32_t)(x32based_args[8]); // PTOKEN_USER  IN 
	uint32_t x32based_Groups = (uint32_t)(x32based_args[9]); // PTOKEN_GROUPS  IN 
	PTOKEN_PRIVILEGES Privileges_used = (PTOKEN_PRIVILEGES)(x32based_args[10]); // PTOKEN_PRIVILEGES  IN 
	uint32_t x32based_Owner = (uint32_t)(x32based_args[11]); // PTOKEN_OWNER  IN 
	uint32_t x32based_PrimaryGroup = (uint32_t)(x32based_args[12]); // PTOKEN_PRIMARY_GROUP  IN 
	uint32_t x32based_DefaultDacl = (uint32_t)(x32based_args[13]); // PTOKEN_DEFAULT_DACL  IN 
	PTOKEN_SOURCE TokenSource_used = (PTOKEN_SOURCE)(x32based_args[14]); // PTOKEN_SOURCE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t TokenHandle_holder[sizeof(PVOID)];
	PHANDLE TokenHandle_used = (PHANDLE)&TokenHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;
	uint8_t User_holder[sizeof(_TOKEN_USER)];
	PTOKEN_USER User_used = (PTOKEN_USER)&User_holder;
	uint8_t Groups_holder[sizeof(_TOKEN_GROUPS)];
	PTOKEN_GROUPS Groups_used = (PTOKEN_GROUPS)&Groups_holder;
	uint8_t Owner_holder[sizeof(_TOKEN_OWNER)];
	PTOKEN_OWNER Owner_used = (PTOKEN_OWNER)&Owner_holder;
	uint8_t PrimaryGroup_holder[sizeof(_TOKEN_PRIMARY_GROUP)];
	PTOKEN_PRIMARY_GROUP PrimaryGroup_used = (PTOKEN_PRIMARY_GROUP)&PrimaryGroup_holder;
	uint8_t DefaultDacl_holder[sizeof(_TOKEN_DEFAULT_DACL)];
	PTOKEN_DEFAULT_DACL DefaultDacl_used = (PTOKEN_DEFAULT_DACL)&DefaultDacl_holder;

	// Convert parameters from x32 to x64
	if (x32based_TokenHandle == NULL) {
		TokenHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}
	if (x32based_User != NULL) {
		convert__TOKEN_USER_32TO64(ctx, (_TOKEN_USER**)&User_used, x32based_User);
	}
	else {
		User_used = 0;
	}
	if (x32based_Groups != NULL) {
		convert__TOKEN_GROUPS_32TO64(ctx, (_TOKEN_GROUPS**)&Groups_used, x32based_Groups);
	}
	else {
		Groups_used = 0;
	}
	if (x32based_Owner != NULL) {
		convert__TOKEN_OWNER_32TO64(ctx, (_TOKEN_OWNER**)&Owner_used, x32based_Owner);
	}
	else {
		Owner_used = 0;
	}
	if (x32based_PrimaryGroup != NULL) {
		convert__TOKEN_PRIMARY_GROUP_32TO64(ctx, (_TOKEN_PRIMARY_GROUP**)&PrimaryGroup_used, x32based_PrimaryGroup);
	}
	else {
		PrimaryGroup_used = 0;
	}
	if (x32based_DefaultDacl != NULL) {
		convert__TOKEN_DEFAULT_DACL_32TO64(ctx, (_TOKEN_DEFAULT_DACL**)&DefaultDacl_used, x32based_DefaultDacl);
	}
	else {
		DefaultDacl_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 13, TokenHandle_used, DesiredAccess_used, ObjectAttributes_used, TokenType_used, AuthenticationId_used, ExpirationTime_used, User_used, Groups_used, Privileges_used, Owner_used, PrimaryGroup_used, DefaultDacl_used, TokenSource_used); // NtCreateToken

	if (TokenHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)TokenHandle_used, x32based_TokenHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateLowBoxToken(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TokenHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	uint32_t x32based_ExistingTokenHandle = (uint32_t)(x32based_args[3]); // HANDLE  IN 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[4]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[5]); // POBJECT_ATTRIBUTES  IN 
	uint32_t x32based_PackageSid = (uint32_t)(x32based_args[6]); // PSID  IN 
	ULONG CapabilityCount_used = (ULONG)(x32based_args[7]); // ULONG  IN 
	uint32_t x32based_Capabilities = (uint32_t)(x32based_args[8]); // PSID_AND_ATTRIBUTES  IN 
	ULONG HandleCount_used = (ULONG)(x32based_args[9]); // ULONG  IN 
	uint32_t x32based_Handles = (uint32_t)(x32based_args[10]); // HANDLE *  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t TokenHandle_holder[sizeof(PVOID)];
	PHANDLE TokenHandle_used = (PHANDLE)&TokenHandle_holder;
	HANDLE ExistingTokenHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ExistingTokenHandle);
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;
	uint8_t PackageSid_holder[sizeof(PVOID)];
	PSID PackageSid_used = (PSID)&PackageSid_holder;
	uint8_t Capabilities_holder[sizeof(_SID_AND_ATTRIBUTES)];
	PSID_AND_ATTRIBUTES Capabilities_used = (PSID_AND_ATTRIBUTES)&Capabilities_holder;
	uint8_t Handles_holder[sizeof(PVOID)];
	HANDLE* Handles_used = (HANDLE*)&Handles_holder;

	// Convert parameters from x32 to x64
	if (x32based_TokenHandle == NULL) {
		TokenHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}
	if (x32based_PackageSid != NULL) {
		convert_HANDLE_32TO64(ctx, (HANDLE**)&PackageSid_used, x32based_PackageSid);
	}
	else {
		PackageSid_used = 0;
	}
	if (x32based_Capabilities != NULL) {
		convert__SID_AND_ATTRIBUTES_32TO64(ctx, (_SID_AND_ATTRIBUTES**)&Capabilities_used, x32based_Capabilities);
	}
	else {
		Capabilities_used = 0;
	}
	if (x32based_Handles != NULL) {
		convert_HANDLE_32TO64(ctx, (HANDLE**)&Handles_used, x32based_Handles);
	}
	else {
		Handles_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 9, TokenHandle_used, ExistingTokenHandle_used, DesiredAccess_used, ObjectAttributes_used, PackageSid_used, CapabilityCount_used, Capabilities_used, HandleCount_used, Handles_used); // NtCreateLowBoxToken

	if (TokenHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)TokenHandle_used, x32based_TokenHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateTokenEx(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TokenHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	TOKEN_TYPE TokenType_used = (TOKEN_TYPE)(x32based_args[5]); // TOKEN_TYPE  IN 
	PLUID AuthenticationId_used = (PLUID)(x32based_args[6]); // PLUID  IN 
	PLARGE_INTEGER ExpirationTime_used = (PLARGE_INTEGER)(x32based_args[7]); // PLARGE_INTEGER  IN 
	uint32_t x32based_User = (uint32_t)(x32based_args[8]); // PTOKEN_USER  IN 
	uint32_t x32based_Groups = (uint32_t)(x32based_args[9]); // PTOKEN_GROUPS  IN 
	PTOKEN_PRIVILEGES Privileges_used = (PTOKEN_PRIVILEGES)(x32based_args[10]); // PTOKEN_PRIVILEGES  IN 
	uint32_t x32based_UserAttributes = (uint32_t)(x32based_args[11]); // PTOKEN_SECURITY_ATTRIBUTES_INFORMATION  IN 
	uint32_t x32based_DeviceAttributes = (uint32_t)(x32based_args[12]); // PTOKEN_SECURITY_ATTRIBUTES_INFORMATION  IN 
	uint32_t x32based_DeviceGroups = (uint32_t)(x32based_args[13]); // PTOKEN_GROUPS  IN 
	PTOKEN_MANDATORY_POLICY TokenMandatoryPolicy_used = (PTOKEN_MANDATORY_POLICY)(x32based_args[14]); // PTOKEN_MANDATORY_POLICY  IN 
	uint32_t x32based_Owner = (uint32_t)(x32based_args[15]); // PTOKEN_OWNER  IN 
	uint32_t x32based_PrimaryGroup = (uint32_t)(x32based_args[16]); // PTOKEN_PRIMARY_GROUP  IN 
	uint32_t x32based_DefaultDacl = (uint32_t)(x32based_args[17]); // PTOKEN_DEFAULT_DACL  IN 
	PTOKEN_SOURCE TokenSource_used = (PTOKEN_SOURCE)(x32based_args[18]); // PTOKEN_SOURCE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t TokenHandle_holder[sizeof(PVOID)];
	PHANDLE TokenHandle_used = (PHANDLE)&TokenHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;
	uint8_t User_holder[sizeof(_TOKEN_USER)];
	PTOKEN_USER User_used = (PTOKEN_USER)&User_holder;
	uint8_t Groups_holder[sizeof(_TOKEN_GROUPS)];
	PTOKEN_GROUPS Groups_used = (PTOKEN_GROUPS)&Groups_holder;
	uint8_t UserAttributes_holder[sizeof(_TOKEN_SECURITY_ATTRIBUTES_INFORMATION)];
	PTOKEN_SECURITY_ATTRIBUTES_INFORMATION UserAttributes_used = (PTOKEN_SECURITY_ATTRIBUTES_INFORMATION)&UserAttributes_holder;
	uint8_t DeviceAttributes_holder[sizeof(_TOKEN_SECURITY_ATTRIBUTES_INFORMATION)];
	PTOKEN_SECURITY_ATTRIBUTES_INFORMATION DeviceAttributes_used = (PTOKEN_SECURITY_ATTRIBUTES_INFORMATION)&DeviceAttributes_holder;
	uint8_t DeviceGroups_holder[sizeof(_TOKEN_GROUPS)];
	PTOKEN_GROUPS DeviceGroups_used = (PTOKEN_GROUPS)&DeviceGroups_holder;
	uint8_t Owner_holder[sizeof(_TOKEN_OWNER)];
	PTOKEN_OWNER Owner_used = (PTOKEN_OWNER)&Owner_holder;
	uint8_t PrimaryGroup_holder[sizeof(_TOKEN_PRIMARY_GROUP)];
	PTOKEN_PRIMARY_GROUP PrimaryGroup_used = (PTOKEN_PRIMARY_GROUP)&PrimaryGroup_holder;
	uint8_t DefaultDacl_holder[sizeof(_TOKEN_DEFAULT_DACL)];
	PTOKEN_DEFAULT_DACL DefaultDacl_used = (PTOKEN_DEFAULT_DACL)&DefaultDacl_holder;

	// Convert parameters from x32 to x64
	if (x32based_TokenHandle == NULL) {
		TokenHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}
	if (x32based_User != NULL) {
		convert__TOKEN_USER_32TO64(ctx, (_TOKEN_USER**)&User_used, x32based_User);
	}
	else {
		User_used = 0;
	}
	if (x32based_Groups != NULL) {
		convert__TOKEN_GROUPS_32TO64(ctx, (_TOKEN_GROUPS**)&Groups_used, x32based_Groups);
	}
	else {
		Groups_used = 0;
	}
	if (x32based_UserAttributes != NULL) {
		convert__TOKEN_SECURITY_ATTRIBUTES_INFORMATION_32TO64(ctx, (_TOKEN_SECURITY_ATTRIBUTES_INFORMATION**)&UserAttributes_used, x32based_UserAttributes);
	}
	else {
		UserAttributes_used = 0;
	}
	if (x32based_DeviceAttributes != NULL) {
		convert__TOKEN_SECURITY_ATTRIBUTES_INFORMATION_32TO64(ctx, (_TOKEN_SECURITY_ATTRIBUTES_INFORMATION**)&DeviceAttributes_used, x32based_DeviceAttributes);
	}
	else {
		DeviceAttributes_used = 0;
	}
	if (x32based_DeviceGroups != NULL) {
		convert__TOKEN_GROUPS_32TO64(ctx, (_TOKEN_GROUPS**)&DeviceGroups_used, x32based_DeviceGroups);
	}
	else {
		DeviceGroups_used = 0;
	}
	if (x32based_Owner != NULL) {
		convert__TOKEN_OWNER_32TO64(ctx, (_TOKEN_OWNER**)&Owner_used, x32based_Owner);
	}
	else {
		Owner_used = 0;
	}
	if (x32based_PrimaryGroup != NULL) {
		convert__TOKEN_PRIMARY_GROUP_32TO64(ctx, (_TOKEN_PRIMARY_GROUP**)&PrimaryGroup_used, x32based_PrimaryGroup);
	}
	else {
		PrimaryGroup_used = 0;
	}
	if (x32based_DefaultDacl != NULL) {
		convert__TOKEN_DEFAULT_DACL_32TO64(ctx, (_TOKEN_DEFAULT_DACL**)&DefaultDacl_used, x32based_DefaultDacl);
	}
	else {
		DefaultDacl_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 17, TokenHandle_used, DesiredAccess_used, ObjectAttributes_used, TokenType_used, AuthenticationId_used, ExpirationTime_used, User_used, Groups_used, Privileges_used, UserAttributes_used, DeviceAttributes_used, DeviceGroups_used, TokenMandatoryPolicy_used, Owner_used, PrimaryGroup_used, DefaultDacl_used, TokenSource_used); // NtCreateTokenEx

	if (TokenHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)TokenHandle_used, x32based_TokenHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtOpenProcessToken(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_TokenHandle = (uint32_t)(x32based_args[4]); // PHANDLE  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);
	uint8_t TokenHandle_holder[sizeof(PVOID)];
	PHANDLE TokenHandle_used = (PHANDLE)&TokenHandle_holder;

	// Convert parameters from x32 to x64
	if (x32based_TokenHandle == NULL) {
		TokenHandle_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 3, ProcessHandle_used, DesiredAccess_used, TokenHandle_used); // NtOpenProcessToken

	if (TokenHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)TokenHandle_used, x32based_TokenHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtOpenProcessTokenEx(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	ULONG HandleAttributes_used = (ULONG)(x32based_args[4]); // ULONG  IN 
	uint32_t x32based_TokenHandle = (uint32_t)(x32based_args[5]); // PHANDLE  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);
	uint8_t TokenHandle_holder[sizeof(PVOID)];
	PHANDLE TokenHandle_used = (PHANDLE)&TokenHandle_holder;

	// Convert parameters from x32 to x64
	if (x32based_TokenHandle == NULL) {
		TokenHandle_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 4, ProcessHandle_used, DesiredAccess_used, HandleAttributes_used, TokenHandle_used); // NtOpenProcessTokenEx

	if (TokenHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)TokenHandle_used, x32based_TokenHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtOpenThreadToken(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ThreadHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	BOOLEAN OpenAsSelf_used = (BOOLEAN)(x32based_args[4]); // BOOLEAN  IN 
	uint32_t x32based_TokenHandle = (uint32_t)(x32based_args[5]); // PHANDLE  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ThreadHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ThreadHandle);
	uint8_t TokenHandle_holder[sizeof(PVOID)];
	PHANDLE TokenHandle_used = (PHANDLE)&TokenHandle_holder;

	// Convert parameters from x32 to x64
	if (x32based_TokenHandle == NULL) {
		TokenHandle_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 4, ThreadHandle_used, DesiredAccess_used, OpenAsSelf_used, TokenHandle_used); // NtOpenThreadToken

	if (TokenHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)TokenHandle_used, x32based_TokenHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtOpenThreadTokenEx(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ThreadHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	BOOLEAN OpenAsSelf_used = (BOOLEAN)(x32based_args[4]); // BOOLEAN  IN 
	ULONG HandleAttributes_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	uint32_t x32based_TokenHandle = (uint32_t)(x32based_args[6]); // PHANDLE  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ThreadHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ThreadHandle);
	uint8_t TokenHandle_holder[sizeof(PVOID)];
	PHANDLE TokenHandle_used = (PHANDLE)&TokenHandle_holder;

	// Convert parameters from x32 to x64
	if (x32based_TokenHandle == NULL) {
		TokenHandle_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 5, ThreadHandle_used, DesiredAccess_used, OpenAsSelf_used, HandleAttributes_used, TokenHandle_used); // NtOpenThreadTokenEx

	if (TokenHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)TokenHandle_used, x32based_TokenHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtDuplicateToken(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ExistingTokenHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	BOOLEAN EffectiveOnly_used = (BOOLEAN)(x32based_args[5]); // BOOLEAN  IN 
	TOKEN_TYPE TokenType_used = (TOKEN_TYPE)(x32based_args[6]); // TOKEN_TYPE  IN 
	uint32_t x32based_NewTokenHandle = (uint32_t)(x32based_args[7]); // PHANDLE  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ExistingTokenHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ExistingTokenHandle);
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;
	uint8_t NewTokenHandle_holder[sizeof(PVOID)];
	PHANDLE NewTokenHandle_used = (PHANDLE)&NewTokenHandle_holder;

	// Convert parameters from x32 to x64
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}
	if (x32based_NewTokenHandle == NULL) {
		NewTokenHandle_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 6, ExistingTokenHandle_used, DesiredAccess_used, ObjectAttributes_used, EffectiveOnly_used, TokenType_used, NewTokenHandle_used); // NtDuplicateToken

	if (NewTokenHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)NewTokenHandle_used, x32based_NewTokenHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryInformationToken(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TokenHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	TOKEN_INFORMATION_CLASS TokenInformationClass_used = (TOKEN_INFORMATION_CLASS)(x32based_args[3]); // TOKEN_INFORMATION_CLASS  IN 
	PVOID TokenInformation_used = (PVOID)(x32based_args[4]); // PVOID  IN  OUT 
	ULONG TokenInformationLength_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	PULONG ReturnLength_used = (PULONG)(x32based_args[6]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE TokenHandle_used = Handle32ToHandle((const void* __ptr32)x32based_TokenHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 5, TokenHandle_used, TokenInformationClass_used, TokenInformation_used, TokenInformationLength_used, ReturnLength_used); // NtQueryInformationToken

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetInformationToken(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TokenHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	TOKEN_INFORMATION_CLASS TokenInformationClass_used = (TOKEN_INFORMATION_CLASS)(x32based_args[3]); // TOKEN_INFORMATION_CLASS  IN 
	PVOID TokenInformation_used = (PVOID)(x32based_args[4]); // PVOID  IN 
	ULONG TokenInformationLength_used = (ULONG)(x32based_args[5]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE TokenHandle_used = Handle32ToHandle((const void* __ptr32)x32based_TokenHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 4, TokenHandle_used, TokenInformationClass_used, TokenInformation_used, TokenInformationLength_used); // NtSetInformationToken

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAdjustPrivilegesToken(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TokenHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	BOOLEAN DisableAllPrivileges_used = (BOOLEAN)(x32based_args[3]); // BOOLEAN  IN 
	PTOKEN_PRIVILEGES NewState_used = (PTOKEN_PRIVILEGES)(x32based_args[4]); // PTOKEN_PRIVILEGES  IN 
	ULONG BufferLength_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	PTOKEN_PRIVILEGES PreviousState_used = (PTOKEN_PRIVILEGES)(x32based_args[6]); // PTOKEN_PRIVILEGES  OUT 
	PULONG ReturnLength_used = (PULONG)(x32based_args[7]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE TokenHandle_used = Handle32ToHandle((const void* __ptr32)x32based_TokenHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 6, TokenHandle_used, DisableAllPrivileges_used, NewState_used, BufferLength_used, PreviousState_used, ReturnLength_used); // NtAdjustPrivilegesToken

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAdjustGroupsToken(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TokenHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	BOOLEAN ResetToDefault_used = (BOOLEAN)(x32based_args[3]); // BOOLEAN  IN 
	uint32_t x32based_NewState = (uint32_t)(x32based_args[4]); // PTOKEN_GROUPS  IN 
	ULONG BufferLength_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	uint32_t x32based_PreviousState = (uint32_t)(x32based_args[6]); // PTOKEN_GROUPS  OUT 
	PULONG ReturnLength_used = (PULONG)(x32based_args[7]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE TokenHandle_used = Handle32ToHandle((const void* __ptr32)x32based_TokenHandle);
	uint8_t NewState_holder[sizeof(_TOKEN_GROUPS)];
	PTOKEN_GROUPS NewState_used = (PTOKEN_GROUPS)&NewState_holder;
	uint8_t PreviousState_holder[sizeof(_TOKEN_GROUPS)];
	PTOKEN_GROUPS PreviousState_used = (PTOKEN_GROUPS)&PreviousState_holder;

	// Convert parameters from x32 to x64
	if (x32based_NewState != NULL) {
		convert__TOKEN_GROUPS_32TO64(ctx, (_TOKEN_GROUPS**)&NewState_used, x32based_NewState);
	}
	else {
		NewState_used = 0;
	}
	if (x32based_PreviousState == NULL) {
		PreviousState_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 6, TokenHandle_used, ResetToDefault_used, NewState_used, BufferLength_used, PreviousState_used, ReturnLength_used); // NtAdjustGroupsToken

	if (PreviousState_used != NULL) {
		convert__TOKEN_GROUPS_64TO32(ctx, (_TOKEN_GROUPS*)PreviousState_used, x32based_PreviousState);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAdjustTokenClaimsAndDeviceGroups(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TokenHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	BOOLEAN UserResetToDefault_used = (BOOLEAN)(x32based_args[3]); // BOOLEAN  IN 
	BOOLEAN DeviceResetToDefault_used = (BOOLEAN)(x32based_args[4]); // BOOLEAN  IN 
	BOOLEAN DeviceGroupsResetToDefault_used = (BOOLEAN)(x32based_args[5]); // BOOLEAN  IN 
	uint32_t x32based_NewUserState = (uint32_t)(x32based_args[6]); // PTOKEN_SECURITY_ATTRIBUTES_INFORMATION  IN 
	uint32_t x32based_NewDeviceState = (uint32_t)(x32based_args[7]); // PTOKEN_SECURITY_ATTRIBUTES_INFORMATION  IN 
	uint32_t x32based_NewDeviceGroupsState = (uint32_t)(x32based_args[8]); // PTOKEN_GROUPS  IN 
	ULONG UserBufferLength_used = (ULONG)(x32based_args[9]); // ULONG  IN 
	uint32_t x32based_PreviousUserState = (uint32_t)(x32based_args[10]); // PTOKEN_SECURITY_ATTRIBUTES_INFORMATION  OUT 
	ULONG DeviceBufferLength_used = (ULONG)(x32based_args[11]); // ULONG  IN 
	uint32_t x32based_PreviousDeviceState = (uint32_t)(x32based_args[12]); // PTOKEN_SECURITY_ATTRIBUTES_INFORMATION  OUT 
	ULONG DeviceGroupsBufferLength_used = (ULONG)(x32based_args[13]); // ULONG  IN 
	uint32_t x32based_PreviousDeviceGroups = (uint32_t)(x32based_args[14]); // PTOKEN_GROUPS  OUT 
	PULONG UserReturnLength_used = (PULONG)(x32based_args[15]); // PULONG  OUT 
	PULONG DeviceReturnLength_used = (PULONG)(x32based_args[16]); // PULONG  OUT 
	PULONG DeviceGroupsReturnBufferLength_used = (PULONG)(x32based_args[17]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE TokenHandle_used = Handle32ToHandle((const void* __ptr32)x32based_TokenHandle);
	uint8_t NewUserState_holder[sizeof(_TOKEN_SECURITY_ATTRIBUTES_INFORMATION)];
	PTOKEN_SECURITY_ATTRIBUTES_INFORMATION NewUserState_used = (PTOKEN_SECURITY_ATTRIBUTES_INFORMATION)&NewUserState_holder;
	uint8_t NewDeviceState_holder[sizeof(_TOKEN_SECURITY_ATTRIBUTES_INFORMATION)];
	PTOKEN_SECURITY_ATTRIBUTES_INFORMATION NewDeviceState_used = (PTOKEN_SECURITY_ATTRIBUTES_INFORMATION)&NewDeviceState_holder;
	uint8_t NewDeviceGroupsState_holder[sizeof(_TOKEN_GROUPS)];
	PTOKEN_GROUPS NewDeviceGroupsState_used = (PTOKEN_GROUPS)&NewDeviceGroupsState_holder;
	uint8_t PreviousUserState_holder[sizeof(_TOKEN_SECURITY_ATTRIBUTES_INFORMATION)];
	PTOKEN_SECURITY_ATTRIBUTES_INFORMATION PreviousUserState_used = (PTOKEN_SECURITY_ATTRIBUTES_INFORMATION)&PreviousUserState_holder;
	uint8_t PreviousDeviceState_holder[sizeof(_TOKEN_SECURITY_ATTRIBUTES_INFORMATION)];
	PTOKEN_SECURITY_ATTRIBUTES_INFORMATION PreviousDeviceState_used = (PTOKEN_SECURITY_ATTRIBUTES_INFORMATION)&PreviousDeviceState_holder;
	uint8_t PreviousDeviceGroups_holder[sizeof(_TOKEN_GROUPS)];
	PTOKEN_GROUPS PreviousDeviceGroups_used = (PTOKEN_GROUPS)&PreviousDeviceGroups_holder;

	// Convert parameters from x32 to x64
	if (x32based_NewUserState != NULL) {
		convert__TOKEN_SECURITY_ATTRIBUTES_INFORMATION_32TO64(ctx, (_TOKEN_SECURITY_ATTRIBUTES_INFORMATION**)&NewUserState_used, x32based_NewUserState);
	}
	else {
		NewUserState_used = 0;
	}
	if (x32based_NewDeviceState != NULL) {
		convert__TOKEN_SECURITY_ATTRIBUTES_INFORMATION_32TO64(ctx, (_TOKEN_SECURITY_ATTRIBUTES_INFORMATION**)&NewDeviceState_used, x32based_NewDeviceState);
	}
	else {
		NewDeviceState_used = 0;
	}
	if (x32based_NewDeviceGroupsState != NULL) {
		convert__TOKEN_GROUPS_32TO64(ctx, (_TOKEN_GROUPS**)&NewDeviceGroupsState_used, x32based_NewDeviceGroupsState);
	}
	else {
		NewDeviceGroupsState_used = 0;
	}
	if (x32based_PreviousUserState == NULL) {
		PreviousUserState_used = 0;
	}
	if (x32based_PreviousDeviceState == NULL) {
		PreviousDeviceState_used = 0;
	}
	if (x32based_PreviousDeviceGroups == NULL) {
		PreviousDeviceGroups_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 16, TokenHandle_used, UserResetToDefault_used, DeviceResetToDefault_used, DeviceGroupsResetToDefault_used, NewUserState_used, NewDeviceState_used, NewDeviceGroupsState_used, UserBufferLength_used, PreviousUserState_used, DeviceBufferLength_used, PreviousDeviceState_used, DeviceGroupsBufferLength_used, PreviousDeviceGroups_used, UserReturnLength_used, DeviceReturnLength_used, DeviceGroupsReturnBufferLength_used); // NtAdjustTokenClaimsAndDeviceGroups

	if (PreviousUserState_used != NULL) {
		convert__TOKEN_SECURITY_ATTRIBUTES_INFORMATION_64TO32(ctx, (_TOKEN_SECURITY_ATTRIBUTES_INFORMATION*)PreviousUserState_used, x32based_PreviousUserState);
	}
	if (PreviousDeviceState_used != NULL) {
		convert__TOKEN_SECURITY_ATTRIBUTES_INFORMATION_64TO32(ctx, (_TOKEN_SECURITY_ATTRIBUTES_INFORMATION*)PreviousDeviceState_used, x32based_PreviousDeviceState);
	}
	if (PreviousDeviceGroups_used != NULL) {
		convert__TOKEN_GROUPS_64TO32(ctx, (_TOKEN_GROUPS*)PreviousDeviceGroups_used, x32based_PreviousDeviceGroups);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtFilterToken(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ExistingTokenHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	ULONG Flags_used = (ULONG)(x32based_args[3]); // ULONG  IN 
	uint32_t x32based_SidsToDisable = (uint32_t)(x32based_args[4]); // PTOKEN_GROUPS  IN 
	PTOKEN_PRIVILEGES PrivilegesToDelete_used = (PTOKEN_PRIVILEGES)(x32based_args[5]); // PTOKEN_PRIVILEGES  IN 
	uint32_t x32based_RestrictedSids = (uint32_t)(x32based_args[6]); // PTOKEN_GROUPS  IN 
	uint32_t x32based_NewTokenHandle = (uint32_t)(x32based_args[7]); // PHANDLE  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ExistingTokenHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ExistingTokenHandle);
	uint8_t SidsToDisable_holder[sizeof(_TOKEN_GROUPS)];
	PTOKEN_GROUPS SidsToDisable_used = (PTOKEN_GROUPS)&SidsToDisable_holder;
	uint8_t RestrictedSids_holder[sizeof(_TOKEN_GROUPS)];
	PTOKEN_GROUPS RestrictedSids_used = (PTOKEN_GROUPS)&RestrictedSids_holder;
	uint8_t NewTokenHandle_holder[sizeof(PVOID)];
	PHANDLE NewTokenHandle_used = (PHANDLE)&NewTokenHandle_holder;

	// Convert parameters from x32 to x64
	if (x32based_SidsToDisable != NULL) {
		convert__TOKEN_GROUPS_32TO64(ctx, (_TOKEN_GROUPS**)&SidsToDisable_used, x32based_SidsToDisable);
	}
	else {
		SidsToDisable_used = 0;
	}
	if (x32based_RestrictedSids != NULL) {
		convert__TOKEN_GROUPS_32TO64(ctx, (_TOKEN_GROUPS**)&RestrictedSids_used, x32based_RestrictedSids);
	}
	else {
		RestrictedSids_used = 0;
	}
	if (x32based_NewTokenHandle == NULL) {
		NewTokenHandle_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 6, ExistingTokenHandle_used, Flags_used, SidsToDisable_used, PrivilegesToDelete_used, RestrictedSids_used, NewTokenHandle_used); // NtFilterToken

	if (NewTokenHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)NewTokenHandle_used, x32based_NewTokenHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtFilterTokenEx(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ExistingTokenHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	ULONG Flags_used = (ULONG)(x32based_args[3]); // ULONG  IN 
	uint32_t x32based_SidsToDisable = (uint32_t)(x32based_args[4]); // PTOKEN_GROUPS  IN 
	PTOKEN_PRIVILEGES PrivilegesToDelete_used = (PTOKEN_PRIVILEGES)(x32based_args[5]); // PTOKEN_PRIVILEGES  IN 
	uint32_t x32based_RestrictedSids = (uint32_t)(x32based_args[6]); // PTOKEN_GROUPS  IN 
	ULONG DisableUserClaimsCount_used = (ULONG)(x32based_args[7]); // ULONG  IN 
	uint32_t x32based_UserClaimsToDisable = (uint32_t)(x32based_args[8]); // PUNICODE_STRING  IN 
	ULONG DisableDeviceClaimsCount_used = (ULONG)(x32based_args[9]); // ULONG  IN 
	uint32_t x32based_DeviceClaimsToDisable = (uint32_t)(x32based_args[10]); // PUNICODE_STRING  IN 
	uint32_t x32based_DeviceGroupsToDisable = (uint32_t)(x32based_args[11]); // PTOKEN_GROUPS  IN 
	uint32_t x32based_RestrictedUserAttributes = (uint32_t)(x32based_args[12]); // PTOKEN_SECURITY_ATTRIBUTES_INFORMATION  IN 
	uint32_t x32based_RestrictedDeviceAttributes = (uint32_t)(x32based_args[13]); // PTOKEN_SECURITY_ATTRIBUTES_INFORMATION  IN 
	uint32_t x32based_RestrictedDeviceGroups = (uint32_t)(x32based_args[14]); // PTOKEN_GROUPS  IN 
	uint32_t x32based_NewTokenHandle = (uint32_t)(x32based_args[15]); // PHANDLE  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ExistingTokenHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ExistingTokenHandle);
	uint8_t SidsToDisable_holder[sizeof(_TOKEN_GROUPS)];
	PTOKEN_GROUPS SidsToDisable_used = (PTOKEN_GROUPS)&SidsToDisable_holder;
	uint8_t RestrictedSids_holder[sizeof(_TOKEN_GROUPS)];
	PTOKEN_GROUPS RestrictedSids_used = (PTOKEN_GROUPS)&RestrictedSids_holder;
	uint8_t UserClaimsToDisable_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING UserClaimsToDisable_used = (PUNICODE_STRING)&UserClaimsToDisable_holder;
	uint8_t DeviceClaimsToDisable_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING DeviceClaimsToDisable_used = (PUNICODE_STRING)&DeviceClaimsToDisable_holder;
	uint8_t DeviceGroupsToDisable_holder[sizeof(_TOKEN_GROUPS)];
	PTOKEN_GROUPS DeviceGroupsToDisable_used = (PTOKEN_GROUPS)&DeviceGroupsToDisable_holder;
	uint8_t RestrictedUserAttributes_holder[sizeof(_TOKEN_SECURITY_ATTRIBUTES_INFORMATION)];
	PTOKEN_SECURITY_ATTRIBUTES_INFORMATION RestrictedUserAttributes_used = (PTOKEN_SECURITY_ATTRIBUTES_INFORMATION)&RestrictedUserAttributes_holder;
	uint8_t RestrictedDeviceAttributes_holder[sizeof(_TOKEN_SECURITY_ATTRIBUTES_INFORMATION)];
	PTOKEN_SECURITY_ATTRIBUTES_INFORMATION RestrictedDeviceAttributes_used = (PTOKEN_SECURITY_ATTRIBUTES_INFORMATION)&RestrictedDeviceAttributes_holder;
	uint8_t RestrictedDeviceGroups_holder[sizeof(_TOKEN_GROUPS)];
	PTOKEN_GROUPS RestrictedDeviceGroups_used = (PTOKEN_GROUPS)&RestrictedDeviceGroups_holder;
	uint8_t NewTokenHandle_holder[sizeof(PVOID)];
	PHANDLE NewTokenHandle_used = (PHANDLE)&NewTokenHandle_holder;

	// Convert parameters from x32 to x64
	if (x32based_SidsToDisable != NULL) {
		convert__TOKEN_GROUPS_32TO64(ctx, (_TOKEN_GROUPS**)&SidsToDisable_used, x32based_SidsToDisable);
	}
	else {
		SidsToDisable_used = 0;
	}
	if (x32based_RestrictedSids != NULL) {
		convert__TOKEN_GROUPS_32TO64(ctx, (_TOKEN_GROUPS**)&RestrictedSids_used, x32based_RestrictedSids);
	}
	else {
		RestrictedSids_used = 0;
	}
	if (x32based_UserClaimsToDisable != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&UserClaimsToDisable_used, x32based_UserClaimsToDisable);
	}
	else {
		UserClaimsToDisable_used = 0;
	}
	if (x32based_DeviceClaimsToDisable != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&DeviceClaimsToDisable_used, x32based_DeviceClaimsToDisable);
	}
	else {
		DeviceClaimsToDisable_used = 0;
	}
	if (x32based_DeviceGroupsToDisable != NULL) {
		convert__TOKEN_GROUPS_32TO64(ctx, (_TOKEN_GROUPS**)&DeviceGroupsToDisable_used, x32based_DeviceGroupsToDisable);
	}
	else {
		DeviceGroupsToDisable_used = 0;
	}
	if (x32based_RestrictedUserAttributes != NULL) {
		convert__TOKEN_SECURITY_ATTRIBUTES_INFORMATION_32TO64(ctx, (_TOKEN_SECURITY_ATTRIBUTES_INFORMATION**)&RestrictedUserAttributes_used, x32based_RestrictedUserAttributes);
	}
	else {
		RestrictedUserAttributes_used = 0;
	}
	if (x32based_RestrictedDeviceAttributes != NULL) {
		convert__TOKEN_SECURITY_ATTRIBUTES_INFORMATION_32TO64(ctx, (_TOKEN_SECURITY_ATTRIBUTES_INFORMATION**)&RestrictedDeviceAttributes_used, x32based_RestrictedDeviceAttributes);
	}
	else {
		RestrictedDeviceAttributes_used = 0;
	}
	if (x32based_RestrictedDeviceGroups != NULL) {
		convert__TOKEN_GROUPS_32TO64(ctx, (_TOKEN_GROUPS**)&RestrictedDeviceGroups_used, x32based_RestrictedDeviceGroups);
	}
	else {
		RestrictedDeviceGroups_used = 0;
	}
	if (x32based_NewTokenHandle == NULL) {
		NewTokenHandle_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 14, ExistingTokenHandle_used, Flags_used, SidsToDisable_used, PrivilegesToDelete_used, RestrictedSids_used, DisableUserClaimsCount_used, UserClaimsToDisable_used, DisableDeviceClaimsCount_used, DeviceClaimsToDisable_used, DeviceGroupsToDisable_used, RestrictedUserAttributes_used, RestrictedDeviceAttributes_used, RestrictedDeviceGroups_used, NewTokenHandle_used); // NtFilterTokenEx

	if (NewTokenHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)NewTokenHandle_used, x32based_NewTokenHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCompareTokens(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_FirstTokenHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_SecondTokenHandle = (uint32_t)(x32based_args[3]); // HANDLE  IN 
	PBOOLEAN Equal_used = (PBOOLEAN)(x32based_args[4]); // PBOOLEAN  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE FirstTokenHandle_used = Handle32ToHandle((const void* __ptr32)x32based_FirstTokenHandle);
	HANDLE SecondTokenHandle_used = Handle32ToHandle((const void* __ptr32)x32based_SecondTokenHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 3, FirstTokenHandle_used, SecondTokenHandle_used, Equal_used); // NtCompareTokens

	return ret_value;
}


NTSTATUS WINAPI _w32_NtPrivilegeCheck(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ClientToken = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PPRIVILEGE_SET RequiredPrivileges_used = (PPRIVILEGE_SET)(x32based_args[3]); // PPRIVILEGE_SET  IN  OUT 
	PBOOLEAN Result_used = (PBOOLEAN)(x32based_args[4]); // PBOOLEAN  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ClientToken_used = Handle32ToHandle((const void* __ptr32)x32based_ClientToken);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 3, ClientToken_used, RequiredPrivileges_used, Result_used); // NtPrivilegeCheck

	return ret_value;
}


NTSTATUS WINAPI _w32_NtImpersonateAnonymousToken(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ThreadHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ThreadHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ThreadHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, ThreadHandle_used); // NtImpersonateAnonymousToken

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQuerySecurityAttributesToken(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TokenHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_Attributes = (uint32_t)(x32based_args[3]); // PUNICODE_STRING  IN 
	ULONG NumberOfAttributes_used = (ULONG)(x32based_args[4]); // ULONG  IN 
	PVOID Buffer_used = (PVOID)(x32based_args[5]); // PVOID  OUT 
	ULONG Length_used = (ULONG)(x32based_args[6]); // ULONG  IN 
	PULONG ReturnLength_used = (PULONG)(x32based_args[7]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE TokenHandle_used = Handle32ToHandle((const void* __ptr32)x32based_TokenHandle);
	uint8_t Attributes_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING Attributes_used = (PUNICODE_STRING)&Attributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_Attributes != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&Attributes_used, x32based_Attributes);
	}
	else {
		Attributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 6, TokenHandle_used, Attributes_used, NumberOfAttributes_used, Buffer_used, Length_used, ReturnLength_used); // NtQuerySecurityAttributesToken

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAccessCheck(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_SecurityDescriptor = (uint32_t)(x32based_args[2]); // PSECURITY_DESCRIPTOR  IN 
	uint32_t x32based_ClientToken = (uint32_t)(x32based_args[3]); // HANDLE  IN 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[4]); // ACCESS_MASK  IN 
	PGENERIC_MAPPING GenericMapping_used = (PGENERIC_MAPPING)(x32based_args[5]); // PGENERIC_MAPPING  IN 
	PPRIVILEGE_SET PrivilegeSet_used = (PPRIVILEGE_SET)(x32based_args[6]); // PPRIVILEGE_SET  OUT 
	PULONG PrivilegeSetLength_used = (PULONG)(x32based_args[7]); // PULONG  IN  OUT 
	PACCESS_MASK GrantedAccess_used = (PACCESS_MASK)(x32based_args[8]); // PACCESS_MASK  OUT 
	PNTSTATUS AccessStatus_used = (PNTSTATUS)(x32based_args[9]); // PNTSTATUS  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SecurityDescriptor_holder[sizeof(PVOID)];
	PSECURITY_DESCRIPTOR SecurityDescriptor_used = (PSECURITY_DESCRIPTOR)&SecurityDescriptor_holder;
	HANDLE ClientToken_used = Handle32ToHandle((const void* __ptr32)x32based_ClientToken);

	// Convert parameters from x32 to x64
	if (x32based_SecurityDescriptor != NULL) {
		convert_HANDLE_32TO64(ctx, (HANDLE**)&SecurityDescriptor_used, x32based_SecurityDescriptor);
	}
	else {
		SecurityDescriptor_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 8, SecurityDescriptor_used, ClientToken_used, DesiredAccess_used, GenericMapping_used, PrivilegeSet_used, PrivilegeSetLength_used, GrantedAccess_used, AccessStatus_used); // NtAccessCheck

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAccessCheckByType(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_SecurityDescriptor = (uint32_t)(x32based_args[2]); // PSECURITY_DESCRIPTOR  IN 
	uint32_t x32based_PrincipalSelfSid = (uint32_t)(x32based_args[3]); // PSID  IN 
	uint32_t x32based_ClientToken = (uint32_t)(x32based_args[4]); // HANDLE  IN 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[5]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectTypeList = (uint32_t)(x32based_args[6]); // POBJECT_TYPE_LIST  IN 
	ULONG ObjectTypeListLength_used = (ULONG)(x32based_args[7]); // ULONG  IN 
	PGENERIC_MAPPING GenericMapping_used = (PGENERIC_MAPPING)(x32based_args[8]); // PGENERIC_MAPPING  IN 
	PPRIVILEGE_SET PrivilegeSet_used = (PPRIVILEGE_SET)(x32based_args[9]); // PPRIVILEGE_SET  OUT 
	PULONG PrivilegeSetLength_used = (PULONG)(x32based_args[10]); // PULONG  IN  OUT 
	PACCESS_MASK GrantedAccess_used = (PACCESS_MASK)(x32based_args[11]); // PACCESS_MASK  OUT 
	PNTSTATUS AccessStatus_used = (PNTSTATUS)(x32based_args[12]); // PNTSTATUS  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SecurityDescriptor_holder[sizeof(PVOID)];
	PSECURITY_DESCRIPTOR SecurityDescriptor_used = (PSECURITY_DESCRIPTOR)&SecurityDescriptor_holder;
	uint8_t PrincipalSelfSid_holder[sizeof(PVOID)];
	PSID PrincipalSelfSid_used = (PSID)&PrincipalSelfSid_holder;
	HANDLE ClientToken_used = Handle32ToHandle((const void* __ptr32)x32based_ClientToken);
	uint8_t ObjectTypeList_holder[sizeof(_OBJECT_TYPE_LIST)];
	POBJECT_TYPE_LIST ObjectTypeList_used = (POBJECT_TYPE_LIST)&ObjectTypeList_holder;

	// Convert parameters from x32 to x64
	if (x32based_SecurityDescriptor != NULL) {
		convert_HANDLE_32TO64(ctx, (HANDLE**)&SecurityDescriptor_used, x32based_SecurityDescriptor);
	}
	else {
		SecurityDescriptor_used = 0;
	}
	if (x32based_PrincipalSelfSid != NULL) {
		convert_HANDLE_32TO64(ctx, (HANDLE**)&PrincipalSelfSid_used, x32based_PrincipalSelfSid);
	}
	else {
		PrincipalSelfSid_used = 0;
	}
	if (x32based_ObjectTypeList != NULL) {
		convert__OBJECT_TYPE_LIST_32TO64(ctx, (_OBJECT_TYPE_LIST**)&ObjectTypeList_used, x32based_ObjectTypeList);
	}
	else {
		ObjectTypeList_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 11, SecurityDescriptor_used, PrincipalSelfSid_used, ClientToken_used, DesiredAccess_used, ObjectTypeList_used, ObjectTypeListLength_used, GenericMapping_used, PrivilegeSet_used, PrivilegeSetLength_used, GrantedAccess_used, AccessStatus_used); // NtAccessCheckByType

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAccessCheckByTypeResultList(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_SecurityDescriptor = (uint32_t)(x32based_args[2]); // PSECURITY_DESCRIPTOR  IN 
	uint32_t x32based_PrincipalSelfSid = (uint32_t)(x32based_args[3]); // PSID  IN 
	uint32_t x32based_ClientToken = (uint32_t)(x32based_args[4]); // HANDLE  IN 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[5]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectTypeList = (uint32_t)(x32based_args[6]); // POBJECT_TYPE_LIST  IN 
	ULONG ObjectTypeListLength_used = (ULONG)(x32based_args[7]); // ULONG  IN 
	PGENERIC_MAPPING GenericMapping_used = (PGENERIC_MAPPING)(x32based_args[8]); // PGENERIC_MAPPING  IN 
	PPRIVILEGE_SET PrivilegeSet_used = (PPRIVILEGE_SET)(x32based_args[9]); // PPRIVILEGE_SET  OUT 
	PULONG PrivilegeSetLength_used = (PULONG)(x32based_args[10]); // PULONG  IN  OUT 
	PACCESS_MASK GrantedAccess_used = (PACCESS_MASK)(x32based_args[11]); // PACCESS_MASK  OUT 
	PNTSTATUS AccessStatus_used = (PNTSTATUS)(x32based_args[12]); // PNTSTATUS  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SecurityDescriptor_holder[sizeof(PVOID)];
	PSECURITY_DESCRIPTOR SecurityDescriptor_used = (PSECURITY_DESCRIPTOR)&SecurityDescriptor_holder;
	uint8_t PrincipalSelfSid_holder[sizeof(PVOID)];
	PSID PrincipalSelfSid_used = (PSID)&PrincipalSelfSid_holder;
	HANDLE ClientToken_used = Handle32ToHandle((const void* __ptr32)x32based_ClientToken);
	uint8_t ObjectTypeList_holder[sizeof(_OBJECT_TYPE_LIST)];
	POBJECT_TYPE_LIST ObjectTypeList_used = (POBJECT_TYPE_LIST)&ObjectTypeList_holder;

	// Convert parameters from x32 to x64
	if (x32based_SecurityDescriptor != NULL) {
		convert_HANDLE_32TO64(ctx, (HANDLE**)&SecurityDescriptor_used, x32based_SecurityDescriptor);
	}
	else {
		SecurityDescriptor_used = 0;
	}
	if (x32based_PrincipalSelfSid != NULL) {
		convert_HANDLE_32TO64(ctx, (HANDLE**)&PrincipalSelfSid_used, x32based_PrincipalSelfSid);
	}
	else {
		PrincipalSelfSid_used = 0;
	}
	if (x32based_ObjectTypeList != NULL) {
		convert__OBJECT_TYPE_LIST_32TO64(ctx, (_OBJECT_TYPE_LIST**)&ObjectTypeList_used, x32based_ObjectTypeList);
	}
	else {
		ObjectTypeList_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 11, SecurityDescriptor_used, PrincipalSelfSid_used, ClientToken_used, DesiredAccess_used, ObjectTypeList_used, ObjectTypeListLength_used, GenericMapping_used, PrivilegeSet_used, PrivilegeSetLength_used, GrantedAccess_used, AccessStatus_used); // NtAccessCheckByTypeResultList

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetCachedSigningLevel(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	ULONG Flags_used = (ULONG)(x32based_args[2]); // ULONG  IN 
	SE_SIGNING_LEVEL InputSigningLevel_used = (SE_SIGNING_LEVEL)(x32based_args[3]); // SE_SIGNING_LEVEL  IN 
	uint32_t x32based_SourceFiles = (uint32_t)(x32based_args[4]); // PHANDLE  IN 
	ULONG SourceFileCount_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	uint32_t x32based_TargetFile = (uint32_t)(x32based_args[6]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SourceFiles_holder[sizeof(PVOID)];
	PHANDLE SourceFiles_used = (PHANDLE)&SourceFiles_holder;
	HANDLE TargetFile_used = Handle32ToHandle((const void* __ptr32)x32based_TargetFile);

	// Convert parameters from x32 to x64
	if (x32based_SourceFiles != NULL) {
		convert_HANDLE_32TO64(ctx, (HANDLE**)&SourceFiles_used, x32based_SourceFiles);
	}
	else {
		SourceFiles_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 5, Flags_used, InputSigningLevel_used, SourceFiles_used, SourceFileCount_used, TargetFile_used); // NtSetCachedSigningLevel

	return ret_value;
}


NTSTATUS WINAPI _w32_NtGetCachedSigningLevel(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_File = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PULONG Flags_used = (PULONG)(x32based_args[3]); // PULONG  OUT 
	PSE_SIGNING_LEVEL SigningLevel_used = (PSE_SIGNING_LEVEL)(x32based_args[4]); // PSE_SIGNING_LEVEL  OUT 
	PUCHAR Thumbprint_used = (PUCHAR)(x32based_args[5]); // PUCHAR  IN  OUT 
	PULONG ThumbprintSize_used = (PULONG)(x32based_args[6]); // PULONG  IN  OUT 
	PULONG ThumbprintAlgorithm_used = (PULONG)(x32based_args[7]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE File_used = Handle32ToHandle((const void* __ptr32)x32based_File);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 6, File_used, Flags_used, SigningLevel_used, Thumbprint_used, ThumbprintSize_used, ThumbprintAlgorithm_used); // NtGetCachedSigningLevel

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAccessCheckAndAuditAlarm(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_SubsystemName = (uint32_t)(x32based_args[2]); // PUNICODE_STRING  IN 
	PVOID HandleId_used = (PVOID)(x32based_args[3]); // PVOID  IN 
	uint32_t x32based_ObjectTypeName = (uint32_t)(x32based_args[4]); // PUNICODE_STRING  IN 
	uint32_t x32based_ObjectName = (uint32_t)(x32based_args[5]); // PUNICODE_STRING  IN 
	uint32_t x32based_SecurityDescriptor = (uint32_t)(x32based_args[6]); // PSECURITY_DESCRIPTOR  IN 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[7]); // ACCESS_MASK  IN 
	PGENERIC_MAPPING GenericMapping_used = (PGENERIC_MAPPING)(x32based_args[8]); // PGENERIC_MAPPING  IN 
	BOOLEAN ObjectCreation_used = (BOOLEAN)(x32based_args[9]); // BOOLEAN  IN 
	PACCESS_MASK GrantedAccess_used = (PACCESS_MASK)(x32based_args[10]); // PACCESS_MASK  OUT 
	PNTSTATUS AccessStatus_used = (PNTSTATUS)(x32based_args[11]); // PNTSTATUS  OUT 
	PBOOLEAN GenerateOnClose_used = (PBOOLEAN)(x32based_args[12]); // PBOOLEAN  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SubsystemName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING SubsystemName_used = (PUNICODE_STRING)&SubsystemName_holder;
	uint8_t ObjectTypeName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING ObjectTypeName_used = (PUNICODE_STRING)&ObjectTypeName_holder;
	uint8_t ObjectName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING ObjectName_used = (PUNICODE_STRING)&ObjectName_holder;
	uint8_t SecurityDescriptor_holder[sizeof(PVOID)];
	PSECURITY_DESCRIPTOR SecurityDescriptor_used = (PSECURITY_DESCRIPTOR)&SecurityDescriptor_holder;

	// Convert parameters from x32 to x64
	if (x32based_SubsystemName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&SubsystemName_used, x32based_SubsystemName);
	}
	else {
		SubsystemName_used = 0;
	}
	if (x32based_ObjectTypeName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&ObjectTypeName_used, x32based_ObjectTypeName);
	}
	else {
		ObjectTypeName_used = 0;
	}
	if (x32based_ObjectName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&ObjectName_used, x32based_ObjectName);
	}
	else {
		ObjectName_used = 0;
	}
	if (x32based_SecurityDescriptor != NULL) {
		convert_HANDLE_32TO64(ctx, (HANDLE**)&SecurityDescriptor_used, x32based_SecurityDescriptor);
	}
	else {
		SecurityDescriptor_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 11, SubsystemName_used, HandleId_used, ObjectTypeName_used, ObjectName_used, SecurityDescriptor_used, DesiredAccess_used, GenericMapping_used, ObjectCreation_used, GrantedAccess_used, AccessStatus_used, GenerateOnClose_used); // NtAccessCheckAndAuditAlarm

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAccessCheckByTypeAndAuditAlarm(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_SubsystemName = (uint32_t)(x32based_args[2]); // PUNICODE_STRING  IN 
	PVOID HandleId_used = (PVOID)(x32based_args[3]); // PVOID  IN 
	uint32_t x32based_ObjectTypeName = (uint32_t)(x32based_args[4]); // PUNICODE_STRING  IN 
	uint32_t x32based_ObjectName = (uint32_t)(x32based_args[5]); // PUNICODE_STRING  IN 
	uint32_t x32based_SecurityDescriptor = (uint32_t)(x32based_args[6]); // PSECURITY_DESCRIPTOR  IN 
	uint32_t x32based_PrincipalSelfSid = (uint32_t)(x32based_args[7]); // PSID  IN 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[8]); // ACCESS_MASK  IN 
	AUDIT_EVENT_TYPE AuditType_used = (AUDIT_EVENT_TYPE)(x32based_args[9]); // AUDIT_EVENT_TYPE  IN 
	ULONG Flags_used = (ULONG)(x32based_args[10]); // ULONG  IN 
	uint32_t x32based_ObjectTypeList = (uint32_t)(x32based_args[11]); // POBJECT_TYPE_LIST  IN 
	ULONG ObjectTypeListLength_used = (ULONG)(x32based_args[12]); // ULONG  IN 
	PGENERIC_MAPPING GenericMapping_used = (PGENERIC_MAPPING)(x32based_args[13]); // PGENERIC_MAPPING  IN 
	BOOLEAN ObjectCreation_used = (BOOLEAN)(x32based_args[14]); // BOOLEAN  IN 
	PACCESS_MASK GrantedAccess_used = (PACCESS_MASK)(x32based_args[15]); // PACCESS_MASK  OUT 
	PNTSTATUS AccessStatus_used = (PNTSTATUS)(x32based_args[16]); // PNTSTATUS  OUT 
	PBOOLEAN GenerateOnClose_used = (PBOOLEAN)(x32based_args[17]); // PBOOLEAN  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SubsystemName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING SubsystemName_used = (PUNICODE_STRING)&SubsystemName_holder;
	uint8_t ObjectTypeName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING ObjectTypeName_used = (PUNICODE_STRING)&ObjectTypeName_holder;
	uint8_t ObjectName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING ObjectName_used = (PUNICODE_STRING)&ObjectName_holder;
	uint8_t SecurityDescriptor_holder[sizeof(PVOID)];
	PSECURITY_DESCRIPTOR SecurityDescriptor_used = (PSECURITY_DESCRIPTOR)&SecurityDescriptor_holder;
	uint8_t PrincipalSelfSid_holder[sizeof(PVOID)];
	PSID PrincipalSelfSid_used = (PSID)&PrincipalSelfSid_holder;
	uint8_t ObjectTypeList_holder[sizeof(_OBJECT_TYPE_LIST)];
	POBJECT_TYPE_LIST ObjectTypeList_used = (POBJECT_TYPE_LIST)&ObjectTypeList_holder;

	// Convert parameters from x32 to x64
	if (x32based_SubsystemName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&SubsystemName_used, x32based_SubsystemName);
	}
	else {
		SubsystemName_used = 0;
	}
	if (x32based_ObjectTypeName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&ObjectTypeName_used, x32based_ObjectTypeName);
	}
	else {
		ObjectTypeName_used = 0;
	}
	if (x32based_ObjectName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&ObjectName_used, x32based_ObjectName);
	}
	else {
		ObjectName_used = 0;
	}
	if (x32based_SecurityDescriptor != NULL) {
		convert_HANDLE_32TO64(ctx, (HANDLE**)&SecurityDescriptor_used, x32based_SecurityDescriptor);
	}
	else {
		SecurityDescriptor_used = 0;
	}
	if (x32based_PrincipalSelfSid != NULL) {
		convert_HANDLE_32TO64(ctx, (HANDLE**)&PrincipalSelfSid_used, x32based_PrincipalSelfSid);
	}
	else {
		PrincipalSelfSid_used = 0;
	}
	if (x32based_ObjectTypeList != NULL) {
		convert__OBJECT_TYPE_LIST_32TO64(ctx, (_OBJECT_TYPE_LIST**)&ObjectTypeList_used, x32based_ObjectTypeList);
	}
	else {
		ObjectTypeList_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 16, SubsystemName_used, HandleId_used, ObjectTypeName_used, ObjectName_used, SecurityDescriptor_used, PrincipalSelfSid_used, DesiredAccess_used, AuditType_used, Flags_used, ObjectTypeList_used, ObjectTypeListLength_used, GenericMapping_used, ObjectCreation_used, GrantedAccess_used, AccessStatus_used, GenerateOnClose_used); // NtAccessCheckByTypeAndAuditAlarm

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAccessCheckByTypeResultListAndAuditAlarm(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_SubsystemName = (uint32_t)(x32based_args[2]); // PUNICODE_STRING  IN 
	PVOID HandleId_used = (PVOID)(x32based_args[3]); // PVOID  IN 
	uint32_t x32based_ObjectTypeName = (uint32_t)(x32based_args[4]); // PUNICODE_STRING  IN 
	uint32_t x32based_ObjectName = (uint32_t)(x32based_args[5]); // PUNICODE_STRING  IN 
	uint32_t x32based_SecurityDescriptor = (uint32_t)(x32based_args[6]); // PSECURITY_DESCRIPTOR  IN 
	uint32_t x32based_PrincipalSelfSid = (uint32_t)(x32based_args[7]); // PSID  IN 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[8]); // ACCESS_MASK  IN 
	AUDIT_EVENT_TYPE AuditType_used = (AUDIT_EVENT_TYPE)(x32based_args[9]); // AUDIT_EVENT_TYPE  IN 
	ULONG Flags_used = (ULONG)(x32based_args[10]); // ULONG  IN 
	uint32_t x32based_ObjectTypeList = (uint32_t)(x32based_args[11]); // POBJECT_TYPE_LIST  IN 
	ULONG ObjectTypeListLength_used = (ULONG)(x32based_args[12]); // ULONG  IN 
	PGENERIC_MAPPING GenericMapping_used = (PGENERIC_MAPPING)(x32based_args[13]); // PGENERIC_MAPPING  IN 
	BOOLEAN ObjectCreation_used = (BOOLEAN)(x32based_args[14]); // BOOLEAN  IN 
	PACCESS_MASK GrantedAccess_used = (PACCESS_MASK)(x32based_args[15]); // PACCESS_MASK  OUT 
	PNTSTATUS AccessStatus_used = (PNTSTATUS)(x32based_args[16]); // PNTSTATUS  OUT 
	PBOOLEAN GenerateOnClose_used = (PBOOLEAN)(x32based_args[17]); // PBOOLEAN  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SubsystemName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING SubsystemName_used = (PUNICODE_STRING)&SubsystemName_holder;
	uint8_t ObjectTypeName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING ObjectTypeName_used = (PUNICODE_STRING)&ObjectTypeName_holder;
	uint8_t ObjectName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING ObjectName_used = (PUNICODE_STRING)&ObjectName_holder;
	uint8_t SecurityDescriptor_holder[sizeof(PVOID)];
	PSECURITY_DESCRIPTOR SecurityDescriptor_used = (PSECURITY_DESCRIPTOR)&SecurityDescriptor_holder;
	uint8_t PrincipalSelfSid_holder[sizeof(PVOID)];
	PSID PrincipalSelfSid_used = (PSID)&PrincipalSelfSid_holder;
	uint8_t ObjectTypeList_holder[sizeof(_OBJECT_TYPE_LIST)];
	POBJECT_TYPE_LIST ObjectTypeList_used = (POBJECT_TYPE_LIST)&ObjectTypeList_holder;

	// Convert parameters from x32 to x64
	if (x32based_SubsystemName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&SubsystemName_used, x32based_SubsystemName);
	}
	else {
		SubsystemName_used = 0;
	}
	if (x32based_ObjectTypeName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&ObjectTypeName_used, x32based_ObjectTypeName);
	}
	else {
		ObjectTypeName_used = 0;
	}
	if (x32based_ObjectName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&ObjectName_used, x32based_ObjectName);
	}
	else {
		ObjectName_used = 0;
	}
	if (x32based_SecurityDescriptor != NULL) {
		convert_HANDLE_32TO64(ctx, (HANDLE**)&SecurityDescriptor_used, x32based_SecurityDescriptor);
	}
	else {
		SecurityDescriptor_used = 0;
	}
	if (x32based_PrincipalSelfSid != NULL) {
		convert_HANDLE_32TO64(ctx, (HANDLE**)&PrincipalSelfSid_used, x32based_PrincipalSelfSid);
	}
	else {
		PrincipalSelfSid_used = 0;
	}
	if (x32based_ObjectTypeList != NULL) {
		convert__OBJECT_TYPE_LIST_32TO64(ctx, (_OBJECT_TYPE_LIST**)&ObjectTypeList_used, x32based_ObjectTypeList);
	}
	else {
		ObjectTypeList_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 16, SubsystemName_used, HandleId_used, ObjectTypeName_used, ObjectName_used, SecurityDescriptor_used, PrincipalSelfSid_used, DesiredAccess_used, AuditType_used, Flags_used, ObjectTypeList_used, ObjectTypeListLength_used, GenericMapping_used, ObjectCreation_used, GrantedAccess_used, AccessStatus_used, GenerateOnClose_used); // NtAccessCheckByTypeResultListAndAuditAlarm

	return ret_value;
}


NTSTATUS WINAPI _w32_NtAccessCheckByTypeResultListAndAuditAlarmByHandle(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_SubsystemName = (uint32_t)(x32based_args[2]); // PUNICODE_STRING  IN 
	PVOID HandleId_used = (PVOID)(x32based_args[3]); // PVOID  IN 
	uint32_t x32based_ClientToken = (uint32_t)(x32based_args[4]); // HANDLE  IN 
	uint32_t x32based_ObjectTypeName = (uint32_t)(x32based_args[5]); // PUNICODE_STRING  IN 
	uint32_t x32based_ObjectName = (uint32_t)(x32based_args[6]); // PUNICODE_STRING  IN 
	uint32_t x32based_SecurityDescriptor = (uint32_t)(x32based_args[7]); // PSECURITY_DESCRIPTOR  IN 
	uint32_t x32based_PrincipalSelfSid = (uint32_t)(x32based_args[8]); // PSID  IN 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[9]); // ACCESS_MASK  IN 
	AUDIT_EVENT_TYPE AuditType_used = (AUDIT_EVENT_TYPE)(x32based_args[10]); // AUDIT_EVENT_TYPE  IN 
	ULONG Flags_used = (ULONG)(x32based_args[11]); // ULONG  IN 
	uint32_t x32based_ObjectTypeList = (uint32_t)(x32based_args[12]); // POBJECT_TYPE_LIST  IN 
	ULONG ObjectTypeListLength_used = (ULONG)(x32based_args[13]); // ULONG  IN 
	PGENERIC_MAPPING GenericMapping_used = (PGENERIC_MAPPING)(x32based_args[14]); // PGENERIC_MAPPING  IN 
	BOOLEAN ObjectCreation_used = (BOOLEAN)(x32based_args[15]); // BOOLEAN  IN 
	PACCESS_MASK GrantedAccess_used = (PACCESS_MASK)(x32based_args[16]); // PACCESS_MASK  OUT 
	PNTSTATUS AccessStatus_used = (PNTSTATUS)(x32based_args[17]); // PNTSTATUS  OUT 
	PBOOLEAN GenerateOnClose_used = (PBOOLEAN)(x32based_args[18]); // PBOOLEAN  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SubsystemName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING SubsystemName_used = (PUNICODE_STRING)&SubsystemName_holder;
	HANDLE ClientToken_used = Handle32ToHandle((const void* __ptr32)x32based_ClientToken);
	uint8_t ObjectTypeName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING ObjectTypeName_used = (PUNICODE_STRING)&ObjectTypeName_holder;
	uint8_t ObjectName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING ObjectName_used = (PUNICODE_STRING)&ObjectName_holder;
	uint8_t SecurityDescriptor_holder[sizeof(PVOID)];
	PSECURITY_DESCRIPTOR SecurityDescriptor_used = (PSECURITY_DESCRIPTOR)&SecurityDescriptor_holder;
	uint8_t PrincipalSelfSid_holder[sizeof(PVOID)];
	PSID PrincipalSelfSid_used = (PSID)&PrincipalSelfSid_holder;
	uint8_t ObjectTypeList_holder[sizeof(_OBJECT_TYPE_LIST)];
	POBJECT_TYPE_LIST ObjectTypeList_used = (POBJECT_TYPE_LIST)&ObjectTypeList_holder;

	// Convert parameters from x32 to x64
	if (x32based_SubsystemName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&SubsystemName_used, x32based_SubsystemName);
	}
	else {
		SubsystemName_used = 0;
	}
	if (x32based_ObjectTypeName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&ObjectTypeName_used, x32based_ObjectTypeName);
	}
	else {
		ObjectTypeName_used = 0;
	}
	if (x32based_ObjectName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&ObjectName_used, x32based_ObjectName);
	}
	else {
		ObjectName_used = 0;
	}
	if (x32based_SecurityDescriptor != NULL) {
		convert_HANDLE_32TO64(ctx, (HANDLE**)&SecurityDescriptor_used, x32based_SecurityDescriptor);
	}
	else {
		SecurityDescriptor_used = 0;
	}
	if (x32based_PrincipalSelfSid != NULL) {
		convert_HANDLE_32TO64(ctx, (HANDLE**)&PrincipalSelfSid_used, x32based_PrincipalSelfSid);
	}
	else {
		PrincipalSelfSid_used = 0;
	}
	if (x32based_ObjectTypeList != NULL) {
		convert__OBJECT_TYPE_LIST_32TO64(ctx, (_OBJECT_TYPE_LIST**)&ObjectTypeList_used, x32based_ObjectTypeList);
	}
	else {
		ObjectTypeList_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 17, SubsystemName_used, HandleId_used, ClientToken_used, ObjectTypeName_used, ObjectName_used, SecurityDescriptor_used, PrincipalSelfSid_used, DesiredAccess_used, AuditType_used, Flags_used, ObjectTypeList_used, ObjectTypeListLength_used, GenericMapping_used, ObjectCreation_used, GrantedAccess_used, AccessStatus_used, GenerateOnClose_used); // NtAccessCheckByTypeResultListAndAuditAlarmByHandle

	return ret_value;
}


NTSTATUS WINAPI _w32_NtOpenObjectAuditAlarm(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_SubsystemName = (uint32_t)(x32based_args[2]); // PUNICODE_STRING  IN 
	PVOID HandleId_used = (PVOID)(x32based_args[3]); // PVOID  IN 
	uint32_t x32based_ObjectTypeName = (uint32_t)(x32based_args[4]); // PUNICODE_STRING  IN 
	uint32_t x32based_ObjectName = (uint32_t)(x32based_args[5]); // PUNICODE_STRING  IN 
	uint32_t x32based_SecurityDescriptor = (uint32_t)(x32based_args[6]); // PSECURITY_DESCRIPTOR  IN 
	uint32_t x32based_ClientToken = (uint32_t)(x32based_args[7]); // HANDLE  IN 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[8]); // ACCESS_MASK  IN 
	ACCESS_MASK GrantedAccess_used = (ACCESS_MASK)(x32based_args[9]); // ACCESS_MASK  IN 
	PPRIVILEGE_SET Privileges_used = (PPRIVILEGE_SET)(x32based_args[10]); // PPRIVILEGE_SET  IN 
	BOOLEAN ObjectCreation_used = (BOOLEAN)(x32based_args[11]); // BOOLEAN  IN 
	BOOLEAN AccessGranted_used = (BOOLEAN)(x32based_args[12]); // BOOLEAN  IN 
	PBOOLEAN GenerateOnClose_used = (PBOOLEAN)(x32based_args[13]); // PBOOLEAN  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SubsystemName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING SubsystemName_used = (PUNICODE_STRING)&SubsystemName_holder;
	uint8_t ObjectTypeName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING ObjectTypeName_used = (PUNICODE_STRING)&ObjectTypeName_holder;
	uint8_t ObjectName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING ObjectName_used = (PUNICODE_STRING)&ObjectName_holder;
	uint8_t SecurityDescriptor_holder[sizeof(PVOID)];
	PSECURITY_DESCRIPTOR SecurityDescriptor_used = (PSECURITY_DESCRIPTOR)&SecurityDescriptor_holder;
	HANDLE ClientToken_used = Handle32ToHandle((const void* __ptr32)x32based_ClientToken);

	// Convert parameters from x32 to x64
	if (x32based_SubsystemName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&SubsystemName_used, x32based_SubsystemName);
	}
	else {
		SubsystemName_used = 0;
	}
	if (x32based_ObjectTypeName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&ObjectTypeName_used, x32based_ObjectTypeName);
	}
	else {
		ObjectTypeName_used = 0;
	}
	if (x32based_ObjectName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&ObjectName_used, x32based_ObjectName);
	}
	else {
		ObjectName_used = 0;
	}
	if (x32based_SecurityDescriptor != NULL) {
		convert_HANDLE_32TO64(ctx, (HANDLE**)&SecurityDescriptor_used, x32based_SecurityDescriptor);
	}
	else {
		SecurityDescriptor_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 12, SubsystemName_used, HandleId_used, ObjectTypeName_used, ObjectName_used, SecurityDescriptor_used, ClientToken_used, DesiredAccess_used, GrantedAccess_used, Privileges_used, ObjectCreation_used, AccessGranted_used, GenerateOnClose_used); // NtOpenObjectAuditAlarm

	return ret_value;
}


NTSTATUS WINAPI _w32_NtPrivilegeObjectAuditAlarm(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_SubsystemName = (uint32_t)(x32based_args[2]); // PUNICODE_STRING  IN 
	PVOID HandleId_used = (PVOID)(x32based_args[3]); // PVOID  IN 
	uint32_t x32based_ClientToken = (uint32_t)(x32based_args[4]); // HANDLE  IN 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[5]); // ACCESS_MASK  IN 
	PPRIVILEGE_SET Privileges_used = (PPRIVILEGE_SET)(x32based_args[6]); // PPRIVILEGE_SET  IN 
	BOOLEAN AccessGranted_used = (BOOLEAN)(x32based_args[7]); // BOOLEAN  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SubsystemName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING SubsystemName_used = (PUNICODE_STRING)&SubsystemName_holder;
	HANDLE ClientToken_used = Handle32ToHandle((const void* __ptr32)x32based_ClientToken);

	// Convert parameters from x32 to x64
	if (x32based_SubsystemName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&SubsystemName_used, x32based_SubsystemName);
	}
	else {
		SubsystemName_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 6, SubsystemName_used, HandleId_used, ClientToken_used, DesiredAccess_used, Privileges_used, AccessGranted_used); // NtPrivilegeObjectAuditAlarm

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCloseObjectAuditAlarm(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_SubsystemName = (uint32_t)(x32based_args[2]); // PUNICODE_STRING  IN 
	PVOID HandleId_used = (PVOID)(x32based_args[3]); // PVOID  IN 
	BOOLEAN GenerateOnClose_used = (BOOLEAN)(x32based_args[4]); // BOOLEAN  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SubsystemName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING SubsystemName_used = (PUNICODE_STRING)&SubsystemName_holder;

	// Convert parameters from x32 to x64
	if (x32based_SubsystemName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&SubsystemName_used, x32based_SubsystemName);
	}
	else {
		SubsystemName_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, SubsystemName_used, HandleId_used, GenerateOnClose_used); // NtCloseObjectAuditAlarm

	return ret_value;
}


NTSTATUS WINAPI _w32_NtDeleteObjectAuditAlarm(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_SubsystemName = (uint32_t)(x32based_args[2]); // PUNICODE_STRING  IN 
	PVOID HandleId_used = (PVOID)(x32based_args[3]); // PVOID  IN 
	BOOLEAN GenerateOnClose_used = (BOOLEAN)(x32based_args[4]); // BOOLEAN  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SubsystemName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING SubsystemName_used = (PUNICODE_STRING)&SubsystemName_holder;

	// Convert parameters from x32 to x64
	if (x32based_SubsystemName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&SubsystemName_used, x32based_SubsystemName);
	}
	else {
		SubsystemName_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, SubsystemName_used, HandleId_used, GenerateOnClose_used); // NtDeleteObjectAuditAlarm

	return ret_value;
}


NTSTATUS WINAPI _w32_NtPrivilegedServiceAuditAlarm(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_SubsystemName = (uint32_t)(x32based_args[2]); // PUNICODE_STRING  IN 
	uint32_t x32based_ServiceName = (uint32_t)(x32based_args[3]); // PUNICODE_STRING  IN 
	uint32_t x32based_ClientToken = (uint32_t)(x32based_args[4]); // HANDLE  IN 
	PPRIVILEGE_SET Privileges_used = (PPRIVILEGE_SET)(x32based_args[5]); // PPRIVILEGE_SET  IN 
	BOOLEAN AccessGranted_used = (BOOLEAN)(x32based_args[6]); // BOOLEAN  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t SubsystemName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING SubsystemName_used = (PUNICODE_STRING)&SubsystemName_holder;
	uint8_t ServiceName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING ServiceName_used = (PUNICODE_STRING)&ServiceName_holder;
	HANDLE ClientToken_used = Handle32ToHandle((const void* __ptr32)x32based_ClientToken);

	// Convert parameters from x32 to x64
	if (x32based_SubsystemName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&SubsystemName_used, x32based_SubsystemName);
	}
	else {
		SubsystemName_used = 0;
	}
	if (x32based_ServiceName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&ServiceName_used, x32based_ServiceName);
	}
	else {
		ServiceName_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 5, SubsystemName_used, ServiceName_used, ClientToken_used, Privileges_used, AccessGranted_used); // NtPrivilegedServiceAuditAlarm

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateTransactionManager(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TmHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	uint32_t x32based_LogFileName = (uint32_t)(x32based_args[5]); // PUNICODE_STRING  IN 
	ULONG CreateOptions_used = (ULONG)(x32based_args[6]); // ULONG  IN 
	ULONG CommitStrength_used = (ULONG)(x32based_args[7]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t TmHandle_holder[sizeof(PVOID)];
	PHANDLE TmHandle_used = (PHANDLE)&TmHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;
	uint8_t LogFileName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING LogFileName_used = (PUNICODE_STRING)&LogFileName_holder;

	// Convert parameters from x32 to x64
	if (x32based_TmHandle == NULL) {
		TmHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}
	if (x32based_LogFileName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&LogFileName_used, x32based_LogFileName);
	}
	else {
		LogFileName_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 6, TmHandle_used, DesiredAccess_used, ObjectAttributes_used, LogFileName_used, CreateOptions_used, CommitStrength_used); // NtCreateTransactionManager

	if (TmHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)TmHandle_used, x32based_TmHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtOpenTransactionManager(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TmHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	uint32_t x32based_LogFileName = (uint32_t)(x32based_args[5]); // PUNICODE_STRING  IN 
	LPGUID TmIdentity_used = (LPGUID)(x32based_args[6]); // LPGUID  IN 
	ULONG OpenOptions_used = (ULONG)(x32based_args[7]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t TmHandle_holder[sizeof(PVOID)];
	PHANDLE TmHandle_used = (PHANDLE)&TmHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;
	uint8_t LogFileName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING LogFileName_used = (PUNICODE_STRING)&LogFileName_holder;

	// Convert parameters from x32 to x64
	if (x32based_TmHandle == NULL) {
		TmHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}
	if (x32based_LogFileName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&LogFileName_used, x32based_LogFileName);
	}
	else {
		LogFileName_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 6, TmHandle_used, DesiredAccess_used, ObjectAttributes_used, LogFileName_used, TmIdentity_used, OpenOptions_used); // NtOpenTransactionManager

	if (TmHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)TmHandle_used, x32based_TmHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtRenameTransactionManager(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_LogFileName = (uint32_t)(x32based_args[2]); // PUNICODE_STRING  IN 
	LPGUID ExistingTransactionManagerGuid_used = (LPGUID)(x32based_args[3]); // LPGUID  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t LogFileName_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING LogFileName_used = (PUNICODE_STRING)&LogFileName_holder;

	// Convert parameters from x32 to x64
	if (x32based_LogFileName != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&LogFileName_used, x32based_LogFileName);
	}
	else {
		LogFileName_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 2, LogFileName_used, ExistingTransactionManagerGuid_used); // NtRenameTransactionManager

	return ret_value;
}


NTSTATUS WINAPI _w32_NtRollforwardTransactionManager(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TransactionManagerHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PLARGE_INTEGER TmVirtualClock_used = (PLARGE_INTEGER)(x32based_args[3]); // PLARGE_INTEGER  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE TransactionManagerHandle_used = Handle32ToHandle((const void* __ptr32)x32based_TransactionManagerHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, TransactionManagerHandle_used, TmVirtualClock_used); // NtRollforwardTransactionManager

	return ret_value;
}


NTSTATUS WINAPI _w32_NtRecoverTransactionManager(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TransactionManagerHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE TransactionManagerHandle_used = Handle32ToHandle((const void* __ptr32)x32based_TransactionManagerHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, TransactionManagerHandle_used); // NtRecoverTransactionManager

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryInformationTransactionManager(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TransactionManagerHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass_used = (TRANSACTIONMANAGER_INFORMATION_CLASS)(x32based_args[3]); // TRANSACTIONMANAGER_INFORMATION_CLASS  IN 
	PVOID TransactionManagerInformation_used = (PVOID)(x32based_args[4]); // PVOID  IN  OUT 
	ULONG TransactionManagerInformationLength_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	PULONG ReturnLength_used = (PULONG)(x32based_args[6]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE TransactionManagerHandle_used = Handle32ToHandle((const void* __ptr32)x32based_TransactionManagerHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 5, TransactionManagerHandle_used, TransactionManagerInformationClass_used, TransactionManagerInformation_used, TransactionManagerInformationLength_used, ReturnLength_used); // NtQueryInformationTransactionManager

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetInformationTransactionManager(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TmHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass_used = (TRANSACTIONMANAGER_INFORMATION_CLASS)(x32based_args[3]); // TRANSACTIONMANAGER_INFORMATION_CLASS  IN 
	PVOID TransactionManagerInformation_used = (PVOID)(x32based_args[4]); // PVOID  IN 
	ULONG TransactionManagerInformationLength_used = (ULONG)(x32based_args[5]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE TmHandle_used = Handle32ToHandle((const void* __ptr32)x32based_TmHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 4, TmHandle_used, TransactionManagerInformationClass_used, TransactionManagerInformation_used, TransactionManagerInformationLength_used); // NtSetInformationTransactionManager

	return ret_value;
}


NTSTATUS WINAPI _w32_NtEnumerateTransactionObject(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_RootObjectHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	KTMOBJECT_TYPE QueryType_used = (KTMOBJECT_TYPE)(x32based_args[3]); // KTMOBJECT_TYPE  IN 
	PKTMOBJECT_CURSOR ObjectCursor_used = (PKTMOBJECT_CURSOR)(x32based_args[4]); // PKTMOBJECT_CURSOR  IN  OUT 
	ULONG ObjectCursorLength_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	PULONG ReturnLength_used = (PULONG)(x32based_args[6]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE RootObjectHandle_used = Handle32ToHandle((const void* __ptr32)x32based_RootObjectHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 5, RootObjectHandle_used, QueryType_used, ObjectCursor_used, ObjectCursorLength_used, ReturnLength_used); // NtEnumerateTransactionObject

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateTransaction(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TransactionHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	LPGUID Uow_used = (LPGUID)(x32based_args[5]); // LPGUID  IN 
	uint32_t x32based_TmHandle = (uint32_t)(x32based_args[6]); // HANDLE  IN 
	ULONG CreateOptions_used = (ULONG)(x32based_args[7]); // ULONG  IN 
	ULONG IsolationLevel_used = (ULONG)(x32based_args[8]); // ULONG  IN 
	ULONG IsolationFlags_used = (ULONG)(x32based_args[9]); // ULONG  IN 
	PLARGE_INTEGER Timeout_used = (PLARGE_INTEGER)(x32based_args[10]); // PLARGE_INTEGER  IN 
	uint32_t x32based_Description = (uint32_t)(x32based_args[11]); // PUNICODE_STRING  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t TransactionHandle_holder[sizeof(PVOID)];
	PHANDLE TransactionHandle_used = (PHANDLE)&TransactionHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;
	HANDLE TmHandle_used = Handle32ToHandle((const void* __ptr32)x32based_TmHandle);
	uint8_t Description_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING Description_used = (PUNICODE_STRING)&Description_holder;

	// Convert parameters from x32 to x64
	if (x32based_TransactionHandle == NULL) {
		TransactionHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}
	if (x32based_Description != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&Description_used, x32based_Description);
	}
	else {
		Description_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 10, TransactionHandle_used, DesiredAccess_used, ObjectAttributes_used, Uow_used, TmHandle_used, CreateOptions_used, IsolationLevel_used, IsolationFlags_used, Timeout_used, Description_used); // NtCreateTransaction

	if (TransactionHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)TransactionHandle_used, x32based_TransactionHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtOpenTransaction(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TransactionHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[4]); // POBJECT_ATTRIBUTES  IN 
	LPGUID Uow_used = (LPGUID)(x32based_args[5]); // LPGUID  IN 
	uint32_t x32based_TmHandle = (uint32_t)(x32based_args[6]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t TransactionHandle_holder[sizeof(PVOID)];
	PHANDLE TransactionHandle_used = (PHANDLE)&TransactionHandle_holder;
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;
	HANDLE TmHandle_used = Handle32ToHandle((const void* __ptr32)x32based_TmHandle);

	// Convert parameters from x32 to x64
	if (x32based_TransactionHandle == NULL) {
		TransactionHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 5, TransactionHandle_used, DesiredAccess_used, ObjectAttributes_used, Uow_used, TmHandle_used); // NtOpenTransaction

	if (TransactionHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)TransactionHandle_used, x32based_TransactionHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryInformationTransaction(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TransactionHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	TRANSACTION_INFORMATION_CLASS TransactionInformationClass_used = (TRANSACTION_INFORMATION_CLASS)(x32based_args[3]); // TRANSACTION_INFORMATION_CLASS  IN 
	PVOID TransactionInformation_used = (PVOID)(x32based_args[4]); // PVOID  IN  OUT 
	ULONG TransactionInformationLength_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	PULONG ReturnLength_used = (PULONG)(x32based_args[6]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE TransactionHandle_used = Handle32ToHandle((const void* __ptr32)x32based_TransactionHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 5, TransactionHandle_used, TransactionInformationClass_used, TransactionInformation_used, TransactionInformationLength_used, ReturnLength_used); // NtQueryInformationTransaction

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetInformationTransaction(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TransactionHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	TRANSACTION_INFORMATION_CLASS TransactionInformationClass_used = (TRANSACTION_INFORMATION_CLASS)(x32based_args[3]); // TRANSACTION_INFORMATION_CLASS  IN 
	PVOID TransactionInformation_used = (PVOID)(x32based_args[4]); // PVOID  IN 
	ULONG TransactionInformationLength_used = (ULONG)(x32based_args[5]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE TransactionHandle_used = Handle32ToHandle((const void* __ptr32)x32based_TransactionHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 4, TransactionHandle_used, TransactionInformationClass_used, TransactionInformation_used, TransactionInformationLength_used); // NtSetInformationTransaction

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCommitTransaction(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TransactionHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	BOOLEAN Wait_used = (BOOLEAN)(x32based_args[3]); // BOOLEAN  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE TransactionHandle_used = Handle32ToHandle((const void* __ptr32)x32based_TransactionHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, TransactionHandle_used, Wait_used); // NtCommitTransaction

	return ret_value;
}


NTSTATUS WINAPI _w32_NtRollbackTransaction(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TransactionHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	BOOLEAN Wait_used = (BOOLEAN)(x32based_args[3]); // BOOLEAN  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE TransactionHandle_used = Handle32ToHandle((const void* __ptr32)x32based_TransactionHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, TransactionHandle_used, Wait_used); // NtRollbackTransaction

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateEnlistment(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_EnlistmentHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ResourceManagerHandle = (uint32_t)(x32based_args[4]); // HANDLE  IN 
	uint32_t x32based_TransactionHandle = (uint32_t)(x32based_args[5]); // HANDLE  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[6]); // POBJECT_ATTRIBUTES  IN 
	ULONG CreateOptions_used = (ULONG)(x32based_args[7]); // ULONG  IN 
	NOTIFICATION_MASK NotificationMask_used = (NOTIFICATION_MASK)(x32based_args[8]); // NOTIFICATION_MASK  IN 
	PVOID EnlistmentKey_used = (PVOID)(x32based_args[9]); // PVOID  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t EnlistmentHandle_holder[sizeof(PVOID)];
	PHANDLE EnlistmentHandle_used = (PHANDLE)&EnlistmentHandle_holder;
	HANDLE ResourceManagerHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ResourceManagerHandle);
	HANDLE TransactionHandle_used = Handle32ToHandle((const void* __ptr32)x32based_TransactionHandle);
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_EnlistmentHandle == NULL) {
		EnlistmentHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 8, EnlistmentHandle_used, DesiredAccess_used, ResourceManagerHandle_used, TransactionHandle_used, ObjectAttributes_used, CreateOptions_used, NotificationMask_used, EnlistmentKey_used); // NtCreateEnlistment

	if (EnlistmentHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)EnlistmentHandle_used, x32based_EnlistmentHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtOpenEnlistment(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_EnlistmentHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_ResourceManagerHandle = (uint32_t)(x32based_args[4]); // HANDLE  IN 
	LPGUID EnlistmentGuid_used = (LPGUID)(x32based_args[5]); // LPGUID  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[6]); // POBJECT_ATTRIBUTES  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t EnlistmentHandle_holder[sizeof(PVOID)];
	PHANDLE EnlistmentHandle_used = (PHANDLE)&EnlistmentHandle_holder;
	HANDLE ResourceManagerHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ResourceManagerHandle);
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_EnlistmentHandle == NULL) {
		EnlistmentHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 5, EnlistmentHandle_used, DesiredAccess_used, ResourceManagerHandle_used, EnlistmentGuid_used, ObjectAttributes_used); // NtOpenEnlistment

	if (EnlistmentHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)EnlistmentHandle_used, x32based_EnlistmentHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryInformationEnlistment(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_EnlistmentHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass_used = (ENLISTMENT_INFORMATION_CLASS)(x32based_args[3]); // ENLISTMENT_INFORMATION_CLASS  IN 
	PVOID EnlistmentInformation_used = (PVOID)(x32based_args[4]); // PVOID  IN  OUT 
	ULONG EnlistmentInformationLength_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	PULONG ReturnLength_used = (PULONG)(x32based_args[6]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE EnlistmentHandle_used = Handle32ToHandle((const void* __ptr32)x32based_EnlistmentHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 5, EnlistmentHandle_used, EnlistmentInformationClass_used, EnlistmentInformation_used, EnlistmentInformationLength_used, ReturnLength_used); // NtQueryInformationEnlistment

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetInformationEnlistment(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_EnlistmentHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass_used = (ENLISTMENT_INFORMATION_CLASS)(x32based_args[3]); // ENLISTMENT_INFORMATION_CLASS  IN 
	PVOID EnlistmentInformation_used = (PVOID)(x32based_args[4]); // PVOID  IN 
	ULONG EnlistmentInformationLength_used = (ULONG)(x32based_args[5]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE EnlistmentHandle_used = Handle32ToHandle((const void* __ptr32)x32based_EnlistmentHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 4, EnlistmentHandle_used, EnlistmentInformationClass_used, EnlistmentInformation_used, EnlistmentInformationLength_used); // NtSetInformationEnlistment

	return ret_value;
}


NTSTATUS WINAPI _w32_NtRecoverEnlistment(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_EnlistmentHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PVOID EnlistmentKey_used = (PVOID)(x32based_args[3]); // PVOID  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE EnlistmentHandle_used = Handle32ToHandle((const void* __ptr32)x32based_EnlistmentHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, EnlistmentHandle_used, EnlistmentKey_used); // NtRecoverEnlistment

	return ret_value;
}


NTSTATUS WINAPI _w32_NtPrePrepareEnlistment(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_EnlistmentHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PLARGE_INTEGER TmVirtualClock_used = (PLARGE_INTEGER)(x32based_args[3]); // PLARGE_INTEGER  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE EnlistmentHandle_used = Handle32ToHandle((const void* __ptr32)x32based_EnlistmentHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, EnlistmentHandle_used, TmVirtualClock_used); // NtPrePrepareEnlistment

	return ret_value;
}


NTSTATUS WINAPI _w32_NtPrepareEnlistment(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_EnlistmentHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PLARGE_INTEGER TmVirtualClock_used = (PLARGE_INTEGER)(x32based_args[3]); // PLARGE_INTEGER  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE EnlistmentHandle_used = Handle32ToHandle((const void* __ptr32)x32based_EnlistmentHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, EnlistmentHandle_used, TmVirtualClock_used); // NtPrepareEnlistment

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCommitEnlistment(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_EnlistmentHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PLARGE_INTEGER TmVirtualClock_used = (PLARGE_INTEGER)(x32based_args[3]); // PLARGE_INTEGER  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE EnlistmentHandle_used = Handle32ToHandle((const void* __ptr32)x32based_EnlistmentHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, EnlistmentHandle_used, TmVirtualClock_used); // NtCommitEnlistment

	return ret_value;
}


NTSTATUS WINAPI _w32_NtRollbackEnlistment(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_EnlistmentHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PLARGE_INTEGER TmVirtualClock_used = (PLARGE_INTEGER)(x32based_args[3]); // PLARGE_INTEGER  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE EnlistmentHandle_used = Handle32ToHandle((const void* __ptr32)x32based_EnlistmentHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, EnlistmentHandle_used, TmVirtualClock_used); // NtRollbackEnlistment

	return ret_value;
}


NTSTATUS WINAPI _w32_NtPrePrepareComplete(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_EnlistmentHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PLARGE_INTEGER TmVirtualClock_used = (PLARGE_INTEGER)(x32based_args[3]); // PLARGE_INTEGER  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE EnlistmentHandle_used = Handle32ToHandle((const void* __ptr32)x32based_EnlistmentHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, EnlistmentHandle_used, TmVirtualClock_used); // NtPrePrepareComplete

	return ret_value;
}


NTSTATUS WINAPI _w32_NtPrepareComplete(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_EnlistmentHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PLARGE_INTEGER TmVirtualClock_used = (PLARGE_INTEGER)(x32based_args[3]); // PLARGE_INTEGER  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE EnlistmentHandle_used = Handle32ToHandle((const void* __ptr32)x32based_EnlistmentHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, EnlistmentHandle_used, TmVirtualClock_used); // NtPrepareComplete

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCommitComplete(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_EnlistmentHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PLARGE_INTEGER TmVirtualClock_used = (PLARGE_INTEGER)(x32based_args[3]); // PLARGE_INTEGER  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE EnlistmentHandle_used = Handle32ToHandle((const void* __ptr32)x32based_EnlistmentHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, EnlistmentHandle_used, TmVirtualClock_used); // NtCommitComplete

	return ret_value;
}


NTSTATUS WINAPI _w32_NtReadOnlyEnlistment(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_EnlistmentHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PLARGE_INTEGER TmVirtualClock_used = (PLARGE_INTEGER)(x32based_args[3]); // PLARGE_INTEGER  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE EnlistmentHandle_used = Handle32ToHandle((const void* __ptr32)x32based_EnlistmentHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, EnlistmentHandle_used, TmVirtualClock_used); // NtReadOnlyEnlistment

	return ret_value;
}


NTSTATUS WINAPI _w32_NtRollbackComplete(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_EnlistmentHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PLARGE_INTEGER TmVirtualClock_used = (PLARGE_INTEGER)(x32based_args[3]); // PLARGE_INTEGER  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE EnlistmentHandle_used = Handle32ToHandle((const void* __ptr32)x32based_EnlistmentHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, EnlistmentHandle_used, TmVirtualClock_used); // NtRollbackComplete

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSinglePhaseReject(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_EnlistmentHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PLARGE_INTEGER TmVirtualClock_used = (PLARGE_INTEGER)(x32based_args[3]); // PLARGE_INTEGER  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE EnlistmentHandle_used = Handle32ToHandle((const void* __ptr32)x32based_EnlistmentHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, EnlistmentHandle_used, TmVirtualClock_used); // NtSinglePhaseReject

	return ret_value;
}


NTSTATUS WINAPI _w32_NtCreateResourceManager(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ResourceManagerHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_TmHandle = (uint32_t)(x32based_args[4]); // HANDLE  IN 
	LPGUID RmGuid_used = (LPGUID)(x32based_args[5]); // LPGUID  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[6]); // POBJECT_ATTRIBUTES  IN 
	ULONG CreateOptions_used = (ULONG)(x32based_args[7]); // ULONG  IN 
	uint32_t x32based_Description = (uint32_t)(x32based_args[8]); // PUNICODE_STRING  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ResourceManagerHandle_holder[sizeof(PVOID)];
	PHANDLE ResourceManagerHandle_used = (PHANDLE)&ResourceManagerHandle_holder;
	HANDLE TmHandle_used = Handle32ToHandle((const void* __ptr32)x32based_TmHandle);
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;
	uint8_t Description_holder[sizeof(_UNICODE_STRING)];
	PUNICODE_STRING Description_used = (PUNICODE_STRING)&Description_holder;

	// Convert parameters from x32 to x64
	if (x32based_ResourceManagerHandle == NULL) {
		ResourceManagerHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}
	if (x32based_Description != NULL) {
		convert__UNICODE_STRING_32TO64(ctx, (_UNICODE_STRING**)&Description_used, x32based_Description);
	}
	else {
		Description_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 7, ResourceManagerHandle_used, DesiredAccess_used, TmHandle_used, RmGuid_used, ObjectAttributes_used, CreateOptions_used, Description_used); // NtCreateResourceManager

	if (ResourceManagerHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)ResourceManagerHandle_used, x32based_ResourceManagerHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtOpenResourceManager(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ResourceManagerHandle = (uint32_t)(x32based_args[2]); // PHANDLE  OUT 
	ACCESS_MASK DesiredAccess_used = (ACCESS_MASK)(x32based_args[3]); // ACCESS_MASK  IN 
	uint32_t x32based_TmHandle = (uint32_t)(x32based_args[4]); // HANDLE  IN 
	LPGUID ResourceManagerGuid_used = (LPGUID)(x32based_args[5]); // LPGUID  IN 
	uint32_t x32based_ObjectAttributes = (uint32_t)(x32based_args[6]); // POBJECT_ATTRIBUTES  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ResourceManagerHandle_holder[sizeof(PVOID)];
	PHANDLE ResourceManagerHandle_used = (PHANDLE)&ResourceManagerHandle_holder;
	HANDLE TmHandle_used = Handle32ToHandle((const void* __ptr32)x32based_TmHandle);
	uint8_t ObjectAttributes_holder[sizeof(_OBJECT_ATTRIBUTES)];
	POBJECT_ATTRIBUTES ObjectAttributes_used = (POBJECT_ATTRIBUTES)&ObjectAttributes_holder;

	// Convert parameters from x32 to x64
	if (x32based_ResourceManagerHandle == NULL) {
		ResourceManagerHandle_used = 0;
	}
	if (x32based_ObjectAttributes != NULL) {
		convert__OBJECT_ATTRIBUTES_32TO64(ctx, (_OBJECT_ATTRIBUTES**)&ObjectAttributes_used, x32based_ObjectAttributes);
	}
	else {
		ObjectAttributes_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 5, ResourceManagerHandle_used, DesiredAccess_used, TmHandle_used, ResourceManagerGuid_used, ObjectAttributes_used); // NtOpenResourceManager

	if (ResourceManagerHandle_used != NULL) {
		convert_HANDLE_64TO32(ctx, (HANDLE*)ResourceManagerHandle_used, x32based_ResourceManagerHandle);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtRecoverResourceManager(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ResourceManagerHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ResourceManagerHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ResourceManagerHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 1, ResourceManagerHandle_used); // NtRecoverResourceManager

	return ret_value;
}


NTSTATUS WINAPI _w32_NtGetNotificationResourceManager(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ResourceManagerHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_TransactionNotification = (uint32_t)(x32based_args[3]); // PTRANSACTION_NOTIFICATION  OUT 
	ULONG NotificationLength_used = (ULONG)(x32based_args[4]); // ULONG  IN 
	PLARGE_INTEGER Timeout_used = (PLARGE_INTEGER)(x32based_args[5]); // PLARGE_INTEGER  IN 
	PULONG ReturnLength_used = (PULONG)(x32based_args[6]); // PULONG  OUT 
	ULONG Asynchronous_used = (ULONG)(x32based_args[7]); // ULONG  IN 
	ULONG_PTR AsynchronousContext_used = (ULONG_PTR)(x32based_args[8]); // ULONG_PTR  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ResourceManagerHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ResourceManagerHandle);
	uint8_t TransactionNotification_holder[sizeof(_TRANSACTION_NOTIFICATION)];
	PTRANSACTION_NOTIFICATION TransactionNotification_used = (PTRANSACTION_NOTIFICATION)&TransactionNotification_holder;

	// Convert parameters from x32 to x64
	if (x32based_TransactionNotification == NULL) {
		TransactionNotification_used = 0;
	}
	ret_value = __syscall64(syscall_idx, 7, ResourceManagerHandle_used, TransactionNotification_used, NotificationLength_used, Timeout_used, ReturnLength_used, Asynchronous_used, AsynchronousContext_used); // NtGetNotificationResourceManager

	if (TransactionNotification_used != NULL) {
		convert__TRANSACTION_NOTIFICATION_64TO32(ctx, (_TRANSACTION_NOTIFICATION*)TransactionNotification_used, x32based_TransactionNotification);
	}

	return ret_value;
}


NTSTATUS WINAPI _w32_NtQueryInformationResourceManager(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ResourceManagerHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass_used = (RESOURCEMANAGER_INFORMATION_CLASS)(x32based_args[3]); // RESOURCEMANAGER_INFORMATION_CLASS  IN 
	PVOID ResourceManagerInformation_used = (PVOID)(x32based_args[4]); // PVOID  IN  OUT 
	ULONG ResourceManagerInformationLength_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	PULONG ReturnLength_used = (PULONG)(x32based_args[6]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ResourceManagerHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ResourceManagerHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 5, ResourceManagerHandle_used, ResourceManagerInformationClass_used, ResourceManagerInformation_used, ResourceManagerInformationLength_used, ReturnLength_used); // NtQueryInformationResourceManager

	return ret_value;
}


NTSTATUS WINAPI _w32_NtSetInformationResourceManager(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ResourceManagerHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass_used = (RESOURCEMANAGER_INFORMATION_CLASS)(x32based_args[3]); // RESOURCEMANAGER_INFORMATION_CLASS  IN 
	PVOID ResourceManagerInformation_used = (PVOID)(x32based_args[4]); // PVOID  IN 
	ULONG ResourceManagerInformationLength_used = (ULONG)(x32based_args[5]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ResourceManagerHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ResourceManagerHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 4, ResourceManagerHandle_used, ResourceManagerInformationClass_used, ResourceManagerInformation_used, ResourceManagerInformationLength_used); // NtSetInformationResourceManager

	return ret_value;
}


NTSTATUS WINAPI _w32_NtRegisterProtocolAddressInformation(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ResourceManager = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PCRM_PROTOCOL_ID ProtocolId_used = (PCRM_PROTOCOL_ID)(x32based_args[3]); // PCRM_PROTOCOL_ID  IN 
	ULONG ProtocolInformationSize_used = (ULONG)(x32based_args[4]); // ULONG  IN 
	PVOID ProtocolInformation_used = (PVOID)(x32based_args[5]); // PVOID  IN 
	ULONG CreateOptions_used = (ULONG)(x32based_args[6]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ResourceManager_used = Handle32ToHandle((const void* __ptr32)x32based_ResourceManager);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 5, ResourceManager_used, ProtocolId_used, ProtocolInformationSize_used, ProtocolInformation_used, CreateOptions_used); // NtRegisterProtocolAddressInformation

	return ret_value;
}


NTSTATUS WINAPI _w32_NtPropagationComplete(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ResourceManagerHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	ULONG RequestCookie_used = (ULONG)(x32based_args[3]); // ULONG  IN 
	ULONG BufferLength_used = (ULONG)(x32based_args[4]); // ULONG  IN 
	PVOID Buffer_used = (PVOID)(x32based_args[5]); // PVOID  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ResourceManagerHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ResourceManagerHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 4, ResourceManagerHandle_used, RequestCookie_used, BufferLength_used, Buffer_used); // NtPropagationComplete

	return ret_value;
}


NTSTATUS WINAPI _w32_NtPropagationFailed(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ResourceManagerHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	ULONG RequestCookie_used = (ULONG)(x32based_args[3]); // ULONG  IN 
	NTSTATUS PropStatus_used = (NTSTATUS)(x32based_args[4]); // NTSTATUS  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ResourceManagerHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ResourceManagerHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 3, ResourceManagerHandle_used, RequestCookie_used, PropStatus_used); // NtPropagationFailed

	return ret_value;
}


NTSTATUS WINAPI _w32_NtFreezeTransactions(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PLARGE_INTEGER FreezeTimeout_used = (PLARGE_INTEGER)(x32based_args[2]); // PLARGE_INTEGER  IN 
	PLARGE_INTEGER ThawTimeout_used = (PLARGE_INTEGER)(x32based_args[3]); // PLARGE_INTEGER  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, FreezeTimeout_used, ThawTimeout_used); // NtFreezeTransactions

	return ret_value;
}


NTSTATUS WINAPI _w32_NtThawTransactions(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 0); // NtThawTransactions

	return ret_value;
}


NTSTATUS WINAPI _w32_NtContinue(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	PCONTEXT ContextRecord_used = (PCONTEXT)(x32based_args[2]); // PCONTEXT  IN 
	BOOLEAN TestAlert_used = (BOOLEAN)(x32based_args[3]); // BOOLEAN  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, ContextRecord_used, TestAlert_used); // NtContinue

	return ret_value;
}


NTSTATUS WINAPI _w32_NtRaiseException(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ExceptionRecord = (uint32_t)(x32based_args[2]); // PEXCEPTION_RECORD  IN 
	PCONTEXT ContextRecord_used = (PCONTEXT)(x32based_args[3]); // PCONTEXT  IN 
	BOOLEAN FirstChance_used = (BOOLEAN)(x32based_args[4]); // BOOLEAN  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	uint8_t ExceptionRecord_holder[sizeof(_EXCEPTION_RECORD)];
	PEXCEPTION_RECORD ExceptionRecord_used = (PEXCEPTION_RECORD)&ExceptionRecord_holder;

	// Convert parameters from x32 to x64
	if (x32based_ExceptionRecord != NULL) {
		convert__EXCEPTION_RECORD_32TO64(ctx, (_EXCEPTION_RECORD**)&ExceptionRecord_used, x32based_ExceptionRecord);
	}
	else {
		ExceptionRecord_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 3, ExceptionRecord_used, ContextRecord_used, FirstChance_used); // NtRaiseException

	return ret_value;
}


NTSTATUS WINAPI _w32_NtVdmControl(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	VDMSERVICECLASS Service_used = (VDMSERVICECLASS)(x32based_args[2]); // VDMSERVICECLASS  IN 
	PVOID ServiceData_used = (PVOID)(x32based_args[3]); // PVOID  IN  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 2, Service_used, ServiceData_used); // NtVdmControl

	return ret_value;
}


NTSTATUS WINAPI _w32_NtTraceEvent(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_TraceHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	ULONG Flags_used = (ULONG)(x32based_args[3]); // ULONG  IN 
	ULONG FieldSize_used = (ULONG)(x32based_args[4]); // ULONG  IN 
	PVOID Fields_used = (PVOID)(x32based_args[5]); // PVOID  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE TraceHandle_used = Handle32ToHandle((const void* __ptr32)x32based_TraceHandle);

	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 4, TraceHandle_used, Flags_used, FieldSize_used, Fields_used); // NtTraceEvent

	return ret_value;
}


NTSTATUS WINAPI _w32_NtTraceControl(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	TRACE_CONTROL_INFORMATION_CLASS TraceInformationClass_used = (TRACE_CONTROL_INFORMATION_CLASS)(x32based_args[2]); // TRACE_CONTROL_INFORMATION_CLASS  IN 
	PVOID InputBuffer_used = (PVOID)(x32based_args[3]); // PVOID  IN 
	ULONG InputBufferLength_used = (ULONG)(x32based_args[4]); // ULONG  IN 
	PVOID TraceInformation_used = (PVOID)(x32based_args[5]); // PVOID  IN  OUT 
	ULONG TraceInformationLength_used = (ULONG)(x32based_args[6]); // ULONG  IN 
	PULONG ReturnLength_used = (PULONG)(x32based_args[7]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	// Convert parameters from x32 to x64
	ret_value = __syscall64(syscall_idx, 6, TraceInformationClass_used, InputBuffer_used, InputBufferLength_used, TraceInformation_used, TraceInformationLength_used, ReturnLength_used); // NtTraceControl

	return ret_value;
}


NTSTATUS WINAPI _w32_NtFlushVirtualMemory(uint32_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint32_t x32based_BaseAddress = (uint32_t)(x32based_args[3]); // PVOID *  IN  OUT 
	uint32_t x32based_RegionSize = (uint32_t)(x32based_args[4]); // PSIZE_T  IN  OUT 
	uint32_t x32based_IoStatus = (uint32_t)(x32based_args[5]); // PIO_STATUS_BLOCK  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);
	uint8_t BaseAddress_holder[sizeof(PVOID)];
	PVOID* BaseAddress_used = (PVOID*)&BaseAddress_holder;
	uint8_t RegionSize_holder[sizeof(long long unsigned int)];
	PSIZE_T RegionSize_used = (PSIZE_T)&RegionSize_holder;
	uint8_t IoStatus_holder[sizeof(_IO_STATUS_BLOCK)];
	PIO_STATUS_BLOCK IoStatus_used = (PIO_STATUS_BLOCK)&IoStatus_holder;

	// Convert parameters from x32 to x64
	if (x32based_BaseAddress != NULL) {
		*((SIZE_T*)BaseAddress_holder) = (SIZE_T)(*((X32_SIZE_T*)x32based_BaseAddress));
	}
	else {
		BaseAddress_used = 0;
	}
	if (x32based_RegionSize != NULL) {
		*((SIZE_T*)RegionSize_holder) = (SIZE_T)(*((X32_SIZE_T*)x32based_RegionSize));
	}
	else {
		RegionSize_used = 0;
	}
	if (x32based_IoStatus == NULL) {
		IoStatus_used = 0;
	}

	ret_value = __syscall64(syscall_idx, 4, ProcessHandle_used, BaseAddress_used, RegionSize_used, IoStatus_used); // NtFlushVirtualMemory

	if (x32based_BaseAddress != NULL) {
		*((X32_SIZE_T*)x32based_BaseAddress) = (X32_SIZE_T)(*(SIZE_T*)BaseAddress_used);
	}
	if (x32based_RegionSize != NULL) {
		*((X32_SIZE_T*)x32based_RegionSize) = (X32_SIZE_T)(*(SIZE_T*)RegionSize_used);
	}
	if (IoStatus_used != NULL) {
		convert__IO_STATUS_BLOCK_64TO32(ctx, (_IO_STATUS_BLOCK*)IoStatus_used, x32based_IoStatus);
	}

	return ret_value;
}

NTSTATUS __cdecl _w64_NtAllocateVirtualMemory(uint64_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint64_t x64based_BaseAddress = (uint64_t)(x32based_args[3]); // PVOID *  IN  OUT 
	uint64_t ZeroBits_used = (uint64_t)(x32based_args[4]); // ULONG_PTR  IN 
	uint64_t x64based_RegionSize = (uint64_t)(x32based_args[5]); // PSIZE_T  IN  OUT 
	ULONG AllocationType_used = (ULONG)(x32based_args[6]); // ULONG  IN 
	ULONG Protect_used = (ULONG)(x32based_args[7]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);

	ret_value = __syscall64(syscall_idx, 6, ProcessHandle_used, x64based_BaseAddress, ZeroBits_used, x64based_RegionSize, AllocationType_used, Protect_used); // NtAllocateVirtualMemory

	return ret_value;
}

NTSTATUS __cdecl _w64_NtFreeVirtualMemory(uint64_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint64_t x64based_BaseAddress = (uint64_t)(x32based_args[3]); // PVOID *  IN  OUT 
	uint64_t x64based_RegionSize = (uint64_t)(x32based_args[4]); // PSIZE_T  IN  OUT 
	ULONG FreeType_used = (ULONG)(x32based_args[5]); // ULONG  IN 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);

	ret_value = __syscall64(syscall_idx, 4, ProcessHandle_used, x64based_BaseAddress, x64based_RegionSize, FreeType_used); // NtFreeVirtualMemory

	return ret_value;
}

NTSTATUS __cdecl _w64_NtReadVirtualMemory(uint64_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PVOID BaseAddress_used = (PVOID)(x32based_args[3]); // PVOID  IN 
	PVOID Buffer_used = (PVOID)(x32based_args[4]); // PVOID  OUT 
	SIZE_T BufferSize_used = (SIZE_T)(x32based_args[5]); // SIZE_T  IN 
	uint64_t x64based_NumberOfBytesRead = (uint64_t)(x32based_args[6]); // PSIZE_T  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);

	ret_value = __syscall64(syscall_idx, 5, ProcessHandle_used, BaseAddress_used, Buffer_used, BufferSize_used, x64based_NumberOfBytesRead); // NtReadVirtualMemory

	return ret_value;
}

NTSTATUS __cdecl _w64_NtWriteVirtualMemory(uint64_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	PVOID BaseAddress_used = (PVOID)(x32based_args[3]); // PVOID  IN 
	PVOID Buffer_used = (PVOID)(x32based_args[4]); // PVOID  IN 
	SIZE_T BufferSize_used = (SIZE_T)(x32based_args[5]); // SIZE_T  IN 
	uint64_t x64based_NumberOfBytesWritten = (uint64_t)(x32based_args[6]); // PSIZE_T  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);

	ret_value = __syscall64(syscall_idx, 5, ProcessHandle_used, BaseAddress_used, Buffer_used, BufferSize_used, x64based_NumberOfBytesWritten); // NtWriteVirtualMemory

	return ret_value;
}

NTSTATUS __cdecl _w64_NtProtectVirtualMemory(uint64_t* x32based_args) {

	// Declare parameters from stack
	void* ctx = (void*)(x32based_args[0]);
	uint32_t syscall_idx = (uint32_t)(x32based_args[1]);
	uint32_t x32based_ProcessHandle = (uint32_t)(x32based_args[2]); // HANDLE  IN 
	uint64_t x64based_BaseAddress = (uint64_t)(x32based_args[3]); // PVOID *  IN  OUT 
	uint64_t x64based_RegionSize = (uint64_t)(x32based_args[4]); // PSIZE_T  IN  OUT 
	ULONG NewProtect_used = (ULONG)(x32based_args[5]); // ULONG  IN 
	PULONG OldProtect_used = (PULONG)(x32based_args[6]); // PULONG  OUT 

	NTSTATUS ret_value = 0;

	// Declare space used in parameters
	HANDLE ProcessHandle_used = Handle32ToHandle((const void* __ptr32)x32based_ProcessHandle);

	ret_value = __syscall64(syscall_idx, 5, ProcessHandle_used, x64based_BaseAddress, x64based_RegionSize, NewProtect_used, OldProtect_used); // NtProtectVirtualMemory

	return ret_value;
}

#pragma warning(pop)
```

`src/HIGU_ntcall_3264/thunk64_structures32.h`:

```h


#pragma pack(push, 4)

typedef struct X32__UNICODE_STRING {
	USHORT Length;
	USHORT MaximumLength;
	WOW64_POINTER(PWCH) Buffer;
} X32_UNICODE_STRING;

typedef struct X32__CLIENT_ID {
	X32_HANDLE UniqueProcess;
	X32_HANDLE UniqueThread;
} X32_CLIENT_ID;

typedef struct X32__IO_STATUS_BLOCK {
	union
	{
		NTSTATUS Status;
		X32_PVOID Pointer;
	};
	X32_ULONG_PTR Information;
} X32_IO_STATUS_BLOCK;

typedef struct X32__SYSTEM_BASIC_INFORMATION {
	ULONG Reserved;
	ULONG TimerResolution;
	ULONG PageSize;
	ULONG NumberOfPhysicalPages;
	ULONG LowestPhysicalPageNumber;
	ULONG HighestPhysicalPageNumber;
	ULONG AllocationGranularity;
	X32_ULONG_PTR MinimumUserModeAddress;
	X32_ULONG_PTR MaximumUserModeAddress;
	X32_ULONG_PTR ActiveProcessorsAffinityMask;
	CCHAR NumberOfProcessors;
};

typedef struct X32__SYSTEM_THREAD_INFORMATION {
	LARGE_INTEGER KernelTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER CreateTime;
	ULONG WaitTime;
	X32_PVOID StartAddress;
	X32_CLIENT_ID ClientId;
	KPRIORITY Priority;
	LONG BasePriority;
	ULONG ContextSwitches;
	KTHREAD_STATE ThreadState;
	KWAIT_REASON WaitReason;
} X32_SYSTEM_THREAD_INFORMATION;

typedef struct X32__SYSTEM_PROCESS_INFORMATION {
	ULONG NextEntryOffset;
	ULONG NumberOfThreads;
	LARGE_INTEGER WorkingSetPrivateSize;
	ULONG HardFaultCount;
	ULONG NumberOfThreadsHighWatermark;
	ULONGLONG CycleTime;
	LARGE_INTEGER CreateTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER KernelTime;
	X32_UNICODE_STRING ImageName;
	KPRIORITY BasePriority;
	X32_HANDLE UniqueProcessId;
	X32_HANDLE InheritedFromUniqueProcessId;
	ULONG HandleCount;
	ULONG SessionId;
	X32_ULONG_PTR UniqueProcessKey;
	X32_SIZE_T PeakVirtualSize;
	X32_SIZE_T VirtualSize;
	ULONG PageFaultCount;
	X32_SIZE_T PeakWorkingSetSize;
	X32_SIZE_T WorkingSetSize;
	X32_SIZE_T QuotaPeakPagedPoolUsage;
	X32_SIZE_T QuotaPagedPoolUsage;
	X32_SIZE_T QuotaPeakNonPagedPoolUsage;
	X32_SIZE_T QuotaNonPagedPoolUsage;
	X32_SIZE_T PagefileUsage;
	X32_SIZE_T PeakPagefileUsage;
	X32_SIZE_T PrivatePageCount;
	LARGE_INTEGER ReadOperationCount;
	LARGE_INTEGER WriteOperationCount;
	LARGE_INTEGER OtherOperationCount;
	LARGE_INTEGER ReadTransferCount;
	LARGE_INTEGER WriteTransferCount;
	LARGE_INTEGER OtherTransferCount;
	X32_SYSTEM_THREAD_INFORMATION Threads[1];
};

typedef struct X32__SYSTEM_POOL_ENTRY {
	BOOLEAN Allocated;
	BOOLEAN Spare0;
	USHORT AllocatorBackTraceIndex;
	ULONG Size;
	union
	{
		UCHAR Tag[4];
		ULONG TagUlong;
		X32_PVOID ProcessChargedQuota;
	};
} X32_SYSTEM_POOL_ENTRY;

typedef struct X32__SYSTEM_POOL_INFORMATION {
	X32_SIZE_T TotalSize;
	X32_PVOID FirstEntry;
	USHORT EntryOverhead;
	BOOLEAN PoolTagPresent;
	BOOLEAN Spare0;
	ULONG NumberOfEntries;
	X32_SYSTEM_POOL_ENTRY Entries[1];
};

typedef struct X32__SYSTEM_PAGEFILE_INFORMATION {
	ULONG NextEntryOffset;
	ULONG TotalSize;
	ULONG TotalInUse;
	ULONG PeakUsage;
	X32_UNICODE_STRING PageFileName;
};

typedef struct X32__SYSTEM_FILECACHE_INFORMATION {
	X32_SIZE_T CurrentSize;
	X32_SIZE_T PeakSize;
	ULONG PageFaultCount;
	X32_SIZE_T MinimumWorkingSet;
	X32_SIZE_T MaximumWorkingSet;
	X32_SIZE_T CurrentSizeIncludingTransitionInPages;
	X32_SIZE_T PeakSizeIncludingTransitionInPages;
	ULONG TransitionRePurposeCount;
	ULONG Flags;
};

typedef struct X32__SYSTEM_REGISTRY_QUOTA_INFORMATION {
	ULONG RegistryQuotaAllowed;
	ULONG RegistryQuotaUsed;
	X32_SIZE_T PagedPoolSize;
};

typedef struct X32__SYSTEM_LEGACY_DRIVER_INFORMATION {
	ULONG VetoType;
	X32_UNICODE_STRING VetoList;
};

typedef struct X32__SYSTEM_VERIFIER_INFORMATION {
	ULONG NextEntryOffset;
	ULONG Level;
	ULONG RuleClasses[2];
	ULONG TriageContext;
	ULONG AreAllDriversBeingVerified;
	X32_UNICODE_STRING DriverName;
	ULONG RaiseIrqls;
	ULONG AcquireSpinLocks;
	ULONG SynchronizeExecutions;
	ULONG AllocationsAttempted;
	ULONG AllocationsSucceeded;
	ULONG AllocationsSucceededSpecialPool;
	ULONG AllocationsWithNoTag;
	ULONG TrimRequests;
	ULONG Trims;
	ULONG AllocationsFailed;
	ULONG AllocationsFailedDeliberately;
	ULONG Loads;
	ULONG Unloads;
	ULONG UnTrackedPool;
	ULONG CurrentPagedPoolAllocations;
	ULONG CurrentNonPagedPoolAllocations;
	ULONG PeakPagedPoolAllocations;
	ULONG PeakNonPagedPoolAllocations;
	X32_SIZE_T PagedPoolUsageInBytes;
	X32_SIZE_T NonPagedPoolUsageInBytes;
	X32_SIZE_T PeakPagedPoolUsageInBytes;
	X32_SIZE_T PeakNonPagedPoolUsageInBytes;
};

typedef struct X32__SYSTEM_SESSION_PROCESS_INFORMATION {
	ULONG SessionId;
	ULONG SizeOfBuf;
	X32_PVOID Buffer;
};

typedef struct X32__SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX {
	X32_PVOID Object;
	X32_ULONG_PTR UniqueProcessId;
	X32_ULONG_PTR HandleValue;
	ULONG GrantedAccess;
	USHORT CreatorBackTraceIndex;
	USHORT ObjectTypeIndex;
	ULONG HandleAttributes;
	ULONG Reserved;
} X32_SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX;

typedef struct X32__SYSTEM_HANDLE_INFORMATION_EX {
	X32_ULONG_PTR NumberOfHandles;
	X32_ULONG_PTR Reserved;
	X32_SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Handles[1];
};

typedef struct X32__SYSTEM_POOLTAG {
	union
	{
		UCHAR Tag[4];
		ULONG TagUlong;
	};
	ULONG PagedAllocs;
	ULONG PagedFrees;
	X32_SIZE_T PagedUsed;
	ULONG NonPagedAllocs;
	ULONG NonPagedFrees;
	X32_SIZE_T NonPagedUsed;
} X32_SYSTEM_POOLTAG;

typedef struct X32__SYSTEM_SESSION_POOLTAG_INFORMATION {
	X32_SIZE_T NextEntryOffset;
	ULONG SessionId;
	ULONG Count;
	X32_SYSTEM_POOLTAG TagInfo[1];
};

typedef struct X32__SYSTEM_SESSION_MAPPED_VIEW_INFORMATION {
	X32_SIZE_T NextEntryOffset;
	ULONG SessionId;
	ULONG ViewFailures;
	X32_SIZE_T NumberOfBytesAvailable;
	X32_SIZE_T NumberOfBytesAvailableContiguous;
};

typedef struct X32__SYSTEM_FIRMWARE_TABLE_HANDLER {
	ULONG ProviderSignature;
	BOOLEAN Register;
	WOW64_POINTER(PFNFTH) FirmwareTableHandler;
	X32_PVOID DriverObject;
};

typedef struct X32__RTL_PROCESS_MODULE_INFORMATION {
	X32_HANDLE Section;
	X32_PVOID MappedBase;
	X32_PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR FullPathName[256];
} X32_RTL_PROCESS_MODULE_INFORMATION;

typedef struct X32__RTL_PROCESS_MODULE_INFORMATION_EX {
	USHORT NextOffset;
	X32_RTL_PROCESS_MODULE_INFORMATION BaseInfo;
	ULONG ImageChecksum;
	ULONG TimeDateStamp;
	X32_PVOID DefaultBase;
};

typedef struct X32__SUPERFETCH_INFORMATION {
	ULONG Version;
	ULONG Magic;
	SUPERFETCH_INFORMATION_CLASS InfoClass;
	X32_PVOID Data;
	ULONG Length;
};

typedef struct X32__SYSTEM_MEMORY_LIST_INFORMATION {
	X32_ULONG_PTR ZeroPageCount;
	X32_ULONG_PTR FreePageCount;
	X32_ULONG_PTR ModifiedPageCount;
	X32_ULONG_PTR ModifiedNoWritePageCount;
	X32_ULONG_PTR BadPageCount;
	X32_ULONG_PTR PageCountByPriority[8];
	X32_ULONG_PTR RepurposedPagesByPriority[8];
	X32_ULONG_PTR ModifiedPageCountPageFile;
};

typedef struct X32__SYSTEM_REF_TRACE_INFORMATION {
	BOOLEAN TraceEnable;
	BOOLEAN TracePermanent;
	X32_UNICODE_STRING TraceProcessName;
	X32_UNICODE_STRING TracePoolTags;
};

typedef struct X32__SYSTEM_PROCESS_ID_INFORMATION {
	X32_HANDLE ProcessId;
	X32_UNICODE_STRING ImageName;
};

typedef struct X32__SYSTEM_VERIFIER_INFORMATION_EX {
	ULONG VerifyMode;
	ULONG OptionChanges;
	X32_UNICODE_STRING PreviousBucketName;
	ULONG IrpCancelTimeoutMsec;
	ULONG VerifierExtensionEnabled;
	ULONG Reserved[3];
};

typedef struct X32__SYSTEM_SYSTEM_PARTITION_INFORMATION {
	X32_UNICODE_STRING SystemPartition;
};

typedef struct X32__SYSTEM_SYSTEM_DISK_INFORMATION {
	X32_UNICODE_STRING SystemDisk;
};

typedef struct X32__SYSTEM_BASIC_PERFORMANCE_INFORMATION {
	X32_SIZE_T AvailablePages;
	X32_SIZE_T CommittedPages;
	X32_SIZE_T CommitLimit;
	X32_SIZE_T PeakCommitment;
};

typedef struct X32__SYSTEM_POLICY_INFORMATION {
	X32_PVOID InputData;
	X32_PVOID OutputData;
	ULONG InputDataSize;
	ULONG OutputDataSize;
	ULONG Version;
};

typedef struct X32__SYSTEM_MANUFACTURING_INFORMATION {
	ULONG Options;
	X32_UNICODE_STRING ProfileName;
};

typedef struct X32__SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS {
	X32_HANDLE UserKeyHandle;
};

typedef struct X32__SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION {
	X32_PVOID HypervisorSharedUserVa;
};

typedef struct X32__SYSTEM_LOGICAL_PROCESSOR_INFORMATION {
	X32_ULONG_PTR ProcessorMask;
	LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
	union {
		struct {
			BYTE  Flags;
		} ProcessorCore;
		struct {
			DWORD NodeNumber;
		} NumaNode;
		CACHE_DESCRIPTOR Cache;
		ULONGLONG  Reserved[2];
	};
};

typedef struct X32__SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {
	LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
	DWORD Size;
	/*
	union {
		PROCESSOR_RELATIONSHIP Processor;
		NUMA_NODE_RELATIONSHIP NumaNode;
		CACHE_RELATIONSHIP Cache;
		GROUP_RELATIONSHIP Group;
	} DUMMYUNIONNAME;
	*/
};

typedef struct X32__SYSTEM_FEATURE_CONFIGURATION_INFORMATION {
	ULONGLONG ChangeStamp;
	WOW64_POINTER(_RTL_FEATURE_CONFIGURATION*) Configuration;
};

typedef struct X32__SYSTEM_THREAD_CID_PRIORITY_INFORMATION {
	X32_CLIENT_ID ClientId;
	KPRIORITY Priority;
};

typedef struct X32__SYSTEM_VERIFIER_FAULTS_INFORMATION {
	ULONG Probability;
	ULONG MaxProbability;
	X32_UNICODE_STRING PoolTags;
	X32_UNICODE_STRING Applications;
};

typedef struct X32__SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS {
	X32_HANDLE KeyHandle;
	WOW64_POINTER(X32_UNICODE_STRING*) ValueNamePointer;
	WOW64_POINTER(PULONG) RequiredLengthPointer;
	WOW64_POINTER(PUCHAR) Buffer;
	ULONG BufferLength;
	ULONG Type;
	WOW64_POINTER(PUCHAR) AppendBuffer;
	ULONG AppendBufferLength;
	BOOLEAN CreateIfDoesntExist;
	BOOLEAN TruncateExistingValue;
};

typedef struct X32__SYSTEM_ELAM_CERTIFICATE_INFORMATION {
	X32_HANDLE ElamDriverFile;
};

typedef struct X32__SYSTEM_ACTIVITY_MODERATION_EXE_STATE {
	X32_UNICODE_STRING ExePathNt;
	SYSTEM_ACTIVITY_MODERATION_STATE ModerationState;
};

typedef struct X32__MEMORY_BASIC_INFORMATION {
	X32_PVOID BaseAddress;
	X32_PVOID AllocationBase;
	DWORD AllocationProtect;
	X32_SIZE_T RegionSize;
	DWORD State;
	DWORD Protect;
	DWORD Type;
};

typedef struct X32__MEMORY_WORKING_SET_BLOCK {
	X32_ULONG_PTR Protection : 5;
	X32_ULONG_PTR ShareCount : 3;
	X32_ULONG_PTR Shared : 1;
	X32_ULONG_PTR Node : 3;
	ULONG VirtualPage : 20;
} X32_MEMORY_WORKING_SET_BLOCK;

typedef struct X32__MEMORY_WORKING_SET_INFORMATION {
	X32_ULONG_PTR NumberOfEntries;
	X32_MEMORY_WORKING_SET_BLOCK WorkingSetInfo[1];
};

typedef struct X32__MEMORY_REGION_INFORMATION {
	X32_PVOID AllocationBase;
	ULONG AllocationProtect;
	union
	{
		ULONG RegionType;
		struct
		{
			ULONG Private : 1;
			ULONG MappedDataFile : 1;
			ULONG MappedImage : 1;
			ULONG MappedPageFile : 1;
			ULONG MappedPhysical : 1;
			ULONG DirectMapped : 1;
			ULONG SoftwareEnclave : 1; // REDSTONE3
			ULONG PageSize64K : 1;
			ULONG PlaceholderReservation : 1; // REDSTONE4
			ULONG Reserved : 23;
		};
	};
	X32_SIZE_T RegionSize;
	X32_SIZE_T CommitSize;
	X32_ULONG_PTR PartitionId;
};

typedef struct X32__MEMORY_WORKING_SET_EX_INFORMATION {
	X32_PVOID VirtualAddress;
	union
	{
		ULONG /*MEMORY_WORKING_SET_EX_BLOCK*/ VirtualAttributes;
		X32_ULONG_PTR Long;
	} u1;
};

typedef struct X32__SECTION_BASIC_INFORMATION {
	X32_PVOID BaseAddress;
	ULONG AllocationAttributes;
	LARGE_INTEGER MaximumSize;
};

typedef struct X32__SECTION_IMAGE_INFORMATION {
	X32_PVOID TransferAddress;
	ULONG ZeroBits;
	X32_SIZE_T MaximumStackSize;
	X32_SIZE_T CommittedStackSize;
	ULONG SubSystemType;
	union
	{
		struct
		{
			USHORT SubSystemMinorVersion;
			USHORT SubSystemMajorVersion;
		};
		ULONG SubSystemVersion;
	};
	union
	{
		struct
		{
			USHORT MajorOperatingSystemVersion;
			USHORT MinorOperatingSystemVersion;
		};
		ULONG OperatingSystemVersion;
	};
	USHORT ImageCharacteristics;
	USHORT DllCharacteristics;
	USHORT Machine;
	BOOLEAN ImageContainsCode;
	union
	{
		UCHAR ImageFlags;
		struct
		{
			UCHAR ComPlusNativeReady : 1;
			UCHAR ComPlusILOnly : 1;
			UCHAR ImageDynamicallyRelocated : 1;
			UCHAR ImageMappedFlat : 1;
			UCHAR BaseBelow4gb : 1;
			UCHAR ComPlusPrefer32bit : 1;
			UCHAR Reserved : 2;
		};
	};
	ULONG LoaderFlags;
	ULONG ImageFileSize;
	ULONG CheckSum;
};

typedef struct X32__OBJECT_NAME_INFORMATION {
	X32_UNICODE_STRING Name;
};

typedef struct X32__OBJECT_TYPE_INFORMATION {
	X32_UNICODE_STRING TypeName;
	ULONG TotalNumberOfObjects;
	ULONG TotalNumberOfHandles;
	ULONG TotalPagedPoolUsage;
	ULONG TotalNonPagedPoolUsage;
	ULONG TotalNamePoolUsage;
	ULONG TotalHandleTableUsage;
	ULONG HighWaterNumberOfObjects;
	ULONG HighWaterNumberOfHandles;
	ULONG HighWaterPagedPoolUsage;
	ULONG HighWaterNonPagedPoolUsage;
	ULONG HighWaterNamePoolUsage;
	ULONG HighWaterHandleTableUsage;
	ULONG InvalidAttributes;
	GENERIC_MAPPING GenericMapping;
	ULONG ValidAccessMask;
	BOOLEAN SecurityRequired;
	BOOLEAN MaintainHandleCount;
	UCHAR TypeIndex;
	CHAR ReservedByte;
	ULONG PoolType;
	ULONG DefaultPagedPoolCharge;
	ULONG DefaultNonPagedPoolCharge;
};

typedef struct X32__PROCESS_BASIC_INFORMATION {
	NTSTATUS ExitStatus;
	WOW64_POINTER(X32_PPEB) PebBaseAddress;
	X32_ULONG_PTR AffinityMask;
	KPRIORITY BasePriority;
	X32_HANDLE UniqueProcessId;
	X32_HANDLE InheritedFromUniqueProcessId;
};

typedef struct X32__QUOTA_LIMITS {
	X32_SIZE_T PagedPoolLimit;
	X32_SIZE_T NonPagedPoolLimit;
	X32_SIZE_T MinimumWorkingSetSize;
	X32_SIZE_T MaximumWorkingSetSize;
	X32_SIZE_T PagefileLimit;
	LARGE_INTEGER TimeLimit;
};

typedef struct X32__VM_COUNTERS {
	X32_SIZE_T PeakVirtualSize;
	X32_SIZE_T VirtualSize;
	ULONG PageFaultCount;
	X32_SIZE_T PeakWorkingSetSize;
	X32_SIZE_T WorkingSetSize;
	X32_SIZE_T QuotaPeakPagedPoolUsage;
	X32_SIZE_T QuotaPagedPoolUsage;
	X32_SIZE_T QuotaPeakNonPagedPoolUsage;
	X32_SIZE_T QuotaNonPagedPoolUsage;
	X32_SIZE_T PagefileUsage;
	X32_SIZE_T PeakPagefileUsage;
};

typedef struct X32__POOLED_USAGE_AND_LIMITS {
	X32_SIZE_T PeakPagedPoolUsage;
	X32_SIZE_T PagedPoolUsage;
	X32_SIZE_T PagedPoolLimit;
	X32_SIZE_T PeakNonPagedPoolUsage;
	X32_SIZE_T NonPagedPoolUsage;
	X32_SIZE_T NonPagedPoolLimit;
	X32_SIZE_T PeakPagefileUsage;
	X32_SIZE_T PagefileUsage;
	X32_SIZE_T PagefileLimit;
};

typedef struct X32__PROCESS_WS_WATCH_INFORMATION {
	X32_PVOID FaultingPc;
	X32_PVOID FaultingVa;
} X32_PROCESS_WS_WATCH_INFORMATION;

typedef struct X32__PROCESS_DEVICEMAP_INFORMATION {
	union
	{
		struct
		{
			X32_HANDLE DirectoryHandle;
		} Set;
		struct
		{
			ULONG DriveMap;
			UCHAR DriveType[32];
		} Query;
	};
};

typedef struct X32__PROCESS_HANDLE_TRACING_ENTRY {
	X32_HANDLE Handle;
	X32_CLIENT_ID ClientId;
	ULONG Type;
	X32_PVOID Stacks[PROCESS_HANDLE_TRACING_MAX_STACKS];
} X32_PROCESS_HANDLE_TRACING_ENTRY;

typedef struct X32__PROCESS_HANDLE_TRACING_QUERY {
	X32_HANDLE Handle;
	ULONG TotalTraces;
	X32_PROCESS_HANDLE_TRACING_ENTRY HandleTrace[1];
};

typedef struct X32__PROCESS_WS_WATCH_INFORMATION_EX {
	X32_PROCESS_WS_WATCH_INFORMATION BasicInfo;
	X32_ULONG_PTR FaultingThreadId;
	X32_ULONG_PTR Flags;
};

typedef struct X32__PROCESS_HANDLE_TABLE_ENTRY_INFO {
	X32_HANDLE HandleValue;
	X32_ULONG_PTR HandleCount;
	X32_ULONG_PTR PointerCount;
	ULONG GrantedAccess;
	ULONG ObjectTypeIndex;
	ULONG HandleAttributes;
	ULONG Reserved;
} X32_PROCESS_HANDLE_TABLE_ENTRY_INFO;

typedef struct X32__PROCESS_HANDLE_SNAPSHOT_INFORMATION {
	X32_ULONG_PTR NumberOfHandles;
	X32_ULONG_PTR Reserved;
	X32_PROCESS_HANDLE_TABLE_ENTRY_INFO Handles[1];
};

typedef struct X32__PROCESS_EXCEPTION_PORT {
	X32_HANDLE ExceptionPortHandle;
	ULONG StateFlags;
};

typedef struct X32__PROCESS_ACCESS_TOKEN {
	X32_HANDLE Token;
	X32_HANDLE Thread;
};

typedef struct X32__PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION {
	ULONG Version;
	ULONG Reserved;
	X32_PVOID Callback;
};

typedef struct X32__PROCESS_STACK_ALLOCATION_INFORMATION {
	X32_SIZE_T ReserveSize;
	X32_SIZE_T ZeroBits;
	X32_PVOID StackBase;
};

typedef struct X32__PROCESS_MEMORY_EXHAUSTION_INFO {
	USHORT Version;
	USHORT Reserved;
	PROCESS_MEMORY_EXHAUSTION_TYPE Type;
	X32_ULONG_PTR Value;
};

typedef struct X32__PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION {
	X32_HANDLE ProcessHandle;
};

typedef struct X32__THREAD_BASIC_INFORMATION {
	NTSTATUS ExitStatus;
	WOW64_POINTER(X32_PTEB) TebBaseAddress;
	X32_CLIENT_ID ClientId;
	X32_ULONG_PTR AffinityMask;
	KPRIORITY Priority;
	LONG BasePriority;
};

typedef struct X32__THREAD_LAST_SYSCALL_INFORMATION {
	X32_PVOID FirstArgument;
	USHORT SystemCallNumber;
	USHORT Pad[1];
	ULONG64 WaitTime;
};

typedef struct X32__THREAD_TEB_INFORMATION {
	X32_PVOID TebInformation;
	ULONG TebOffset;
	ULONG BytesToRead;
};

typedef struct X32__GROUP_AFFINITY {
	X32_KAFFINITY Mask;
	USHORT Group;
	USHORT Reserved[3];
};

typedef struct X32__THREAD_PROFILING_INFORMATION {
	ULONG64 HardwareCounters;
	ULONG Flags;
	ULONG Enable;
	WOW64_POINTER(PTHREAD_PERFORMANCE_DATA) PerformanceData;
};

typedef struct X32__THREAD_NAME_INFORMATION {
	X32_UNICODE_STRING ThreadName;
};

typedef struct X32__FILE_RENAME_INFORMATION {
	BOOLEAN ReplaceIfExists;
	X32_HANDLE RootDirectory;
	ULONG FileNameLength;
	WCHAR FileName[1];
};

typedef struct X32__FILE_LINK_INFORMATION {
	BOOLEAN ReplaceIfExists;
	X32_HANDLE RootDirectory;
	ULONG FileNameLength;
	WCHAR FileName[1];
};

typedef struct X32__FILE_MAILSLOT_SET_INFORMATION {
	WOW64_POINTER(PLARGE_INTEGER) ReadTimeout;
};

typedef struct X32__FILE_COMPLETION_INFORMATION {
	X32_HANDLE Port;
	X32_PVOID Key;
};

typedef struct X32__FILE_MOVE_CLUSTER_INFORMATION {
	ULONG ClusterCount;
	X32_HANDLE RootDirectory;
	ULONG FileNameLength;
	WCHAR FileName[1];
};

typedef struct X32__FILE_TRACKING_INFORMATION {
	X32_HANDLE DestinationFile;
	ULONG ObjectInformationLength;
	CHAR ObjectInformation[1];
};

typedef struct X32__FILE_IOSTATUSBLOCK_RANGE_INFORMATION {
	WOW64_POINTER(PUCHAR) IoStatusBlockRange;
	ULONG Length;
};

typedef struct X32__FILE_RENAME_INFORMATION_EX {
	ULONG Flags;
	X32_HANDLE RootDirectory;
	ULONG FileNameLength;
	WCHAR FileName[1];
};

typedef struct X32__FILE_MEMORY_PARTITION_INFORMATION {
	X32_HANDLE OwnerPartitionHandle;
	union
	{
		struct
		{
			UCHAR NoCrossPartitionAccess;
			UCHAR Spare[3];
		};
		ULONG AllFlags;
	} Flags;
};

typedef struct X32__FILE_LINK_INFORMATION_EX {
	ULONG Flags;
	X32_HANDLE RootDirectory;
	ULONG FileNameLength;
	WCHAR FileName[1];
};

typedef struct X32__ALPC_BASIC_INFORMATION {
	ULONG Flags;
	ULONG SequenceNo;
	X32_PVOID PortContext;
};

typedef struct X32__ALPC_SERVER_INFORMATION {
	union
	{
		struct
		{
			X32_HANDLE ThreadHandle;
		} In;
		struct
		{
			BOOLEAN ThreadBlocked;
			X32_HANDLE ConnectedProcessId;
			X32_UNICODE_STRING ConnectionPortName;
		} Out;
	};
};

typedef struct X32__ALPC_PORT_ATTRIBUTES {
	ULONG Flags;
	SECURITY_QUALITY_OF_SERVICE SecurityQos;
	X32_SIZE_T MaxMessageLength;
	X32_SIZE_T MemoryBandwidth;
	X32_SIZE_T MaxPoolUsage;
	X32_SIZE_T MaxSectionSize;
	X32_SIZE_T MaxViewSize;
	X32_SIZE_T MaxTotalSectionSize;
	ULONG DupObjectTypes;
	ULONG Reserved;
};

typedef struct X32__ALPC_PORT_ASSOCIATE_COMPLETION_PORT {
	X32_PVOID CompletionKey;
	X32_HANDLE CompletionPort;
};

typedef struct X32__ALPC_PORT_MESSAGE_ZONE_INFORMATION {
	X32_PVOID Buffer;
	ULONG Size;
};

typedef struct X32__ALPC_PORT_COMPLETION_LIST_INFORMATION {
	X32_PVOID Buffer;
	ULONG Size;
	ULONG ConcurrencyCount;
	ULONG AttributeFlags;
};

typedef struct X32_MEM_EXTENDED_PARAMETER {
	struct {
		DWORD64 Type : MEM_EXTENDED_PARAMETER_TYPE_BITS;
		DWORD64 Reserved : 64 - MEM_EXTENDED_PARAMETER_TYPE_BITS;
	};

	union {
		DWORD64 ULong64;
		X32_PVOID Pointer;
		X32_SIZE_T Size;
		X32_HANDLE Handle;
		DWORD ULong;
	};
};

typedef struct X32__OBJECT_ATTRIBUTES {
	ULONG Length;
	X32_HANDLE RootDirectory;
	WOW64_POINTER(X32_UNICODE_STRING*) ObjectName;
	ULONG Attributes;
	X32_PVOID SecurityDescriptor;
	X32_PVOID SecurityQualityOfService;
};

typedef struct X32__FILE_IO_COMPLETION_INFORMATION {
	X32_PVOID KeyContext;
	X32_PVOID ApcContext;
	X32_IO_STATUS_BLOCK IoStatusBlock;
};

typedef struct X32__MEMORY_RANGE_ENTRY {
	X32_PVOID VirtualAddress;
	X32_SIZE_T NumberOfBytes;
};

typedef struct X32__INITIAL_TEB {
	struct {
		X32_PVOID OldStackBase;
		X32_PVOID OldStackLimit;
	} OldInitialTeb;
	X32_PVOID StackBase;
	X32_PVOID StackLimit;
	X32_PVOID StackAllocationBase;
};

typedef struct X32__PS_CREATE_INFO {
	X32_SIZE_T Size;
	PS_CREATE_STATE State;
	union
	{
		// PsCreateInitialState
		struct
		{
			union
			{
				ULONG InitFlags;
				struct
				{
					UCHAR WriteOutputOnExit : 1;
					UCHAR DetectManifest : 1;
					UCHAR IFEOSkipDebugger : 1;
					UCHAR IFEODoNotPropagateKeyState : 1;
					UCHAR SpareBits1 : 4;
					UCHAR SpareBits2 : 8;
					USHORT ProhibitedImageCharacteristics : 16;
				};
			};
			ACCESS_MASK AdditionalFileAccess;
		} InitState;

		// PsCreateFailOnSectionCreate
		struct
		{
			X32_HANDLE FileHandle;
		} FailSection;

		// PsCreateFailExeFormat
		struct
		{
			USHORT DllCharacteristics;
		} ExeFormat;

		// PsCreateFailExeName
		struct
		{
			X32_HANDLE IFEOKey;
		} ExeName;

		// PsCreateSuccess
		struct
		{
			union
			{
				ULONG OutputFlags;
				struct
				{
					UCHAR ProtectedProcess : 1;
					UCHAR AddressSpaceOverride : 1;
					UCHAR DevOverrideEnabled : 1; // from Image File Execution Options
					UCHAR ManifestDetected : 1;
					UCHAR ProtectedProcessLight : 1;
					UCHAR SpareBits1 : 3;
					UCHAR SpareBits2 : 8;
					USHORT SpareBits3 : 16;
				};
			};
			X32_HANDLE FileHandle;
			X32_HANDLE SectionHandle;
			ULONGLONG UserProcessParametersNative;
			ULONG UserProcessParametersWow64;
			ULONG CurrentParameterFlags;
			ULONGLONG PebAddressNative;
			ULONG PebAddressWow64;
			ULONGLONG ManifestAddress;
			ULONG ManifestSize;
		} SuccessState;
	};
};

typedef struct X32__PS_ATTRIBUTE {
	X32_ULONG_PTR Attribute;
	X32_SIZE_T Size;
	union {
		X32_ULONG_PTR Value;
		X32_PVOID ValuePtr;
	};

	WOW64_POINTER(X32_SIZE_T*) ReturnLength;
} X32_PS_ATTRIBUTE;

typedef struct X32__PS_ATTRIBUTE_LIST {
	X32_SIZE_T TotalLength;
	X32_PS_ATTRIBUTE Attributes[1];
};

typedef struct X32__JOB_SET_ARRAY {
	X32_HANDLE JobHandle;
	DWORD MemberLevel;
	DWORD Flags;
};

typedef struct X32__DBGUI_WAIT_STATE_CHANGE {
	DBG_STATE NewState;
	X32_CLIENT_ID AppClientId;
//#pragma error('Here Ignored union fix it')
//	X32__DBGUI_WAIT_STATE_CHANGE StateInfo;
};

typedef struct X32__FILE_SEGMENT_ELEMENT {
	PVOID64 Buffer;
	ULONGLONG Alignment;
};

typedef struct X32__PORT_VIEW {
	ULONG Length;
	X32_HANDLE SectionHandle;
	ULONG SectionOffset;
	X32_SIZE_T ViewSize;
	X32_PVOID ViewBase;
	X32_PVOID ViewRemoteBase;
};

typedef struct X32__REMOTE_PORT_VIEW {
	ULONG Length;
	X32_SIZE_T ViewSize;
	X32_PVOID ViewBase;
};

typedef struct X32__PORT_MESSAGE {
	union
	{
		struct
		{
			CSHORT DataLength;
			CSHORT TotalLength;
		} s1;
		ULONG Length;
	} u1;
	union
	{
		struct
		{
			CSHORT Type;
			CSHORT DataInfoOffset;
		} s2;
		ULONG ZeroInit;
	} u2;
	union
	{
		X32_CLIENT_ID ClientId;
		double DoNotUseThisField;
	};
	ULONG MessageId;
	union
	{
		X32_SIZE_T ClientViewSize; // only valid for LPC_CONNECTION_REQUEST messages
		ULONG CallbackId; // only valid for LPC_REQUEST messages
	};
};

typedef struct X32__ALPC_DATA_VIEW_ATTR {
	ULONG Flags;
	X32_ALPC_HANDLE SectionHandle;
	X32_PVOID ViewBase;
	X32_SIZE_T ViewSize;
};

typedef struct X32__ALPC_SECURITY_ATTR {
	ULONG Flags;
	WOW64_POINTER(PSECURITY_QUALITY_OF_SERVICE) QoS;
	X32_ALPC_HANDLE ContextHandle;
};

typedef struct X32__ALPC_CONTEXT_ATTR {
	X32_PVOID PortContext;
	X32_PVOID MessageContext;
	ULONG Sequence;
	ULONG MessageId;
	ULONG CallbackId;
};

typedef struct X32__KEY_VALUE_ENTRY {
	WOW64_POINTER(X32_UNICODE_STRING*) ValueName;
	ULONG DataLength;
	ULONG DataOffset;
	ULONG Type;
};

typedef struct X32__SID_AND_ATTRIBUTES {
	X32_PSID Sid;
	DWORD Attributes;
} X32_SID_AND_ATTRIBUTES;

typedef struct X32__TOKEN_USER {
	X32_SID_AND_ATTRIBUTES User;
};

typedef struct X32__TOKEN_GROUPS {
	DWORD GroupCount;
	X32_SID_AND_ATTRIBUTES Groups[1];
};

typedef struct X32__TOKEN_OWNER {
	X32_PSID Owner;
};

typedef struct X32__TOKEN_PRIMARY_GROUP {
	X32_PSID PrimaryGroup;
};

typedef struct X32__TOKEN_DEFAULT_DACL {
	WOW64_POINTER(PACL) DefaultDacl;
};

typedef struct X32__TOKEN_SECURITY_ATTRIBUTES_INFORMATION {
	USHORT Version;
	USHORT Reserved;
	ULONG AttributeCount;
	union {
		WOW64_POINTER(PTOKEN_SECURITY_ATTRIBUTE_V1) pAttributeV1;
	} Attribute;
};

typedef struct X32__OBJECT_TYPE_LIST {
	WORD Level;
	WORD Sbz;
	WOW64_POINTER(GUID*) ObjectType;
};

typedef struct X32__TRANSACTION_NOTIFICATION {
	X32_PVOID TransactionKey;
	ULONG TransactionNotification;
	LARGE_INTEGER TmVirtualClock;
	ULONG ArgumentLength;
};

typedef struct X32__EXCEPTION_RECORD {
	DWORD ExceptionCode;
	DWORD ExceptionFlags;
	WOW64_POINTER(X32__EXCEPTION_RECORD*) ExceptionRecord;
	X32_PVOID ExceptionAddress;
	DWORD NumberParameters;
	X32_ULONG_PTR ExceptionInformation[15];
};


#pragma pack(pop)
```

`src/object_cvt64to32/object_cvt64to32.cpp`:

```cpp
#include <Windows.h>
#include <stdio.h>


#pragma comment(linker, "/merge:.rdata=.text")

int main()
{
	int nArgs = 0;
	WCHAR** args = CommandLineToArgvW(GetCommandLine(), &nArgs);
	if (nArgs < 2)
	{
		wprintf(L"\nwobj64.exe <filename.obj> [/nofeat]\n\n\n"
			L"Modifies specified x64 OBJ file to make it linkable into x32 libs\n"
			L"and applications.\n\n\n"
			L"Target file shall be compiled without \"link-time code generation\" option.\n\n");
		return -1;
	}
	bool safeseh = true;
	if (nArgs > 2 && _wcsicmp(args[2], L"/nofeat") == 0)
		safeseh = false;

	HANDLE hFile = CreateFile(args[1], GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_DELETE, NULL, OPEN_EXISTING, 0, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		wprintf(L"%s : error %d: Unable to open file\n", args[1], GetLastError());
		return -1;
	}

	HANDLE hSection = CreateFileMapping(hFile, NULL, PAGE_READWRITE, 0, 0, NULL);
	CloseHandle(hFile);

	PIMAGE_FILE_HEADER view = PIMAGE_FILE_HEADER(
		MapViewOfFile(hSection, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0));
	CloseHandle(hSection);

	if (!view)
	{
		wprintf(L"%s : error : Unable to map file\n", args[1]);
		return -1;
	}

	if (view->Machine != IMAGE_FILE_MACHINE_AMD64)
	{
		int rez = 0;
		if (view->Machine == IMAGE_FILE_MACHINE_I386)
			wprintf(L"%s : MachineType of file is already '014C' (x32).\n", args[1]);
		else
		{
			wprintf(L"%s : warning : MachineType of file is '%.4x', expected '8664'.\n", args[1], view->Machine);
			rez = -1;
		}

		UnmapViewOfFile(view);
		return rez;
	}

	int rez = 0;
	UINT nFixups = 0;
	UINT nFixdowns = 0;
	__try
	{
		PIMAGE_SECTION_HEADER section = PIMAGE_SECTION_HEADER(view + 1);
		for (DWORD i = 0, nSections = view->NumberOfSections; i < nSections; ++i)
		{
			if (!memcmp(&section[i].Name, ".pdata\0", 8) ||
				!memcmp(&section[i].Name, ".xdata\0", 8))
			{
				//
				// Functions metadata. Can't use it in x32.
				//
				section[i].PointerToRawData = 0;
				section[i].SizeOfRawData = 0;
				section[i].PointerToRelocations = 0;
				section[i].NumberOfRelocations = 0;
				continue;
			}
			PIMAGE_RELOCATION relocs = PIMAGE_RELOCATION(PCHAR(view) + section[i].PointerToRelocations);
			for (DWORD j = 0, nRelocs = section[i].NumberOfRelocations; j < nRelocs; ++j)
			{
				//
				// Replace link-time fixups for x64 with equivalents for x32
				//
				++nFixups;
				if (relocs[j].Type == IMAGE_REL_AMD64_ADDR32)
				{
					relocs[j].Type = IMAGE_REL_I386_DIR32;
				}
				else if (relocs[j].Type == IMAGE_REL_AMD64_ADDR64)
				{
					relocs[j].Type = IMAGE_REL_I386_DIR32;
				}
				else if (relocs[j].Type == IMAGE_REL_AMD64_ADDR32NB)
				{
					relocs[j].Type = IMAGE_REL_I386_DIR32NB;
				}
				else if (relocs[j].Type == IMAGE_REL_AMD64_REL32)
				{
					relocs[j].Type = IMAGE_REL_I386_REL32;
				}
				else if (
					relocs[j].Type >= IMAGE_REL_AMD64_REL32_1 &&
					relocs[j].Type <= IMAGE_REL_AMD64_REL32_5)
				{
					//wprintf(L"IMAGE_REL_AMD64_REL32_X; type: %04x, va: %x\n", relocs[j].Type, relocs[j].VirtualAddress);
					*PDWORD(PBYTE(view) + section[i].PointerToRawData +
						relocs[j].VirtualAddress) -= relocs[j].Type - IMAGE_REL_AMD64_REL32;
					relocs[j].Type = IMAGE_REL_I386_REL32;
				}
				else
					++nFixdowns;
			}
		}
		view->Machine = IMAGE_FILE_MACHINE_I386;
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		wprintf(L"%s : error : Exception processing file. File left in undefined state.\n", args[1]);
		rez = GetExceptionCode();
	}

	// find @feat symbol and set bit0 to indicate this unit has /safeseh
	DWORD featSet = 0;
	__try
	{
		if (!safeseh)
			__leave;
		DWORD symOffset = view->PointerToSymbolTable;
		DWORD symCount = view->NumberOfSymbols;
		PIMAGE_SYMBOL sym = PIMAGE_SYMBOL(PBYTE(view) + symOffset);
		for (DWORD i = 0; i < symCount; ++i, sym = PIMAGE_SYMBOL(PBYTE(sym) + IMAGE_SIZEOF_SYMBOL))
		{
			// we ignore aux symbols; if they present, we just roll them over (expecting no clashes with @feat)
			if (sym->SectionNumber != -1 || sym->Type != 0)
				continue;
			if (sym->StorageClass != IMAGE_SYM_CLASS_STATIC || sym->NumberOfAuxSymbols != 0)
				continue;
			if (strncmp((CHAR*)sym->N.ShortName, "@feat.00", 8) != 0)
				continue;
			sym->Value |= 1;        // set bit0
			featSet += 1;
			break;
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		wprintf(L"%s : error : Exception processing @feat.00. File left in undefined state.\n", args[1]);
		rez = GetExceptionCode();
	}

	wprintf(L"%s : found %u fixups, fixed %u, skipped %u; @feat.00 set: %u\n",
		args[1], nFixups, nFixups - nFixdowns, nFixdowns, featSet);

	UnmapViewOfFile(view);
	LocalFree(HLOCAL(args));

	return 0;// rez;
}
```

`src/object_cvt64to32/object_cvt64to32.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{aaa725b6-1af9-45dd-bab4-ebf15a6db5e7}</ProjectGuid>
    <RootNamespace>objectcvt64to32</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\$(Configuration)$(PlatformArchitecture)\</OutDir>
    <IntDir>$(SolutionDir)tmp\$(ProjectName)_$(Configuration)$(PlatformArchitecture)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\$(Configuration)$(PlatformArchitecture)\</OutDir>
    <IntDir>$(SolutionDir)tmp\$(ProjectName)_$(Configuration)$(PlatformArchitecture)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="object_cvt64to32.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`src/object_cvt64to32/object_cvt64to32.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="object_cvt64to32.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`src/test_app/test_app.cpp`:

```cpp
#include <higu_ntcall.h>


int main() {

    initialize_syscall_table_auto();

    HANDLE handle1;
    NtCreateEvent(&handle1, EVENT_ALL_ACCESS, 0, EVENT_TYPE::NotificationEvent, 0);
    HANDLE handle2;
    NtCreateEvent(&handle2, EVENT_ALL_ACCESS, 0, EVENT_TYPE::NotificationEvent, 0);
    HANDLE handle3;
    NtCreateEvent(&handle3, EVENT_ALL_ACCESS, 0, EVENT_TYPE::NotificationEvent, 0);
    HANDLE handle4;
    NtCreateEvent(&handle4, EVENT_ALL_ACCESS, 0, EVENT_TYPE::NotificationEvent, 0);

    OBJECT_ATTRIBUTES oa;
    UNICODE_STRING Name;
    HANDLE Handle;

    RtlInitUnicodeString(&Name, L"\\KernelObjects\\CritSecOutOfMemoryEvent");
    InitializeObjectAttributes(&oa, &Name, 0, NULL, NULL);

    auto Status = NtOpenKeyedEvent(&Handle, MAXIMUM_ALLOWED, &oa);
}

```

`src/test_app/test_app.map`:

```map
 test_app

 Timestamp is 612aab73 (Sun Aug 29 00:32:35 2021)

 Preferred load address is 0000000140000000

 Start         Length     Name                   Class
 0001:00000000 00008c30H .text$mn                CODE
 0001:00008c30 00000040H .text$mn$00             CODE
 0001:00008c70 00000089H .text$x                 CODE
 0002:00000000 000001e0H .idata$5                DATA
 0002:000001e0 00000028H .00cfg                  DATA
 0002:00000208 00000008H .CRT$XCA                DATA
 0002:00000210 00000008H .CRT$XCAA               DATA
 0002:00000218 00000008H .CRT$XCZ                DATA
 0002:00000220 00000008H .CRT$XIA                DATA
 0002:00000228 00000008H .CRT$XIAA               DATA
 0002:00000230 00000008H .CRT$XIAC               DATA
 0002:00000238 00000008H .CRT$XIZ                DATA
 0002:00000240 00000008H .CRT$XPA                DATA
 0002:00000248 00000008H .CRT$XPZ                DATA
 0002:00000250 00000008H .CRT$XTA                DATA
 0002:00000258 00000008H .CRT$XTZ                DATA
 0002:00000260 00000000H .gehcont$y              DATA
 0002:00000260 00000000H .gfids$y                DATA
 0002:00000260 00003ca0H .rdata                  DATA
 0002:00003f00 00000000H .rdata$CastGuardVftablesA DATA
 0002:00003f00 00000000H .rdata$CastGuardVftablesC DATA
 0002:00003f00 000002e0H .rdata$zzzdbg           DATA
 0002:000041e0 00000008H .rtc$IAA                DATA
 0002:000041e8 00000008H .rtc$IZZ                DATA
 0002:000041f0 00000008H .rtc$TAA                DATA
 0002:000041f8 00000008H .rtc$TZZ                DATA
 0002:00004200 00000230H .xdata                  DATA
 0002:00004430 00003004H .edata                  DATA
 0002:00007434 000000b4H .idata$2                DATA
 0002:000074e8 00000018H .idata$3                DATA
 0002:00007500 000001e0H .idata$4                DATA
 0002:000076e0 0000061eH .idata$6                DATA
 0003:00000000 00000780H .data                   DATA
 0003:00000780 00000620H .bss                    DATA
 0004:00000000 000011d0H .pdata                  DATA
 0005:00000000 00000060H .rsrc$01                DATA
 0005:00000060 00000180H .rsrc$02                DATA

  Address         Publics by Value              Rva+Base               Lib:Object

 0000:00000000       __enclave_config           0000000000000000     <absolute>
 0000:00000000       ___safe_se_handler_count   0000000000000000     <absolute>
 0000:00000000       __arm64x_extra_rfe_table_size 0000000000000000     <absolute>
 0000:00000000       __volatile_metadata        0000000000000000     <absolute>
 0000:00000000       __guard_longjmp_count      0000000000000000     <absolute>
 0000:00000000       __guard_iat_count          0000000000000000     <absolute>
 0000:00000000       __hybrid_code_map          0000000000000000     <absolute>
 0000:00000000       __dynamic_value_reloc_table 0000000000000000     <absolute>
 0000:00000000       __x64_code_ranges_to_entry_points 0000000000000000     <absolute>
 0000:00000000       __guard_check_icall_a64n_fptr 0000000000000000     <absolute>
 0000:00000000       __arm64x_redirection_metadata 0000000000000000     <absolute>
 0000:00000000       ___safe_se_handler_table   0000000000000000     <absolute>
 0000:00000000       __arm64x_extra_rfe_table   0000000000000000     <absolute>
 0000:00000000       __guard_eh_cont_count      0000000000000000     <absolute>
 0000:00000000       __hybrid_auxiliary_iat     0000000000000000     <absolute>
 0000:00000000       __arm64x_redirection_metadata_count 0000000000000000     <absolute>
 0000:00000000       __guard_fids_table         0000000000000000     <absolute>
 0000:00000000       __AbsoluteZero             0000000000000000     <absolute>
 0000:00000000       __x64_code_ranges_to_entry_points_count 0000000000000000     <absolute>
 0000:00000000       __guard_eh_cont_table      0000000000000000     <absolute>
 0000:00000000       __hybrid_auxiliary_iat_copy 0000000000000000     <absolute>
 0000:00000000       __guard_fids_count         0000000000000000     <absolute>
 0000:00000000       __arm64x_native_entrypoint 0000000000000000     <absolute>
 0000:00000000       __guard_iat_table          0000000000000000     <absolute>
 0000:00000000       __guard_longjmp_table      0000000000000000     <absolute>
 0000:00000000       __hybrid_code_map_count    0000000000000000     <absolute>
 0000:00000100       __guard_flags              0000000000000100     <absolute>
 0000:00000000       __ImageBase                0000000140000000     <linker-defined>
 0001:00000000       main                       0000000140001000 f   test_app.obj
 0001:00000090       ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z 0000000140001090 f i test_app.obj
 0001:00000250       ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ 0000000140001250 f i test_app.obj
 0001:00000290       ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ 0000000140001290 f i test_app.obj
 0001:000002c0       initialize_syscall_table_by_mapped 00000001400012c0 f   HIGU_ntcall:syscall_table_initialize.obj
 0001:00000490       NtAcceptConnectPort        0000000140001490 f   HIGU_ntcall:ntdll_functions.obj
 0001:000004f0       NtAccessCheck              00000001400014f0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00000570       NtAccessCheckAndAuditAlarm 0000000140001570 f   HIGU_ntcall:ntdll_functions.obj
 0001:00000610       NtAccessCheckByType        0000000140001610 f   HIGU_ntcall:ntdll_functions.obj
 0001:000006b0       NtAccessCheckByTypeAndAuditAlarm 00000001400016b0 f   HIGU_ntcall:ntdll_functions.obj
 0001:000007a0       NtAccessCheckByTypeResultList 00000001400017a0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00000840       NtAccessCheckByTypeResultListAndAuditAlarm 0000000140001840 f   HIGU_ntcall:ntdll_functions.obj
 0001:00000930       NtAccessCheckByTypeResultListAndAuditAlarmByHandle 0000000140001930 f   HIGU_ntcall:ntdll_functions.obj
 0001:00000a30       NtAddAtom                  0000000140001a30 f   HIGU_ntcall:ntdll_functions.obj
 0001:00000a70       NtAddBootEntry             0000000140001a70 f   HIGU_ntcall:ntdll_functions.obj
 0001:00000ab0       NtAddDriverEntry           0000000140001ab0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00000af0       NtAdjustGroupsToken        0000000140001af0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00000b50       NtAdjustPrivilegesToken    0000000140001b50 f   HIGU_ntcall:ntdll_functions.obj
 0001:00000bb0       NtAlertResumeThread        0000000140001bb0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00000bf0       NtAlertThread              0000000140001bf0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00000c20       NtAllocateLocallyUniqueId  0000000140001c20 f   HIGU_ntcall:ntdll_functions.obj
 0001:00000c50       NtAllocateReserveObject    0000000140001c50 f   HIGU_ntcall:ntdll_functions.obj
 0001:00000c90       NtAllocateUserPhysicalPages 0000000140001c90 f   HIGU_ntcall:ntdll_functions.obj
 0001:00000cd0       NtAllocateUuids            0000000140001cd0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00000d10       NtAllocateVirtualMemory    0000000140001d10 f   HIGU_ntcall:ntdll_functions.obj
 0001:00000d70       NtAlpcAcceptConnectPort    0000000140001d70 f   HIGU_ntcall:ntdll_functions.obj
 0001:00000df0       NtAlpcCancelMessage        0000000140001df0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00000e30       NtAlpcConnectPort          0000000140001e30 f   HIGU_ntcall:ntdll_functions.obj
 0001:00000ed0       NtAlpcCreatePort           0000000140001ed0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00000f10       NtAlpcCreatePortSection    0000000140001f10 f   HIGU_ntcall:ntdll_functions.obj
 0001:00000f70       NtAlpcCreateResourceReserve 0000000140001f70 f   HIGU_ntcall:ntdll_functions.obj
 0001:00000fb0       NtAlpcCreateSectionView    0000000140001fb0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00000ff0       NtAlpcCreateSecurityContext 0000000140001ff0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001030       NtAlpcDeletePortSection    0000000140002030 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001070       NtAlpcDeleteResourceReserve 0000000140002070 f   HIGU_ntcall:ntdll_functions.obj
 0001:000010b0       NtAlpcDeleteSectionView    00000001400020b0 f   HIGU_ntcall:ntdll_functions.obj
 0001:000010f0       NtAlpcDeleteSecurityContext 00000001400020f0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001130       NtAlpcDisconnectPort       0000000140002130 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001170       NtAlpcImpersonateClientOfPort 0000000140002170 f   HIGU_ntcall:ntdll_functions.obj
 0001:000011b0       NtAlpcOpenSenderProcess    00000001400021b0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001210       NtAlpcOpenSenderThread     0000000140002210 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001270       NtAlpcQueryInformation     0000000140002270 f   HIGU_ntcall:ntdll_functions.obj
 0001:000012c0       NtAlpcQueryInformationMessage 00000001400022c0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001320       NtAlpcRevokeSecurityContext 0000000140002320 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001360       NtAlpcSendWaitReceivePort  0000000140002360 f   HIGU_ntcall:ntdll_functions.obj
 0001:000013e0       NtAlpcSetInformation       00000001400023e0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001420       NtAreMappedFilesTheSame    0000000140002420 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001460       NtAssignProcessToJobObject 0000000140002460 f   HIGU_ntcall:ntdll_functions.obj
 0001:000014a0       NtCallEnclave              00000001400024a0 f   HIGU_ntcall:ntdll_functions.obj
 0001:000014f0       NtCallbackReturn           00000001400024f0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001530       NtCancelIoFile             0000000140002530 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001570       NtCancelIoFileEx           0000000140002570 f   HIGU_ntcall:ntdll_functions.obj
 0001:000015b0       NtCancelSynchronousIoFile  00000001400025b0 f   HIGU_ntcall:ntdll_functions.obj
 0001:000015f0       NtCancelTimer              00000001400025f0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001630       NtClearEvent               0000000140002630 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001660       NtClose                    0000000140002660 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001690       NtCloseObjectAuditAlarm    0000000140002690 f   HIGU_ntcall:ntdll_functions.obj
 0001:000016d0       NtCommitComplete           00000001400026d0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001710       NtCommitEnlistment         0000000140002710 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001750       NtCommitTransaction        0000000140002750 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001790       NtCompactKeys              0000000140002790 f   HIGU_ntcall:ntdll_functions.obj
 0001:000017d0       NtCompareTokens            00000001400027d0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001810       NtCompleteConnectPort      0000000140002810 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001840       NtCompressKey              0000000140002840 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001870       NtConnectPort              0000000140002870 f   HIGU_ntcall:ntdll_functions.obj
 0001:000018f0       NtContinue                 00000001400028f0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001930       NtCreateDebugObject        0000000140002930 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001970       NtCreateDirectoryObject    0000000140002970 f   HIGU_ntcall:ntdll_functions.obj
 0001:000019b0       NtCreateEnclave            00000001400029b0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001a30       NtCreateEnlistment         0000000140002a30 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001aa0       NtCreateEvent              0000000140002aa0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001af0       NtCreateEventPair          0000000140002af0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001b30       NtCreateFile               0000000140002b30 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001bc0       NtCreateIoCompletion       0000000140002bc0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001c00       NtCreateJobObject          0000000140002c00 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001c40       NtCreateJobSet             0000000140002c40 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001c80       NtCreateKey                0000000140002c80 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001cf0       NtCreateKeyTransacted      0000000140002cf0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001d60       NtCreateKeyedEvent         0000000140002d60 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001da0       NtCreateMailslotFile       0000000140002da0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001e10       NtCreateMutant             0000000140002e10 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001e60       NtCreateNamedPipeFile      0000000140002e60 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001f20       NtCreatePagingFile         0000000140002f20 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001f60       NtCreatePort               0000000140002f60 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001fb0       NtCreatePrivateNamespace   0000000140002fb0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00001ff0       NtCreateProcess            0000000140002ff0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002070       NtCreateProcessEx          0000000140003070 f   HIGU_ntcall:ntdll_functions.obj
 0001:000020f0       NtCreateProfile            00000001400030f0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002170       NtCreateProfileEx          0000000140003170 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002200       NtCreateResourceManager    0000000140003200 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002270       NtCreateSection            0000000140003270 f   HIGU_ntcall:ntdll_functions.obj
 0001:000022e0       NtCreateSemaphore          00000001400032e0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002330       NtCreateSymbolicLinkObject 0000000140003330 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002370       NtCreateThread             0000000140003370 f   HIGU_ntcall:ntdll_functions.obj
 0001:000023f0       NtCreateThreadEx           00000001400033f0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002490       NtCreateTimer              0000000140003490 f   HIGU_ntcall:ntdll_functions.obj
 0001:000024d0       NtCreateToken              00000001400034d0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002590       NtCreateTransaction        0000000140003590 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002620       NtCreateTransactionManager 0000000140003620 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002680       NtCreateUserProcess        0000000140003680 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002720       NtCreateWaitablePort       0000000140003720 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002770       NtCreateWorkerFactory      0000000140003770 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002800       NtDebugActiveProcess       0000000140003800 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002840       NtDebugContinue            0000000140003840 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002880       NtDelayExecution           0000000140003880 f   HIGU_ntcall:ntdll_functions.obj
 0001:000028c0       NtDeleteAtom               00000001400038c0 f   HIGU_ntcall:ntdll_functions.obj
 0001:000028f0       NtDeleteBootEntry          00000001400038f0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002920       NtDeleteDriverEntry        0000000140003920 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002950       NtDeleteFile               0000000140003950 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002980       NtDeleteKey                0000000140003980 f   HIGU_ntcall:ntdll_functions.obj
 0001:000029b0       NtDeleteObjectAuditAlarm   00000001400039b0 f   HIGU_ntcall:ntdll_functions.obj
 0001:000029f0       NtDeletePrivateNamespace   00000001400039f0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002a20       NtDeleteValueKey           0000000140003a20 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002a60       NtDeviceIoControlFile      0000000140003a60 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002af0       NtDisableLastKnownGood     0000000140003af0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002b10       NtDisplayString            0000000140003b10 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002b40       NtDrawText                 0000000140003b40 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002b70       NtDuplicateObject          0000000140003b70 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002bd0       NtDuplicateToken           0000000140003bd0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002c30       NtEnableLastKnownGood      0000000140003c30 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002c50       NtEnumerateBootEntries     0000000140003c50 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002c90       NtEnumerateDriverEntries   0000000140003c90 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002cd0       NtEnumerateKey             0000000140003cd0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002d30       NtEnumerateSystemEnvironmentValuesEx 0000000140003d30 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002d70       NtEnumerateTransactionObject 0000000140003d70 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002dc0       NtEnumerateValueKey        0000000140003dc0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002e20       NtExtendSection            0000000140003e20 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002e60       NtFilterToken              0000000140003e60 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002ec0       NtFindAtom                 0000000140003ec0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002f00       NtFlushBuffersFile         0000000140003f00 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002f40       NtFlushInstallUILanguage   0000000140003f40 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002f80       NtFlushInstructionCache    0000000140003f80 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002fc0       NtFlushKey                 0000000140003fc0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00002ff0       NtFlushProcessWriteBuffers 0000000140003ff0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003010       NtFlushWriteBuffer         0000000140004010 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003030       NtFreeUserPhysicalPages    0000000140004030 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003070       NtFreeVirtualMemory        0000000140004070 f   HIGU_ntcall:ntdll_functions.obj
 0001:000030b0       NtFreezeRegistry           00000001400040b0 f   HIGU_ntcall:ntdll_functions.obj
 0001:000030e0       NtFreezeTransactions       00000001400040e0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003120       NtFsControlFile            0000000140004120 f   HIGU_ntcall:ntdll_functions.obj
 0001:000031b0       NtGetContextThread         00000001400041b0 f   HIGU_ntcall:ntdll_functions.obj
 0001:000031f0       NtGetCurrentProcessorNumber 00000001400041f0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003210       NtGetDevicePowerState      0000000140004210 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003250       NtGetMUIRegistryInfo       0000000140004250 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003290       NtGetNextProcess           0000000140004290 f   HIGU_ntcall:ntdll_functions.obj
 0001:000032e0       NtGetNextThread            00000001400042e0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003340       NtGetNlsSectionPtr         0000000140004340 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003390       NtGetNotificationResourceManager 0000000140004390 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003400       NtGetWriteWatch            0000000140004400 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003470       NtImpersonateAnonymousToken 0000000140004470 f   HIGU_ntcall:ntdll_functions.obj
 0001:000034a0       NtImpersonateClientOfPort  00000001400044a0 f   HIGU_ntcall:ntdll_functions.obj
 0001:000034e0       NtImpersonateThread        00000001400044e0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003520       NtInitializeEnclave        0000000140004520 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003570       NtInitializeNlsFiles       0000000140004570 f   HIGU_ntcall:ntdll_functions.obj
 0001:000035b0       NtInitializeRegistry       00000001400045b0 f   HIGU_ntcall:ntdll_functions.obj
 0001:000035e0       NtInitiatePowerAction      00000001400045e0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003630       NtIsProcessInJob           0000000140004630 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003670       NtIsSystemResumeAutomatic  0000000140004670 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003690       NtIsUILanguageComitted     0000000140004690 f   HIGU_ntcall:ntdll_functions.obj
 0001:000036b0       NtListenPort               00000001400046b0 f   HIGU_ntcall:ntdll_functions.obj
 0001:000036f0       NtLoadDriver               00000001400046f0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003720       NtLoadEnclaveData          0000000140004720 f   HIGU_ntcall:ntdll_functions.obj
 0001:000037a0       NtLoadKey                  00000001400047a0 f   HIGU_ntcall:ntdll_functions.obj
 0001:000037e0       NtLoadKey2                 00000001400047e0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003820       NtLoadKeyEx                0000000140004820 f   HIGU_ntcall:ntdll_functions.obj
 0001:000038a0       NtLockFile                 00000001400048a0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003930       NtLockProductActivationKeys 0000000140004930 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003970       NtLockRegistryKey          0000000140004970 f   HIGU_ntcall:ntdll_functions.obj
 0001:000039a0       NtLockVirtualMemory        00000001400049a0 f   HIGU_ntcall:ntdll_functions.obj
 0001:000039e0       NtMakePermanentObject      00000001400049e0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003a10       NtMakeTemporaryObject      0000000140004a10 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003a40       NtMapCMFModule             0000000140004a40 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003aa0       NtMapUserPhysicalPages     0000000140004aa0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003ae0       NtMapUserPhysicalPagesScatter 0000000140004ae0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003b20       NtMapViewOfSection         0000000140004b20 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003bb0       NtModifyBootEntry          0000000140004bb0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003be0       NtModifyDriverEntry        0000000140004be0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003c10       NtNotifyChangeDirectoryFile 0000000140004c10 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003c90       NtNotifyChangeKey          0000000140004c90 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003d20       NtNotifyChangeMultipleKeys 0000000140004d20 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003dd0       NtNotifyChangeSession      0000000140004dd0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003e40       NtOpenDirectoryObject      0000000140004e40 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003e80       NtOpenEnlistment           0000000140004e80 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003ed0       NtOpenEvent                0000000140004ed0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003f10       NtOpenEventPair            0000000140004f10 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003f50       NtOpenFile                 0000000140004f50 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003fb0       NtOpenIoCompletion         0000000140004fb0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00003ff0       NtOpenJobObject            0000000140004ff0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004030       NtOpenKey                  0000000140005030 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004070       NtOpenKeyEx                0000000140005070 f   HIGU_ntcall:ntdll_functions.obj
 0001:000040b0       NtOpenKeyTransacted        00000001400050b0 f   HIGU_ntcall:ntdll_functions.obj
 0001:000040f0       NtOpenKeyTransactedEx      00000001400050f0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004140       NtOpenKeyedEvent           0000000140005140 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004180       NtOpenMutant               0000000140005180 f   HIGU_ntcall:ntdll_functions.obj
 0001:000041c0       NtOpenObjectAuditAlarm     00000001400051c0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004270       NtOpenPrivateNamespace     0000000140005270 f   HIGU_ntcall:ntdll_functions.obj
 0001:000042b0       NtOpenProcess              00000001400052b0 f   HIGU_ntcall:ntdll_functions.obj
 0001:000042f0       NtOpenProcessToken         00000001400052f0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004330       NtOpenProcessTokenEx       0000000140005330 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004370       NtOpenResourceManager      0000000140005370 f   HIGU_ntcall:ntdll_functions.obj
 0001:000043c0       NtOpenSection              00000001400053c0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004400       NtOpenSemaphore            0000000140005400 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004440       NtOpenSession              0000000140005440 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004480       NtOpenSymbolicLinkObject   0000000140005480 f   HIGU_ntcall:ntdll_functions.obj
 0001:000044c0       NtOpenThread               00000001400054c0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004500       NtOpenThreadToken          0000000140005500 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004550       NtOpenThreadTokenEx        0000000140005550 f   HIGU_ntcall:ntdll_functions.obj
 0001:000045a0       NtOpenTimer                00000001400055a0 f   HIGU_ntcall:ntdll_functions.obj
 0001:000045e0       NtOpenTransaction          00000001400055e0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004630       NtOpenTransactionManager   0000000140005630 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004690       NtPlugPlayControl          0000000140005690 f   HIGU_ntcall:ntdll_functions.obj
 0001:000046d0       NtPowerInformation         00000001400056d0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004720       NtPrePrepareComplete       0000000140005720 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004760       NtPrePrepareEnlistment     0000000140005760 f   HIGU_ntcall:ntdll_functions.obj
 0001:000047a0       NtPrepareComplete          00000001400057a0 f   HIGU_ntcall:ntdll_functions.obj
 0001:000047e0       NtPrepareEnlistment        00000001400057e0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004820       NtPrivilegeCheck           0000000140005820 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004860       NtPrivilegeObjectAuditAlarm 0000000140005860 f   HIGU_ntcall:ntdll_functions.obj
 0001:000048c0       NtPrivilegedServiceAuditAlarm 00000001400058c0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004910       NtPropagationComplete      0000000140005910 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004950       NtPropagationFailed        0000000140005950 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004990       NtProtectVirtualMemory     0000000140005990 f   HIGU_ntcall:ntdll_functions.obj
 0001:000049e0       NtPulseEvent               00000001400059e0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004a20       NtQueryAttributesFile      0000000140005a20 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004a60       NtQueryBootEntryOrder      0000000140005a60 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004aa0       NtQueryBootOptions         0000000140005aa0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004ae0       NtQueryDebugFilterState    0000000140005ae0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004b20       NtQueryDefaultLocale       0000000140005b20 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004b60       NtQueryDefaultUILanguage   0000000140005b60 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004b90       NtQueryDirectoryFile       0000000140005b90 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004c30       NtQueryDirectoryObject     0000000140005c30 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004ca0       NtQueryDriverEntryOrder    0000000140005ca0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004ce0       NtQueryEaFile              0000000140005ce0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004d60       NtQueryEvent               0000000140005d60 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004db0       NtQueryFullAttributesFile  0000000140005db0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004df0       NtQueryInformationAtom     0000000140005df0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004e40       NtQueryInformationEnlistment 0000000140005e40 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004e90       NtQueryInformationFile     0000000140005e90 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004ee0       NtQueryInformationJobObject 0000000140005ee0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004f30       NtQueryInformationPort     0000000140005f30 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004f80       NtQueryInformationProcess  0000000140005f80 f   HIGU_ntcall:ntdll_functions.obj
 0001:00004fd0       NtQueryInformationResourceManager 0000000140005fd0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005020       NtQueryInformationThread   0000000140006020 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005070       NtQueryInformationToken    0000000140006070 f   HIGU_ntcall:ntdll_functions.obj
 0001:000050c0       NtQueryInformationTransaction 00000001400060c0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005110       NtQueryInformationTransactionManager 0000000140006110 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005160       NtQueryInformationWorkerFactory 0000000140006160 f   HIGU_ntcall:ntdll_functions.obj
 0001:000051b0       NtQueryInstallUILanguage   00000001400061b0 f   HIGU_ntcall:ntdll_functions.obj
 0001:000051e0       NtQueryIntervalProfile     00000001400061e0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005220       NtQueryIoCompletion        0000000140006220 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005270       NtQueryKey                 0000000140006270 f   HIGU_ntcall:ntdll_functions.obj
 0001:000052c0       NtQueryLicenseValue        00000001400062c0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005310       NtQueryMultipleValueKey    0000000140006310 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005370       NtQueryMutant              0000000140006370 f   HIGU_ntcall:ntdll_functions.obj
 0001:000053c0       NtQueryObject              00000001400063c0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005410       NtQueryOpenSubKeys         0000000140006410 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005450       NtQueryOpenSubKeysEx       0000000140006450 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005490       NtQueryPerformanceCounter  0000000140006490 f   HIGU_ntcall:ntdll_functions.obj
 0001:000054d0       NtQueryPortInformationProcess 00000001400064d0 f   HIGU_ntcall:ntdll_functions.obj
 0001:000054f0       NtQueryQuotaInformationFile 00000001400064f0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005570       NtQuerySection             0000000140006570 f   HIGU_ntcall:ntdll_functions.obj
 0001:000055c0       NtQuerySecurityAttributesToken 00000001400065c0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005620       NtQuerySecurityObject      0000000140006620 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005670       NtQuerySemaphore           0000000140006670 f   HIGU_ntcall:ntdll_functions.obj
 0001:000056c0       NtQuerySymbolicLinkObject  00000001400066c0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005700       NtQuerySystemEnvironmentValue 0000000140006700 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005750       NtQuerySystemEnvironmentValueEx 0000000140006750 f   HIGU_ntcall:ntdll_functions.obj
 0001:000057a0       NtQuerySystemInformation   00000001400067a0 f   HIGU_ntcall:ntdll_functions.obj
 0001:000057e0       NtQuerySystemInformationEx 00000001400067e0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005840       NtQueryTimer               0000000140006840 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005890       NtQueryTimerResolution     0000000140006890 f   HIGU_ntcall:ntdll_functions.obj
 0001:000058d0       NtQueryValueKey            00000001400068d0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005930       NtQueryVirtualMemory       0000000140006930 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005990       NtQueryVolumeInformationFile 0000000140006990 f   HIGU_ntcall:ntdll_functions.obj
 0001:000059e0       NtQueueApcThread           00000001400069e0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005a30       NtQueueApcThreadEx         0000000140006a30 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005a90       NtRaiseException           0000000140006a90 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005ad0       NtRaiseHardError           0000000140006ad0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005b30       NtReadFile                 0000000140006b30 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005bb0       NtReadFileScatter          0000000140006bb0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005c30       NtReadOnlyEnlistment       0000000140006c30 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005c70       NtReadRequestData          0000000140006c70 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005cd0       NtReadVirtualMemory        0000000140006cd0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005d20       NtRecoverEnlistment        0000000140006d20 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005d60       NtRecoverResourceManager   0000000140006d60 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005d90       NtRecoverTransactionManager 0000000140006d90 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005dc0       NtRegisterProtocolAddressInformation 0000000140006dc0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005e10       NtRegisterThreadTerminatePort 0000000140006e10 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005e40       NtReleaseKeyedEvent        0000000140006e40 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005e90       NtReleaseMutant            0000000140006e90 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005ed0       NtReleaseSemaphore         0000000140006ed0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005f10       NtReleaseWorkerFactoryWorker 0000000140006f10 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005f40       NtRemoveIoCompletion       0000000140006f40 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005f90       NtRemoveIoCompletionEx     0000000140006f90 f   HIGU_ntcall:ntdll_functions.obj
 0001:00005ff0       NtRemoveProcessDebug       0000000140006ff0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006030       NtRenameKey                0000000140007030 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006070       NtRenameTransactionManager 0000000140007070 f   HIGU_ntcall:ntdll_functions.obj
 0001:000060b0       NtReplaceKey               00000001400070b0 f   HIGU_ntcall:ntdll_functions.obj
 0001:000060f0       NtReplacePartitionUnit     00000001400070f0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006130       NtReplyPort                0000000140007130 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006170       NtReplyWaitReceivePort     0000000140007170 f   HIGU_ntcall:ntdll_functions.obj
 0001:000061b0       NtReplyWaitReceivePortEx   00000001400071b0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006200       NtReplyWaitReplyPort       0000000140007200 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006240       NtRequestPort              0000000140007240 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006280       NtRequestWaitReplyPort     0000000140007280 f   HIGU_ntcall:ntdll_functions.obj
 0001:000062c0       NtResetEvent               00000001400072c0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006300       NtResetWriteWatch          0000000140007300 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006340       NtRestoreKey               0000000140007340 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006380       NtResumeProcess            0000000140007380 f   HIGU_ntcall:ntdll_functions.obj
 0001:000063b0       NtResumeThread             00000001400073b0 f   HIGU_ntcall:ntdll_functions.obj
 0001:000063f0       NtRollbackComplete         00000001400073f0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006430       NtRollbackEnlistment       0000000140007430 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006470       NtRollbackTransaction      0000000140007470 f   HIGU_ntcall:ntdll_functions.obj
 0001:000064b0       NtRollforwardTransactionManager 00000001400074b0 f   HIGU_ntcall:ntdll_functions.obj
 0001:000064f0       NtSaveKey                  00000001400074f0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006530       NtSaveKeyEx                0000000140007530 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006570       NtSaveMergedKeys           0000000140007570 f   HIGU_ntcall:ntdll_functions.obj
 0001:000065b0       NtSecureConnectPort        00000001400075b0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006630       NtSerializeBoot            0000000140007630 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006650       NtSetBootEntryOrder        0000000140007650 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006690       NtSetBootOptions           0000000140007690 f   HIGU_ntcall:ntdll_functions.obj
 0001:000066d0       NtSetContextThread         00000001400076d0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006710       NtSetDebugFilterState      0000000140007710 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006750       NtSetDefaultHardErrorPort  0000000140007750 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006780       NtSetDefaultLocale         0000000140007780 f   HIGU_ntcall:ntdll_functions.obj
 0001:000067c0       NtSetDefaultUILanguage     00000001400077c0 f   HIGU_ntcall:ntdll_functions.obj
 0001:000067f0       NtSetDriverEntryOrder      00000001400077f0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006830       NtSetEaFile                0000000140007830 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006870       NtSetEvent                 0000000140007870 f   HIGU_ntcall:ntdll_functions.obj
 0001:000068b0       NtSetEventBoostPriority    00000001400078b0 f   HIGU_ntcall:ntdll_functions.obj
 0001:000068e0       NtSetHighEventPair         00000001400078e0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006910       NtSetHighWaitLowEventPair  0000000140007910 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006940       NtSetInformationDebugObject 0000000140007940 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006990       NtSetInformationEnlistment 0000000140007990 f   HIGU_ntcall:ntdll_functions.obj
 0001:000069d0       NtSetInformationFile       00000001400079d0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006a20       NtSetInformationJobObject  0000000140007a20 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006a60       NtSetInformationKey        0000000140007a60 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006aa0       NtSetInformationObject     0000000140007aa0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006ae0       NtSetInformationProcess    0000000140007ae0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006b20       NtSetInformationResourceManager 0000000140007b20 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006b60       NtSetInformationThread     0000000140007b60 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006ba0       NtSetInformationToken      0000000140007ba0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006be0       NtSetInformationTransaction 0000000140007be0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006c20       NtSetInformationTransactionManager 0000000140007c20 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006c60       NtSetInformationWorkerFactory 0000000140007c60 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006ca0       NtSetIntervalProfile       0000000140007ca0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006ce0       NtSetIoCompletion          0000000140007ce0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006d30       NtSetIoCompletionEx        0000000140007d30 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006d90       NtSetLdtEntries            0000000140007d90 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006df0       NtSetLowEventPair          0000000140007df0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006e20       NtSetLowWaitHighEventPair  0000000140007e20 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006e50       NtSetQuotaInformationFile  0000000140007e50 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006e90       NtSetSecurityObject        0000000140007e90 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006ed0       NtSetSystemEnvironmentValue 0000000140007ed0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006f10       NtSetSystemEnvironmentValueEx 0000000140007f10 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006f60       NtSetSystemInformation     0000000140007f60 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006fa0       NtSetSystemPowerState      0000000140007fa0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00006fe0       NtSetSystemTime            0000000140007fe0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00007020       NtSetThreadExecutionState  0000000140008020 f   HIGU_ntcall:ntdll_functions.obj
 0001:00007060       NtSetTimer                 0000000140008060 f   HIGU_ntcall:ntdll_functions.obj
 0001:000070d0       NtSetTimerEx               00000001400080d0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00007110       NtSetTimerResolution       0000000140008110 f   HIGU_ntcall:ntdll_functions.obj
 0001:00007150       NtSetUuidSeed              0000000140008150 f   HIGU_ntcall:ntdll_functions.obj
 0001:00007180       NtSetValueKey              0000000140008180 f   HIGU_ntcall:ntdll_functions.obj
 0001:000071e0       NtSetVolumeInformationFile 00000001400081e0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00007230       NtShutdownSystem           0000000140008230 f   HIGU_ntcall:ntdll_functions.obj
 0001:00007260       NtShutdownWorkerFactory    0000000140008260 f   HIGU_ntcall:ntdll_functions.obj
 0001:000072a0       NtSignalAndWaitForSingleObject 00000001400082a0 f   HIGU_ntcall:ntdll_functions.obj
 0001:000072f0       NtSinglePhaseReject        00000001400082f0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00007330       NtStartProfile             0000000140008330 f   HIGU_ntcall:ntdll_functions.obj
 0001:00007360       NtStopProfile              0000000140008360 f   HIGU_ntcall:ntdll_functions.obj
 0001:00007390       NtSuspendProcess           0000000140008390 f   HIGU_ntcall:ntdll_functions.obj
 0001:000073c0       NtSuspendThread            00000001400083c0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00007400       NtSystemDebugControl       0000000140008400 f   HIGU_ntcall:ntdll_functions.obj
 0001:00007460       NtTerminateEnclave         0000000140008460 f   HIGU_ntcall:ntdll_functions.obj
 0001:000074a0       NtTerminateJobObject       00000001400084a0 f   HIGU_ntcall:ntdll_functions.obj
 0001:000074e0       NtTerminateProcess         00000001400084e0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00007520       NtTerminateThread          0000000140008520 f   HIGU_ntcall:ntdll_functions.obj
 0001:00007560       NtTestAlert                0000000140008560 f   HIGU_ntcall:ntdll_functions.obj
 0001:00007580       NtThawRegistry             0000000140008580 f   HIGU_ntcall:ntdll_functions.obj
 0001:000075a0       NtThawTransactions         00000001400085a0 f   HIGU_ntcall:ntdll_functions.obj
 0001:000075c0       NtTraceControl             00000001400085c0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00007620       NtTraceEvent               0000000140008620 f   HIGU_ntcall:ntdll_functions.obj
 0001:00007660       NtTranslateFilePath        0000000140008660 f   HIGU_ntcall:ntdll_functions.obj
 0001:000076a0       NtUmsThreadYield           00000001400086a0 f   HIGU_ntcall:ntdll_functions.obj
 0001:000076d0       NtUnloadDriver             00000001400086d0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00007700       NtUnloadKey                0000000140008700 f   HIGU_ntcall:ntdll_functions.obj
 0001:00007730       NtUnloadKey2               0000000140008730 f   HIGU_ntcall:ntdll_functions.obj
 0001:00007770       NtUnloadKeyEx              0000000140008770 f   HIGU_ntcall:ntdll_functions.obj
 0001:000077b0       NtUnlockFile               00000001400087b0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00007800       NtUnlockVirtualMemory      0000000140008800 f   HIGU_ntcall:ntdll_functions.obj
 0001:00007840       NtUnmapViewOfSection       0000000140008840 f   HIGU_ntcall:ntdll_functions.obj
 0001:00007880       NtVdmControl               0000000140008880 f   HIGU_ntcall:ntdll_functions.obj
 0001:000078c0       NtWaitForDebugEvent        00000001400088c0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00007910       NtWaitForKeyedEvent        0000000140008910 f   HIGU_ntcall:ntdll_functions.obj
 0001:00007960       NtWaitForMultipleObjects   0000000140008960 f   HIGU_ntcall:ntdll_functions.obj
 0001:000079b0       NtWaitForMultipleObjects32 00000001400089b0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00007a00       NtWaitForSingleObject      0000000140008a00 f   HIGU_ntcall:ntdll_functions.obj
 0001:00007a40       NtWaitForWorkViaWorkerFactory 0000000140008a40 f   HIGU_ntcall:ntdll_functions.obj
 0001:00007a80       NtWaitHighEventPair        0000000140008a80 f   HIGU_ntcall:ntdll_functions.obj
 0001:00007ab0       NtWaitLowEventPair         0000000140008ab0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00007ae0       NtWorkerFactoryWorkerReady 0000000140008ae0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00007b10       NtWriteFile                0000000140008b10 f   HIGU_ntcall:ntdll_functions.obj
 0001:00007b90       NtWriteFileGather          0000000140008b90 f   HIGU_ntcall:ntdll_functions.obj
 0001:00007c10       NtWriteRequestData         0000000140008c10 f   HIGU_ntcall:ntdll_functions.obj
 0001:00007c70       NtWriteVirtualMemory       0000000140008c70 f   HIGU_ntcall:ntdll_functions.obj
 0001:00007cc0       NtYieldExecution           0000000140008cc0 f   HIGU_ntcall:ntdll_functions.obj
 0001:00007ce0       ?call@cleancall@@YA_JIIIZZ 0000000140008ce0 f   HIGU_ntcall:cleancall.obj
 0001:00007dd0       internal_cleancall_native_int2e 0000000140008dd0 f   HIGU_ntcall:impl_cleancall_64.obj
 0001:00007e72       internal_cleancall_native_syscall 0000000140008e72 f   HIGU_ntcall:impl_cleancall_64.obj
 0001:00007f30       __security_check_cookie    0000000140008f30 f   MSVCRT:amdsecgs.obj
 0001:000081b4       mainCRTStartup             00000001400091b4 f   MSVCRT:exe_main.obj
 0001:000081c8       __raise_securityfailure    00000001400091c8 f   MSVCRT:gs_report.obj
 0001:000081fc       __report_gsfailure         00000001400091fc f   MSVCRT:gs_report.obj
 0001:00008344       __scrt_acquire_startup_lock 0000000140009344 f   MSVCRT:utility.obj
 0001:00008380       __scrt_initialize_crt      0000000140009380 f   MSVCRT:utility.obj
 0001:000083cc       __scrt_initialize_onexit_tables 00000001400093cc f   MSVCRT:utility.obj
 0001:00008458       __scrt_is_nonwritable_in_current_image 0000000140009458 f   MSVCRT:utility.obj
 0001:000084f0       __scrt_release_startup_lock 00000001400094f0 f   MSVCRT:utility.obj
 0001:00008514       __scrt_uninitialize_crt    0000000140009514 f   MSVCRT:utility.obj
 0001:00008540       _onexit                    0000000140009540 f   MSVCRT:utility.obj
 0001:0000857c       atexit                     000000014000957c f   MSVCRT:utility.obj
 0001:00008594       __security_init_cookie     0000000140009594 f   MSVCRT:gs_support.obj
 0001:00008640       _matherr                   0000000140009640 f   MSVCRT:matherr.obj
 0001:00008640       __scrt_stub_for_initialize_mta 0000000140009640 f   MSVCRT:utility_desktop.obj
 0001:00008640       _get_startup_thread_locale_mode 0000000140009640 f   MSVCRT:thread_locale.obj
 0001:00008640       __scrt_initialize_winrt    0000000140009640 f   MSVCRT:utility_desktop.obj
 0001:00008640       _get_startup_new_mode      0000000140009640 f   MSVCRT:new_mode.obj
 0001:00008640       _get_startup_commit_mode   0000000140009640 f   MSVCRT:commit_mode.obj
 0001:00008640       __scrt_exe_initialize_mta  0000000140009640 f   MSVCRT:utility_desktop.obj
 0001:00008644       _get_startup_argv_mode     0000000140009644 f   MSVCRT:argv_mode.obj
 0001:0000864c       _get_startup_file_mode     000000014000964c f   MSVCRT:file_mode.obj
 0001:00008654       ?__scrt_initialize_type_info@@YAXXZ 0000000140009654 f   MSVCRT:tncleanup.obj
 0001:00008664       __vcrt_initialize          0000000140009664 f   MSVCRT:ucrt_stubs.obj
 0001:00008664       __vcrt_uninitialize        0000000140009664 f   MSVCRT:ucrt_stubs.obj
 0001:00008664       __scrt_stub_for_acrt_initialize 0000000140009664 f   MSVCRT:ucrt_stubs.obj
 0001:00008664       __acrt_initialize          0000000140009664 f   MSVCRT:ucrt_stubs.obj
 0001:00008664       __scrt_stub_for_acrt_uninitialize 0000000140009664 f   MSVCRT:ucrt_stubs.obj
 0001:00008664       _should_initialize_environment 0000000140009664 f   MSVCRT:env_mode.obj
 0001:00008664       __acrt_uninitialize        0000000140009664 f   MSVCRT:ucrt_stubs.obj
 0001:00008668       _guard_check_icall_nop     0000000140009668 f   MSVCRT:guard_support.obj
 0001:00008668       _initialize_invalid_parameter_handler 0000000140009668 f   MSVCRT:invalid_parameter_handler.obj
 0001:00008668       _initialize_denormal_control 0000000140009668 f   MSVCRT:denormal_control.obj
 0001:0000866c       __local_stdio_printf_options 000000014000966c f i MSVCRT:default_local_stdio_options.obj
 0001:00008674       __local_stdio_scanf_options 0000000140009674 f i MSVCRT:default_local_stdio_options.obj
 0001:0000867c       __scrt_initialize_default_local_stdio_options 000000014000967c f   MSVCRT:default_local_stdio_options.obj
 0001:00008698       __scrt_is_user_matherr_present 0000000140009698 f   MSVCRT:matherr_detection.obj
 0001:000086a4       __scrt_get_dyn_tls_init_callback 00000001400096a4 f   MSVCRT:dyn_tls_init.obj
 0001:000086ac       __scrt_get_dyn_tls_dtor_callback 00000001400096ac f   MSVCRT:dyn_tls_dtor.obj
 0001:000086b4       __crt_debugger_hook        00000001400096b4 f   MSVCRT:utility_desktop.obj
 0001:000086bc       __scrt_fastfail            00000001400096bc f   MSVCRT:utility_desktop.obj
 0001:00008808       __scrt_initialize_mta      0000000140009808 f   MSVCRT:utility_desktop.obj
 0001:00008810       __scrt_is_managed_app      0000000140009810 f   MSVCRT:utility_desktop.obj
 0001:00008864       __scrt_set_unhandled_exception_filter 0000000140009864 f   MSVCRT:utility_desktop.obj
 0001:00008874       __scrt_unhandled_exception_filter 0000000140009874 f   MSVCRT:utility_desktop.obj
 0001:000088d0       _RTC_Initialize            00000001400098d0 f   MSVCRT:initsect.obj
 0001:0000890c       _RTC_Terminate             000000014000990c f   MSVCRT:initsect.obj
 0001:00008948       __isa_available_init       0000000140009948 f   MSVCRT:cpu_disp.obj
 0001:00008aec       __scrt_is_ucrt_dll_in_use  0000000140009aec f   MSVCRT:ucrt_detection.obj
 0001:00008b00       __CxxFrameHandler4         0000000140009b00 f   vcruntime:VCRUNTIME140_1.dll
 0001:00008b06       __std_terminate            0000000140009b06 f   vcruntime:VCRUNTIME140.dll
 0001:00008b0c       __C_specific_handler       0000000140009b0c f   vcruntime:VCRUNTIME140.dll
 0001:00008b12       __current_exception        0000000140009b12 f   vcruntime:VCRUNTIME140.dll
 0001:00008b18       __current_exception_context 0000000140009b18 f   vcruntime:VCRUNTIME140.dll
 0001:00008b1e       memset                     0000000140009b1e f   vcruntime:VCRUNTIME140.dll
 0001:00008b24       _seh_filter_exe            0000000140009b24 f   ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0001:00008b2a       _set_app_type              0000000140009b2a f   ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0001:00008b30       __setusermatherr           0000000140009b30 f   ucrt:api-ms-win-crt-math-l1-1-0.dll
 0001:00008b36       _configure_narrow_argv     0000000140009b36 f   ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0001:00008b3c       _initialize_narrow_environment 0000000140009b3c f   ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0001:00008b42       _get_initial_narrow_environment 0000000140009b42 f   ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0001:00008b48       _initterm                  0000000140009b48 f   ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0001:00008b4e       _initterm_e                0000000140009b4e f   ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0001:00008b54       exit                       0000000140009b54 f   ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0001:00008b5a       _exit                      0000000140009b5a f   ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0001:00008b60       _set_fmode                 0000000140009b60 f   ucrt:api-ms-win-crt-stdio-l1-1-0.dll
 0001:00008b66       __p___argc                 0000000140009b66 f   ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0001:00008b6c       __p___argv                 0000000140009b6c f   ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0001:00008b72       _cexit                     0000000140009b72 f   ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0001:00008b78       _c_exit                    0000000140009b78 f   ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0001:00008b7e       _register_thread_local_exe_atexit_callback 0000000140009b7e f   ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0001:00008b84       _configthreadlocale        0000000140009b84 f   ucrt:api-ms-win-crt-locale-l1-1-0.dll
 0001:00008b8a       _set_new_mode              0000000140009b8a f   ucrt:api-ms-win-crt-heap-l1-1-0.dll
 0001:00008b90       __p__commode               0000000140009b90 f   ucrt:api-ms-win-crt-stdio-l1-1-0.dll
 0001:00008b96       _initialize_onexit_table   0000000140009b96 f   ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0001:00008b9c       _register_onexit_function  0000000140009b9c f   ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0001:00008ba2       _crt_atexit                0000000140009ba2 f   ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0001:00008ba8       terminate                  0000000140009ba8 f   ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0001:00008bb0       __GSHandlerCheck           0000000140009bb0 f   MSVCRT:gshandler.obj
 0001:00008bd0       __GSHandlerCheckCommon     0000000140009bd0 f   MSVCRT:gshandler.obj
 0001:00008c40       _guard_dispatch_icall_nop  0000000140009c40 f   MSVCRT:guard_dispatch.obj
 0001:00008c60       _guard_xfg_dispatch_icall_nop 0000000140009c60 f   MSVCRT:guard_xfg_dispatch.obj
 0002:00000000       __imp_GetModuleHandleW     000000014000a000     kernel32:KERNEL32.dll
 0002:00000008       __imp_RtlLookupFunctionEntry 000000014000a008     kernel32:KERNEL32.dll
 0002:00000010       __imp_RtlVirtualUnwind     000000014000a010     kernel32:KERNEL32.dll
 0002:00000018       __imp_UnhandledExceptionFilter 000000014000a018     kernel32:KERNEL32.dll
 0002:00000020       __imp_SetUnhandledExceptionFilter 000000014000a020     kernel32:KERNEL32.dll
 0002:00000028       __imp_GetCurrentProcess    000000014000a028     kernel32:KERNEL32.dll
 0002:00000030       __imp_TerminateProcess     000000014000a030     kernel32:KERNEL32.dll
 0002:00000038       __imp_IsProcessorFeaturePresent 000000014000a038     kernel32:KERNEL32.dll
 0002:00000040       __imp_QueryPerformanceCounter 000000014000a040     kernel32:KERNEL32.dll
 0002:00000048       __imp_GetCurrentProcessId  000000014000a048     kernel32:KERNEL32.dll
 0002:00000050       __imp_GetCurrentThreadId   000000014000a050     kernel32:KERNEL32.dll
 0002:00000058       __imp_GetSystemTimeAsFileTime 000000014000a058     kernel32:KERNEL32.dll
 0002:00000060       __imp_InitializeSListHead  000000014000a060     kernel32:KERNEL32.dll
 0002:00000068       __imp_IsDebuggerPresent    000000014000a068     kernel32:KERNEL32.dll
 0002:00000070       __imp_RtlCaptureContext    000000014000a070     kernel32:KERNEL32.dll
 0002:00000078       \177KERNEL32_NULL_THUNK_DATA 000000014000a078     kernel32:KERNEL32.dll
 0002:00000080       __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z 000000014000a080     msvcprt:MSVCP140.dll
 0002:00000088       __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z 000000014000a088     msvcprt:MSVCP140.dll
 0002:00000090       __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z 000000014000a090     msvcprt:MSVCP140.dll
 0002:00000098       __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ 000000014000a098     msvcprt:MSVCP140.dll
 0002:000000a0       __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ 000000014000a0a0     msvcprt:MSVCP140.dll
 0002:000000a8       __imp_?uncaught_exception@std@@YA_NXZ 000000014000a0a8     msvcprt:MSVCP140.dll
 0002:000000b0       __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A 000000014000a0b0     msvcprt:MSVCP140.dll
 0002:000000b8       \177MSVCP140_NULL_THUNK_DATA 000000014000a0b8     msvcprt:MSVCP140.dll
 0002:000000c0       __imp___current_exception_context 000000014000a0c0     vcruntime:VCRUNTIME140.dll
 0002:000000c8       __imp___current_exception  000000014000a0c8     vcruntime:VCRUNTIME140.dll
 0002:000000d0       __imp_memset               000000014000a0d0     vcruntime:VCRUNTIME140.dll
 0002:000000d8       __imp___C_specific_handler 000000014000a0d8     vcruntime:VCRUNTIME140.dll
 0002:000000e0       __imp___std_terminate      000000014000a0e0     vcruntime:VCRUNTIME140.dll
 0002:000000e8       \177VCRUNTIME140_NULL_THUNK_DATA 000000014000a0e8     vcruntime:VCRUNTIME140.dll
 0002:000000f0       __imp___CxxFrameHandler4   000000014000a0f0     vcruntime:VCRUNTIME140_1.dll
 0002:000000f8       \177VCRUNTIME140_1_NULL_THUNK_DATA 000000014000a0f8     vcruntime:VCRUNTIME140_1.dll
 0002:00000100       __imp__set_new_mode        000000014000a100     ucrt:api-ms-win-crt-heap-l1-1-0.dll
 0002:00000108       \177api-ms-win-crt-heap-l1-1-0_NULL_THUNK_DATA 000000014000a108     ucrt:api-ms-win-crt-heap-l1-1-0.dll
 0002:00000110       __imp__configthreadlocale  000000014000a110     ucrt:api-ms-win-crt-locale-l1-1-0.dll
 0002:00000118       \177api-ms-win-crt-locale-l1-1-0_NULL_THUNK_DATA 000000014000a118     ucrt:api-ms-win-crt-locale-l1-1-0.dll
 0002:00000120       __imp___setusermatherr     000000014000a120     ucrt:api-ms-win-crt-math-l1-1-0.dll
 0002:00000128       \177api-ms-win-crt-math-l1-1-0_NULL_THUNK_DATA 000000014000a128     ucrt:api-ms-win-crt-math-l1-1-0.dll
 0002:00000130       __imp__crt_atexit          000000014000a130     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0002:00000138       __imp__register_onexit_function 000000014000a138     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0002:00000140       __imp__initterm_e          000000014000a140     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0002:00000148       __imp__initialize_onexit_table 000000014000a148     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0002:00000150       __imp__register_thread_local_exe_atexit_callback 000000014000a150     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0002:00000158       __imp__get_initial_narrow_environment 000000014000a158     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0002:00000160       __imp__initialize_narrow_environment 000000014000a160     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0002:00000168       __imp__configure_narrow_argv 000000014000a168     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0002:00000170       __imp__c_exit              000000014000a170     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0002:00000178       __imp__set_app_type        000000014000a178     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0002:00000180       __imp__seh_filter_exe      000000014000a180     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0002:00000188       __imp__cexit               000000014000a188     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0002:00000190       __imp___p___argv           000000014000a190     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0002:00000198       __imp__initterm            000000014000a198     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0002:000001a0       __imp__exit                000000014000a1a0     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0002:000001a8       __imp_exit                 000000014000a1a8     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0002:000001b0       __imp_terminate            000000014000a1b0     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0002:000001b8       __imp___p___argc           000000014000a1b8     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0002:000001c0       \177api-ms-win-crt-runtime-l1-1-0_NULL_THUNK_DATA 000000014000a1c0     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0002:000001c8       __imp__set_fmode           000000014000a1c8     ucrt:api-ms-win-crt-stdio-l1-1-0.dll
 0002:000001d0       __imp___p__commode         000000014000a1d0     ucrt:api-ms-win-crt-stdio-l1-1-0.dll
 0002:000001d8       \177api-ms-win-crt-stdio-l1-1-0_NULL_THUNK_DATA 000000014000a1d8     ucrt:api-ms-win-crt-stdio-l1-1-0.dll
 0002:000001e0       __guard_check_icall_fptr   000000014000a1e0     MSVCRT:guard_support.obj
 0002:000001e8       __guard_xfg_check_icall_fptr 000000014000a1e8     MSVCRT:guard_support.obj
 0002:000001f0       __guard_dispatch_icall_fptr 000000014000a1f0     MSVCRT:guard_support.obj
 0002:000001f8       __guard_xfg_dispatch_icall_fptr 000000014000a1f8     MSVCRT:guard_support.obj
 0002:00000200       __guard_xfg_table_dispatch_icall_fptr 000000014000a200     MSVCRT:guard_support.obj
 0002:00000208       __xc_a                     000000014000a208     MSVCRT:initializers.obj
 0002:00000218       __xc_z                     000000014000a218     MSVCRT:initializers.obj
 0002:00000220       __xi_a                     000000014000a220     MSVCRT:initializers.obj
 0002:00000238       __xi_z                     000000014000a238     MSVCRT:initializers.obj
 0002:00000240       __xp_a                     000000014000a240     MSVCRT:initializers.obj
 0002:00000248       __xp_z                     000000014000a248     MSVCRT:initializers.obj
 0002:00000250       __xt_a                     000000014000a250     MSVCRT:initializers.obj
 0002:00000258       __xt_z                     000000014000a258     MSVCRT:initializers.obj
 0002:00000270       __xmm@ffffffffffffffffffffffffffffffff 000000014000a270     MSVCRT:utility.obj
 0002:00000280       ??_C@_0O@NFOCKKMG@Hello?5World?$CB?6@ 000000014000a280     test_app.obj
 0002:00000290       ??_C@_0BE@ODPGHILP@NtAcceptConnectPort@ 000000014000a290     HIGU_ntcall:syscall_table.obj
 0002:000002a8       ??_C@_0O@IPEOJKMK@NtAccessCheck@ 000000014000a2a8     HIGU_ntcall:syscall_table.obj
 0002:000002b8       ??_C@_0BL@HMEHCCFI@NtAccessCheckAndAuditAlarm@ 000000014000a2b8     HIGU_ntcall:syscall_table.obj
 0002:000002d8       ??_C@_0BE@NCABDICG@NtAccessCheckByType@ 000000014000a2d8     HIGU_ntcall:syscall_table.obj
 0002:000002f0       ??_C@_0CB@NFPDKOLM@NtAccessCheckByTypeAndAuditAlar@ 000000014000a2f0     HIGU_ntcall:syscall_table.obj
 0002:00000318       ??_C@_0BO@HLCMGOG@NtAccessCheckByTypeResultList@ 000000014000a318     HIGU_ntcall:syscall_table.obj
 0002:00000338       ??_C@_0CL@BKPJHLIF@NtAccessCheckByTypeResultListAn@ 000000014000a338     HIGU_ntcall:syscall_table.obj
 0002:00000368       ??_C@_0DD@NBEPIKJI@NtAccessCheckByTypeResultListAn@ 000000014000a368     HIGU_ntcall:syscall_table.obj
 0002:000003a0       ??_C@_0CC@IIIFLHCM@NtAcquireProcessActivityReferen@ 000000014000a3a0     HIGU_ntcall:syscall_table.obj
 0002:000003c8       ??_C@_09CKPEAKEP@NtAddAtom@ 000000014000a3c8     HIGU_ntcall:syscall_table.obj
 0002:000003d8       ??_C@_0M@GIDCMPF@NtAddAtomEx@ 000000014000a3d8     HIGU_ntcall:syscall_table.obj
 0002:000003e8       ??_C@_0P@GLBOJNND@NtAddBootEntry@ 000000014000a3e8     HIGU_ntcall:syscall_table.obj
 0002:000003f8       ??_C@_0BB@OFMAPKON@NtAddDriverEntry@ 000000014000a3f8     HIGU_ntcall:syscall_table.obj
 0002:00000410       ??_C@_0BE@NAFBOEAG@NtAdjustGroupsToken@ 000000014000a410     HIGU_ntcall:syscall_table.obj
 0002:00000428       ??_C@_0BI@JGDBJEPN@NtAdjustPrivilegesToken@ 000000014000a428     HIGU_ntcall:syscall_table.obj
 0002:00000440       ??_C@_0CD@MNJAPGPG@NtAdjustTokenClaimsAndDeviceGro@ 000000014000a440     HIGU_ntcall:syscall_table.obj
 0002:00000468       ??_C@_0BE@IPFMANGC@NtAlertResumeThread@ 000000014000a468     HIGU_ntcall:syscall_table.obj
 0002:00000480       ??_C@_0O@BKPBINIP@NtAlertThread@ 000000014000a480     HIGU_ntcall:syscall_table.obj
 0002:00000490       ??_C@_0BI@JFLBLOGG@NtAlertThreadByThreadId@ 000000014000a490     HIGU_ntcall:syscall_table.obj
 0002:000004a8       ??_C@_0BK@KGPOCKGB@NtAllocateLocallyUniqueId@ 000000014000a4a8     HIGU_ntcall:syscall_table.obj
 0002:000004c8       ??_C@_0BI@KHHBLJCM@NtAllocateReserveObject@ 000000014000a4c8     HIGU_ntcall:syscall_table.obj
 0002:000004e0       ??_C@_0BM@NODLOBEE@NtAllocateUserPhysicalPages@ 000000014000a4e0     HIGU_ntcall:syscall_table.obj
 0002:00000500       ??_C@_0BA@NHNMOMGG@NtAllocateUuids@ 000000014000a500     HIGU_ntcall:syscall_table.obj
 0002:00000510       ??_C@_0BI@BKMFFNKN@NtAllocateVirtualMemory@ 000000014000a510     HIGU_ntcall:syscall_table.obj
 0002:00000528       ??_C@_0BK@JPMEEJPN@NtAllocateVirtualMemoryEx@ 000000014000a528     HIGU_ntcall:syscall_table.obj
 0002:00000548       ??_C@_0BI@DOPFKNNF@NtAlpcAcceptConnectPort@ 000000014000a548     HIGU_ntcall:syscall_table.obj
 0002:00000560       ??_C@_0BE@JHKAOGPP@NtAlpcCancelMessage@ 000000014000a560     HIGU_ntcall:syscall_table.obj
 0002:00000578       ??_C@_0BC@NILLMDHH@NtAlpcConnectPort@ 000000014000a578     HIGU_ntcall:syscall_table.obj
 0002:00000590       ??_C@_0BE@PDKEBIFF@NtAlpcConnectPortEx@ 000000014000a590     HIGU_ntcall:syscall_table.obj
 0002:000005a8       ??_C@_0BB@KBPIBMFF@NtAlpcCreatePort@ 000000014000a5a8     HIGU_ntcall:syscall_table.obj
 0002:000005c0       ??_C@_0BI@PGKELPCN@NtAlpcCreatePortSection@ 000000014000a5c0     HIGU_ntcall:syscall_table.obj
 0002:000005d8       ??_C@_0BM@PMHGKDBI@NtAlpcCreateResourceReserve@ 000000014000a5d8     HIGU_ntcall:syscall_table.obj
 0002:000005f8       ??_C@_0BI@IKIMIMAA@NtAlpcCreateSectionView@ 000000014000a5f8     HIGU_ntcall:syscall_table.obj
 0002:00000610       ??_C@_0BM@KOBNOPFN@NtAlpcCreateSecurityContext@ 000000014000a610     HIGU_ntcall:syscall_table.obj
 0002:00000630       ??_C@_0BI@HHEODLMC@NtAlpcDeletePortSection@ 000000014000a630     HIGU_ntcall:syscall_table.obj
 0002:00000648       ??_C@_0BM@KKHIOJPK@NtAlpcDeleteResourceReserve@ 000000014000a648     HIGU_ntcall:syscall_table.obj
 0002:00000668       ??_C@_0BI@LGGAIOP@NtAlpcDeleteSectionView@ 000000014000a668     HIGU_ntcall:syscall_table.obj
 0002:00000680       ??_C@_0BM@PIBDKFLP@NtAlpcDeleteSecurityContext@ 000000014000a680     HIGU_ntcall:syscall_table.obj
 0002:000006a0       ??_C@_0BF@FKNELCJE@NtAlpcDisconnectPort@ 000000014000a6a0     HIGU_ntcall:syscall_table.obj
 0002:000006b8       ??_C@_0CH@GEBGDOOA@NtAlpcImpersonateClientContaine@ 000000014000a6b8     HIGU_ntcall:syscall_table.obj
 0002:000006e0       ??_C@_0BO@INJDCFMN@NtAlpcImpersonateClientOfPort@ 000000014000a6e0     HIGU_ntcall:syscall_table.obj
 0002:00000700       ??_C@_0BI@IDGDGBNK@NtAlpcOpenSenderProcess@ 000000014000a700     HIGU_ntcall:syscall_table.obj
 0002:00000718       ??_C@_0BH@JAHLBINK@NtAlpcOpenSenderThread@ 000000014000a718     HIGU_ntcall:syscall_table.obj
 0002:00000730       ??_C@_0BH@NKMCNGLO@NtAlpcQueryInformation@ 000000014000a730     HIGU_ntcall:syscall_table.obj
 0002:00000748       ??_C@_0BO@OAELKKKG@NtAlpcQueryInformationMessage@ 000000014000a748     HIGU_ntcall:syscall_table.obj
 0002:00000768       ??_C@_0BM@DBAPFNGB@NtAlpcRevokeSecurityContext@ 000000014000a768     HIGU_ntcall:syscall_table.obj
 0002:00000788       ??_C@_0BK@MADOEJBO@NtAlpcSendWaitReceivePort@ 000000014000a788     HIGU_ntcall:syscall_table.obj
 0002:000007a8       ??_C@_0BF@CFLGMBPN@NtAlpcSetInformation@ 000000014000a7a8     HIGU_ntcall:syscall_table.obj
 0002:000007c0       ??_C@_0BG@LHJJGKJJ@NtApphelpCacheControl@ 000000014000a7c0     HIGU_ntcall:syscall_table.obj
 0002:000007d8       ??_C@_0BI@LPIPKEFH@NtAreMappedFilesTheSame@ 000000014000a7d8     HIGU_ntcall:syscall_table.obj
 0002:000007f0       ??_C@_0BL@CJFGDNCA@NtAssignProcessToJobObject@ 000000014000a7f0     HIGU_ntcall:syscall_table.obj
 0002:00000810       ??_C@_0CA@LCFEDOGF@NtAssociateWaitCompletionPacket@ 000000014000a810     HIGU_ntcall:syscall_table.obj
 0002:00000830       ??_C@_0O@NKDKIPAC@NtCallEnclave@ 000000014000a830     HIGU_ntcall:syscall_table.obj
 0002:00000840       ??_C@_0BB@JMFJJKDD@NtCallbackReturn@ 000000014000a840     HIGU_ntcall:syscall_table.obj
 0002:00000858       ??_C@_0P@GPODIPN@NtCancelIoFile@ 000000014000a858     HIGU_ntcall:syscall_table.obj
 0002:00000868       ??_C@_0BB@BIKHJNEF@NtCancelIoFileEx@ 000000014000a868     HIGU_ntcall:syscall_table.obj
 0002:00000880       ??_C@_0BK@POBIMMMH@NtCancelSynchronousIoFile@ 000000014000a880     HIGU_ntcall:syscall_table.obj
 0002:000008a0       ??_C@_0O@OPDFHNPD@NtCancelTimer@ 000000014000a8a0     HIGU_ntcall:syscall_table.obj
 0002:000008b0       ??_C@_0P@MJCLMCKK@NtCancelTimer2@ 000000014000a8b0     HIGU_ntcall:syscall_table.obj
 0002:000008c0       ??_C@_0BN@GBBFILCI@NtCancelWaitCompletionPacket@ 000000014000a8c0     HIGU_ntcall:syscall_table.obj
 0002:000008e0       ??_C@_0N@EJHKHDGI@NtClearEvent@ 000000014000a8e0     HIGU_ntcall:syscall_table.obj
 0002:000008f0       ??_C@_07EGJLEIEB@NtClose@  000000014000a8f0     HIGU_ntcall:syscall_table.obj
 0002:000008f8       ??_C@_0BI@ODDKDACP@NtCloseObjectAuditAlarm@ 000000014000a8f8     HIGU_ntcall:syscall_table.obj
 0002:00000910       ??_C@_0BB@BPCMHDNO@NtCommitComplete@ 000000014000a910     HIGU_ntcall:syscall_table.obj
 0002:00000928       ??_C@_0BD@JILJNKDH@NtCommitEnlistment@ 000000014000a928     HIGU_ntcall:syscall_table.obj
 0002:00000940       ??_C@_0BM@BOLEJCOH@NtCommitRegistryTransaction@ 000000014000a940     HIGU_ntcall:syscall_table.obj
 0002:00000960       ??_C@_0BE@DOFNFDBJ@NtCommitTransaction@ 000000014000a960     HIGU_ntcall:syscall_table.obj
 0002:00000978       ??_C@_0O@MEAFNHLJ@NtCompactKeys@ 000000014000a978     HIGU_ntcall:syscall_table.obj
 0002:00000988       ??_C@_0BB@FCDNEONP@NtCompareObjects@ 000000014000a988     HIGU_ntcall:syscall_table.obj
 0002:000009a0       ??_C@_0BH@ENMIOKAE@NtCompareSigningLevels@ 000000014000a9a0     HIGU_ntcall:syscall_table.obj
 0002:000009b8       ??_C@_0BA@DPBODOPL@NtCompareTokens@ 000000014000a9b8     HIGU_ntcall:syscall_table.obj
 0002:000009c8       ??_C@_0BG@ILIFEBNN@NtCompleteConnectPort@ 000000014000a9c8     HIGU_ntcall:syscall_table.obj
 0002:000009e0       ??_C@_0O@HGILHNCH@NtCompressKey@ 000000014000a9e0     HIGU_ntcall:syscall_table.obj
 0002:000009f0       ??_C@_0O@PEODMEHC@NtConnectPort@ 000000014000a9f0     HIGU_ntcall:syscall_table.obj
 0002:00000a00       ??_C@_0L@EPGBAMPH@NtContinue@ 000000014000aa00     HIGU_ntcall:syscall_table.obj
 0002:00000a10       ??_C@_0DG@EBDJEKNI@NtConvertBetweenAuxiliaryCounte@ 000000014000aa10     HIGU_ntcall:syscall_table.obj
 0002:00000a48       ??_C@_0BF@CEKDOCEH@NtCreateCrossVmEvent@ 000000014000aa48     HIGU_ntcall:syscall_table.obj
 0002:00000a60       ??_C@_0BE@HLOEAMPP@NtCreateDebugObject@ 000000014000aa60     HIGU_ntcall:syscall_table.obj
 0002:00000a78       ??_C@_0BI@HPAPPJDJ@NtCreateDirectoryObject@ 000000014000aa78     HIGU_ntcall:syscall_table.obj
 0002:00000a90       ??_C@_0BK@FLFCAENI@NtCreateDirectoryObjectEx@ 000000014000aa90     HIGU_ntcall:syscall_table.obj
 0002:00000ab0       ??_C@_0BA@BNCPKENH@NtCreateEnclave@ 000000014000aab0     HIGU_ntcall:syscall_table.obj
 0002:00000ac0       ??_C@_0BD@PGDOJMGN@NtCreateEnlistment@ 000000014000aac0     HIGU_ntcall:syscall_table.obj
 0002:00000ad8       ??_C@_0O@JODPMJML@NtCreateEvent@ 000000014000aad8     HIGU_ntcall:syscall_table.obj
 0002:00000ae8       ??_C@_0BC@JBNNOEMB@NtCreateEventPair@ 000000014000aae8     HIGU_ntcall:syscall_table.obj
 0002:00000b00       ??_C@_0N@KPMLACHP@NtCreateFile@ 000000014000ab00     HIGU_ntcall:syscall_table.obj
 0002:00000b10       ??_C@_0BA@KFOJOANM@NtCreateIRTimer@ 000000014000ab10     HIGU_ntcall:syscall_table.obj
 0002:00000b20       ??_C@_0BF@EGGGJEIB@NtCreateIoCompletion@ 000000014000ab20     HIGU_ntcall:syscall_table.obj
 0002:00000b38       ??_C@_0BC@OJALIEPB@NtCreateJobObject@ 000000014000ab38     HIGU_ntcall:syscall_table.obj
 0002:00000b50       ??_C@_0P@DIGPIOJC@NtCreateJobSet@ 000000014000ab50     HIGU_ntcall:syscall_table.obj
 0002:00000b60       ??_C@_0M@DAAEGBND@NtCreateKey@ 000000014000ab60     HIGU_ntcall:syscall_table.obj
 0002:00000b70       ??_C@_0BG@MNPFNBP@NtCreateKeyTransacted@ 000000014000ab70     HIGU_ntcall:syscall_table.obj
 0002:00000b88       ??_C@_0BD@JHDPIODG@NtCreateKeyedEvent@ 000000014000ab88     HIGU_ntcall:syscall_table.obj
 0002:00000ba0       ??_C@_0BE@OEANNPMB@NtCreateLowBoxToken@ 000000014000aba0     HIGU_ntcall:syscall_table.obj
 0002:00000bb8       ??_C@_0BF@GMMNLLAJ@NtCreateMailslotFile@ 000000014000abb8     HIGU_ntcall:syscall_table.obj
 0002:00000bd0       ??_C@_0P@OGFCCMAI@NtCreateMutant@ 000000014000abd0     HIGU_ntcall:syscall_table.obj
 0002:00000be0       ??_C@_0BG@KAOBEKOP@NtCreateNamedPipeFile@ 000000014000abe0     HIGU_ntcall:syscall_table.obj
 0002:00000bf8       ??_C@_0BD@HFBAOKFM@NtCreatePagingFile@ 000000014000abf8     HIGU_ntcall:syscall_table.obj
 0002:00000c10       ??_C@_0BC@IBGMOLOG@NtCreatePartition@ 000000014000ac10     HIGU_ntcall:syscall_table.obj
 0002:00000c28       ??_C@_0N@CAGBJCOL@NtCreatePort@ 000000014000ac28     HIGU_ntcall:syscall_table.obj
 0002:00000c38       ??_C@_0BJ@LJHJJBOO@NtCreatePrivateNamespace@ 000000014000ac38     HIGU_ntcall:syscall_table.obj
 0002:00000c58       ??_C@_0BA@OJKJNKOD@NtCreateProcess@ 000000014000ac58     HIGU_ntcall:syscall_table.obj
 0002:00000c68       ??_C@_0BC@ICOCMOJJ@NtCreateProcessEx@ 000000014000ac68     HIGU_ntcall:syscall_table.obj
 0002:00000c80       ??_C@_0BA@GAHNLLLB@NtCreateProfile@ 000000014000ac80     HIGU_ntcall:syscall_table.obj
 0002:00000c90       ??_C@_0BC@DANKCJFF@NtCreateProfileEx@ 000000014000ac90     HIGU_ntcall:syscall_table.obj
 0002:00000ca8       ??_C@_0BM@GJHFCIDD@NtCreateRegistryTransaction@ 000000014000aca8     HIGU_ntcall:syscall_table.obj
 0002:00000cc8       ??_C@_0BI@JHNIDAAN@NtCreateResourceManager@ 000000014000acc8     HIGU_ntcall:syscall_table.obj
 0002:00000ce0       ??_C@_0BA@MANLHNBJ@NtCreateSection@ 000000014000ace0     HIGU_ntcall:syscall_table.obj
 0002:00000cf0       ??_C@_0BC@CEADNIJH@NtCreateSectionEx@ 000000014000acf0     HIGU_ntcall:syscall_table.obj
 0002:00000d08       ??_C@_0BC@PEGCAOOD@NtCreateSemaphore@ 000000014000ad08     HIGU_ntcall:syscall_table.obj
 0002:00000d20       ??_C@_0BL@EBFDOHBM@NtCreateSymbolicLinkObject@ 000000014000ad20     HIGU_ntcall:syscall_table.obj
 0002:00000d40       ??_C@_0P@OKOANDML@NtCreateThread@ 000000014000ad40     HIGU_ntcall:syscall_table.obj
 0002:00000d50       ??_C@_0BB@KGGDNLNO@NtCreateThreadEx@ 000000014000ad50     HIGU_ntcall:syscall_table.obj
 0002:00000d68       ??_C@_0O@CLLOHICO@NtCreateTimer@ 000000014000ad68     HIGU_ntcall:syscall_table.obj
 0002:00000d78       ??_C@_0P@DBINOHMG@NtCreateTimer2@ 000000014000ad78     HIGU_ntcall:syscall_table.obj
 0002:00000d88       ??_C@_0O@GHOCIPAP@NtCreateToken@ 000000014000ad88     HIGU_ntcall:syscall_table.obj
 0002:00000d98       ??_C@_0BA@GLCIFJEJ@NtCreateTokenEx@ 000000014000ad98     HIGU_ntcall:syscall_table.obj
 0002:00000da8       ??_C@_0BE@LFINGMLF@NtCreateTransaction@ 000000014000ada8     HIGU_ntcall:syscall_table.obj
 0002:00000dc0       ??_C@_0BL@JCLABIBC@NtCreateTransactionManager@ 000000014000adc0     HIGU_ntcall:syscall_table.obj
 0002:00000de0       ??_C@_0BE@IIPCAPLK@NtCreateUserProcess@ 000000014000ade0     HIGU_ntcall:syscall_table.obj
 0002:00000df8       ??_C@_0BN@MNKHPKBL@NtCreateWaitCompletionPacket@ 000000014000adf8     HIGU_ntcall:syscall_table.obj
 0002:00000e18       ??_C@_0BF@DHJIJJBL@NtCreateWaitablePort@ 000000014000ae18     HIGU_ntcall:syscall_table.obj
 0002:00000e30       ??_C@_0BF@DMDAKBPM@NtCreateWnfStateName@ 000000014000ae30     HIGU_ntcall:syscall_table.obj
 0002:00000e48       ??_C@_0BG@MEDPHOGD@NtCreateWorkerFactory@ 000000014000ae48     HIGU_ntcall:syscall_table.obj
 0002:00000e60       ??_C@_0BF@LNDHJKNI@NtDebugActiveProcess@ 000000014000ae60     HIGU_ntcall:syscall_table.obj
 0002:00000e78       ??_C@_0BA@CPDFMFD@NtDebugContinue@ 000000014000ae78     HIGU_ntcall:syscall_table.obj
 0002:00000e88       ??_C@_0BB@HDNGEBBO@NtDelayExecution@ 000000014000ae88     HIGU_ntcall:syscall_table.obj
 0002:00000ea0       ??_C@_0N@LBKHFCMP@NtDeleteAtom@ 000000014000aea0     HIGU_ntcall:syscall_table.obj
 0002:00000eb0       ??_C@_0BC@CIAOMJDE@NtDeleteBootEntry@ 000000014000aeb0     HIGU_ntcall:syscall_table.obj
 0002:00000ec8       ??_C@_0BE@JIPJEJDL@NtDeleteDriverEntry@ 000000014000aec8     HIGU_ntcall:syscall_table.obj
 0002:00000ee0       ??_C@_0N@GLGLDFMM@NtDeleteFile@ 000000014000aee0     HIGU_ntcall:syscall_table.obj
 0002:00000ef0       ??_C@_0M@PBHJGKCK@NtDeleteKey@ 000000014000aef0     HIGU_ntcall:syscall_table.obj
 0002:00000f00       ??_C@_0BJ@DLJAIIHM@NtDeleteObjectAuditAlarm@ 000000014000af00     HIGU_ntcall:syscall_table.obj
 0002:00000f20       ??_C@_0BJ@PHCLBMPA@NtDeletePrivateNamespace@ 000000014000af20     HIGU_ntcall:syscall_table.obj
 0002:00000f40       ??_C@_0BB@JDIHMLFD@NtDeleteValueKey@ 000000014000af40     HIGU_ntcall:syscall_table.obj
 0002:00000f58       ??_C@_0BF@DBCPPBML@NtDeleteWnfStateData@ 000000014000af58     HIGU_ntcall:syscall_table.obj
 0002:00000f70       ??_C@_0BF@MAELEJB@NtDeleteWnfStateName@ 000000014000af70     HIGU_ntcall:syscall_table.obj
 0002:00000f88       ??_C@_0BG@PCMBHBNE@NtDeviceIoControlFile@ 000000014000af88     HIGU_ntcall:syscall_table.obj
 0002:00000fa0       ??_C@_0BH@PGEIDGMI@NtDisableLastKnownGood@ 000000014000afa0     HIGU_ntcall:syscall_table.obj
 0002:00000fb8       ??_C@_0BA@PBIGPFKM@NtDisplayString@ 000000014000afb8     HIGU_ntcall:syscall_table.obj
 0002:00000fc8       ??_C@_0L@GJNDAMPG@NtDrawText@ 000000014000afc8     HIGU_ntcall:syscall_table.obj
 0002:00000fd8       ??_C@_0BC@MDCBEKCC@NtDuplicateObject@ 000000014000afd8     HIGU_ntcall:syscall_table.obj
 0002:00000ff0       ??_C@_0BB@OGDPBJBJ@NtDuplicateToken@ 000000014000aff0     HIGU_ntcall:syscall_table.obj
 0002:00001008       ??_C@_0BG@EDIMENOD@NtEnableLastKnownGood@ 000000014000b008     HIGU_ntcall:syscall_table.obj
 0002:00001020       ??_C@_0BH@DMIODNGA@NtEnumerateBootEntries@ 000000014000b020     HIGU_ntcall:syscall_table.obj
 0002:00001038       ??_C@_0BJ@HFLPFDDF@NtEnumerateDriverEntries@ 000000014000b038     HIGU_ntcall:syscall_table.obj
 0002:00001058       ??_C@_0P@NOBPPJGE@NtEnumerateKey@ 000000014000b058     HIGU_ntcall:syscall_table.obj
 0002:00001068       ??_C@_0CF@EHNHPKKA@NtEnumerateSystemEnvironmentVal@ 000000014000b068     HIGU_ntcall:syscall_table.obj
 0002:00001090       ??_C@_0BN@OIGLNAGF@NtEnumerateTransactionObject@ 000000014000b090     HIGU_ntcall:syscall_table.obj
 0002:000010b0       ??_C@_0BE@IFPHOMMO@NtEnumerateValueKey@ 000000014000b0b0     HIGU_ntcall:syscall_table.obj
 0002:000010c8       ??_C@_0BA@CNFIHPK@NtExtendSection@ 000000014000b0c8     HIGU_ntcall:syscall_table.obj
 0002:000010d8       ??_C@_0BD@EBEPGKJF@NtFilterBootOption@ 000000014000b0d8     HIGU_ntcall:syscall_table.obj
 0002:000010f0       ??_C@_0O@HKLMAEJB@NtFilterToken@ 000000014000b0f0     HIGU_ntcall:syscall_table.obj
 0002:00001100       ??_C@_0BA@POIALJCL@NtFilterTokenEx@ 000000014000b100     HIGU_ntcall:syscall_table.obj
 0002:00001110       ??_C@_0L@NHDCDNDE@NtFindAtom@ 000000014000b110     HIGU_ntcall:syscall_table.obj
 0002:00001120       ??_C@_0BD@KLELALOK@NtFlushBuffersFile@ 000000014000b120     HIGU_ntcall:syscall_table.obj
 0002:00001138       ??_C@_0BF@KCPENFHA@NtFlushBuffersFileEx@ 000000014000b138     HIGU_ntcall:syscall_table.obj
 0002:00001150       ??_C@_0BJ@IFAJIGM@NtFlushInstallUILanguage@ 000000014000b150     HIGU_ntcall:syscall_table.obj
 0002:00001170       ??_C@_0BI@NEMBHADC@NtFlushInstructionCache@ 000000014000b170     HIGU_ntcall:syscall_table.obj
 0002:00001188       ??_C@_0L@KDHIDOEG@NtFlushKey@ 000000014000b188     HIGU_ntcall:syscall_table.obj
 0002:00001198       ??_C@_0BL@FOGDDBEO@NtFlushProcessWriteBuffers@ 000000014000b198     HIGU_ntcall:syscall_table.obj
 0002:000011b8       ??_C@_0BF@CIMJBHF@NtFlushVirtualMemory@ 000000014000b1b8     HIGU_ntcall:syscall_table.obj
 0002:000011d0       ??_C@_0BD@IIDMHDPL@NtFlushWriteBuffer@ 000000014000b1d0     HIGU_ntcall:syscall_table.obj
 0002:000011e8       ??_C@_0BI@GAGFKGFE@NtFreeUserPhysicalPages@ 000000014000b1e8     HIGU_ntcall:syscall_table.obj
 0002:00001200       ??_C@_0BE@KBMHLKEP@NtFreeVirtualMemory@ 000000014000b200     HIGU_ntcall:syscall_table.obj
 0002:00001218       ??_C@_0BB@BMKJDLEM@NtFreezeRegistry@ 000000014000b218     HIGU_ntcall:syscall_table.obj
 0002:00001230       ??_C@_0BF@LIGEDJBC@NtFreezeTransactions@ 000000014000b230     HIGU_ntcall:syscall_table.obj
 0002:00001248       ??_C@_0BA@ONAKNLNL@NtFsControlFile@ 000000014000b248     HIGU_ntcall:syscall_table.obj
 0002:00001258       ??_C@_0BI@JKMBINHI@NtGetCachedSigningLevel@ 000000014000b258     HIGU_ntcall:syscall_table.obj
 0002:00001270       ??_C@_0CC@HCGENDOI@NtGetCompleteWnfStateSubscripti@ 000000014000b270     HIGU_ntcall:syscall_table.obj
 0002:00001298       ??_C@_0BD@LHJBPAIN@NtGetContextThread@ 000000014000b298     HIGU_ntcall:syscall_table.obj
 0002:000012b0       ??_C@_0BM@FOFOFHCC@NtGetCurrentProcessorNumber@ 000000014000b2b0     HIGU_ntcall:syscall_table.obj
 0002:000012d0       ??_C@_0BO@MDAKGAPM@NtGetCurrentProcessorNumberEx@ 000000014000b2d0     HIGU_ntcall:syscall_table.obj
 0002:000012f0       ??_C@_0BG@CGBLEMDI@NtGetDevicePowerState@ 000000014000b2f0     HIGU_ntcall:syscall_table.obj
 0002:00001308       ??_C@_0BF@GFHFLIDH@NtGetMUIRegistryInfo@ 000000014000b308     HIGU_ntcall:syscall_table.obj
 0002:00001320       ??_C@_0BB@OFFAJPHF@NtGetNextProcess@ 000000014000b320     HIGU_ntcall:syscall_table.obj
 0002:00001338       ??_C@_0BA@KFLOHNAA@NtGetNextThread@ 000000014000b338     HIGU_ntcall:syscall_table.obj
 0002:00001348       ??_C@_0BD@BOAFBEIE@NtGetNlsSectionPtr@ 000000014000b348     HIGU_ntcall:syscall_table.obj
 0002:00001360       ??_C@_0CB@MCFIEFCG@NtGetNotificationResourceManage@ 000000014000b360     HIGU_ntcall:syscall_table.obj
 0002:00001388       ??_C@_0BA@JFCABGLJ@NtGetWriteWatch@ 000000014000b388     HIGU_ntcall:syscall_table.obj
 0002:00001398       ??_C@_0BM@HLNNOHJJ@NtImpersonateAnonymousToken@ 000000014000b398     HIGU_ntcall:syscall_table.obj
 0002:000013b8       ??_C@_0BK@PCANPAFF@NtImpersonateClientOfPort@ 000000014000b3b8     HIGU_ntcall:syscall_table.obj
 0002:000013d8       ??_C@_0BE@GLOPHGCD@NtImpersonateThread@ 000000014000b3d8     HIGU_ntcall:syscall_table.obj
 0002:000013f0       ??_C@_0BE@PGFDPEIH@NtInitializeEnclave@ 000000014000b3f0     HIGU_ntcall:syscall_table.obj
 0002:00001408       ??_C@_0BF@HJHFLAEG@NtInitializeNlsFiles@ 000000014000b408     HIGU_ntcall:syscall_table.obj
 0002:00001420       ??_C@_0BF@BFNOLIBK@NtInitializeRegistry@ 000000014000b420     HIGU_ntcall:syscall_table.obj
 0002:00001438       ??_C@_0BG@CEOJBMLA@NtInitiatePowerAction@ 000000014000b438     HIGU_ntcall:syscall_table.obj
 0002:00001450       ??_C@_0BB@DELCFEGC@NtIsProcessInJob@ 000000014000b450     HIGU_ntcall:syscall_table.obj
 0002:00001468       ??_C@_0BK@PDKIFICB@NtIsSystemResumeAutomatic@ 000000014000b468     HIGU_ntcall:syscall_table.obj
 0002:00001488       ??_C@_0BH@BBGGJKBB@NtIsUILanguageComitted@ 000000014000b488     HIGU_ntcall:syscall_table.obj
 0002:000014a0       ??_C@_0N@CMDIHPDP@NtListenPort@ 000000014000b4a0     HIGU_ntcall:syscall_table.obj
 0002:000014b0       ??_C@_0N@MGGHEPN@NtLoadDriver@ 000000014000b4b0     HIGU_ntcall:syscall_table.obj
 0002:000014c0       ??_C@_0BC@IMFIFJHJ@NtLoadEnclaveData@ 000000014000b4c0     HIGU_ntcall:syscall_table.obj
 0002:000014d8       ??_C@_09GBGLMANH@NtLoadKey@ 000000014000b4d8     HIGU_ntcall:syscall_table.obj
 0002:000014e8       ??_C@_0L@PFKGHIMG@NtLoadKey2@ 000000014000b4e8     HIGU_ntcall:syscall_table.obj
 0002:000014f8       ??_C@_0M@MEKKEMNG@NtLoadKeyEx@ 000000014000b4f8     HIGU_ntcall:syscall_table.obj
 0002:00001508       ??_C@_0L@MODOAKDL@NtLockFile@ 000000014000b508     HIGU_ntcall:syscall_table.obj
 0002:00001518       ??_C@_0BM@NFALGCOJ@NtLockProductActivationKeys@ 000000014000b518     HIGU_ntcall:syscall_table.obj
 0002:00001538       ??_C@_0BC@OMIIFJMM@NtLockRegistryKey@ 000000014000b538     HIGU_ntcall:syscall_table.obj
 0002:00001550       ??_C@_0BE@IEPDEDO@NtLockVirtualMemory@ 000000014000b550     HIGU_ntcall:syscall_table.obj
 0002:00001568       ??_C@_0BG@CGFHLACH@NtMakePermanentObject@ 000000014000b568     HIGU_ntcall:syscall_table.obj
 0002:00001580       ??_C@_0BG@KEKMDDEC@NtMakeTemporaryObject@ 000000014000b580     HIGU_ntcall:syscall_table.obj
 0002:00001598       ??_C@_0BB@NAFDKDLB@NtManageHotPatch@ 000000014000b598     HIGU_ntcall:syscall_table.obj
 0002:000015b0       ??_C@_0BC@MAEPOMJK@NtManagePartition@ 000000014000b5b0     HIGU_ntcall:syscall_table.obj
 0002:000015c8       ??_C@_0P@ELNLDGCF@NtMapCMFModule@ 000000014000b5c8     HIGU_ntcall:syscall_table.obj
 0002:000015d8       ??_C@_0BH@OHHEDCIB@NtMapUserPhysicalPages@ 000000014000b5d8     HIGU_ntcall:syscall_table.obj
 0002:000015f0       ??_C@_0BO@DJGMGFLH@NtMapUserPhysicalPagesScatter@ 000000014000b5f0     HIGU_ntcall:syscall_table.obj
 0002:00001610       ??_C@_0BD@OPIOPJOL@NtMapViewOfSection@ 000000014000b610     HIGU_ntcall:syscall_table.obj
 0002:00001628       ??_C@_0BF@OIFMDDME@NtMapViewOfSectionEx@ 000000014000b628     HIGU_ntcall:syscall_table.obj
 0002:00001640       ??_C@_0BC@HPFGDIFO@NtModifyBootEntry@ 000000014000b640     HIGU_ntcall:syscall_table.obj
 0002:00001658       ??_C@_0BE@MNFBFPME@NtModifyDriverEntry@ 000000014000b658     HIGU_ntcall:syscall_table.obj
 0002:00001670       ??_C@_0BM@MCFOHJPO@NtNotifyChangeDirectoryFile@ 000000014000b670     HIGU_ntcall:syscall_table.obj
 0002:00001690       ??_C@_0BO@DCFBHLCA@NtNotifyChangeDirectoryFileEx@ 000000014000b690     HIGU_ntcall:syscall_table.obj
 0002:000016b0       ??_C@_0BC@OBDOKPKL@NtNotifyChangeKey@ 000000014000b6b0     HIGU_ntcall:syscall_table.obj
 0002:000016c8       ??_C@_0BL@IIHAIJOH@NtNotifyChangeMultipleKeys@ 000000014000b6c8     HIGU_ntcall:syscall_table.obj
 0002:000016e8       ??_C@_0BG@JAOKKMJA@NtNotifyChangeSession@ 000000014000b6e8     HIGU_ntcall:syscall_table.obj
 0002:00001700       ??_C@_0BG@MPMPEFFH@NtOpenDirectoryObject@ 000000014000b700     HIGU_ntcall:syscall_table.obj
 0002:00001718       ??_C@_0BB@LDDHJCHK@NtOpenEnlistment@ 000000014000b718     HIGU_ntcall:syscall_table.obj
 0002:00001730       ??_C@_0M@ODPGKJMJ@NtOpenEvent@ 000000014000b730     HIGU_ntcall:syscall_table.obj
 0002:00001740       ??_C@_0BA@EHIPIGOM@NtOpenEventPair@ 000000014000b740     HIGU_ntcall:syscall_table.obj
 0002:00001750       ??_C@_0L@GBDFLBPA@NtOpenFile@ 000000014000b750     HIGU_ntcall:syscall_table.obj
 0002:00001760       ??_C@_0BD@KEFNHIBJ@NtOpenIoCompletion@ 000000014000b760     HIGU_ntcall:syscall_table.obj
 0002:00001778       ??_C@_0BA@DPFJOGNM@NtOpenJobObject@ 000000014000b778     HIGU_ntcall:syscall_table.obj
 0002:00001788       ??_C@_09KPFDHBKE@NtOpenKey@ 000000014000b788     HIGU_ntcall:syscall_table.obj
 0002:00001798       ??_C@_0M@HMNOCLMB@NtOpenKeyEx@ 000000014000b798     HIGU_ntcall:syscall_table.obj
 0002:000017a8       ??_C@_0BE@PCOJHNIF@NtOpenKeyTransacted@ 000000014000b7a8     HIGU_ntcall:syscall_table.obj
 0002:000017c0       ??_C@_0BG@PJPHCPLD@NtOpenKeyTransactedEx@ 000000014000b7c0     HIGU_ntcall:syscall_table.obj
 0002:000017d8       ??_C@_0BB@NCDGIACB@NtOpenKeyedEvent@ 000000014000b7d8     HIGU_ntcall:syscall_table.obj
 0002:000017f0       ??_C@_0N@ICBIEEE@NtOpenMutant@ 000000014000b7f0     HIGU_ntcall:syscall_table.obj
 0002:00001800       ??_C@_0BH@NPHIIJIB@NtOpenObjectAuditAlarm@ 000000014000b800     HIGU_ntcall:syscall_table.obj
 0002:00001818       ??_C@_0BA@FHDOIJML@NtOpenPartition@ 000000014000b818     HIGU_ntcall:syscall_table.obj
 0002:00001828       ??_C@_0BH@BDMDBNAN@NtOpenPrivateNamespace@ 000000014000b828     HIGU_ntcall:syscall_table.obj
 0002:00001840       ??_C@_0O@JGCNKEPA@NtOpenProcess@ 000000014000b840     HIGU_ntcall:syscall_table.obj
 0002:00001850       ??_C@_0BD@EIILLDLN@NtOpenProcessToken@ 000000014000b850     HIGU_ntcall:syscall_table.obj
 0002:00001868       ??_C@_0BF@JCLEMGJN@NtOpenProcessTokenEx@ 000000014000b868     HIGU_ntcall:syscall_table.obj
 0002:00001880       ??_C@_0BK@HOFDMLLF@NtOpenRegistryTransaction@ 000000014000b880     HIGU_ntcall:syscall_table.obj
 0002:000018a0       ??_C@_0BG@CHBIIMGD@NtOpenResourceManager@ 000000014000b8a0     HIGU_ntcall:syscall_table.obj
 0002:000018b8       ??_C@_0O@LPFPADAK@NtOpenSection@ 000000014000b8b8     HIGU_ntcall:syscall_table.obj
 0002:000018c8       ??_C@_0BA@CCDAGMMO@NtOpenSemaphore@ 000000014000b8c8     HIGU_ntcall:syscall_table.obj
 0002:000018d8       ??_C@_0O@OKJNNIB@NtOpenSession@ 000000014000b8d8     HIGU_ntcall:syscall_table.obj
 0002:000018e8       ??_C@_0BJ@NAAOCCIC@NtOpenSymbolicLinkObject@ 000000014000b8e8     HIGU_ntcall:syscall_table.obj
 0002:00001908       ??_C@_0N@EJDHLIH@NtOpenThread@ 000000014000b908     HIGU_ntcall:syscall_table.obj
 0002:00001918       ??_C@_0BC@PBPJBNCP@NtOpenThreadToken@ 000000014000b918     HIGU_ntcall:syscall_table.obj
 0002:00001930       ??_C@_0BE@OAKNBJJI@NtOpenThreadTokenEx@ 000000014000b930     HIGU_ntcall:syscall_table.obj
 0002:00001948       ??_C@_0M@FGHHBICM@NtOpenTimer@ 000000014000b948     HIGU_ntcall:syscall_table.obj
 0002:00001958       ??_C@_0BC@DGBLOAHM@NtOpenTransaction@ 000000014000b958     HIGU_ntcall:syscall_table.obj
 0002:00001970       ??_C@_0BJ@DONNNIM@NtOpenTransactionManager@ 000000014000b970     HIGU_ntcall:syscall_table.obj
 0002:00001990       ??_C@_0BC@FFADMLBP@NtPlugPlayControl@ 000000014000b990     HIGU_ntcall:syscall_table.obj
 0002:000019a8       ??_C@_0BD@EJALDNPB@NtPowerInformation@ 000000014000b9a8     HIGU_ntcall:syscall_table.obj
 0002:000019c0       ??_C@_0BF@OPOGANOF@NtPrePrepareComplete@ 000000014000b9c0     HIGU_ntcall:syscall_table.obj
 0002:000019d8       ??_C@_0BH@BDLGJJPO@NtPrePrepareEnlistment@ 000000014000b9d8     HIGU_ntcall:syscall_table.obj
 0002:000019f0       ??_C@_0BC@MOFJOODN@NtPrepareComplete@ 000000014000b9f0     HIGU_ntcall:syscall_table.obj
 0002:00001a08       ??_C@_0BE@GDFEEEJE@NtPrepareEnlistment@ 000000014000ba08     HIGU_ntcall:syscall_table.obj
 0002:00001a20       ??_C@_0BB@PDFEMNOE@NtPrivilegeCheck@ 000000014000ba20     HIGU_ntcall:syscall_table.obj
 0002:00001a38       ??_C@_0BM@LJIJAIJD@NtPrivilegeObjectAuditAlarm@ 000000014000ba38     HIGU_ntcall:syscall_table.obj
 0002:00001a58       ??_C@_0BO@ONAPENGN@NtPrivilegedServiceAuditAlarm@ 000000014000ba58     HIGU_ntcall:syscall_table.obj
 0002:00001a78       ??_C@_0BG@EIPFCALN@NtPropagationComplete@ 000000014000ba78     HIGU_ntcall:syscall_table.obj
 0002:00001a90       ??_C@_0BE@GCOGGHFA@NtPropagationFailed@ 000000014000ba90     HIGU_ntcall:syscall_table.obj
 0002:00001aa8       ??_C@_0BH@EDMKDLIP@NtProtectVirtualMemory@ 000000014000baa8     HIGU_ntcall:syscall_table.obj
 0002:00001ac0       ??_C@_0N@JFJBFJMN@NtPulseEvent@ 000000014000bac0     HIGU_ntcall:syscall_table.obj
 0002:00001ad0       ??_C@_0BG@OJBPGNEC@NtQueryAttributesFile@ 000000014000bad0     HIGU_ntcall:syscall_table.obj
 0002:00001ae8       ??_C@_0CB@KOJBFJIO@NtQueryAuxiliaryCounterFrequenc@ 000000014000bae8     HIGU_ntcall:syscall_table.obj
 0002:00001b10       ??_C@_0BG@FFOKBEJH@NtQueryBootEntryOrder@ 000000014000bb10     HIGU_ntcall:syscall_table.obj
 0002:00001b28       ??_C@_0BD@LOJINLDH@NtQueryBootOptions@ 000000014000bb28     HIGU_ntcall:syscall_table.obj
 0002:00001b40       ??_C@_0BI@FDJONPMK@NtQueryDebugFilterState@ 000000014000bb40     HIGU_ntcall:syscall_table.obj
 0002:00001b58       ??_C@_0BF@PCPECJNE@NtQueryDefaultLocale@ 000000014000bb58     HIGU_ntcall:syscall_table.obj
 0002:00001b70       ??_C@_0BJ@EKJECNDP@NtQueryDefaultUILanguage@ 000000014000bb70     HIGU_ntcall:syscall_table.obj
 0002:00001b90       ??_C@_0BF@CKLGLOIH@NtQueryDirectoryFile@ 000000014000bb90     HIGU_ntcall:syscall_table.obj
 0002:00001ba8       ??_C@_0BH@MJKMAGGE@NtQueryDirectoryFileEx@ 000000014000bba8     HIGU_ntcall:syscall_table.obj
 0002:00001bc0       ??_C@_0BH@CJMGDDIK@NtQueryDirectoryObject@ 000000014000bbc0     HIGU_ntcall:syscall_table.obj
 0002:00001bd8       ??_C@_0BI@LFEBAJHC@NtQueryDriverEntryOrder@ 000000014000bbd8     HIGU_ntcall:syscall_table.obj
 0002:00001bf0       ??_C@_0O@LBEFEKLC@NtQueryEaFile@ 000000014000bbf0     HIGU_ntcall:syscall_table.obj
 0002:00001c00       ??_C@_0N@JEGIMGHC@NtQueryEvent@ 000000014000bc00     HIGU_ntcall:syscall_table.obj
 0002:00001c10       ??_C@_0BK@KGDIPKDC@NtQueryFullAttributesFile@ 000000014000bc10     HIGU_ntcall:syscall_table.obj
 0002:00001c30       ??_C@_0BH@NJHDAPCD@NtQueryInformationAtom@ 000000014000bc30     HIGU_ntcall:syscall_table.obj
 0002:00001c48       ??_C@_0BJ@ENJCMEFN@NtQueryInformationByName@ 000000014000bc48     HIGU_ntcall:syscall_table.obj
 0002:00001c68       ??_C@_0BN@OMFLNKGM@NtQueryInformationEnlistment@ 000000014000bc68     HIGU_ntcall:syscall_table.obj
 0002:00001c88       ??_C@_0BH@DLPGICA@NtQueryInformationFile@ 000000014000bc88     HIGU_ntcall:syscall_table.obj
 0002:00001ca0       ??_C@_0BM@FGJJPIOF@NtQueryInformationJobObject@ 000000014000bca0     HIGU_ntcall:syscall_table.obj
 0002:00001cc0       ??_C@_0BH@IMBFPILE@NtQueryInformationPort@ 000000014000bcc0     HIGU_ntcall:syscall_table.obj
 0002:00001cd8       ??_C@_0BK@EGDDIFMK@NtQueryInformationProcess@ 000000014000bcd8     HIGU_ntcall:syscall_table.obj
 0002:00001cf8       ??_C@_0CC@OKPGONEM@NtQueryInformationResourceManag@ 000000014000bcf8     HIGU_ntcall:syscall_table.obj
 0002:00001d20       ??_C@_0BJ@HKKELGGC@NtQueryInformationThread@ 000000014000bd20     HIGU_ntcall:syscall_table.obj
 0002:00001d40       ??_C@_0BI@JMJKLHAA@NtQueryInformationToken@ 000000014000bd40     HIGU_ntcall:syscall_table.obj
 0002:00001d58       ??_C@_0BO@MCJADJGF@NtQueryInformationTransaction@ 000000014000bd58     HIGU_ntcall:syscall_table.obj
 0002:00001d78       ??_C@_0CF@LKIEJAF@NtQueryInformationTransactionMa@ 000000014000bd78     HIGU_ntcall:syscall_table.obj
 0002:00001da0       ??_C@_0CA@FOAGGJBK@NtQueryInformationWorkerFactory@ 000000014000bda0     HIGU_ntcall:syscall_table.obj
 0002:00001dc0       ??_C@_0BJ@JCCEBMPH@NtQueryInstallUILanguage@ 000000014000bdc0     HIGU_ntcall:syscall_table.obj
 0002:00001de0       ??_C@_0BH@LCOFBMNI@NtQueryIntervalProfile@ 000000014000bde0     HIGU_ntcall:syscall_table.obj
 0002:00001df8       ??_C@_0BE@OHFDNPJI@NtQueryIoCompletion@ 000000014000bdf8     HIGU_ntcall:syscall_table.obj
 0002:00001e10       ??_C@_0L@PJCPMKKH@NtQueryKey@ 000000014000be10     HIGU_ntcall:syscall_table.obj
 0002:00001e20       ??_C@_0BE@EJBAMKCO@NtQueryLicenseValue@ 000000014000be20     HIGU_ntcall:syscall_table.obj
 0002:00001e38       ??_C@_0BI@IPAGEEED@NtQueryMultipleValueKey@ 000000014000be38     HIGU_ntcall:syscall_table.obj
 0002:00001e50       ??_C@_0O@FEOFHACP@NtQueryMutant@ 000000014000be50     HIGU_ntcall:syscall_table.obj
 0002:00001e60       ??_C@_0O@IFMDHOMC@NtQueryObject@ 000000014000be60     HIGU_ntcall:syscall_table.obj
 0002:00001e70       ??_C@_0BD@FCIDHBEC@NtQueryOpenSubKeys@ 000000014000be70     HIGU_ntcall:syscall_table.obj
 0002:00001e88       ??_C@_0BF@HEPKICHL@NtQueryOpenSubKeysEx@ 000000014000be88     HIGU_ntcall:syscall_table.obj
 0002:00001ea0       ??_C@_0BK@LPCLDNPC@NtQueryPerformanceCounter@ 000000014000bea0     HIGU_ntcall:syscall_table.obj
 0002:00001ec0       ??_C@_0BO@NOJMFHHL@NtQueryPortInformationProcess@ 000000014000bec0     HIGU_ntcall:syscall_table.obj
 0002:00001ee0       ??_C@_0BM@HCHCCCLC@NtQueryQuotaInformationFile@ 000000014000bee0     HIGU_ntcall:syscall_table.obj
 0002:00001f00       ??_C@_0P@GFGDHPCO@NtQuerySection@ 000000014000bf00     HIGU_ntcall:syscall_table.obj
 0002:00001f10       ??_C@_0BP@NKBNEFBF@NtQuerySecurityAttributesToken@ 000000014000bf10     HIGU_ntcall:syscall_table.obj
 0002:00001f30       ??_C@_0BG@PMGMABN@NtQuerySecurityObject@ 000000014000bf30     HIGU_ntcall:syscall_table.obj
 0002:00001f48       ??_C@_0BG@FCPGALLB@NtQuerySecurityPolicy@ 000000014000bf48     HIGU_ntcall:syscall_table.obj
 0002:00001f60       ??_C@_0BB@IKGLGKED@NtQuerySemaphore@ 000000014000bf60     HIGU_ntcall:syscall_table.obj
 0002:00001f78       ??_C@_0BK@FFOGOCND@NtQuerySymbolicLinkObject@ 000000014000bf78     HIGU_ntcall:syscall_table.obj
 0002:00001f98       ??_C@_0BO@JEAMHLIF@NtQuerySystemEnvironmentValue@ 000000014000bf98     HIGU_ntcall:syscall_table.obj
 0002:00001fb8       ??_C@_0CA@BAJEOMGD@NtQuerySystemEnvironmentValueEx@ 000000014000bfb8     HIGU_ntcall:syscall_table.obj
 0002:00001fd8       ??_C@_0BJ@NDLOPGCH@NtQuerySystemInformation@ 000000014000bfd8     HIGU_ntcall:syscall_table.obj
 0002:00001ff8       ??_C@_0BL@BPKMIKCH@NtQuerySystemInformationEx@ 000000014000bff8     HIGU_ntcall:syscall_table.obj
 0002:00002018       ??_C@_0N@CBOJHHJH@NtQueryTimer@ 000000014000c018     HIGU_ntcall:syscall_table.obj
 0002:00002028       ??_C@_0BH@HAGJFJGJ@NtQueryTimerResolution@ 000000014000c028     HIGU_ntcall:syscall_table.obj
 0002:00002040       ??_C@_0BA@DHHCHOHP@NtQueryValueKey@ 000000014000c040     HIGU_ntcall:syscall_table.obj
 0002:00002050       ??_C@_0BF@MJPACJIK@NtQueryVirtualMemory@ 000000014000c050     HIGU_ntcall:syscall_table.obj
 0002:00002068       ??_C@_0BN@GNEAHKFP@NtQueryVolumeInformationFile@ 000000014000c068     HIGU_ntcall:syscall_table.obj
 0002:00002088       ??_C@_0BE@KACOKPLP@NtQueryWnfStateData@ 000000014000c088     HIGU_ntcall:syscall_table.obj
 0002:000020a0       ??_C@_0BP@ENMOCPKK@NtQueryWnfStateNameInformation@ 000000014000c0a0     HIGU_ntcall:syscall_table.obj
 0002:000020c0       ??_C@_0BB@NNNBNIDF@NtQueueApcThread@ 000000014000c0c0     HIGU_ntcall:syscall_table.obj
 0002:000020d8       ??_C@_0BD@LLIOPJFE@NtQueueApcThreadEx@ 000000014000c0d8     HIGU_ntcall:syscall_table.obj
 0002:000020f0       ??_C@_0BB@KAHALOMK@NtRaiseException@ 000000014000c0f0     HIGU_ntcall:syscall_table.obj
 0002:00002108       ??_C@_0BB@PJBDBFCM@NtRaiseHardError@ 000000014000c108     HIGU_ntcall:syscall_table.obj
 0002:00002120       ??_C@_0L@FNDFCMOM@NtReadFile@ 000000014000c120     HIGU_ntcall:syscall_table.obj
 0002:00002130       ??_C@_0BC@PNINPEHO@NtReadFileScatter@ 000000014000c130     HIGU_ntcall:syscall_table.obj
 0002:00002148       ??_C@_0BF@OICIHHMO@NtReadOnlyEnlistment@ 000000014000c148     HIGU_ntcall:syscall_table.obj
 0002:00002160       ??_C@_0BC@ELJDDKPB@NtReadRequestData@ 000000014000c160     HIGU_ntcall:syscall_table.obj
 0002:00002178       ??_C@_0BE@NOMFEDAI@NtReadVirtualMemory@ 000000014000c178     HIGU_ntcall:syscall_table.obj
 0002:00002190       ??_C@_0BE@KALDMNEK@NtRecoverEnlistment@ 000000014000c190     HIGU_ntcall:syscall_table.obj
 0002:000021a8       ??_C@_0BJ@JCIENJNP@NtRecoverResourceManager@ 000000014000c1a8     HIGU_ntcall:syscall_table.obj
 0002:000021c8       ??_C@_0BM@PBNMKMDD@NtRecoverTransactionManager@ 000000014000c1c8     HIGU_ntcall:syscall_table.obj
 0002:000021e8       ??_C@_0CF@FEGIOPAP@NtRegisterProtocolAddressInform@ 000000014000c1e8     HIGU_ntcall:syscall_table.obj
 0002:00002210       ??_C@_0BO@FPABIJCL@NtRegisterThreadTerminatePort@ 000000014000c210     HIGU_ntcall:syscall_table.obj
 0002:00002230       ??_C@_0BE@EHEKCOOF@NtReleaseKeyedEvent@ 000000014000c230     HIGU_ntcall:syscall_table.obj
 0002:00002248       ??_C@_0BA@NPBLEMEB@NtReleaseMutant@ 000000014000c248     HIGU_ntcall:syscall_table.obj
 0002:00002258       ??_C@_0BD@OBNECKAG@NtReleaseSemaphore@ 000000014000c258     HIGU_ntcall:syscall_table.obj
 0002:00002270       ??_C@_0BN@PODFDHEG@NtReleaseWorkerFactoryWorker@ 000000014000c270     HIGU_ntcall:syscall_table.obj
 0002:00002290       ??_C@_0BF@CDFPHBAL@NtRemoveIoCompletion@ 000000014000c290     HIGU_ntcall:syscall_table.obj
 0002:000022a8       ??_C@_0BH@FFEBAHOL@NtRemoveIoCompletionEx@ 000000014000c2a8     HIGU_ntcall:syscall_table.obj
 0002:000022c0       ??_C@_0BF@DGADPHCG@NtRemoveProcessDebug@ 000000014000c2c0     HIGU_ntcall:syscall_table.obj
 0002:000022d8       ??_C@_0M@EJHKOLLI@NtRenameKey@ 000000014000c2d8     HIGU_ntcall:syscall_table.obj
 0002:000022e8       ??_C@_0BL@KGMPAFCH@NtRenameTransactionManager@ 000000014000c2e8     HIGU_ntcall:syscall_table.obj
 0002:00002308       ??_C@_0N@PONAJFMN@NtReplaceKey@ 000000014000c308     HIGU_ntcall:syscall_table.obj
 0002:00002318       ??_C@_0BH@MOADIFJD@NtReplacePartitionUnit@ 000000014000c318     HIGU_ntcall:syscall_table.obj
 0002:00002330       ??_C@_0M@DDINCNML@NtReplyPort@ 000000014000c330     HIGU_ntcall:syscall_table.obj
 0002:00002340       ??_C@_0BH@BPMBBKBI@NtReplyWaitReceivePort@ 000000014000c340     HIGU_ntcall:syscall_table.obj
 0002:00002358       ??_C@_0BJ@OOMOMCDH@NtReplyWaitReceivePortEx@ 000000014000c358     HIGU_ntcall:syscall_table.obj
 0002:00002378       ??_C@_0BF@PBGBKKGF@NtReplyWaitReplyPort@ 000000014000c378     HIGU_ntcall:syscall_table.obj
 0002:00002390       ??_C@_0O@BOBPKHGC@NtRequestPort@ 000000014000c390     HIGU_ntcall:syscall_table.obj
 0002:000023a0       ??_C@_0BH@LIPIHGDN@NtRequestWaitReplyPort@ 000000014000c3a0     HIGU_ntcall:syscall_table.obj
 0002:000023b8       ??_C@_0N@OCFHEDJC@NtResetEvent@ 000000014000c3b8     HIGU_ntcall:syscall_table.obj
 0002:000023c8       ??_C@_0BC@KEHKHLKK@NtResetWriteWatch@ 000000014000c3c8     HIGU_ntcall:syscall_table.obj
 0002:000023e0       ??_C@_0N@PALGCJPF@NtRestoreKey@ 000000014000c3e0     HIGU_ntcall:syscall_table.obj
 0002:000023f0       ??_C@_0BA@PNNBPCAM@NtResumeProcess@ 000000014000c3f0     HIGU_ntcall:syscall_table.obj
 0002:00002400       ??_C@_0P@JDJEHDNH@NtResumeThread@ 000000014000c400     HIGU_ntcall:syscall_table.obj
 0002:00002410       ??_C@_0BP@HGNHJNMG@NtRevertContainerImpersonation@ 000000014000c410     HIGU_ntcall:syscall_table.obj
 0002:00002430       ??_C@_0BD@JPJHNEHO@NtRollbackComplete@ 000000014000c430     HIGU_ntcall:syscall_table.obj
 0002:00002448       ??_C@_0BF@HOAMNACO@NtRollbackEnlistment@ 000000014000c448     HIGU_ntcall:syscall_table.obj
 0002:00002460       ??_C@_0BO@DNEHOCJN@NtRollbackRegistryTransaction@ 000000014000c460     HIGU_ntcall:syscall_table.obj
 0002:00002480       ??_C@_0BG@FKNAEOND@NtRollbackTransaction@ 000000014000c480     HIGU_ntcall:syscall_table.obj
 0002:00002498       ??_C@_0CA@OJPLBLBK@NtRollforwardTransactionManager@ 000000014000c498     HIGU_ntcall:syscall_table.obj
 0002:000024b8       ??_C@_09LHHMIDJO@NtSaveKey@ 000000014000c4b8     HIGU_ntcall:syscall_table.obj
 0002:000024c8       ??_C@_0M@KMEHOKH@NtSaveKeyEx@ 000000014000c4c8     HIGU_ntcall:syscall_table.obj
 0002:000024d8       ??_C@_0BB@BNJINEEL@NtSaveMergedKeys@ 000000014000c4d8     HIGU_ntcall:syscall_table.obj
 0002:000024f0       ??_C@_0BE@KDCINMJB@NtSecureConnectPort@ 000000014000c4f0     HIGU_ntcall:syscall_table.obj
 0002:00002508       ??_C@_0BA@CIJPFAJI@NtSerializeBoot@ 000000014000c508     HIGU_ntcall:syscall_table.obj
 0002:00002518       ??_C@_0BE@MBHFLLFN@NtSetBootEntryOrder@ 000000014000c518     HIGU_ntcall:syscall_table.obj
 0002:00002530       ??_C@_0BB@GDHPOCNN@NtSetBootOptions@ 000000014000c530     HIGU_ntcall:syscall_table.obj
 0002:00002548       ??_C@_0BI@GPJHFEDJ@NtSetCachedSigningLevel@ 000000014000c548     HIGU_ntcall:syscall_table.obj
 0002:00002560       ??_C@_0BJ@LCBKELCN@NtSetCachedSigningLevel2@ 000000014000c560     HIGU_ntcall:syscall_table.obj
 0002:00002580       ??_C@_0BD@NDMIEODP@NtSetContextThread@ 000000014000c580     HIGU_ntcall:syscall_table.obj
 0002:00002598       ??_C@_0BG@CEOCMKOI@NtSetDebugFilterState@ 000000014000c598     HIGU_ntcall:syscall_table.obj
 0002:000025b0       ??_C@_0BK@FPJBCIPD@NtSetDefaultHardErrorPort@ 000000014000c5b0     HIGU_ntcall:syscall_table.obj
 0002:000025d0       ??_C@_0BD@JGAGHFN@NtSetDefaultLocale@ 000000014000c5d0     HIGU_ntcall:syscall_table.obj
 0002:000025e8       ??_C@_0BH@JPIDBAMO@NtSetDefaultUILanguage@ 000000014000c5e8     HIGU_ntcall:syscall_table.obj
 0002:00002600       ??_C@_0BG@MCDNBMFA@NtSetDriverEntryOrder@ 000000014000c600     HIGU_ntcall:syscall_table.obj
 0002:00002618       ??_C@_0M@GCAPCECC@NtSetEaFile@ 000000014000c618     HIGU_ntcall:syscall_table.obj
 0002:00002628       ??_C@_0L@IPCKNBF@NtSetEvent@ 000000014000c628     HIGU_ntcall:syscall_table.obj
 0002:00002638       ??_C@_0BI@NFGLIKAP@NtSetEventBoostPriority@ 000000014000c638     HIGU_ntcall:syscall_table.obj
 0002:00002650       ??_C@_0BD@GMDBBIMF@NtSetHighEventPair@ 000000014000c650     HIGU_ntcall:syscall_table.obj
 0002:00002668       ??_C@_0BK@PCGMCADO@NtSetHighWaitLowEventPair@ 000000014000c668     HIGU_ntcall:syscall_table.obj
 0002:00002688       ??_C@_0N@PAINDLMB@NtSetIRTimer@ 000000014000c688     HIGU_ntcall:syscall_table.obj
 0002:00002698       ??_C@_0BM@JOMKIEBB@NtSetInformationDebugObject@ 000000014000c698     HIGU_ntcall:syscall_table.obj
 0002:000026b8       ??_C@_0BL@NAIHPKA@NtSetInformationEnlistment@ 000000014000c6b8     HIGU_ntcall:syscall_table.obj
 0002:000026d8       ??_C@_0BF@HIJKNMCB@NtSetInformationFile@ 000000014000c6d8     HIGU_ntcall:syscall_table.obj
 0002:000026f0       ??_C@_0BK@LKECMKO@NtSetInformationJobObject@ 000000014000c6f0     HIGU_ntcall:syscall_table.obj
 0002:00002710       ??_C@_0BE@GMAINBDC@NtSetInformationKey@ 000000014000c710     HIGU_ntcall:syscall_table.obj
 0002:00002728       ??_C@_0BH@HCCHHKLN@NtSetInformationObject@ 000000014000c728     HIGU_ntcall:syscall_table.obj
 0002:00002740       ??_C@_0BI@IMFMFAHN@NtSetInformationProcess@ 000000014000c740     HIGU_ntcall:syscall_table.obj
 0002:00002758       ??_C@_0CA@JFDJFDOF@NtSetInformationResourceManager@ 000000014000c758     HIGU_ntcall:syscall_table.obj
 0002:00002778       ??_C@_0BN@CBDPHPJK@NtSetInformationSymbolicLink@ 000000014000c778     HIGU_ntcall:syscall_table.obj
 0002:00002798       ??_C@_0BH@KPLDILJD@NtSetInformationThread@ 000000014000c798     HIGU_ntcall:syscall_table.obj
 0002:000027b0       ??_C@_0BG@OLOGKCCC@NtSetInformationToken@ 000000014000c7b0     HIGU_ntcall:syscall_table.obj
 0002:000027c8       ??_C@_0BM@FAKDOEFL@NtSetInformationTransaction@ 000000014000c7c8     HIGU_ntcall:syscall_table.obj
 0002:000027e8       ??_C@_0CD@KMJMHDIC@NtSetInformationTransactionMana@ 000000014000c7e8     HIGU_ntcall:syscall_table.obj
 0002:00002810       ??_C@_0BO@IOKEIEFP@NtSetInformationVirtualMemory@ 000000014000c810     HIGU_ntcall:syscall_table.obj
 0002:00002830       ??_C@_0BO@OHKBEODN@NtSetInformationWorkerFactory@ 000000014000c830     HIGU_ntcall:syscall_table.obj
 0002:00002850       ??_C@_0BF@MJMAKINJ@NtSetIntervalProfile@ 000000014000c850     HIGU_ntcall:syscall_table.obj
 0002:00002868       ??_C@_0BC@KHFBDDMH@NtSetIoCompletion@ 000000014000c868     HIGU_ntcall:syscall_table.obj
 0002:00002880       ??_C@_0BE@KKNMDLBL@NtSetIoCompletionEx@ 000000014000c880     HIGU_ntcall:syscall_table.obj
 0002:00002898       ??_C@_0BA@PCAGBHHB@NtSetLdtEntries@ 000000014000c898     HIGU_ntcall:syscall_table.obj
 0002:000028a8       ??_C@_0BC@CMGGIIGD@NtSetLowEventPair@ 000000014000c8a8     HIGU_ntcall:syscall_table.obj
 0002:000028c0       ??_C@_0BK@LDKHMHBF@NtSetLowWaitHighEventPair@ 000000014000c8c0     HIGU_ntcall:syscall_table.obj
 0002:000028e0       ??_C@_0BK@CPEPPGPJ@NtSetQuotaInformationFile@ 000000014000c8e0     HIGU_ntcall:syscall_table.obj
 0002:00002900       ??_C@_0BE@JLFJGPNH@NtSetSecurityObject@ 000000014000c900     HIGU_ntcall:syscall_table.obj
 0002:00002918       ??_C@_0BM@GDPKGLL@NtSetSystemEnvironmentValue@ 000000014000c918     HIGU_ntcall:syscall_table.obj
 0002:00002938       ??_C@_0BO@KJDDMLEE@NtSetSystemEnvironmentValueEx@ 000000014000c938     HIGU_ntcall:syscall_table.obj
 0002:00002958       ??_C@_0BH@GKJMLNG@NtSetSystemInformation@ 000000014000c958     HIGU_ntcall:syscall_table.obj
 0002:00002970       ??_C@_0BG@LKNAFPLL@NtSetSystemPowerState@ 000000014000c970     HIGU_ntcall:syscall_table.obj
 0002:00002988       ??_C@_0BA@EKIKCKGM@NtSetSystemTime@ 000000014000c988     HIGU_ntcall:syscall_table.obj
 0002:00002998       ??_C@_0BK@FENHPAA@NtSetThreadExecutionState@ 000000014000c998     HIGU_ntcall:syscall_table.obj
 0002:000029b8       ??_C@_0L@LNHDBMPA@NtSetTimer@ 000000014000c9b8     HIGU_ntcall:syscall_table.obj
 0002:000029c8       ??_C@_0M@FAHANFHB@NtSetTimer2@ 000000014000c9c8     HIGU_ntcall:syscall_table.obj
 0002:000029d8       ??_C@_0N@JBAKLMFE@NtSetTimerEx@ 000000014000c9d8     HIGU_ntcall:syscall_table.obj
 0002:000029e8       ??_C@_0BF@LEMONGI@NtSetTimerResolution@ 000000014000c9e8     HIGU_ntcall:syscall_table.obj
 0002:00002a00       ??_C@_0O@CGBHGPMK@NtSetUuidSeed@ 000000014000ca00     HIGU_ntcall:syscall_table.obj
 0002:00002a10       ??_C@_0O@OMDJGLHA@NtSetValueKey@ 000000014000ca10     HIGU_ntcall:syscall_table.obj
 0002:00002a20       ??_C@_0BL@IMBDNPJD@NtSetVolumeInformationFile@ 000000014000ca20     HIGU_ntcall:syscall_table.obj
 0002:00002a40       ??_C@_0CB@FFEAIEGN@NtSetWnfProcessNotificationEven@ 000000014000ca40     HIGU_ntcall:syscall_table.obj
 0002:00002a68       ??_C@_0BB@OKOALOPC@NtShutdownSystem@ 000000014000ca68     HIGU_ntcall:syscall_table.obj
 0002:00002a80       ??_C@_0BI@BAGHBGLM@NtShutdownWorkerFactory@ 000000014000ca80     HIGU_ntcall:syscall_table.obj
 0002:00002a98       ??_C@_0BP@CPDJPMNC@NtSignalAndWaitForSingleObject@ 000000014000ca98     HIGU_ntcall:syscall_table.obj
 0002:00002ab8       ??_C@_0BE@NPNIJDFD@NtSinglePhaseReject@ 000000014000cab8     HIGU_ntcall:syscall_table.obj
 0002:00002ad0       ??_C@_0P@HPKKNEHH@NtStartProfile@ 000000014000cad0     HIGU_ntcall:syscall_table.obj
 0002:00002ae0       ??_C@_0O@NFBCBPHH@NtStopProfile@ 000000014000cae0     HIGU_ntcall:syscall_table.obj
 0002:00002af0       ??_C@_0BK@MLIKPHJJ@NtSubscribeWnfStateChange@ 000000014000caf0     HIGU_ntcall:syscall_table.obj
 0002:00002b10       ??_C@_0BB@ELOHAJKJ@NtSuspendProcess@ 000000014000cb10     HIGU_ntcall:syscall_table.obj
 0002:00002b28       ??_C@_0BA@MDECOLOI@NtSuspendThread@ 000000014000cb28     HIGU_ntcall:syscall_table.obj
 0002:00002b38       ??_C@_0BF@OAMAAEOC@NtSystemDebugControl@ 000000014000cb38     HIGU_ntcall:syscall_table.obj
 0002:00002b50       ??_C@_0BD@ECILFAEG@NtTerminateEnclave@ 000000014000cb50     HIGU_ntcall:syscall_table.obj
 0002:00002b68       ??_C@_0BF@DLIBFGAL@NtTerminateJobObject@ 000000014000cb68     HIGU_ntcall:syscall_table.obj
 0002:00002b80       ??_C@_0BD@LGANCOHC@NtTerminateProcess@ 000000014000cb80     HIGU_ntcall:syscall_table.obj
 0002:00002b98       ??_C@_0BC@ELJMEKPC@NtTerminateThread@ 000000014000cb98     HIGU_ntcall:syscall_table.obj
 0002:00002bb0       ??_C@_0M@HGILIOF@NtTestAlert@ 000000014000cbb0     HIGU_ntcall:syscall_table.obj
 0002:00002bc0       ??_C@_0P@MICHALMF@NtThawRegistry@ 000000014000cbc0     HIGU_ntcall:syscall_table.obj
 0002:00002bd0       ??_C@_0BD@CIOAIGDL@NtThawTransactions@ 000000014000cbd0     HIGU_ntcall:syscall_table.obj
 0002:00002be8       ??_C@_0P@OPOOMCCE@NtTraceControl@ 000000014000cbe8     HIGU_ntcall:syscall_table.obj
 0002:00002bf8       ??_C@_0N@EKGAOHEK@NtTraceEvent@ 000000014000cbf8     HIGU_ntcall:syscall_table.obj
 0002:00002c08       ??_C@_0BE@KBDFPLGP@NtTranslateFilePath@ 000000014000cc08     HIGU_ntcall:syscall_table.obj
 0002:00002c20       ??_C@_0BB@BLPEBHJ@NtUmsThreadYield@ 000000014000cc20     HIGU_ntcall:syscall_table.obj
 0002:00002c38       ??_C@_0P@DDPHPNPN@NtUnloadDriver@ 000000014000cc38     HIGU_ntcall:syscall_table.obj
 0002:00002c48       ??_C@_0M@HBELPLPH@NtUnloadKey@ 000000014000cc48     HIGU_ntcall:syscall_table.obj
 0002:00002c58       ??_C@_0N@MONIHIDF@NtUnloadKey2@ 000000014000cc58     HIGU_ntcall:syscall_table.obj
 0002:00002c68       ??_C@_0O@OACFJBHA@NtUnloadKeyEx@ 000000014000cc68     HIGU_ntcall:syscall_table.obj
 0002:00002c78       ??_C@_0N@PFEAAKMI@NtUnlockFile@ 000000014000cc78     HIGU_ntcall:syscall_table.obj
 0002:00002c88       ??_C@_0BG@HFNOJHHJ@NtUnlockVirtualMemory@ 000000014000cc88     HIGU_ntcall:syscall_table.obj
 0002:00002ca0       ??_C@_0BF@HJLDAPGE@NtUnmapViewOfSection@ 000000014000cca0     HIGU_ntcall:syscall_table.obj
 0002:00002cb8       ??_C@_0BH@JJHGFE@NtUnmapViewOfSectionEx@ 000000014000ccb8     HIGU_ntcall:syscall_table.obj
 0002:00002cd0       ??_C@_0BM@LHIFFFMJ@NtUnsubscribeWnfStateChange@ 000000014000ccd0     HIGU_ntcall:syscall_table.obj
 0002:00002cf0       ??_C@_0BF@NPHHEHP@NtUpdateWnfStateData@ 000000014000ccf0     HIGU_ntcall:syscall_table.obj
 0002:00002d08       ??_C@_0N@NKDCFKPF@NtVdmControl@ 000000014000cd08     HIGU_ntcall:syscall_table.obj
 0002:00002d18       ??_C@_0BJ@LNBJOAPO@NtWaitForAlertByThreadId@ 000000014000cd18     HIGU_ntcall:syscall_table.obj
 0002:00002d38       ??_C@_0BE@FJNCDLOK@NtWaitForDebugEvent@ 000000014000cd38     HIGU_ntcall:syscall_table.obj
 0002:00002d50       ??_C@_0BE@KJOMDIDG@NtWaitForKeyedEvent@ 000000014000cd50     HIGU_ntcall:syscall_table.obj
 0002:00002d68       ??_C@_0BJ@BILIDCAB@NtWaitForMultipleObjects@ 000000014000cd68     HIGU_ntcall:syscall_table.obj
 0002:00002d88       ??_C@_0BL@BKJBHHMB@NtWaitForMultipleObjects32@ 000000014000cd88     HIGU_ntcall:syscall_table.obj
 0002:00002da8       ??_C@_0BG@LHJPPGIC@NtWaitForSingleObject@ 000000014000cda8     HIGU_ntcall:syscall_table.obj
 0002:00002dc0       ??_C@_0BO@IEGJOEEP@NtWaitForWorkViaWorkerFactory@ 000000014000cdc0     HIGU_ntcall:syscall_table.obj
 0002:00002de0       ??_C@_0BE@CABDHKOG@NtWaitHighEventPair@ 000000014000cde0     HIGU_ntcall:syscall_table.obj
 0002:00002df8       ??_C@_0BD@GHBEPFEC@NtWaitLowEventPair@ 000000014000cdf8     HIGU_ntcall:syscall_table.obj
 0002:00002e10       ??_C@_0BL@JDEBBJBE@NtWorkerFactoryWorkerReady@ 000000014000ce10     HIGU_ntcall:syscall_table.obj
 0002:00002e30       ??_C@_0M@NBHOGDOK@NtWriteFile@ 000000014000ce30     HIGU_ntcall:syscall_table.obj
 0002:00002e40       ??_C@_0BC@INDHKBIF@NtWriteFileGather@ 000000014000ce40     HIGU_ntcall:syscall_table.obj
 0002:00002e58       ??_C@_0BD@FOOBNHKJ@NtWriteRequestData@ 000000014000ce58     HIGU_ntcall:syscall_table.obj
 0002:00002e70       ??_C@_0BF@HCBMBPOD@NtWriteVirtualMemory@ 000000014000ce70     HIGU_ntcall:syscall_table.obj
 0002:00002e88       ??_C@_0BB@JNBHLPLK@NtYieldExecution@ 000000014000ce88     HIGU_ntcall:syscall_table.obj
 0002:00003d90       _load_config_used          000000014000dd90     MSVCRT:loadcfg.obj
 0002:000041e0       __rtc_iaa                  000000014000e1e0     MSVCRT:initsect.obj
 0002:000041e8       __rtc_izz                  000000014000e1e8     MSVCRT:initsect.obj
 0002:000041f0       __rtc_taa                  000000014000e1f0     MSVCRT:initsect.obj
 0002:000041f8       __rtc_tzz                  000000014000e1f8     MSVCRT:initsect.obj
 0002:00007434       __IMPORT_DESCRIPTOR_MSVCP140 0000000140011434     msvcprt:MSVCP140.dll
 0002:00007448       __IMPORT_DESCRIPTOR_VCRUNTIME140_1 0000000140011448     vcruntime:VCRUNTIME140_1.dll
 0002:0000745c       __IMPORT_DESCRIPTOR_VCRUNTIME140 000000014001145c     vcruntime:VCRUNTIME140.dll
 0002:00007470       __IMPORT_DESCRIPTOR_api-ms-win-crt-runtime-l1-1-0 0000000140011470     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0002:00007484       __IMPORT_DESCRIPTOR_api-ms-win-crt-math-l1-1-0 0000000140011484     ucrt:api-ms-win-crt-math-l1-1-0.dll
 0002:00007498       __IMPORT_DESCRIPTOR_api-ms-win-crt-stdio-l1-1-0 0000000140011498     ucrt:api-ms-win-crt-stdio-l1-1-0.dll
 0002:000074ac       __IMPORT_DESCRIPTOR_api-ms-win-crt-locale-l1-1-0 00000001400114ac     ucrt:api-ms-win-crt-locale-l1-1-0.dll
 0002:000074c0       __IMPORT_DESCRIPTOR_api-ms-win-crt-heap-l1-1-0 00000001400114c0     ucrt:api-ms-win-crt-heap-l1-1-0.dll
 0002:000074d4       __IMPORT_DESCRIPTOR_KERNEL32 00000001400114d4     kernel32:KERNEL32.dll
 0002:000074e8       __NULL_IMPORT_DESCRIPTOR   00000001400114e8     msvcprt:MSVCP140.dll
 0003:00000000       __security_cookie_complement 0000000140012000     MSVCRT:gs_cookie.obj
 0003:00000008       __security_cookie          0000000140012008     MSVCRT:gs_cookie.obj
 0003:00000010       __scrt_native_dllmain_reason 0000000140012010     MSVCRT:utility.obj
 0003:00000014       __scrt_default_matherr     0000000140012014     MSVCRT:matherr.obj
 0003:00000018       __isa_available            0000000140012018     MSVCRT:cpu_disp.obj
 0003:0000001c       __isa_enabled              000000014001201c     MSVCRT:cpu_disp.obj
 0003:00000020       __memcpy_nt_iters          0000000140012020     MSVCRT:cpu_disp.obj
 0003:00000028       __memset_nt_iters          0000000140012028     MSVCRT:cpu_disp.obj
 0003:00000030       __scrt_ucrt_dll_is_in_use  0000000140012030     MSVCRT:ucrt_stubs.obj
 0003:00000040       ?syscall_table@@3PAIA      0000000140012040     HIGU_ntcall:syscall_table.obj
 0003:00000cf0       __scrt_current_native_startup_state 0000000140012cf0     MSVCRT:utility.obj
 0003:00000cf8       __scrt_native_startup_lock 0000000140012cf8     MSVCRT:utility.obj
 0003:00000d40       ?__type_info_root_node@@3U__type_info_node@@A 0000000140012d40     MSVCRT:tncleanup.obj
 0003:00000d50       ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA 0000000140012d50     MSVCRT:default_local_stdio_options.obj
 0003:00000d58       ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA 0000000140012d58     MSVCRT:default_local_stdio_options.obj
 0003:00000d60       __scrt_debugger_hook_flag  0000000140012d60     MSVCRT:utility_desktop.obj
 0003:00000d68       __castguard_check_failure_os_handled_fptr 0000000140012d68     MSVCRT:guard_support.obj
 0003:00000d70       __favor                    0000000140012d70     MSVCRT:cpu_disp.obj
 0003:00000d74       __@@_PchSym_@00@UkilqvxghUsrtfPmgxzooUgnkUsrtfPmgxzooPivovzhvGEUkxsOlyq@4B2008FD98C1DD4 0000000140012d74     HIGU_ntcall:pch.obj
 0003:00000d90       __dyn_tls_dtor_callback    0000000140012d90     <common>
 0003:00000d98       __dyn_tls_init_callback    0000000140012d98     <common>

 entry point at        0001:000081b4

 Static symbols

 0000:fffe9000       .debug$S                   0000000140000000     test_app.exp
 0000:fffe9000       .debug$S                   0000000140000000     msvcprt:MSVCP140.dll
 0000:fffe9000       .debug$S                   0000000140000000     msvcprt:MSVCP140.dll
 0000:fffe9000       .debug$S                   0000000140000000     msvcprt:MSVCP140.dll
 0000:fffe9000       .debug$S                   0000000140000000     msvcprt:MSVCP140.dll
 0000:fffe9000       .debug$S                   0000000140000000     msvcprt:MSVCP140.dll
 0000:fffe9000       .debug$S                   0000000140000000     msvcprt:MSVCP140.dll
 0000:fffe9000       .debug$S                   0000000140000000     msvcprt:MSVCP140.dll
 0000:fffe9000       .debug$S                   0000000140000000     msvcprt:MSVCP140.dll
 0000:fffe9000       .debug$S                   0000000140000000     msvcprt:MSVCP140.dll
 0000:fffe9000       .debug$S                   0000000140000000     msvcprt:MSVCP140.dll
 0000:fffe9000       .debug$S                   0000000140000000     msvcprt:MSVCP140.dll
 0000:fffe9000       .debug$S                   0000000140000000     msvcprt:MSVCP140.dll
 0000:fffe9000       .debug$S                   0000000140000000     msvcprt:MSVCP140.dll
 0000:fffe9000       .debug$S                   0000000140000000     msvcprt:MSVCP140.dll
 0000:fffe9000       .debug$S                   0000000140000000     msvcprt:MSVCP140.dll
 0000:fffe9000       .debug$S                   0000000140000000     vcruntime:VCRUNTIME140.dll
 0000:fffe9000       .debug$S                   0000000140000000     vcruntime:VCRUNTIME140.dll
 0000:fffe9000       .debug$S                   0000000140000000     vcruntime:VCRUNTIME140.dll
 0000:fffe9000       .debug$S                   0000000140000000     vcruntime:VCRUNTIME140.dll
 0000:fffe9000       .debug$S                   0000000140000000     vcruntime:VCRUNTIME140.dll
 0000:fffe9000       .debug$S                   0000000140000000     vcruntime:VCRUNTIME140.dll
 0000:fffe9000       .debug$S                   0000000140000000     vcruntime:VCRUNTIME140_1.dll
 0000:fffe9000       .debug$S                   0000000140000000     ucrt:api-ms-win-crt-heap-l1-1-0.dll
 0000:fffe9000       .debug$S                   0000000140000000     ucrt:api-ms-win-crt-locale-l1-1-0.dll
 0000:fffe9000       .debug$S                   0000000140000000     ucrt:api-ms-win-crt-math-l1-1-0.dll
 0000:fffe9000       .debug$S                   0000000140000000     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0000:fffe9000       .debug$S                   0000000140000000     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0000:fffe9000       .debug$S                   0000000140000000     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0000:fffe9000       .debug$S                   0000000140000000     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0000:fffe9000       .debug$S                   0000000140000000     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0000:fffe9000       .debug$S                   0000000140000000     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0000:fffe9000       .debug$S                   0000000140000000     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0000:fffe9000       .debug$S                   0000000140000000     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0000:fffe9000       .debug$S                   0000000140000000     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0000:fffe9000       .debug$S                   0000000140000000     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0000:fffe9000       .debug$S                   0000000140000000     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0000:fffe9000       .debug$S                   0000000140000000     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0000:fffe9000       .debug$S                   0000000140000000     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0000:fffe9000       .debug$S                   0000000140000000     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0000:fffe9000       .debug$S                   0000000140000000     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0000:fffe9000       .debug$S                   0000000140000000     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0000:fffe9000       .debug$S                   0000000140000000     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0000:fffe9000       .debug$S                   0000000140000000     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0000:fffe9000       .debug$S                   0000000140000000     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0000:fffe9000       .debug$S                   0000000140000000     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0000:fffe9000       .debug$S                   0000000140000000     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0000:fffe9000       .debug$S                   0000000140000000     ucrt:api-ms-win-crt-stdio-l1-1-0.dll
 0000:fffe9000       .debug$S                   0000000140000000     ucrt:api-ms-win-crt-stdio-l1-1-0.dll
 0000:fffe9000       .debug$S                   0000000140000000     kernel32:KERNEL32.dll
 0000:fffe9000       .debug$S                   0000000140000000     kernel32:KERNEL32.dll
 0000:fffe9000       .debug$S                   0000000140000000     kernel32:KERNEL32.dll
 0000:fffe9000       .debug$S                   0000000140000000     kernel32:KERNEL32.dll
 0000:fffe9000       .debug$S                   0000000140000000     kernel32:KERNEL32.dll
 0000:fffe9000       .debug$S                   0000000140000000     kernel32:KERNEL32.dll
 0000:fffe9000       .debug$S                   0000000140000000     kernel32:KERNEL32.dll
 0000:fffe9000       .debug$S                   0000000140000000     kernel32:KERNEL32.dll
 0000:fffe9000       .debug$S                   0000000140000000     kernel32:KERNEL32.dll
 0000:fffe9000       .debug$S                   0000000140000000     kernel32:KERNEL32.dll
 0000:fffe9000       .debug$S                   0000000140000000     kernel32:KERNEL32.dll
 0000:fffe9000       .debug$S                   0000000140000000     kernel32:KERNEL32.dll
 0000:fffe9000       .debug$S                   0000000140000000     kernel32:KERNEL32.dll
 0000:fffe9000       .debug$S                   0000000140000000     kernel32:KERNEL32.dll
 0000:fffe9000       .debug$S                   0000000140000000     kernel32:KERNEL32.dll
 0000:fffe9000       .debug$S                   0000000140000000     kernel32:KERNEL32.dll
 0001:00007dd0       $$000000                   0000000140008dd0     HIGU_ntcall:impl_cleancall_64.obj
 0001:00007f20       $$000000                   0000000140008f20     MSVCRT:amdsecgs.obj
 0001:00007f54       ?pre_c_initialization@@YAHXZ 0000000140008f54 f   MSVCRT:exe_main.obj
 0001:0000800c       ?post_pgo_initialization@@YAHXZ 000000014000900c f   MSVCRT:exe_main.obj
 0001:0000801c       ?pre_cpp_initialization@@YAXXZ 000000014000901c f   MSVCRT:exe_main.obj
 0001:00008038       ?__scrt_common_main_seh@@YAHXZ 0000000140009038 f   MSVCRT:exe_main.obj
 0001:000082d0       capture_previous_context   00000001400092d0 f   MSVCRT:gs_report.obj
 0001:00008c30       $$000000                   0000000140009c30     MSVCRT:guard_dispatch.obj
 0001:00008c50       $$000000                   0000000140009c50     MSVCRT:guard_xfg_dispatch.obj
 0001:00008c70       ?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA 0000000140009c70 f   test_app.obj
 0001:00008c7c       ?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA 0000000140009c7c f   test_app.obj
 0001:00008c88       ?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA 0000000140009c88 f   test_app.obj
 0001:00008c95       __catch$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z$0 0000000140009c95 f   test_app.obj
 0001:00008cc3       ?filt$0@?0??__scrt_common_main_seh@@YAHXZ@4HA 0000000140009cc3 f   MSVCRT:exe_main.obj
 0001:00008ce1       __scrt_is_nonwritable_in_current_image$filt$0 0000000140009ce1 f   MSVCRT:utility.obj
 0002:00000210       ?pre_cpp_initializer@@3P6AXXZEA 000000014000a210     MSVCRT:exe_main.obj
 0002:00000228       ?pre_c_initializer@@3P6AHXZEA 000000014000a228     MSVCRT:exe_main.obj
 0002:00000230       ?post_pgo_initializer@@3P6AHXZEA 000000014000a230     MSVCRT:exe_main.obj
 0002:00000260       GS_ExceptionPointers       000000014000a260     MSVCRT:gs_report.obj
 0002:00002ea0       ?syscall_table_names@@3PAPEBDA 000000014000cea0     HIGU_ntcall:syscall_table.obj
 0002:00004200       $unwind$main               000000014000e200     test_app.obj
 0002:00004210       $unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z 000000014000e210     test_app.obj
 0002:00004228       $cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z 000000014000e228     test_app.obj
 0002:00004235       $stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z 000000014000e235     test_app.obj
 0002:0000424e       $tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z 000000014000e24e     test_app.obj
 0002:00004256       $handlerMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z 000000014000e256     test_app.obj
 0002:0000425f       $ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z 000000014000e25f     test_app.obj
 0002:00004270       $unwind$?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA 000000014000e270     test_app.obj
 0002:00004278       $unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ 000000014000e278     test_app.obj
 0002:00004288       $cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ 000000014000e288     test_app.obj
 0002:00004291       $stateUnwindMap$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ 000000014000e291     test_app.obj
 0002:00004297       $ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ 000000014000e297     test_app.obj
 0002:0000429c       $unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ 000000014000e29c     test_app.obj
 0002:000042ac       $cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ 000000014000e2ac     test_app.obj
 0002:000042b1       $ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ 000000014000e2b1     test_app.obj
 0002:000042b4       $unwind$initialize_syscall_table_by_mapped 000000014000e2b4     HIGU_ntcall:syscall_table_initialize.obj
 0002:000042bc       $chain$6$initialize_syscall_table_by_mapped 000000014000e2bc     HIGU_ntcall:syscall_table_initialize.obj
 0002:000042e8       $chain$7$initialize_syscall_table_by_mapped 000000014000e2e8     HIGU_ntcall:syscall_table_initialize.obj
 0002:000042f8       $unwind$NtAcceptConnectPort 000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtAdjustGroupsToken 000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtAdjustPrivilegesToken 000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtAllocateVirtualMemory 000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtAlpcCreatePortSection 000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtAlpcOpenSenderProcess 000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtAlpcOpenSenderThread 000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtAlpcQueryInformationMessage 000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtCreateKey        000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtCreateResourceManager 000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtCreateSection    000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtCreateTransactionManager 000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtDuplicateObject  000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtDuplicateToken   000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtEnumerateKey     000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtEnumerateValueKey 000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtFilterToken      000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtGetNextThread    000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtGetNotificationResourceManager 000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtGetWriteWatch    000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtMapCMFModule     000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtOpenFile         000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtOpenTransactionManager 000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtPrivilegeObjectAuditAlarm 000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtQueryDirectoryObject 000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtQueryMultipleValueKey 000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtQuerySecurityAttributesToken 000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtQuerySystemInformationEx 000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtQueryValueKey    000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtQueryVirtualMemory 000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtQueueApcThreadEx 000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtRaiseHardError   000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtReadRequestData  000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtRemoveIoCompletionEx 000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtSetIoCompletionEx 000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtSetLdtEntries    000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtSetTimer         000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtSetValueKey      000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtSystemDebugControl 000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtTraceControl     000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:000042f8       $unwind$NtWriteRequestData 000000014000e2f8     HIGU_ntcall:ntdll_functions.obj
 0002:00004300       $unwind$NtAccessCheck      000000014000e300     HIGU_ntcall:ntdll_functions.obj
 0002:00004300       $unwind$NtAlpcAcceptConnectPort 000000014000e300     HIGU_ntcall:ntdll_functions.obj
 0002:00004300       $unwind$NtAlpcSendWaitReceivePort 000000014000e300     HIGU_ntcall:ntdll_functions.obj
 0002:00004300       $unwind$NtConnectPort      000000014000e300     HIGU_ntcall:ntdll_functions.obj
 0002:00004300       $unwind$NtCreateEnclave    000000014000e300     HIGU_ntcall:ntdll_functions.obj
 0002:00004300       $unwind$NtCreateEnlistment 000000014000e300     HIGU_ntcall:ntdll_functions.obj
 0002:00004300       $unwind$NtCreateKeyTransacted 000000014000e300     HIGU_ntcall:ntdll_functions.obj
 0002:00004300       $unwind$NtCreateMailslotFile 000000014000e300     HIGU_ntcall:ntdll_functions.obj
 0002:00004300       $unwind$NtCreateProcess    000000014000e300     HIGU_ntcall:ntdll_functions.obj
 0002:00004300       $unwind$NtCreateProcessEx  000000014000e300     HIGU_ntcall:ntdll_functions.obj
 0002:00004300       $unwind$NtCreateProfile    000000014000e300     HIGU_ntcall:ntdll_functions.obj
 0002:00004300       $unwind$NtCreateThread     000000014000e300     HIGU_ntcall:ntdll_functions.obj
 0002:00004300       $unwind$NtLoadEnclaveData  000000014000e300     HIGU_ntcall:ntdll_functions.obj
 0002:00004300       $unwind$NtLoadKeyEx        000000014000e300     HIGU_ntcall:ntdll_functions.obj
 0002:00004300       $unwind$NtNotifyChangeDirectoryFile 000000014000e300     HIGU_ntcall:ntdll_functions.obj
 0002:00004300       $unwind$NtNotifyChangeSession 000000014000e300     HIGU_ntcall:ntdll_functions.obj
 0002:00004300       $unwind$NtQueryEaFile      000000014000e300     HIGU_ntcall:ntdll_functions.obj
 0002:00004300       $unwind$NtQueryQuotaInformationFile 000000014000e300     HIGU_ntcall:ntdll_functions.obj
 0002:00004300       $unwind$NtReadFile         000000014000e300     HIGU_ntcall:ntdll_functions.obj
 0002:00004300       $unwind$NtReadFileScatter  000000014000e300     HIGU_ntcall:ntdll_functions.obj
 0002:00004300       $unwind$NtSecureConnectPort 000000014000e300     HIGU_ntcall:ntdll_functions.obj
 0002:00004300       $unwind$NtWriteFile        000000014000e300     HIGU_ntcall:ntdll_functions.obj
 0002:00004300       $unwind$NtWriteFileGather  000000014000e300     HIGU_ntcall:ntdll_functions.obj
 0002:00004308       $unwind$NtAccessCheckAndAuditAlarm 000000014000e308     HIGU_ntcall:ntdll_functions.obj
 0002:00004308       $unwind$NtAccessCheckByType 000000014000e308     HIGU_ntcall:ntdll_functions.obj
 0002:00004308       $unwind$NtAccessCheckByTypeResultList 000000014000e308     HIGU_ntcall:ntdll_functions.obj
 0002:00004308       $unwind$NtAlpcConnectPort  000000014000e308     HIGU_ntcall:ntdll_functions.obj
 0002:00004308       $unwind$NtCreateFile       000000014000e308     HIGU_ntcall:ntdll_functions.obj
 0002:00004308       $unwind$NtCreateProfileEx  000000014000e308     HIGU_ntcall:ntdll_functions.obj
 0002:00004308       $unwind$NtCreateThreadEx   000000014000e308     HIGU_ntcall:ntdll_functions.obj
 0002:00004308       $unwind$NtCreateTransaction 000000014000e308     HIGU_ntcall:ntdll_functions.obj
 0002:00004308       $unwind$NtCreateUserProcess 000000014000e308     HIGU_ntcall:ntdll_functions.obj
 0002:00004308       $unwind$NtCreateWorkerFactory 000000014000e308     HIGU_ntcall:ntdll_functions.obj
 0002:00004308       $unwind$NtDeviceIoControlFile 000000014000e308     HIGU_ntcall:ntdll_functions.obj
 0002:00004308       $unwind$NtFsControlFile    000000014000e308     HIGU_ntcall:ntdll_functions.obj
 0002:00004308       $unwind$NtLockFile         000000014000e308     HIGU_ntcall:ntdll_functions.obj
 0002:00004308       $unwind$NtMapViewOfSection 000000014000e308     HIGU_ntcall:ntdll_functions.obj
 0002:00004308       $unwind$NtNotifyChangeKey  000000014000e308     HIGU_ntcall:ntdll_functions.obj
 0002:00004308       $unwind$NtQueryDirectoryFile 000000014000e308     HIGU_ntcall:ntdll_functions.obj
 0002:00004310       $unwind$NtAccessCheckByTypeAndAuditAlarm 000000014000e310     HIGU_ntcall:ntdll_functions.obj
 0002:00004310       $unwind$NtAccessCheckByTypeResultListAndAuditAlarm 000000014000e310     HIGU_ntcall:ntdll_functions.obj
 0002:00004310       $unwind$NtAccessCheckByTypeResultListAndAuditAlarmByHandle 000000014000e310     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtAddAtom          000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtAddBootEntry     000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtAddDriverEntry   000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtAlertResumeThread 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtAllocateReserveObject 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtAllocateUserPhysicalPages 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtAlpcCancelMessage 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtAlpcCreatePort   000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtAlpcCreateSectionView 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtAlpcCreateSecurityContext 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtAlpcDeletePortSection 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtAlpcDeleteResourceReserve 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtAlpcDeleteSectionView 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtAlpcDeleteSecurityContext 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtAlpcDisconnectPort 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtAlpcImpersonateClientOfPort 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtAlpcRevokeSecurityContext 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtAreMappedFilesTheSame 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtAssignProcessToJobObject 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtCallbackReturn   000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtCancelIoFile     000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtCancelIoFileEx   000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtCancelSynchronousIoFile 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtCancelTimer      000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtCloseObjectAuditAlarm 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtCommitComplete   000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtCommitEnlistment 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtCommitTransaction 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtCompactKeys      000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtCompareTokens    000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtContinue         000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtCreateDirectoryObject 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtCreateEventPair  000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtCreateJobObject  000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtCreateJobSet     000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtDebugActiveProcess 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtDebugContinue    000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtDelayExecution   000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtDeleteObjectAuditAlarm 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtDeleteValueKey   000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtEnumerateBootEntries 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtEnumerateDriverEntries 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtEnumerateSystemEnvironmentValuesEx 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtExtendSection    000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtFindAtom         000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtFlushBuffersFile 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtFlushInstallUILanguage 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtFlushInstructionCache 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtFreeUserPhysicalPages 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtFreezeTransactions 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtGetContextThread 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtGetDevicePowerState 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtGetMUIRegistryInfo 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtImpersonateClientOfPort 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtImpersonateThread 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtInitializeNlsFiles 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtIsProcessInJob   000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtListenPort       000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtLoadKey          000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtLoadKey2         000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtLockProductActivationKeys 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtMapUserPhysicalPages 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtMapUserPhysicalPagesScatter 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtOpenDirectoryObject 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtOpenEvent        000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtOpenEventPair    000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtOpenIoCompletion 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtOpenJobObject    000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtOpenKey          000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtOpenKeyedEvent   000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtOpenMutant       000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtOpenProcessToken 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtOpenSection      000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtOpenSemaphore    000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtOpenSession      000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtOpenSymbolicLinkObject 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtOpenTimer        000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtPlugPlayControl  000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtPrePrepareComplete 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtPrePrepareEnlistment 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtPrepareComplete  000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtPrepareEnlistment 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtPrivilegeCheck   000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtPropagationFailed 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtPulseEvent       000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtQueryAttributesFile 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtQueryBootEntryOrder 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtQueryBootOptions 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtQueryDebugFilterState 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtQueryDefaultLocale 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtQueryDriverEntryOrder 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtQueryFullAttributesFile 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtQueryIntervalProfile 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtQueryOpenSubKeys 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtQueryPerformanceCounter 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtQuerySymbolicLinkObject 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtQueryTimerResolution 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtRaiseException   000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtReadOnlyEnlistment 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtRecoverEnlistment 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtReleaseMutant    000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtReleaseSemaphore 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtRemoveProcessDebug 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtRenameKey        000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtRenameTransactionManager 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtReplaceKey       000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtReplacePartitionUnit 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtReplyPort        000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtReplyWaitReplyPort 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtRequestPort      000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtRequestWaitReplyPort 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtResetEvent       000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtResetWriteWatch  000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtRestoreKey       000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtResumeThread     000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtRollbackComplete 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtRollbackEnlistment 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtRollbackTransaction 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtRollforwardTransactionManager 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtSaveKey          000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtSaveKeyEx        000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtSaveMergedKeys   000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtSetBootEntryOrder 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtSetBootOptions   000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtSetContextThread 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtSetDebugFilterState 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtSetDefaultLocale 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtSetDriverEntryOrder 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtSetEvent         000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtSetIntervalProfile 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtSetSecurityObject 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtSetSystemEnvironmentValue 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtSetSystemInformation 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtSetSystemPowerState 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtSetSystemTime    000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtSetThreadExecutionState 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtSetTimerResolution 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtShutdownWorkerFactory 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtSinglePhaseReject 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtSuspendThread    000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtTerminateEnclave 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtTerminateJobObject 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtTerminateProcess 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtTerminateThread  000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtUnloadKey2       000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtUnloadKeyEx      000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtUnmapViewOfSection 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtVdmControl       000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtWaitForSingleObject 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004318       $unwind$NtWaitForWorkViaWorkerFactory 000000014000e318     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtAllocateUuids    000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtAlpcCreateResourceReserve 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtAlpcQueryInformation 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtAlpcSetInformation 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtCallEnclave      000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtCreateDebugObject 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtCreateEvent      000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtCreateIoCompletion 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtCreateKeyedEvent 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtCreateMutant     000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtCreatePagingFile 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtCreatePort       000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtCreatePrivateNamespace 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtCreateSemaphore  000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtCreateSymbolicLinkObject 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtCreateTimer      000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtCreateWaitablePort 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtEnumerateTransactionObject 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtFreeVirtualMemory 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtGetNextProcess   000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtGetNlsSectionPtr 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtInitializeEnclave 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtInitiatePowerAction 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtLockVirtualMemory 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtOpenEnlistment   000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtOpenKeyEx        000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtOpenKeyTransacted 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtOpenKeyTransactedEx 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtOpenPrivateNamespace 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtOpenProcess      000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtOpenProcessTokenEx 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtOpenResourceManager 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtOpenThread       000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtOpenThreadToken  000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtOpenThreadTokenEx 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtOpenTransaction  000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtPowerInformation 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtPrivilegedServiceAuditAlarm 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtPropagationComplete 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtProtectVirtualMemory 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtQueryEvent       000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtQueryInformationAtom 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtQueryInformationEnlistment 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtQueryInformationFile 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtQueryInformationJobObject 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtQueryInformationPort 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtQueryInformationProcess 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtQueryInformationResourceManager 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtQueryInformationThread 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtQueryInformationToken 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtQueryInformationTransaction 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtQueryInformationTransactionManager 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtQueryInformationWorkerFactory 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtQueryIoCompletion 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtQueryKey         000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtQueryLicenseValue 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtQueryMutant      000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtQueryObject      000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtQueryOpenSubKeysEx 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtQuerySection     000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtQuerySecurityObject 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtQuerySemaphore   000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtQuerySystemEnvironmentValue 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtQuerySystemEnvironmentValueEx 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtQuerySystemInformation 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtQueryTimer       000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtQueryVolumeInformationFile 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtQueueApcThread   000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtReadVirtualMemory 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtRegisterProtocolAddressInformation 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtReleaseKeyedEvent 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtRemoveIoCompletion 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtReplyWaitReceivePort 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtReplyWaitReceivePortEx 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtSetEaFile        000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtSetInformationDebugObject 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtSetInformationEnlistment 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtSetInformationFile 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtSetInformationJobObject 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtSetInformationKey 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtSetInformationObject 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtSetInformationProcess 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtSetInformationResourceManager 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtSetInformationThread 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtSetInformationToken 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtSetInformationTransaction 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtSetInformationTransactionManager 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtSetInformationWorkerFactory 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtSetIoCompletion  000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtSetQuotaInformationFile 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtSetSystemEnvironmentValueEx 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtSetTimerEx       000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtSetVolumeInformationFile 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtSignalAndWaitForSingleObject 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtTraceEvent       000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtTranslateFilePath 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtUnlockFile       000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtUnlockVirtualMemory 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtWaitForDebugEvent 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtWaitForKeyedEvent 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtWaitForMultipleObjects 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtWaitForMultipleObjects32 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004320       $unwind$NtWriteVirtualMemory 000000014000e320     HIGU_ntcall:ntdll_functions.obj
 0002:00004328       $unwind$NtCreateNamedPipeFile 000000014000e328     HIGU_ntcall:ntdll_functions.obj
 0002:00004330       $unwind$NtCreateToken      000000014000e330     HIGU_ntcall:ntdll_functions.obj
 0002:00004330       $unwind$NtNotifyChangeMultipleKeys 000000014000e330     HIGU_ntcall:ntdll_functions.obj
 0002:00004330       $unwind$NtOpenObjectAuditAlarm 000000014000e330     HIGU_ntcall:ntdll_functions.obj
 0002:00004338       $unwind$?call@cleancall@@YA_JIIIZZ 000000014000e338     HIGU_ntcall:cleancall.obj
 0002:00004348       $xdatasym                  000000014000e348     MSVCRT:amdsecgs.obj
 0002:0000434c       $unwind$?pre_c_initialization@@YAHXZ 000000014000e34c     MSVCRT:exe_main.obj
 0002:0000434c       $unwind$__raise_securityfailure 000000014000e34c     MSVCRT:gs_report.obj
 0002:0000434c       $unwind$__scrt_initialize_crt 000000014000e34c     MSVCRT:utility.obj
 0002:0000434c       $unwind$__scrt_initialize_onexit_tables 000000014000e34c     MSVCRT:utility.obj
 0002:0000434c       $unwind$__scrt_release_startup_lock 000000014000e34c     MSVCRT:utility.obj
 0002:0000434c       $unwind$__scrt_uninitialize_crt 000000014000e34c     MSVCRT:utility.obj
 0002:0000434c       $unwind$_onexit            000000014000e34c     MSVCRT:utility.obj
 0002:00004354       $unwind$__scrt_initialize_default_local_stdio_options 000000014000e354     MSVCRT:default_local_stdio_options.obj
 0002:00004354       $unwind$?post_pgo_initialization@@YAHXZ 000000014000e354     MSVCRT:exe_main.obj
 0002:00004354       $unwind$?pre_cpp_initialization@@YAXXZ 000000014000e354     MSVCRT:exe_main.obj
 0002:00004354       $unwind$mainCRTStartup     000000014000e354     MSVCRT:exe_main.obj
 0002:00004354       $unwind$__GSHandlerCheck   000000014000e354     MSVCRT:gshandler.obj
 0002:00004354       $unwind$__scrt_acquire_startup_lock 000000014000e354     MSVCRT:utility.obj
 0002:00004354       $unwind$atexit             000000014000e354     MSVCRT:utility.obj
 0002:00004354       $unwind$__scrt_is_managed_app 000000014000e354     MSVCRT:utility_desktop.obj
 0002:0000435c       $unwind$?__scrt_common_main_seh@@YAHXZ 000000014000e35c     MSVCRT:exe_main.obj
 0002:00004394       $unwind$?filt$0@?0??__scrt_common_main_seh@@YAHXZ@4HA 000000014000e394     MSVCRT:exe_main.obj
 0002:0000439c       $unwind$__report_gsfailure 000000014000e39c     MSVCRT:gs_report.obj
 0002:000043a4       $unwind$capture_previous_context 000000014000e3a4     MSVCRT:gs_report.obj
 0002:000043b0       $unwind$__scrt_is_nonwritable_in_current_image 000000014000e3b0     MSVCRT:utility.obj
 0002:000043d0       $unwind$__scrt_is_nonwritable_in_current_image$filt$0 000000014000e3d0     MSVCRT:utility.obj
 0002:000043d8       $unwind$__security_init_cookie 000000014000e3d8     MSVCRT:gs_support.obj
 0002:000043e4       $unwind$__scrt_fastfail    000000014000e3e4     MSVCRT:utility_desktop.obj
 0002:000043f4       $unwind$_RTC_Initialize    000000014000e3f4     MSVCRT:initsect.obj
 0002:000043f4       $unwind$_RTC_Terminate     000000014000e3f4     MSVCRT:initsect.obj
 0002:000043f4       $unwind$__scrt_unhandled_exception_filter 000000014000e3f4     MSVCRT:utility_desktop.obj
 0002:00004400       $unwind$__isa_available_init 000000014000e400     MSVCRT:cpu_disp.obj
 0002:00004410       $xdatasym                  000000014000e410     MSVCRT:guard_dispatch.obj
 0002:00004418       $xdatasym                  000000014000e418     MSVCRT:guard_xfg_dispatch.obj
 0002:0000441c       $unwind$__GSHandlerCheckCommon 000000014000e41c     MSVCRT:gshandler.obj
 0002:00004430       .edata                     000000014000e430     test_app.exp
 0002:00004458       rgpv                       000000014000e458     test_app.exp
 0002:00004aa0       rgszName                   000000014000eaa0     test_app.exp
 0002:000050e8       rgwOrd                     000000014000f0e8     test_app.exp
 0002:0000540c       szName                     000000014000f40c     test_app.exp
 0002:00005419       $N00001                    000000014000f419     test_app.exp
 0002:0000542d       $N00002                    000000014000f42d     test_app.exp
 0002:0000543b       $N00003                    000000014000f43b     test_app.exp
 0002:00005456       $N00004                    000000014000f456     test_app.exp
 0002:0000546a       $N00005                    000000014000f46a     test_app.exp
 0002:0000548b       $N00006                    000000014000f48b     test_app.exp
 0002:000054a9       $N00007                    000000014000f4a9     test_app.exp
 0002:000054d4       $N00008                    000000014000f4d4     test_app.exp
 0002:00005507       $N00009                    000000014000f507     test_app.exp
 0002:00005511       $N00010                    000000014000f511     test_app.exp
 0002:00005520       $N00011                    000000014000f520     test_app.exp
 0002:00005531       $N00012                    000000014000f531     test_app.exp
 0002:00005545       $N00013                    000000014000f545     test_app.exp
 0002:0000555d       $N00014                    000000014000f55d     test_app.exp
 0002:00005571       $N00015                    000000014000f571     test_app.exp
 0002:0000557f       $N00016                    000000014000f57f     test_app.exp
 0002:00005599       $N00017                    000000014000f599     test_app.exp
 0002:000055b1       $N00018                    000000014000f5b1     test_app.exp
 0002:000055cd       $N00019                    000000014000f5cd     test_app.exp
 0002:000055dd       $N00020                    000000014000f5dd     test_app.exp
 0002:000055f5       $N00021                    000000014000f5f5     test_app.exp
 0002:0000560d       $N00022                    000000014000f60d     test_app.exp
 0002:00005621       $N00023                    000000014000f621     test_app.exp
 0002:00005633       $N00024                    000000014000f633     test_app.exp
 0002:00005644       $N00025                    000000014000f644     test_app.exp
 0002:0000565c       $N00026                    000000014000f65c     test_app.exp
 0002:00005678       $N00027                    000000014000f678     test_app.exp
 0002:00005690       $N00028                    000000014000f690     test_app.exp
 0002:000056ac       $N00029                    000000014000f6ac     test_app.exp
 0002:000056c4       $N00030                    000000014000f6c4     test_app.exp
 0002:000056e0       $N00031                    000000014000f6e0     test_app.exp
 0002:000056f8       $N00032                    000000014000f6f8     test_app.exp
 0002:00005714       $N00033                    000000014000f714     test_app.exp
 0002:00005729       $N00034                    000000014000f729     test_app.exp
 0002:00005747       $N00035                    000000014000f747     test_app.exp
 0002:0000575f       $N00036                    000000014000f75f     test_app.exp
 0002:00005776       $N00037                    000000014000f776     test_app.exp
 0002:0000578d       $N00038                    000000014000f78d     test_app.exp
 0002:000057ab       $N00039                    000000014000f7ab     test_app.exp
 0002:000057c7       $N00040                    000000014000f7c7     test_app.exp
 0002:000057e1       $N00041                    000000014000f7e1     test_app.exp
 0002:000057f6       $N00042                    000000014000f7f6     test_app.exp
 0002:0000580e       $N00043                    000000014000f80e     test_app.exp
 0002:00005829       $N00044                    000000014000f829     test_app.exp
 0002:00005837       $N00045                    000000014000f837     test_app.exp
 0002:00005848       $N00046                    000000014000f848     test_app.exp
 0002:00005857       $N00047                    000000014000f857     test_app.exp
 0002:00005868       $N00048                    000000014000f868     test_app.exp
 0002:00005882       $N00049                    000000014000f882     test_app.exp
 0002:00005890       $N00050                    000000014000f890     test_app.exp
 0002:0000589d       $N00051                    000000014000f89d     test_app.exp
 0002:000058a5       $N00052                    000000014000f8a5     test_app.exp
 0002:000058bd       $N00053                    000000014000f8bd     test_app.exp
 0002:000058ce       $N00054                    000000014000f8ce     test_app.exp
 0002:000058e1       $N00055                    000000014000f8e1     test_app.exp
 0002:000058f5       $N00056                    000000014000f8f5     test_app.exp
 0002:00005903       $N00057                    000000014000f903     test_app.exp
 0002:00005913       $N00058                    000000014000f913     test_app.exp
 0002:00005929       $N00059                    000000014000f929     test_app.exp
 0002:00005937       $N00060                    000000014000f937     test_app.exp
 0002:00005945       $N00061                    000000014000f945     test_app.exp
 0002:00005950       $N00062                    000000014000f950     test_app.exp
 0002:00005964       $N00063                    000000014000f964     test_app.exp
 0002:0000597c       $N00064                    000000014000f97c     test_app.exp
 0002:0000598c       $N00065                    000000014000f98c     test_app.exp
 0002:0000599f       $N00066                    000000014000f99f     test_app.exp
 0002:000059ad       $N00067                    000000014000f9ad     test_app.exp
 0002:000059bf       $N00068                    000000014000f9bf     test_app.exp
 0002:000059cc       $N00069                    000000014000f9cc     test_app.exp
 0002:000059e1       $N00070                    000000014000f9e1     test_app.exp
 0002:000059f3       $N00071                    000000014000f9f3     test_app.exp
 0002:00005a02       $N00072                    000000014000fa02     test_app.exp
 0002:00005a0e       $N00073                    000000014000fa0e     test_app.exp
 0002:00005a24       $N00074                    000000014000fa24     test_app.exp
 0002:00005a37       $N00075                    000000014000fa37     test_app.exp
 0002:00005a4c       $N00076                    000000014000fa4c     test_app.exp
 0002:00005a5b       $N00077                    000000014000fa5b     test_app.exp
 0002:00005a71       $N00078                    000000014000fa71     test_app.exp
 0002:00005a84       $N00079                    000000014000fa84     test_app.exp
 0002:00005a91       $N00080                    000000014000fa91     test_app.exp
 0002:00005aaa       $N00081                    000000014000faaa     test_app.exp
 0002:00005aba       $N00082                    000000014000faba     test_app.exp
 0002:00005acc       $N00083                    000000014000facc     test_app.exp
 0002:00005adc       $N00084                    000000014000fadc     test_app.exp
 0002:00005aee       $N00085                    000000014000faee     test_app.exp
 0002:00005b06       $N00086                    000000014000fb06     test_app.exp
 0002:00005b16       $N00087                    000000014000fb16     test_app.exp
 0002:00005b28       $N00088                    000000014000fb28     test_app.exp
 0002:00005b43       $N00089                    000000014000fb43     test_app.exp
 0002:00005b52       $N00090                    000000014000fb52     test_app.exp
 0002:00005b63       $N00091                    000000014000fb63     test_app.exp
 0002:00005b71       $N00092                    000000014000fb71     test_app.exp
 0002:00005b7f       $N00093                    000000014000fb7f     test_app.exp
 0002:00005b93       $N00094                    000000014000fb93     test_app.exp
 0002:00005bae       $N00095                    000000014000fbae     test_app.exp
 0002:00005bc2       $N00096                    000000014000fbc2     test_app.exp
 0002:00005bd7       $N00097                    000000014000fbd7     test_app.exp
 0002:00005bed       $N00098                    000000014000fbed     test_app.exp
 0002:00005c02       $N00099                    000000014000fc02     test_app.exp
 0002:00005c12       $N00100                    000000014000fc12     test_app.exp
 0002:00005c23       $N00101                    000000014000fc23     test_app.exp
 0002:00005c30       $N00102                    000000014000fc30     test_app.exp
 0002:00005c42       $N00103                    000000014000fc42     test_app.exp
 0002:00005c56       $N00104                    000000014000fc56     test_app.exp
 0002:00005c63       $N00105                    000000014000fc63     test_app.exp
 0002:00005c6f       $N00106                    000000014000fc6f     test_app.exp
 0002:00005c88       $N00107                    000000014000fc88     test_app.exp
 0002:00005ca1       $N00108                    000000014000fca1     test_app.exp
 0002:00005cb2       $N00109                    000000014000fcb2     test_app.exp
 0002:00005cc8       $N00110                    000000014000fcc8     test_app.exp
 0002:00005cdf       $N00111                    000000014000fcdf     test_app.exp
 0002:00005cef       $N00112                    000000014000fcef     test_app.exp
 0002:00005cfa       $N00113                    000000014000fcfa     test_app.exp
 0002:00005d0c       $N00114                    000000014000fd0c     test_app.exp
 0002:00005d1d       $N00115                    000000014000fd1d     test_app.exp
 0002:00005d33       $N00116                    000000014000fd33     test_app.exp
 0002:00005d4a       $N00117                    000000014000fd4a     test_app.exp
 0002:00005d63       $N00118                    000000014000fd63     test_app.exp
 0002:00005d72       $N00119                    000000014000fd72     test_app.exp
 0002:00005d97       $N00120                    000000014000fd97     test_app.exp
 0002:00005db4       $N00121                    000000014000fdb4     test_app.exp
 0002:00005dc8       $N00122                    000000014000fdc8     test_app.exp
 0002:00005dd8       $N00123                    000000014000fdd8     test_app.exp
 0002:00005de6       $N00124                    000000014000fde6     test_app.exp
 0002:00005df1       $N00125                    000000014000fdf1     test_app.exp
 0002:00005e04       $N00126                    000000014000fe04     test_app.exp
 0002:00005e1d       $N00127                    000000014000fe1d     test_app.exp
 0002:00005e35       $N00128                    000000014000fe35     test_app.exp
 0002:00005e40       $N00129                    000000014000fe40     test_app.exp
 0002:00005e5b       $N00130                    000000014000fe5b     test_app.exp
 0002:00005e6e       $N00131                    000000014000fe6e     test_app.exp
 0002:00005e86       $N00132                    000000014000fe86     test_app.exp
 0002:00005e9a       $N00133                    000000014000fe9a     test_app.exp
 0002:00005eab       $N00134                    000000014000feab     test_app.exp
 0002:00005ec0       $N00135                    000000014000fec0     test_app.exp
 0002:00005ed0       $N00136                    000000014000fed0     test_app.exp
 0002:00005ee3       $N00137                    000000014000fee3     test_app.exp
 0002:00005eff       $N00138                    000000014000feff     test_app.exp
 0002:00005f15       $N00139                    000000014000ff15     test_app.exp
 0002:00005f2a       $N00140                    000000014000ff2a     test_app.exp
 0002:00005f3b       $N00141                    000000014000ff3b     test_app.exp
 0002:00005f4b       $N00142                    000000014000ff4b     test_app.exp
 0002:00005f5e       $N00143                    000000014000ff5e     test_app.exp
 0002:00005f7f       $N00144                    000000014000ff7f     test_app.exp
 0002:00005f8f       $N00145                    000000014000ff8f     test_app.exp
 0002:00005fab       $N00146                    000000014000ffab     test_app.exp
 0002:00005fc5       $N00147                    000000014000ffc5     test_app.exp
 0002:00005fd9       $N00148                    000000014000ffd9     test_app.exp
 0002:00005fed       $N00149                    000000014000ffed     test_app.exp
 0002:00006002       $N00150                    0000000140010002     test_app.exp
 0002:00006017       $N00151                    0000000140010017     test_app.exp
 0002:0000602d       $N00152                    000000014001002d     test_app.exp
 0002:0000603e       $N00153                    000000014001003e     test_app.exp
 0002:00006058       $N00154                    0000000140010058     test_app.exp
 0002:0000606f       $N00155                    000000014001006f     test_app.exp
 0002:0000607c       $N00156                    000000014001007c     test_app.exp
 0002:00006089       $N00157                    0000000140010089     test_app.exp
 0002:0000609b       $N00158                    000000014001009b     test_app.exp
 0002:000060a5       $N00159                    00000001400100a5     test_app.exp
 0002:000060b0       $N00160                    00000001400100b0     test_app.exp
 0002:000060bc       $N00161                    00000001400100bc     test_app.exp
 0002:000060c7       $N00162                    00000001400100c7     test_app.exp
 0002:000060e3       $N00163                    00000001400100e3     test_app.exp
 0002:000060f5       $N00164                    00000001400100f5     test_app.exp
 0002:00006109       $N00165                    0000000140010109     test_app.exp
 0002:0000611f       $N00166                    000000014001011f     test_app.exp
 0002:00006135       $N00167                    0000000140010135     test_app.exp
 0002:00006144       $N00168                    0000000140010144     test_app.exp
 0002:0000615b       $N00169                    000000014001015b     test_app.exp
 0002:00006179       $N00170                    0000000140010179     test_app.exp
 0002:0000618c       $N00171                    000000014001018c     test_app.exp
 0002:0000619e       $N00172                    000000014001019e     test_app.exp
 0002:000061b2       $N00173                    00000001400101b2     test_app.exp
 0002:000061ce       $N00174                    00000001400101ce     test_app.exp
 0002:000061e0       $N00175                    00000001400101e0     test_app.exp
 0002:000061fb       $N00176                    00000001400101fb     test_app.exp
 0002:00006211       $N00177                    0000000140010211     test_app.exp
 0002:00006227       $N00178                    0000000140010227     test_app.exp
 0002:00006238       $N00179                    0000000140010238     test_app.exp
 0002:00006244       $N00180                    0000000140010244     test_app.exp
 0002:00006254       $N00181                    0000000140010254     test_app.exp
 0002:0000625f       $N00182                    000000014001025f     test_app.exp
 0002:00006272       $N00183                    0000000140010272     test_app.exp
 0002:00006282       $N00184                    0000000140010282     test_app.exp
 0002:0000628c       $N00185                    000000014001028c     test_app.exp
 0002:00006298       $N00186                    0000000140010298     test_app.exp
 0002:000062ac       $N00187                    00000001400102ac     test_app.exp
 0002:000062c2       $N00188                    00000001400102c2     test_app.exp
 0002:000062d3       $N00189                    00000001400102d3     test_app.exp
 0002:000062e0       $N00190                    00000001400102e0     test_app.exp
 0002:000062f7       $N00191                    00000001400102f7     test_app.exp
 0002:0000630e       $N00192                    000000014001030e     test_app.exp
 0002:0000631c       $N00193                    000000014001031c     test_app.exp
 0002:0000632f       $N00194                    000000014001032f     test_app.exp
 0002:00006344       $N00195                    0000000140010344     test_app.exp
 0002:0000635a       $N00196                    000000014001035a     test_app.exp
 0002:00006368       $N00197                    0000000140010368     test_app.exp
 0002:00006378       $N00198                    0000000140010378     test_app.exp
 0002:00006386       $N00199                    0000000140010386     test_app.exp
 0002:0000639f       $N00200                    000000014001039f     test_app.exp
 0002:000063ac       $N00201                    00000001400103ac     test_app.exp
 0002:000063be       $N00202                    00000001400103be     test_app.exp
 0002:000063d2       $N00203                    00000001400103d2     test_app.exp
 0002:000063de       $N00204                    00000001400103de     test_app.exp
 0002:000063f0       $N00205                    00000001400103f0     test_app.exp
 0002:00006409       $N00206                    0000000140010409     test_app.exp
 0002:0000641b       $N00207                    000000014001041b     test_app.exp
 0002:0000642e       $N00208                    000000014001042e     test_app.exp
 0002:00006443       $N00209                    0000000140010443     test_app.exp
 0002:0000645a       $N00210                    000000014001045a     test_app.exp
 0002:0000646c       $N00211                    000000014001046c     test_app.exp
 0002:00006480       $N00212                    0000000140010480     test_app.exp
 0002:00006491       $N00213                    0000000140010491     test_app.exp
 0002:000064ad       $N00214                    00000001400104ad     test_app.exp
 0002:000064cb       $N00215                    00000001400104cb     test_app.exp
 0002:000064e1       $N00216                    00000001400104e1     test_app.exp
 0002:000064f5       $N00217                    00000001400104f5     test_app.exp
 0002:0000650c       $N00218                    000000014001050c     test_app.exp
 0002:00006519       $N00219                    0000000140010519     test_app.exp
 0002:0000652f       $N00220                    000000014001052f     test_app.exp
 0002:00006545       $N00221                    0000000140010545     test_app.exp
 0002:00006558       $N00222                    0000000140010558     test_app.exp
 0002:00006570       $N00223                    0000000140010570     test_app.exp
 0002:00006585       $N00224                    0000000140010585     test_app.exp
 0002:0000659e       $N00225                    000000014001059e     test_app.exp
 0002:000065b3       $N00226                    00000001400105b3     test_app.exp
 0002:000065ca       $N00227                    00000001400105ca     test_app.exp
 0002:000065e2       $N00228                    00000001400105e2     test_app.exp
 0002:000065f0       $N00229                    00000001400105f0     test_app.exp
 0002:000065fd       $N00230                    00000001400105fd     test_app.exp
 0002:00006617       $N00231                    0000000140010617     test_app.exp
 0002:0000662e       $N00232                    000000014001062e     test_app.exp
 0002:0000664b       $N00233                    000000014001064b     test_app.exp
 0002:00006662       $N00234                    0000000140010662     test_app.exp
 0002:0000667e       $N00235                    000000014001067e     test_app.exp
 0002:00006695       $N00236                    0000000140010695     test_app.exp
 0002:000066af       $N00237                    00000001400106af     test_app.exp
 0002:000066d1       $N00238                    00000001400106d1     test_app.exp
 0002:000066ea       $N00239                    00000001400106ea     test_app.exp
 0002:00006702       $N00240                    0000000140010702     test_app.exp
 0002:00006720       $N00241                    0000000140010720     test_app.exp
 0002:00006745       $N00242                    0000000140010745     test_app.exp
 0002:00006765       $N00243                    0000000140010765     test_app.exp
 0002:0000677e       $N00244                    000000014001077e     test_app.exp
 0002:00006795       $N00245                    0000000140010795     test_app.exp
 0002:000067a9       $N00246                    00000001400107a9     test_app.exp
 0002:000067b4       $N00247                    00000001400107b4     test_app.exp
 0002:000067c8       $N00248                    00000001400107c8     test_app.exp
 0002:000067e0       $N00249                    00000001400107e0     test_app.exp
 0002:000067ee       $N00250                    00000001400107ee     test_app.exp
 0002:000067fc       $N00251                    00000001400107fc     test_app.exp
 0002:0000680f       $N00252                    000000014001080f     test_app.exp
 0002:00006824       $N00253                    0000000140010824     test_app.exp
 0002:0000683e       $N00254                    000000014001083e     test_app.exp
 0002:0000685c       $N00255                    000000014001085c     test_app.exp
 0002:00006878       $N00256                    0000000140010878     test_app.exp
 0002:00006887       $N00257                    0000000140010887     test_app.exp
 0002:000068a6       $N00258                    00000001400108a6     test_app.exp
 0002:000068bc       $N00259                    00000001400108bc     test_app.exp
 0002:000068cd       $N00260                    00000001400108cd     test_app.exp
 0002:000068e7       $N00261                    00000001400108e7     test_app.exp
 0002:00006905       $N00262                    0000000140010905     test_app.exp
 0002:00006925       $N00263                    0000000140010925     test_app.exp
 0002:0000693e       $N00264                    000000014001093e     test_app.exp
 0002:00006959       $N00265                    0000000140010959     test_app.exp
 0002:00006966       $N00266                    0000000140010966     test_app.exp
 0002:0000697d       $N00267                    000000014001097d     test_app.exp
 0002:0000698d       $N00268                    000000014001098d     test_app.exp
 0002:000069a2       $N00269                    00000001400109a2     test_app.exp
 0002:000069bf       $N00270                    00000001400109bf     test_app.exp
 0002:000069d0       $N00271                    00000001400109d0     test_app.exp
 0002:000069e3       $N00272                    00000001400109e3     test_app.exp
 0002:000069f4       $N00273                    00000001400109f4     test_app.exp
 0002:00006a05       $N00274                    0000000140010a05     test_app.exp
 0002:00006a10       $N00275                    0000000140010a10     test_app.exp
 0002:00006a22       $N00276                    0000000140010a22     test_app.exp
 0002:00006a37       $N00277                    0000000140010a37     test_app.exp
 0002:00006a49       $N00278                    0000000140010a49     test_app.exp
 0002:00006a5d       $N00279                    0000000140010a5d     test_app.exp
 0002:00006a71       $N00280                    0000000140010a71     test_app.exp
 0002:00006a8a       $N00281                    0000000140010a8a     test_app.exp
 0002:00006aa6       $N00282                    0000000140010aa6     test_app.exp
 0002:00006acb       $N00283                    0000000140010acb     test_app.exp
 0002:00006ae9       $N00284                    0000000140010ae9     test_app.exp
 0002:00006afd       $N00285                    0000000140010afd     test_app.exp
 0002:00006b0d       $N00286                    0000000140010b0d     test_app.exp
 0002:00006b20       $N00287                    0000000140010b20     test_app.exp
 0002:00006b3d       $N00288                    0000000140010b3d     test_app.exp
 0002:00006b52       $N00289                    0000000140010b52     test_app.exp
 0002:00006b69       $N00290                    0000000140010b69     test_app.exp
 0002:00006b7e       $N00291                    0000000140010b7e     test_app.exp
 0002:00006b8a       $N00292                    0000000140010b8a     test_app.exp
 0002:00006ba5       $N00293                    0000000140010ba5     test_app.exp
 0002:00006bb2       $N00294                    0000000140010bb2     test_app.exp
 0002:00006bc9       $N00295                    0000000140010bc9     test_app.exp
 0002:00006bd5       $N00296                    0000000140010bd5     test_app.exp
 0002:00006bec       $N00297                    0000000140010bec     test_app.exp
 0002:00006c05       $N00298                    0000000140010c05     test_app.exp
 0002:00006c1a       $N00299                    0000000140010c1a     test_app.exp
 0002:00006c28       $N00300                    0000000140010c28     test_app.exp
 0002:00006c3f       $N00301                    0000000140010c3f     test_app.exp
 0002:00006c4c       $N00302                    0000000140010c4c     test_app.exp
 0002:00006c5e       $N00303                    0000000140010c5e     test_app.exp
 0002:00006c6b       $N00304                    0000000140010c6b     test_app.exp
 0002:00006c7b       $N00305                    0000000140010c7b     test_app.exp
 0002:00006c8a       $N00306                    0000000140010c8a     test_app.exp
 0002:00006c9d       $N00307                    0000000140010c9d     test_app.exp
 0002:00006cb2       $N00308                    0000000140010cb2     test_app.exp
 0002:00006cc8       $N00309                    0000000140010cc8     test_app.exp
 0002:00006ce8       $N00310                    0000000140010ce8     test_app.exp
 0002:00006cf2       $N00311                    0000000140010cf2     test_app.exp
 0002:00006cfe       $N00312                    0000000140010cfe     test_app.exp
 0002:00006d0f       $N00313                    0000000140010d0f     test_app.exp
 0002:00006d23       $N00314                    0000000140010d23     test_app.exp
 0002:00006d33       $N00315                    0000000140010d33     test_app.exp
 0002:00006d47       $N00316                    0000000140010d47     test_app.exp
 0002:00006d58       $N00317                    0000000140010d58     test_app.exp
 0002:00006d6b       $N00318                    0000000140010d6b     test_app.exp
 0002:00006d81       $N00319                    0000000140010d81     test_app.exp
 0002:00006d9b       $N00320                    0000000140010d9b     test_app.exp
 0002:00006dae       $N00321                    0000000140010dae     test_app.exp
 0002:00006dc5       $N00322                    0000000140010dc5     test_app.exp
 0002:00006ddb       $N00323                    0000000140010ddb     test_app.exp
 0002:00006de7       $N00324                    0000000140010de7     test_app.exp
 0002:00006df2       $N00325                    0000000140010df2     test_app.exp
 0002:00006e0a       $N00326                    0000000140010e0a     test_app.exp
 0002:00006e1d       $N00327                    0000000140010e1d     test_app.exp
 0002:00006e37       $N00328                    0000000140010e37     test_app.exp
 0002:00006e53       $N00329                    0000000140010e53     test_app.exp
 0002:00006e6e       $N00330                    0000000140010e6e     test_app.exp
 0002:00006e83       $N00331                    0000000140010e83     test_app.exp
 0002:00006e9d       $N00332                    0000000140010e9d     test_app.exp
 0002:00006eb1       $N00333                    0000000140010eb1     test_app.exp
 0002:00006ec8       $N00334                    0000000140010ec8     test_app.exp
 0002:00006ee0       $N00335                    0000000140010ee0     test_app.exp
 0002:00006f00       $N00336                    0000000140010f00     test_app.exp
 0002:00006f17       $N00337                    0000000140010f17     test_app.exp
 0002:00006f2d       $N00338                    0000000140010f2d     test_app.exp
 0002:00006f49       $N00339                    0000000140010f49     test_app.exp
 0002:00006f6c       $N00340                    0000000140010f6c     test_app.exp
 0002:00006f8a       $N00341                    0000000140010f8a     test_app.exp
 0002:00006f9f       $N00342                    0000000140010f9f     test_app.exp
 0002:00006fb1       $N00343                    0000000140010fb1     test_app.exp
 0002:00006fc5       $N00344                    0000000140010fc5     test_app.exp
 0002:00006fd5       $N00345                    0000000140010fd5     test_app.exp
 0002:00006fe7       $N00346                    0000000140010fe7     test_app.exp
 0002:00007001       $N00347                    0000000140011001     test_app.exp
 0002:0000701b       $N00348                    000000014001101b     test_app.exp
 0002:0000702f       $N00349                    000000014001102f     test_app.exp
 0002:0000704b       $N00350                    000000014001104b     test_app.exp
 0002:00007069       $N00351                    0000000140011069     test_app.exp
 0002:00007080       $N00352                    0000000140011080     test_app.exp
 0002:00007096       $N00353                    0000000140011096     test_app.exp
 0002:000070a6       $N00354                    00000001400110a6     test_app.exp
 0002:000070c0       $N00355                    00000001400110c0     test_app.exp
 0002:000070cb       $N00356                    00000001400110cb     test_app.exp
 0002:000070d8       $N00357                    00000001400110d8     test_app.exp
 0002:000070ed       $N00358                    00000001400110ed     test_app.exp
 0002:000070fb       $N00359                    00000001400110fb     test_app.exp
 0002:00007109       $N00360                    0000000140011109     test_app.exp
 0002:00007124       $N00361                    0000000140011124     test_app.exp
 0002:00007135       $N00362                    0000000140011135     test_app.exp
 0002:0000714d       $N00363                    000000014001114d     test_app.exp
 0002:0000716c       $N00364                    000000014001116c     test_app.exp
 0002:00007180       $N00365                    0000000140011180     test_app.exp
 0002:0000718f       $N00366                    000000014001118f     test_app.exp
 0002:0000719d       $N00367                    000000014001119d     test_app.exp
 0002:000071ae       $N00368                    00000001400111ae     test_app.exp
 0002:000071be       $N00369                    00000001400111be     test_app.exp
 0002:000071d3       $N00370                    00000001400111d3     test_app.exp
 0002:000071e6       $N00371                    00000001400111e6     test_app.exp
 0002:000071fb       $N00372                    00000001400111fb     test_app.exp
 0002:0000720e       $N00373                    000000014001120e     test_app.exp
 0002:00007220       $N00374                    0000000140011220     test_app.exp
 0002:0000722c       $N00375                    000000014001122c     test_app.exp
 0002:0000723b       $N00376                    000000014001123b     test_app.exp
 0002:0000724e       $N00377                    000000014001124e     test_app.exp
 0002:0000725d       $N00378                    000000014001125d     test_app.exp
 0002:0000726a       $N00379                    000000014001126a     test_app.exp
 0002:0000727e       $N00380                    000000014001127e     test_app.exp
 0002:0000728f       $N00381                    000000014001128f     test_app.exp
 0002:0000729e       $N00382                    000000014001129e     test_app.exp
 0002:000072aa       $N00383                    00000001400112aa     test_app.exp
 0002:000072b7       $N00384                    00000001400112b7     test_app.exp
 0002:000072c5       $N00385                    00000001400112c5     test_app.exp
 0002:000072d2       $N00386                    00000001400112d2     test_app.exp
 0002:000072e8       $N00387                    00000001400112e8     test_app.exp
 0002:000072fd       $N00388                    00000001400112fd     test_app.exp
 0002:0000730a       $N00389                    000000014001130a     test_app.exp
 0002:0000731e       $N00390                    000000014001131e     test_app.exp
 0002:00007332       $N00391                    0000000140011332     test_app.exp
 0002:0000734b       $N00392                    000000014001134b     test_app.exp
 0002:00007366       $N00393                    0000000140011366     test_app.exp
 0002:0000737c       $N00394                    000000014001137c     test_app.exp
 0002:0000739a       $N00395                    000000014001139a     test_app.exp
 0002:000073ae       $N00396                    00000001400113ae     test_app.exp
 0002:000073c1       $N00397                    00000001400113c1     test_app.exp
 0002:000073dc       $N00398                    00000001400113dc     test_app.exp
 0002:000073e8       $N00399                    00000001400113e8     test_app.exp
 0002:000073fa       $N00400                    00000001400113fa     test_app.exp
 0002:0000740d       $N00401                    000000014001140d     test_app.exp
 0002:00007422       $N00402                    0000000140011422     test_app.exp
 0002:0000788a       .idata$6                   000000014001188a     msvcprt:MSVCP140.dll
 0002:00007916       .idata$6                   0000000140011916     vcruntime:VCRUNTIME140_1.dll
 0002:0000792a       .idata$6                   000000014001192a     vcruntime:VCRUNTIME140.dll
 0002:00007aee       .idata$6                   0000000140011aee     ucrt:api-ms-win-crt-runtime-l1-1-0.dll
 0002:00007b10       .idata$6                   0000000140011b10     ucrt:api-ms-win-crt-math-l1-1-0.dll
 0002:00007b30       .idata$6                   0000000140011b30     ucrt:api-ms-win-crt-stdio-l1-1-0.dll
 0002:00007b50       .idata$6                   0000000140011b50     ucrt:api-ms-win-crt-locale-l1-1-0.dll
 0002:00007b72       .idata$6                   0000000140011b72     ucrt:api-ms-win-crt-heap-l1-1-0.dll
 0002:00007cf0       .idata$6                   0000000140011cf0     kernel32:KERNEL32.dll
 0003:00000780       GS_ExceptionRecord         0000000140012780     MSVCRT:gs_report.obj
 0003:00000820       GS_ContextRecord           0000000140012820     MSVCRT:gs_report.obj
 0003:00000d00       ?is_initialized_as_dll@@3_NA 0000000140012d00     MSVCRT:utility.obj
 0003:00000d01       ?module_local_atexit_table_initialized@@3_NA 0000000140012d01     MSVCRT:utility.obj
 0003:00000d08       ?module_local_atexit_table@@3U_onexit_table_t@@A 0000000140012d08     MSVCRT:utility.obj
 0003:00000d20       ?module_local_at_quick_exit_table@@3U_onexit_table_t@@A 0000000140012d20     MSVCRT:utility.obj
 0003:00000d78       ?syscall_table_initialized@@3_NA 0000000140012d78     HIGU_ntcall:syscall_table_initialize.obj
 0003:00000d80       ?used_sys_gate@cleancall@@3P6A_JIIPEA_K@ZEA 0000000140012d80     HIGU_ntcall:cleancall.obj
 0003:00000d88       ?used_gate_type@cleancall@@3W4_cleancall_gate_type@1@A 0000000140012d88     HIGU_ntcall:cleancall.obj
 0005:00000060       $R000000                   0000000140015060     * linker generated manifest res *

```

`src/test_app/test_app.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{d3bb02a9-0655-4fc0-8cc3-711ceb494619}</ProjectGuid>
    <RootNamespace>testapp</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\$(Configuration)$(PlatformArchitecture)\</OutDir>
    <IntDir>$(SolutionDir)tmp\$(ProjectName)_$(Configuration)$(PlatformArchitecture)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\$(Configuration)$(PlatformArchitecture)\</OutDir>
    <IntDir>$(SolutionDir)tmp\$(ProjectName)_$(Configuration)$(PlatformArchitecture)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\$(Configuration)$(PlatformArchitecture)\</OutDir>
    <IntDir>$(SolutionDir)tmp\$(ProjectName)_$(Configuration)$(PlatformArchitecture)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\$(Configuration)$(PlatformArchitecture)\</OutDir>
    <IntDir>$(SolutionDir)tmp\$(ProjectName)_$(Configuration)$(PlatformArchitecture)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(SolutionDir)phnt;$(SolutionDir)src\HIGU_ntcall;</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>$(OutDir)</AdditionalLibraryDirectories>
      <AdditionalDependencies>HIGU_ntcall.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(SolutionDir)phnt;$(SolutionDir)src\HIGU_ntcall;</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>$(OutDir)</AdditionalLibraryDirectories>
      <AdditionalDependencies>HIGU_ntcall.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(SolutionDir)phnt;$(SolutionDir)src\HIGU_ntcall;</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>$(OutDir)</AdditionalLibraryDirectories>
      <AdditionalDependencies>HIGU_ntcall.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <GenerateMapFile>true</GenerateMapFile>
      <MapFileName>
      </MapFileName>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(SolutionDir)phnt;$(SolutionDir)src\HIGU_ntcall;</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>$(OutDir)</AdditionalLibraryDirectories>
      <AdditionalDependencies>HIGU_ntcall.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <GenerateMapFile>true</GenerateMapFile>
      <MapFileName>
      </MapFileName>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="test_app.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`src/test_app/test_app.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="test_app.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```