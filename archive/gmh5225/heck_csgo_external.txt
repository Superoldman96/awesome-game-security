Project Path: arc_gmh5225_heck_csgo_external_6lcujtgs

Source Tree:

```txt
arc_gmh5225_heck_csgo_external_6lcujtgs
├── LICENSE
├── README.md
├── configs
│   ├── custom.txt
│   ├── hitsounds
│   │   ├── 1.wav
│   │   ├── 2.wav
│   │   └── 3.wav
│   ├── legit.txt
│   └── rage.txt
├── heck_external.sln
├── screenshot.png
└── src
    ├── Aim.hpp
    ├── CPlayer.hpp
    ├── CWeapon.hpp
    ├── Common.hpp
    ├── Config.hpp
    ├── Features.hpp
    ├── Main.cpp
    ├── Memory.hpp
    ├── Misc.hpp
    ├── NetVars.hpp
    ├── SDK
    │   ├── BSP.hpp
    │   ├── Client.hpp
    │   ├── Random.hpp
    │   ├── Studio.hpp
    │   ├── UserCmd.hpp
    │   └── checksum_md5.hpp
    ├── Shellcodes.hpp
    ├── Signatures.hpp
    ├── Vector.hpp
    ├── Visuals.hpp
    ├── heck_external.vcxproj
    ├── heck_external.vcxproj.filters
    ├── stdafx.cpp
    └── stdafx.h

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Lesser General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

                    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

                            NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

    Gnomovision version 69, Copyright (C) year name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  <signature of Ty Coon>, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.

```

`README.md`:

```md
# heck external
Fully featured CS:GO external cheat.

![screenshot](screenshot.png)

# Disclaimer
The cheat is outdated, signatures and offsets need to be updated.

No ESP.

UserCmd features unbind left mouse button.

bSendPacket features don't work on a local server in Release build due to it using m_flNextCmdTime method.

# Features
## Aim:
* Aimbot:
  - Enable
  - VKey
  - Team check
  - Auto fire
  - Hitscan:
    - Enable
    - Priority (1 - most dmg, 2 - closest)
    - Head
    - Body
    - Shoulders
    - Legs
    - Toes
  - Pseudo auto wall
  
  - Rage:
    - Enable
    - Prioritize bone
    - FOV
    - Auto scope
    - Body aim with AWP
    - Silent aim
    - Hit chance:
      - Enable
      - Pistols %
      - SMGs %
      - Rifles %
      - Machineguns %
      - Shotguns %
      - Auto-snipers %
      - SSG08 %
      - AWP  %
      
  - Weapon category settings:
    - Prioritize bone
    - Scale FOV by distance
    - FOV
    - Speed
    - Ignore enemies in air
    - Disable when flashed
    - Silent aim

* RCS:
  - Enable
  - Always on
  - Vertical %
  - Horizontal %

* Triggerbot:
  - Enable
  - VKey
  - Disable when flashed

* Auto pistol
* Backtrack:
  - Enable
  - Max [1-12]

## Visuals:
* Team check
* Glow ESP:
  - Players
  - Style (0 - outside, 1 - silhouette, 2 - inside)
  - Patch flicker
  - Color
  - Color health based
    - Color 0 hp
    - Color 100 hp
  - Show vunerable 
  - Vunerable color
  - Dropped C4
  - Grenades

* Model tone:
  - Enable
  - Color

* Show enemies on radar
* Update delay (ms)

## Misc:
* Auto jump:
  - Enable
  - Legit looking

* Fake lag:
  - Enable
  - Toggle VKey (0 - no key)
  - Ticks lag
  - Ticks pass
  - Disable when shooting
  - Only in air
  
* Hitsound:
  - Enable
  - Style 
  - Volume %
  
* Nightmode:
  - Enable
  - Lightscale
  
* Skybox name
* Enable "name" command
* Auto accept
* Reveal ranks
* Disable post-processing
* No smoke
* No sniper scope
* Visual no recoil (1 - no punch, 2 - no recoil)
* Max flash %
* Viewmodel FOV
* View FOV
* Load next config vkey
* Insult vkey
* Bot mount vkey (aka runboost bot)

# Compile
You can compile with or without the "insult" feature. 

### Compiling with the "insult" feature
* Compile libcurl with windows SSPI or other SSL (but you'll have to set CA cert)
* Fix project's include paths
* Select "Release" project configuration
* Compile the cheat

### Compiling without "insult" feature
* Select "Release (no curl)" project configuration
* Compile the cheat

# Usage
* Copy contents of "configs" folder into cheat's directory
* Optionally edit configs to enable/disable features (0 - off, 1 - on)
* Optionally add different hitsounds by placing the WAV files in "hitsounds" folder and naming them "\*single digit\*.wav" ("1.wav" etc.)
* Start the cheat

Config parsing depends on the order of settings (e.g. 1st setting must be "aimbot enable"), you'll most likely get "Warning: MapVirtualKey returned 0" if you break the order.

# Credits
* nuggah for external UserCmd manipulation
* Forza for signature finder
* ReactiioN for hitbox enum
* keybode for BSP parser

```

`configs/custom.txt`:

```txt
Aim:
	Aimbot:
		Enable						= 1
		VKey						= 1
		Team check					= 1
		Auto fire					= 0
		Hitscan:
			Enable						= 1
			Priority (1 - most dmg,
				2 - closest)			= 2
			Head						= 1
			Body						= 1
			Shoulders					= 1
			Legs						= 0
			Toes						= 0
		Pseudo auto wall			= 0
		
		Rage:
			Enable						= 0
			Prioritize bone				= 8
			FOV							= 30
			Auto scope					= 1
			Body aim with AWP			= 1
			Silent aim					= 0
			Hit chance:
				Enable						= 1
				Pistols %					= 40
				SMGs %						= 10
				Rifles %					= 20
				Machineguns %				= 20
				Shotguns %					= 10
				Auto-snipers %				= 50
				SSG08 %						= 40
				AWP	%						= 40
				
		PISTOLS:
			Prioritize bone				= 8
			Scale FOV by distance		= 0
			FOV							= 0.7
			Speed						= 0.5
			Ignore enemies in air		= 0
			Disable when flashed		= 1
			Silent aim					= 1

		SMGS:
			Prioritize bone				= 8
			Scale FOV by distance		= 0
			FOV							= 1.0
			Speed						= 0.2
			Ignore enemies in air		= 1
			Disable when flashed		= 1
			Silent aim					= 0

		RIFLES:
			Prioritize bone				= 8
			Scale FOV by distance		= 0
			FOV							= 1.0
			Speed						= 0.25
			Ignore enemies in air		= 1
			Disable when flashed		= 1
			Silent aim					= 0

		SHOTGUNS:
			Prioritize bone				= 6
			Scale FOV by distance		= 0
			FOV							= 2.0
			Speed						= 0.5
			Ignore enemies in air		= 0
			Disable when flashed		= 1
			Silent aim					= 0

		AUTO-SNIPERS:
			Prioritize bone				= 5
			Scale FOV by distance		= 0
			FOV							= 1.0
			Speed						= 0.2
			Ignore enemies in air		= 1
			Disable when flashed		= 1
			Silent aim					= 0

		SSG08:
			Prioritize bone				= 8
			Scale FOV by distance		= 0
			FOV							= 1.1
			Speed						= 0.8
			Ignore enemies in air		= 0
			Disable when flashed		= 0
			Silent aim					= 0

		AWP:
			Prioritize bone				= 5
			Scale FOV by distance		= 0
			FOV							= 1.5
			Speed						= 0.8
			Ignore enemies in air		= 0
			Disable when flashed		= 0
			Silent aim					= 0

	RCS:
		Enable						= 0
		Always on					= 0
		Vertical %					= 100
		Horizontal %				= 50

	Triggerbot:
		Enable						= 1
		VKey						= 6
		Disable when flashed		= 1

	Auto pistol					= 1
	Backtrack:
		Enable						= 1
		Max [1-12]					= 12

Visuals:
	Team check					= 1
	Glow ESP:
		Players						= 1
		Style (0 - outside,
			1 - silhouette,
			2 - inside)				= 0
		Patch flicker				= 0
		Color						= [255, 102, 171, 128]
		Color health based			= 0
			Color 0 hp					= [255, 0, 0, 153]
			Color 100 hp				= [0, 255, 0, 153]
		Show vunerable 				= 1
		Vunerable color				= [255, 255, 255, 153]
		Dropped C4					= 1
		Grenades					= 1

	Model tone:
		Enable						= 1
		Color						= [255, 102, 171]

	Show enemies on radar		= 1
	Update delay (ms)			= 50

Misc:
	Auto jump:
		Enable						= 1
		Legit looking				= 0

	Fake lag:
		Enable						= 1
		Toggle VKey (0 - no key)	= 78
		Ticks lag					= 10
		Ticks pass					= 2
		Disable when shooting		= 1
		Only in air					= 0

	Hitsound:
		Enable						= 0
		Style						= 1
		Volume %					= 100
		
	Nightmode:
		Enable						= 0
		Lightscale					= 0.15
		
	Skybox name					= ""
	Enable "name" command		= 1
	Auto accept					= 1
	Reveal ranks				= 1
	Disable post-processing		= 1
	No smoke					= 0
	No sniper scope				= 0
	Visual no recoil
		(1 - no punch,
		2 - no recoil)			= 0
	Max flash %					= 80
	Viewmodel FOV				= 76
	View FOV					= 0
	Load next config vkey		= 114
	Insult vkey					= 115
	Bot mount vkey				= 53
```

`configs/legit.txt`:

```txt
Aim:
	Aimbot:
		Enable						= 0
		VKey						= 1
		Team check					= 1
		Auto fire					= 0
		Hitscan:
			Enable						= 0
			Priority (1 - most dmg,
				2 - closest)			= 1
			Head						= 1
			Body						= 1
			Shoulders					= 1
			Legs						= 1
			Toes						= 1
		Pseudo auto wall			= 0
		
		Rage:
			Enable						= 0
			Prioritize bone				= 8
			FOV							= 30
			Auto scope					= 1
			Body aim with AWP			= 1
			Silent aim					= 0
			Hit chance:
				Enable						= 1
				Pistols %					= 40
				SMGs %						= 10
				Rifles %					= 20
				Machineguns %				= 20
				Shotguns %					= 10
				Auto-snipers %				= 50
				SSG08 %						= 40
				AWP	%						= 40
				
		PISTOLS:
			Prioritize bone				= 8
			Scale FOV by distance		= 0
			FOV							= 1.1
			Speed						= 0.7
			Ignore enemies in air		= 0
			Disable when flashed		= 1
			Silent aim					= 0

		SMGS:
			Prioritize bone				= 8
			Scale FOV by distance		= 0
			FOV							= 1.0
			Speed						= 0.2
			Ignore enemies in air		= 1
			Disable when flashed		= 1
			Silent aim					= 0

		RIFLES:
			Prioritize bone				= 8
			Scale FOV by distance		= 0
			FOV							= 1.0
			Speed						= 0.25
			Ignore enemies in air		= 1
			Disable when flashed		= 1
			Silent aim					= 0

		SHOTGUNS:
			Prioritize bone				= 6
			Scale FOV by distance		= 0
			FOV							= 2.0
			Speed						= 0.5
			Ignore enemies in air		= 0
			Disable when flashed		= 1
			Silent aim					= 0

		AUTO-SNIPERS:
			Prioritize bone				= 5
			Scale FOV by distance		= 0
			FOV							= 1.0
			Speed						= 0.2
			Ignore enemies in air		= 1
			Disable when flashed		= 1
			Silent aim					= 0

		SSG08:
			Prioritize bone				= 8
			Scale FOV by distance		= 0
			FOV							= 1.1
			Speed						= 0.8
			Ignore enemies in air		= 0
			Disable when flashed		= 0
			Silent aim					= 0

		AWP:
			Prioritize bone				= 5
			Scale FOV by distance		= 0
			FOV							= 1.5
			Speed						= 0.8
			Ignore enemies in air		= 0
			Disable when flashed		= 0
			Silent aim					= 0

	RCS:
		Enable						= 0
		Always on					= 0
		Vertical %					= 100
		Horizontal %				= 100

	Triggerbot:
		Enable						= 1
		VKey						= 6
		Disable when flashed		= 1

	Auto pistol					= 1
	Backtrack:
		Enable						= 1
		Max [1-12]					= 12

Visuals:
	Team check					= 1
	Glow ESP:
		Players						= 0
		Style (0 - outside,
			1 - silhouette,
			2 - inside)				= 1
		Patch flicker				= 0
		Color						= [255, 102, 171, 128]
		Color health based			= 0
			Color 0 hp					= [255, 0, 0, 153]
			Color 100 hp				= [0, 255, 0, 153]
		Show vunerable 				= 1
		Vunerable color				= [255, 255, 255, 153]
		Dropped C4					= 1
		Grenades					= 1

	Model tone:
		Enable						= 1
		Color						= [255, 0, 0]

	Show enemies on radar		= 1
	Update delay (ms)			= 250

Misc:
	Auto jump:
		Enable						= 1
		Legit looking				= 1

	Fake lag:
		Enable						= 0
		Toggle VKey (0 - no key)	= 0
		Ticks lag					= 6
		Ticks pass					= 2
		Disable when shooting		= 1
		Only in air					= 0
		
	Hitsound:
		Enable						= 0
		Style 						= 1
		Volume %					= 100
		
	Nightmode:
		Enable						= 0
		Lightscale					= 0.15
		
	Skybox name					= ""
	Enable "name" command		= 1
	Auto accept					= 1
	Reveal ranks				= 1
	Disable post-processing		= 1
	No smoke					= 0
	No sniper scope				= 0
	Visual no recoil
		(1 - no punch,
		2 - no recoil)			= 0
	Max flash %					= 80
	Viewmodel FOV				= 76
	View FOV					= 0
	Load next config vkey		= 114
	Insult vkey					= 115
	Bot mount vkey				= 53
```

`configs/rage.txt`:

```txt
Aim:
	Aimbot:
		Enable						= 1
		VKey						= 6
		Team check					= 1
		Auto fire					= 1
		Hitscan:
			Enable						= 1
			Priority (1 - most dmg,
				2 - closest)			= 1
			Head						= 1
			Body						= 1
			Shoulders					= 1
			Legs						= 1
			Toes						= 1
		Pseudo auto wall			= 1
		
		Rage:
			Enable						= 1
			Prioritize bone				= 8
			FOV							= 45
			Auto scope					= 1
			Body aim with AWP			= 1
			Silent aim					= 1
			Hit chance:
				Enable						= 1
				Pistols %					= 40
				SMGs %						= 10
				Rifles %					= 20
				Machineguns %				= 20
				Shotguns %					= 10
				Auto-snipers %				= 50
				SSG08 %						= 40
				AWP	%						= 40
				
		PISTOLS:
			Prioritize bone				= 8
			Scale FOV by distance		= 0
			FOV							= 0.7
			Speed						= 0.5
			Ignore enemies in air		= 0
			Disable when flashed		= 1
			Silent aim					= 0

		SMGS:
			Prioritize bone				= 8
			Scale FOV by distance		= 0
			FOV							= 1.0
			Speed						= 0.25
			Ignore enemies in air		= 1
			Disable when flashed		= 1
			Silent aim					= 0

		RIFLES:
			Prioritize bone				= 8
			Scale FOV by distance		= 0
			FOV							= 0.9
			Speed						= 0.25
			Ignore enemies in air		= 1
			Disable when flashed		= 1
			Silent aim					= 0

		SHOTGUNS:
			Prioritize bone				= 6
			Scale FOV by distance		= 0
			FOV							= 2.0
			Speed						= 0.5
			Ignore enemies in air		= 0
			Disable when flashed		= 1
			Silent aim					= 0

		AUTO-SNIPERS:
			Prioritize bone				= 5
			Scale FOV by distance		= 0
			FOV							= 1.0
			Speed						= 0.2
			Ignore enemies in air		= 1
			Disable when flashed		= 1
			Silent aim					= 0

		SSG08:
			Prioritize bone				= 8
			Scale FOV by distance		= 0
			FOV							= 1.1
			Speed						= 0.8
			Ignore enemies in air		= 0
			Disable when flashed		= 0
			Silent aim					= 0

		AWP:
			Prioritize bone				= 5
			Scale FOV by distance		= 0
			FOV							= 1.6
			Speed						= 0.8
			Ignore enemies in air		= 0
			Disable when flashed		= 0
			Silent aim					= 0

	RCS:
		Enable						= 0
		Always on					= 0
		Vertical %					= 100
		Horizontal %				= 100

	Triggerbot:
		Enable						= 0
		VKey						= 6
		Disable when flashed		= 1

	Auto pistol					= 1
	Backtrack:
		Enable						= 1
		Max [1-12]					= 12

Visuals:
	Team check					= 1
	Glow ESP:
		Players						= 1
		Style (0 - outside,
			1 - silhouette,
			2 - inside)				= 0
		Patch flicker				= 0
		Color						= [255, 102, 171, 128]
		Color health based			= 1
			Color 0 hp					= [255, 0, 0, 153]
			Color 100 hp				= [0, 255, 0, 153]
		Show vunerable 				= 1
		Vunerable color				= [255, 255, 255, 153]
		Dropped C4					= 1
		Grenades					= 1

	Model tone:
		Enable						= 0
		Color						= [255, 102, 171]

	Show enemies on radar		= 1
	Update delay (ms)			= 50

Misc:
	Auto jump:
		Enable						= 1
		Legit looking				= 0

	Fake lag:
		Enable						= 0
		Toggle VKey (0 - no key)	= 0
		Ticks lag					= 6
		Ticks pass					= 2
		Disable when shooting		= 0
		Only in air					= 0

	Hitsound:
		Enable						= 1
		Style 						= 2
		Volume %					= 35
		
	Nightmode:
		Enable						= 0
		Lightscale					= 0.15
		
	Skybox name					= ""
	Enable "name" command		= 1
	Auto accept					= 1
	Reveal ranks				= 1
	Disable post-processing		= 1
	No smoke					= 1
	No sniper scope				= 1
	Visual no recoil
		(1 - no punch,
		2 - no recoil)			= 2
	Max flash %					= 0
	Viewmodel FOV				= 76
	View FOV					= 0
	Load next config vkey		= 114
	Insult vkey					= 115
	Bot mount vkey				= 53
```

`heck_external.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28307.329
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "heck_external", "src\heck_external.vcxproj", "{327334D9-4D57-4465-968F-96A81FD397A9}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release (no curl)|x64 = Release (no curl)|x64
		Release (no curl)|x86 = Release (no curl)|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{327334D9-4D57-4465-968F-96A81FD397A9}.Debug|x64.ActiveCfg = Debug|x64
		{327334D9-4D57-4465-968F-96A81FD397A9}.Debug|x64.Build.0 = Debug|x64
		{327334D9-4D57-4465-968F-96A81FD397A9}.Debug|x86.ActiveCfg = Debug|Win32
		{327334D9-4D57-4465-968F-96A81FD397A9}.Debug|x86.Build.0 = Debug|Win32
		{327334D9-4D57-4465-968F-96A81FD397A9}.Release (no curl)|x64.ActiveCfg = Release (no curl)|x64
		{327334D9-4D57-4465-968F-96A81FD397A9}.Release (no curl)|x64.Build.0 = Release (no curl)|x64
		{327334D9-4D57-4465-968F-96A81FD397A9}.Release (no curl)|x86.ActiveCfg = Release (no curl)|Win32
		{327334D9-4D57-4465-968F-96A81FD397A9}.Release (no curl)|x86.Build.0 = Release (no curl)|Win32
		{327334D9-4D57-4465-968F-96A81FD397A9}.Release|x64.ActiveCfg = Release|x64
		{327334D9-4D57-4465-968F-96A81FD397A9}.Release|x64.Build.0 = Release|x64
		{327334D9-4D57-4465-968F-96A81FD397A9}.Release|x86.ActiveCfg = Release|Win32
		{327334D9-4D57-4465-968F-96A81FD397A9}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {1A3A8770-3E09-44A1-926B-129C8542A991}
	EndGlobalSection
EndGlobal

```

`src/Aim.hpp`:

```hpp
#pragma once

namespace Features
{
	struct CBone
	{
		float _pad1[3];
		float x;
		float _pad2[3];
		float y;
		float _pad3[3];
		float z;

		operator vec3() const { return { x, y, z }; }

		CBone& operator+=(const vec3& vec) { x += vec.x; y += vec.y; z += vec.z; return *this; }
	};

	bool GetBestBone(const CWeapon& weapon, const Config::Aimbot::CWpnCfg* weaponCfg, const vec2& viewangles, const vec3& localHead, const CPlayer& Player, bool bodyAim, vec3& out)
	{
		if (bodyAim || Config::Aimbot::Hitscan::Enable)
		{
			const int* const hitboxBones = Studio::GetHitboxBones(Player);

			CBone Bones[128];
			Mem::Read<CBone[128]>(Player.m_pBones, Bones);

			Bones[hitboxBones[HITBOX_HEAD]].z += 2.4f;

			std::vector<int> hitscanBones;
			if (bodyAim)
			{
				hitscanBones.push_back(hitboxBones[HITBOX_PELVIS]);
				hitscanBones.push_back(hitboxBones[HITBOX_UPPER_CHEST]);
			}
			else
			{
				hitscanBones.push_back(weaponCfg->PriorityBone);

				if (Config::Aimbot::Hitscan::Head)
					hitscanBones.push_back(hitboxBones[HITBOX_HEAD]);

				if (Config::Aimbot::Hitscan::Body)
				{
					hitscanBones.push_back(hitboxBones[HITBOX_PELVIS]);
					hitscanBones.push_back(hitboxBones[HITBOX_UPPER_CHEST]);
				}

				if (Config::Aimbot::Hitscan::Shoulders)
				{
					hitscanBones.push_back(hitboxBones[HITBOX_LEFT_UPPER_ARM]);
					hitscanBones.push_back(hitboxBones[HITBOX_RIGHT_UPPER_ARM]);
				}

				if (Config::Aimbot::Hitscan::Legs)
				{
					hitscanBones.push_back(hitboxBones[HITBOX_LEFT_CALF]);
					hitscanBones.push_back(hitboxBones[HITBOX_RIGHT_CALF]);
				}

				if (Config::Aimbot::Hitscan::Toes)
				{
					hitscanBones.push_back(hitboxBones[HITBOX_LEFT_FOOT]);
					hitscanBones.push_back(hitboxBones[HITBOX_RIGHT_FOOT]);
				}
			}

			float bestFov = FLT_MAX;

			for (size_t i = 0; i < hitscanBones.size(); ++i)
			{
				Bones[hitscanBones[i]] += Player.m_vecVelocity * g_IntervalPerTick;

				if (BSP::CanHit(localHead, Bones[hitscanBones[i]], weapon.m_iItemDefinitionIndex))
				{
					if (!Config::Aimbot::Rage::Enable)
					{
						const vec3 posDelta(Bones[hitscanBones[i]] - localHead);
						const float distance = posDelta.Length();
						const float fov = GetFOV(viewangles, CalcAngle(localHead, Bones[hitscanBones[i]]));
						if (fov > weaponCfg->FOV)
							continue;

						if (weaponCfg->FovDistBased && (fov > RAD2DEG(atan2(weaponCfg->FOV, distance))))
							continue;

						if ((i != 0) && (Config::Aimbot::Hitscan::Priority == 2)) // what did i mean by this
						{
							if (fov < bestFov)
							{
								bestFov = fov;
								out = Bones[hitscanBones[i]];
							}
							continue;
						}
					}
					out = Bones[hitscanBones[i]];
					return true;
				}
			}

			if (bestFov != FLT_MAX)
				return true;
		}
		else
		{
			vec3 bone = Mem::Read<CBone>(Player.m_pBones + (weaponCfg->PriorityBone * sizeof(CBone)));
			if (weaponCfg->PriorityBone == 8)
				bone.z += 2.4f;

			bone += Player.m_vecVelocity * g_IntervalPerTick;

			if (BSP::CanHit(localHead, bone, weapon.m_iItemDefinitionIndex))
			{
				out = bone;
				return true;
			}
		}
		return false;
	}

	bool HitChance(const CWeapon& weapon, CSWeaponType weaponType, float dist)
	{
		int leftHits = Config::GetWpnHitchance(weapon.m_iItemDefinitionIndex, weaponType);
		if (leftHits <= 0)
			return true;
		leftHits *= (255.f / 100.f);

		Random::SetSeed((MD5_PseudoRandom(Mem::Read<int>(Signatures::m_nLastOutgoingCommand) + 1) & 0x7fffffff) & 0xff + 1);
		for (int i = 255; i > 0; --i)
		{
			const float aRandom[4] = {
				Random::RandomFloat(0.f, M_PI_F * 2.f),
				Random::RandomFloat(0.f, 1.f) * weapon.GetInaccuracy(g_LocalPlayer),
				Random::RandomFloat(0.f, M_PI_F * 2.f),
				Random::RandomFloat(0.f, 1.f) * weapon.GetSpread()
			};

			const vec2 vSpread(cos(aRandom[0]) * aRandom[1] + cos(aRandom[2]) * aRandom[3],
				sin(aRandom[0]) * aRandom[1] + sin(aRandom[2]) * aRandom[3]);

			const vec2 angSpread(RAD2DEG(atan(-vSpread.y / sqrt(1.f + -vSpread.x * -vSpread.x))),
				RAD2DEG(atan(-vSpread.x)));

			const float distBasedFOV = RAD2DEG(atan2(10.f, dist));
			if (angSpread.Length() < distBasedFOV)
			{
				if (--leftHits <= 0)
					return true;
			}
			else if (leftHits > i)
				return false;
		}
		return false;
	}

	namespace Backtrack
	{
		struct CRecord
		{
			float	SimTime = 0.f;
			vec3	Head;
			vec3	Body;
		};
		CRecord Records[64][12];

		void Record()
		{
			for (UINT i = 0; i < g_PlayersCount; ++i)
			{
				if ((!Config::Aimbot::TeamCheck || g_LocalPlayer.IsEnemy(g_Players[i])) && g_Players[i].IsGoodTarget())
				{
					CBone Bones[9];
					Mem::Read<CBone[9]>(g_Players[i].m_pBones, Bones);
					Records[i][g_LocalPlayer.m_nTickBase % Config::Backtrack::Max] = { g_Players[i].m_flSimulationTime, Bones[8], Bones[5] };
				}
			}
		}

		float GetSimTime(const vec2& viewangles)
		{
			vec3 localHead(g_LocalPlayer.m_vecOrigin);
			localHead.z += g_LocalPlayer.m_vecViewOffset.z;
			localHead += g_LocalPlayer.m_vecVelocity * g_IntervalPerTick;

			float bestSimTime = 0.f;
			float bestFov = FLT_MAX;

			for (UINT i = 0; i < g_PlayersCount; ++i)
			{
				if (!Config::Aimbot::TeamCheck || g_LocalPlayer.IsEnemy(g_Players[i]))
				{
					for (int j = 0; j < Config::Backtrack::Max; ++j)
					{
						if ((g_LocalPlayer.m_flSimulationTime - Records[i][j].SimTime) <= 0.2f) // sv_maxunlag = 0.2
						{
							for (UINT k = 0; k < 2 && bestFov == FLT_MAX; ++k)
							{
								const vec3 posDelta((k == 0 ? Records[i][j].Head : Records[i][j].Body) - localHead);
								const float distance = posDelta.Length();
								const float fov = GetFOV(viewangles, CalcAngle(posDelta, distance));
								if (fov < bestFov)
								{
									const float distBasedFOV = RAD2DEG(atan2((k == 0 ? 5.f : 10.f), distance));
									if (fov <= distBasedFOV)
									{
										bestSimTime = Records[i][j].SimTime;
										bestFov = fov;
									}
								}
							}
						}
					}
				}
			}
#ifndef NDEBUG
			if (bestSimTime != 0.f)
				std::cout << "Backtrack delta - " << static_cast<int>(TIME_TO_TICKS(g_LocalPlayer.m_flSimulationTime - bestSimTime)) << '\n';
			else
				std::cout << "Can't backtrack\n";
#endif
			return bestSimTime;
		}
	}

	void Aimbot(const CWeapon& weapon, CSWeaponType weaponType, vec2& cmdViewangles, bool& outShoot, bool& outHaveTarget)
	{
		Config::Aimbot::CWpnCfg* wpnCfg = Config::GetWeaponCfg(weapon.m_iItemDefinitionIndex, weaponType);
		if (wpnCfg && 
			((!Config::Aimbot::Rage::Enable && !weapon.IsLowFirerate()) || (ROUND_TO_TICKS(weapon.m_flNextPrimaryAttack) <= TICKS_TO_TIME(g_LocalPlayer.m_nTickBase))) &&
			(!wpnCfg->CheckIfFlashed || (g_LocalPlayer.m_flFlashAlpha <= 120.f)) &&
			(GetAsyncKeyState(Config::Aimbot::Key) & 0x8000))
		{
			vec2 bulletAngle(cmdViewangles);
			bulletAngle.x += g_LocalPlayer.m_aimPunchAngle.x * 2.f; // adding recoil to our viewangles
			bulletAngle.y += g_LocalPlayer.m_aimPunchAngle.y * 2.f; // (expecting player is compensating them)
			ClampAngle(&bulletAngle.x);

			vec3 localHead(g_LocalPlayer.m_vecOrigin);
			localHead.z += g_LocalPlayer.m_vecViewOffset.z;
			localHead += g_LocalPlayer.m_vecVelocity * g_IntervalPerTick;

			const bool bBodyAim = (weapon.m_iItemDefinitionIndex == WEAPON_TASER) || // taser gets here only if raging so not checking
				(Config::Aimbot::Rage::Enable && Config::Aimbot::Rage::BodyAWP && (weapon.m_iItemDefinitionIndex == WEAPON_AWP));

			vec2 bestAngleDelta;
			float bestFov = wpnCfg->FOV;
			for (UINT i = 0; i < g_PlayersCount; ++i)
			{
				if ((!Config::Aimbot::TeamCheck || g_Players[i].IsEnemy(g_LocalPlayer)) && g_Players[i].IsGoodTarget() && (!wpnCfg->IgnoreInAir || (g_Players[i].m_fFlags & FL_ONGROUND)))
				{
					vec3 aimPoint;
					if (!GetBestBone(weapon, wpnCfg, bulletAngle, localHead, g_Players[i], bBodyAim, aimPoint))
						continue;

					const vec3 posDelta(aimPoint - localHead);
					const float distance = posDelta.Length();

					vec2 angleDelta(CalcAngle(posDelta, distance) - bulletAngle);
					ClampAngle(&angleDelta.x);

					if (weapon.m_iItemDefinitionIndex == WEAPON_TASER)
					{
						if (distance <= 182.f)
						{
							bestFov = 0.f;
							bestAngleDelta = angleDelta;
							break;
						}
						else
							continue;
					}

					float fov = angleDelta.Length();
					if (fov > 180.f)
						fov = 360.f - fov;

					if (fov < bestFov)
					{
						if (Config::Aimbot::Rage::Enable)
						{
							if (Config::Aimbot::Rage::AutoScope && !weapon.m_zoomLevel && weapon.CanScope())
							{
								Mem::Write<uint8_t>(Signatures::Attack2, 6);
								return;
							}

							if (Config::Aimbot::Rage::HitChance::Enable && !HitChance(weapon, weaponType, distance))
								continue;
						}
						else if (wpnCfg->FovDistBased)
						{
							const float distBasedFOV = RAD2DEG(atan2(wpnCfg->FOV, distance)); // clamp dist fov by min value?
							if (distBasedFOV < fov)
								continue;
						}

						bestFov = fov;
						bestAngleDelta = angleDelta;
					}
				}
			}

			if (bestFov != wpnCfg->FOV)
			{
				outHaveTarget = true;
				cmdViewangles += bestAngleDelta * wpnCfg->Speed;
				ClampAngle(&cmdViewangles.x);

				if (!wpnCfg->Silent)
				{
					Mem::Write<bool>(Signatures::m_fMouseActive, false);
					Mem::Write<vec2>(Signatures::m_vecViewAngles, cmdViewangles);
				}

				if (Config::Aimbot::AutoFire)
					outShoot = true;
			}
		}
	}

	void Triggerbot(bool& outShoot)
	{
		if (0 < g_LocalPlayer.m_iIDEntIndex &&
			g_LocalPlayer.m_iIDEntIndex <= 64 && (!Config::Triggerbot::CheckIfFlashed || (g_LocalPlayer.m_flFlashAlpha <= 120.f)) &&
			(GetAsyncKeyState(Config::Triggerbot::Key) & 0x8000))
		{
			for (UINT i = 0; i < g_PlayersCount; ++i)
			{
				if (g_Players[i].index == g_LocalPlayer.m_iIDEntIndex)
				{
					if (g_Players[i].IsEnemy(g_LocalPlayer))
						outShoot = true;
					break;
				}
			}
		}
	}

	void AutoPistol(const CWeapon& weapon, CSWeaponType weaponType, bool& outShoot)
	{
		if ((weapon.m_iItemDefinitionIndex != WEAPON_CZ75A) && (weaponType == WEAPONTYPE_PISTOL) && (GetAsyncKeyState(VK_LBUTTON) & 0x8000))
			outShoot = (g_LocalPlayer.m_nTickBase % 2);
	}

	void RCS(const CWeapon& weapon, vec2& viewangles, bool bHaveTarget)
	{
		static vec2 prevPunch;
		if (!weapon.m_bInReload &&
			(Config::RCS::AlwaysOn ? (GetAsyncKeyState(VK_LBUTTON) & 0x8000) : bHaveTarget) &&
			(g_bChangingUserCmd ? !weapon.IsLowFirerate() : (g_LocalPlayer.m_iShotsFired > 1)))
		{
			viewangles.x -= (g_LocalPlayer.m_aimPunchAngle.x - prevPunch.x) * ((2.f / 100.f) * Config::RCS::Vertical);
			viewangles.y -= (g_LocalPlayer.m_aimPunchAngle.y - prevPunch.y) * ((2.f / 100.f) * Config::RCS::Horizontal);
			ClampAngle(&viewangles.x);
			Mem::Write<vec2>(Signatures::m_vecViewAngles, viewangles);
		}
		prevPunch = { g_LocalPlayer.m_aimPunchAngle.x, g_LocalPlayer.m_aimPunchAngle.y };
	}

	void Aim()
	{
		bool bHold = false;
		while (true)
		{
			CWeapon weapon;
			if (g_bInGame && (Config::Aimbot::Enable || Config::Triggerbot::Enable || Config::AutoPistol) && IsMouseActive() && g_LocalPlayer.GetWeapon(weapon))
			{
				const CSWeaponType weaponType = GetWeaponType(weapon.m_iItemDefinitionIndex);
				vec2 cmdViewangles;
				Mem::Read<vec2>(Signatures::m_vecViewAngles, cmdViewangles);
				bool bShoot = g_bChangingUserCmd && (GetAsyncKeyState(VK_LBUTTON) & 0x8000);
				if ((0 < weapon.m_iClip1) && (weapon.m_iItemDefinitionIndex != WEAPON_BREACHCHARGE))
				{
					bool bHaveTarget = false;
					if (!weapon.m_bInReload && Config::Aimbot::Enable)
						Aimbot(weapon, weaponType, cmdViewangles, bShoot, bHaveTarget);

					if (Config::RCS::Enable)
						RCS(weapon, cmdViewangles, bHaveTarget);

					if (!weapon.m_bInReload && (ROUND_TO_TICKS(weapon.m_flNextPrimaryAttack) <= TICKS_TO_TIME(g_LocalPlayer.m_nTickBase)))
					{
						if (!bShoot && Config::Triggerbot::Enable)
							Triggerbot(bShoot);

						if (Config::AutoPistol)
							AutoPistol(weapon, weaponType, bShoot);

						if (bShoot)
						{
							bool bWriteViewangles = false;
							if (Config::Aimbot::Enable)
							{
								Config::Aimbot::CWpnCfg* wpnCfg = Config::GetWeaponCfg(weapon.m_iItemDefinitionIndex, weaponType);
								if (wpnCfg && wpnCfg->Silent && (GetAsyncKeyState(Config::Aimbot::Key) & 0x8000))
									bWriteViewangles = true;
							}

							float simTime = (Config::Backtrack::Enable && 
								((weapon.m_iItemDefinitionIndex != WEAPON_TASER) || (GetAsyncKeyState(VK_LBUTTON) & 0x8000))) ? Backtrack::GetSimTime(cmdViewangles) : 0.f;

							if (bWriteViewangles || simTime)
							{
#ifndef NDEBUG
								std::cout << "Changing UserCmd\n";
#endif
								ChangeUserCmd(bWriteViewangles ? &cmdViewangles : nullptr,
									IN_ATTACK,
									simTime ? TIME_TO_TICKS(simTime) : 0);
								bShoot = false;
							}
						}
					}
				}

				if (bShoot)
				{
#ifndef NDEBUG
					std::cout << "Writing attack\n";
#endif
					if (!bHold)
					{
						if ((weapon.m_iItemDefinitionIndex == WEAPON_C4) || (weaponType == WEAPONTYPE_GRENADE))
						{
							bHold = true;
							Mem::Write<uint8_t>(Signatures::Attack, 5);
						}
						else
						{
							Mem::Write<uint8_t>(Signatures::Attack, 6);

							if (Config::FakeLag::Enabled && Config::FakeLag::DisableWhenShoot)
#ifdef NDEBUG
								Mem::Write<double>(Signatures::m_flNextCmdTime, 0.0);
#else
								Mem::Write<bool>(Signatures::bSendPacket, true);
#endif // NDEBUG
						}
					}
				}
				else if (bHold)
				{
					bHold = false;
					Mem::Write<uint8_t>(Signatures::Attack, 4);
				}
				Backtrack::Record();

				if (Config::Hitsound::Enable)
				{
					static int prevTotalHits = g_LocalPlayer.m_Hits.m_Size;
					if (prevTotalHits < g_LocalPlayer.m_Hits.m_Size)
					{
						char szFile[16] = "hitsounds\\0.wav";
						szFile[10] = '0' + Config::Hitsound::Style;
						static const HMODULE hMod = GetModuleHandle(NULL);
						PlaySound(szFile, hMod, SND_FILENAME | SND_ASYNC | SND_NODEFAULT);
					}
					prevTotalHits = g_LocalPlayer.m_Hits.m_Size;
				}
			}
			SleepTicks(1.f);
		}
	}
}
```

`src/CPlayer.hpp`:

```hpp
#pragma once

extern bool g_bDangerZone;

struct CEntInfo
{
	uintptr_t	m_pEntity;
	int			m_SerialNumber;
	CEntInfo*	m_pPrev;
	CEntInfo*	m_pNext;
};

enum MoveType_t : UCHAR
{
	MOVETYPE_NONE = 0,			// never moves
	MOVETYPE_ISOMETRIC,			// For players -- in TF2 commander view, etc.
	MOVETYPE_WALK,				// Player only - moving on the ground
	MOVETYPE_STEP,				// gravity, special edge handling -- monsters use this
	MOVETYPE_FLY,				// No gravity, but still collides with stuff
	MOVETYPE_FLYGRAVITY,		// flies through the air + is affected by gravity
	MOVETYPE_VPHYSICS,			// uses VPHYSICS for simulation
	MOVETYPE_PUSH,				// no clip to world, push and crush
	MOVETYPE_NOCLIP,			// No gravity, no collisions, still do velocity/avelocity
	MOVETYPE_LADDER,			// Used by players only when going onto a ladder
	MOVETYPE_OBSERVER,			// Observer movement, depends on player's observer mode
	MOVETYPE_CUSTOM,			// Allows the entity to describe its own physics

	// should always be defined as the last item in the list
	MOVETYPE_LAST = MOVETYPE_CUSTOM,

	MOVETYPE_MAX_BITS = 4
};

// Flags
#define	FL_ONGROUND				(1<<0)	// At rest / on the ground
#define FL_DUCKING				(1<<1)	// Player flag -- Player is fully crouched
#define FL_ANIMDUCKING			(1<<2)	// Player flag -- Player is in the process of crouching or uncrouching but could be in transition
// examples:                                   Fully ducked:  FL_DUCKING &  FL_ANIMDUCKING
//           Previously fully ducked, unducking in progress:  FL_DUCKING & !FL_ANIMDUCKING
//                                           Fully unducked: !FL_DUCKING & !FL_ANIMDUCKING
//           Previously fully unducked, ducking in progress: !FL_DUCKING &  FL_ANIMDUCKING
#define	FL_WATERJUMP			(1<<3) // Player jumping out of water
#define FL_ONTRAIN				(1<<4) // Player is _controlling_ a train, so movement commands should be ignored on client during prediction.
#define FL_INRAIN				(1<<5) // Indicates the entity is standing in rain
#define FL_FROZEN				(1<<6) // Player is frozen for 3rd person camera
#define FL_ATCONTROLS			(1<<7) // Player can't move, but keeps key inputs for controlling another entity
#define	FL_CLIENT				(1<<8) // Is a player
#define FL_FAKECLIENT			(1<<9) // Fake client, simulated server side; don't send network messages to them
// NON-PLAYER SPECIFIC (i.e., not used by GameMovement or the client .dll ) -- Can still be applied to players, though
#define	FL_INWATER				(1<<10) // In water

class CWeapon;

class CPlayer
{
public:
	int			index;
	uintptr_t	model;
	DWORD		m_clrRender;
	vec3		m_vecAbsVelocity;
	bool		m_bDormant;
	int			m_iTeamNum;
	int			m_iHealth;
	int			m_fFlags;
	vec3		m_vecViewOffset;
	vec3		m_vecVelocity;
	vec3		m_vecOrigin;
	char		m_lifeState;
	float		m_flSimulationTime;
	bool		m_bSpotted;
	uintptr_t	m_pBones;
	uintptr_t	m_pStudioHdr;
	DWORD		m_hActiveWeapon;
	vec3		m_aimPunchAngle;
	int			m_iDefaultFOV;
	int			m_nTickBase;
	bool		m_bIsScoped;
	bool		m_bIsWalking;
	bool		m_bGunGameImmunity;
	int			m_iShotsFired;
	int			m_nSurvivalTeam;
	float		m_flFlashAlpha;
	float		m_flFlashMaxAlpha;
	vec3		m_angEyeAngles;
	int			m_iIDEntIndex;
	CUtlVector	m_Hits;

	uintptr_t Address;

	inline void SetFromChunk(std::byte* chunk)
	{
		index = *reinterpret_cast<decltype(index)*>(reinterpret_cast<uintptr_t>(chunk) + 0x64);
		model = *reinterpret_cast<decltype(model)*>(reinterpret_cast<uintptr_t>(chunk) + 0x6C);
		CHUNKTONETVAR(chunk, m_clrRender);
		m_vecAbsVelocity = *reinterpret_cast<decltype(m_vecAbsVelocity)*>(reinterpret_cast<uintptr_t>(chunk) + 0x94);
		m_bDormant = *reinterpret_cast<decltype(m_bDormant)*>(reinterpret_cast<uintptr_t>(chunk) + 0xED);
		CHUNKTONETVAR(chunk, m_iTeamNum);
		CHUNKTONETVAR(chunk, m_iHealth);
		CHUNKTONETVAR(chunk, m_fFlags);
		CHUNKTONETVAR(chunk, m_vecViewOffset);
		CHUNKTONETVAR(chunk, m_vecVelocity);
		CHUNKTONETVAR(chunk, m_vecOrigin);
		CHUNKTONETVAR(chunk, m_lifeState);
		CHUNKTONETVAR(chunk, m_flSimulationTime);
		CHUNKTONETVAR(chunk, m_bSpotted);
		CHUNKTONETVAR(chunk, m_pBones);
		m_pStudioHdr = *reinterpret_cast<decltype(m_pStudioHdr)*>(reinterpret_cast<uintptr_t>(chunk) + Signatures::m_pStudioHdr);
		CHUNKTONETVAR(chunk, m_hActiveWeapon);
		CHUNKTONETVAR(chunk, m_aimPunchAngle);
		CHUNKTONETVAR(chunk, m_iDefaultFOV);
		CHUNKTONETVAR(chunk, m_nTickBase);
		CHUNKTONETVAR(chunk, m_bIsScoped);
		CHUNKTONETVAR(chunk, m_bIsWalking);
		CHUNKTONETVAR(chunk, m_bGunGameImmunity);
		CHUNKTONETVAR(chunk, m_iShotsFired);
		CHUNKTONETVAR(chunk, m_nSurvivalTeam);
		CHUNKTONETVAR(chunk, m_flFlashAlpha);
		CHUNKTONETVAR(chunk, m_flFlashMaxAlpha);
		CHUNKTONETVAR(chunk, m_angEyeAngles);
		CHUNKTONETVAR(chunk, m_iIDEntIndex);
		m_Hits = *reinterpret_cast<decltype(m_Hits)*>(reinterpret_cast<uintptr_t>(chunk) + Signatures::m_Hits);
	}

	inline void Update(uintptr_t pEntity)
	{
		std::byte* chunk = new std::byte[Signatures::m_Hits + sizeof(CUtlVector)];
		ReadProcessMemory(Mem::Process, reinterpret_cast<LPCVOID>(pEntity), chunk, Signatures::m_Hits + sizeof(CUtlVector), 0);
		SetFromChunk(chunk);
		delete[] chunk;
		Address = pEntity;
	}

	inline bool GetWeapon(CWeapon& out) const;

	inline bool IsEnemy(const CPlayer& pPlayer) const
	{
		return g_bDangerZone ? ((m_nSurvivalTeam == -1) || (m_nSurvivalTeam != pPlayer.m_nSurvivalTeam)) : (m_iTeamNum != pPlayer.m_iTeamNum);
	}

	inline bool IsGoodTarget() const
	{
		return !m_bDormant && !m_lifeState && !m_bGunGameImmunity;
	}
} g_LocalPlayer;

CPlayer g_Players[63];
unsigned int g_PlayersCount = 0;
```

`src/CWeapon.hpp`:

```hpp
#pragma once

enum ItemDefinitionIndex
{
	WEAPON_NONE = 0,
	WEAPON_DEAGLE,
	WEAPON_ELITE,
	WEAPON_FIVESEVEN,
	WEAPON_GLOCK,
	WEAPON_AK47 = 7,
	WEAPON_AUG,
	WEAPON_AWP,
	WEAPON_FAMAS,
	WEAPON_G3SG1,
	WEAPON_GALILAR = 13,
	WEAPON_M249,
	WEAPON_M4A1 = 16,
	WEAPON_MAC10,
	WEAPON_P90 = 19,
	WEAPON_MP5SD = 23,
	WEAPON_UMP45,
	WEAPON_XM1014,
	WEAPON_BIZON,
	WEAPON_MAG7,
	WEAPON_NEGEV,
	WEAPON_SAWEDOFF,
	WEAPON_TEC9,
	WEAPON_TASER,
	WEAPON_HKP2000,
	WEAPON_MP7,
	WEAPON_MP9,
	WEAPON_NOVA,
	WEAPON_P250,
	WEAPON_SCAR20 = 38,
	WEAPON_SG556,
	WEAPON_SSG08,
	WEAPON_KNIFE_GG,
	WEAPON_KNIFE_CT,
	WEAPON_FLASHBANG,
	WEAPON_HEGRENADE,
	WEAPON_SMOKEGRENADE,
	WEAPON_MOLOTOV,
	WEAPON_DECOY,
	WEAPON_INCGRENADE,
	WEAPON_C4,
	WEAPON_HEALTHSHOT = 57,
	WEAPON_KNIFE_T = 59,
	WEAPON_M4A1_SILENCER,
	WEAPON_USP_SILENCER,
	WEAPON_CZ75A = 63,
	WEAPON_REVOLVER,
	WEAPON_TAGRENADE = 68,
	WEAPON_FISTS,
	WEAPON_BREACHCHARGE,
	WEAPON_TABLET = 72,
	//WEAPON_MELEE = 74,	// prefab
	WEAPON_AXE = 75,
	WEAPON_HAMMER,
	WEAPON_SPANNER = 78,
	WEAPON_KNIFE_GHOST = 80,
	WEAPON_FIREBOMB,
	WEAPON_DIVERSION,
	WEAPON_FRAG_GRENADE,
	WEAPON_KNIFE_BAYONET = 500,
	WEAPON_KNIFE_FLIP = 505,
	WEAPON_KNIFE_GUT,
	WEAPON_KNIFE_KARAMBIT,
	WEAPON_KNIFE_M9_BAYONET,
	WEAPON_KNIFE_TACTICAL,
	WEAPON_KNIFE_FALCHION = 512,
	WEAPON_KNIFE_SURVIVAL_BOWIE = 514,
	WEAPON_KNIFE_BUTTERFLY,
	WEAPON_KNIFE_PUSH,
	WEAPON_KNIFE_URSUS = 519,
	WEAPON_KNIFE_GYPSY_JACKKNIFE,
	WEAPON_KNIFE_STILETTO = 522,
	WEAPON_KNIFE_WIDOWMAKER
};

// change to array value table?
inline const char* GetWeaponClassName(int itemDefIndex)
{
	switch (itemDefIndex)
	{
	case WEAPON_DEAGLE: return "weapon_deagle";
	case WEAPON_ELITE: return "weapon_elite";
	case WEAPON_FIVESEVEN: return "weapon_fiveseven";
	case WEAPON_GLOCK: return "weapon_glock";
	case WEAPON_AK47: return "weapon_ak47";
	case WEAPON_AUG: return "weapon_aug";
	case WEAPON_AWP: return "weapon_awp";
	case WEAPON_FAMAS: return "weapon_famas";
	case WEAPON_G3SG1: return "weapon_g3sg1";
	case WEAPON_GALILAR: return "weapon_galilar";
	case WEAPON_M249: return "weapon_m249";
	case WEAPON_M4A1: return "weapon_m4a1";
	case WEAPON_MAC10: return "weapon_mac10";
	case WEAPON_P90: return "weapon_p90";
	case WEAPON_MP5SD: return "weapon_mp5sd";
	case WEAPON_UMP45: return "weapon_ump45";
	case WEAPON_XM1014: return "weapon_xm1014";
	case WEAPON_BIZON: return "weapon_bizon";
	case WEAPON_MAG7: return "weapon_mag7";
	case WEAPON_NEGEV: return "weapon_negev";
	case WEAPON_SAWEDOFF: return "weapon_sawedoff";
	case WEAPON_TEC9: return "weapon_tec9";
	case WEAPON_TASER: return "weapon_taser";
	case WEAPON_HKP2000: return "weapon_hkp2000";
	case WEAPON_MP7: return "weapon_mp7";
	case WEAPON_MP9: return "weapon_mp9";
	case WEAPON_NOVA: return "weapon_nova";
	case WEAPON_P250: return "weapon_p250";
	case WEAPON_SCAR20: return "weapon_scar20";
	case WEAPON_SG556: return "weapon_sg556";
	case WEAPON_SSG08: return "weapon_ssg08";
	case WEAPON_KNIFE_CT:
	case WEAPON_KNIFE_T:
	case WEAPON_KNIFE_GG:
	case WEAPON_KNIFE_GHOST:
	case WEAPON_KNIFE_BAYONET:
	case WEAPON_KNIFE_FLIP:
	case WEAPON_KNIFE_GUT:
	case WEAPON_KNIFE_KARAMBIT:
	case WEAPON_KNIFE_M9_BAYONET:
	case WEAPON_KNIFE_TACTICAL:
	case WEAPON_KNIFE_FALCHION:
	case WEAPON_KNIFE_SURVIVAL_BOWIE:
	case WEAPON_KNIFE_BUTTERFLY:
	case WEAPON_KNIFE_PUSH:
	case WEAPON_KNIFE_URSUS:
	case WEAPON_KNIFE_GYPSY_JACKKNIFE:
	case WEAPON_KNIFE_STILETTO:
	case WEAPON_KNIFE_WIDOWMAKER:
		return "weapon_knife";
	case WEAPON_FLASHBANG: return "weapon_flashbang";
	case WEAPON_HEGRENADE: return "weapon_hegrenade";
	case WEAPON_SMOKEGRENADE: return "weapon_smokegrenade";
	case WEAPON_MOLOTOV: return "weapon_molotov";
	case WEAPON_DECOY: return "weapon_decoy";
	case WEAPON_INCGRENADE: return "weapon_incgrenade";
	case WEAPON_C4: return "weapon_c4";
	case WEAPON_M4A1_SILENCER: return "weapon_m4a1_silencer";
	case WEAPON_USP_SILENCER: return "weapon_usp_silencer";
	case WEAPON_CZ75A: return "weapon_cz75a";
	case WEAPON_REVOLVER: return "weapon_revolver";
	case WEAPON_TAGRENADE: return "weapon_tagrenade";
	case WEAPON_HEALTHSHOT: return "weapon_healthshot";
	case WEAPON_FISTS: return "weapon_fists";
	case WEAPON_BREACHCHARGE: return "weapon_breachcharge";
	case WEAPON_TABLET: return "weapon_tablet";
	//case WEAPON_MELEE: return "weapon_melee";
	case WEAPON_AXE: return "weapon_axe";
	case WEAPON_HAMMER: return "weapon_hammer";
	case WEAPON_SPANNER: return "weapon_spanner";
	case WEAPON_FIREBOMB: return "weapon_firebomb";
	case WEAPON_DIVERSION: return "weapon_diversion";
	case WEAPON_FRAG_GRENADE: return "weapon_frag_grenade";
	default:
		std::cout << "Warning: GetWpnClassName got unexpected ItemDefIndex " << itemDefIndex << '\n';
		return "";
	}
}

inline const char* GetWeaponName(int itemDefIndex)
{
	switch (itemDefIndex)
	{
	case WEAPON_DEAGLE: return "Deagle";
	case WEAPON_ELITE: return "Dual Berettas";
	case WEAPON_FIVESEVEN: return "Five-SeveN";
	case WEAPON_GLOCK: return "Glock-18";
	case WEAPON_AK47: return "AK-47";
	case WEAPON_AUG: return "AUG";
	case WEAPON_AWP: return "AWP";
	case WEAPON_FAMAS: return "FAMAS";
	case WEAPON_G3SG1: return "G3SG1";
	case WEAPON_GALILAR: return "Galil AR";
	case WEAPON_M249: return "M249";
	case WEAPON_M4A1: return "M4A4";
	case WEAPON_MAC10: return "MAC-10";
	case WEAPON_P90: return "P90";
	case WEAPON_MP5SD: return "MP5-SD";
	case WEAPON_UMP45: return "UMP-45";
	case WEAPON_XM1014: return "XM1014";
	case WEAPON_BIZON: return "PP-Bizon";
	case WEAPON_MAG7: return "MAG-7";
	case WEAPON_NEGEV: return "Negev";
	case WEAPON_SAWEDOFF: return "Sawed-off";
	case WEAPON_TEC9: return "Tec-9";
	case WEAPON_TASER: return "Zeus";
	case WEAPON_HKP2000: return "P2000";
	case WEAPON_MP7: return "MP7";
	case WEAPON_MP9: return "MP9";
	case WEAPON_NOVA: return "Nova";
	case WEAPON_P250: return "P250";
	case WEAPON_SCAR20: return "SCAR-20";
	case WEAPON_SG556: return "SG 553";
	case WEAPON_SSG08: return "SSG 08";
	case WEAPON_KNIFE_CT:
	case WEAPON_KNIFE_T:
	case WEAPON_KNIFE_GG:
	case WEAPON_KNIFE_GHOST:
	case WEAPON_KNIFE_BAYONET:
	case WEAPON_KNIFE_FLIP:
	case WEAPON_KNIFE_GUT:
	case WEAPON_KNIFE_KARAMBIT:
	case WEAPON_KNIFE_M9_BAYONET:
	case WEAPON_KNIFE_TACTICAL:
	case WEAPON_KNIFE_FALCHION:
	case WEAPON_KNIFE_SURVIVAL_BOWIE:
	case WEAPON_KNIFE_BUTTERFLY:
	case WEAPON_KNIFE_PUSH:
	case WEAPON_KNIFE_URSUS:
	case WEAPON_KNIFE_GYPSY_JACKKNIFE:
	case WEAPON_KNIFE_STILETTO:
	case WEAPON_KNIFE_WIDOWMAKER:
		return "knife";
	case WEAPON_FLASHBANG: return "flashbang";
	case WEAPON_HEGRENADE:
	case WEAPON_FRAG_GRENADE:
		return "grenade";
	case WEAPON_SMOKEGRENADE: return "smoke";
	case WEAPON_MOLOTOV:
	case WEAPON_INCGRENADE:
	case WEAPON_FIREBOMB:
		return "molotov";
	case WEAPON_DECOY:
	case WEAPON_DIVERSION:
		return "decoy";
	case WEAPON_C4: return "bomb";
	case WEAPON_M4A1_SILENCER: return "M4A1-S";
	case WEAPON_USP_SILENCER: return "USP-S";
	case WEAPON_CZ75A: return "CZ75-A";
	case WEAPON_REVOLVER: return "Revolver";
	case WEAPON_TAGRENADE: return "ta grenade";
	case WEAPON_HEALTHSHOT: return "healthshot";
	case WEAPON_FISTS: return "fists";
	case WEAPON_BREACHCHARGE: return "breach charge";
	case WEAPON_TABLET: return "tablet";
	//case WEAPON_MELEE: return "melee";
	case WEAPON_AXE: return "axe";
	case WEAPON_HAMMER: return "hammer";
	case WEAPON_SPANNER: return "spanner";
	default:
		std::cout << "Warning: GetWpnName got unexpected ItemDefIndex " << itemDefIndex << '\n';
		return "";
	}
}

enum CSWeaponType
{
	WEAPONTYPE_KNIFE = 0,
	WEAPONTYPE_PISTOL,
	WEAPONTYPE_SUBMACHINEGUN,
	WEAPONTYPE_RIFLE,
	WEAPONTYPE_SHOTGUN,
	WEAPONTYPE_SNIPER_RIFLE,
	WEAPONTYPE_MACHINEGUN,
	WEAPONTYPE_C4,
	WEAPONTYPE_GRENADE = 9,
	WEAPONTYPE_STACKABLE = 11,
	WEAPONTYPE_FISTS,
	WEAPONTYPE_BREACHCHARGE,
	WEAPONTYPE_TABLET,
	WEAPONTYPE_MELEE,
	WEAPONTYPE_UNKNOWN
};

inline CSWeaponType GetWeaponType(int itemDefIndex)
{
	switch (itemDefIndex)
	{
	case WEAPON_TASER:
	case WEAPON_KNIFE_GG:
	case WEAPON_KNIFE_CT:
	case WEAPON_KNIFE_T:
	case WEAPON_KNIFE_GHOST:
	case WEAPON_KNIFE_BAYONET:
	case WEAPON_KNIFE_FLIP:
	case WEAPON_KNIFE_GUT:
	case WEAPON_KNIFE_KARAMBIT:
	case WEAPON_KNIFE_M9_BAYONET:
	case WEAPON_KNIFE_TACTICAL:
	case WEAPON_KNIFE_FALCHION:
	case WEAPON_KNIFE_SURVIVAL_BOWIE:
	case WEAPON_KNIFE_BUTTERFLY:
	case WEAPON_KNIFE_PUSH:
	case WEAPON_KNIFE_URSUS:
	case WEAPON_KNIFE_GYPSY_JACKKNIFE:
	case WEAPON_KNIFE_STILETTO:
	case WEAPON_KNIFE_WIDOWMAKER:
		return WEAPONTYPE_KNIFE;
	case WEAPON_DEAGLE:
	case WEAPON_ELITE:
	case WEAPON_FIVESEVEN:
	case WEAPON_GLOCK:
	case WEAPON_TEC9:
	case WEAPON_HKP2000:
	case WEAPON_P250:
	case WEAPON_USP_SILENCER:
	case WEAPON_CZ75A:
	case WEAPON_REVOLVER:
		return WEAPONTYPE_PISTOL;
	case WEAPON_MAC10:
	case WEAPON_P90:
	case WEAPON_MP5SD:
	case WEAPON_UMP45:
	case WEAPON_BIZON:
	case WEAPON_MP7:
	case WEAPON_MP9:
		return WEAPONTYPE_SUBMACHINEGUN;
	case WEAPON_AK47:
	case WEAPON_AUG:
	case WEAPON_FAMAS:
	case WEAPON_GALILAR:
	case WEAPON_M4A1:
	case WEAPON_SG556:
	case WEAPON_M4A1_SILENCER:
		return WEAPONTYPE_RIFLE;
	case WEAPON_XM1014:
	case WEAPON_MAG7:
	case WEAPON_SAWEDOFF:
	case WEAPON_NOVA:
		return WEAPONTYPE_SHOTGUN;
	case WEAPON_AWP:
	case WEAPON_G3SG1:
	case WEAPON_SCAR20:
	case WEAPON_SSG08:
		return WEAPONTYPE_SNIPER_RIFLE;
	case WEAPON_M249:
	case WEAPON_NEGEV:
		return WEAPONTYPE_MACHINEGUN;
	case WEAPON_C4:
		return WEAPONTYPE_C4;
	case WEAPON_FLASHBANG:
	case WEAPON_HEGRENADE:
	case WEAPON_SMOKEGRENADE:
	case WEAPON_MOLOTOV:
	case WEAPON_DECOY:
	case WEAPON_INCGRENADE:
	case WEAPON_TAGRENADE:
	case WEAPON_FIREBOMB:
	case WEAPON_DIVERSION:
	case WEAPON_FRAG_GRENADE:
		return WEAPONTYPE_GRENADE;
	case WEAPON_FISTS:
		return WEAPONTYPE_FISTS;
	case WEAPON_BREACHCHARGE:
		return WEAPONTYPE_BREACHCHARGE;
	case WEAPON_TABLET:
		return WEAPONTYPE_TABLET;
	case WEAPON_AXE:
	case WEAPON_HAMMER:
	case WEAPON_SPANNER:
		return WEAPONTYPE_MELEE;
	default:
		return WEAPONTYPE_UNKNOWN;
	}
}

struct CWeaponScript
{
	float flSpread,
		flSpreadAlt;

	float flInaccuracyMove,
		flInaccuracyMoveAlt;

	float flInaccuracyJumpInitial;

	float flMaxPlayerSpeed,
		flMaxPlayerSpeedAlt;

	void Parse(const char* in, const char* name)
	{
		char prefab[32];
		strcpy_s(prefab, sizeof(prefab), name);
		strcat_s(prefab, sizeof(prefab), "_prefab");

		const char* script = strstr(in, prefab);
		if (!script)
		{
			char err[64] = "Failed to find a script for ";
			strcat_s(err, sizeof(err), name);
			ErrorExit(err);
		}

		GetKeyValue(script, "spread\"", flSpread);
		GetKeyValue(script, "spread alt", flSpreadAlt);
		GetKeyValue(script, "inaccuracy move\"", flInaccuracyMove);
		GetKeyValue(script, "inaccuracy move alt", flInaccuracyMoveAlt);
		GetKeyValue(script, "inaccuracy jump initial", flInaccuracyJumpInitial);
		GetKeyValue(script, "max player speed\"", flMaxPlayerSpeed);
		GetKeyValue(script, "max player speed alt", flMaxPlayerSpeedAlt);
	}
} g_WeaponScript[65];
// we also can read type, weaponid etc..
void ReadWeaponsScript()
{
	char Path[MAX_PATH];
	strcpy_s(Path, sizeof(Path), Mem::GetDir());
	strcat_s(Path, sizeof(Path), "csgo\\scripts\\items\\items_game.txt");

	std::ifstream File(Path, std::ios::ate);
	if (File.fail())
		ErrorExit("Failed to open the weapons script");

	const int len = File.tellg();
	File.seekg(0, File.beg);

	char* Content = new char[len];
	File.read(Content, len);
	File.close();

	for (UINT i = WEAPON_DEAGLE; i < WEAPON_REVOLVER; ++i)
	{
		const CSWeaponType type = GetWeaponType(i);
		if ((WEAPONTYPE_PISTOL <= type) && (type <= WEAPONTYPE_MACHINEGUN))
		{
			const char* className = GetWeaponClassName(i);
			if (!className)
				ErrorExit("Failed to get weapon's classname");

			g_WeaponScript[i].Parse(Content, className);
			g_WeaponScript[i].flSpread *= 0.001f;
			g_WeaponScript[i].flSpreadAlt *= 0.001f;
			g_WeaponScript[i].flInaccuracyMove *= 0.001f;
			g_WeaponScript[i].flInaccuracyMoveAlt *= 0.001f;
			g_WeaponScript[i].flInaccuracyJumpInitial *= 0.001f;
		}
	}

	delete[] Content;
}

class CWeapon
{
public:
	short	m_iItemDefinitionIndex;
	float	m_flNextPrimaryAttack;
	int		m_iClip1;
	bool	m_bInReload;
	int		m_weaponMode;
	float	m_fAccuracyPenalty;
	int		m_zoomLevel;

	inline void SetFromChunk(std::byte* chunk)
	{
		CHUNKTONETVAR(chunk, m_iItemDefinitionIndex);
		CHUNKTONETVAR(chunk, m_flNextPrimaryAttack);
		CHUNKTONETVAR(chunk, m_iClip1);
		CHUNKTONETVAR(chunk, m_bInReload);
		CHUNKTONETVAR(chunk, m_weaponMode);
		CHUNKTONETVAR(chunk, m_fAccuracyPenalty);
		CHUNKTONETVAR(chunk, m_zoomLevel);
	}

	inline bool CanScope() const
	{
		return (m_iItemDefinitionIndex == WEAPON_SG556) ||
			(m_iItemDefinitionIndex == WEAPON_AUG) ||
			(m_iItemDefinitionIndex == WEAPON_SSG08) ||
			(m_iItemDefinitionIndex == WEAPON_AWP) ||
			(m_iItemDefinitionIndex == WEAPON_G3SG1) ||
			(m_iItemDefinitionIndex == WEAPON_SCAR20);
	}

	inline float GetSpread() const
	{
		return m_weaponMode ? g_WeaponScript[m_iItemDefinitionIndex].flSpreadAlt : g_WeaponScript[m_iItemDefinitionIndex].flSpread;
	}

	float GetInaccuracy(const CPlayer& pOwner) const
	{
		float flInaccuracyMove, flMaxPlayerSpeed;
		if (m_weaponMode)
		{
			flInaccuracyMove = g_WeaponScript[m_iItemDefinitionIndex].flInaccuracyMoveAlt;
			flMaxPlayerSpeed = g_WeaponScript[m_iItemDefinitionIndex].flMaxPlayerSpeedAlt;
		}
		else
		{
			flInaccuracyMove = g_WeaponScript[m_iItemDefinitionIndex].flInaccuracyMove;
			flMaxPlayerSpeed = g_WeaponScript[m_iItemDefinitionIndex].flMaxPlayerSpeed;
		}

		float flInaccuracy = m_fAccuracyPenalty;

		//						(flVelocity - (MaxPlayerSpeed * 0.34)) / ((MaxPlayerSpeed * 0.95) - (MaxPlayerSpeed * 0.34))
		const float someScale = (pOwner.m_vecAbsVelocity.Length2D() - (flMaxPlayerSpeed * 0.34f)) / (flMaxPlayerSpeed * 0.61f);
		if (someScale > 0.f)
		{
			if (someScale >= 1.f)
				flInaccuracy += flInaccuracyMove;
			else
				flInaccuracy += flInaccuracyMove * (pOwner.m_bIsWalking ? someScale : sqrt(sqrt(someScale)));
		}

		if (!(pOwner.m_fFlags & FL_ONGROUND))
		{
			//uint32_t dwJumpImpulse;
			//Mem::Read<uint32_t>(Offsets::sv_jump_impulseFloat, dwJumpImpulse);
			//dwJumpImpulse ^= Offsets::sv_jump_impulse;

			const float sqrtVelocityZ = sqrt(abs(pOwner.m_vecAbsVelocity.z));
			const float inaccJumpInitial = g_WeaponScript[m_iItemDefinitionIndex].flInaccuracyJumpInitial/* * HexToFloat(Mem::Read<uint32_t>(Offsets::weapon_air_spread_scaleFloat) ^ Offsets::weapon_air_spread_scale)*/;

			//if (!dwJumpImpulse)
			//{
			//	if (sqrtVelocityZ < 0.f)
			//	{
			//		const float someInaccuracy2x = someInaccuracy * 2.f;
			//		if (0.f > someInaccuracy2x)
			//			flInaccuracy += someInaccuracy2x;
			//	}
			//	else if (someInaccuracy > 0.f)
			//		flInaccuracy += someInaccuracy;
			//}
			//else
			{
				const float sqrtJumpImpulse = 17.37795664052595108787552411148f/*sqrt(HexToFloat(dwJumpImpulse))*/;
				const float sqrtJumpImpulse025 = sqrtJumpImpulse * 0.25f;
				const float someScale2 = ((sqrtVelocityZ - sqrtJumpImpulse025) * inaccJumpInitial) / (sqrtJumpImpulse - sqrtJumpImpulse025);
				if (someScale2 >= 0.f)
				{
					const float inaccJumpInitialx2 = inaccJumpInitial * 2.f;
					flInaccuracy += (someScale2 > inaccJumpInitialx2) ? inaccJumpInitialx2 : someScale2;
				}
			}
		}

		if (flInaccuracy > 1.f)
			return 1.f;
		else
			return flInaccuracy;
	}
	
	bool IsLowFirerate() const
	{
		switch (m_iItemDefinitionIndex)
		{
		case WEAPON_CZ75A:
		case WEAPON_MAC10:
		case WEAPON_P90:
		case WEAPON_MP5SD:
		case WEAPON_UMP45:
		case WEAPON_BIZON:
		case WEAPON_MP7:
		case WEAPON_MP9:
		case WEAPON_AK47:
		case WEAPON_AUG:
		case WEAPON_FAMAS:
		case WEAPON_GALILAR:
		case WEAPON_M4A1:
		case WEAPON_SG556:
		case WEAPON_M4A1_SILENCER:
		case WEAPON_M249:
		case WEAPON_NEGEV:
			return false;
		default:
			return true;
		}
	}

};

inline bool CPlayer::GetWeapon(CWeapon& out) const
{
	if (m_hActiveWeapon == -1)
		return false;

	uintptr_t pWeapon = Mem::Read<uintptr_t>(Signatures::EntityList + ((m_hActiveWeapon & 0xFFF) - 1) * sizeof(CEntInfo));

	std::byte* chunk = new std::byte[NetVars::m_zoomLevel + sizeof(int)];
	ReadProcessMemory(Mem::Process, reinterpret_cast<LPCVOID>(pWeapon), chunk, NetVars::m_zoomLevel + sizeof(int), 0);
	out.SetFromChunk(chunk);
	delete[] chunk;

	return true;
}

```

`src/Common.hpp`:

```hpp
#pragma once

#define M_PI_F			( static_cast<float>(3.1415926535897932384626433832795) )
#define RAD2DEG(rad)	( static_cast<float>(rad) * static_cast<float>(180.f / M_PI_F) )
#define DEG2RAD(deg)	( static_cast<float>(deg) * static_cast<float>(M_PI_F / 180.f) )

//inline void clrHexToFloat(const uint32_t dw, float fl[])
//{
//	fl[0] = ((dw & 0xFF000000) >> 24) / 255.f;
//	fl[1] = ((dw & 0x00FF0000) >> 16) / 255.f;
//	fl[2] = ((dw & 0x0000FF00) >> 8) / 255.f;
//	fl[3] = (dw & 0x000000FF) / 255.f;
//}

extern void ErrorExit(const char* szErr);

inline void GetKeyValue(const char* in, const char* key, int& value)
{
	const char* subs = strstr(in, key) + strlen(key);
	if (subs)
		sscanf_s(subs, "%*[^0-9]%d", &value);
	else
	{
		char err[64] = "Failed to get a key-value ";
		strcat_s(err, sizeof(err), key);
		ErrorExit(err);
	}
}

inline void GetKeyValue(const char* in, const char* key, float& value)
{
	const char* subs = strstr(in, key) + strlen(key);
	if (subs)
		sscanf_s(subs, "%*[^0-9]%f", &value);
	else
	{
		char err[64] = "Failed to get a key-value ";
		strcat_s(err, sizeof(err), key);
		ErrorExit(err);
	}
}

inline float HexToFloat(uint32_t hex)
{
	return *reinterpret_cast<float*>(&hex);
}

inline uint32_t FloatToHex(float fl)
{
	return *reinterpret_cast<uint32_t*>(&fl);
}

struct CUtlVector
{
	uintptr_t m_pMemory; //0x0000 
	int m_nAllocationCount; //0x0004 
	int m_nGrowSize; //0x0008 
	int m_Size; //0x000C 
	uintptr_t m_pElements; //0x0010 
}; //Size=0x0014

BOOL ChangeVolume(float flVolume)
{
	HRESULT hr = NULL;
	IMMDeviceEnumerator* deviceEnumerator = nullptr;
	hr = CoCreateInstance(__uuidof(MMDeviceEnumerator), NULL, CLSCTX_INPROC_SERVER,
		__uuidof(IMMDeviceEnumerator), (LPVOID*)&deviceEnumerator);
	if (FAILED(hr))
		return FALSE;

	IMMDevice* defaultDevice = nullptr;
	hr = deviceEnumerator->GetDefaultAudioEndpoint(eRender, eMultimedia, &defaultDevice);
	deviceEnumerator->Release();
	if (FAILED(hr))
		return FALSE;

	IAudioClient* audioClient = nullptr;
	hr = defaultDevice->Activate(__uuidof(IAudioClient),
		CLSCTX_INPROC_SERVER, NULL, (void**)&audioClient);
	defaultDevice->Release();
	if (FAILED(hr))
		return FALSE;

	WAVEFORMATEX* pwfx = nullptr;
	hr = audioClient->GetMixFormat(&pwfx);
	if (FAILED(hr))
		return FALSE;

	hr = audioClient->Initialize(AUDCLNT_SHAREMODE_SHARED, 0, 0, 0, pwfx, NULL);
	if (FAILED(hr))
		return FALSE;

	ISimpleAudioVolume* audioVolume = nullptr;
	hr = audioClient->GetService(__uuidof(ISimpleAudioVolume), (void**)&audioVolume);
	audioClient->Release();
	if (FAILED(hr))
		return FALSE;

	hr = audioVolume->SetMasterVolume(flVolume, NULL);
	audioVolume->Release();

	return SUCCEEDED(hr);
}

inline bool GetVKeyName(int vkey, char* buffer, int buffersize)
{
	switch (vkey)
	{
	case VK_LBUTTON:
		strcpy_s(buffer, buffersize, "Left mouse button");
		return true;
	case VK_RBUTTON:
		strcpy_s(buffer, buffersize, "Right mouse button");
		return true;
	case VK_MBUTTON:
		strcpy_s(buffer, buffersize, "Middle mouse button");
		return true;
	case VK_XBUTTON1:
		strcpy_s(buffer, buffersize, "Forth mouse button");
		return true;
	case VK_XBUTTON2:
		strcpy_s(buffer, buffersize, "Fifth mouse button");
		return true;
	}

	UINT vsc = MapVirtualKey(vkey, MAPVK_VK_TO_VSC);
	if (!vsc)
	{
		std::cout << "Warning: MapVirtualKey returned 0\n";
		return false;
	}

	int res = GetKeyNameText((vsc << 16), buffer, buffersize);
	if (!res)
	{
		std::cout << "Warning: GetKeyNameText returned 0\n";
		return false;
	}

	return true;
}

#define CHUNKTONETVAR(chunk, var) var = *reinterpret_cast<decltype(var)*>(reinterpret_cast<uintptr_t>(chunk) + NetVars::var)
```

`src/Config.hpp`:

```hpp
#pragma once

bool g_bChangingUserCmd = false;

namespace Config
{
	const char* const configNames[] = {
		"legit",
		"rage",
		"custom"
	};

	UINT	curConfig;

	namespace Aimbot
	{
		bool	Enable;
		int		Key;
		bool	TeamCheck;
		bool	AutoFire;
		namespace Hitscan
		{
			bool	Enable;
			int		Priority;
			bool	Head;
			bool	Body;
			bool	Shoulders;
			bool	Legs;
			bool	Toes;
		}
		bool	PseudoAwall;
		//bool	ResolveByLBY;

		namespace Rage
		{
			bool	Enable;
			bool	AutoScope;
			bool	BodyAWP;

			namespace HitChance
			{
				bool	Enable;
				int		Percentages[8];
			}
		}

		struct CWpnCfg
		{
			int		PriorityBone;
			bool	FovDistBased;
			float	FOV;
			float	Speed;
			bool	IgnoreInAir;
			bool	CheckIfFlashed;
			bool	Silent;
		} WpnCfgs[8];
	}

	namespace RCS
	{
		bool	Enable;
		bool	AlwaysOn;
		int		Vertical;
		int		Horizontal;
	}

	namespace Triggerbot
	{
		bool	Enable;
		int		Key;
		bool	CheckIfFlashed;
	}

	bool	AutoPistol;
	namespace Backtrack
	{
		bool	Enable;
		int		Max;
	}

	bool	VisualsTeamCheck;
	namespace GlowESP
	{
		bool	Players;
		int		Style;
		bool	PatchFlicker;
		float	Color[4];
		bool	HealthBased;
		float	Color0hp[4];
		float	Color100hp[4];
		bool	ShowVunerable;
		float	ColorVunerable[4];
		bool	DroppedC4;
		bool	Grenades;
	}

	namespace clrRender
	{
		bool	Enable;
		uint32_t Color;
	}

	bool	Radar;
	int		VisualsSleep;

	namespace AutoJump
	{
		bool	Enable;
		bool	Legit;
	}

	namespace FakeLag
	{
		bool	Enabled;
		int		ToggleKey;
		int		TicksLag;
		int		TicksPass;
		bool	DisableWhenShoot;
		bool	OnlyInAir;
	}

	namespace Hitsound
	{
		bool	Enable;
		int		Style;
		float	Volume;
	}

	namespace Nightmode
	{
		bool	Enable;
		float	Lightscale;
	}

	char	Skyname[48];
	bool	EnableName;
	bool	AutoAccept;
	bool	RevealRanks;
	bool	NoPostProcess;
	bool	NoSmoke;
	bool	NoScope;
	int		NoRecoil;
	float	MaxFlashEffect;
	int		ViewmodelFov;
	int		ViewFov;
	int		LoadNextConfigKey;
	int		InsultKey;
	int		BotMountKey;

	void ReadColorFloat(std::ifstream &File, float out[4])
	{
		File.ignore(80, '[');
		File >> out[0]; File.ignore();
		File >> out[1]; File.ignore();
		File >> out[2]; File.ignore();
		File >> out[3];
		for (UINT i = 0; i < 4; ++i)
			out[i] /= 255.f;
	}

	void ReadColorHex(std::ifstream &File, uint32_t &out)
	{
		File.ignore(80, '[');
		int rgb[3];
		File >> rgb[0]; File.ignore();
		File >> rgb[1]; File.ignore();
		File >> rgb[2];
		out = (rgb[0]) |
			(rgb[1] << 8) |
			(rgb[2] << 16) |
			(0xFF << 24);
	}

	void Read(const unsigned int id)
	{
		std::ifstream File;
		switch (id)
		{
		case 1:
			File.open("legit.txt");
			break;
		case 2:
			File.open("rage.txt");
			break;
		case 3:
			File.open("custom.txt");
			break;
		}

		if (File.fail())
			ErrorExit("Failed to open the config");

#define ReadNextSetting(s) File.ignore(80, '='); File >> s

		ReadNextSetting(Aimbot::Enable);
		ReadNextSetting(Aimbot::Key);
		ReadNextSetting(Aimbot::TeamCheck);
		ReadNextSetting(Aimbot::AutoFire);
		ReadNextSetting(Aimbot::Hitscan::Enable);
		ReadNextSetting(Aimbot::Hitscan::Priority);
		ReadNextSetting(Aimbot::Hitscan::Head);
		ReadNextSetting(Aimbot::Hitscan::Body);
		ReadNextSetting(Aimbot::Hitscan::Shoulders);
		ReadNextSetting(Aimbot::Hitscan::Legs);
		ReadNextSetting(Aimbot::Hitscan::Toes);
		ReadNextSetting(Aimbot::PseudoAwall);
		//ReadNextSetting(Aimbot::ResolveByLBY);

		Aimbot::WpnCfgs[0].FovDistBased = false;
		Aimbot::WpnCfgs[0].Speed = 1.f;
		Aimbot::WpnCfgs[0].IgnoreInAir = false;
		Aimbot::WpnCfgs[0].CheckIfFlashed = false;
		ReadNextSetting(Aimbot::Rage::Enable);
		ReadNextSetting(Aimbot::WpnCfgs[0].PriorityBone);
		ReadNextSetting(Aimbot::WpnCfgs[0].FOV);
		ReadNextSetting(Aimbot::Rage::AutoScope);
		ReadNextSetting(Aimbot::Rage::BodyAWP);
		ReadNextSetting(Aimbot::WpnCfgs[0].Silent);
		ReadNextSetting(Aimbot::Rage::HitChance::Enable);
		for (UINT i = 0; i < 8; ++i)
		{
			ReadNextSetting(Aimbot::Rage::HitChance::Percentages[i]);
		}

		for (UINT i = 1; i < 8; ++i)
		{
			ReadNextSetting(Aimbot::WpnCfgs[i].PriorityBone);
			ReadNextSetting(Aimbot::WpnCfgs[i].FovDistBased);
			ReadNextSetting(Aimbot::WpnCfgs[i].FOV);
			ReadNextSetting(Aimbot::WpnCfgs[i].Speed);
			ReadNextSetting(Aimbot::WpnCfgs[i].IgnoreInAir);
			ReadNextSetting(Aimbot::WpnCfgs[i].CheckIfFlashed);
			ReadNextSetting(Aimbot::WpnCfgs[i].Silent);
		}

		ReadNextSetting(RCS::Enable);
		ReadNextSetting(RCS::AlwaysOn);
		ReadNextSetting(RCS::Vertical);
		ReadNextSetting(RCS::Horizontal);

		ReadNextSetting(Triggerbot::Enable);
		ReadNextSetting(Triggerbot::Key);
		ReadNextSetting(Triggerbot::CheckIfFlashed);

		ReadNextSetting(AutoPistol);
		ReadNextSetting(Backtrack::Enable);
		ReadNextSetting(Backtrack::Max);
		if (Backtrack::Max > 12) Backtrack::Max = 12;

		ReadNextSetting(VisualsTeamCheck);
		ReadNextSetting(GlowESP::Players);
		ReadNextSetting(GlowESP::Style);
		ReadNextSetting(GlowESP::PatchFlicker);
		ReadColorFloat(File, GlowESP::Color);
		ReadNextSetting(GlowESP::HealthBased);
		ReadColorFloat(File, GlowESP::Color0hp);
		ReadColorFloat(File, GlowESP::Color100hp);
		ReadNextSetting(GlowESP::ShowVunerable);
		ReadColorFloat(File, GlowESP::ColorVunerable);
		ReadNextSetting(GlowESP::DroppedC4);
		ReadNextSetting(GlowESP::Grenades);

		ReadNextSetting(clrRender::Enable);
		ReadColorHex(File, clrRender::Color);

		ReadNextSetting(Radar);
		ReadNextSetting(VisualsSleep);
		if (VisualsSleep < 1) VisualsSleep = 1;

		ReadNextSetting(AutoJump::Enable);
		ReadNextSetting(AutoJump::Legit);

		ReadNextSetting(FakeLag::Enabled);
		ReadNextSetting(FakeLag::ToggleKey);
		ReadNextSetting(FakeLag::TicksLag);
		ReadNextSetting(FakeLag::TicksPass);
		ReadNextSetting(FakeLag::DisableWhenShoot);
		ReadNextSetting(FakeLag::OnlyInAir);

		ReadNextSetting(Hitsound::Enable);
		ReadNextSetting(Hitsound::Style);
		ReadNextSetting(Hitsound::Volume);
		Hitsound::Volume *= 0.01f;

		ReadNextSetting(Nightmode::Enable);
		ReadNextSetting(Nightmode::Lightscale);
		File.ignore(80, '\"'); File.getline(Skyname, sizeof(Skyname), '\"');

		ReadNextSetting(EnableName);
		ReadNextSetting(AutoAccept);
		ReadNextSetting(RevealRanks);
		ReadNextSetting(NoPostProcess);
		ReadNextSetting(NoSmoke);
		ReadNextSetting(NoScope);
		ReadNextSetting(NoRecoil);
		ReadNextSetting(MaxFlashEffect);
		MaxFlashEffect *= 2.55f;
		ReadNextSetting(ViewmodelFov);
		ReadNextSetting(ViewFov);
		ReadNextSetting(LoadNextConfigKey);
		ReadNextSetting(InsultKey);
		ReadNextSetting(BotMountKey);

#undef ReadNextSetting
		// Prev. features: TriggerbotType, C4 Timer, CalloutsEnable, CalloutEnemies
		File.close();
	}

	void Apply()
	{
		Mem::Write<int>(Signatures::nameChangeCallbacks + offsetof(CUtlVector, m_Size), (EnableName ? 0 : 1));
		Mem::Write<bool>(Signatures::s_bOverridePostProcessing, NoPostProcess);
		Mem::Write<uint32_t>(Signatures::weapon_recoil_view_punch_extraFloat, (NoRecoil > 0 ? Signatures::weapon_recoil_view_punch_extra : (Signatures::weapon_recoil_view_punch_extra ^ FloatToHex(0.055f))));
#ifdef NDEBUG
		Mem::Write<uint32_t>(Signatures::weapon_recoil_scaleFloat, (NoRecoil > 1 ? Signatures::weapon_recoil_scale : (Signatures::weapon_recoil_scale ^ FloatToHex(2.f))));
#endif
		if (ViewmodelFov)
			Mem::Write<uint32_t>(Signatures::viewmodel_fovFloat, (Signatures::viewmodel_fov ^ FloatToHex(ViewmodelFov)));
		if (!GlowESP::Players || !GlowESP::PatchFlicker)
			Mem::Write<int>(Signatures::Spec_Show_Xray_Callback, 1);
		Mem::Write<uint32_t>(Signatures::mat_force_tonemap_scaleFloat, (Nightmode::Enable ? (Signatures::mat_force_tonemap_scale ^ FloatToHex(Config::Nightmode::Lightscale)) : (Signatures::mat_force_tonemap_scale ^ FloatToHex(1.f))));

		bool bUsingSilent = false;
		for (UINT i = 0; i < 8; ++i)
		{
			if (Aimbot::WpnCfgs[i].Silent && ((i != 0) || Config::Aimbot::Rage::Enable))
			{
				bUsingSilent = true;
				break;	
			}
		}
		g_bChangingUserCmd = (Aimbot::Enable && bUsingSilent) || Backtrack::Enable;
		ClientCmd_Unrestricted(g_bChangingUserCmd ? "unbind mouse1" : "bind mouse1 +attack");

		if (Hitsound::Enable && !ChangeVolume(Hitsound::Volume))
			std::cout << "Warning: Failed to set hitsound volume.\n";
	}

	void PrintHotkeys()
	{
		struct CHotkey
		{
			int code;
			const char* desc;
		};

		CHotkey hotkeys[] = {
			{ Config::Aimbot::Key,			"aimbot" },
			{ Config::Triggerbot::Key,		"triggerbot" },
			{ Config::FakeLag::ToggleKey,	"toggle fakelag" },
			{ Config::LoadNextConfigKey,	"load next config" },
	#ifndef NCURL
			{ Config::InsultKey,			"send the insult to global chat" },
	#endif // !NCURL
			{ Config::BotMountKey,			"mount a bot" },
		};

		std::cout << "Hotkeys:\n";

		char keyName[24];
		for (UINT i = 0; i < _countof(hotkeys); ++i)
		{
			if (hotkeys[i].code)
			{
				if (GetVKeyName(hotkeys[i].code, keyName, sizeof(keyName)))
					std::cout << keyName << " - " << hotkeys[i].desc << '\n';
			}
			else
				std::cout << "Unbound - " << hotkeys[i].desc << '\n';
		}

		std::cout << "\n";
	}

	void ReadNext()
	{
		curConfig = (curConfig == 3) ? 1 : (curConfig + 1);
		Read(curConfig);
		Apply();

		std::cout << "Loading " << configNames[curConfig - 1] << " config\n\n";
		PrintHotkeys();

		for (UINT i = 0; i < curConfig; ++i)
			std::cout << '\a';
	}

	int GetWpnHitchance(int itemDefIndex, CSWeaponType weaponType)
	{
		if (itemDefIndex == WEAPON_SSG08)
			return Aimbot::Rage::HitChance::Percentages[6];
		else if (itemDefIndex == WEAPON_AWP)
			return Aimbot::Rage::HitChance::Percentages[7];
		else
			return Aimbot::Rage::HitChance::Percentages[weaponType - 1];
	}

	Aimbot::CWpnCfg* GetWeaponCfg(int itemDefIndex, CSWeaponType weaponType)
	{
		if (Aimbot::Rage::Enable)
			return &Aimbot::WpnCfgs[0];

		if (itemDefIndex == WEAPON_SSG08)
			return &Aimbot::WpnCfgs[6];
		else if (itemDefIndex == WEAPON_AWP)
			return &Aimbot::WpnCfgs[7];
		else
		{
			if (WEAPONTYPE_PISTOL <= weaponType && weaponType <= WEAPONTYPE_SNIPER_RIFLE)
				return &Aimbot::WpnCfgs[weaponType];
			else if (weaponType == WEAPONTYPE_MACHINEGUN)
				return &Aimbot::WpnCfgs[3];
			else
				return nullptr;
		}
	}
}
```

`src/Features.hpp`:

```hpp
#pragma once

bool g_bInGame = false;
bool g_bDangerZone = false;
uintptr_t g_NetChannel;
float g_IntervalPerTick = (1.f / 64.f);

inline void SleepTicks(float ticks)
{
	std::this_thread::sleep_for(std::chrono::milliseconds(static_cast<int>(g_IntervalPerTick * 1000.f * ticks)));
}

inline bool IsMouseActive()
{
	return (Mem::Read<uint32_t>(Signatures::cl_mouseenableInt) ^ Signatures::cl_mouseenable) && !Mem::Read<bool>(Signatures::bOverlayActivated) && Mem::Read<bool>(Signatures::m_fMouseActive);
}

namespace ModelIndexes
{
	short Flashbang;
	short Smoke;
	short Grenade;
	short Molotov;
	short Incendiary;
	short C4;

	void Init()
	{
		Flashbang = GetModelIndex("models/weapons/w_eq_flashbang_dropped.mdl");
		Smoke = GetModelIndex("models/weapons/w_eq_smokegrenade_thrown.mdl");
		Grenade = GetModelIndex("models/weapons/w_eq_fraggrenade_dropped.mdl");
		Molotov = GetModelIndex("models/weapons/w_eq_molotov_dropped.mdl");
		Incendiary = GetModelIndex("models/weapons/w_eq_incendiarygrenade_dropped.mdl");
		C4 = GetModelIndex("models/weapons/w_ied_dropped.mdl");
	}
}

namespace Features
{
	// Credits: nuggah
	void ChangeUserCmd(vec2* viewangles, int buttons, int tick_count)
	{
#ifdef NDEBUG
		Mem::Write<double>(Signatures::m_flNextCmdTime, DBL_MAX);
#else
		Mem::Write<bool>(Signatures::bSendPacket, false);
#endif // NDEBUG
		const int iDesiredCmdNum = Mem::Read<int>(Signatures::m_nLastOutgoingCommand) + 2;
		uintptr_t pCommands;
		Mem::Read<uintptr_t>(Signatures::m_pCommands, pCommands);
		const uintptr_t pOldCmd = pCommands + ((iDesiredCmdNum - 1) % 150) * sizeof(CUserCmd);
		const uintptr_t pOldVerifiedCmd = Mem::Read<uintptr_t>(Signatures::m_pVerifiedCommands) + ((iDesiredCmdNum - 1) % 150) * sizeof(CVerifiedUserCmd);

		while (Mem::Read<int>(g_NetChannel + Signatures::m_nOutSequenceNr) < iDesiredCmdNum)
			std::this_thread::yield();

		CUserCmd OldCmd;
		Mem::Read<CUserCmd>(pOldCmd, OldCmd);
		if (viewangles)
		{
			ClampAngle(&viewangles->x);
			OldCmd.viewangles.x = viewangles->x;
			OldCmd.viewangles.y = viewangles->y;
		}
		if (buttons) OldCmd.buttons |= buttons;
		if (tick_count) OldCmd.tick_count = tick_count;
		Mem::Write<CUserCmd>(pOldCmd, OldCmd);
		Mem::Write<CUserCmd>(pOldVerifiedCmd, OldCmd);
#ifdef NDEBUG
		Mem::Write<double>(Signatures::m_flNextCmdTime, 0.0);
#else
		Mem::Write<bool>(Signatures::bSendPacket, true);
#endif // NDEBUG
	}
}
```

`src/Main.cpp`:

```cpp
#include "stdafx.h"

#include "Common.hpp"
#include "Vector.hpp"
#ifndef NCURL
#include <curl/curl.h>
#endif // !NCURL
#include "Memory.hpp"
#include "SDK/Random.hpp"
#include "SDK/checksum_md5.hpp"
#include "SDK/UserCmd.hpp"
#include "SDK/Client.hpp"
#include "Signatures.hpp"
#include "NetVars.hpp"
#include "CPlayer.hpp"
#include "CWeapon.hpp"
#include "Shellcodes.hpp"
#include "Config.hpp"
#include "SDK/BSP.hpp"
#include "SDK/Studio.hpp"

#include "Features.hpp"
#include "Aim.hpp"
#include "Visuals.hpp"
#include "Misc.hpp"

void ErrorExit(const char* szErr)
{
	std::cerr << "Error: " << szErr;
	MessageBeep(MB_ICONERROR);
	Mem::Detach();
	std::cin.ignore(2);
	exit(EXIT_FAILURE);
}

BOOL WINAPI HandlerRoutine(DWORD dwCtrlType)
{
	if (dwCtrlType == CTRL_CLOSE_EVENT)
	{
		Mem::Detach();
#ifndef NDEBUG
		if (Config::FakeLag::Enabled)
			Mem::Write<bool>(Signatures::bSendPacket, true);
#endif
	}
	return FALSE;
}

int main()
{
	std::cout << "csgo heck by hirus (" << __DATE__ << " build)" << "\n1. Legit\n2. Rage\n3. Custom\nEnter config index: ";

	do std::cin >> Config::curConfig; while (1 > Config::curConfig || Config::curConfig > 3);

	std::cout << '\n' << std::left << std::setw(23) << std::setfill('.') << "Reading config";
	Config::Read(Config::curConfig);
	std::cout << std::setw(28) << "done\nAttaching";
	Mem::Attach();
	std::cout << std::setw(28) << "done\nReading items script";
	ReadWeaponsScript();
	std::cout << std::setw(28) << "done\nFinding offsets";
	Signatures::Find();
	std::cout << std::setw(28) << "done\nFinding netvars";
	NetVars::Find();
	std::cout << std::setw(28) << "done\nApplying config";

	if (!SetConsoleCtrlHandler(HandlerRoutine, TRUE))
		std::clog << "Warning: SetConsoleCtrlHandler failed.\n";

	if (CoInitializeEx(NULL, COINIT_MULTITHREADED) != S_OK)
		std::clog << "Warning: CoInitializeEx could have failed.\n";

	Config::Apply();
	std::cout << "done\n\n";
	Config::PrintHotkeys();

#ifndef NCURL
	curl_global_init(CURL_GLOBAL_DEFAULT);
#endif // !NCURL

	std::thread (Features::Aim).detach();
	std::thread (Features::AutoJump).detach();
	std::thread (Features::FakeLag).detach();
	std::thread (Features::Visuals).detach();
	std::thread (Features::Misc).detach();

	while (Mem::IsProcessRunning())
	{
		int SignonState;
		Mem::Read<int>(Signatures::m_nSignonState, SignonState);

		if (SignonState == 6)
		{
			if (Config::clrRender::Enable && g_bInGame && Config::VisualsTeamCheck)
			{
				for (UINT i = 0; i < g_PlayersCount; ++i)
				{
					if (g_LocalPlayer.m_iTeamNum == g_Players[i].m_iTeamNum)
					{
						if (g_Players[i].m_clrRender != 0xFFFFFFFF)
							Mem::Write<int>(Signatures::m_nDeltaTick, -1);
						break;
					}
				}
			}

			CEntInfo EntInfoList[64];
			ReadProcessMemory(Mem::Process, reinterpret_cast<LPCVOID>(Signatures::EntityList), EntInfoList, sizeof(EntInfoList) - 12, 0);

			int PlayerSlot;
			Mem::Read<int>(Signatures::m_nPlayerSlot, PlayerSlot);
			g_LocalPlayer.Update(EntInfoList[PlayerSlot].m_pEntity);
			EntInfoList[PlayerSlot].m_pEntity = 0; // don't add LocalPlayer to g_Players

			g_PlayersCount = 0;

			for (UINT i = 0; i < 64; ++i)
			{
				if (EntInfoList[i].m_pEntity)
				{
					g_Players[g_PlayersCount].Update(EntInfoList[i].m_pEntity);
					++g_PlayersCount;
				}
			}

			if (g_LocalPlayer.m_iTeamNum != 0)
				g_bInGame = true;
		}
		else
			g_bInGame = false;

		SleepTicks(0.5f);
	}

	g_bInGame = false;
	Mem::Detach();
	return 0;
}
```

`src/Memory.hpp`:

```hpp
#pragma once

extern const size_t g_AllocSize;

struct CURLCallback
{
	char*	data;
	size_t	size;

	CURLCallback()
	{
		data = (char*)malloc(1);
		size = 0;
	}

	~CURLCallback()
	{
		free(data);
	}

	CURLCallback(const CURLCallback&) = delete;
};

size_t CURLWriteCallback(void* contents, size_t size, size_t nmemb, void* userp)
{
	CURLCallback* mem = (CURLCallback*)userp;
	mem->data = (char*)realloc(mem->data, mem->size + nmemb + 1);
	if (mem->data == nullptr)
	{
		std::cerr << "Error: Not enough memory (realloc returned NULL)\n";
		return 0;
	}

	memcpy(&(mem->data[mem->size]), contents, nmemb);
	mem->size += nmemb;
	mem->data[mem->size] = '\0';

	return nmemb;
}

namespace Mem
{
	DWORD	PID;
	HANDLE	Process;
	LPVOID	Alloc = 0;
	char	Dir[MAX_PATH] = { 0 };

	struct CModCache
	{
		MODULEENTRY32	Entry;
		uint8_t*		Content;
	};
	std::vector<CModCache> ModulesCache;

	void Attach()
	{
		HWND hwnd = FindWindowA("Valve001", 0);

		while (!hwnd)
		{
			std::this_thread::sleep_for(30s);
			hwnd = FindWindowA("Valve001", 0);
		}

		GetWindowThreadProcessId(hwnd, &PID);
		Process = OpenProcess((PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE), FALSE, PID);
		if (!Process)
			ErrorExit("Failed to open a process");
	}

	void Detach()
	{
		CoUninitialize();
#ifndef NCURL
		curl_global_cleanup();
#endif // !NCURL
		VirtualFreeEx(Process, Alloc, 0, MEM_RELEASE);
		CloseHandle(Process);
	}

	MODULEENTRY32* GetModuleEntry(const char* szMod)
	{
		for (size_t i = 0; i < ModulesCache.size(); ++i)
		{
			if (!strcmp(ModulesCache[i].Entry.szModule, szMod))
				return &ModulesCache[i].Entry;
		}

		MODULEENTRY32 ModuleEntry;
		ModuleEntry.dwSize = sizeof(ModuleEntry);

		HANDLE Snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, PID);
		if (Snapshot == INVALID_HANDLE_VALUE)
			ErrorExit("Invalid module snapshot");

		if (!Module32First(Snapshot, &ModuleEntry))
		{
			CloseHandle(Snapshot);
			ErrorExit("Failed to get first module");
		}

		do {
			if (!strcmp(ModuleEntry.szModule, szMod))
			{
				CloseHandle(Snapshot);
				ModulesCache.push_back({ ModuleEntry, nullptr });
				return &ModulesCache.back().Entry;
			}
		} while (Module32Next(Snapshot, &ModuleEntry));

		CloseHandle(Snapshot);
		ErrorExit("Failed to get a module");
	}

	inline bool IsProcessRunning()
	{
		DWORD ExitCode;
		if (!GetExitCodeProcess(Process, &ExitCode))
		{
			std::clog << "Warning: GetExitCodeProcess failed.\n";
			return true;
		}

		return (ExitCode == STILL_ACTIVE);
	}

	template <typename T>
	inline void Read(uintptr_t address, T &buffer)
	{
		ReadProcessMemory(Process, reinterpret_cast<LPCVOID>(address), &buffer, sizeof(T), 0);
	}

	template <typename T>
	inline T Read(uintptr_t address)
	{
		T buffer;
		ReadProcessMemory(Process, reinterpret_cast<LPCVOID>(address), &buffer, sizeof(T), 0);
		return buffer;
	}

	template <typename T>
	inline void Write(uintptr_t address, const T &value)
	{
		WriteProcessMemory(Process, reinterpret_cast<LPVOID>(address), &value, sizeof(T), 0);
	}

	const char* GetDir()
	{
		if (!Dir[0])
		{
			DWORD dwDirSize = sizeof(Dir);
			if (QueryFullProcessImageName(Process, 0, Dir, &dwDirSize) == 0)
				ErrorExit("Failed to get the game's dir");
			// don't remove trailing slash
			*(strrchr(Dir, '\\') + 1) = '\0';
		}
		return Dir;
	}

	inline LPVOID GetAlloc()
	{
		if (!Alloc)
		{
			Alloc = VirtualAllocEx(Process, 0, g_AllocSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
			if (!Alloc)
				std::clog << "Warning: VirtualAllocEx failed.\n";
		}
		return Alloc;
	}

	inline void CreateThread(uintptr_t address, LPVOID parameter = 0)
	{
		HANDLE hThread = CreateRemoteThread(Process, 0, 0, reinterpret_cast<LPTHREAD_START_ROUTINE>(address), parameter, 0, 0);
		if (!hThread)
		{
			std::clog << "Warning: CreateRemoteThread failed.\n";
			return;
		}
		WaitForSingleObject(hThread, 5000);
		CloseHandle(hThread);
	}

	inline DWORD CreateThreadReturn(uintptr_t address, LPVOID parameter = 0)
	{
		HANDLE hThread = CreateRemoteThread(Process, 0, 0, reinterpret_cast<LPTHREAD_START_ROUTINE>(address), parameter, 0, 0);
		if (!hThread)
		{
			std::clog << "Warning: CreateRemoteThread failed.\n";
			return 0;
		}
		WaitForSingleObject(hThread, 5000);
		DWORD ret = 0;
		GetExitCodeThread(hThread, &ret);
		CloseHandle(hThread);
		return ret;
	}

	// Credits: Forza
	void FindLongestArray(const char* Signature, const char* Mask, int Out[2])
	{
		int startIndex = 0,
			endIndex = strlen(Signature),
			maskLen = strlen(Mask);

		for (int i = endIndex; i < maskLen; ++i)
		{
			if (Mask[i] != 'x')
				continue;

			int count = 0;
			for (int j = i; j < maskLen && Mask[j] == 'x'; ++j)
				++count;

			if (count > endIndex)
			{
				startIndex = i;
				endIndex = count;
			}

			i += (count - 1);
		}

		Out[0] = startIndex;
		Out[1] = endIndex;
	}

	uintptr_t FindSignature(const char* Module, const char* Signature, const char* Mask, const ptrdiff_t Offset = 0)
	{
		CModCache* Cache = nullptr;
		for (size_t i = 0; i < ModulesCache.size(); ++i)
		{
			if (!strcmp(ModulesCache[i].Entry.szModule, Module))
				Cache = &ModulesCache[i];
		}

		if (!Cache)
		{
			GetModuleEntry(Module);
			Cache = &ModulesCache.back();
		}

		if (!Cache->Content)
		{
			Cache->Content = new uint8_t[Cache->Entry.modBaseSize];
			ReadProcessMemory(Process, Cache->Entry.modBaseAddr, Cache->Content, Cache->Entry.modBaseSize, 0);
		}

		int d[2] = { 0 };
		FindLongestArray(Signature, Mask, d);

		const uint8_t len = (uint8_t)strlen(Mask),
			mbeg	= (uint8_t)d[0],
			mlen	= (uint8_t)d[1],
			mfirst	= (uint8_t)Signature[mbeg];

		bool arrInSig[UCHAR_MAX + 1] = { false };

		for (auto i = mbeg; i < mbeg + mlen; ++i)
			arrInSig[(uint8_t)Signature[i]] = true;

		for (int i = Cache->Entry.modBaseSize - len; i >= 0; --i)
		{
			const uint8_t cur = Cache->Content[i];
			bool bInSig = arrInSig[cur];
			bool bSkipped = false;

			while (!bInSig && i > mlen)
			{
				i -= mlen;
				bInSig = arrInSig[Cache->Content[i]];
				bSkipped = true;
			}

			if (bSkipped)
			{
				++i;
				continue;
			}

			if (cur != mfirst)
				continue;

			if ((i - mbeg < 0) || (i - mbeg + len > Cache->Entry.modBaseSize))
				ErrorExit("Failed to find a signature");

			for (int j = 0; j < len; ++j)
			{
				if (j == mbeg || Mask[j] != 'x')
					continue;

				if (Cache->Content[i - mbeg + j] != (uint8_t)Signature[j])
					break;

				if (j + 1 == len)
					return Offset ? *(uintptr_t*)(Cache->Content + i - mbeg + Offset) : (uintptr_t)Cache->Entry.modBaseAddr + i - mbeg;
			}
		}

		ErrorExit("Failed to find a signature");
	}

	void UnallocContentCache()
	{
		for (size_t i = 0; i < ModulesCache.size(); ++i)
			delete[] ModulesCache[i].Content;
	}
}
```

`src/Misc.hpp`:

```hpp
#pragma once

namespace Features
{
	void AutoAccept()
	{
		static bool bFound = false;
		static bool bAccepted = false;
		static uintptr_t prevCallback = 0;
		uintptr_t Callback;
		Mem::Read<uintptr_t>(Signatures::ConfirmedReservationCallback, Callback);
		if (Callback)
		{
			if (prevCallback != Callback)
			{
				prevCallback = Callback;
				bFound = false;
				bAccepted = false;
			}

			if (!bFound)
			{
				bFound = true;
				std::this_thread::sleep_for(5s);
			}
			else if (!bAccepted)
			{
				bAccepted = true;
				Mem::CreateThread(Signatures::Callback__IsReady);
				std::cout << "Tried to accept the match\n";
			}
		}
		else
		{
			bFound = false;
			bAccepted = false;
		}
	}

#ifndef NCURL
	void SayInsult()
	{
		CURL* curl;
		CURLcode code;
		CURLCallback data;
		curl = curl_easy_init();
		if (curl)
		{
			curl_easy_setopt(curl, CURLOPT_URL, "https://www.rappad.co/api/battles/random_insult");
			curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 1L);
			curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 2L);
			curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, &CURLWriteCallback);
			curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)&data);
			curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);

			code = curl_easy_perform(curl);
			if (code == CURLE_OK)
			{
				// {"insult":"YOU SHOULDN'T PLAY HIDE AND SEEK, NO ONE WOULD LOOK FOR YOU.","email":"amir@rappad.co"}
				// {"insult":"YO MAMA IS SO STUPID THAT SHE SHOVED A AA BATTERY UP HER BUTT AND SAID \"I GOT THE POWER!\"","email":"amir@rappad.co"} -- SANITIZE
				char* Command = &data.data[6];
				Command[0] = 's';
				Command[1] = 'a';
				Command[2] = 'y';
				Command[3] = ' ';

				if (data.data[data.size - 28] == '.')
				{
					data.data[data.size - 28] = '\"';
					data.data[data.size - 27] = '\0';
				}
				else
					data.data[data.size - 26] = '\0';

				while (char* ss = strstr(Command, "\\\""))
					ss[1] = '\'';

				for (char* c = &Command[5]; *c != '\"'; ++c)
					*c = tolower(*c);

				ClientCmd_Unrestricted(Command);
			}
#ifndef NDEBUG
			else
				std::cout << "curl_easy_perform failed: " << curl_easy_strerror(code) << std::endl;
#endif // NDEBUG
			curl_easy_cleanup(curl);
		}
	}
#endif // !NCURL

	void BotMount()
	{
		static int target = -1;
		vec3 bestPosDelta;
		float bestDist = FLT_MAX;

		if (target != -1)
		{
			bestPosDelta = g_Players[target].m_vecOrigin - g_LocalPlayer.m_vecOrigin;
			bestDist = bestPosDelta.Length2D();
		}
		
		if (32.f < bestDist)
		{
			target = -1;
			bestDist = 32.f;

			for (UINT i = 0; i < g_PlayersCount; ++i)
			{
				vec3 posDelta = g_Players[i].m_vecOrigin - g_LocalPlayer.m_vecOrigin;
				float dist = posDelta.Length2D();
				if (dist < bestDist)
				{
					bestPosDelta = posDelta;
					bestDist = dist;
					target = i;
				}
			}
		}

		Mem::Write<int8_t>(Signatures::Forward, 4);
		Mem::Write<int8_t>(Signatures::Back, 4);
		Mem::Write<int8_t>(Signatures::Right, 4);
		Mem::Write<int8_t>(Signatures::Left, 4);

		if (target != -1 && 15.f < bestDist)
		{
			vec3 curAngle;
			Mem::Read<vec3>(Signatures::m_vecViewAngles, curAngle);

			vec3 aimAngle(curAngle.x, RAD2DEG(atan2(bestPosDelta.y, bestPosDelta.x)), curAngle.z);
			ClampAngle(&aimAngle.x);

			vec2 svFwd, svRgh;
			AngleVectors(curAngle, &svFwd, &svRgh, nullptr);

			VectorNormalize(svFwd);
			VectorNormalize(svRgh);


			vec2 clFwd, clRgh;
			AngleVectors(aimAngle, &clFwd, &clRgh, nullptr);

			VectorNormalize(clFwd);
			VectorNormalize(clRgh);


			float divider = (svFwd.x*svRgh.y - svFwd.y*svRgh.x);
			if (divider == 0.f)
				return;
			float fmove = ((clFwd.x*svRgh.y - clFwd.y*svRgh.x)*450.f/* + (clRgh.x*svRgh.y - clRgh.y*svRgh.x)*450.f*/) / divider;
			float smove = -((clFwd.x*svFwd.y - clFwd.y*svFwd.x)*450.f/* + (clRgh.x*svFwd.y - clRgh.y*svFwd.x)*450.f*/) / divider;

			if (fmove > 0.f)
				Mem::Write<int8_t>(Signatures::Forward, 5);
			else if (fmove < 0.f)
				Mem::Write<int8_t>(Signatures::Back, 5);

			if (smove > 0.f)
				Mem::Write<int8_t>(Signatures::Right, 5);
			else if (smove < 0.f)
				Mem::Write<int8_t>(Signatures::Left, 5);
		}
	}

	void Misc()
	{
		char prevMap[64] = {};
		bool bHoldingTab = false;
		bool bRevealedWarmup = false;
		bool bRevealedGame = false;
		bool bChangedSky = false;
		bool bBotMount = false;

		while (true)
		{
			if (GetAsyncKeyState(Config::LoadNextConfigKey) & 0x8000)
			{
				Config::ReadNext();
				std::this_thread::sleep_for(1s);
				bChangedSky = false;
			}

			if (g_bInGame)
			{
				Mem::Read<float>(Signatures::GlobalVars + 32, g_IntervalPerTick);
				Mem::Read<uintptr_t>(Signatures::m_NetChannel, g_NetChannel);

				char curMap[_countof(prevMap)];
				Mem::Read<char[_countof(prevMap)]>(Signatures::m_szLevelName, curMap);
				if (curMap[0] != '\0' && strcmp(prevMap, curMap) != 0)
				{
					strcpy_s(prevMap, sizeof(prevMap), curMap);
					BSP::Load(curMap);
					g_bDangerZone = (curMap[5] == 'd' && curMap[6] == 'z' && curMap[7] == '_');
					ModelIndexes::Init();
				}

				if (!bChangedSky)
				{
					if (Config::Skyname[0] != '\0')
						R_LoadNamedSkys(Config::Skyname);
					bChangedSky = true;
				}

				if (GetAsyncKeyState(Config::BotMountKey) & 0x8000)
				{
					bBotMount = !bBotMount;
					std::cout << "Bot mount: " << (bBotMount ? "on" : "off") << "\n\a";
					std::this_thread::sleep_for(1s);
				}
#ifndef NCURL
				else if (GetAsyncKeyState(Config::InsultKey) & 0x8000)
				{
					SayInsult();
					std::this_thread::sleep_for(1s);
				}
#endif // !NCURL

				if (bBotMount)
					BotMount(); // todo: improve this shit

				if (Config::RevealRanks && !bRevealedGame)
				{
					uintptr_t GameRules;
					Mem::Read<uintptr_t>(Signatures::GameRulesProxy, GameRules);
					if (bRevealedWarmup || Mem::Read<bool>(GameRules + NetVars::m_bIsQueuedMatchmaking))
					{
						if (GetAsyncKeyState(VK_TAB) & 0x8000)
						{
							bHoldingTab = true;
						}
						else if (bHoldingTab)
						{
							bHoldingTab = false;
							if (Mem::Read<bool>(GameRules + NetVars::m_bWarmupPeriod))
							{
								if (!bRevealedWarmup)
								{
									bRevealedWarmup = true;
									RankReveal();
								}
							}
							else
							{
								if (!bRevealedGame && !Mem::Read<bool>(GameRules + NetVars::m_bFreezePeriod))
								{
									bRevealedGame = true;
									RankReveal();
								}
							}
						}
					}
				}

				static bool bFovChanged = true;
				CWeapon weapon;
				if (g_LocalPlayer.GetWeapon(weapon))
				{
					if (Config::NoScope && g_LocalPlayer.m_bIsScoped && 
						weapon.m_iItemDefinitionIndex != WEAPON_SG556 && weapon.m_iItemDefinitionIndex != WEAPON_AUG && 
						(1 <= weapon.m_zoomLevel) && (weapon.m_zoomLevel <= 2))
					{
						bFovChanged = true;
						Mem::Write<int>(g_LocalPlayer.Address + NetVars::m_iDefaultFOV, (weapon.m_zoomLevel == 1 ? 40 : 25));
					}
					else if (bFovChanged)
					{
						bFovChanged = false;
						Mem::Write<int>(g_LocalPlayer.Address + NetVars::m_iDefaultFOV, (Config::ViewFov ? Config::ViewFov : 90));
					}
				}

				if (g_LocalPlayer.m_flFlashMaxAlpha != Config::MaxFlashEffect)
					Mem::Write<float>(g_LocalPlayer.Address + NetVars::m_flFlashMaxAlpha, Config::MaxFlashEffect);
			}
			else
			{
				bHoldingTab = bRevealedWarmup = bRevealedGame = bChangedSky = false;

				if (Config::AutoAccept)
					AutoAccept();
			}

			std::this_thread::sleep_for(100ms);
		}
	}

	void AutoJump()
	{
		bool bSpacePressedFirstTime = true;
		while (true)
		{
			if (g_bInGame && Config::AutoJump::Enable && IsMouseActive())
			{
				if (GetAsyncKeyState(VK_SPACE) & 0x8000)
				{
					if (g_LocalPlayer.m_fFlags & FL_ONGROUND)
					{
						Mem::Write<uint8_t>(Signatures::Jump, 6);
						if (Config::AutoJump::Legit)
							std::this_thread::sleep_for(500ms); // so we dont get stuck when we hit roof with the head
					}
					else if (bSpacePressedFirstTime)
					{
						bSpacePressedFirstTime = false;
						Mem::Write<uint8_t>(Signatures::Jump, 4);
					}
				}
				else
					bSpacePressedFirstTime = true;
			}
			SleepTicks(Config::AutoJump::Legit ? 1.f : 0.5f);
		}
	}

	void FakeLag()
	{
		bool bToggled = false;
		while (true)
		{
			if (Config::FakeLag::Enabled)
			{
				if ((GetAsyncKeyState(Config::FakeLag::ToggleKey) & 0x8000) && IsMouseActive())
				{
					bToggled = !bToggled;
					std::cout << "FakeLag: " << (bToggled ? "on" : "off") << "\n\a";
					std::this_thread::sleep_for(500ms);
				}

				if (g_bInGame && !g_LocalPlayer.m_lifeState && bToggled &&
					(!Config::FakeLag::OnlyInAir || !(g_LocalPlayer.m_fFlags & FL_ONGROUND)) &&
					(!Config::FakeLag::DisableWhenShoot || !(GetAsyncKeyState(VK_LBUTTON) & 0x8000)) && !Mem::Read<bool>(Signatures::g_bVoiceRecording))
				{
#ifdef NDEBUG
					Mem::Write<double>(Signatures::m_flNextCmdTime, FLT_MAX);
#else
					Mem::Write<bool>(Signatures::bSendPacket, false);
#endif // NDEBUG
					SleepTicks(Config::FakeLag::TicksLag);
#ifdef NDEBUG
					Mem::Write<double>(Signatures::m_flNextCmdTime, 0.0);
#else
					Mem::Write<bool>(Signatures::bSendPacket, true);
#endif // NDEBUG
				}
			}
			SleepTicks(Config::FakeLag::TicksPass);
		}
	}
}
```

`src/NetVars.hpp`:

```hpp
#pragma once

#ifdef GetProp
#undef GetProp
#endif

namespace NetVars
{
	RecvTable* GetTable(const char* name)
	{
		ClientClass cc;
		Mem::Read<ClientClass>(Signatures::g_pClientClassHead, cc);

		while (true)
		{
			char varname[64];
			Mem::Read<char[64]>(reinterpret_cast<uintptr_t>(cc.m_pNetworkName), varname);

			if (!strcmp(varname, name))
				return cc.m_pRecvTable;

			if (cc.m_pNext == 0)
				break;

			Mem::Read<ClientClass>(reinterpret_cast<uintptr_t>(cc.m_pNext), cc);
		}

		return nullptr;
	}

	int GetProp(RecvTable* pTable, const char* name)
	{
		RecvTable table;
		Mem::Read<RecvTable>(reinterpret_cast<uintptr_t>(pTable), table);

		int offset = 0;
		for (int i = 0; i < table.m_nProps; ++i)
		{
			RecvProp prop;
			Mem::Read<RecvProp>(reinterpret_cast<uintptr_t>(table.m_pProps) + i * sizeof(RecvProp), prop);
			if (prop.m_RecvType == DPT_DataTable)
			{
				int extra = GetProp(prop.m_pDataTable, name);
				if (extra)
					offset += prop.m_Offset + extra;
			}
			else
			{
				char varname[64];
				Mem::Read<char[64]>(reinterpret_cast<uintptr_t>(prop.m_pVarName), varname);

				if (!strcmp(varname, name))
					return prop.m_Offset;
			}
		}
		return offset;
	}

	int GetOffset(const char* tableName, const char* varName)
	{
		RecvTable* table = GetTable(tableName);
		if (!table)
			ErrorExit("Failed to find a netvar");

		int offset = GetProp(table, varName);
		if (!offset)
			ErrorExit("Failed to find a netvar");

#ifdef _DEBUG
		std::cout << "Found " << varName << " -> 0x" << std::hex << offset << '\n';
#endif
		return offset;
	}

	int m_clrRender,
		m_iTeamNum,
		m_vecOrigin,
		m_nModelIndex,
		m_flSimulationTime,
		m_bSpotted,

		m_pBones,

		m_iHealth,
		m_fFlags,
		m_vecViewOffset,
		m_vecVelocity,
		m_lifeState,
		m_aimPunchAngle,
		m_iDefaultFOV,
		m_nTickBase,

		m_hActiveWeapon,

		m_bIsScoped,
		m_bIsWalking,
		m_bGunGameImmunity,
		m_iShotsFired,
		m_nSurvivalTeam,
		m_flFlashAlpha,
		m_flFlashMaxAlpha,
		m_angEyeAngles,
		m_iIDEntIndex,

		m_iItemDefinitionIndex,
		m_flNextPrimaryAttack,
		m_iClip1,
		m_bInReload,
		m_weaponMode,
		m_fAccuracyPenalty,
		m_zoomLevel,

		m_bFreezePeriod,
		m_bWarmupPeriod,
		m_bIsQueuedMatchmaking;

	void Find()
	{
#ifdef _DEBUG
		std::cout << '\n';
#endif // _DEBUG

		m_clrRender					= GetOffset("CBaseEntity", "m_clrRender");
		m_iTeamNum					= GetOffset("CBaseEntity", "m_iTeamNum");
		m_vecOrigin					= GetOffset("CBaseEntity", "m_vecOrigin");
		m_nModelIndex				= GetOffset("CBaseEntity", "m_nModelIndex");
		m_flSimulationTime			= GetOffset("CBaseEntity", "m_flSimulationTime");
		m_bSpotted					= GetOffset("CBaseEntity", "m_bSpotted");

		m_pBones					= GetOffset("CBaseAnimating", "m_nForceBone") + 28;

		m_iHealth					= GetOffset("CBasePlayer", "m_iHealth");
		m_fFlags					= GetOffset("CBasePlayer", "m_fFlags");
		m_vecViewOffset				= GetOffset("CBasePlayer", "m_vecViewOffset[0]");
		m_vecVelocity				= GetOffset("CBasePlayer", "m_vecVelocity[0]");
		m_lifeState					= GetOffset("CBasePlayer", "m_lifeState");
		m_aimPunchAngle				= GetOffset("CBasePlayer", "m_aimPunchAngle");
		m_iDefaultFOV				= GetOffset("CBasePlayer", "m_iDefaultFOV");
		m_nTickBase					= GetOffset("CBasePlayer", "m_nTickBase");

		m_hActiveWeapon				= GetOffset("CBaseCombatCharacter", "m_hActiveWeapon");

		m_bIsScoped					= GetOffset("CCSPlayer", "m_bIsScoped");
		m_bIsWalking				= GetOffset("CCSPlayer", "m_bIsWalking");
		m_bGunGameImmunity			= GetOffset("CCSPlayer", "m_bGunGameImmunity");
		m_iShotsFired				= GetOffset("CCSPlayer", "m_iShotsFired");
		m_nSurvivalTeam				= GetOffset("CCSPlayer", "m_nSurvivalTeam");
		m_flFlashMaxAlpha			= GetOffset("CCSPlayer", "m_flFlashMaxAlpha");
		m_flFlashAlpha				= m_flFlashMaxAlpha - 12;
		m_angEyeAngles				= GetOffset("CCSPlayer", "m_angEyeAngles[0]");
		m_iIDEntIndex				= GetOffset("CCSPlayer", "m_bHasDefuser") + 92;

		m_iItemDefinitionIndex		= GetOffset("CEconEntity", "m_iItemDefinitionIndex");
		m_flNextPrimaryAttack		= GetOffset("CBaseCombatWeapon", "m_flNextPrimaryAttack");
		m_iClip1					= GetOffset("CBaseCombatWeapon", "m_iClip1");
		m_bInReload					= GetOffset("CBaseCombatWeapon", "m_flTimeWeaponIdle") + 49;
		m_weaponMode				= GetOffset("CWeaponCSBase", "m_weaponMode");
		m_fAccuracyPenalty			= GetOffset("CWeaponCSBase", "m_fAccuracyPenalty");
		m_zoomLevel					= GetOffset("CWeaponCSBaseGun", "m_zoomLevel");

		m_bFreezePeriod				= GetOffset("CCSGameRulesProxy", "m_bFreezePeriod");
		m_bWarmupPeriod				= GetOffset("CCSGameRulesProxy", "m_bWarmupPeriod");
		m_bIsQueuedMatchmaking		= GetOffset("CCSGameRulesProxy", "m_bIsQueuedMatchmaking");
	}
}
```

`src/SDK/BSP.hpp`:

```hpp
#pragma once

enum
{
	LUMP_ENTITIES					= 0,	// *
	LUMP_PLANES						= 1,	// *
	LUMP_TEXDATA					= 2,	// *
	LUMP_VERTEXES					= 3,	// *
	LUMP_VISIBILITY					= 4,	// *
	LUMP_NODES						= 5,	// *
	LUMP_TEXINFO					= 6,	// *
	LUMP_FACES						= 7,	// *
	LUMP_LIGHTING					= 8,	// *
	LUMP_OCCLUSION					= 9,
	LUMP_LEAFS						= 10,	// *
	LUMP_FACEIDS					= 11,
	LUMP_EDGES						= 12,	// *
	LUMP_SURFEDGES					= 13,	// *
	LUMP_MODELS						= 14,	// *
	LUMP_WORLDLIGHTS				= 15,	// 
	LUMP_LEAFFACES					= 16,	// *
	LUMP_LEAFBRUSHES				= 17,	// *
	LUMP_BRUSHES					= 18,	// *
	LUMP_BRUSHSIDES					= 19,	// *
	LUMP_AREAS						= 20,	// *
	LUMP_AREAPORTALS				= 21,	// *
	LUMP_PROPCOLLISION				= 22,	// static props convex hull lists
	LUMP_PROPHULLS					= 23,	// static prop convex hulls
	LUMP_PROPHULLVERTS				= 24,	// static prop collision verts
	LUMP_PROPTRIS					= 25,	// static prop per hull triangle index start/count

	LUMP_DISPINFO					= 26,
	LUMP_ORIGINALFACES				= 27,
	LUMP_PHYSDISP					= 28,
	LUMP_PHYSCOLLIDE				= 29,
	LUMP_VERTNORMALS				= 30,
	LUMP_VERTNORMALINDICES			= 31,
	LUMP_DISP_LIGHTMAP_ALPHAS		= 32,
	LUMP_DISP_VERTS					= 33,		// CDispVerts
	LUMP_DISP_LIGHTMAP_SAMPLE_POSITIONS = 34,	// For each displacement
												//     For each lightmap sample
												//         byte for index
												//         if 255, then index = next byte + 255
												//         3 bytes for barycentric coordinates
	// The game lump is a method of adding game-specific lumps
	// FIXME: Eventually, all lumps could use the game lump system
	LUMP_GAME_LUMP					= 35,
	LUMP_LEAFWATERDATA				= 36,
	LUMP_PRIMITIVES					= 37,
	LUMP_PRIMVERTS					= 38,
	LUMP_PRIMINDICES				= 39,
	// A pak file can be embedded in a .bsp now, and the file system will search the pak
	//  file first for any referenced names, before deferring to the game directory 
	//  file system/pak files and finally the base directory file system/pak files.
	LUMP_PAKFILE					= 40,
	LUMP_CLIPPORTALVERTS			= 41,
	// A map can have a number of cubemap entities in it which cause cubemap renders
	// to be taken after running vrad.
	LUMP_CUBEMAPS					= 42,
	LUMP_TEXDATA_STRING_DATA		= 43,
	LUMP_TEXDATA_STRING_TABLE		= 44,
	LUMP_OVERLAYS					= 45,
	LUMP_LEAFMINDISTTOWATER			= 46,
	LUMP_FACE_MACRO_TEXTURE_INFO	= 47,
	LUMP_DISP_TRIS					= 48,
	LUMP_PROP_BLOB					= 49,	// static prop triangle & string data
	LUMP_WATEROVERLAYS              = 50,
	LUMP_LEAF_AMBIENT_INDEX_HDR		= 51,	// index of LUMP_LEAF_AMBIENT_LIGHTING_HDR
	LUMP_LEAF_AMBIENT_INDEX         = 52,	// index of LUMP_LEAF_AMBIENT_LIGHTING

	// optional lumps for HDR
	LUMP_LIGHTING_HDR				= 53,
	LUMP_WORLDLIGHTS_HDR			= 54,
	LUMP_LEAF_AMBIENT_LIGHTING_HDR	= 55,	// NOTE: this data overrides part of the data stored in LUMP_LEAFS.
	LUMP_LEAF_AMBIENT_LIGHTING		= 56,	// NOTE: this data overrides part of the data stored in LUMP_LEAFS.

	LUMP_XZIPPAKFILE				= 57,   // deprecated. xbox 1: xzip version of pak file
	LUMP_FACES_HDR					= 58,	// HDR maps may have different face data.
	LUMP_MAP_FLAGS                  = 59,   // extended level-wide flags. not present in all levels
	LUMP_OVERLAY_FADES				= 60,	// Fade distances for overlays
	LUMP_OVERLAY_SYSTEM_LEVELS		= 61,	// System level settings (min/max CPU & GPU to render this overlay) 
	LUMP_PHYSLEVEL                  = 62,
	LUMP_DISP_MULTIBLEND			= 63,	// Displacement multiblend info
};
namespace BSP
{
	struct lump_t
	{
		int		fileOfs;		// offset into file (bytes)
		int		fileLen;		// length of lump (bytes)
		int		version;		// lump format version
		char	fourCC[4];		// lump ident code
	};

	struct dheader_t
	{
		int		ident;			// BSP file identifier
		int		version;		// BSP file version
		lump_t	lumps[64];		// lump directory array HEADER_LUMPS
		int		mapRevision;	// the map's revision (iteration, version) number
	};

	struct dnode_t
	{
		int				planeNum;		// index into plane array
		int				children[2];	// negative numbers are -(leafs + 1), not nodes
		short			mins[3];		// for frustum culling
		short			maxs[3];
		unsigned short	firstFace;		// index into face array
		unsigned short	numFaces;		// counting both sides
		short			area;			// If all leaves below this node are in the same area, then this is the area index. If not, this is -1.
		short			paddding;		// pad to 32 bytes length
	};

	struct dplane_t
	{
		vec3	normal;		// normal vector
		float	dist;		// distance from origin
		int		type;		// plane axis identifier
	};

	struct dleaf_t
	{
		int				contents;			// OR of all brushes (not needed?)
		short			cluster;			// cluster this leaf is in
		short			area : 9;			// area this leaf is in
		short			flags : 7;			// flags
		short			mins[3];			// for frustum culling
		short			maxs[3];
		unsigned short	firstLeafFace;		// index into leaffaces
		unsigned short	numLeafFaces;
		unsigned short	firstLeafBrush;		// index into leafbrushes
		unsigned short	numLeafBrushes;
		short			leafWaterDataID;	// -1 for not in water
	};


	char*		m_mapData = nullptr;
	dplane_t*	m_lumpPlane = nullptr;
	dnode_t*	m_lumpNode = nullptr;
	dleaf_t*	m_lumpLeaf = nullptr;

	void Load(const char Map[])
	{
		char Path[MAX_PATH];
		strcpy_s(Path, sizeof(Path), Mem::GetDir());
		strcat_s(Path, sizeof(Path), "csgo\\");
		strcat_s(Path, sizeof(Path), Map);
		char* scrim = strstr(Path, "_scrim");
		if (scrim)
		{
			scrim[0] = '.';
			scrim[1] = 'b';
			scrim[2] = 's';
			scrim[3] = 'p';
			scrim[4] = '\0';
		}

		std::ifstream File(Path, std::ios::binary | std::ios::ate);
		if (File.fail())
			ErrorExit("Failed to open a map");

		const int length = File.tellg();
		File.seekg(0, File.beg);

		delete[] m_mapData;
		m_mapData = new char[length];
		File.read(m_mapData, length);
		File.close();

		const dheader_t* header = reinterpret_cast<dheader_t*>(m_mapData);
		m_lumpPlane = reinterpret_cast<dplane_t*>(m_mapData + header->lumps[LUMP_PLANES].fileOfs);
		m_lumpNode = reinterpret_cast<dnode_t*>(m_mapData + header->lumps[LUMP_NODES].fileOfs);
		m_lumpLeaf = reinterpret_cast<dleaf_t*>(m_mapData + header->lumps[LUMP_LEAFS].fileOfs);
	}

	dleaf_t* GetLeafForPoint(const vec3& point)
	{
		int iNode = 0;
		while (iNode >= 0)
		{
			const dnode_t* pNode = &m_lumpNode[iNode];
			const dplane_t* pPlane = &m_lumpPlane[pNode->planeNum];
			iNode = (((point.x * pPlane->normal.x + point.y * pPlane->normal.y + point.z * pPlane->normal.z) - pPlane->dist) > 0.f) ? pNode->children[0] : pNode->children[1];
		}
		return &m_lumpLeaf[-1 - iNode];
	}

	bool isVisible(const vec3& start, const vec3& end)
	{
		vec3 direction(end - start);
		int stepCount = direction.Length();
		direction /= stepCount;

		vec3 point(start);
		while (stepCount)
		{
			point += direction;
			const dleaf_t* leaf = GetLeafForPoint(point);
			if (leaf && (leaf->contents & 1))
				return false;

			--stepCount;
		}
		return true;
	}

	bool canWallbang(const vec3& start, const vec3& end, int WeaponIndex)
	{
		int leftWallbangable;
		switch (WeaponIndex)
		{
		case WEAPON_DEAGLE:

		case WEAPON_AK47:
		case WEAPON_AUG:
		case WEAPON_FAMAS:
		case WEAPON_GALILAR:
		case WEAPON_M4A1:
		case WEAPON_SG556:
		case WEAPON_M4A1_SILENCER:

		case WEAPON_M249:
		case WEAPON_NEGEV:
			leftWallbangable = 12;
			break;
		case WEAPON_AWP:
			leftWallbangable = 26;
			break;
		case WEAPON_G3SG1:
		case WEAPON_SCAR20:
			leftWallbangable = 18;
			break;
		case WEAPON_REVOLVER:
		case WEAPON_SSG08:
			leftWallbangable = 16;
			break;
		case WEAPON_TASER:
			leftWallbangable = 0;
			break;
		default:
			leftWallbangable = 3;
			break;
		}

		vec3 direction(end - start);
		int stepCount = direction.Length();
		direction /= stepCount;

		vec3 point(start);
		while (stepCount)
		{
			point += direction;
			const dleaf_t* leaf = GetLeafForPoint(point);
			if (leaf && (leaf->contents & 1))
			{
				if (leftWallbangable <= 0)
					return false;

				--leftWallbangable;
			}
			--stepCount;
		}
		return true;
	}

	bool CanHit(const vec3& start, const vec3& end, int WeaponIndex)
	{
		return (!Config::Aimbot::PseudoAwall) ? isVisible(start, end) : canWallbang(start, end, WeaponIndex);
	}
}
```

`src/SDK/Client.hpp`:

```hpp
#pragma once

enum SendPropType
{
	DPT_Int = 0,
	DPT_Float,
	DPT_Vector,
	DPT_VectorXY,	// Only encodes the XY of a vector, ignores Z
	DPT_String,
	DPT_Array,		// An array of the base types (can't be of datatables).
	DPT_DataTable,
	DPT_Int64,
	DPT_NUMSendPropTypes
};

struct RecvTable;

struct RecvProp
{
	char* m_pVarName;
	SendPropType m_RecvType;
	int			m_Flags;
	int			m_StringBufferSize;
	bool		m_bInsideArray;
	const void* m_pExtraData;
	RecvProp* m_pArrayProp;
	void* m_ArrayLengthProxy;
	void* m_ProxyFn;
	void* m_DataTableProxyFn;
	RecvTable* m_pDataTable;
	int			m_Offset;
	int			m_ElementStride;
	int			m_nElements;

	// If it's one of the numbered "000", "001", etc properties in an array, then
	// these can be used to get it's array property name for debugging.
	const char* m_pParentArrayPropName;
};

struct RecvTable
{
	RecvProp* m_pProps;
	int			m_nProps;
	void* m_pDecoder;
	char* m_pNetTableName;	// The name matched between client and server.
	bool		m_bInitialized;
	bool		m_bInMainList;
};

enum ClassInfo
{
	CAI_BaseNPC,
	CAK47,
	CBaseAnimating,
	CBaseAnimatingOverlay,
	CBaseAttributableItem,
	CBaseButton,
	CBaseCombatCharacter,
	CBaseCombatWeapon,
	CBaseCSGrenade,
	CBaseCSGrenadeProjectile,
	CBaseDoor,
	CBaseEntity,
	CBaseFlex,
	CBaseGrenade,
	CBaseParticleEntity,
	CBasePlayer,
	CBasePropDoor,
	CBaseTeamObjectiveResource,
	CBaseTempEntity,
	CBaseToggle,
	CBaseTrigger,
	CBaseViewModel,
	CBaseVPhysicsTrigger,
	CBaseWeaponWorldModel,
	CBeam,
	CBeamSpotlight,
	CBoneFollower,
	CBRC4Target,
	CBreachCharge,
	CBreachChargeProjectile,
	CBreakableProp,
	CBreakableSurface,
	CBumpMine,
	CBumpMineProjectile,
	CC4,
	CCascadeLight,
	CChicken,
	CColorCorrection,
	CColorCorrectionVolume,
	CCSGameRulesProxy,
	CCSPlayer,
	CCSPlayerResource,
	CCSRagdoll,
	CCSTeam,
	CDangerZone,
	CDangerZoneController,
	CDEagle,
	CDecoyGrenade,
	CDecoyProjectile,
	CDrone,
	CDronegun,
	CDynamicLight,
	CDynamicProp,
	CEconEntity,
	CEconWearable,
	CEmbers,
	CEntityDissolve,
	CEntityFlame,
	CEntityFreezing,
	CEntityParticleTrail,
	CEnvAmbientLight,
	CEnvDetailController,
	CEnvDOFController,
	CEnvGasCanister,
	CEnvParticleScript,
	CEnvProjectedTexture,
	CEnvQuadraticBeam,
	CEnvScreenEffect,
	CEnvScreenOverlay,
	CEnvTonemapController,
	CEnvWind,
	CFEPlayerDecal,
	CFireCrackerBlast,
	CFireSmoke,
	CFireTrail,
	CFish,
	CFists,
	CFlashbang,
	CFogController,
	CFootstepControl,
	CFunc_Dust,
	CFunc_LOD,
	CFuncAreaPortalWindow,
	CFuncBrush,
	CFuncConveyor,
	CFuncLadder,
	CFuncMonitor,
	CFuncMoveLinear,
	CFuncOccluder,
	CFuncReflectiveGlass,
	CFuncRotating,
	CFuncSmokeVolume,
	CFuncTrackTrain,
	CGameRulesProxy,
	CGrassBurn,
	CHandleTest,
	CHEGrenade,
	CHostage,
	CHostageCarriableProp,
	CIncendiaryGrenade,
	CInferno,
	CInfoLadderDismount,
	CInfoMapRegion,
	CInfoOverlayAccessor,
	CItem_Healthshot,
	CItemCash,
	CItemDogtags,
	CKnife,
	CKnifeGG,
	CLightGlow,
	CMaterialModifyControl,
	CMelee,
	CMolotovGrenade,
	CMolotovProjectile,
	CMovieDisplay,
	CParadropChopper,
	CParticleFire,
	CParticlePerformanceMonitor,
	CParticleSystem,
	CPhysBox,
	CPhysBoxMultiplayer,
	CPhysicsProp,
	CPhysicsPropMultiplayer,
	CPhysMagnet,
	CPhysPropAmmoBox,
	CPhysPropLootCrate,
	CPhysPropRadarJammer,
	CPhysPropWeaponUpgrade,
	CPlantedC4,
	CPlasma,
	CPlayerPing,
	CPlayerResource,
	CPointCamera,
	CPointCommentaryNode,
	CPointWorldText,
	CPoseController,
	CPostProcessController,
	CPrecipitation,
	CPrecipitationBlocker,
	CPredictedViewModel,
	CProp_Hallucination,
	CPropCounter,
	CPropDoorRotating,
	CPropJeep,
	CPropVehicleDriveable,
	CRagdollManager,
	CRagdollProp,
	CRagdollPropAttached,
	CRopeKeyframe,
	CSCAR17,
	CSceneEntity,
	CSensorGrenade,
	CSensorGrenadeProjectile,
	CShadowControl,
	CSlideshowDisplay,
	CSmokeGrenade,
	CSmokeGrenadeProjectile,
	CSmokeStack,
	CSnowball,
	CSnowballPile,
	CSnowballProjectile,
	CSpatialEntity,
	CSpotlightEnd,
	CSprite,
	CSpriteOriented,
	CSpriteTrail,
	CStatueProp,
	CSteamJet,
	CSun,
	CSunlightShadowControl,
	CSurvivalSpawnChopper,
	CTablet,
	CTeam,
	CTeamplayRoundBasedRulesProxy,
	CTEArmorRicochet,
	CTEBaseBeam,
	CTEBeamEntPoint,
	CTEBeamEnts,
	CTEBeamFollow,
	CTEBeamLaser,
	CTEBeamPoints,
	CTEBeamRing,
	CTEBeamRingPoint,
	CTEBeamSpline,
	CTEBloodSprite,
	CTEBloodStream,
	CTEBreakModel,
	CTEBSPDecal,
	CTEBubbles,
	CTEBubbleTrail,
	CTEClientProjectile,
	CTEDecal,
	CTEDust,
	CTEDynamicLight,
	CTEEffectDispatch,
	CTEEnergySplash,
	CTEExplosion,
	CTEFireBullets,
	CTEFizz,
	CTEFootprintDecal,
	CTEFoundryHelpers,
	CTEGaussExplosion,
	CTEGlowSprite,
	CTEImpact,
	CTEKillPlayerAttachments,
	CTELargeFunnel,
	CTEMetalSparks,
	CTEMuzzleFlash,
	CTEParticleSystem,
	CTEPhysicsProp,
	CTEPlantBomb,
	CTEPlayerAnimEvent,
	CTEPlayerDecal,
	CTEProjectedDecal,
	CTERadioIcon,
	CTEShatterSurface,
	CTEShowLine,
	CTesla,
	CTESmoke,
	CTESparks,
	CTESprite,
	CTESpriteSpray,
	CTest_ProxyToggle_Networkable,
	CTestTraceline,
	CTEWorldDecal,
	CTriggerPlayerMovement,
	CTriggerSoundOperator,
	CVGuiScreen,
	CVoteController,
	CWaterBullet,
	CWaterLODControl,
	CWeaponAug,
	CWeaponAWP,
	CWeaponBaseItem,
	CWeaponBizon,
	CWeaponCSBase,
	CWeaponCSBaseGun,
	CWeaponCycler,
	CWeaponElite,
	CWeaponFamas,
	CWeaponFiveSeven,
	CWeaponG3SG1,
	CWeaponGalil,
	CWeaponGalilAR,
	CWeaponGlock,
	CWeaponHKP2000,
	CWeaponM249,
	CWeaponM3,
	CWeaponM4A1,
	CWeaponMAC10,
	CWeaponMag7,
	CWeaponMP5Navy,
	CWeaponMP7,
	CWeaponMP9,
	CWeaponNegev,
	CWeaponNOVA,
	CWeaponP228,
	CWeaponP250,
	CWeaponP90,
	CWeaponSawedoff,
	CWeaponSCAR20,
	CWeaponScout,
	CWeaponSG550,
	CWeaponSG552,
	CWeaponSG556,
	CWeaponShield,
	CWeaponSSG08,
	CWeaponTaser,
	CWeaponTec9,
	CWeaponTMP,
	CWeaponUMP45,
	CWeaponUSP,
	CWeaponXM1014,
	CWorld,
	CWorldVguiText,
	DustTrail,
	MovieExplosion,
	ParticleSmokeGrenade,
	RocketTrail,
	SmokeTrail,
	SporeExplosion,
	SporeTrail
};

struct ClientClass
{
private:
	BYTE		vfns[8];
public:
	char* m_pNetworkName;
	RecvTable* m_pRecvTable;
	ClientClass* m_pNext;
	int			m_ClassID;
};

int GetClassId(uintptr_t pEnt)
{
	return Mem::Read<int>(
		Mem::Read<uintptr_t>(
			Mem::Read<uintptr_t>(
				Mem::Read<uintptr_t>(pEnt + 8) // IClientNetworkable
				+ 8) // GetClientClass
			+ 1) // var in function
		+ 20); // class id
}
```

`src/SDK/Random.hpp`:

```hpp
#pragma once

#define NTAB 32
#define IA 16807
#define IM 2147483647
#define IQ 127773
#define IR 2836
#define NDIV (1+(IM-1)/NTAB)
#define MAX_RANDOM_RANGE 0x7FFFFFFFUL

#define AM (1.0/IM)
#define EPS 1.2e-7
#define RNMX (1.0-EPS)

namespace Random
{
	int m_idum;
	int m_iy;
	int m_iv[NTAB];

	void SetSeed(int iSeed)
	{
		m_idum = ((iSeed < 0) ? iSeed : -iSeed);
		m_iy = 0;
	}

	int GenerateRandomNumber()
	{
		int j;
		int k;

		if (m_idum <= 0 || !m_iy)
		{
			if (-(m_idum) < 1)
				m_idum = 1;
			else
				m_idum = -(m_idum);

			for (j = NTAB + 7; j >= 0; j--)
			{
				k = (m_idum) / IQ;
				m_idum = IA * (m_idum - k * IQ) - IR * k;
				if (m_idum < 0)
					m_idum += IM;
				if (j < NTAB)
					m_iv[j] = m_idum;
			}
			m_iy = m_iv[0];
		}
		k = (m_idum) / IQ;
		m_idum = IA * (m_idum - k * IQ) - IR * k;
		if (m_idum < 0)
			m_idum += IM;
		j = m_iy / NDIV;

		// We're seeing some strange memory corruption in the contents of s_pUniformStream. 
		// Perhaps it's being caused by something writing past the end of this array? 
		// Bounds-check in release to see if that's the case.
		if (j >= NTAB || j < 0)
		{
			std::cout << "Warning: GenerateRandomNumber had an array overrun.\n";
			j = (j % NTAB) & 0x7fffffff;
		}

		m_iy = m_iv[j];
		m_iv[j] = m_idum;

		return m_iy;
	}

	float RandomFloat(float flLow, float flHigh)
	{
		// float in [0,1)
		float fl = AM * GenerateRandomNumber();
		if (fl > RNMX)
			fl = RNMX;

		return (fl * (flHigh - flLow)) + flLow; // float in [low,high)
	}

	float RandomFloatExp(float flMinVal, float flMaxVal, float flExponent)
	{
		// float in [0,1)
		float fl = AM * GenerateRandomNumber();
		if (fl > RNMX)
			fl = RNMX;

		if (flExponent != 1.0f)
			fl = powf(fl, flExponent);

		return (fl * (flMaxVal - flMinVal)) + flMinVal; // float in [low,high)
	}

	int RandomInt(int iLow, int iHigh)
	{
		unsigned int x = iHigh - iLow + 1;
		if (x <= 1 || MAX_RANDOM_RANGE < x - 1)
			return iLow;

		// The following maps a uniform distribution on the interval [0,MAX_RANDOM_RANGE]
		// to a smaller, client-specified range of [0,x-1] in a way that doesn't bias
		// the uniform distribution unfavorably. Even for a worst case x, the loop is
		// guaranteed to be taken no more than half the time, so for that worst case x,
		// the average number of times through the loop is 2. For cases where x is
		// much smaller than MAX_RANDOM_RANGE, the average number of times through the
		// loop is very close to 1.
		unsigned int maxAcceptable = MAX_RANDOM_RANGE - ((MAX_RANDOM_RANGE + 1) % x);
		unsigned int n;
		do
		{
			n = GenerateRandomNumber();
		} while (n > maxAcceptable);

		return iLow + (n % x);
	}
}
```

`src/SDK/Studio.hpp`:

```hpp
#pragma once

#define BONE_USED_BY_HITBOX	0x00000100	// bone (or child) is used by a hit box

// Credits: ReactiioN
enum EHitbox
{
	HITBOX_HEAD,
	HITBOX_NECK,
	HITBOX_PELVIS,
	HITBOX_STOMACH,
	HITBOX_CHEST,
	HITBOX_LOWER_CHEST,
	HITBOX_UPPER_CHEST,
	HITBOX_RIGHT_THIGH,
	HITBOX_LEFT_THIGH,
	HITBOX_RIGHT_CALF,
	HITBOX_LEFT_CALF,
	HITBOX_RIGHT_FOOT,
	HITBOX_LEFT_FOOT,
	HITBOX_RIGHT_HAND,
	HITBOX_LEFT_HAND,
	HITBOX_RIGHT_UPPER_ARM,
	HITBOX_RIGHT_LOWER_ARM,
	HITBOX_LEFT_UPPER_ARM,
	HITBOX_LEFT_LOWER_ARM,
	HITBOX_LAST
};

struct mstudiobbox_t
{
	int					bone;
	int					group;				// intersection group
	vec3				bbmin;				// bounding box
	vec3				bbmax;
	int					szHitboxNameIndex;	// offset to the name of the hitbox.
	int					unused[3];
	float				radius;
	int					unused2[4];
};

struct mstudiohitboxset_t
{
	int					szNameIndex;
	int					numhitboxes;
	int					hitboxindex;
};

struct mstudiobone_t
{
	int					szNameIndex;
	int		 			parent;				// parent bone
	int					bonecontroller[6];	// bone controller index, -1 == none

	// default values
	vec3				pos;
	float				quat[4];
	vec3				rot;

	// compression scale
	vec3				posscale;
	vec3				rotscale;

	matrix3x4_t			poseToBone;
	float				qAlignment[4];
	int					flags;
	int					proctype;
	int					procindex;			// procedural rule
	mutable int			physicsbone;		// index into physically simulated bone
	int					surfacepropidx;		// index into string tablefor property name

	int					contents;			// See BSPFlags.h for the contents flags
	int					SurfacePropLookup;	// this index must be cached by the loader, not saved in the file
	int					unused[7];
};

namespace Studio
{
	std::unordered_map<uint32_t, int[HITBOX_LAST]> mapHitboxBones;

	void InitHitboxBones(uint32_t fnHandle, uintptr_t pStudioHdr)
	{
		uintptr_t studiohdr;
		Mem::Read<uintptr_t>(pStudioHdr, studiohdr);

		int hitboxsetindex;
		Mem::Read<int>(studiohdr + 0xB0, hitboxsetindex);

		uintptr_t pHitboxSet = studiohdr + hitboxsetindex;
		mstudiohitboxset_t hitboxset; // player have just 1 set
		Mem::Read<mstudiohitboxset_t>(pHitboxSet, hitboxset);

		if (hitboxset.numhitboxes != HITBOX_LAST)
			ErrorExit("Error: Hitboxes enum requires an update");

		for (UINT i = 0; i < HITBOX_LAST; ++i)
			mapHitboxBones[fnHandle][i] = Mem::Read<mstudiobbox_t>(pHitboxSet + hitboxset.hitboxindex + i * sizeof(mstudiobbox_t)).bone;
	}

	const int* const GetHitboxBones(const CPlayer& Player)
	{
		uint32_t fnHandle;
		Mem::Read<uint32_t>(Player.model, fnHandle);

		auto s = mapHitboxBones.find(fnHandle);
		if (s == mapHitboxBones.end())
		{
			InitHitboxBones(fnHandle, Player.m_pStudioHdr);
			return mapHitboxBones.find(fnHandle)->second;
		}
		else
			return s->second;
	}

	//void GetBones(const CPlayer& Player)
	//{
	//	uintptr_t studiohdr;
	//	Mem::Read<uintptr_t>(Mem::Read<uintptr_t>(Player.pStudioHdr), studiohdr);

	//	struct studiohdr_part
	//	{
	//		int					numbones;
	//		int					boneindex;
	//	};
	//	studiohdr_part bonePart;
	//	Mem::Read<studiohdr_part>(studiohdr + 0x9C, bonePart);

	//	for (UINT i = 0; i < bonePart.numbones; ++i)
	//	{
	//		mstudiobone_t bone;
	//		Mem::Read<mstudiobone_t>(studiohdr + bonePart.boneindex + i * sizeof(mstudiobone_t), bone);
	//		if (bone.flags & BONE_USED_BY_HITBOX)
	//			return; // do shit
	//	}
	//}
}
```

`src/SDK/UserCmd.hpp`:

```hpp
#pragma once

// Buttons
#define IN_ATTACK		(1 << 0)
#define IN_JUMP			(1 << 1)
#define IN_DUCK			(1 << 2)
#define IN_FORWARD		(1 << 3)
#define IN_BACK			(1 << 4)
#define IN_USE			(1 << 5)
#define IN_CANCEL		(1 << 6)
#define IN_LEFT			(1 << 7)
#define IN_RIGHT		(1 << 8)
#define IN_MOVELEFT		(1 << 9)
#define IN_MOVERIGHT	(1 << 10)
#define IN_ATTACK2		(1 << 11)
#define IN_RUN			(1 << 12)
#define IN_RELOAD		(1 << 13)
#define IN_ALT1			(1 << 14)
#define IN_ALT2			(1 << 15)
#define IN_SCORE		(1 << 16)   // Used by client.dll for when scoreboard is held down
#define IN_SPEED		(1 << 17)	// Player is holding the speed key
#define IN_WALK			(1 << 18)	// Player holding walk key
#define IN_ZOOM			(1 << 19)	// Zoom key for HUD zoom
#define IN_WEAPON1		(1 << 20)	// weapon defines these bits
#define IN_WEAPON2		(1 << 21)	// weapon defines these bits
#define IN_BULLRUSH		(1 << 22)
#define IN_GRENADE1		(1 << 23)	// grenade 1
#define IN_GRENADE2		(1 << 24)	// grenade 2
#define	IN_ATTACK3		(1 << 25)

struct CUserCmd
{
private:
	BYTE	vtable[4];
public:
	int		command_number;		// 0x04 For matching server and client commands for debugging
	int		tick_count;			// 0x08 the tick the client created this command
	vec3	viewangles;			// 0x0C Player instantaneous view angles
	vec3	aimdirection;		// 0x18
	float	forwardmove;		// 0x24
	float	sidemove;			// 0x28
	float	upmove;				// 0x2C
	int		buttons;			// 0x30 Attack button states
	BYTE    impulse;			// 0x34
	int		weaponselect;		// 0x38 Current weapon id
	int		weaponsubtype;		// 0x3C
	int		random_seed;		// 0x40 For shared random functions
	short	mousedx;			// 0x44 mouse accum in x from create move
	short	mousedy;			// 0x46 mouse accum in y from create move
	bool	hasbeenpredicted;	// 0x48 Client only, tracks whether we've predicted this command at least once
private:
	BYTE	_pad[24];			// 0x4C Current sizeof( usercmd ) =  100  = 0x64
};

typedef unsigned long CRC32_t;

struct CVerifiedUserCmd
{
public:
	CUserCmd	m_cmd;
	CRC32_t		m_crc;
};

#define TICK_INTERVAL			(g_IntervalPerTick)
#define TIME_TO_TICKS( dt )		( (int)( 0.5f + (float)(dt) / TICK_INTERVAL ) )
#define TICKS_TO_TIME( t )		( TICK_INTERVAL * ( t ) )
#define ROUND_TO_TICKS( t ) ( TICK_INTERVAL * TIME_TO_TICKS( t ) )
```

`src/SDK/checksum_md5.hpp`:

```hpp
#pragma once

// 16 bytes == 128 bit digest
#define MD5_DIGEST_LENGTH 16  
#define MD5_BIT_LENGTH ( MD5_DIGEST_LENGTH * sizeof(unsigned char) )

// MD5 Hash
typedef struct
{
	unsigned int	buf[4];
	unsigned int	bits[2];
	unsigned char	in[64];
} MD5Context_t;

// The four core functions - F1 is optimized somewhat
// #define F1(x, y, z) (x & y | ~x & z)
#define F1(x, y, z) (z ^ (x & (y ^ z)))
#define F2(x, y, z) F1(z, x, y)
#define F3(x, y, z) (x ^ y ^ z)
#define F4(x, y, z) (y ^ (x | ~z))

// This is the central step in the MD5 algorithm.
#define MD5STEP(f, w, x, y, z, data, s) \
        ( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )

//-----------------------------------------------------------------------------
// Purpose: The core of the MD5 algorithm, this alters an existing MD5 hash to
//  reflect the addition of 16 longwords of new data.  MD5Update blocks
//  the data and converts bytes into longwords for this routine.
// Input  : buf[4] - 
//			in[16] - 
// Output : static void
//-----------------------------------------------------------------------------
static void MD5Transform(unsigned int buf[4], unsigned int const in[16])
{
	unsigned int a, b, c, d;

	a = buf[0];
	b = buf[1];
	c = buf[2];
	d = buf[3];

	MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);
	MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
	MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);
	MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);
	MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);
	MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);
	MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);
	MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);
	MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);
	MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);
	MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);
	MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);
	MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);
	MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);
	MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);
	MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);

	MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);
	MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);
	MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);
	MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);
	MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);
	MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);
	MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);
	MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);
	MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);
	MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);
	MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);
	MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);
	MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);
	MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);
	MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);
	MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);

	MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);
	MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);
	MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);
	MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);
	MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);
	MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);
	MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);
	MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);
	MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);
	MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);
	MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);
	MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);
	MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);
	MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);
	MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);
	MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);

	MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);
	MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);
	MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);
	MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);
	MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);
	MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);
	MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);
	MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);
	MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);
	MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);
	MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);
	MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);
	MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);
	MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);
	MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);
	MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);

	buf[0] += a;
	buf[1] += b;
	buf[2] += c;
	buf[3] += d;
}

//-----------------------------------------------------------------------------
// Purpose: Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious initialization constants.

// Input  : *ctx - 
//-----------------------------------------------------------------------------
void MD5Init(MD5Context_t *ctx)
{
	ctx->buf[0] = 0x67452301;
	ctx->buf[1] = 0xefcdab89;
	ctx->buf[2] = 0x98badcfe;
	ctx->buf[3] = 0x10325476;

	ctx->bits[0] = 0;
	ctx->bits[1] = 0;
}

//-----------------------------------------------------------------------------
// Purpose: Update context to reflect the concatenation of another buffer full of bytes.
// Input  : *ctx - 
//			*buf - 
//			len - 
//-----------------------------------------------------------------------------
void MD5Update(MD5Context_t *ctx, unsigned char const *buf, unsigned int len)
{
	unsigned int t;

	/* Update bitcount */

	t = ctx->bits[0];
	if ((ctx->bits[0] = t + ((unsigned int)len << 3)) < t)
		ctx->bits[1]++;         /* Carry from low to high */
	ctx->bits[1] += len >> 29;

	t = (t >> 3) & 0x3f;        /* Bytes already in shsInfo->data */

								/* Handle any leading odd-sized chunks */

	if (t)
	{
		unsigned char *p = (unsigned char *)ctx->in + t;

		t = 64 - t;
		if (len < t)
		{
			memcpy(p, buf, len);
			return;
		}
		memcpy(p, buf, t);
		//byteReverse(ctx->in, 16);
		MD5Transform(ctx->buf, (unsigned int *)ctx->in);
		buf += t;
		len -= t;
	}
	/* Process data in 64-byte chunks */

	while (len >= 64)
	{
		memcpy(ctx->in, buf, 64);
		//byteReverse(ctx->in, 16);
		MD5Transform(ctx->buf, (unsigned int *)ctx->in);
		buf += 64;
		len -= 64;
	}

	/* Handle any remaining bytes of data. */
	memcpy(ctx->in, buf, len);
}

//-----------------------------------------------------------------------------
// Purpose: Final wrapup - pad to 64-byte boundary with the bit pattern 
// 1 0* (64-bit count of bits processed, MSB-first)
// Input  : digest[MD5_DIGEST_LENGTH] - 
//			*ctx - 
//-----------------------------------------------------------------------------
void MD5Final(unsigned char digest[MD5_DIGEST_LENGTH], MD5Context_t *ctx)
{
	unsigned count;
	unsigned char *p;

	/* Compute number of bytes mod 64 */
	count = (ctx->bits[0] >> 3) & 0x3F;

	/* Set the first char of padding to 0x80.  This is safe since there is
	always at least one byte free */
	p = ctx->in + count;
	*p++ = 0x80;

	/* Bytes of padding needed to make 64 bytes */
	count = 64 - 1 - count;

	/* Pad out to 56 mod 64 */
	if (count < 8)
	{
		/* Two lots of padding:  Pad the first block to 64 bytes */
		memset(p, 0, count);
		//byteReverse(ctx->in, 16);
		MD5Transform(ctx->buf, (unsigned int *)ctx->in);

		/* Now fill the next block with 56 bytes */
		memset(ctx->in, 0, 56);
	}
	else
	{
		/* Pad block to 56 bytes */
		memset(p, 0, count - 8);
	}
	//byteReverse(ctx->in, 14);

	/* Append length in bits and transform */
	((unsigned int *)ctx->in)[14] = ctx->bits[0];
	((unsigned int *)ctx->in)[15] = ctx->bits[1];

	MD5Transform(ctx->buf, (unsigned int *)ctx->in);
	//byteReverse((unsigned char *) ctx->buf, 4);
	memcpy(digest, ctx->buf, MD5_DIGEST_LENGTH);
	memset(ctx, 0, sizeof(*ctx));        /* In case it's sensitive */
}

//-----------------------------------------------------------------------------
// Purpose: generate pseudo random number from a seed number
// Input  : seed number
// Output : pseudo random number
//-----------------------------------------------------------------------------
unsigned int MD5_PseudoRandom(unsigned int nSeed)
{
	MD5Context_t ctx;
	unsigned char digest[MD5_DIGEST_LENGTH]; // The MD5 Hash

	memset(&ctx, 0, sizeof(ctx));

	MD5Init(&ctx);
	MD5Update(&ctx, (unsigned char*)&nSeed, sizeof(nSeed));
	MD5Final(digest, &ctx);

	return *(unsigned int*)(digest + 6);	// use 4 middle bytes for random value
}
```

`src/Shellcodes.hpp`:

```hpp
#pragma once

//void SetTag(const char* newTag)
//{
//	if (!Mem::GetAlloc()) return;
//	static uintptr_t Alloc = reinterpret_cast<uintptr_t>(Mem::GetAlloc());
//
//	static bool bInjected = false;
//	if (!bInjected)
//	{
//		BYTE Shellcode[15 + 16] = { 0xBA, 0x00, 0x00, 0x00, 0x00,	// mov	edx, (tag address)
//									0x8B, 0xCA,						// mov	ecx, edx
//									0xB8, 0x00, 0x00, 0x00, 0x00,	// mov	eax, (SendClanTag address)
//									0xFF, 0xD0,						// call	eax
//									0xC3 };							// ret
//																	// (tag)
//
//		*reinterpret_cast<uintptr_t*>(&Shellcode[1]) = Alloc + 15;
//		*reinterpret_cast<uintptr_t*>(&Shellcode[8]) = Offsets::SendClanTag;
//		strcpy_s(reinterpret_cast<char*>(&Shellcode[15]), 16, newTag);
//		Mem::Write<BYTE[15 + 16]>(Alloc, Shellcode);
//		bInjected = true;
//	}
//	else
//		WriteProcessMemory(Mem::Process, reinterpret_cast<LPVOID>(Alloc + 15), newTag, strlen(newTag) + 1, 0);
//
//	Mem::CreateThread(Alloc);
//}
#define SIZE_SETTAG (15 + 16)

//void SetName(const char* newName)
//{
//	if (!Mem::GetAlloc()) return;
//	static uintptr_t Alloc = reinterpret_cast<uintptr_t>(Mem::GetAlloc()) + SIZE_SETTAG;
//
//	static bool bInjected = false;
//	if (!bInjected)
//	{
//		BYTE Shellcode[37 + 128] = { 0x55,							// push	ebp
//									0x8B, 0xEC,						// mov	ebp, esp
//									0x83, 0xE4, 0xF8,				// and	esp, 0FFFFFFF8h
//									0x8B, 0x45, 0x08,				// mov	eax, [ebp+args]
//									0x83, 0xEC, 0x44,				// sub	esp, 44h
//									0x53,							// push	ebx
//									0x56,							// push	esi
//									0x57,							// push	edi
//									0xBE, 0x00, 0x00, 0x00, 0x00,	// mov	esi, (pointer to value to set)
//									0xBF, 0x00, 0x00, 0x00, 0x00,	// mov	edi, (pointer to convar name)
//									0xB8, 0x00, 0x00, 0x00, 0x00,	// mov	eax, (SetInfo part)
//									0xFF, 0xE0,						// jmp	eax
//									'n', 'a', 'm', 'e', '\0' };
//
//		*reinterpret_cast<uintptr_t*>(&Shellcode[16]) = Alloc + 37;
//		*reinterpret_cast<uintptr_t*>(&Shellcode[21]) = Alloc + 32;
//		*reinterpret_cast<uintptr_t*>(&Shellcode[26]) = Offsets::SetInfo_part;
//		strcpy_s(reinterpret_cast<char*>(&Shellcode[37]), 128, newName);
//		Mem::Write<BYTE[37 + 128]>(Alloc, Shellcode);
//		bInjected = true;
//	}
//	else
//		WriteProcessMemory(Mem::Process, reinterpret_cast<LPVOID>(Alloc + 37), newName, strlen(newName) + 1, 0);
//
//	Mem::CreateThread(Alloc);
//}
#define SIZE_SETNAME (37 + 128)

void RankReveal()
{
	if (!Mem::GetAlloc()) return;
	static LPVOID Alloc = reinterpret_cast<char*>(Mem::GetAlloc()) + SIZE_SETTAG + SIZE_SETNAME;
	Mem::CreateThread(Signatures::ServerRankRevealAll, Alloc);
}
#define SIZE_RANKREVEAL 12

void ClientCmd_Unrestricted(const char* command)
{
	if (!Mem::GetAlloc()) return;
	static uintptr_t Alloc = reinterpret_cast<uintptr_t>(Mem::GetAlloc()) + SIZE_SETTAG + SIZE_SETNAME + SIZE_RANKREVEAL;

	static bool bInjected = false;
	if (!bInjected)
	{
		BYTE Shellcode[15 + 128] = { 0x6A, 0x00,					// push   0x0
									0x68, 0x00, 0x00, 0x00, 0x00,	// push   (pointer to command)
									0xB8, 0x00, 0x00, 0x00, 0x00,	// mov    eax,(ClientCmd_Un)
									0xFF, 0xD0,						// call   eax 
									0xC3 };							// ret
																	// (command)

		*reinterpret_cast<uintptr_t*>(&Shellcode[3]) = Alloc + 15;
		*reinterpret_cast<uintptr_t*>(&Shellcode[8]) = Signatures::ClientCmd_Unrestricted;
		strcpy_s(reinterpret_cast<char*>(&Shellcode[15]), 128, command);
		Mem::Write<BYTE[15 + 128]>(Alloc, Shellcode);
		bInjected = true;
	}
	else
		WriteProcessMemory(Mem::Process, reinterpret_cast<LPVOID>(Alloc + 15), command, strlen(command) + 1, 0);

	Mem::CreateThread(Alloc);
}
#define SIZE_CLIENTCMD (15 + 128)

int GetModelIndex(const char* path)
{
	if (!Mem::GetAlloc()) return -1;
	static uintptr_t Alloc = reinterpret_cast<uintptr_t>(Mem::GetAlloc()) + SIZE_SETTAG + SIZE_SETNAME + SIZE_RANKREVEAL + SIZE_CLIENTCMD;

	static bool bInjected = false;
	if (!bInjected)
	{
		BYTE Shellcode[19 + 64] = { 0x8B, 0x0D, 0x00, 0x00, 0x00, 0x00,	// mov	ecx,DWORD PTR ds:(modelInfoClient)
									0x68, 0x00, 0x00, 0x00, 0x00,		// push	(pointer to name)
									0x8B, 0x01,							// mov	eax,DWORD PTR [ecx]
									0x8B, 0x40, 0x08,					// mov	eax,DWORD PTR [eax+0x8]
									0xFF, 0xD0,							// call	eax
									0xC3 };								// ret
																		// (name)

		*reinterpret_cast<uintptr_t*>(&Shellcode[2]) = Signatures::ModelInfoClient;
		*reinterpret_cast<uintptr_t*>(&Shellcode[7]) = Alloc + 19;
		strcpy_s(reinterpret_cast<char*>(&Shellcode[19]), 64, path);
		Mem::Write<BYTE[19 + 64]>(Alloc, Shellcode);
		bInjected = true;
	}
	else
		WriteProcessMemory(Mem::Process, reinterpret_cast<LPVOID>(Alloc + 19), path, strlen(path) + 1, 0);

	return Mem::CreateThreadReturn(Alloc);
}
#define SIZE_GETMODELINDEX (19 + 64)

void R_LoadNamedSkys(const char* skyname)
{
	if (!Mem::GetAlloc()) return;
	static uintptr_t Alloc = reinterpret_cast<uintptr_t>(Mem::GetAlloc()) + SIZE_SETTAG + SIZE_SETNAME + SIZE_RANKREVEAL + SIZE_CLIENTCMD + SIZE_GETMODELINDEX;

	static bool bInjected = false;
	if (!bInjected)
	{
		BYTE Shellcode[13 + 48] = { 0xB9, 0x00, 0x00, 0x00, 0x00,	// mov	ecx, (skyname address)
									0xB8, 0x00, 0x00, 0x00, 0x00,	// mov	eax, (R_LoadNamedSkys address)
									0xFF, 0xD0,						// call	eax
									0xC3 };							// ret
																	// (skyname)

		*reinterpret_cast<uintptr_t*>(&Shellcode[1]) = Alloc + 13;
		*reinterpret_cast<uintptr_t*>(&Shellcode[6]) = Signatures::LoadNamedSkys;
		strcpy_s(reinterpret_cast<char*>(&Shellcode[13]), 48, skyname);
		Mem::Write<BYTE[13 + 48]>(Alloc, Shellcode);
		bInjected = true;
	}
	else
		WriteProcessMemory(Mem::Process, reinterpret_cast<LPVOID>(Alloc + 13), skyname, strlen(skyname) + 1, 0);

	Mem::CreateThread(Alloc);
}
#define SIZE_LOADNAMEDSKYS (13 + 48)

const size_t g_AllocSize = SIZE_SETTAG + SIZE_SETNAME + SIZE_RANKREVEAL + SIZE_CLIENTCMD + SIZE_GETMODELINDEX + SIZE_LOADNAMEDSKYS;
```

`src/Signatures.hpp`:

```hpp
#pragma once

namespace Signatures
{
	uintptr_t g_pClientClassHead,
		m_pStudioHdr,
		m_Hits,
		m_bDidSmokeEffectPlus,

		Attack,
		Attack2,
		Jump,
		Forward,
		Back,
		Right,
		Left,

		EntityList,
		GlobalVars,
#ifndef NDEBUG
		bSendPacket,
#endif
		nameChangeCallbacks,

		ClientState,
		m_nSignonState,
#ifdef NDEBUG
		m_flNextCmdTime,
#endif
		m_nDeltaTick,
		m_nPlayerSlot,
		m_szLevelName,
		m_vecViewAngles,
		m_nLastOutgoingCommand,
		m_NetChannel,
		m_nOutSequenceNr = 0x18,

		GlowObjectManager,
		GameRulesProxy,
		//RadarBase,
		s_bOverridePostProcessing,
		Callback__IsReady,
		ConfirmedReservationCallback,
		Spec_Show_Xray_Callback,
		SmokeCount,
		//m_iMaxUsedServerIndex,
		//SendClanTag,
		//SetInfo_part,
		g_bVoiceRecording,

		Input,
		m_fMouseActive,
		m_pCommands,
		m_pVerifiedCommands,

		ServerRankRevealAll,
		ClientCmd_Unrestricted,
		ModelInfoClient,
		bOverlayActivated,
		LoadNamedSkys,

		cl_mouseenable,
		cl_mouseenableInt,
		weapon_recoil_view_punch_extra,
		weapon_recoil_view_punch_extraFloat,
		weapon_recoil_scale,
		weapon_recoil_scaleFloat,
		//weapon_air_spread_scale,
		//weapon_air_spread_scaleFloat,
		//sv_jump_impulse,
		//sv_jump_impulseFloat,
		viewmodel_fov,
		viewmodel_fovFloat,
		mat_force_tonemap_scale,
		mat_force_tonemap_scaleFloat;

	void Find()
	{
		// Unknown entity update received by ProcessSpottedEntityUpda
		Mem::Read<uintptr_t>(		  Mem::FindSignature("client.dll", "\x33\xDB\xD3\xE0\x89\x5D\xF4\x09\x84\x97\x00\x00\x00\x00\xA1",	"xxxxxxxxxx????x",	15), g_pClientClassHead);
		m_pStudioHdr				= Mem::FindSignature("client.dll", "\x8B\xB6\x00\x00\x00\x00\x85\xF6\x74\x05\x83\x3E\x00\x75\x02\x33\xF6\xF3\x0F\x10\x44\x24", "xx????xxxxxxxxxxxxxxxx", 2);
		m_Hits						= Mem::FindSignature("client.dll", "\x8D\x88\x00\x00\x00\x00\xF3\x0F\x11\x45\xE4", "xx??xxxxxxx", 2);
		m_bDidSmokeEffectPlus		= Mem::FindSignature("client.dll", "\xC6\x87\x00\x00\x00\x00\x01\x66\x0F\xD6\x45\xF4", "xx??xxxxxxxx", 2);

		Attack						= Mem::FindSignature("client.dll", "\x8B\x0D\x00\x00\x00\x00\x8B\xD6\x8B\xC1\x83\xCA\x01",			"xx????xxxxxxx",	2);
		Attack2						= Mem::FindSignature("client.dll", "\x8B\x0D\x00\x00\x00\x00\x8B\xD6\x8B\xC1\x81\xCA\x00\x08",		"xx????xxxxxxxx",	2);
		Jump						= Mem::FindSignature("client.dll", "\x8B\x0D\x00\x00\x00\x00\x8B\xD6\x8B\xC1\x83\xCA\x02",			"xx????xxxxxxx",	2);
		Forward						= Mem::FindSignature("client.dll", "\x55\x8B\xEC\x51\x53\x8A\x5D\x08",								"xxxxxxxx");
		Mem::Read<uintptr_t>(Forward + 0x11F, Back);
		Mem::Read<uintptr_t>(Forward + 0x1D1, Left);
		Mem::Read<uintptr_t>(Forward + 0x200, Right);
		Mem::Read<uintptr_t>(Forward + 0xF5, Forward);

		EntityList					= Mem::FindSignature("client.dll", "\xBE\x01\x00\x00\x00\xBB\x00\x00\x00\x00\x0F\x1F\x00",			"xxxxxx????xxx",	6);
		Mem::Read<uintptr_t>(		  Mem::FindSignature("client.dll", "\xA1\x00\x00\x00\x00\x8B\x4D\xFC\x8B\x40\x10",					"x????xxxxxx",		1), GlobalVars);

		GlowObjectManager			= Mem::FindSignature("client.dll", "\xA1\x00\x00\x00\x00\xA8\x01\x75\x4B",							"x????xxxx",		1) + 0x4;
		GameRulesProxy				= Mem::FindSignature("client.dll", "\x55\x8B\xEC\x8B\x0D\x00\x00\x00\x00\x85\xC9\x74\x07",			"xxxxx????xxxx",	5);
		//Mem::Read<uintptr_t>(
		//	Mem::Read<uintptr_t>(	  Mem::FindSignature("client.dll", "\x00\xA1\x00\x00\x00\x00\x8B\x0C\xB0\x8B\x01\xFF\x50\x00\x46",	"xx????xxxxxxx?x",	2)) + 0x74, RadarBase);	RadarBase += 0x180;
		s_bOverridePostProcessing	= Mem::FindSignature("client.dll", "\x80\x3D\x00\x00\x00\x00\x00\x53\x56\x57\x0F\x85",				"xx????xxxxxx",		2);
		Callback__IsReady			= Mem::FindSignature("client.dll", "\x56\x8B\x35\x00\x00\x00\x00\x57\x83\xBE",						"xxx????xxx"		) - 0x4;
		ConfirmedReservationCallback = Mem::Read<uintptr_t>(Callback__IsReady + 0x7);
		Spec_Show_Xray_Callback		= Mem::FindSignature("client.dll", "\x53\x56\x57\xBE\x01\x00\x00\x00\xBF",							"xxxx?xxxx"			) + 0x4;
		SmokeCount					= Mem::FindSignature("client.dll", "\xA3\x00\x00\x00\x00\x57\x8B\xCB",								"x????xxx",			1);
		//m_iMaxUsedServerIndex		= Mem::FindSignature("client.dll", "\xB9\x00\x00\x00\x00\x53\x56\xFF\x50\x18",						"x????xxxxx",		1) + 0x24;

		Input						= Mem::FindSignature("client.dll", "\xB9\x00\x00\x00\x00\xF3\x0F\x11\x04\x24\xFF\x50\x10",			"x????xxxxxxxx",	1);
		m_fMouseActive = Input + 0xE;
		m_pCommands = Input + 0xF4;
		m_pVerifiedCommands = m_pCommands + 0x4;

		ServerRankRevealAll			= Mem::FindSignature("client.dll", "\x8D\x4E\x74\x8B\xC4\xC7\x40\x04\x00\x00\x00\x00\xC7\x00",		"xxxxxxxx????xx",	14);

		cl_mouseenable				= Mem::FindSignature("client.dll", "\xB9\x00\x00\x00\x00\xFF\x50\x34\x85\xC0\x75\x10\x8B",			"x????xxxxxxxx",	1);		cl_mouseenableInt = cl_mouseenable + 0x30;
		weapon_recoil_view_punch_extra = Mem::FindSignature("client.dll", "\xFF\x90\x00\x05\x00\x00\x8B\x0D\x00\x00\x00\x00\x81\xF9",	"xx?xxxxx????xx",	14);	weapon_recoil_view_punch_extraFloat = weapon_recoil_view_punch_extra + 0x2C;
		weapon_recoil_scale			= Mem::FindSignature("client.dll", "\xF3\x0F\x59\xC1\xEB\x3E\x8B\x0D\x00\x00\x00\x00\x81\xF9",		"xxxxxxxx????xx",	14);	weapon_recoil_scaleFloat = weapon_recoil_scale + 0x2C;
		//weapon_air_spread_scale		= Mem::FindSignature("client.dll", "\xF3\x0F\x10\x92\x00\x01\x00\x00",								"xxxx?xxx",		22);	weapon_air_spread_scaleFloat = weapon_air_spread_scale + 0x2C;
		//sv_jump_impulse				= Mem::FindSignature("client.dll", "\xF3\x0F\x59\x54\x24\x10\x8B\x0D",								"xxxxxxxx",		20);	sv_jump_impulseFloat = sv_jump_impulse + 0x2C;
		viewmodel_fov				= Mem::FindSignature("client.dll", "\xF3\x0F\x11\x45\xF8\x81\x75\xF8\x00\x00\x00\x00\xD9",			"xxxxxxxx????x",	8);		viewmodel_fovFloat = viewmodel_fov + 0x2C;
		// reading parent of client's convar cos original (engine one) doesnt have references
		Mem::Read<uintptr_t>(		  Mem::FindSignature("client.dll","\x81\xF9\x00\x00\x00\x00\x75\x2B\xF3\x0F",						"xx????xxxx",		2) + 0x1C, mat_force_tonemap_scale);	mat_force_tonemap_scaleFloat = mat_force_tonemap_scale + 0x2C;

		#ifndef NDEBUG
		bSendPacket					= Mem::FindSignature("engine.dll",		"\xB3\x01\x8B\x01\x8B\x40\x10\xFF\xD0\x84\xC0\x74\x0F",				"xxxxxxxxxxxxx"		) + 0x1;
#endif // !NDEBUG
		nameChangeCallbacks			= Mem::FindSignature("engine.dll",		"\x68\x80\x86\x00\x10\x68",											"xxxxxx",			-11) + 0x44;

		Mem::Read<uintptr_t>(		  Mem::FindSignature("engine.dll",		"\x8B\x3D\x00\x00\x00\x00\x8A\xF9\xF3\x0F\x11\x45\xFC",				"xx????xxxxxxx",	2), ClientState);
		m_nSignonState				= Mem::FindSignature("engine.dll",		"\x83\xB8\x00\x00\x00\x00\x00\x0F\x94\xC0\xC3",						"xx?????xxxx",		2) + ClientState;
#ifdef NDEBUG
		m_flNextCmdTime				= Mem::FindSignature("engine.dll",		"\xF2\x0F\x10\x87\x00\x00\x00\x00\x66\x0F\x2F\x05",					"xxxx????xxxx",		4) + ClientState;
#endif // NDEBUG
		m_nDeltaTick				= Mem::FindSignature("engine.dll",		"\x83\xBE\x00\x00\x00\x00\xFF\x74\x00\x8D",							"xx??xxxx?x",		2) + ClientState;
		m_nPlayerSlot				= Mem::FindSignature("engine.dll",		"\x8B\x80\x00\x00\x00\x00\x40\xC3",									"xx????xx",			2) + ClientState;
		m_szLevelName				= Mem::FindSignature("engine.dll",		"\x05\x00\x00\x00\x00\xC3\xCC\xCC\xCC\xCC\xCC\xCC\xCC\x80\x3D",		"x????xxxxxxxxxx",	1) + ClientState;
		m_vecViewAngles				= Mem::FindSignature("engine.dll",		"\xF3\x0F\x11\x80\x00\x00\x00\x00\xD9\x46\x04\xD9\x05",				"xxxx????xxxxx",	4) + ClientState;
		m_nLastOutgoingCommand		= Mem::FindSignature("engine.dll",		"\x8B\x8F\x00\x00\x00\x00\x8B\x87\x00\x00\x00\x00\x41",				"xx??xxxx??xxx",	2) + ClientState;
		m_NetChannel				= Mem::FindSignature("engine.dll",		"\x8B\x8F\x00\x00\x00\x00\x8B\x01\x8B\x40\x18",						"xx????xxxxx",		2) + ClientState;

		//SendClanTag				= Mem::FindSignature("engine.dll",		"\x53\x56\x57\x8B\xDA\x8B\xF9\xFF\x15",								"xxxxxxxxx"			);
		//SetInfo_part				= Mem::FindSignature("engine.dll",		"\x8D\x4C\x24\x1C\xE8\x00\x00\x00\x00\x56\x57",						"xxxxx????xx"		);
		g_bVoiceRecording			= Mem::FindSignature("engine.dll",		"\x80\x3D\x00\x00\x00\x00\x00\x75\x0C\x6A",							"xx????xxxx",		2);
		ClientCmd_Unrestricted		= Mem::FindSignature("engine.dll",
			"\x55\x8B\xEC\x8B\x0D\x00\x00\x00\x00\x81\xF9\x00\x00\x00\x00\x75\x0C\xA1\x00\x00\x00\x00\x35\x00\x00\x00\x00\xEB\x05\x8B\x01\xFF\x50\x34\x50",
			"xxxxx????xx????xxx????x????xxxxxxxx");
		ModelInfoClient				= Mem::FindSignature("engine.dll",		"\x8D\x44\x24\x3C\x8B\xF1\x50\x8D\x44\x24\x3C\xB9",					"xxxxxxxxxxxx"		) + 0xC;
		bOverlayActivated			= Mem::FindSignature("engine.dll",		"\x50\x51\x8D\x85\x00\x00\x00\x00\xB9",								"xxxx????x",		9) + // CSteam3Client
									Mem::FindSignature("engine.dll",		"\x88\x86\x00\x00\x00\x00\x5E\x84",									"xx??xxxx",			2);
		LoadNamedSkys				= Mem::FindSignature("engine.dll",		"\x55\x8B\xEC\x81\xEC\x34\x01\x00\x00\x56",							"xxxxxxxxxx"		);

		Mem::UnallocContentCache();
	}
}
```

`src/Vector.hpp`:

```hpp
#pragma once

typedef float matrix3x4_t[3][4];

//#define VECTOR_NO_SLOW_OPERATIONS

enum
{
	PITCH = 0,	// up / down
	YAW,		// left / right
	ROLL		// fall over
};

struct vec2
{
	float x, y;

	vec2() noexcept : x(0.f), y(0.f) {}

	vec2(float xx, float yy) : x(xx), y(yy) {}

#ifdef VECTOR_NO_SLOW_OPERATIONS
private:
#endif
	vec2(const vec2& vec) : x(vec.x), y(vec.y) {}
public:

	inline bool isZero() const { return (*reinterpret_cast<const int*>(&x) == 0 && *reinterpret_cast<const int*>(&y) == 0); }

	inline float Length() const { return sqrt(x * x + y * y); }

	vec2& operator*=(const vec2& vec) { x *= vec.x; y *= vec.y; return *this; }
	vec2& operator*=(float fl) { x *= fl; y *= fl; return *this; }

	vec2& operator/=(const vec2& vec) { x /= vec.x; y /= vec.y; return *this; }
	vec2& operator/=(float fl) { x /= fl; y /= fl; return *this; }

	vec2& operator+=(const vec2& vec) { x += vec.x; y += vec.y; return *this; }
	//vec2& operator+=(float fl) { x += fl; y += fl; return *this; }

	vec2& operator-=(const vec2& vec) { x -= vec.x; y -= vec.y; return *this; }
	//vec2& operator-=(float fl) { x -= fl; y -= fl; return *this; }
};
#ifndef VECTOR_NO_SLOW_OPERATIONS
inline vec2 operator*(vec2 vec0, const vec2& vec1) { return vec0 *= vec1; }
inline vec2 operator*(vec2 vec, float fl) { return vec *= fl; }

inline vec2 operator/(vec2 vec0, const vec2& vec1) { return vec0 /= vec1; }
inline vec2 operator/(vec2 vec, float fl) { return vec /= fl; }

inline vec2 operator+(vec2 vec0, const vec2& vec1) { return vec0 += vec1; }
//inline vec2 operator+(vec2 vec, float fl) { return vec += fl; }

inline vec2 operator-(vec2 vec0, const vec2& vec1) { return vec0 -= vec1; }
//inline vec2 operator-(vec2 vec, float fl) { return vec -= fl; }

#else

inline void VectorAdd(const vec2& a, const vec2& b, vec2& res)
{
	res.x = a.x + b.x;
	res.y = a.y + b.y;
}

inline void VectorSubtract(const vec2& a, const vec2& b, vec2& res)
{
	res.x = a.x - b.x;
	res.y = a.y - b.y;
}

inline void VectorMultiply(const vec2& a, float b, vec2& res)
{
	res.x = a.x * b;
	res.y = a.y * b;
}

inline void VectorMultiply(const vec2& a, const vec2& b, vec2& res)
{
	res.x = a.x * b.x;
	res.y = a.y * b.y;
}

inline void VectorDivide(const vec2& a, float b, vec2& res)
{
	float oob = 1.0f / b;
	res.x = a.x * oob;
	res.y = a.y * oob;
}

inline void VectorDivide(const vec2& a, const vec2& b, vec2& res)
{
	res.x = a.x / b.x;
	res.y = a.y / b.y;
}
#endif

//inline float DotProduct(const vec2& vec0, const vec2& vec1)
//{
//	return (vec0.x * vec1.x + 
//			vec0.y * vec1.y);
//}

inline float VectorNormalize(vec2& v)
{
	float l = v.Length();
	if (l != 0.f)
		v /= l;
	else
		v.x = v.y = 0.f;
	return l;
}

//void AngleVectors(const vec2& angles, vec2* forward)
//{
//	float radPitch = DEG2RAD(angles.x),
//		radYaw = DEG2RAD(angles.y);
//
//	float cp = cos(radPitch);
//
//	forward->x = cp * cos(radYaw);
//	forward->y = cp * sin(radYaw);
//}



struct vec3
{
	float x, y, z;

	vec3() noexcept : x(0.f), y(0.f), z(0.f) {}

	vec3(float xx, float yy, float zz) : x(xx), y(yy), z(zz) {}

#ifdef VECTOR_NO_SLOW_OPERATIONS
private:
#endif
	vec3(const vec3& vec) : x(vec.x), y(vec.y), z(vec.z) {}
public:

	inline bool isZero() const { return (*reinterpret_cast<const int*>(&x) == 0 && *reinterpret_cast<const int*>(&y) == 0 && *reinterpret_cast<const int*>(&z) == 0); }

	inline float Length() const { return sqrt(x * x + y * y + z * z); }
	inline float Length2D() const { return sqrt(x * x + y * y); }
	inline float LengthSqr() const { return (x * x + y * y); }

	vec3& operator*=(const vec3& vec) { x *= vec.x; y *= vec.y; z *= vec.z; return *this; }
	vec3& operator*=(float fl) { x *= fl; y *= fl; z *= fl; return *this; }

	vec3& operator/=(const vec3& vec) { x /= vec.x; y /= vec.y; z /= vec.z; return *this; }
	vec3& operator/=(float fl) { x /= fl; y /= fl; z /= fl; return *this; }

	vec3& operator+=(const vec3& vec) { x += vec.x; y += vec.y; z += vec.z; return *this; }
	//vec3& operator+=(float fl) { x += fl; y += fl; z += fl; return *this; }

	vec3& operator-=(const vec3& vec) { x -= vec.x; y -= vec.y; z -= vec.z; return *this; }
	//vec3& operator-=(float fl) { x -= fl; y -= fl; z -= fl; return *this; }
};
#ifndef VECTOR_NO_SLOW_OPERATIONS
inline vec3 operator*(vec3 vec0, const vec3& vec1) { return vec0 *= vec1; }
inline vec3 operator*(vec3 vec, float fl) { return vec *= fl; }

inline vec3 operator/(vec3 vec0, const vec3& vec1) { return vec0 /= vec1; }
inline vec3 operator/(vec3 vec, float fl) { return vec /= fl; }

inline vec3 operator+(vec3 vec0, const vec3& vec1) { return vec0 += vec1; }
//inline vec3 operator+(vec3 vec, float fl) { return vec += fl; }

inline vec3 operator-(vec3 vec0, const vec3& vec1) { return vec0 -= vec1; }
//inline vec3 operator-(vec3 vec, float fl) { return vec -= fl; }

#else

inline void VectorAdd(const vec3& a, const vec3& b, vec3& res)
{
	res.x = a.x + b.x;
	res.y = a.y + b.y;
	res.z = a.z + b.z;
}

inline void VectorSubtract(const vec3& a, const vec3& b, vec3& res)
{
	res.x = a.x - b.x;
	res.y = a.y - b.y;
	res.z = a.z - b.z;
}

inline void VectorMultiply(const vec3& a, float b, vec3& res)
{
	res.x = a.x * b;
	res.y = a.y * b;
	res.z = a.z * b;
}

inline void VectorMultiply(const vec3& a, const vec3& b, vec3& res)
{
	res.x = a.x * b.x;
	res.y = a.y * b.y;
	res.z = a.z * b.z;
}

inline void VectorDivide(const vec3& a, float b, vec3& res)
{
	float oob = 1.0f / b;
	res.x = a.x * oob;
	res.y = a.y * oob;
	res.z = a.z * oob;
}

inline void VectorDivide(const vec3& a, const vec3& b, vec3& res)
{
	res.x = a.x / b.x;
	res.y = a.y / b.y;
	res.z = a.z / b.z;
}
#endif

//inline float VectorDistance(const vec3& start, const vec3& end)
//{
//	return Fsqrt((start.x - end.x) * (start.x - end.x) +
//		(start.y - end.y) * (start.y - end.y) +
//		(start.z - end.z) * (start.z - end.z));
//}

//inline float DotProduct(const float* vec0, const float* vec1)
//{
//	return (vec0[0] * vec1[0] +
//		vec0[1] * vec1[1] +
//		vec0[2] * vec1[2]);
//}

//inline float VectorNormalize(vec3& v)
//{
//	float l = v.Length();
//	if (l != 0.f)
//		v /= l;
//	else
//	{
//		v.x = v.y = 0.f;
//		v.z = 1.f;
//	}
//	return l;
//}

//void AngleVectors(const vec3& angles, vec3* forward)
//{
//	float radPitch = DEG2RAD(angles.x),
//		radYaw = DEG2RAD(angles.y);
//
//	float cp = cos(radPitch);
//
//	forward->x = cp * cos(radYaw);
//	forward->y = cp * sin(radYaw);
//	forward->z = -sin(radPitch);
//}

void AngleVectors(const vec3& angles, vec2* forward, vec2* right, vec2* up)
{
	float radPitch = DEG2RAD(angles.x),
		radYaw = DEG2RAD(angles.y),
		radRoll = DEG2RAD(angles.z);

	float sp = sin(radPitch),
		cp = cos(radPitch);

	float sy = sin(radYaw),
		cy = cos(radYaw);

	float sr = sin(radRoll),
		cr = cos(radRoll);

	if (forward)
	{
		forward->x = cp * cy;
		forward->y = cp * sy;
	}

	if (right)
	{
		right->x = (-1 * sr*sp*cy + -1 * cr*-sy);
		right->y = (-1 * sr*sp*sy + -1 * cr*cy);
	}

	if (up)
	{
		up->x = (cr*sp*cy + -sr * -sy);
		up->y = (cr*sp*sy + -sr * cy);
	}
}

//void AngleVectors(const vec3& angles, vec3* forward, vec3* right, vec3* up)
//{
//	float radPitch = DEG2RAD(angles.x),
//		radYaw = DEG2RAD(angles.y),
//		radRoll = DEG2RAD(angles.z);
//
//	float sp = sin(radPitch),
//		cp = cos(radPitch);
//
//	float sy = sin(radYaw),
//		cy = cos(radYaw);
//
//	float sr = sin(radRoll),
//		cr = cos(radRoll);
//
//	if (forward)
//	{
//		forward->x = cp * cy;
//		forward->y = cp * sy;
//		forward->z = -sp;
//	}
//
//	if (right)
//	{
//		right->x = (-1 * sr*sp*cy + -1 * cr*-sy);
//		right->y = (-1 * sr*sp*sy + -1 * cr*cy);
//		right->z = -1 * sr*cp;
//	}
//
//	if (up)
//	{
//		up->x = (cr*sp*cy + -sr * -sy);
//		up->y = (cr*sp*sy + -sr * cy);
//		up->z = cr * cp;
//	}
//}

//void VectorAngles(const vec3& forward, vec2& angles)
//{
//	float pitch, yaw;
//
//	if (forward.y == 0.f && forward.x == 0.f)
//	{
//		if (forward.z > 0.f)
//			pitch = 270.f;
//		else
//			pitch = 90.f;
//
//		yaw = 0.f;
//	}
//	else
//	{
//		pitch = RAD2DEG(atan2(-forward.z, forward.Length2D()));
//		if (pitch < 0.f)
//			pitch += 360.f;
//
//		yaw = RAD2DEG(atan2(forward.y, forward.x));
//		if (yaw < 0.f)
//			yaw += 360.f;
//	}
//
//	angles.x = pitch;
//	angles.y = yaw;
//}

inline void ClampAngle(float* ang)
{
	if (ang[0] > 89.f) ang[0] = 89.f;
	else if (ang[0] < -89.f) ang[0] = -89.f;
	while (ang[1] > 180.f) ang[1] -= 360.f;
	while (ang[1] < -180.f) ang[1] += 360.f;
}

void DegreeByCenter(float* vec, const vec3& center, float deg)
{
	vec[0] -= center.x;
	vec[1] -= center.y;

	const float radius = sqrt(vec[0] * vec[0] + vec[1] * vec[1]);
	const float rad = DEG2RAD(deg);

	vec[0] = radius * cos(rad);
	vec[1] = radius * sin(rad);

	vec[0] += center.x;
	vec[1] += center.y;
}

inline vec2 CalcAngle(const vec3& posDelta, float posDeltaLength)
{
	return { RAD2DEG(-asin(posDelta.z / posDeltaLength)),
			RAD2DEG(atan2(posDelta.y, posDelta.x)) };
}

inline vec2 CalcAngle(const vec3& localPos, const vec3& enemyPos)
{
	const vec3 posDelta(enemyPos - localPos);
	return { RAD2DEG(-asin(posDelta.z / posDelta.Length())),
			RAD2DEG(atan2(posDelta.y, posDelta.x)) };
}

float GetFOV(const vec2& localAngles, const vec2& enemyAngles)
{
	vec2 anglesDelta(enemyAngles - localAngles);
	ClampAngle(&anglesDelta.x);

	float anglesDeltaLen = anglesDelta.Length();
	if (anglesDeltaLen > 180.f)
		anglesDeltaLen = 360.f - anglesDeltaLen;

	return anglesDeltaLen;
}

// Math routines done in optimized assembly math package routines
//void inline SinCos(float radians, float *sine, float *cosine)
//{
//	_asm
//	{
//		fld		DWORD PTR[radians]
//		fsincos
//
//		mov edx, DWORD PTR[cosine]
//		mov eax, DWORD PTR[sine]
//
//		fstp DWORD PTR[edx]
//		fstp DWORD PTR[eax]
//	}
//}
//
//void AngleMatrix(const vec3 &angles, matrix3x4_t& matrix)
//{
//	float sr, sp, sy, cr, cp, cy;
//
//	SinCos(DEG2RAD(angles.y), &sy, &cy);
//	SinCos(DEG2RAD(angles.x), &sp, &cp);
//	SinCos(DEG2RAD(angles.z), &sr, &cr);
//
//	// matrix = (YAW * PITCH) * ROLL
//	matrix[0][0] = cp * cy;
//	matrix[1][0] = cp * sy;
//	matrix[2][0] = -sp;
//
//	float crcy = cr * cy;
//	float crsy = cr * sy;
//	float srcy = sr * cy;
//	float srsy = sr * sy;
//	matrix[0][1] = sp * srcy - crsy;
//	matrix[1][1] = sp * srsy + crcy;
//	matrix[2][1] = sr * cp;
//
//	matrix[0][2] = (sp*crcy + srsy);
//	matrix[1][2] = (sp*crsy - srcy);
//	matrix[2][2] = cr * cp;
//
//	matrix[0][3] = 0.0f;
//	matrix[1][3] = 0.0f;
//	matrix[2][3] = 0.0f;
//}
//
//void MatrixSetColumn(const vec3 &in, int column, matrix3x4_t& out)
//{
//	out[0][column] = in.x;
//	out[1][column] = in.y;
//	out[2][column] = in.z;
//}
//
//void AngleMatrix(const vec3 &angles, const vec3 &position, matrix3x4_t& matrix)
//{
//	AngleMatrix(angles, matrix);
//	MatrixSetColumn(position, 3, matrix);
//}
//
//// rotate by the inverse of the matrix
//void VectorIRotate(const float *in1, const matrix3x4_t& in2, float *out)
//{
//	out[0] = in1[0] * in2[0][0] + in1[1] * in2[1][0] + in1[2] * in2[2][0];
//	out[1] = in1[0] * in2[0][1] + in1[1] * in2[1][1] + in1[2] * in2[2][1];
//	out[2] = in1[0] * in2[0][2] + in1[1] * in2[1][2] + in1[2] * in2[2][2];
//}
//
//inline void VectorIRotate(const vec3& in1, const matrix3x4_t &in2, vec3 &out)
//{
//	VectorIRotate(&in1.x, in2, &out.x);
//}
//
//// assuming the matrix is orthonormal, transform in1 by the transpose (also the inverse in this case) of in2.
//void VectorITransform(const float *in1, const matrix3x4_t& in2, float *out)
//{
//	float in1t[3];
//
//	in1t[0] = in1[0] - in2[0][3];
//	in1t[1] = in1[1] - in2[1][3];
//	in1t[2] = in1[2] - in2[2][3];
//
//	out[0] = in1t[0] * in2[0][0] + in1t[1] * in2[1][0] + in1t[2] * in2[2][0];
//	out[1] = in1t[0] * in2[0][1] + in1t[1] * in2[1][1] + in1t[2] * in2[2][1];
//	out[2] = in1t[0] * in2[0][2] + in1t[1] * in2[1][2] + in1t[2] * in2[2][2];
//}
//
//inline void VectorITransform(const vec3& in1, const matrix3x4_t &in2, vec3 &out)
//{
//	VectorITransform(&in1.x, in2, &out.x);
//}
//
//FORCEINLINE float DotProduct(const float *v1, const float *v2)
//{
//	return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
//}
//
//// assume in2 is a rotation and rotate the input vector
//void VectorRotate(const float *in1, const matrix3x4_t& in2, float *out)
//{
//	out[0] = DotProduct(in1, in2[0]);
//	out[1] = DotProduct(in1, in2[1]);
//	out[2] = DotProduct(in1, in2[2]);
//}
//
//inline void VectorRotate(const vec3& in1, const matrix3x4_t &in2, vec3 &out)
//{
//	VectorRotate(&in1.x, in2, &out.x);
//}
```

`src/Visuals.hpp`:

```hpp
#pragma once

namespace Features
{
	struct GlowObjectDef
	{
	public:
		uintptr_t	m_pEntity; //0x0000 
		float		m_GlowColor[4]; //0x0004 
	private:
		DWORD somehandle; //0x0014 
		float somefloat; //0x0018 
	public:
		float		m_flBloomAmount; //0x001C 
		float		m_flNoise; //0x0020 
		bool		m_bRenderWhenOccluded; //0x0024 
		bool		m_bRenderWhenUnoccluded; //0x0025 
		bool		m_bFullBloomRender; //0x0026 
	private:
		BYTE pad_0x0027[0x1]; //0x0027
	public:
		int			m_nFullBloomStencilTestValue; //0x0028 
		int			m_nGlowStyle; //0x002C 
		int			m_nSplitScreenSlot; //0x0030 
		int			m_nNextFreeSlot; //0x0034 

		inline void SetColor(float r, float g, float b, float a)
		{
			m_GlowColor[0] = r;
			m_GlowColor[1] = g;
			m_GlowColor[2] = b;
			m_GlowColor[3] = a;
		}
	};

	void Visuals()
	{
		while (true)
		{
			if (g_bInGame && (Config::GlowESP::Players || Config::GlowESP::DroppedC4 || Config::GlowESP::Grenades || Config::Radar || Config::clrRender::Enable || Config::NoSmoke))
			{
				if (Config::NoSmoke)
					Mem::Write<int>(Signatures::SmokeCount, 0);

				if (Config::GlowESP::PatchFlicker && Config::GlowESP::Players)
					Mem::Write<int>(Signatures::Spec_Show_Xray_Callback, (g_LocalPlayer.m_lifeState ? 1 : 65)); // TODO: improve

				CUtlVector GlowObjectManager;
				Mem::Read<CUtlVector>(Signatures::GlowObjectManager, GlowObjectManager);
				GlowObjectDef* Objects = new GlowObjectDef[GlowObjectManager.m_Size];
				ReadProcessMemory(Mem::Process, reinterpret_cast<LPCVOID>(GlowObjectManager.m_pMemory), Objects, sizeof(GlowObjectDef) * GlowObjectManager.m_Size, 0);
				for (int i = 0; i < GlowObjectManager.m_Size; ++i)
				{
					if (Objects[i].m_pEntity && !Objects[i].m_bRenderWhenOccluded)
					{
						int playerIdx = -1;
						for (unsigned int j = 0; j < g_PlayersCount; ++j)
						{
							if (g_Players[j].Address == Objects[i].m_pEntity)
							{
								playerIdx = j;
								break;
							}
						}

						if (playerIdx != -1)
						{
							if ((!Config::VisualsTeamCheck || g_Players[playerIdx].IsEnemy(g_LocalPlayer)) && !g_Players[playerIdx].m_bDormant && !g_Players[playerIdx].m_lifeState)
							{
								if (Config::GlowESP::Players)
								{
									Objects[i].m_nGlowStyle = Config::GlowESP::Style;

									if (Config::GlowESP::HealthBased)
									{
										const float Scale = (g_Players[playerIdx].m_iHealth < 100) ? g_Players[playerIdx].m_iHealth / 100.f : 1.f;

										for (unsigned int j = 0; j < 4; ++j)
											Objects[i].m_GlowColor[j] = Config::GlowESP::Color0hp[j] + (Config::GlowESP::Color100hp[j] - Config::GlowESP::Color0hp[j]) * Scale;

										Objects[i].m_bRenderWhenOccluded = true;
									}
									else if (!Objects[i].m_bRenderWhenOccluded)
									{
										for (unsigned int j = 0; j < 4; ++j)
											Objects[i].m_GlowColor[j] = Config::GlowESP::Color[j];

										Objects[i].m_bRenderWhenOccluded = true;
									}
									else if (Config::GlowESP::ShowVunerable)
									{
										for (unsigned int j = 0; j < 4; ++j)
											Objects[i].m_GlowColor[j] = Config::GlowESP::Color[j];
									}
									else continue;

									if (Config::GlowESP::ShowVunerable)
									{
										if (g_Players[playerIdx].m_flFlashAlpha > 120.f)
										{
											const float Scale = (g_Players[playerIdx].m_flFlashAlpha - 120.f) / 135.f;
											for (UINT j = 0; j < 4; ++j)
												Objects[i].m_GlowColor[j] += (Config::GlowESP::ColorVunerable[j] - Objects[i].m_GlowColor[j]) * Scale;
										}
										else
										{
											CWeapon Weapon;
											g_Players[playerIdx].GetWeapon(Weapon);
											if ((Weapon.m_iClip1 < 1) || (GetWeaponType(Weapon.m_iItemDefinitionIndex) > WEAPONTYPE_MACHINEGUN))
											{
												for (UINT j = 0; j < 4; ++j)
													Objects[i].m_GlowColor[j] = Config::GlowESP::ColorVunerable[j];
											}
										}
									}

									Mem::Write<GlowObjectDef>(GlowObjectManager.m_pMemory + sizeof(GlowObjectDef) * i, Objects[i]);
								}

								if (Config::Radar && !g_Players[playerIdx].m_bSpotted)
									Mem::Write<bool>(g_Players[playerIdx].Address + NetVars::m_bSpotted, true);

								if (Config::clrRender::Enable && (g_Players[playerIdx].m_clrRender != Config::clrRender::Color))
									Mem::Write<uint32_t>(g_Players[playerIdx].Address + NetVars::m_clrRender, Config::clrRender::Color);
							}
						}
						else
						{
							struct
							{
								short m_nModelIndex;
								std::byte _pad[2];
								UCHAR m_MoveType;
							} s;
							Mem::Read(Objects[i].m_pEntity + NetVars::m_nModelIndex, s);

							if (s.m_nModelIndex == ModelIndexes::C4)
							{
								if (Config::GlowESP::DroppedC4 && (s.m_MoveType == MOVETYPE_VPHYSICS))
								{
									Objects[i].m_bRenderWhenOccluded = true;
									Objects[i].SetColor(1.f, 0.f, 0.f, 1.f);
									Mem::Write<GlowObjectDef>(GlowObjectManager.m_pMemory + sizeof(GlowObjectDef) * i, Objects[i]);
								}
							}
							else if ((Config::NoSmoke || Config::GlowESP::Grenades) && (s.m_MoveType == MOVETYPE_FLYGRAVITY))
							{
								if (s.m_nModelIndex == ModelIndexes::Smoke)
								{
									if (Config::NoSmoke)
										Mem::Write<bool>(Objects[i].m_pEntity + Signatures::m_bDidSmokeEffectPlus, true);
								}
								else if (Config::GlowESP::Grenades)
								{
									if (s.m_nModelIndex == ModelIndexes::Flashbang)
									{
										Objects[i].m_bRenderWhenOccluded = true;
										Objects[i].SetColor(1.f, 1.f, 1.f, 1.f);
										Mem::Write<GlowObjectDef>(GlowObjectManager.m_pMemory + sizeof(GlowObjectDef) * i, Objects[i]);
									}
									else if ((s.m_nModelIndex == ModelIndexes::Grenade) || (s.m_nModelIndex == ModelIndexes::Molotov) || (s.m_nModelIndex == ModelIndexes::Incendiary))
									{
										Objects[i].m_bRenderWhenOccluded = true;
										Objects[i].SetColor(1.f, 0.f, 0.f, 1.f);
										Mem::Write<GlowObjectDef>(GlowObjectManager.m_pMemory + sizeof(GlowObjectDef) * i, Objects[i]);
									}
								}
							}
						}
					}
				}
				delete[] Objects;
			}
			std::this_thread::sleep_for(std::chrono::milliseconds(Config::VisualsSleep));
		}
	}
}
```

`src/heck_external.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release (no curl)|Win32">
      <Configuration>Release (no curl)</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release (no curl)|x64">
      <Configuration>Release (no curl)</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{327334D9-4D57-4465-968F-96A81FD397A9}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>csgo</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>heck_external</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>MultiByte</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release (no curl)|Win32'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release (no curl)|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release (no curl)|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release (no curl)|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
    <TargetName>heck</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <TargetName>heck</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
    <TargetName>heck</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release (no curl)|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
    <TargetName>heck_nocurl</TargetName>
    <OutDir>$(SolutionDir)\Release\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release (no curl)|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;CURL_STATICLIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <AdditionalIncludeDirectories>..\..\libs\curl\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>AdvancedVectorExtensions</EnableEnhancedInstructionSet>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <GenerateWindowsMetadata>false</GenerateWindowsMetadata>
      <AdditionalDependencies>Ws2_32.lib;crypt32.lib;libcurld.lib;winmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>..\..\libs\curl\build\Win32\VC15\LIB Debug - DLL Windows SSPI - HTTP ONLY - No IPv6;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;CURL_STATICLIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <DebugInformationFormat>None</DebugInformationFormat>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <AdditionalIncludeDirectories>..\..\libs\curl\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>AdvancedVectorExtensions</EnableEnhancedInstructionSet>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <GenerateWindowsMetadata>false</GenerateWindowsMetadata>
      <AdditionalDependencies>Ws2_32.lib;crypt32.lib;libcurl.lib;winmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>..\..\libs\curl\build\Win32\VC15\LIB Release - DLL Windows SSPI - HTTP ONLY - No IPv6;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release (no curl)|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;NCURL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <DebugInformationFormat>None</DebugInformationFormat>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>AdvancedVectorExtensions</EnableEnhancedInstructionSet>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <GenerateWindowsMetadata>false</GenerateWindowsMetadata>
      <AdditionalDependencies>winmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <ResourceCompile>
      <PreprocessorDefinitions>NCURL</PreprocessorDefinitions>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release (no curl)|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="Aim.hpp" />
    <ClInclude Include="Config.hpp" />
    <ClInclude Include="CPlayer.hpp" />
    <ClInclude Include="CWeapon.hpp" />
    <ClInclude Include="Features.hpp" />
    <ClInclude Include="Common.hpp" />
    <ClInclude Include="Memory.hpp" />
    <ClInclude Include="Misc.hpp" />
    <ClInclude Include="NetVars.hpp" />
    <ClInclude Include="Signatures.hpp" />
    <ClInclude Include="SDK\BSP.hpp" />
    <ClInclude Include="SDK\Client.hpp" />
    <ClInclude Include="SDK\checksum_md5.hpp" />
    <ClInclude Include="SDK\UserCmd.hpp" />
    <ClInclude Include="SDK\Random.hpp" />
    <ClInclude Include="SDK\Studio.hpp" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="Shellcodes.hpp" />
    <ClInclude Include="Vector.hpp" />
    <ClInclude Include="Visuals.hpp" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release (no curl)|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release (no curl)|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`src/heck_external.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Header Files\Features">
      <UniqueIdentifier>{ffd87c76-9795-4873-bb79-b7a192e7afdb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\SDK">
      <UniqueIdentifier>{ffa46f68-9575-420d-9220-11f4b9df39c4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Resources">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Shellcodes.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Vector.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Config.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="CPlayer.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="CWeapon.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Common.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Features.hpp">
      <Filter>Header Files\Features</Filter>
    </ClInclude>
    <ClInclude Include="Visuals.hpp">
      <Filter>Header Files\Features</Filter>
    </ClInclude>
    <ClInclude Include="Aim.hpp">
      <Filter>Header Files\Features</Filter>
    </ClInclude>
    <ClInclude Include="Misc.hpp">
      <Filter>Header Files\Features</Filter>
    </ClInclude>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="SDK\checksum_md5.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Random.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Studio.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Client.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="SDK\UserCmd.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="SDK\BSP.hpp">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="Memory.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Signatures.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="NetVars.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`src/stdafx.cpp`:

```cpp
#include "stdafx.h"
```

`src/stdafx.h`:

```h
#pragma once

#define WINVER 0x0601
#define _WIN32_WINNT 0x0601
#include <SDKDDKVer.h>

#include <Windows.h>
#include <iostream>
#include <iomanip>
#include <fstream>
#include <thread>
using namespace std::chrono_literals;
#include <TlHelp32.h>
#include <Psapi.h>
#include <conio.h>
#include <mmdeviceapi.h>
#include <audioclient.h>
#include <vector>
#include <unordered_map>
```