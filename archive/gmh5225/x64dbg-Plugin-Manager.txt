Project Path: arc_gmh5225_x64dbg-Plugin-Manager_wre1oipp

Source Tree:

```txt
arc_gmh5225_x64dbg-Plugin-Manager_wre1oipp
├── Formats
├── LICENSE
├── README.md
├── XArchive
├── XGithub
├── XOptions
├── XShortcuts
├── XUpdate
├── build.pri
├── build_tools
├── build_win32.bat
├── changelog.txt
├── console_source
│   ├── console_source.pro
│   ├── consoleoutput.cpp
│   ├── consoleoutput.h
│   └── main_console.cpp
├── convertprocess.cpp
├── convertprocess.h
├── createmoduleprocess.cpp
├── createmoduleprocess.h
├── docs
│   ├── screenshot_console.jpg
│   └── screenshot_gui.jpg
├── getfilefromserverprocess.cpp
├── getfilefromserverprocess.h
├── global.h
├── gui_source
│   ├── dialogabout.cpp
│   ├── dialogabout.h
│   ├── dialogabout.ui
│   ├── dialogconvertprocess.cpp
│   ├── dialogconvertprocess.h
│   ├── dialogconvertprocess.ui
│   ├── dialogcreatemodule.cpp
│   ├── dialogcreatemodule.h
│   ├── dialogcreatemodule.ui
│   ├── dialogcreatemoduleprocess.cpp
│   ├── dialogcreatemoduleprocess.h
│   ├── dialogcreatemoduleprocess.ui
│   ├── dialoggetfilefromserverprocess.cpp
│   ├── dialoggetfilefromserverprocess.h
│   ├── dialoggetfilefromserverprocess.ui
│   ├── dialoginfomodule.cpp
│   ├── dialoginfomodule.h
│   ├── dialoginfomodule.ui
│   ├── dialoginstallmodule.cpp
│   ├── dialoginstallmodule.h
│   ├── dialoginstallmodule.ui
│   ├── dialoginstallmoduleprocess.cpp
│   ├── dialoginstallmoduleprocess.h
│   ├── dialoginstallmoduleprocess.ui
│   ├── dialogoptions.cpp
│   ├── dialogoptions.h
│   ├── dialogoptions.ui
│   ├── dialogremovemodule.cpp
│   ├── dialogremovemodule.h
│   ├── dialogremovemodule.ui
│   ├── dialogremovemoduleprocess.cpp
│   ├── dialogremovemoduleprocess.h
│   ├── dialogremovemoduleprocess.ui
│   ├── dialogupdategitprocess.cpp
│   ├── dialogupdategitprocess.h
│   ├── dialogupdategitprocess.ui
│   ├── gui_source.pro
│   ├── guimainwindow.cpp
│   ├── guimainwindow.h
│   ├── guimainwindow.ui
│   ├── images
│   │   └── main.png
│   ├── main_gui.cpp
│   ├── plugininfowidget.cpp
│   ├── plugininfowidget.h
│   ├── plugininfowidget.ui
│   └── resources.qrc
├── icons
│   └── main.ico
├── installmoduleprocess.cpp
├── installmoduleprocess.h
├── release_version.txt
├── removemoduleprocess.cpp
├── removemoduleprocess.h
├── ssl
│   ├── libeay32.dll
│   └── ssleay32.dll
├── updategitprocess.cpp
├── updategitprocess.h
├── utils.cpp
├── utils.h
└── x64dbgPluginManager_source.pro

```

`LICENSE`:

```
MIT License

Copyright (c) 2019-2022 hors<horsicq@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
[![Donate](https://img.shields.io/badge/Donate-PayPal-green.svg)](https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=NF3FBD3KHMXDN)
[![GitHub tag (latest SemVer)](https://img.shields.io/github/tag/horsicq/x64dbg-Plugin-Manager.svg)](https://github.com/horsicq/x64dbg-Plugin-Manager/releases)
[![GitHub All Releases](https://img.shields.io/github/downloads/horsicq/x64dbg-Plugin-Manager/total.svg)](https://github.com/horsicq/x64dbg-Plugin-Manager/releases)

x64dbg Plugin Manager
=======

![alt text](https://github.com/horsicq/x64dbg-Plugin-Manager/blob/master/docs/screenshot_gui.jpg "Screenshot gui")
![alt text](https://github.com/horsicq/x64dbg-Plugin-Manager/blob/master/docs/screenshot_console.jpg "Screenshot console")

Console example
=======

x64plgmnrc.exe -G "C:\x64dbg_root"  // Set root path for x64dbg

x64plgmnrc.exe -U                   // Update list from server

x64plgmnrc.exe -S                   // Show list of plugins

x64plgmnrc.exe -i x64core           // Install last version of x64dbg

x64plgmnrc.exe -i AdvancedScript    // install AdvancedScript


# How to build on Windows
=======

Install Visual Studio 2013: https://github.com/horsicq/build_tools

Install Qt 5.6.3 for VS2013(x86): https://github.com/horsicq/build_tools

Install 7-Zip: https://github.com/horsicq/build_tools

Clone project: git clone --recursive https://github.com/horsicq/x64dbg-Plugin-Manager.git

Edit build_win32.bat ( check VS_PATH,  SEVENZIP_PATH, QT_PATH variables)

Run build_win32.bat


# How to add new plugin
=======

You should make PR with new plugin to https://github.com/x64dbg/PluginManager/blob/master/list.json

```

`build.pri`:

```pri
# For additional build parameters

CONFIG(debug, debug|release) {
    DESTDIR = $$PWD/build/debug
} else {
    DESTDIR = $$PWD/build/release
}
# Windows minGW
win32-g++* {
    QMAKE_CFLAGS  += -Wno-missing-field-initializers
    QMAKE_CFLAGS  += -Werror=format-security
    QMAKE_CFLAGS  += -Wno-unused-parameter
    QMAKE_CXXFLAGS += -Wno-missing-field-initializers
    QMAKE_CXXFLAGS += -Werror=format-security
    QMAKE_CXXFLAGS += -Wno-unused-parameter
}
# Linux gcc
unix:!macx {
    QMAKE_CFLAGS  += -Wno-missing-field-initializers
    QMAKE_CFLAGS  += -Werror=format-security
    QMAKE_CFLAGS  += -Wno-unused-parameter
    QMAKE_CXXFLAGS += -Wno-missing-field-initializers
    QMAKE_CXXFLAGS += -Werror=format-security
    QMAKE_CXXFLAGS += -Wno-unused-parameter
}
# macOS clang
unix:macx {
    QMAKE_CFLAGS  += -Wno-missing-field-initializers
    QMAKE_CFLAGS  += -Werror=format-security
    QMAKE_CFLAGS  += -Wno-unused-parameter
    QMAKE_CXXFLAGS += -Wno-missing-field-initializers
    QMAKE_CXXFLAGS += -Werror=format-security
    QMAKE_CXXFLAGS += -Wno-unused-parameter
}
# Windows MSVC TODO check ARM/ARM64 !!!
!contains(QMAKE_TARGET.arch, x86_64) {
    win32-msvc2013{
       # VS2013
       # Windows XP support
       QMAKE_CXXFLAGS  += /D_USING_V110_SDK71_
       QMAKE_LFLAGS += /SUBSYSTEM:WINDOWS,5.01
    }
    win32-msvc{ 
       # VS2017
       # Windows XP support
       QMAKE_CXXFLAGS  += /D_USING_V110_SDK71_
       QMAKE_LFLAGS += /SUBSYSTEM:WINDOWS,5.01
    }
    # TODO more MSVC versions 2019
}

contains(DEFINES, CREATE_PDB) {
    QMAKE_CXXFLAGS += /Zi
    QMAKE_LFLAGS += /DEBUG 
}

```

`build_win32.bat`:

```bat
set VS_PATH="C:\Program Files (x86)\Microsoft Visual Studio 12.0"
set SEVENZIP_PATH="C:\Program Files\7-Zip"
set QT_PATH="C:\Qt5.6.3\5.6.3\msvc2013"

set BUILD_NAME=x64plgmnr_win32_portable
set CUR_DRIVE=%CD:~0,2%
set SOURCE_PATH=%~dp0
mkdir %SOURCE_PATH%\build
mkdir %SOURCE_PATH%\build\loader
mkdir %SOURCE_PATH%\release
set /p RELEASE_VERSION=<%SOURCE_PATH%\release_version.txt

set QT_SPEC=win32-msvc2013
call %VS_PATH%\VC\bin\vcvars32.bat
set ZIP_NAME=%BUILD_NAME%_%RELEASE_VERSION%

%CUR_DRIVE%
cd %SOURCE_PATH%

cd %SOURCE_PATH%\gui_source
%QT_PATH%\bin\qmake.exe gui_source.pro -r -spec %QT_SPEC% "CONFIG+=release"

nmake Makefile.Release clean
nmake
del Makefile
del Makefile.Release
del Makefile.Debug

cd %SOURCE_PATH%

cd %SOURCE_PATH%\console_source
%QT_PATH%\bin\qmake.exe console_source.pro -r -spec %QT_SPEC% "CONFIG+=release"

nmake Makefile.Release clean
nmake
del Makefile
del Makefile.Release
del Makefile.Debug

cd %SOURCE_PATH%

rem rmdir /s /q release\
mkdir %SOURCE_PATH%\release

rem portable
rmdir /s /q %SOURCE_PATH%\release\%BUILD_NAME%\
mkdir %SOURCE_PATH%\release\%BUILD_NAME%
mkdir %SOURCE_PATH%\release\%BUILD_NAME%\platforms

copy %SOURCE_PATH%\build\release\x64plgmnr.exe %SOURCE_PATH%\release\%BUILD_NAME%\
copy %SOURCE_PATH%\build\release\x64plgmnrc.exe %SOURCE_PATH%\release\%BUILD_NAME%\

copy %QT_PATH%\bin\Qt5Widgets.dll %SOURCE_PATH%\release\%BUILD_NAME%\
copy %QT_PATH%\bin\Qt5Gui.dll %SOURCE_PATH%\release\%BUILD_NAME%\
copy %QT_PATH%\bin\Qt5Core.dll %SOURCE_PATH%\release\%BUILD_NAME%\
copy %QT_PATH%\bin\Qt5Network.dll %SOURCE_PATH%\release\%BUILD_NAME%\
copy %QT_PATH%\plugins\platforms\qwindows.dll %SOURCE_PATH%\release\%BUILD_NAME%\platforms\
copy %SOURCE_PATH%\ssl\libeay32.dll %SOURCE_PATH%\release\%BUILD_NAME%\
copy %SOURCE_PATH%\ssl\ssleay32.dll %SOURCE_PATH%\release\%BUILD_NAME%\

copy %VS_PATH%\VC\redist\x86\Microsoft.VC120.CRT\msvcp120.dll %SOURCE_PATH%\release\%BUILD_NAME%\
copy %VS_PATH%\VC\redist\x86\Microsoft.VC120.CRT\msvcr120.dll %SOURCE_PATH%\release\%BUILD_NAME%\

cd %SOURCE_PATH%\release
if exist %BUILD_NAME%_%RELEASE_VERSION%.zip del %BUILD_NAME%_%RELEASE_VERSION%.zip
%SEVENZIP_PATH%\7z.exe a %BUILD_NAME%_%RELEASE_VERSION%.zip %BUILD_NAME%\*
cd %SOURCE_PATH%

cd %SOURCE_PATH%\release\%BUILD_NAME%
ren Example Example1

cd %SOURCE_PATH%

rmdir /s /q %SOURCE_PATH%\release\%BUILD_NAME%\

goto:eof

```

`changelog.txt`:

```txt
0.04
-----------------------------------------------------------------------
[+] Fixed AV false detects
[+] GitHub API.
[+] Minor bugs fixed
#######################################################################
```

`console_source/console_source.pro`:

```pro
QT -= gui
QT += network

CONFIG += c++11 console
CONFIG -= app_bundle

TARGET = x64plgmnrc

include(../build.pri)

SOURCES += \
    ../createmoduleprocess.cpp \
    ../getfilefromserverprocess.cpp \
    ../installmoduleprocess.cpp \
    ../removemoduleprocess.cpp \
    ../updategitprocess.cpp \
    ../convertprocess.cpp \
    ../utils.cpp \
    main_console.cpp \
    consoleoutput.cpp

HEADERS += \
    ../createmoduleprocess.h \
    ../getfilefromserverprocess.h \
    ../global.h \
    ../installmoduleprocess.h \
    ../removemoduleprocess.h \
    ../updategitprocess.h \
    ../convertprocess.h \
    ../utils.h \
    consoleoutput.h

!contains(XCONFIG, xarchive) {
    XCONFIG += xarchive
    include(../XArchive/xarchive.pri)
}

!contains(XCONFIG, xgithub) {
    XCONFIG += xgithub
    include(../XGithub/xgithub.pri)
}

!contains(XCONFIG, xoptions) {
    XCONFIG += xoptions
    include(../XOptions/xoptions.pri)
}

```

`console_source/consoleoutput.cpp`:

```cpp
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#include "consoleoutput.h"

ConsoleOutput::ConsoleOutput(QObject *pParent) : QObject(pParent)
{
}

void ConsoleOutput::infoMessage(QString sText)
{
    QString _sText = sText;
    printf("%s\n", _sText.toLatin1().data());
}

void ConsoleOutput::errorMessage(QString sText)
{
    QString _sText = sText;
    printf("Error: %s\n", _sText.toLatin1().data());
}

```

`console_source/consoleoutput.h`:

```h
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#ifndef CONSOLEOUTPUT_H
#define CONSOLEOUTPUT_H

#include <QObject>

class ConsoleOutput : public QObject {
    Q_OBJECT
public:
    explicit ConsoleOutput(QObject *pParent = nullptr);

public slots:
    void infoMessage(QString sText);
    void errorMessage(QString sText);
};

#endif  // CONSOLEOUTPUT_H

```

`console_source/main_console.cpp`:

```cpp
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#include <QCommandLineOption>
#include <QCommandLineParser>
#include <QCoreApplication>

#include "../convertprocess.h"
#include "../createmoduleprocess.h"
#include "../getfilefromserverprocess.h"
#include "../global.h"
#include "../installmoduleprocess.h"
#include "../removemoduleprocess.h"
#include "../updategitprocess.h"
#include "../utils.h"
#include "consoleoutput.h"
#include "xoptions.h"

enum PLGMNGREXITCODE {
    PLGMNGREXITCODE_NOARGS = 0,
    PLGMNGREXITCODE_ERROR,
    PLGMNGREXITCODE_DATAERROR,
    PLGMNGREXITCODE_INSTALLFILES,
    PLGMNGREXITCODE_INSTALLPLUGINS,
    PLGMNGREXITCODE_LISTNAMEISEMPTY,
    PLGMNGREXITCODE_NOINPUTFILES,
    PLGMNGREXITCODE_NOPLUGINSINSTALLED,
    PLGMNGREXITCODE_PLUGINCREATED,
    PLGMNGREXITCODE_CANNOTCREATESERVERLIST,
    PLGMNGREXITCODE_SHOWSERVERLIST,
    PLGMNGREXITCODE_SERVERLISTCREATED,
    PLGMNGREXITCODE_SERVERLISTISEMPTY,
    PLGMNGREXITCODE_SERVERLISTUPDATED,
    PLGMNGREXITCODE_SHOWINSTALLED,
    PLGMNGREXITCODE_SHOWUPDATES,
    PLGMNGREXITCODE_UPDATEALL,
    PLGMNGREXITCODE_UPDATEPLUGINS,
    PLGMNGREXITCODE_REMOVEPLUGINS,
    PLGMNGREXITCODE_NOUPDATESAVAILABLE,
};

void installFiles(QString sDataPath, QString sRootPath, ConsoleOutput *pConsoleOutput, QList<QString> *pListFileNames)
{
    int nCount = pListFileNames->count();

    for (int i = 0; i < nCount; i++) {
        QString sFileName = pListFileNames->at(i);
        if (Utils::isPluginValid(sFileName)) {
            InstallModuleProcess installModuleProcess;
            QObject::connect(&installModuleProcess, SIGNAL(infoMessage(QString)), pConsoleOutput, SLOT(infoMessage(QString)));
            QObject::connect(&installModuleProcess, SIGNAL(errorMessage(QString)), pConsoleOutput, SLOT(errorMessage(QString)));
            installModuleProcess.setData(sDataPath, sRootPath, QList<QString>() << sFileName);
            installModuleProcess.process();
        } else {
            pConsoleOutput->errorMessage(QString("Invalid plugin file: %1").arg(sFileName));
        }
    }
}

void installModules(QString sDataPath, QString sRootPath, Utils::MODULES_DATA *pModulesData, ConsoleOutput *pConsoleOutput, QList<QString> *pListModuleNames)
{
    int nCount = pListModuleNames->count();

    for (int i = 0; i < nCount; i++) {
        Utils::MDATA mdata = Utils::getMDataByName(&(pModulesData->listServerList), pListModuleNames->at(i));

        if (mdata.sName != "") {
            QString sSHA1 = mdata.sSHA1;

            QString sModuleFileName = Utils::getModuleFileName(sDataPath, mdata.sName);

            bool bHash = XBinary::isFileHashValid(XBinary::HASH_SHA1, sModuleFileName, sSHA1);

            if (!bHash) {
                if (mdata.sGithub != "") {
                    QString sConvertPath = Utils::getConvertPath(sDataPath, mdata.sName);
                    QString sDownloadModulePath = Utils::getConvertModulePath(sDataPath, mdata.sName);

                    XBinary::createDirectory(sConvertPath);
                    XBinary::createDirectory(sDownloadModulePath);

                    QList<Utils::WEB_RECORD> listWebRecords;

                    int nCount = mdata.listDownloads.count();

                    for (int i = 0; i < nCount; i++) {
                        Utils::WEB_RECORD record = {};

                        QString sLink = mdata.listDownloads.at(i);

                        record.sFileName = sConvertPath + QDir::separator() + sLink.section("/", -1, -1);
                        record.sFileName = record.sFileName.remove("?raw=true");
                        record.sLink = sLink;

                        listWebRecords.append(record);
                    }

                    GetFileFromServerProcess getFileFromServerProcess;
                    QObject::connect(&getFileFromServerProcess, SIGNAL(infoMessage(QString)), pConsoleOutput, SLOT(infoMessage(QString)));
                    QObject::connect(&getFileFromServerProcess, SIGNAL(errorMessage(QString)), pConsoleOutput, SLOT(errorMessage(QString)));
                    getFileFromServerProcess.setData(listWebRecords);
                    getFileFromServerProcess.process();

                    ConvertProcess convertProcess;
                    QObject::connect(&convertProcess, SIGNAL(infoMessage(QString)), pConsoleOutput, SLOT(infoMessage(QString)));
                    QObject::connect(&convertProcess, SIGNAL(errorMessage(QString)), pConsoleOutput, SLOT(errorMessage(QString)));
                    convertProcess.setData(&mdata, sDataPath);
                    convertProcess.process();

                    Utils::MDATA _mdata = mdata;

                    _mdata.sBundleFileName = Utils::getModuleFileName(sDataPath, _mdata.sName);
                    _mdata.sRoot = sDownloadModulePath;

                    QString sErrorString;

                    if (Utils::checkMData(&_mdata, &sErrorString)) {
                        CreateModuleProcess createModuleProcess;
                        QObject::connect(&createModuleProcess, SIGNAL(infoMessage(QString)), pConsoleOutput, SLOT(infoMessage(QString)));
                        QObject::connect(&createModuleProcess, SIGNAL(errorMessage(QString)), pConsoleOutput, SLOT(errorMessage(QString)));
                        createModuleProcess.setData(&_mdata, false);
                        createModuleProcess.process();
                    } else {
                        pConsoleOutput->errorMessage(sErrorString);
                    }

#ifndef QT_DEBUG
                    XBinary::removeDirectory(sConvertPath);
#endif

                    Utils::updateJsonFile(Utils::getServerListFileName(sDataPath), QList<Utils::MDATA>() << _mdata);

                    sSHA1 = _mdata.sSHA1;
                } else {
                    Utils::WEB_RECORD record = {};

                    record.sFileName = sModuleFileName;
                    record.sLink = mdata.sSrc;

                    GetFileFromServerProcess getFileFromServerProcess;
                    QObject::connect(&getFileFromServerProcess, SIGNAL(infoMessage(QString)), pConsoleOutput, SLOT(infoMessage(QString)));
                    QObject::connect(&getFileFromServerProcess, SIGNAL(errorMessage(QString)), pConsoleOutput, SLOT(errorMessage(QString)));
                    getFileFromServerProcess.setData(QList<Utils::WEB_RECORD>() << record);
                    getFileFromServerProcess.process();
                }

                bHash = XBinary::isFileHashValid(XBinary::HASH_SHA1, sModuleFileName, sSHA1);
            }

            if (bHash) {
                InstallModuleProcess installModuleProcess;
                QObject::connect(&installModuleProcess, SIGNAL(infoMessage(QString)), pConsoleOutput, SLOT(infoMessage(QString)));
                QObject::connect(&installModuleProcess, SIGNAL(errorMessage(QString)), pConsoleOutput, SLOT(errorMessage(QString)));
                installModuleProcess.setData(sDataPath, sRootPath, QList<QString>() << sModuleFileName);
                installModuleProcess.process();
            } else {
                pConsoleOutput->errorMessage(QString("Invalid SHA1: %1").arg(sModuleFileName));
            }
        } else {
            pConsoleOutput->errorMessage(QString("Invalid name: %1").arg(pListModuleNames->at(i)));
        }
    }
}

void removeModules(QString sDataPath, QString sRootPath, Utils::MODULES_DATA *pModulesData, ConsoleOutput *pConsoleOutput, QList<QString> *pListModuleNames)
{
    int nCount = pListModuleNames->count();

    for (int i = 0; i < nCount; i++) {
        Utils::MDATA mdata = Utils::getMDataByName(&(pModulesData->listInstalled), pListModuleNames->at(i));

        if (mdata.sName != "") {
            RemoveModuleProcess removeModuleProcess;
            QObject::connect(&removeModuleProcess, SIGNAL(infoMessage(QString)), pConsoleOutput, SLOT(infoMessage(QString)));
            QObject::connect(&removeModuleProcess, SIGNAL(errorMessage(QString)), pConsoleOutput, SLOT(errorMessage(QString)));
            removeModuleProcess.setData(sDataPath, sRootPath, QList<QString>() << mdata.sName);
            removeModuleProcess.process();
        } else {
            pConsoleOutput->errorMessage(QString("Invalid name: %1. This module is not installed.").arg(pListModuleNames->at(i)));
        }
    }
}

void showModules(ConsoleOutput *pConsoleOutput, QList<Utils::MDATA> *pList)
{
    int nCount = pList->count();

    for (int i = 0; i < nCount; i++) {
        QString sString = QString("%1 [%2]").arg(pList->at(i).sName).arg(pList->at(i).sVersion);

        pConsoleOutput->infoMessage(sString);
    }
}

int main(int argc, char *argv[])
{
    int nReturnCode = PLGMNGREXITCODE_NOARGS;

    QCoreApplication::setOrganizationName(X_ORGANIZATIONNAME);
    QCoreApplication::setOrganizationDomain(X_ORGANIZATIONDOMAIN);
    QCoreApplication::setApplicationName(X_APPLICATIONNAME);
    QCoreApplication::setApplicationVersion(X_APPLICATIONVERSION);

    QCoreApplication app(argc, argv);

    XOptions xOptions;
    xOptions.setName(X_OPTIONSFILE);

    QList<XOptions::ID> listIDs;

    listIDs.append(XOptions::ID_DATAPATH);
    listIDs.append(XOptions::ID_ROOTPATH);
    listIDs.append(XOptions::ID_JSON);
    listIDs.append(XOptions::ID_AUTHUSER);
    listIDs.append(XOptions::ID_AUTHTOKEN);

    xOptions.setValueIDs(listIDs);

    QMap<XOptions::ID, QVariant> mapDefaultValues;

    mapDefaultValues.insert(XOptions::ID_JSON, X_JSON_DEFAULT);

    xOptions.setDefaultValues(mapDefaultValues);

    xOptions.load();

    ConsoleOutput consoleOutput;
    QCommandLineParser parser;
    QString sDescription;
    sDescription.append(QString("%1 v%2\n").arg(X_APPLICATIONNAME).arg(X_APPLICATIONVERSION));
    sDescription.append(QString("%1\n").arg("Copyright(C) 2019-2022 hors<horsicq@gmail.com> Web: http://ntinfo.biz"));
    parser.setApplicationDescription(sDescription);
    parser.addHelpOption();
    parser.addVersionOption();

    parser.addPositionalArgument("plugin or file", "The plugin or file to open.");

    QCommandLineOption clSetGlobalRootPath(QStringList() << "G"
                                                         << "setglobalrootpath",
                                           "Set a global root path<path>.", "path");
    QCommandLineOption clSetGlobalDataPath(QStringList() << "D"
                                                         << "setglobaldatapath",
                                           "Set a global data path<path>.", "path");
    QCommandLineOption clSetGlobalJSONLink(QStringList() << "J"
                                                         << "setglobaljsonlink",
                                           "Set a global JSON link<link>.", "link");
    QCommandLineOption clCreatePlugin(QStringList() << "c"
                                                    << "createplugin",
                                      "Create a plugin<name>.", "name");
    QCommandLineOption clCreateServerList(QStringList() << "l"
                                                        << "createserverlist",
                                          "Create a serverlist<name>.", "name");
    QCommandLineOption clInstallPlugin(QStringList() << "i"
                                                     << "installplugin",
                                       "Install plugin(s).");
    QCommandLineOption clInstallFile(QStringList() << "f"
                                                   << "installfile",
                                     "Install file(s).");
    QCommandLineOption clUpdatePlugin(QStringList() << "u"
                                                    << "updateplugin",
                                      "Update plugin(s).");
    QCommandLineOption clRemovePlugin(QStringList() << "m"
                                                    << "removeplugin",
                                      "Remove plugin(s).");
    QCommandLineOption clUpdateServerList(QStringList() << "U"
                                                        << "updateserverlist",
                                          "Update server list.");
    QCommandLineOption clUpdateAllInstalledPlugins(QStringList() << "A"
                                                                 << "updateall",
                                                   "Update all installed plugins.");
    QCommandLineOption clShowServerList(QStringList() << "S"
                                                      << "showserverlist",
                                        "Show server list.");
    QCommandLineOption clShowInstalled(QStringList() << "N"
                                                     << "showinstalled",
                                       "Show installed.");
    QCommandLineOption clShowUpdates(QStringList() << "P"
                                                   << "showupdates",
                                     "Show updates.");
    QCommandLineOption clSetRootPath(QStringList() << "r"
                                                   << "setrootpath",
                                     "Set a root path<path>.", "path");
    QCommandLineOption clSetName(QStringList() << "n"
                                               << "setname",
                                 "Set a name of plugin<name>.", "name");
    QCommandLineOption clSetVersion(QStringList() << "V"
                                                  << "setversion",
                                    "Set a version of plugin<version>.", "version");
    QCommandLineOption clSetDate(QStringList() << "d"
                                               << "setdate",
                                 "Set a date of plugin<date>.", "date");
    QCommandLineOption clSetAuthor(QStringList() << "a"
                                                 << "setauthor",
                                   "Set an author of plugin<author>.", "author");
    QCommandLineOption clSetBugreport(QStringList() << "b"
                                                    << "setbugreport",
                                      "Set a bugreport of plugin<bugreport>.", "bugreport");
    QCommandLineOption clSetInfo(QStringList() << "I"
                                               << "setinfo",
                                 "Set an info of plugin<info>.", "info");
    QCommandLineOption clSetWebPrefix(QStringList() << "p"
                                                    << "setwebprefix",
                                      "Set a webprefix<prefix>.", "prefix");

    parser.addOption(clSetGlobalRootPath);
    parser.addOption(clSetGlobalDataPath);
    parser.addOption(clSetGlobalJSONLink);
    parser.addOption(clCreatePlugin);
    parser.addOption(clCreateServerList);
    parser.addOption(clInstallPlugin);
    parser.addOption(clInstallFile);
    parser.addOption(clUpdatePlugin);
    parser.addOption(clRemovePlugin);
    parser.addOption(clUpdateServerList);
    parser.addOption(clUpdateAllInstalledPlugins);
    parser.addOption(clShowServerList);
    parser.addOption(clShowInstalled);
    parser.addOption(clShowUpdates);
    parser.addOption(clSetRootPath);
    parser.addOption(clSetName);
    parser.addOption(clSetVersion);
    parser.addOption(clSetDate);
    parser.addOption(clSetAuthor);
    parser.addOption(clSetBugreport);
    parser.addOption(clSetInfo);
    parser.addOption(clSetWebPrefix);

    parser.process(app);

    bool bProcess = false;

    bool bIsSetGlobalRootPath = parser.isSet(clSetGlobalRootPath);
    bool bIsSetGlobalDataPath = parser.isSet(clSetGlobalDataPath);
    bool bIsSetGlobalJSONLink = parser.isSet(clSetGlobalJSONLink);

    if (bIsSetGlobalRootPath || bIsSetGlobalDataPath || bIsSetGlobalJSONLink) {
        bProcess = true;

        if (bIsSetGlobalRootPath) {
            xOptions.setValue(XOptions::ID_ROOTPATH, parser.value(clSetGlobalRootPath));

            if (xOptions.getRootPath() != "") {
                XBinary::createDirectory(XBinary::convertPathName(xOptions.getRootPath()));
            }

            if (XBinary::isDirectoryExists(XBinary::convertPathName(xOptions.getRootPath()))) {
                consoleOutput.infoMessage(QString("Set a global root path: %1").arg(xOptions.getRootPath()));
            } else {
                xOptions.clearValue(XOptions::ID_ROOTPATH);
                consoleOutput.errorMessage(QString("Invalid root path: %1").arg(xOptions.getRootPath()));
            }
        }
        if (bIsSetGlobalDataPath) {
            xOptions.setValue(XOptions::ID_DATAPATH, parser.value(clSetGlobalDataPath));

            if (xOptions.getDataPath() != "") {
                XBinary::createDirectory(XBinary::convertPathName(xOptions.getDataPath()));
            }

            if (XBinary::isDirectoryExists(XBinary::convertPathName(xOptions.getDataPath()))) {
                consoleOutput.infoMessage(QString("Set a global data path: %1").arg(xOptions.getDataPath()));
            } else {
                xOptions.clearValue(XOptions::ID_DATAPATH);
                consoleOutput.errorMessage(QString("Invalid data path: %1").arg(xOptions.getDataPath()));
            }
        }
        if (bIsSetGlobalJSONLink) {
            xOptions.setValue(XOptions::ID_JSON, parser.value(clSetGlobalJSONLink));
            consoleOutput.infoMessage(QString("Set a global JSON link: %1").arg(xOptions.getJson()));
        }

        xOptions.save();
    }

    if (parser.isSet(clSetRootPath)) {
        xOptions.setValue(XOptions::ID_ROOTPATH, parser.value(clSetRootPath));
    }

    bool bRootPathPresent = false;
    bool bDataPathPresent = false;

    if (xOptions.getRootPath() != "") {
        XBinary::createDirectory(XBinary::convertPathName(xOptions.getRootPath()));
        bRootPathPresent = XBinary::isDirectoryExists(XBinary::convertPathName(xOptions.getRootPath()));
    }

    if (xOptions.getDataPath() != "") {
        XBinary::createDirectory(XBinary::convertPathName(xOptions.getDataPath()));
        XBinary::createDirectory(XBinary::convertPathName(xOptions.getDataPath()) + QDir::separator() + "installed");
        XBinary::createDirectory(XBinary::convertPathName(xOptions.getDataPath()) + QDir::separator() + "modules");
        bDataPathPresent = XBinary::isDirectoryExists(XBinary::convertPathName(xOptions.getDataPath()));
    }

    if (!bRootPathPresent) {
        consoleOutput.errorMessage(QString("Invalid root path: %1").arg(xOptions.getRootPath()));
    }

    if (!bDataPathPresent) {
        consoleOutput.errorMessage(QString("Invalid data path: %1").arg(xOptions.getDataPath()));
    }

    if (parser.isSet(clCreatePlugin)) {
        bProcess = true;

        Utils::MDATA mdata = {};

        mdata.sBundleFileName = parser.value(clCreatePlugin);
        consoleOutput.infoMessage(QString("Create a plugin: %1").arg(mdata.sBundleFileName));

        if (mdata.sBundleFileName != "") {
            mdata.sBundleFileName += ".x64dbg.zip";
        }

        mdata.sRoot = parser.value(clSetRootPath);
        mdata.sName = parser.value(clSetName);
        mdata.sVersion = parser.value(clSetVersion);
        mdata.sDate = parser.value(clSetDate);
        mdata.sAuthor = parser.value(clSetAuthor);
        mdata.sBugreport = parser.value(clSetBugreport);
        mdata.sInfo = parser.value(clSetInfo);

        QString sErrorString;

        if (Utils::checkMData(&mdata, &sErrorString)) {
            CreateModuleProcess createModuleProcess;
            QObject::connect(&createModuleProcess, SIGNAL(infoMessage(QString)), &consoleOutput, SLOT(infoMessage(QString)));
            QObject::connect(&createModuleProcess, SIGNAL(errorMessage(QString)), &consoleOutput, SLOT(errorMessage(QString)));
            createModuleProcess.setData(&mdata, true);
            createModuleProcess.process();

            nReturnCode = PLGMNGREXITCODE_PLUGINCREATED;
        } else {
            consoleOutput.errorMessage(sErrorString);

            nReturnCode = PLGMNGREXITCODE_DATAERROR;
        }
    } else if (parser.isSet(clCreateServerList)) {
        bProcess = true;

        QString sListName = parser.value(clCreateServerList);
        consoleOutput.infoMessage(QString("Create a serverlist: %1").arg(sListName));
        QString sWebPrefix = parser.value(clSetWebPrefix);
        QString sDate = parser.value(clSetDate);

        if (sDate == "") {
            sDate = QDate::currentDate().toString("yyyy-MM-dd");
        }

        if (sListName != "") {
            QList<QString> listFiles = parser.positionalArguments();

            if (listFiles.count()) {
                if (Utils::createServerList(sListName, &listFiles, sWebPrefix, sDate)) {
                    nReturnCode = PLGMNGREXITCODE_SERVERLISTCREATED;
                } else {
                    consoleOutput.errorMessage("Cannot create serverlist.");

                    nReturnCode = PLGMNGREXITCODE_CANNOTCREATESERVERLIST;
                }
            } else {
                consoleOutput.errorMessage("No input files.");

                nReturnCode = PLGMNGREXITCODE_NOINPUTFILES;
            }
        } else {
            consoleOutput.errorMessage("List name is empty.");

            nReturnCode = PLGMNGREXITCODE_LISTNAMEISEMPTY;
        }
    } else if (parser.isSet(clUpdateServerList)) {
        bProcess = true;

        consoleOutput.infoMessage(QString("Update server list."));

        QString sServerListFileName = Utils::getServerListFileName(xOptions.getDataPath());
        QString sServerLastestListFileName = Utils::getServerLastestListFileName(xOptions.getDataPath());

        Utils::WEB_RECORD record = {};

        record.sFileName = sServerLastestListFileName;
        record.sLink = xOptions.getJson();

        GetFileFromServerProcess getFileFromServerProcess;
        QObject::connect(&getFileFromServerProcess, SIGNAL(infoMessage(QString)), &consoleOutput, SLOT(infoMessage(QString)));
        QObject::connect(&getFileFromServerProcess, SIGNAL(errorMessage(QString)), &consoleOutput, SLOT(errorMessage(QString)));
        getFileFromServerProcess.setData(QList<Utils::WEB_RECORD>() << record);

        getFileFromServerProcess.process();

        if (Utils::isGithubPresent(sServerLastestListFileName)) {
            UpdateGitProcess updateGitProcess;

            QString authUser = xOptions.getValue(XOptions::ID_AUTHUSER).toString();
            if (!authUser.isEmpty()) {
                QString authToken = xOptions.getValue(XOptions::ID_AUTHTOKEN).toString();
                updateGitProcess.setCredentials(authUser, authToken);
            }

            QObject::connect(&updateGitProcess, SIGNAL(infoMessage(QString)), &consoleOutput, SLOT(infoMessage(QString)));
            QObject::connect(&updateGitProcess, SIGNAL(errorMessage(QString)), &consoleOutput, SLOT(errorMessage(QString)));
            updateGitProcess.setData(sServerLastestListFileName);
            updateGitProcess.process();
        }

        Utils::updateServerList(sServerListFileName, sServerLastestListFileName);

        nReturnCode = PLGMNGREXITCODE_SERVERLISTUPDATED;
    } else if (parser.isSet(clInstallPlugin) || parser.isSet(clInstallFile) || parser.isSet(clUpdatePlugin) || parser.isSet(clRemovePlugin) ||
               parser.isSet(clUpdateAllInstalledPlugins) || parser.isSet(clShowServerList) || parser.isSet(clShowInstalled) || parser.isSet(clShowUpdates)) {
        bProcess = true;

        if (bRootPathPresent && bDataPathPresent) {
            Utils::MODULES_DATA modulesData = Utils::getModulesData(xOptions.getDataPath());

            if (parser.isSet(clShowServerList)) {
                if (modulesData.listServerList.count()) {
                    consoleOutput.infoMessage(QString("Show server list."));

                    showModules(&consoleOutput, &modulesData.listServerList);

                    nReturnCode = PLGMNGREXITCODE_SHOWSERVERLIST;
                } else {
                    consoleOutput.infoMessage(QString("Server list is empty. Please update server list('-U' or '--updateserverlist')"));

                    nReturnCode = PLGMNGREXITCODE_SERVERLISTISEMPTY;
                }
            } else if (parser.isSet(clShowInstalled)) {
                if (modulesData.listInstalled.count()) {
                    consoleOutput.infoMessage(QString("Show installed."));

                    showModules(&consoleOutput, &modulesData.listInstalled);

                    nReturnCode = PLGMNGREXITCODE_SHOWINSTALLED;
                } else {
                    consoleOutput.infoMessage(QString("No plugins installed"));

                    nReturnCode = PLGMNGREXITCODE_NOPLUGINSINSTALLED;
                }
            } else if (parser.isSet(clShowUpdates)) {
                if (modulesData.listUpdates.count()) {
                    consoleOutput.infoMessage(QString("Show updates."));

                    int nCount = modulesData.listUpdates.count();

                    for (int i = 0; i < nCount; i++) {
                        consoleOutput.infoMessage(modulesData.listUpdates.at(i).sName);
                    }

                    nReturnCode = PLGMNGREXITCODE_SHOWUPDATES;
                } else {
                    consoleOutput.infoMessage(QString("No updates available."));

                    nReturnCode = PLGMNGREXITCODE_NOUPDATESAVAILABLE;
                }
            } else if (parser.isSet(clInstallPlugin)) {
                consoleOutput.infoMessage(QString("Install plugin(s)."));

                QList<QString> listModules = parser.positionalArguments();

                installModules(xOptions.getDataPath(), xOptions.getRootPath(), &modulesData, &consoleOutput, &listModules);

                nReturnCode = PLGMNGREXITCODE_INSTALLPLUGINS;
            } else if (parser.isSet(clInstallFile)) {
                consoleOutput.infoMessage(QString("Install file(s)."));

                QList<QString> listFiles = parser.positionalArguments();

                installFiles(xOptions.getDataPath(), xOptions.getRootPath(), &consoleOutput, &listFiles);

                nReturnCode = PLGMNGREXITCODE_INSTALLFILES;
            } else if (parser.isSet(clUpdatePlugin)) {
                consoleOutput.infoMessage(QString("Update plugin(s)."));

                QList<QString> listModules = parser.positionalArguments();
                QList<QString> _listModules;

                int nCount = listModules.count();

                for (int i = 0; i < nCount; i++) {
                    Utils::WEB_RECORD webRecord = Utils::getWebRecordByName(&(modulesData.listUpdates), listModules.at(i));

                    if (webRecord.sName != "") {
                        _listModules.append(webRecord.sName);
                    } else {
                        consoleOutput.errorMessage(QString("No update available for module: %1").arg(listModules.at(i)));
                    }
                }

                installModules(xOptions.getDataPath(), xOptions.getRootPath(), &modulesData, &consoleOutput, &_listModules);

                nReturnCode = PLGMNGREXITCODE_UPDATEPLUGINS;
            } else if (parser.isSet(clRemovePlugin)) {
                consoleOutput.infoMessage(QString("Remove plugin(s)."));

                QList<QString> listModules = parser.positionalArguments();

                removeModules(xOptions.getDataPath(), xOptions.getRootPath(), &modulesData, &consoleOutput, &listModules);

                nReturnCode = PLGMNGREXITCODE_REMOVEPLUGINS;
            } else if (parser.isSet(clUpdateAllInstalledPlugins)) {
                if (modulesData.listUpdates.count()) {
                    consoleOutput.infoMessage(QString("Update all installed plugins"));

                    QList<QString> listModules = Utils::getNamesFromWebRecords(&(modulesData.listUpdates));

                    installModules(xOptions.getDataPath(), xOptions.getRootPath(), &modulesData, &consoleOutput, &listModules);

                    nReturnCode = PLGMNGREXITCODE_UPDATEALL;
                } else {
                    consoleOutput.infoMessage(QString("No updates available."));

                    nReturnCode = PLGMNGREXITCODE_NOUPDATESAVAILABLE;
                }
            }
        }
    }

    if (!bProcess) {
        parser.showHelp();
        Q_UNREACHABLE();
    }

    return nReturnCode;
}

```

`convertprocess.cpp`:

```cpp
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#include "convertprocess.h"

ConvertProcess::ConvertProcess(QObject *pParent) : QObject(pParent)
{
    bIsStop = false;
    currentStats = {};
}

void ConvertProcess::setData(Utils::MDATA *pMData, QString sDataPath)
{
    this->pMData = pMData;
    this->sDataPath = XBinary::convertPathName(sDataPath);
}

void ConvertProcess::stop()
{
    bIsStop = true;
}

Utils::STATS ConvertProcess::getCurrentStats()
{
    return currentStats;
}

void ConvertProcess::process()
{
    QElapsedTimer elapsedTimer;
    elapsedTimer.start();

    bIsStop = false;

    QString sGithubZipModulePath = Utils::getConvertModulePath(sDataPath, pMData->sName);

    currentStats.nTotalModule = pMData->listConvertRecords.count();

    for (int i = 0; (i < currentStats.nTotalModule) && (!bIsStop); i++) {
        Utils::HANDLE_RECORD handleRecord = pMData->listConvertRecords.at(i);

        QString sFileName = Utils::getConvertDownloadFileName(sDataPath, pMData->sName, handleRecord.sPattern);
        QString sPath = sGithubZipModulePath + QDir::separator() + handleRecord.sPath;

        XZip zip;

        // TODO errors
        if (handleRecord.action == Utils::ACTION_MAKEDIRECTORY) {
            XBinary::createDirectory(sPath);
        } else if (handleRecord.action == Utils::ACTION_COPYFILE) {
            if (sFileName != "") {
                XBinary::createDirectory(QFileInfo(sPath).absolutePath());
                XBinary::copyFile(sFileName, sPath);
            }
            // TODO errors
        } else if (handleRecord.action == Utils::ACTION_UNPACKFILE) {
            if (sFileName != "") {
                zip.decompressToFile(sFileName, handleRecord.sSrc, sPath);
            }
            // TODO errors
        } else if (handleRecord.action == Utils::ACTION_UNPACKDIRECTORY) {
            if (sFileName != "") {
                zip.decompressToPath(sFileName, handleRecord.sSrc, sPath);
            }
            // TODO errors
        }

        currentStats.nCurrentModule = i;
    }

    emit completed(elapsedTimer.elapsed());
}

```

`convertprocess.h`:

```h
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#ifndef CONVERTPROCESS_H
#define CONVERTPROCESS_H

#include <QElapsedTimer>
#include <QObject>

#include "utils.h"
#include "xzip.h"

class ConvertProcess : public QObject {
    Q_OBJECT
public:
    explicit ConvertProcess(QObject *pParent = nullptr);
    void setData(Utils::MDATA *pMData, QString sDataPath);
    void stop();
    Utils::STATS getCurrentStats();

signals:
    void errorMessage(QString sMessage);
    void infoMessage(QString sMessage);
    void completed(qint64 nElapsedTime);

public slots:
    void process();

private:
    Utils::MDATA *pMData;
    bool bIsStop;
    Utils::STATS currentStats;
    QString sDataPath;
};

#endif  // CONVERTPROCESS_H

```

`createmoduleprocess.cpp`:

```cpp
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#include "createmoduleprocess.h"

CreateModuleProcess::CreateModuleProcess(QObject *pParent) : QObject(pParent)
{
    bIsStop = false;
    currentStats = {};
}

void CreateModuleProcess::setData(Utils::MDATA *pMData, bool bCreateInfoFile)
{
    this->pMData = pMData;
    this->bCreateInfoFile = bCreateInfoFile;
}

void CreateModuleProcess::stop()
{
    bIsStop = true;
}

Utils::STATS CreateModuleProcess::getCurrentStats()
{
    return currentStats;
}

void CreateModuleProcess::process()
{
    QElapsedTimer elapsedTimer;
    elapsedTimer.start();

    bIsStop = false;

    QList<Utils::FILE_RECORD> listFileRecords;
    QList<Utils::DIRECTORY_RECORD> listDirectoryRecords;

    QList<Utils::RECORD> listRecords = Utils::getRecords(XBinary::convertPathName(pMData->sRoot));

    QString sBundleFileName = pMData->sBundleFileName;
    QString sBundleInfoFileName = pMData->sBundleFileName + ".json";

    if (pMData->sDate == "") {
        pMData->sDate = QDate::currentDate().toString("yyyy-MM-dd");
    }

    bool bSuccess = true;

    if (XBinary::isFileExists(sBundleFileName)) {
        bSuccess = XBinary::removeFile(sBundleFileName);

        if (!bSuccess) {
            emit errorMessage(QString("%1: %2").arg(tr("Cannot remove")).arg(sBundleFileName));
        }
    }

    if (bCreateInfoFile) {
        if (XBinary::isFileExists(sBundleInfoFileName)) {
            bSuccess = XBinary::removeFile(sBundleInfoFileName);

            if (!bSuccess) {
                emit errorMessage(QString("%1: %2").arg(tr("Cannot remove")).arg(sBundleFileName));
            }
        }
    }

    QFileInfo fi(sBundleFileName);

    pMData->sSrc = fi.fileName();

    pMData->nSize = 0;
    pMData->nCompressedSize = 0;
    currentStats.nTotalFile = listRecords.count();

    if (bSuccess) {
        QFile fileResult;

        fileResult.setFileName(sBundleFileName);

        if (fileResult.open(QIODevice::ReadWrite)) {
            QList<XZip::ZIPFILE_RECORD> listZipFiles;

            for (int i = 0; (i < currentStats.nTotalFile) && (!bIsStop); i++) {
                if (listRecords.at(i).bIsFile) {
                    currentStats.sFile = QString("%1: %2").arg(tr("Add file")).arg(listRecords.at(i).sPath);

                    emit infoMessage(currentStats.sFile);

                    QFile file;

                    file.setFileName(listRecords.at(i).sFullPath);

                    if (file.open(QIODevice::ReadOnly)) {
                        Utils::FILE_RECORD fileRecord = {};

                        fileRecord.sFullPath = listRecords.at(i).sFullPath;
                        fileRecord.sPath = listRecords.at(i).sPath;
                        fileRecord.sSHA1 = XBinary::getHash(XBinary::HASH_SHA1, &file);

                        XZip::ZIPFILE_RECORD zipFileRecord = {};

                        zipFileRecord.sFileName = QString("files/") + fileRecord.sPath;
                        zipFileRecord.method = XZip::METHOD_DEFLATE;

                        XZip::addLocalFileRecord(&file, &fileResult, &zipFileRecord);  // TODO handle errors

                        pMData->nSize += zipFileRecord.nUncompressedSize;
                        pMData->nCompressedSize += zipFileRecord.nCompressedSize;

                        file.close();

                        listFileRecords.append(fileRecord);
                        listZipFiles.append(zipFileRecord);
                    }
                } else {
                    if (listRecords.at(i).sPath.toLower() == "x32") {
                        pMData->bIs32 = true;
                    }

                    if (listRecords.at(i).sPath.toLower() == "x64") {
                        pMData->bIs64 = true;
                    }

                    currentStats.sFile = QString("%1: %2").arg(tr("Add directory")).arg(listRecords.at(i).sPath);

                    Utils::DIRECTORY_RECORD directoryRecord = {};

                    directoryRecord.sFullPath = listRecords.at(i).sFullPath;
                    directoryRecord.sPath = listRecords.at(i).sPath;

                    listDirectoryRecords.append(directoryRecord);
                }

                currentStats.nCurrentFile = i + 1;
            }

            QByteArray baInfoFile = Utils::createPluginInfo(pMData, &listFileRecords, &listDirectoryRecords);

            QBuffer bufferInfoFile(&baInfoFile);

            if (bufferInfoFile.open(QIODevice::ReadOnly)) {
                XZip::ZIPFILE_RECORD zipFileRecord = {};

                zipFileRecord.sFileName = "plugin_info.json";
                zipFileRecord.method = XZip::METHOD_DEFLATE;

                XZip::addLocalFileRecord(&bufferInfoFile, &fileResult, &zipFileRecord);

                pMData->nSize += zipFileRecord.nUncompressedSize;
                pMData->nCompressedSize += zipFileRecord.nCompressedSize;

                listZipFiles.append(zipFileRecord);

                bufferInfoFile.close();
            }

            if (!bIsStop) {
                currentStats.sFile = tr("Add central directory");

                XZip::addCentralDirectory(&fileResult, &listZipFiles, QString("%1 v%2").arg(X_APPLICATIONNAME).arg(X_APPLICATIONVERSION));
            }

            fileResult.close();

            pMData->sSHA1 = XBinary::getHash(XBinary::HASH_SHA1, sBundleFileName);

            if (bCreateInfoFile) {
                if (!XBinary::writeToFile(sBundleInfoFileName, Utils::createPluginInfo(pMData, &listFileRecords, &listDirectoryRecords))) {
                    emit errorMessage(QString("%1: %2").arg(tr("Cannot write data to file")).arg(sBundleInfoFileName));
                }
            }
        }
    }

    emit completed(elapsedTimer.elapsed());
}

```

`createmoduleprocess.h`:

```h
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#ifndef CREATEMODULEPROCESS_H
#define CREATEMODULEPROCESS_H

#include <QElapsedTimer>
#include <QObject>

#include "utils.h"
#include "xzip.h"

class CreateModuleProcess : public QObject {
    Q_OBJECT

public:
    explicit CreateModuleProcess(QObject *pParent = nullptr);
    void setData(Utils::MDATA *pMData, bool bCreateInfoFile);
    void stop();
    Utils::STATS getCurrentStats();

signals:
    void errorMessage(QString sMessage);
    void infoMessage(QString sMessage);
    void completed(qint64 nElapsedTime);

public slots:
    void process();

private:
    Utils::MDATA *pMData;
    bool bIsStop;
    Utils::STATS currentStats;
    bool bCreateInfoFile;
};

#endif  // CREATEMODULEPROCESS_H

```

`getfilefromserverprocess.cpp`:

```cpp
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#include "getfilefromserverprocess.h"

GetFileFromServerProcess::GetFileFromServerProcess(QObject *pParent) : QObject(pParent)
{
    pReply = 0;
    replyRed = 0;
    currentStats = {};
}

void GetFileFromServerProcess::setData(QList<Utils::WEB_RECORD> listWebRecords)
{
    this->listWebRecords = listWebRecords;
}

void GetFileFromServerProcess::stop()
{
    bIsStop = true;

    if (pReply) {
        pReply->abort();
    }

    if (replyRed) {
        replyRed->abort();
    }
}

Utils::STATS GetFileFromServerProcess::getCurrentStats()
{
    return currentStats;
}

void GetFileFromServerProcess::process()
{
    QElapsedTimer elapsedTimer;
    elapsedTimer.start();

    bIsStop = false;

    currentStats.nTotalModule = listWebRecords.count();

    for (qint32 i = 0; (i < currentStats.nTotalModule) && (!bIsStop); i++) {
        currentStats.sModule = listWebRecords.at(i).sLink;
        emit infoMessage(currentStats.sModule);

        QNetworkAccessManager nam;
        QNetworkRequest *pRequest = new QNetworkRequest(QUrl(listWebRecords.at(i).sLink));
        pReply = nam.get(*pRequest);
        QEventLoop loop;
        QObject::connect(pReply, SIGNAL(finished()), &loop, SLOT(quit()));
        QObject::connect(pReply, SIGNAL(downloadProgress(qint64, qint64)), this, SLOT(_downloadProgress(qint64, qint64)));
        loop.exec();

        if (pReply->error() == QNetworkReply::NoError) {
            if (pReply->bytesAvailable()) {
                bool bSuccess = false;
                QByteArray baData;

                QString sRedirectUrl = pReply->attribute(QNetworkRequest::RedirectionTargetAttribute).toString();

                if (sRedirectUrl != "")  // Github redirect
                {
                    QNetworkAccessManager namRed;
                    QNetworkRequest *pRequestRed = new QNetworkRequest(QUrl(sRedirectUrl));
                    replyRed = namRed.get(*pRequestRed);
                    QEventLoop loopRed;
                    QObject::connect(replyRed, SIGNAL(finished()), &loopRed, SLOT(quit()));
                    QObject::connect(replyRed, SIGNAL(downloadProgress(qint64, qint64)), this, SLOT(_downloadProgress(qint64, qint64)));
                    loopRed.exec();

                    if (replyRed->bytesAvailable()) {
                        baData = replyRed->readAll();
                        bSuccess = true;
                    }
                } else {
                    baData = pReply->readAll();
                    bSuccess = true;
                }

                if (bSuccess) {
                    if (XBinary::isFileExists(listWebRecords.at(i).sFileName)) {
                        if (!XBinary::removeFile(listWebRecords.at(i).sFileName)) {
                            emit errorMessage(QString("%1: %2").arg(tr("Cannot remove file")).arg(listWebRecords.at(i).sFileName));
                            bIsStop = true;
                        }
                    }

                    if (XBinary::writeToFile(listWebRecords.at(i).sFileName, baData)) {
                        currentStats.sFile = QString("%1: %2").arg(tr("Write data to file")).arg(listWebRecords.at(i).sFileName);
                        emit infoMessage(currentStats.sFile);
                    } else {
                        emit errorMessage(QString("%1: %2").arg(tr("Cannot write data to file")).arg(listWebRecords.at(i).sFileName));
                    }
                }
            }
        } else {
            emit errorMessage(pReply->errorString());
            bIsStop = true;
        }

        pReply->deleteLater();
        delete pRequest;

        pReply = 0;

        currentStats.nCurrentModule = i;
    }

    bIsStop = false;

    emit completed(elapsedTimer.elapsed());
}

void GetFileFromServerProcess::_downloadProgress(qint64 bytesReceived, qint64 bytesTotal)
{
    currentStats.nTotalBytes = bytesTotal;
    currentStats.nCurrentBytes = bytesReceived;
}

```

`getfilefromserverprocess.h`:

```h
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#ifndef GETFILEFROMSERVERPROCESS_H
#define GETFILEFROMSERVERPROCESS_H

#include <QElapsedTimer>
#include <QNetworkAccessManager>
#include <QNetworkReply>
#include <QNetworkRequest>
#include <QObject>

#include "utils.h"

class GetFileFromServerProcess : public QObject {
    Q_OBJECT
public:
    explicit GetFileFromServerProcess(QObject *pParent = nullptr);
    void setData(QList<Utils::WEB_RECORD> listWebRecords);
    void stop();
    Utils::STATS getCurrentStats();

signals:
    void errorMessage(QString sMessage);
    void infoMessage(QString sMessage);
    void completed(qint64 nElapsedTime);

public slots:
    void process();
    void _downloadProgress(qint64 bytesReceived, qint64 bytesTotal);

private:
    bool bIsStop;
    QList<Utils::WEB_RECORD> listWebRecords;
    QNetworkReply *pReply;
    QNetworkReply *replyRed;
    Utils::STATS currentStats;
};

#endif  // GETFILEFROMSERVERPROCESS_H

```

`global.h`:

```h
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#ifndef _GLOBAL_H
#define _GLOBAL_H

#include <QString>

#define X_APPLICATIONNAME "x64dbg Plugin Manager"
#define X_APPLICATIONVERSION "0.05"
#define X_ORGANIZATIONNAME "NTInfo"
#define X_ORGANIZATIONDOMAIN "ntinfo.biz"
#define X_OPTIONSFILE "x64plgmnr.ini"
#define X_HOMEPAGE "https://github.com/horsicq/x64dbg-Plugin-Manager"
#define X_SERVERVERSION "https://raw.githubusercontent.com/horsicq/x64dbg-Plugin-Manager/master/release_version.txt"

#define X_JSON_DEFAULT "https://raw.githubusercontent.com/x64dbg/PluginManager/master/list.json"

#endif  // _GLOBAL_H

```

`gui_source/dialogabout.cpp`:

```cpp
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#include "dialogabout.h"

#include "ui_dialogabout.h"

DialogAbout::DialogAbout(QWidget *pParent) : QDialog(pParent), ui(new Ui::DialogAbout)
{
    ui->setupUi(this);

    ui->labelInfo->setText(QString("<html><head/><body><p align=\"center\">"
                                   "<span style=\" font-weight:600;\">Copyright(C) 2019-2022 hors</span></p>"
                                   "<p align=\"center\"><span style=\" font-weight:600;\">"
                                   "Version: </span>%1 (%2)</p><p align=\"center\">"
                                   "<span style=\" font-weight:600;\">Website: </span><a href=\"http://ntinfo.biz\">"
                                   "<span style=\" text-decoration: underline; color:#0000ff;\">http://ntinfo.biz</span>"
                                   "</a></p><p align=\"center\"><span style=\" font-weight:600;\">Bugerports: </span>"
                                   "<a href=\"mailto:horsicq@gmail.com\"><span style=\" text-decoration: underline; color:#0000ff;\">"
                                   "horsicq@gmail.com</span></a></p></body></html>")
                               .arg(X_APPLICATIONVERSION)
                               .arg(__DATE__));
}

DialogAbout::~DialogAbout()
{
    delete ui;
}

void DialogAbout::on_pushButtonOK_clicked()
{
    this->close();
}

```

`gui_source/dialogabout.h`:

```h
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#ifndef DIALOGABOUT_H
#define DIALOGABOUT_H

#include <QDate>
#include <QDialog>

#include "../global.h"

namespace Ui {
class DialogAbout;
}

class DialogAbout : public QDialog {
    Q_OBJECT

public:
    explicit DialogAbout(QWidget *pParent = nullptr);
    ~DialogAbout();

private slots:
    void on_pushButtonOK_clicked();

private:
    Ui::DialogAbout *ui;
};

#endif  // DIALOGABOUT_H

```

`gui_source/dialogabout.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>DialogAbout</class>
 <widget class="QDialog" name="DialogAbout">
  <property name="windowModality">
   <enum>Qt::ApplicationModal</enum>
  </property>
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>365</width>
    <height>451</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>About</string>
  </property>
  <property name="modal">
   <bool>true</bool>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout_2">
     <item>
      <spacer name="horizontalSpacer_2">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
     <item>
      <widget class="QLabel" name="labelLogo">
       <property name="minimumSize">
        <size>
         <width>314</width>
         <height>177</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>314</width>
         <height>177</height>
        </size>
       </property>
       <property name="frameShape">
        <enum>QFrame::NoFrame</enum>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="pixmap">
        <pixmap resource="resources.qrc">:/images/main.png</pixmap>
       </property>
       <property name="scaledContents">
        <bool>true</bool>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item>
      <spacer name="horizontalSpacer_3">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
    </layout>
   </item>
   <item>
    <widget class="QLabel" name="labelInfo">
     <property name="text">
      <string>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p align=&quot;center&quot;&gt;Bugreports: &lt;a href=&quot;mailto:horsicq@gmail.com&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#ff0000;&quot;&gt;horsicq@gmail.com&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;Website: &lt;a href=&quot;http://ntinfo.biz&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#ff0000;&quot;&gt;http://ntinfo.biz&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;&lt;span style=&quot; font-weight:600;&quot;&gt;2019-2022(C) hors&lt;/span&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;&lt;span style=&quot; font-weight:600;&quot;&gt;Thanks:&lt;/span&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;&lt;span style=&quot; font-weight:600;&quot;&gt;Fernando Mercês: &lt;/span&gt;&lt;a href=&quot;https://www.mentebinaria.com.br/&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#ff0000;&quot;&gt;https://www.mentebinaria.com.br&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;&lt;span style=&quot; font-weight:600;&quot;&gt;David Zimmer: &lt;/span&gt;&lt;a href=&quot;http://sandsprite.com/&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#ff0000;&quot;&gt;http://sandsprite.com&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;&lt;span style=&quot; font-weight:600;&quot;&gt;misonothx: &lt;/span&gt;&lt;a href=&quot;https://github.com/miso-xyz&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#ff0000;&quot;&gt;https://github.com/miso-xyz&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;&lt;span style=&quot; font-weight:600;&quot;&gt;FrenchYeti: &lt;/span&gt;&lt;a href=&quot;https://twitter.com/frenchyeti&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#ff0000;&quot;&gt;https://twitter.com/frenchyeti&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
     </property>
     <property name="openExternalLinks">
      <bool>true</bool>
     </property>
    </widget>
   </item>
   <item>
    <spacer name="verticalSpacer">
     <property name="orientation">
      <enum>Qt::Vertical</enum>
     </property>
     <property name="sizeHint" stdset="0">
      <size>
       <width>20</width>
       <height>40</height>
      </size>
     </property>
    </spacer>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <spacer name="horizontalSpacer">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
     <item>
      <widget class="QPushButton" name="pushButtonOK">
       <property name="text">
        <string>OK</string>
       </property>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources>
  <include location="resources.qrc"/>
 </resources>
 <connections/>
</ui>

```

`gui_source/dialogconvertprocess.cpp`:

```cpp
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#include "dialogconvertprocess.h"

#include "ui_dialogconvertprocess.h"

DialogConvertProcess::DialogConvertProcess(QWidget *pParent, Utils::MDATA *pMData, QString sDataPath) : QDialog(pParent), ui(new Ui::DialogConvertProcess)
{
    ui->setupUi(this);

    this->pMData = pMData;
    this->sDataPath = sDataPath;

    pConvertProcess = new ConvertProcess;
    pThread = new QThread;

    pConvertProcess->moveToThread(pThread);

    connect(pThread, SIGNAL(started()), pConvertProcess, SLOT(process()));
    connect(pConvertProcess, SIGNAL(completed(qint64)), this, SLOT(onCompleted(qint64)));
    connect(pConvertProcess, SIGNAL(errorMessage(QString)), this, SIGNAL(errorMessage(QString)));

    pTimer = new QTimer(this);
    connect(pTimer, SIGNAL(timeout()), this, SLOT(timerSlot()));

    pConvertProcess->setData(pMData, sDataPath);

    bIsRun = true;

    ui->progressBar->setMaximum(100);
    ui->progressBar->setValue(0);

    pThread->start();
    pTimer->start(100);  // 0.1 sec
}

DialogConvertProcess::~DialogConvertProcess()
{
    if (bIsRun) {
        pConvertProcess->stop();
    }

    pTimer->stop();

    pThread->quit();
    pThread->wait();

    delete ui;

    delete pThread;
    delete pConvertProcess;
}

void DialogConvertProcess::on_pushButtonCancel_clicked()
{
    if (bIsRun) {
        pConvertProcess->stop();
        pTimer->stop();
        bIsRun = false;
    }
}

void DialogConvertProcess::onCompleted(qint64 nElapsed)
{
    Q_UNUSED(nElapsed)
    // TODO
    bIsRun = false;
    this->close();
}

void DialogConvertProcess::timerSlot()
{
    Utils::STATS stats = pConvertProcess->getCurrentStats();

    ui->labelInfo->setText(stats.sModule);

    if (stats.nTotalModule) {
        ui->progressBar->setValue((int)((stats.nCurrentModule * 100) / stats.nTotalModule));
    }
}

```

`gui_source/dialogconvertprocess.h`:

```h
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#ifndef DIALOGCONVERTPROCESS_H
#define DIALOGCONVERTPROCESS_H

#include <QDialog>
#include <QThread>
#include <QTimer>

#include "../convertprocess.h"
#include "../utils.h"

namespace Ui {
class DialogConvertProcess;
}

class DialogConvertProcess : public QDialog {
    Q_OBJECT

public:
    explicit DialogConvertProcess(QWidget *pParent, Utils::MDATA *pMData, QString sDataPath);
    ~DialogConvertProcess();

private slots:
    void on_pushButtonCancel_clicked();
    void onCompleted(qint64 nElapsed);
    void timerSlot();

signals:
    void errorMessage(QString sMessage);

private:
    Ui::DialogConvertProcess *ui;
    Utils::MDATA *pMData;
    QString sDataPath;
    ConvertProcess *pConvertProcess;
    QThread *pThread;
    bool bIsRun;
    QTimer *pTimer;
};

#endif  // DIALOGCONVERTPROCESS_H

```

`gui_source/dialogconvertprocess.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>DialogConvertProcess</class>
 <widget class="QDialog" name="DialogConvertProcess">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>457</width>
    <height>118</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Convert</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QLabel" name="labelInfo">
     <property name="text">
      <string/>
     </property>
     <property name="alignment">
      <set>Qt::AlignCenter</set>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QProgressBar" name="progressBar">
     <property name="maximum">
      <number>0</number>
     </property>
     <property name="value">
      <number>0</number>
     </property>
     <property name="alignment">
      <set>Qt::AlignCenter</set>
     </property>
    </widget>
   </item>
   <item>
    <spacer name="verticalSpacer">
     <property name="orientation">
      <enum>Qt::Vertical</enum>
     </property>
     <property name="sizeHint" stdset="0">
      <size>
       <width>20</width>
       <height>20</height>
      </size>
     </property>
    </spacer>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <spacer name="horizontalSpacer">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
     <item>
      <widget class="QPushButton" name="pushButtonCancel">
       <property name="text">
        <string>Cancel</string>
       </property>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`gui_source/dialogcreatemodule.cpp`:

```cpp
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#include "dialogcreatemodule.h"

#include "ui_dialogcreatemodule.h"

DialogCreateModule::DialogCreateModule(QWidget *pParent) : QDialog(pParent), ui(new Ui::DialogCreateModule)
{
    ui->setupUi(this);

    mdata = {};

    _currentDate();
    ui->pushButtonSave->setEnabled(false);
}

DialogCreateModule::~DialogCreateModule()
{
    delete ui;
}

void DialogCreateModule::on_pushButtonLoad_clicked()
{
    //    QString sInitDirectory=QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation);
    QString sInitDirectory;

    QString sFileName = QFileDialog::getOpenFileName(this, tr("Load project"), sInitDirectory, "*.pro.ini");

    if (sFileName != "") {
        QSettings settings(sFileName, QSettings::IniFormat);

        ui->lineEditName->setText(settings.value("Name", "").toString());
        ui->lineEditVersion->setText(settings.value("Version", "").toString());
        ui->dateEdit->setDate(QDate::fromString(settings.value("Date", QDate::currentDate().toString("yyyy-MM-dd")).toString(), "yyyy-MM-dd"));
        ui->lineEditAuthor->setText(settings.value("Author", "").toString());
        ui->lineEditBugreport->setText(settings.value("Bugreport", "").toString());
        ui->lineEditInfo->setText(settings.value("Info", "").toString());
        ui->lineEditRoot->setText(settings.value("Root", "").toString());
    }
}

void DialogCreateModule::on_pushButtonSave_clicked()
{
    //    QString sFileName=QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation)+QDir::separator()+ui->lineEditName->text()+".pro.ini";
    QString sFileName;

    sFileName = QFileDialog::getSaveFileName(this, tr("Save project"), sFileName, "*.pro.ini");

    if (sFileName != "") {
        QSettings settings(sFileName, QSettings::IniFormat);

        settings.setValue("Name", ui->lineEditName->text());
        settings.setValue("Version", ui->lineEditVersion->text());
        settings.setValue("Date", ui->dateEdit->date().toString("yyyy-MM-dd"));
        settings.setValue("Author", ui->lineEditAuthor->text());
        settings.setValue("Bugreport", ui->lineEditBugreport->text());
        settings.setValue("Info", ui->lineEditInfo->text());
        settings.setValue("Root", ui->lineEditRoot->text());
    }
}

void DialogCreateModule::on_pushButtonCreate_clicked()
{
    QString sFileName = Utils::createBundleName(&mdata) + ".x64dbg.zip";
    sFileName = QFileDialog::getSaveFileName(this, tr("Save plugin bundle"), sFileName, "*.x64dbg.zip");

    if (sFileName != "") {
        mdata.sBundleFileName = sFileName;

        QString sErrorString;

        if (Utils::checkMData(&mdata, &sErrorString)) {
            DialogCreateModuleProcess dcmp(this, &mdata, true);

            connect(&dcmp, SIGNAL(errorMessage(QString)), this, SIGNAL(errorMessage(QString)));

            dcmp.exec();
        } else {
            emit errorMessage(sErrorString);
        }
    }
}

void DialogCreateModule::on_toolButtonRoot_clicked()
{
    QString sDirectoryName = QFileDialog::getExistingDirectory(this, tr("Select plugin root directory"), ui->lineEditRoot->text());

    if (sDirectoryName != "") {
        ui->lineEditRoot->setText(sDirectoryName);
    }
}

void DialogCreateModule::on_lineEditRoot_textChanged(const QString &sDirectoryName)
{
    mdata.sRoot = "";

    QString _sDirectoryName = sDirectoryName;

    if (sDirectoryName != "") {
        _sDirectoryName = XBinary::convertPathName(_sDirectoryName);

        QDir dir(_sDirectoryName);

        if (dir.exists()) {
            mdata.sRoot = _sDirectoryName;

            QList<Utils::RECORD> listRecords = Utils::getRecords(_sDirectoryName);

            int nCount = listRecords.count();

            ui->tableWidgetRecords->setColumnCount(1);
            ui->tableWidgetRecords->setRowCount(nCount);

            for (int i = 0; i < nCount; i++) {
                QTableWidgetItem *pItem = new QTableWidgetItem(listRecords.at(i).sPath);
                ui->tableWidgetRecords->setItem(i, 0, pItem);
            }
        }
    }
}

void DialogCreateModule::on_pushButtonCancel_clicked()
{
    this->close();
}

void DialogCreateModule::on_lineEditName_textChanged(const QString &sName)
{
    QSignalBlocker(ui->lineEditName);

    QString _sName = sName;

    if (_sName.contains(" ")) _sName.remove(" ");
    // TODO more checks

    ui->lineEditName->setText(_sName);

    mdata.sName = _sName;

    ui->pushButtonSave->setEnabled(_sName != "");
}

void DialogCreateModule::on_lineEditVersion_textChanged(const QString &sVersion)
{
    // TODO Checks
    mdata.sVersion = sVersion;
}

void DialogCreateModule::on_pushButtonCurrentDate_clicked()
{
    _currentDate();
}

void DialogCreateModule::_currentDate()
{
    ui->dateEdit->setDate(QDate::currentDate());
}

void DialogCreateModule::on_dateEdit_dateChanged(const QDate &date)
{
    mdata.sDate = date.toString("yyyy-MM-dd");
}

void DialogCreateModule::on_lineEditInfo_textChanged(const QString &sInfo)
{
    mdata.sInfo = sInfo;
}

void DialogCreateModule::on_lineEditAuthor_textChanged(const QString &sAuthor)
{
    mdata.sAuthor = sAuthor;
}

void DialogCreateModule::on_lineEditBugreport_textChanged(const QString &sBugreport)
{
    mdata.sBugreport = sBugreport;
}

```

`gui_source/dialogcreatemodule.h`:

```h
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#ifndef DIALOGCREATEMODULE_H
#define DIALOGCREATEMODULE_H

#include <QDate>
#include <QDialog>
#include <QFileDialog>
#include <QSettings>
#include <QStandardPaths>

#include "../utils.h"
#include "dialogcreatemoduleprocess.h"

namespace Ui {
class DialogCreateModule;
}

class DialogCreateModule : public QDialog {
    Q_OBJECT

public:
    explicit DialogCreateModule(QWidget *pParent);
    ~DialogCreateModule();

private slots:
    void on_pushButtonLoad_clicked();
    void on_pushButtonSave_clicked();
    void on_pushButtonCreate_clicked();
    void on_toolButtonRoot_clicked();
    void on_lineEditRoot_textChanged(const QString &sDirectoryName);
    void on_pushButtonCancel_clicked();
    void on_lineEditName_textChanged(const QString &sName);
    void on_lineEditVersion_textChanged(const QString &sVersion);
    void on_pushButtonCurrentDate_clicked();
    void _currentDate();
    void on_dateEdit_dateChanged(const QDate &date);
    void on_lineEditInfo_textChanged(const QString &sInfo);
    void on_lineEditAuthor_textChanged(const QString &sAuthor);
    void on_lineEditBugreport_textChanged(const QString &sBugreport);

signals:
    void errorMessage(QString sMessage);

private:
    Ui::DialogCreateModule *ui;
    Utils::MDATA mdata;
};

#endif  // DIALOGCREATEMODULE_H

```

`gui_source/dialogcreatemodule.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>DialogCreateModule</class>
 <widget class="QDialog" name="DialogCreateModule">
  <property name="windowModality">
   <enum>Qt::ApplicationModal</enum>
  </property>
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>559</width>
    <height>545</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Create</string>
  </property>
  <property name="modal">
   <bool>true</bool>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout_3">
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout_3">
     <item>
      <widget class="QPushButton" name="pushButtonLoad">
       <property name="text">
        <string>Load project</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="pushButtonSave">
       <property name="text">
        <string>Save project</string>
       </property>
      </widget>
     </item>
     <item>
      <spacer name="horizontalSpacer">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
    </layout>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <widget class="QGroupBox" name="groupBoxName">
       <property name="title">
        <string>Name</string>
       </property>
       <layout class="QVBoxLayout" name="verticalLayout">
        <property name="leftMargin">
         <number>1</number>
        </property>
        <property name="topMargin">
         <number>1</number>
        </property>
        <property name="rightMargin">
         <number>1</number>
        </property>
        <property name="bottomMargin">
         <number>1</number>
        </property>
        <item>
         <widget class="QLineEdit" name="lineEditName"/>
        </item>
       </layout>
      </widget>
     </item>
     <item>
      <widget class="QGroupBox" name="groupBoxVersion">
       <property name="title">
        <string>Version</string>
       </property>
       <layout class="QVBoxLayout" name="verticalLayout_2">
        <property name="leftMargin">
         <number>1</number>
        </property>
        <property name="topMargin">
         <number>1</number>
        </property>
        <property name="rightMargin">
         <number>1</number>
        </property>
        <property name="bottomMargin">
         <number>1</number>
        </property>
        <item>
         <widget class="QLineEdit" name="lineEditVersion"/>
        </item>
       </layout>
      </widget>
     </item>
     <item>
      <widget class="QGroupBox" name="groupBoxDate">
       <property name="title">
        <string>Date</string>
       </property>
       <layout class="QHBoxLayout" name="horizontalLayout_5">
        <property name="leftMargin">
         <number>1</number>
        </property>
        <property name="topMargin">
         <number>1</number>
        </property>
        <property name="rightMargin">
         <number>1</number>
        </property>
        <property name="bottomMargin">
         <number>1</number>
        </property>
        <item>
         <widget class="QPushButton" name="pushButtonCurrentDate">
          <property name="text">
           <string>Current</string>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QDateEdit" name="dateEdit"/>
        </item>
       </layout>
      </widget>
     </item>
    </layout>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout_6">
     <item>
      <widget class="QGroupBox" name="groupBoxAuthor">
       <property name="title">
        <string>Author</string>
       </property>
       <layout class="QVBoxLayout" name="verticalLayout_5">
        <property name="leftMargin">
         <number>1</number>
        </property>
        <property name="topMargin">
         <number>1</number>
        </property>
        <property name="rightMargin">
         <number>1</number>
        </property>
        <property name="bottomMargin">
         <number>1</number>
        </property>
        <item>
         <widget class="QLineEdit" name="lineEditAuthor"/>
        </item>
       </layout>
      </widget>
     </item>
     <item>
      <widget class="QGroupBox" name="groupBoxBugreport">
       <property name="title">
        <string>Bugreport</string>
       </property>
       <layout class="QVBoxLayout" name="verticalLayout_7">
        <property name="leftMargin">
         <number>1</number>
        </property>
        <property name="topMargin">
         <number>1</number>
        </property>
        <property name="rightMargin">
         <number>1</number>
        </property>
        <property name="bottomMargin">
         <number>1</number>
        </property>
        <item>
         <widget class="QLineEdit" name="lineEditBugreport"/>
        </item>
       </layout>
      </widget>
     </item>
    </layout>
   </item>
   <item>
    <widget class="QGroupBox" name="groupBoxInfo">
     <property name="title">
      <string>Info</string>
     </property>
     <layout class="QVBoxLayout" name="verticalLayout_4">
      <property name="leftMargin">
       <number>1</number>
      </property>
      <property name="topMargin">
       <number>1</number>
      </property>
      <property name="rightMargin">
       <number>1</number>
      </property>
      <property name="bottomMargin">
       <number>1</number>
      </property>
      <item>
       <widget class="QLineEdit" name="lineEditInfo"/>
      </item>
     </layout>
    </widget>
   </item>
   <item>
    <widget class="QGroupBox" name="groupBoxRoot">
     <property name="title">
      <string>Root</string>
     </property>
     <layout class="QHBoxLayout" name="horizontalLayout_2">
      <property name="leftMargin">
       <number>1</number>
      </property>
      <property name="topMargin">
       <number>1</number>
      </property>
      <property name="rightMargin">
       <number>1</number>
      </property>
      <property name="bottomMargin">
       <number>1</number>
      </property>
      <item>
       <widget class="QLineEdit" name="lineEditRoot"/>
      </item>
      <item>
       <widget class="QToolButton" name="toolButtonRoot">
        <property name="text">
         <string>..</string>
        </property>
       </widget>
      </item>
     </layout>
    </widget>
   </item>
   <item>
    <widget class="QGroupBox" name="groupBoxRecords">
     <property name="title">
      <string>Files</string>
     </property>
     <layout class="QVBoxLayout" name="verticalLayout_6">
      <property name="leftMargin">
       <number>1</number>
      </property>
      <property name="topMargin">
       <number>1</number>
      </property>
      <property name="rightMargin">
       <number>1</number>
      </property>
      <property name="bottomMargin">
       <number>1</number>
      </property>
      <item>
       <widget class="QTableWidget" name="tableWidgetRecords">
        <property name="editTriggers">
         <set>QAbstractItemView::NoEditTriggers</set>
        </property>
        <property name="selectionBehavior">
         <enum>QAbstractItemView::SelectRows</enum>
        </property>
        <attribute name="horizontalHeaderVisible">
         <bool>false</bool>
        </attribute>
        <attribute name="horizontalHeaderStretchLastSection">
         <bool>true</bool>
        </attribute>
        <attribute name="verticalHeaderVisible">
         <bool>false</bool>
        </attribute>
        <attribute name="verticalHeaderMinimumSectionSize">
         <number>20</number>
        </attribute>
        <attribute name="verticalHeaderDefaultSectionSize">
         <number>20</number>
        </attribute>
       </widget>
      </item>
     </layout>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout_4">
     <item>
      <spacer name="horizontalSpacer_2">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
     <item>
      <widget class="QPushButton" name="pushButtonCancel">
       <property name="text">
        <string>Cancel</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="pushButtonCreate">
       <property name="text">
        <string>Create</string>
       </property>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`gui_source/dialogcreatemoduleprocess.cpp`:

```cpp
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#include "dialogcreatemoduleprocess.h"

#include "ui_dialogcreatemoduleprocess.h"

DialogCreateModuleProcess::DialogCreateModuleProcess(QWidget *pParent, Utils::MDATA *pMData, bool bCreateInfoFile)
    : QDialog(pParent), ui(new Ui::DialogCreateModuleProcess)
{
    ui->setupUi(this);

    this->pMData = pMData;

    pCreateModuleProcess = new CreateModuleProcess;
    pThread = new QThread;

    pCreateModuleProcess->moveToThread(pThread);

    connect(pThread, SIGNAL(started()), pCreateModuleProcess, SLOT(process()));
    connect(pCreateModuleProcess, SIGNAL(completed(qint64)), this, SLOT(onCompleted(qint64)));
    connect(pCreateModuleProcess, SIGNAL(errorMessage(QString)), this, SIGNAL(errorMessage(QString)));

    pTimer = new QTimer(this);
    connect(pTimer, SIGNAL(timeout()), this, SLOT(timerSlot()));

    pCreateModuleProcess->setData(pMData, bCreateInfoFile);

    bIsRun = true;

    ui->progressBar->setMaximum(100);
    ui->progressBar->setValue(0);

    pThread->start();
    pTimer->start(1000);  // 1 sec
}

DialogCreateModuleProcess::~DialogCreateModuleProcess()
{
    if (bIsRun) {
        pCreateModuleProcess->stop();
    }

    pTimer->stop();

    pThread->quit();
    pThread->wait();

    delete ui;

    delete pThread;
    delete pCreateModuleProcess;
}

void DialogCreateModuleProcess::on_pushButtonCancel_clicked()
{
    if (bIsRun) {
        pCreateModuleProcess->stop();
        pTimer->stop();
        bIsRun = false;
    }
}

void DialogCreateModuleProcess::onCompleted(qint64 nElapsed)
{
    Q_UNUSED(nElapsed)
    // TODO
    bIsRun = false;
    this->close();
}

void DialogCreateModuleProcess::timerSlot()
{
    Utils::STATS stats = pCreateModuleProcess->getCurrentStats();

    ui->labelInfo->setText(stats.sFile);

    if (stats.nTotalFile) {
        ui->progressBar->setValue((int)((stats.nCurrentFile * 100) / stats.nTotalFile));
    }
}

```

`gui_source/dialogcreatemoduleprocess.h`:

```h
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#ifndef DIALOGCREATEMODULEPROCESS_H
#define DIALOGCREATEMODULEPROCESS_H

#include <QDialog>
#include <QThread>
#include <QTimer>

#include "../createmoduleprocess.h"
#include "../utils.h"

namespace Ui {
class DialogCreateModuleProcess;
}

class DialogCreateModuleProcess : public QDialog {
    Q_OBJECT

public:
    explicit DialogCreateModuleProcess(QWidget *pParent, Utils::MDATA *pMData, bool bCreateInfoFile);
    ~DialogCreateModuleProcess();

private slots:
    void on_pushButtonCancel_clicked();
    void onCompleted(qint64 nElapsed);
    void timerSlot();

signals:
    void errorMessage(QString sMessage);

private:
    Ui::DialogCreateModuleProcess *ui;
    Utils::MDATA *pMData;

    CreateModuleProcess *pCreateModuleProcess;
    QThread *pThread;
    bool bIsRun;
    QTimer *pTimer;
};

#endif  // DIALOGCREATEMODULEPROCESS_H

```

`gui_source/dialogcreatemoduleprocess.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>DialogCreateModuleProcess</class>
 <widget class="QDialog" name="DialogCreateModuleProcess">
  <property name="windowModality">
   <enum>Qt::ApplicationModal</enum>
  </property>
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>621</width>
    <height>110</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Create Module</string>
  </property>
  <property name="modal">
   <bool>true</bool>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QLabel" name="labelInfo">
     <property name="text">
      <string/>
     </property>
     <property name="alignment">
      <set>Qt::AlignCenter</set>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QProgressBar" name="progressBar">
     <property name="maximum">
      <number>0</number>
     </property>
     <property name="value">
      <number>0</number>
     </property>
     <property name="alignment">
      <set>Qt::AlignCenter</set>
     </property>
    </widget>
   </item>
   <item>
    <spacer name="verticalSpacer">
     <property name="orientation">
      <enum>Qt::Vertical</enum>
     </property>
     <property name="sizeHint" stdset="0">
      <size>
       <width>20</width>
       <height>40</height>
      </size>
     </property>
    </spacer>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <spacer name="horizontalSpacer">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
     <item>
      <widget class="QPushButton" name="pushButtonCancel">
       <property name="text">
        <string>Cancel</string>
       </property>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`gui_source/dialoggetfilefromserverprocess.cpp`:

```cpp
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#include "dialoggetfilefromserverprocess.h"

#include "ui_dialoggetfilefromserverprocess.h"

DialogGetFileFromServerProcess::DialogGetFileFromServerProcess(QWidget *pParent, QList<Utils::WEB_RECORD> listWebRecords)
    : QDialog(pParent), ui(new Ui::DialogGetFileFromServerProcess)
{
    ui->setupUi(this);

    pGetFileFromServerProcess = new GetFileFromServerProcess;
    pThread = new QThread;

    pGetFileFromServerProcess->moveToThread(pThread);

    connect(pThread, SIGNAL(started()), pGetFileFromServerProcess, SLOT(process()));
    connect(pGetFileFromServerProcess, SIGNAL(completed(qint64)), this, SLOT(onCompleted(qint64)));
    connect(pGetFileFromServerProcess, SIGNAL(errorMessage(QString)), this, SIGNAL(errorMessage(QString)));

    bIsRun = false;

    pGetFileFromServerProcess->setData(listWebRecords);

    bIsRun = true;

    pThread->start();

    pTimer = new QTimer(this);
    connect(pTimer, SIGNAL(timeout()), this, SLOT(timerSlot()));

    ui->progressBarModule->setMaximum(100);
    ui->progressBarModule->setValue(0);

    ui->progressBarBytes->setMaximum(100);
    ui->progressBarBytes->setValue(0);

    pTimer->start(100);  // 0.1 sec
}

DialogGetFileFromServerProcess::~DialogGetFileFromServerProcess()
{
    if (bIsRun) {
        pGetFileFromServerProcess->stop();
    }

    pTimer->stop();

    pThread->quit();
    pThread->wait();

    delete ui;

    delete pThread;
    delete pGetFileFromServerProcess;
}

void DialogGetFileFromServerProcess::on_pushButtonCancel_clicked()
{
    if (bIsRun) {
        pGetFileFromServerProcess->stop();
        pTimer->stop();
        bIsRun = false;
    }
}

void DialogGetFileFromServerProcess::onCompleted(qint64 nElapsed)
{
    Q_UNUSED(nElapsed)
    // TODO
    bIsRun = false;
    this->close();
}

void DialogGetFileFromServerProcess::timerSlot()
{
    Utils::STATS stats = pGetFileFromServerProcess->getCurrentStats();

    ui->labelInfoModule->setText(stats.sModule);

    if (stats.nTotalModule) {
        ui->progressBarModule->setValue((int)((stats.nCurrentModule * 100) / stats.nTotalModule));
    }

    if (stats.nTotalBytes) {
        ui->progressBarBytes->setValue((int)((stats.nCurrentBytes * 100) / stats.nTotalBytes));
    }
}

```

`gui_source/dialoggetfilefromserverprocess.h`:

```h
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#ifndef DIALOGGETFILEFROMSERVERPROCESS_H
#define DIALOGGETFILEFROMSERVERPROCESS_H

#include <QDialog>
#include <QThread>
#include <QTimer>

#include "../getfilefromserverprocess.h"

namespace Ui {
class DialogGetFileFromServerProcess;
}

class DialogGetFileFromServerProcess : public QDialog {
    Q_OBJECT

public:
    explicit DialogGetFileFromServerProcess(QWidget *pParent, QList<Utils::WEB_RECORD> listWebRecords);
    ~DialogGetFileFromServerProcess();

private slots:
    void on_pushButtonCancel_clicked();
    void onCompleted(qint64 nElapsed);
    void timerSlot();

signals:
    void errorMessage(QString sMessage);

private:
    Ui::DialogGetFileFromServerProcess *ui;
    GetFileFromServerProcess *pGetFileFromServerProcess;
    QThread *pThread;
    bool bIsRun;
    QTimer *pTimer;
};

#endif  // DIALOGGETFILEFROMSERVERPROCESS_H

```

`gui_source/dialoggetfilefromserverprocess.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>DialogGetFileFromServerProcess</class>
 <widget class="QDialog" name="DialogGetFileFromServerProcess">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>452</width>
    <height>135</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Download file</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QLabel" name="labelInfoModule">
     <property name="text">
      <string/>
     </property>
     <property name="alignment">
      <set>Qt::AlignCenter</set>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QProgressBar" name="progressBarModule">
     <property name="maximum">
      <number>0</number>
     </property>
     <property name="value">
      <number>0</number>
     </property>
     <property name="alignment">
      <set>Qt::AlignCenter</set>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QProgressBar" name="progressBarBytes">
     <property name="maximum">
      <number>0</number>
     </property>
     <property name="value">
      <number>0</number>
     </property>
     <property name="alignment">
      <set>Qt::AlignCenter</set>
     </property>
    </widget>
   </item>
   <item>
    <spacer name="verticalSpacer">
     <property name="orientation">
      <enum>Qt::Vertical</enum>
     </property>
     <property name="sizeHint" stdset="0">
      <size>
       <width>20</width>
       <height>6</height>
      </size>
     </property>
    </spacer>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <spacer name="horizontalSpacer">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
     <item>
      <widget class="QPushButton" name="pushButtonCancel">
       <property name="text">
        <string>Cancel</string>
       </property>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`gui_source/dialoginfomodule.cpp`:

```cpp
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#include "dialoginfomodule.h"

#include "ui_dialoginfomodule.h"

DialogInfoModule::DialogInfoModule(QWidget *pParent, Utils::MDATA *pMData) : QDialog(pParent), ui(new Ui::DialogInfoModule)
{
    ui->setupUi(this);

    ui->widgetInfo->setData(pMData);
}

DialogInfoModule::~DialogInfoModule()
{
    delete ui;
}

void DialogInfoModule::on_pushButtonOK_clicked()
{
    this->close();
}

```

`gui_source/dialoginfomodule.h`:

```h
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#ifndef DIALOGINFOMODULE_H
#define DIALOGINFOMODULE_H

#include <QDialog>

#include "../utils.h"

namespace Ui {
class DialogInfoModule;
}

class DialogInfoModule : public QDialog {
    Q_OBJECT

public:
    explicit DialogInfoModule(QWidget *pParent, Utils::MDATA *pMData);
    ~DialogInfoModule();

private slots:
    void on_pushButtonOK_clicked();

private:
    Ui::DialogInfoModule *ui;
};

#endif  // DIALOGINFOMODULE_H

```

`gui_source/dialoginfomodule.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>DialogInfoModule</class>
 <widget class="QDialog" name="DialogInfoModule">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>391</width>
    <height>326</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Information</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="PluginInfoWidget" name="widgetInfo" native="true">
     <property name="sizePolicy">
      <sizepolicy hsizetype="Preferred" vsizetype="Expanding">
       <horstretch>0</horstretch>
       <verstretch>0</verstretch>
      </sizepolicy>
     </property>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <spacer name="horizontalSpacer">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
     <item>
      <widget class="QPushButton" name="pushButtonOK">
       <property name="text">
        <string>OK</string>
       </property>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <customwidgets>
  <customwidget>
   <class>PluginInfoWidget</class>
   <extends>QWidget</extends>
   <header>plugininfowidget.h</header>
   <container>1</container>
  </customwidget>
 </customwidgets>
 <resources/>
 <connections/>
</ui>

```

`gui_source/dialoginstallmodule.cpp`:

```cpp
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#include "dialoginstallmodule.h"

#include "ui_dialoginstallmodule.h"

DialogInstallModule::DialogInstallModule(QWidget *pParent, QString sDataPath, QString sRootPath) : QDialog(pParent), ui(new Ui::DialogInstallModule)
{
    ui->setupUi(this);

    this->pParent = pParent;
    this->sDataPath = sDataPath;
    this->sRootPath = sRootPath;
}

DialogInstallModule::~DialogInstallModule()
{
    delete ui;
}

void DialogInstallModule::setFileName(QString sModuleFileName)
{
    this->sModuleFileName = sModuleFileName;

    _mdata = Utils::getMDataFromZip(sModuleFileName, XBinary::convertPathName(sRootPath));

    ui->widgetInfo->setData(&_mdata);

    int nCount = _mdata.listInstallRecords.count();

    ui->tableWidgetRecords->setColumnCount(1);
    ui->tableWidgetRecords->setRowCount(nCount);

    for (int i = 0; i < nCount; i++) {
        QTableWidgetItem *pItem = new QTableWidgetItem(_mdata.listInstallRecords.at(i).sPath);
        ui->tableWidgetRecords->setItem(i, 0, pItem);
    }
}

bool DialogInstallModule::setMData(Utils::MDATA *pMData)
{
    bool bResult = false;

    QString sSHA1 = pMData->sSHA1;

    QString sModuleFileName = Utils::getModuleFileName(sDataPath, pMData->sName);

    bool bHash = XBinary::isFileHashValid(XBinary::HASH_SHA1, sModuleFileName, sSHA1);

    if (!bHash) {
        if (pMData->sGithub != "") {
            QString sConvertPath = Utils::getConvertPath(sDataPath, pMData->sName);
            QString sDownloadModulePath = Utils::getConvertModulePath(sDataPath, pMData->sName);

            XBinary::createDirectory(sConvertPath);
            XBinary::createDirectory(sDownloadModulePath);

            QList<Utils::WEB_RECORD> listWebRecords;

            int nCount = pMData->listDownloads.count();

            for (int i = 0; i < nCount; i++) {
                Utils::WEB_RECORD record = {};

                QString sLink = pMData->listDownloads.at(i);

                record.sFileName = sConvertPath + QDir::separator() + sLink.section("/", -1, -1);
                record.sFileName = record.sFileName.remove("?raw=true");
                record.sLink = sLink;

                listWebRecords.append(record);
            }

            DialogGetFileFromServerProcess dialogGetFileFromServer(pParent, listWebRecords);

            connect(&dialogGetFileFromServer, SIGNAL(errorMessage(QString)), this, SIGNAL(errorMessage(QString)));

            dialogGetFileFromServer.exec();

            DialogConvertProcess dialogConvertProcess(pParent, pMData, sDataPath);

            connect(&dialogConvertProcess, SIGNAL(errorMessage(QString)), this, SIGNAL(errorMessage(QString)));

            dialogConvertProcess.exec();

            Utils::MDATA mdata = *pMData;

            mdata.sBundleFileName = Utils::getModuleFileName(sDataPath, mdata.sName);
            mdata.sRoot = sDownloadModulePath;

            QString sErrorString;

            if (Utils::checkMData(&mdata, &sErrorString)) {
                DialogCreateModuleProcess dcmp(pParent, &mdata, false);

                connect(&dcmp, SIGNAL(errorMessage(QString)), this, SIGNAL(errorMessage(QString)));

                dcmp.exec();
            } else {
                emit errorMessage(sErrorString);
            }

#ifndef QT_DEBUG
            XBinary::removeDirectory(sConvertPath);
#endif

            Utils::updateJsonFile(Utils::getServerListFileName(sDataPath), QList<Utils::MDATA>() << mdata);

            sSHA1 = mdata.sSHA1;
        } else {
            Utils::WEB_RECORD record = {};

            record.sFileName = sModuleFileName;
            record.sLink = pMData->sSrc;

            DialogGetFileFromServerProcess dialogGetFileFromServer(pParent, QList<Utils::WEB_RECORD>() << record);

            connect(&dialogGetFileFromServer, SIGNAL(errorMessage(QString)), this, SIGNAL(errorMessage(QString)));

            dialogGetFileFromServer.exec();
        }

        bHash = XBinary::isFileHashValid(XBinary::HASH_SHA1, sModuleFileName, sSHA1);
    }

    if (bHash) {
        setFileName(sModuleFileName);

        bResult = true;
    } else {
        emit errorMessage(QString("%1: %2").arg(tr("Invalid SHA1")).arg(sModuleFileName));
    }

    return bResult;
}

void DialogInstallModule::on_pushButtonCancel_clicked()
{
    this->close();
}

void DialogInstallModule::on_pushButtonOK_clicked()
{
    DialogInstallModuleProcess dimp(this, sDataPath, sRootPath, QList<QString>() << sModuleFileName);

    connect(&dimp, SIGNAL(errorMessage(QString)), this, SIGNAL(errorMessage(QString)));

    dimp.exec();

    this->close();
}

```

`gui_source/dialoginstallmodule.h`:

```h
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#ifndef DIALOGINSTALLMODULE_H
#define DIALOGINSTALLMODULE_H

#include <QDialog>

#include "../utils.h"
#include "dialogconvertprocess.h"
#include "dialogcreatemoduleprocess.h"
#include "dialoggetfilefromserverprocess.h"
#include "dialoginstallmoduleprocess.h"

namespace Ui {
class DialogInstallModule;
}

class DialogInstallModule : public QDialog {
    Q_OBJECT

public:
    explicit DialogInstallModule(QWidget *pParent, QString sDataPath, QString sRootPath);
    ~DialogInstallModule();
    void setFileName(QString sModuleFileName);
    bool setMData(Utils::MDATA *pMData);

private slots:
    void on_pushButtonCancel_clicked();
    void on_pushButtonOK_clicked();

signals:
    void errorMessage(QString sMessage);

private:
    Ui::DialogInstallModule *ui;
    QWidget *pParent;
    Utils::MDATA _mdata;
    QString sDataPath;
    QString sRootPath;
    QString sModuleFileName;
};

#endif  // DIALOGINSTALLMODULE_H

```

`gui_source/dialoginstallmodule.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>DialogInstallModule</class>
 <widget class="QDialog" name="DialogInstallModule">
  <property name="windowModality">
   <enum>Qt::ApplicationModal</enum>
  </property>
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>502</width>
    <height>461</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Install</string>
  </property>
  <property name="modal">
   <bool>true</bool>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout_2">
   <item>
    <widget class="PluginInfoWidget" name="widgetInfo" native="true">
     <property name="sizePolicy">
      <sizepolicy hsizetype="Preferred" vsizetype="Expanding">
       <horstretch>0</horstretch>
       <verstretch>0</verstretch>
      </sizepolicy>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QGroupBox" name="groupBoxRecords">
     <property name="title">
      <string>Files</string>
     </property>
     <layout class="QVBoxLayout" name="verticalLayout_6">
      <property name="leftMargin">
       <number>1</number>
      </property>
      <property name="topMargin">
       <number>1</number>
      </property>
      <property name="rightMargin">
       <number>1</number>
      </property>
      <property name="bottomMargin">
       <number>1</number>
      </property>
      <item>
       <widget class="QTableWidget" name="tableWidgetRecords">
        <property name="editTriggers">
         <set>QAbstractItemView::NoEditTriggers</set>
        </property>
        <property name="selectionBehavior">
         <enum>QAbstractItemView::SelectRows</enum>
        </property>
        <attribute name="horizontalHeaderVisible">
         <bool>false</bool>
        </attribute>
        <attribute name="horizontalHeaderStretchLastSection">
         <bool>true</bool>
        </attribute>
        <attribute name="verticalHeaderVisible">
         <bool>false</bool>
        </attribute>
        <attribute name="verticalHeaderMinimumSectionSize">
         <number>20</number>
        </attribute>
        <attribute name="verticalHeaderDefaultSectionSize">
         <number>20</number>
        </attribute>
       </widget>
      </item>
     </layout>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <spacer name="horizontalSpacer">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
     <item>
      <widget class="QPushButton" name="pushButtonCancel">
       <property name="text">
        <string>Cancel</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="pushButtonOK">
       <property name="text">
        <string>OK</string>
       </property>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <customwidgets>
  <customwidget>
   <class>PluginInfoWidget</class>
   <extends>QWidget</extends>
   <header>plugininfowidget.h</header>
   <container>1</container>
  </customwidget>
 </customwidgets>
 <resources/>
 <connections/>
</ui>

```

`gui_source/dialoginstallmoduleprocess.cpp`:

```cpp
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#include "dialoginstallmoduleprocess.h"

#include "ui_dialoginstallmoduleprocess.h"

DialogInstallModuleProcess::DialogInstallModuleProcess(QWidget *pParent, QString sDataPath, QString sRootPath, QList<QString> listModuleFileNames)
    : QDialog(pParent), ui(new Ui::DialogInstallModuleProcess)
{
    ui->setupUi(this);

    this->sDataPath = sDataPath;
    this->sRootPath = sRootPath;
    this->listModuleFileNames = listModuleFileNames;

    pInstallModuleProcess = new InstallModuleProcess;
    pThread = new QThread;

    pInstallModuleProcess->moveToThread(pThread);

    connect(pThread, SIGNAL(started()), pInstallModuleProcess, SLOT(process()));
    connect(pInstallModuleProcess, SIGNAL(completed(qint64)), this, SLOT(onCompleted(qint64)));
    connect(pInstallModuleProcess, SIGNAL(errorMessage(QString)), this, SIGNAL(errorMessage(QString)));

    pTimer = new QTimer(this);
    connect(pTimer, SIGNAL(timeout()), this, SLOT(timerSlot()));

    pInstallModuleProcess->setData(sDataPath, sRootPath, listModuleFileNames);

    bIsRun = true;

    ui->progressBarFile->setMaximum(100);
    ui->progressBarFile->setValue(0);

    ui->progressBarModule->setMaximum(100);
    ui->progressBarModule->setValue(0);

    pThread->start();
    pTimer->start(1000);  // 1 sec
}

DialogInstallModuleProcess::~DialogInstallModuleProcess()
{
    if (bIsRun) {
        pInstallModuleProcess->stop();
    }

    pTimer->stop();

    pThread->quit();
    pThread->wait();

    delete ui;

    delete pThread;
    delete pInstallModuleProcess;
}

void DialogInstallModuleProcess::on_pushButtonCancel_clicked()
{
    if (bIsRun) {
        pInstallModuleProcess->stop();
        pTimer->stop();
        bIsRun = false;
    }
}

void DialogInstallModuleProcess::onCompleted(qint64 nElapsed)
{
    Q_UNUSED(nElapsed)
    // TODO
    bIsRun = false;
    this->close();
}

void DialogInstallModuleProcess::timerSlot()
{
    Utils::STATS stats = pInstallModuleProcess->getCurrentStats();

    ui->labelInfoFile->setText(stats.sFile);

    if (stats.nTotalFile) {
        ui->progressBarFile->setValue((int)((stats.nCurrentFile * 100) / stats.nTotalFile));
    }

    ui->labelInfoModule->setText(stats.sModule);

    if (stats.nTotalModule) {
        ui->progressBarModule->setValue((int)((stats.nCurrentModule * 100) / stats.nTotalModule));
    }
}

```

`gui_source/dialoginstallmoduleprocess.h`:

```h
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#ifndef DIALOGINSTALLMODULEPROCESS_H
#define DIALOGINSTALLMODULEPROCESS_H

#include <QDialog>
#include <QThread>
#include <QTimer>

#include "../installmoduleprocess.h"
#include "../utils.h"

namespace Ui {
class DialogInstallModuleProcess;
}

class DialogInstallModuleProcess : public QDialog {
    Q_OBJECT

public:
    explicit DialogInstallModuleProcess(QWidget *pParent, QString sDataPath, QString sRootPath, QList<QString> listModuleFileNames);
    ~DialogInstallModuleProcess();

private slots:
    void on_pushButtonCancel_clicked();
    void onCompleted(qint64 nElapsed);
    void timerSlot();

signals:
    void errorMessage(QString sMessage);

private:
    Ui::DialogInstallModuleProcess *ui;
    QString sDataPath;
    QString sRootPath;
    QList<QString> listModuleFileNames;
    InstallModuleProcess *pInstallModuleProcess;
    QThread *pThread;
    bool bIsRun;
    QTimer *pTimer;
};

#endif  // DIALOGINSTALLMODULEPROCESS_H

```

`gui_source/dialoginstallmoduleprocess.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>DialogInstallModuleProcess</class>
 <widget class="QDialog" name="DialogInstallModuleProcess">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>444</width>
    <height>161</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Install</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QLabel" name="labelInfoModule">
     <property name="text">
      <string/>
     </property>
     <property name="alignment">
      <set>Qt::AlignCenter</set>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QLabel" name="labelInfoFile">
     <property name="text">
      <string/>
     </property>
     <property name="alignment">
      <set>Qt::AlignCenter</set>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QProgressBar" name="progressBarModule">
     <property name="maximum">
      <number>0</number>
     </property>
     <property name="value">
      <number>0</number>
     </property>
     <property name="alignment">
      <set>Qt::AlignCenter</set>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QProgressBar" name="progressBarFile">
     <property name="maximum">
      <number>0</number>
     </property>
     <property name="value">
      <number>0</number>
     </property>
     <property name="alignment">
      <set>Qt::AlignCenter</set>
     </property>
    </widget>
   </item>
   <item>
    <spacer name="verticalSpacer">
     <property name="orientation">
      <enum>Qt::Vertical</enum>
     </property>
     <property name="sizeHint" stdset="0">
      <size>
       <width>20</width>
       <height>6</height>
      </size>
     </property>
    </spacer>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <spacer name="horizontalSpacer">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
     <item>
      <widget class="QPushButton" name="pushButtonCancel">
       <property name="text">
        <string>Cancel</string>
       </property>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`gui_source/dialogoptions.cpp`:

```cpp
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#include "dialogoptions.h"

#include "ui_dialogoptions.h"

DialogOptions::DialogOptions(QWidget *pParent, XOptions *pOptions) : QDialog(pParent), ui(new Ui::DialogOptions)
{
    ui->setupUi(this);

    this->pOptions = pOptions;

    pOptions->setCheckBox(ui->checkBoxStayOnTop, XOptions::ID_VIEW_STAYONTOP);
    pOptions->setLineEdit(ui->lineEditRootPath, XOptions::ID_ROOTPATH);
    pOptions->setLineEdit(ui->lineEditDataPath, XOptions::ID_DATAPATH);
    pOptions->setLineEdit(ui->lineEditJSONLink, XOptions::ID_JSON);
}

DialogOptions::~DialogOptions()
{
    delete ui;
}

void DialogOptions::on_pushButtonOK_clicked()
{
    pOptions->getCheckBox(ui->checkBoxStayOnTop, XOptions::ID_VIEW_STAYONTOP);
    pOptions->getLineEdit(ui->lineEditRootPath, XOptions::ID_ROOTPATH);
    pOptions->getLineEdit(ui->lineEditDataPath, XOptions::ID_DATAPATH);
    pOptions->getLineEdit(ui->lineEditJSONLink, XOptions::ID_JSON);

    this->close();
}

void DialogOptions::on_pushButtonCancel_clicked()
{
    this->close();
}

void DialogOptions::on_toolButtonRootPath_clicked()
{
    QString sDirectoryName = QFileDialog::getExistingDirectory(this, tr("Select root directory"), XBinary::convertPathName(ui->lineEditRootPath->text()));

    if (sDirectoryName != "") {
        ui->lineEditRootPath->setText(sDirectoryName);
    }
}

void DialogOptions::on_toolButtonDataPath_clicked()
{
    QString sDirectoryName = QFileDialog::getExistingDirectory(this, tr("Select data directory"), XBinary::convertPathName(ui->lineEditDataPath->text()));

    if (sDirectoryName != "") {
        ui->lineEditDataPath->setText(sDirectoryName);
    }
}

```

`gui_source/dialogoptions.h`:

```h
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#ifndef DIALOGOPTIONS_H
#define DIALOGOPTIONS_H

#include <QDialog>
#include <QDir>
#include <QFileDialog>

#include "../global.h"
#include "../utils.h"
#include "xoptions.h"

namespace Ui {
class DialogOptions;
}

class DialogOptions : public QDialog {
    Q_OBJECT

public:
    explicit DialogOptions(QWidget *pParent, XOptions *pOptions);
    ~DialogOptions();

private slots:
    void on_pushButtonOK_clicked();
    void on_pushButtonCancel_clicked();
    void on_toolButtonRootPath_clicked();
    void on_toolButtonDataPath_clicked();

private:
    Ui::DialogOptions *ui;
    XOptions *pOptions;
};

#endif  // DIALOGOPTIONS_H

```

`gui_source/dialogoptions.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>DialogOptions</class>
 <widget class="QDialog" name="DialogOptions">
  <property name="windowModality">
   <enum>Qt::ApplicationModal</enum>
  </property>
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>463</width>
    <height>221</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Options</string>
  </property>
  <property name="modal">
   <bool>true</bool>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QCheckBox" name="checkBoxStayOnTop">
     <property name="text">
      <string>Stay on top</string>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QGroupBox" name="groupBoxRootPath">
     <property name="title">
      <string>Root path</string>
     </property>
     <layout class="QHBoxLayout" name="horizontalLayout_2">
      <property name="leftMargin">
       <number>1</number>
      </property>
      <property name="topMargin">
       <number>1</number>
      </property>
      <property name="rightMargin">
       <number>1</number>
      </property>
      <property name="bottomMargin">
       <number>1</number>
      </property>
      <item>
       <widget class="QLineEdit" name="lineEditRootPath"/>
      </item>
      <item>
       <widget class="QToolButton" name="toolButtonRootPath">
        <property name="text">
         <string>...</string>
        </property>
       </widget>
      </item>
     </layout>
    </widget>
   </item>
   <item>
    <widget class="QGroupBox" name="groupBoxDataPath">
     <property name="title">
      <string>Data path</string>
     </property>
     <layout class="QHBoxLayout" name="horizontalLayout_4">
      <property name="leftMargin">
       <number>1</number>
      </property>
      <property name="topMargin">
       <number>1</number>
      </property>
      <property name="rightMargin">
       <number>1</number>
      </property>
      <property name="bottomMargin">
       <number>1</number>
      </property>
      <item>
       <widget class="QLineEdit" name="lineEditDataPath"/>
      </item>
      <item>
       <widget class="QToolButton" name="toolButtonDataPath">
        <property name="text">
         <string>...</string>
        </property>
       </widget>
      </item>
     </layout>
    </widget>
   </item>
   <item>
    <widget class="QGroupBox" name="groupBoxJSONLink">
     <property name="title">
      <string>JSON link</string>
     </property>
     <layout class="QHBoxLayout" name="horizontalLayout_3">
      <property name="leftMargin">
       <number>1</number>
      </property>
      <property name="topMargin">
       <number>1</number>
      </property>
      <property name="rightMargin">
       <number>1</number>
      </property>
      <property name="bottomMargin">
       <number>1</number>
      </property>
      <item>
       <widget class="QLineEdit" name="lineEditJSONLink"/>
      </item>
     </layout>
    </widget>
   </item>
   <item>
    <spacer name="verticalSpacer">
     <property name="orientation">
      <enum>Qt::Vertical</enum>
     </property>
     <property name="sizeHint" stdset="0">
      <size>
       <width>20</width>
       <height>119</height>
      </size>
     </property>
    </spacer>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <spacer name="horizontalSpacer">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
     <item>
      <widget class="QPushButton" name="pushButtonCancel">
       <property name="text">
        <string>Cancel</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="pushButtonOK">
       <property name="text">
        <string>OK</string>
       </property>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`gui_source/dialogremovemodule.cpp`:

```cpp
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#include "dialogremovemodule.h"

#include "ui_dialogremovemodule.h"

DialogRemoveModule::DialogRemoveModule(QWidget *pParent, QString sDataPath, QString sRootPath, QString sModuleName) : QDialog(pParent), ui(new Ui::DialogRemoveModule)
{
    ui->setupUi(this);

    this->sDataPath = sDataPath;
    this->sRootPath = sRootPath;
    this->sModuleName = sModuleName;

    QString sFileName = Utils::getInstalledJsonFileName(sDataPath, sModuleName);

    Utils::MDATA mdata = Utils::getMDataFromJSONFile(sFileName);

    ui->widgetInfo->setData(&mdata);
}

DialogRemoveModule::~DialogRemoveModule()
{
    delete ui;
}

void DialogRemoveModule::on_pushButtonCancel_clicked()
{
    this->close();
}

void DialogRemoveModule::on_pushButtonOK_clicked()
{
    DialogRemoveModuleProcess drmp(this, sDataPath, sRootPath, QList<QString>() << sModuleName);

    connect(&drmp, SIGNAL(errorMessage(QString)), this, SIGNAL(errorMessage(QString)));

    drmp.exec();

    this->close();
}

```

`gui_source/dialogremovemodule.h`:

```h
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#ifndef DIALOGREMOVEMODULE_H
#define DIALOGREMOVEMODULE_H

#include <QDialog>

#include "../utils.h"
#include "dialogremovemoduleprocess.h"

namespace Ui {
class DialogRemoveModule;
}

class DialogRemoveModule : public QDialog {
    Q_OBJECT

public:
    explicit DialogRemoveModule(QWidget *pParent, QString sDataPath, QString sRootPath, QString sModuleName);
    ~DialogRemoveModule();

private slots:
    void on_pushButtonCancel_clicked();
    void on_pushButtonOK_clicked();

signals:
    void errorMessage(QString sMessage);

private:
    Ui::DialogRemoveModule *ui;
    QString sDataPath;
    QString sRootPath;
    QString sModuleName;
};

#endif  // DIALOGREMOVEMODULE_H

```

`gui_source/dialogremovemodule.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>DialogRemoveModule</class>
 <widget class="QDialog" name="DialogRemoveModule">
  <property name="windowModality">
   <enum>Qt::ApplicationModal</enum>
  </property>
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>390</width>
    <height>260</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Remove</string>
  </property>
  <property name="modal">
   <bool>true</bool>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout_2">
   <item>
    <widget class="PluginInfoWidget" name="widgetInfo" native="true">
     <property name="sizePolicy">
      <sizepolicy hsizetype="Preferred" vsizetype="Expanding">
       <horstretch>0</horstretch>
       <verstretch>0</verstretch>
      </sizepolicy>
     </property>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <spacer name="horizontalSpacer">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
     <item>
      <widget class="QPushButton" name="pushButtonCancel">
       <property name="text">
        <string>Cancel</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="pushButtonOK">
       <property name="text">
        <string>OK</string>
       </property>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <customwidgets>
  <customwidget>
   <class>PluginInfoWidget</class>
   <extends>QWidget</extends>
   <header>plugininfowidget.h</header>
   <container>1</container>
  </customwidget>
 </customwidgets>
 <resources/>
 <connections/>
</ui>

```

`gui_source/dialogremovemoduleprocess.cpp`:

```cpp
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#include "dialogremovemoduleprocess.h"

#include "ui_dialogremovemoduleprocess.h"

DialogRemoveModuleProcess::DialogRemoveModuleProcess(QWidget *pParent, QString sDataPath, QString sRootPath, QList<QString> listModuleNames)
    : QDialog(pParent), ui(new Ui::DialogRemoveModuleProcess)
{
    ui->setupUi(this);

    this->sDataPath = sDataPath;
    this->sRootPath = sRootPath;
    this->listModuleNames = listModuleNames;

    pRemoveModuleProcess = new RemoveModuleProcess;
    pThread = new QThread;

    pRemoveModuleProcess->moveToThread(pThread);

    connect(pThread, SIGNAL(started()), pRemoveModuleProcess, SLOT(process()));
    connect(pRemoveModuleProcess, SIGNAL(completed(qint64)), this, SLOT(onCompleted(qint64)));
    connect(pRemoveModuleProcess, SIGNAL(errorMessage(QString)), this, SIGNAL(errorMessage(QString)));

    pTimer = new QTimer(this);
    connect(pTimer, SIGNAL(timeout()), this, SLOT(timerSlot()));

    pRemoveModuleProcess->setData(sDataPath, sRootPath, listModuleNames);

    bIsRun = true;

    ui->progressBarFile->setMaximum(100);
    ui->progressBarFile->setValue(0);

    ui->progressBarModule->setMaximum(100);
    ui->progressBarModule->setValue(0);

    pThread->start();
    pTimer->start(1000);  // 1 sec
}

DialogRemoveModuleProcess::~DialogRemoveModuleProcess()
{
    if (bIsRun) {
        pRemoveModuleProcess->stop();
    }

    pTimer->stop();

    pThread->quit();
    pThread->wait();

    delete ui;

    delete pThread;
    delete pRemoveModuleProcess;
}

void DialogRemoveModuleProcess::on_pushButtonCancel_clicked()
{
    if (bIsRun) {
        pRemoveModuleProcess->stop();
        pTimer->stop();
        bIsRun = false;
    }
}

void DialogRemoveModuleProcess::onCompleted(qint64 nElapsed)
{
    Q_UNUSED(nElapsed)
    // TODO
    bIsRun = false;
    this->close();
}

void DialogRemoveModuleProcess::timerSlot()
{
    Utils::STATS stats = pRemoveModuleProcess->getCurrentStats();

    ui->labelInfoFile->setText(stats.sFile);

    if (stats.nTotalFile) {
        ui->progressBarFile->setValue((int)((stats.nCurrentFile * 100) / stats.nTotalFile));
    }

    ui->labelInfoModule->setText(stats.sModule);

    if (stats.nTotalModule) {
        ui->progressBarModule->setValue((int)((stats.nCurrentModule * 100) / stats.nTotalModule));
    }
}

```

`gui_source/dialogremovemoduleprocess.h`:

```h
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#ifndef DIALOGREMOVEMODULEPROCESS_H
#define DIALOGREMOVEMODULEPROCESS_H

#include <QDialog>
#include <QThread>
#include <QTimer>

#include "../removemoduleprocess.h"
#include "../utils.h"

namespace Ui {
class DialogRemoveModuleProcess;
}

class DialogRemoveModuleProcess : public QDialog {
    Q_OBJECT

public:
    explicit DialogRemoveModuleProcess(QWidget *pParent, QString sDataPath, QString sRootPath, QList<QString> listModuleNames);
    ~DialogRemoveModuleProcess();

private slots:
    void on_pushButtonCancel_clicked();
    void onCompleted(qint64 nElapsed);
    void timerSlot();

signals:
    void errorMessage(QString sMessage);

private:
    Ui::DialogRemoveModuleProcess *ui;
    QString sDataPath;
    QString sRootPath;
    QList<QString> listModuleNames;
    RemoveModuleProcess *pRemoveModuleProcess;
    QThread *pThread;
    bool bIsRun;
    QTimer *pTimer;
};

#endif  // DIALOGREMOVEMODULEPROCESS_H

```

`gui_source/dialogremovemoduleprocess.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>DialogRemoveModuleProcess</class>
 <widget class="QDialog" name="DialogRemoveModuleProcess">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>444</width>
    <height>149</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Remove Module</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QLabel" name="labelInfoModule">
     <property name="text">
      <string/>
     </property>
     <property name="alignment">
      <set>Qt::AlignCenter</set>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QLabel" name="labelInfoFile">
     <property name="text">
      <string/>
     </property>
     <property name="alignment">
      <set>Qt::AlignCenter</set>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QProgressBar" name="progressBarModule">
     <property name="maximum">
      <number>0</number>
     </property>
     <property name="value">
      <number>0</number>
     </property>
     <property name="alignment">
      <set>Qt::AlignCenter</set>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QProgressBar" name="progressBarFile">
     <property name="maximum">
      <number>0</number>
     </property>
     <property name="value">
      <number>0</number>
     </property>
     <property name="alignment">
      <set>Qt::AlignCenter</set>
     </property>
    </widget>
   </item>
   <item>
    <spacer name="verticalSpacer">
     <property name="orientation">
      <enum>Qt::Vertical</enum>
     </property>
     <property name="sizeHint" stdset="0">
      <size>
       <width>20</width>
       <height>44</height>
      </size>
     </property>
    </spacer>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <spacer name="horizontalSpacer">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
     <item>
      <widget class="QPushButton" name="pushButtonCancel">
       <property name="text">
        <string>Cancel</string>
       </property>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`gui_source/dialogupdategitprocess.cpp`:

```cpp
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#include "dialogupdategitprocess.h"

#include "ui_dialogupdategitprocess.h"

DialogUpdateGitProcess::DialogUpdateGitProcess(QWidget *pParent, QString sDataPath) : QDialog(pParent), ui(new Ui::DialogUpdateGitProcess)
{
    ui->setupUi(this);

    this->sDataPath = sDataPath;

    pUpdateGitProcess = new UpdateGitProcess;
    pThread = new QThread;

    pUpdateGitProcess->moveToThread(pThread);

    connect(pThread, SIGNAL(started()), pUpdateGitProcess, SLOT(process()));
    connect(pUpdateGitProcess, SIGNAL(completed(qint64)), this, SLOT(onCompleted(qint64)));
    connect(pUpdateGitProcess, SIGNAL(errorMessage(QString)), this, SIGNAL(errorMessage(QString)));

    pTimer = new QTimer(this);
    connect(pTimer, SIGNAL(timeout()), this, SLOT(timerSlot()));

    pUpdateGitProcess->setData(sDataPath);

    bIsRun = true;

    ui->progressBar->setMaximum(100);
    ui->progressBar->setValue(0);

    pThread->start();
    pTimer->start(100);  // 0.1 sec
}

DialogUpdateGitProcess::~DialogUpdateGitProcess()
{
    if (bIsRun) {
        pUpdateGitProcess->stop();
    }

    pTimer->stop();

    pThread->quit();
    pThread->wait();

    delete ui;

    delete pThread;
    delete pUpdateGitProcess;
}

void DialogUpdateGitProcess::on_pushButtonCancel_clicked()
{
    if (bIsRun) {
        pUpdateGitProcess->stop();
        pTimer->stop();
        bIsRun = false;
    }
}

void DialogUpdateGitProcess::onCompleted(qint64 nElapsed)
{
    Q_UNUSED(nElapsed)
    // TODO
    bIsRun = false;
    this->close();
}

void DialogUpdateGitProcess::timerSlot()
{
    Utils::STATS stats = pUpdateGitProcess->getCurrentStats();

    ui->labelInfo->setText(stats.sFile);

    if (stats.nTotalModule) {
        ui->progressBar->setValue((int)((stats.nCurrentModule * 100) / stats.nTotalModule));
    }
}

```

`gui_source/dialogupdategitprocess.h`:

```h
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#ifndef DIALOGUPDATEGITPROCESS_H
#define DIALOGUPDATEGITPROCESS_H

#include <QDialog>
#include <QThread>
#include <QTimer>

#include "../updategitprocess.h"
#include "../utils.h"

namespace Ui {
class DialogUpdateGitProcess;
}

class DialogUpdateGitProcess : public QDialog {
    Q_OBJECT

public:
    explicit DialogUpdateGitProcess(QWidget *pParent, QString sDataPath);
    ~DialogUpdateGitProcess();

private slots:
    void on_pushButtonCancel_clicked();
    void onCompleted(qint64 nElapsed);
    void timerSlot();

signals:
    void errorMessage(QString sMessage);

private:
    Ui::DialogUpdateGitProcess *ui;
    QString sDataPath;
    UpdateGitProcess *pUpdateGitProcess;
    QThread *pThread;
    bool bIsRun;
    QTimer *pTimer;
};

#endif  // DIALOGUPDATEGITPROCESS_H

```

`gui_source/dialogupdategitprocess.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>DialogUpdateGitProcess</class>
 <widget class="QDialog" name="DialogUpdateGitProcess">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>496</width>
    <height>103</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Update Github</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QLabel" name="labelInfo">
     <property name="text">
      <string/>
     </property>
     <property name="alignment">
      <set>Qt::AlignCenter</set>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QProgressBar" name="progressBar">
     <property name="maximum">
      <number>0</number>
     </property>
     <property name="value">
      <number>0</number>
     </property>
     <property name="alignment">
      <set>Qt::AlignCenter</set>
     </property>
    </widget>
   </item>
   <item>
    <spacer name="verticalSpacer">
     <property name="orientation">
      <enum>Qt::Vertical</enum>
     </property>
     <property name="sizeHint" stdset="0">
      <size>
       <width>20</width>
       <height>5</height>
      </size>
     </property>
    </spacer>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <spacer name="horizontalSpacer">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
     <item>
      <widget class="QPushButton" name="pushButtonCancel">
       <property name="text">
        <string>Cancel</string>
       </property>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`gui_source/gui_source.pro`:

```pro
QT       += core gui network

greaterThan(QT_MAJOR_VERSION, 4): QT += widgets

CONFIG += c++11

TARGET = x64plgmnr
TEMPLATE = app

include(../build.pri)

SOURCES += \
    ../convertprocess.cpp \
    ../getfilefromserverprocess.cpp \
    ../installmoduleprocess.cpp \
    ../removemoduleprocess.cpp \
    ../updategitprocess.cpp \
    ../utils.cpp \
    ../createmoduleprocess.cpp \
    dialogabout.cpp \
    dialogconvertprocess.cpp \
    dialogcreatemodule.cpp \
    dialogcreatemoduleprocess.cpp \
    dialoggetfilefromserverprocess.cpp \
    dialoginfomodule.cpp \
    dialoginstallmodule.cpp \
    dialoginstallmoduleprocess.cpp \
    dialogoptions.cpp \
    dialogremovemodule.cpp \
    dialogremovemoduleprocess.cpp \
    dialogupdategitprocess.cpp \
    guimainwindow.cpp \
    main_gui.cpp \
    plugininfowidget.cpp

HEADERS += \
    ../convertprocess.h \
    ../getfilefromserverprocess.h \
    ../global.h \
    ../installmoduleprocess.h \
    ../removemoduleprocess.h \
    ../updategitprocess.h \
    ../utils.h \
    ../createmoduleprocess.h \
    dialogabout.h \
    dialogconvertprocess.h \
    dialogcreatemodule.h \
    dialogcreatemoduleprocess.h \
    dialoggetfilefromserverprocess.h \
    dialoginfomodule.h \
    dialoginstallmodule.h \
    dialoginstallmoduleprocess.h \
    dialogoptions.h \
    dialogremovemodule.h \
    dialogremovemoduleprocess.h \
    dialogupdategitprocess.h \
    guimainwindow.h \
    plugininfowidget.h

FORMS += \
    dialogabout.ui \
    dialogconvertprocess.ui \
    dialogcreatemodule.ui \
    dialogcreatemoduleprocess.ui \
    dialoggetfilefromserverprocess.ui \
    dialoginfomodule.ui \
    dialoginstallmodule.ui \
    dialoginstallmoduleprocess.ui \
    dialogoptions.ui \
    dialogremovemodule.ui \
    dialogremovemoduleprocess.ui \
    dialogupdategitprocess.ui \
    guimainwindow.ui \
    plugininfowidget.ui

!contains(XCONFIG, xarchive) {
    XCONFIG += xarchive
    include(../XArchive/xarchive.pri)
}

!contains(XCONFIG, xgithub) {
    XCONFIG += xgithub
    include(../XGithub/xgithub.pri)
}

!contains(XCONFIG, xoptions) {
    XCONFIG += xoptions
    include(../XOptions/xoptions.pri)
}

win32 {
    RC_ICONS = ../icons/main.ico
}

RESOURCES += \
    resources.qrc

```

`gui_source/guimainwindow.cpp`:

```cpp
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#include "guimainwindow.h"

#include "ui_guimainwindow.h"

GuiMainWindow::GuiMainWindow(QWidget *pParent) : QMainWindow(pParent), ui(new Ui::GuiMainWindow)
{
    ui->setupUi(this);

    setWindowTitle(QString("%1 v%2").arg(X_APPLICATIONNAME).arg(X_APPLICATIONVERSION));

    setAcceptDrops(true);

    xOptions.setName(X_OPTIONSFILE);

    QList<XOptions::ID> listIDs;

    listIDs.append(XOptions::ID_VIEW_STAYONTOP);
    listIDs.append(XOptions::ID_DATAPATH);
    listIDs.append(XOptions::ID_ROOTPATH);
    listIDs.append(XOptions::ID_JSON);

    xOptions.setValueIDs(listIDs);

    QMap<XOptions::ID, QVariant> mapDefaultValues;

    mapDefaultValues.insert(XOptions::ID_JSON, X_JSON_DEFAULT);

    xOptions.setDefaultValues(mapDefaultValues);

    xOptions.load();

    xOptions.adjustStayOnTop(this);

    if (!XBinary::isDirectoryExists(XBinary::convertPathName(xOptions.getRootPath()))) {
        xOptions.clearValue(XOptions::ID_ROOTPATH);
    }

    if (xOptions.getRootPath() == "") {
        QString sDirectoryName;

        if (QMessageBox::information(this, tr("Information"), tr("Please select a root directory for x64dbg"), QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes) ==
            QMessageBox::Yes) {
            sDirectoryName = QFileDialog::getExistingDirectory(this, tr("Select root directory"));
        }

        if (sDirectoryName != "") {
            xOptions.setValue(XOptions::ID_ROOTPATH, sDirectoryName);
        }
    }

    if (xOptions.getRootPath() == "") {
        exit(1);
    }

    XBinary::createDirectory(XBinary::convertPathName(xOptions.getDataPath()));
    XBinary::createDirectory(XBinary::convertPathName(xOptions.getDataPath()) + QDir::separator() + "installed");
    XBinary::createDirectory(XBinary::convertPathName(xOptions.getDataPath()) + QDir::separator() + "modules");

    setAcceptDrops(true);

    if (QCoreApplication::arguments().count() > 1) {
        QString sFileName = QCoreApplication::arguments().at(1);

        openPlugin(sFileName);
    } else {
        if (!XBinary::isFileExists(Utils::getServerListFileName(xOptions.getDataPath()))) {
            updateJsonList();
        }
    }

    adjustTable(ui->tableWidgetServerList);
    adjustTable(ui->tableWidgetInstalled);

    getModules();
}

GuiMainWindow::~GuiMainWindow()
{
    xOptions.save();

    delete ui;
}

void GuiMainWindow::adjustTable(QTableWidget *pTableWidget)
{
    pTableWidget->setColumnCount(CN_size);
    pTableWidget->setRowCount(0);

    pTableWidget->setHorizontalHeaderItem(CN_NAME, new QTableWidgetItem(tr("Name")));
    pTableWidget->setHorizontalHeaderItem(CN_INFO, new QTableWidgetItem(tr("Information")));
    pTableWidget->setHorizontalHeaderItem(CN_32, new QTableWidgetItem(tr("32")));
    pTableWidget->setHorizontalHeaderItem(CN_64, new QTableWidgetItem(tr("64")));
    pTableWidget->setHorizontalHeaderItem(CN_VERSION, new QTableWidgetItem(tr("Version")));
    pTableWidget->setHorizontalHeaderItem(CN_DATE, new QTableWidgetItem(tr("Date")));
    pTableWidget->setHorizontalHeaderItem(CN_INSTALL, new QTableWidgetItem(""));
    pTableWidget->setHorizontalHeaderItem(CN_REMOVE, new QTableWidgetItem(""));

    pTableWidget->setColumnWidth(CN_NAME, 100);
    pTableWidget->setColumnWidth(CN_INFO, 300);
    pTableWidget->setColumnWidth(CN_32, 10);
    pTableWidget->setColumnWidth(CN_64, 10);
    pTableWidget->setColumnWidth(CN_VERSION, 80);
    pTableWidget->setColumnWidth(CN_DATE, 80);
    pTableWidget->setColumnWidth(CN_INSTALL, 60);
    pTableWidget->setColumnWidth(CN_REMOVE, 60);

    pTableWidget->horizontalHeader()->setSectionResizeMode(CN_NAME, QHeaderView::ResizeToContents);
    pTableWidget->horizontalHeader()->setSectionResizeMode(CN_INFO, QHeaderView::Stretch);
    pTableWidget->horizontalHeader()->setSectionResizeMode(CN_32, QHeaderView::ResizeToContents);
    pTableWidget->horizontalHeader()->setSectionResizeMode(CN_64, QHeaderView::ResizeToContents);
    pTableWidget->horizontalHeader()->setSectionResizeMode(CN_VERSION, QHeaderView::ResizeToContents);
    pTableWidget->horizontalHeader()->setSectionResizeMode(CN_DATE, QHeaderView::ResizeToContents);
    pTableWidget->horizontalHeader()->setSectionResizeMode(CN_INSTALL, QHeaderView::Interactive);
    pTableWidget->horizontalHeader()->setSectionResizeMode(CN_REMOVE, QHeaderView::Interactive);
}

void GuiMainWindow::fillTable(QTableWidget *pTableWidget, QList<Utils::MDATA> *pMData, QMap<QString, Utils::STATUS> *pMapStatus)
{
    int nCount = pMData->count();

    pTableWidget->setSortingEnabled(false);

    pTableWidget->setRowCount(0);
    pTableWidget->setRowCount(nCount);

    QColor colDisabled = QWidget::palette().color(QPalette::Window);

    for (int i = 0; i < nCount; i++) {
        Utils::STATUS status = pMapStatus->value(pMData->at(i).sName);

        QTableWidgetItem *pItemName = new QTableWidgetItem;
        QTableWidgetItem *pItemInfo = new QTableWidgetItem;
        QCheckBox *pCheckBoxIs32 = new QCheckBox(this);
        QCheckBox *pCheckBoxIs64 = new QCheckBox(this);
        QTableWidgetItem *pItemVersion = new QTableWidgetItem;
        QTableWidgetItem *pItemDate = new QTableWidgetItem;

        if (status.bUpdate) {
            pItemName->setBackgroundColor(colDisabled);
            pItemInfo->setBackgroundColor(colDisabled);
            pItemVersion->setBackgroundColor(colDisabled);
            pItemDate->setBackgroundColor(colDisabled);
        }

        pItemName->setText(pMData->at(i).sName);
        pItemName->setData(Qt::UserRole, pMData->at(i).sName);
        pTableWidget->setItem(i, CN_NAME, pItemName);

        pItemInfo->setText(pMData->at(i).sInfo);
        pTableWidget->setItem(i, CN_INFO, pItemInfo);

        pCheckBoxIs32->setEnabled(false);
        pCheckBoxIs32->setChecked(pMData->at(i).bIs32);
        pTableWidget->setCellWidget(i, CN_32, pCheckBoxIs32);

        pCheckBoxIs64->setEnabled(false);
        pCheckBoxIs64->setChecked(pMData->at(i).bIs64);
        pTableWidget->setCellWidget(i, CN_64, pCheckBoxIs64);

        pItemVersion->setText(pMData->at(i).sVersion);
        pTableWidget->setItem(i, CN_VERSION, pItemVersion);

        pItemDate->setText(pMData->at(i).sDate);
        pTableWidget->setItem(i, CN_DATE, pItemDate);

        if (status.bInstall || status.bUpdate) {
            QToolButton *pPushButtonInstall = new QToolButton(this);
            pPushButtonInstall->setProperty("Name", pMData->at(i).sName);
            connect(pPushButtonInstall, SIGNAL(clicked()), this, SLOT(installButtonSlot()));

            if (status.bInstall) {
                pPushButtonInstall->setText(tr("Install"));
            } else if (status.bUpdate) {
                pPushButtonInstall->setText(tr("Update"));
            }

            pTableWidget->setCellWidget(i, CN_INSTALL, pPushButtonInstall);
        }

        if (status.bRemove) {
            QToolButton *pPushButtonRemove = new QToolButton(this);
            pPushButtonRemove->setProperty("Name", pMData->at(i).sName);
            connect(pPushButtonRemove, SIGNAL(clicked()), this, SLOT(removeButtonSlot()));
            pPushButtonRemove->setText(tr("Remove"));
            pTableWidget->setCellWidget(i, CN_REMOVE, pPushButtonRemove);
        }
    }

    pTableWidget->setSortingEnabled(true);
}

void GuiMainWindow::createPlugin()
{
    DialogCreateModule dialogCreateModule(this);

    connect(&dialogCreateModule, SIGNAL(errorMessage(QString)), this, SLOT(errorMessage(QString)));

    dialogCreateModule.exec();
}

void GuiMainWindow::aboutDialog()
{
    DialogAbout dialogAbout(this);

    dialogAbout.exec();
}

void GuiMainWindow::openPlugin()
{
    QString sInitDirectory;  // TODO

    QString sFileName = QFileDialog::getOpenFileName(this, tr("Open plugin"), sInitDirectory, "*.x64dbg.zip");

    if (sFileName != "") {
        openPlugin(sFileName);
    }
}

void GuiMainWindow::optionsDialog()
{
    DialogOptions dialogOptions(this, &xOptions);

    dialogOptions.exec();

    xOptions.adjustStayOnTop(this);
}

void GuiMainWindow::exitProgram()
{
    this->close();
}

void GuiMainWindow::errorMessage(QString sMessage)
{
    QMessageBox::critical(this, tr("Error"), sMessage);
}

void GuiMainWindow::getModules()
{
    modulesData = Utils::getModulesData(xOptions.getDataPath());

    fillTable(ui->tableWidgetServerList, &(modulesData.listServerList), &(modulesData.mapStatus));
    fillTable(ui->tableWidgetInstalled, &(modulesData.listInstalled), &(modulesData.mapStatus));

    ui->pushButtonUpdateAllInstalledPlugins->setEnabled(modulesData.listUpdates.count());
}

void GuiMainWindow::openPlugin(QString sFileName)
{
    if (Utils::isPluginValid(sFileName)) {
        DialogInstallModule dialogInstallModule(this, xOptions.getDataPath(), xOptions.getRootPath());
        connect(&dialogInstallModule, SIGNAL(errorMessage(QString)), this, SLOT(errorMessage(QString)));

        dialogInstallModule.setFileName(sFileName);
        dialogInstallModule.exec();

        getModules();
    } else {
        errorMessage(QString("%1: %2").arg(tr("Invalid plugin file")).arg(sFileName));
    }
}

void GuiMainWindow::updateJsonList()
{
    QString sServerListFileName = Utils::getServerListFileName(xOptions.getDataPath());
    QString sServerLastestListFileName = Utils::getServerLastestListFileName(xOptions.getDataPath());

    Utils::WEB_RECORD record = {};

    record.sFileName = sServerLastestListFileName;
    record.sLink = xOptions.getJson();

    DialogGetFileFromServerProcess dialogGetFileFromServer(this, QList<Utils::WEB_RECORD>() << record);

    connect(&dialogGetFileFromServer, SIGNAL(errorMessage(QString)), this, SLOT(errorMessage(QString)));

    dialogGetFileFromServer.exec();

    if (Utils::isGithubPresent(sServerLastestListFileName)) {
        DialogUpdateGitProcess dialogUpdateGitProcess(this, sServerLastestListFileName);

        connect(&dialogUpdateGitProcess, SIGNAL(errorMessage(QString)), this, SLOT(errorMessage(QString)));

        dialogUpdateGitProcess.exec();
    }

    Utils::updateServerList(sServerListFileName, sServerLastestListFileName);
}

void GuiMainWindow::installButtonSlot()
{
    QToolButton *pPushButton = qobject_cast<QToolButton *>(sender());
    QString sName = pPushButton->property("Name").toString();

    installPlugin(sName);
}

void GuiMainWindow::removeButtonSlot()
{
    QToolButton *pPushButton = qobject_cast<QToolButton *>(sender());
    QString sName = pPushButton->property("Name").toString();

    removePlugin(sName);
}

void GuiMainWindow::installPlugin(QString sName)
{
    if (sName != "") {
        Utils::MDATA mdata = Utils::getMDataByName(&(modulesData.listServerList), sName);

        if (mdata.sName != "") {
            DialogInstallModule dialogInstallModule(this, xOptions.getDataPath(), xOptions.getRootPath());
            connect(&dialogInstallModule, SIGNAL(errorMessage(QString)), this, SLOT(errorMessage(QString)));

            if (dialogInstallModule.setMData(&mdata)) {
                dialogInstallModule.exec();

                getModules();
            }
        }
    }
}

void GuiMainWindow::installPlugins(QList<QString> *pListNames)
{
    QList<QString> listFileNames;

    int nCount = pListNames->count();

    for (int i = 0; i < nCount; i++) {
        Utils::MDATA mdata = Utils::getMDataByName(&(modulesData.listServerList), pListNames->at(i));

        if (mdata.sName != "") {
            QString sFileName = Utils::getModuleFileName(xOptions.getDataPath(), mdata.sName);

            if (XBinary::isFileHashValid(XBinary::HASH_SHA1, sFileName, mdata.sSHA1)) {
                listFileNames.append(sFileName);
            }
        }
    }

    if (listFileNames.count()) {
        DialogInstallModuleProcess dialogInstallModuleProcess(this, xOptions.getDataPath(), xOptions.getRootPath(), listFileNames);

        connect(&dialogInstallModuleProcess, SIGNAL(errorMessage(QString)), this, SLOT(errorMessage(QString)));

        dialogInstallModuleProcess.exec();

        getModules();
    }
}

void GuiMainWindow::removePlugin(QString sName)
{
    if (sName != "") {
        DialogRemoveModule dialogRemoveModule(this, xOptions.getDataPath(), xOptions.getRootPath(), sName);

        connect(&dialogRemoveModule, SIGNAL(errorMessage(QString)), this, SLOT(errorMessage(QString)));

        dialogRemoveModule.exec();

        getModules();
    }
}

void GuiMainWindow::infoPlugin(Utils::MDATA *pMData)
{
    if (pMData->sName != "") {
        DialogInfoModule dialogInfoModule(this, pMData);

        dialogInfoModule.exec();
    }
}

void GuiMainWindow::dragEnterEvent(QDragEnterEvent *pEvent)
{
    const QMimeData *mimeData = pEvent->mimeData();

    if (mimeData->hasUrls()) {
        QList<QUrl> urlList = mimeData->urls();

        if (urlList.count()) {
            QString sFileName = urlList.at(0).toLocalFile();

            if (Utils::isPluginValid(sFileName)) {
                pEvent->acceptProposedAction();
            }
        }
    }
}

void GuiMainWindow::dragMoveEvent(QDragMoveEvent *pEvent)
{
    pEvent->acceptProposedAction();
}

void GuiMainWindow::dropEvent(QDropEvent *pEvent)
{
    const QMimeData *mimeData = pEvent->mimeData();

    if (mimeData->hasUrls()) {
        QList<QUrl> urlList = mimeData->urls();

        if (urlList.count()) {
            QString sFileName = urlList.at(0).toLocalFile();

            sFileName = XBinary::convertFileName(sFileName);

            openPlugin(sFileName);
        }
    }
}

void GuiMainWindow::on_tableWidgetServerList_customContextMenuRequested(const QPoint &pos)
{
    if (ui->tableWidgetServerList->selectedItems().count()) {
        QMenu contextMenu(this);

        QAction actionInfo(tr("Info"), this);
        connect(&actionInfo, SIGNAL(triggered()), this, SLOT(_infoPluginServerList()));

        QAction actionInstall(tr("Install"), this);
        connect(&actionInstall, SIGNAL(triggered()), this, SLOT(_installPluginServerList()));

        QAction actionUpdate(tr("Update"), this);
        connect(&actionUpdate, SIGNAL(triggered()), this, SLOT(_installPluginServerList()));

        QAction actionRemove(tr("Remove"), this);
        connect(&actionRemove, SIGNAL(triggered()), this, SLOT(_removePluginServerList()));

        contextMenu.addAction(&actionInfo);
        contextMenu.addSeparator();

        QString sName = ui->tableWidgetServerList->selectedItems().at(0)->data(Qt::UserRole).toString();

        Utils::STATUS status = modulesData.mapStatus.value(sName);

        if (status.bInstall) {
            contextMenu.addAction(&actionInstall);
        }

        if (status.bUpdate) {
            contextMenu.addAction(&actionUpdate);
        }

        if (status.bRemove) {
            contextMenu.addAction(&actionRemove);
        }

        contextMenu.exec(ui->tableWidgetServerList->viewport()->mapToGlobal(pos));
    }
}

void GuiMainWindow::on_tableWidgetInstalled_customContextMenuRequested(const QPoint &pos)
{
    if (ui->tableWidgetInstalled->selectedItems().count()) {
        QMenu contextMenu(this);

        QAction actionInfo(tr("Info"), this);
        connect(&actionInfo, SIGNAL(triggered()), this, SLOT(_infoPluginInstalled()));

        QAction actionInstall(tr("Install"), this);
        connect(&actionInstall, SIGNAL(triggered()), this, SLOT(_installPluginInstalled()));

        QAction actionUpdate(tr("Update"), this);
        connect(&actionUpdate, SIGNAL(triggered()), this, SLOT(_installPluginInstalled()));

        QAction actionRemove(tr("Remove"), this);
        connect(&actionRemove, SIGNAL(triggered()), this, SLOT(_removePluginInstalled()));

        contextMenu.addAction(&actionInfo);
        contextMenu.addSeparator();

        QString sName = ui->tableWidgetInstalled->selectedItems().at(0)->data(Qt::UserRole).toString();

        Utils::STATUS status = modulesData.mapStatus.value(sName);

        if (status.bInstall) {
            contextMenu.addAction(&actionInstall);
        }

        if (status.bUpdate) {
            contextMenu.addAction(&actionUpdate);
        }

        if (status.bRemove) {
            contextMenu.addAction(&actionRemove);
        }

        contextMenu.exec(ui->tableWidgetInstalled->viewport()->mapToGlobal(pos));
    }
}

void GuiMainWindow::_infoPluginServerList()
{
    if (ui->tableWidgetServerList->selectedItems().count()) {
        QString sName = ui->tableWidgetServerList->selectedItems().at(0)->data(Qt::UserRole).toString();

        Utils::MDATA mdata = Utils::getMDataByName(&(modulesData.listServerList), sName);

        infoPlugin(&mdata);
    }
}

void GuiMainWindow::_installPluginServerList()
{
    if (ui->tableWidgetServerList->selectedItems().count()) {
        QString sName = ui->tableWidgetServerList->selectedItems().at(0)->data(Qt::UserRole).toString();

        installPlugin(sName);
    }
}

void GuiMainWindow::_removePluginServerList()
{
    if (ui->tableWidgetServerList->selectedItems().count()) {
        QString sName = ui->tableWidgetServerList->selectedItems().at(0)->data(Qt::UserRole).toString();

        removePlugin(sName);
    }
}

void GuiMainWindow::_infoPluginInstalled()
{
    if (ui->tableWidgetInstalled->selectedItems().count()) {
        QString sName = ui->tableWidgetInstalled->selectedItems().at(0)->data(Qt::UserRole).toString();

        Utils::MDATA mdata = Utils::getMDataByName(&(modulesData.listInstalled), sName);

        infoPlugin(&mdata);
    }
}

void GuiMainWindow::_installPluginInstalled()
{
    if (ui->tableWidgetInstalled->selectedItems().count()) {
        QString sName = ui->tableWidgetInstalled->selectedItems().at(0)->data(Qt::UserRole).toString();

        installPlugin(sName);
    }
}

void GuiMainWindow::_removePluginInstalled()
{
    if (ui->tableWidgetInstalled->selectedItems().count()) {
        QString sName = ui->tableWidgetInstalled->selectedItems().at(0)->data(Qt::UserRole).toString();

        removePlugin(sName);
    }
}

void GuiMainWindow::updateServerList()
{
    updateJsonList();

    getModules();
}

void GuiMainWindow::updateAllInstalledPlugins()
{
    DialogGetFileFromServerProcess dialogGetFileFromServer(this, modulesData.listUpdates);

    connect(&dialogGetFileFromServer, SIGNAL(errorMessage(QString)), this, SLOT(errorMessage(QString)));

    dialogGetFileFromServer.exec();

    QList<QString> listNames = Utils::getNamesFromWebRecords(&modulesData.listUpdates);

    installPlugins(&listNames);
}

void GuiMainWindow::checkForUpdates()
{
    QNetworkAccessManager manager(this);
    QNetworkRequest request(QUrl(X_SERVERVERSION));
    QNetworkReply *pReply = manager.get(request);
    QEventLoop loop;
    QObject::connect(pReply, SIGNAL(finished()), &loop, SLOT(quit()));
    loop.exec();

    if (pReply->error() == QNetworkReply::NoError) {
        if (pReply->bytesAvailable()) {
            QByteArray baData = pReply->readAll();
            QString sVersion = QString(baData.data());

            if (QCoreApplication::applicationVersion().toDouble() < sVersion.toDouble()) {
                if (QMessageBox::information(this, tr("Update information"),
                                             QString("%1\r\n\r\n%2\r\n\r\n%3").arg(tr("New version available")).arg(sVersion).arg(tr("Go to download page?")),
                                             QMessageBox::Yes, QMessageBox::No) == QMessageBox::Yes) {
                    QDesktopServices::openUrl(QUrl(X_HOMEPAGE));
                }
            } else {
                QMessageBox::information(this, tr("Update information"), tr("No update available"));
            }
        }
    } else {
        QMessageBox::critical(this, tr("Network error"), pReply->errorString());
    }

    delete pReply;
}

void GuiMainWindow::on_pushButtonUpdateServerList_clicked()
{
    updateServerList();
}

void GuiMainWindow::on_pushButtonUpdateAllInstalledPlugins_clicked()
{
    updateAllInstalledPlugins();
}

void GuiMainWindow::on_actionExit_triggered()
{
    exitProgram();
}

void GuiMainWindow::on_actionAbout_triggered()
{
    aboutDialog();
}

void GuiMainWindow::on_actionOpen_triggered()
{
    openPlugin();
}

void GuiMainWindow::on_actionCreate_triggered()
{
    createPlugin();
}

void GuiMainWindow::on_actionOptions_triggered()
{
    optionsDialog();
}

void GuiMainWindow::on_actionUpdate_server_list_triggered()
{
    updateServerList();
}

void GuiMainWindow::on_actionUpdate_all_installed_plugins_triggered()
{
    updateAllInstalledPlugins();
}

void GuiMainWindow::on_actionCheck_for_updates_triggered()
{
    checkForUpdates();
}

```

`gui_source/guimainwindow.h`:

```h
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#ifndef GUIMAINWINDOW_H
#define GUIMAINWINDOW_H

#include <QCheckBox>
#include <QDesktopServices>
#include <QDragEnterEvent>
#include <QMainWindow>
#include <QMessageBox>
#include <QMimeData>
#include <QTableWidget>
#include <QToolButton>

#include "../global.h"
#include "dialogabout.h"
#include "dialogcreatemodule.h"
#include "dialoggetfilefromserverprocess.h"
#include "dialoginfomodule.h"
#include "dialoginstallmodule.h"
#include "dialogoptions.h"
#include "dialogremovemodule.h"
#include "dialogupdategitprocess.h"

QT_BEGIN_NAMESPACE
namespace Ui {
class GuiMainWindow;
}
QT_END_NAMESPACE

class GuiMainWindow : public QMainWindow {
    Q_OBJECT

    enum CN {
        CN_NAME = 0,
        CN_INFO,
        CN_32,
        CN_64,
        CN_VERSION,
        CN_DATE,
        CN_INSTALL,
        CN_REMOVE,
        CN_size
    };

public:
    GuiMainWindow(QWidget *pParent = nullptr);
    ~GuiMainWindow();

private:
    void adjustTable(QTableWidget *pTableWidget);
    void fillTable(QTableWidget *pTableWidget, QList<Utils::MDATA> *pMData, QMap<QString, Utils::STATUS> *pMapStatus);

private slots:
    void createPlugin();
    void aboutDialog();
    void openPlugin();
    void optionsDialog();
    void exitProgram();
    void errorMessage(QString sMessage);
    void getModules();
    void openPlugin(QString sFileName);
    void updateJsonList();
    void installButtonSlot();
    void removeButtonSlot();
    void installPlugin(QString sName);
    void installPlugins(QList<QString> *pListNames);
    void removePlugin(QString sName);
    void infoPlugin(Utils::MDATA *pMData);
    void on_tableWidgetServerList_customContextMenuRequested(const QPoint &pos);
    void on_tableWidgetInstalled_customContextMenuRequested(const QPoint &pos);
    void _infoPluginServerList();
    void _installPluginServerList();
    void _removePluginServerList();
    void _infoPluginInstalled();
    void _installPluginInstalled();
    void _removePluginInstalled();
    void updateServerList();
    void updateAllInstalledPlugins();
    void checkForUpdates();
    void on_pushButtonUpdateServerList_clicked();
    void on_pushButtonUpdateAllInstalledPlugins_clicked();
    void on_actionExit_triggered();
    void on_actionAbout_triggered();
    void on_actionOpen_triggered();
    void on_actionCreate_triggered();
    void on_actionOptions_triggered();
    void on_actionUpdate_server_list_triggered();
    void on_actionUpdate_all_installed_plugins_triggered();
    void on_actionCheck_for_updates_triggered();

protected:
    void dragEnterEvent(QDragEnterEvent *pEvent) override;
    void dragMoveEvent(QDragMoveEvent *pEvent) override;
    void dropEvent(QDropEvent *pEvent) override;

private:
    Ui::GuiMainWindow *ui;
    XOptions xOptions;
    Utils::MODULES_DATA modulesData;
};
#endif  // GUIMAINWINDOW_H

```

`gui_source/guimainwindow.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>GuiMainWindow</class>
 <widget class="QMainWindow" name="GuiMainWindow">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>834</width>
    <height>373</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>GuiMainWindow</string>
  </property>
  <widget class="QWidget" name="centralwidget">
   <layout class="QVBoxLayout" name="verticalLayout_2">
    <item>
     <layout class="QHBoxLayout" name="horizontalLayout_3">
      <item>
       <widget class="QPushButton" name="pushButtonUpdateServerList">
        <property name="text">
         <string>Update server list</string>
        </property>
       </widget>
      </item>
      <item>
       <spacer name="horizontalSpacer_3">
        <property name="orientation">
         <enum>Qt::Horizontal</enum>
        </property>
        <property name="sizeHint" stdset="0">
         <size>
          <width>40</width>
          <height>20</height>
         </size>
        </property>
       </spacer>
      </item>
      <item>
       <widget class="QPushButton" name="pushButtonUpdateAllInstalledPlugins">
        <property name="text">
         <string>Update all installed plugins</string>
        </property>
       </widget>
      </item>
     </layout>
    </item>
    <item>
     <widget class="QTabWidget" name="tabWidgetPlugins">
      <property name="currentIndex">
       <number>0</number>
      </property>
      <widget class="QWidget" name="tabServerList">
       <attribute name="title">
        <string>Server list</string>
       </attribute>
       <layout class="QVBoxLayout" name="verticalLayout">
        <property name="leftMargin">
         <number>1</number>
        </property>
        <property name="topMargin">
         <number>1</number>
        </property>
        <property name="rightMargin">
         <number>1</number>
        </property>
        <property name="bottomMargin">
         <number>1</number>
        </property>
        <item>
         <widget class="QTableWidget" name="tableWidgetServerList">
          <property name="contextMenuPolicy">
           <enum>Qt::CustomContextMenu</enum>
          </property>
          <property name="editTriggers">
           <set>QAbstractItemView::NoEditTriggers</set>
          </property>
          <property name="selectionMode">
           <enum>QAbstractItemView::SingleSelection</enum>
          </property>
          <property name="selectionBehavior">
           <enum>QAbstractItemView::SelectRows</enum>
          </property>
          <property name="sortingEnabled">
           <bool>true</bool>
          </property>
          <attribute name="horizontalHeaderMinimumSectionSize">
           <number>5</number>
          </attribute>
          <attribute name="horizontalHeaderStretchLastSection">
           <bool>false</bool>
          </attribute>
          <attribute name="verticalHeaderVisible">
           <bool>false</bool>
          </attribute>
          <attribute name="verticalHeaderMinimumSectionSize">
           <number>20</number>
          </attribute>
          <attribute name="verticalHeaderDefaultSectionSize">
           <number>20</number>
          </attribute>
         </widget>
        </item>
       </layout>
      </widget>
      <widget class="QWidget" name="tabInstalled">
       <attribute name="title">
        <string>Installed</string>
       </attribute>
       <layout class="QVBoxLayout" name="verticalLayout_3">
        <property name="leftMargin">
         <number>1</number>
        </property>
        <property name="topMargin">
         <number>1</number>
        </property>
        <property name="rightMargin">
         <number>1</number>
        </property>
        <property name="bottomMargin">
         <number>1</number>
        </property>
        <item>
         <widget class="QTableWidget" name="tableWidgetInstalled">
          <property name="contextMenuPolicy">
           <enum>Qt::CustomContextMenu</enum>
          </property>
          <property name="editTriggers">
           <set>QAbstractItemView::NoEditTriggers</set>
          </property>
          <property name="selectionMode">
           <enum>QAbstractItemView::SingleSelection</enum>
          </property>
          <property name="selectionBehavior">
           <enum>QAbstractItemView::SelectRows</enum>
          </property>
          <property name="sortingEnabled">
           <bool>true</bool>
          </property>
          <attribute name="horizontalHeaderMinimumSectionSize">
           <number>5</number>
          </attribute>
          <attribute name="horizontalHeaderStretchLastSection">
           <bool>false</bool>
          </attribute>
          <attribute name="verticalHeaderVisible">
           <bool>false</bool>
          </attribute>
          <attribute name="verticalHeaderMinimumSectionSize">
           <number>20</number>
          </attribute>
          <attribute name="verticalHeaderDefaultSectionSize">
           <number>20</number>
          </attribute>
         </widget>
        </item>
       </layout>
      </widget>
     </widget>
    </item>
   </layout>
  </widget>
  <widget class="QMenuBar" name="menubar">
   <property name="geometry">
    <rect>
     <x>0</x>
     <y>0</y>
     <width>834</width>
     <height>22</height>
    </rect>
   </property>
   <widget class="QMenu" name="menuFile">
    <property name="title">
     <string>File</string>
    </property>
    <addaction name="actionOpen"/>
    <addaction name="actionCreate"/>
    <addaction name="separator"/>
    <addaction name="actionExit"/>
   </widget>
   <widget class="QMenu" name="menuHelp">
    <property name="title">
     <string>Help</string>
    </property>
    <addaction name="actionAbout"/>
    <addaction name="actionCheck_for_updates"/>
   </widget>
   <widget class="QMenu" name="menuTools">
    <property name="title">
     <string>Tools</string>
    </property>
    <addaction name="actionOptions"/>
   </widget>
   <widget class="QMenu" name="menuAction">
    <property name="title">
     <string>Action</string>
    </property>
    <addaction name="actionUpdate_server_list"/>
    <addaction name="actionUpdate_all_installed_plugins"/>
   </widget>
   <addaction name="menuFile"/>
   <addaction name="menuAction"/>
   <addaction name="menuTools"/>
   <addaction name="menuHelp"/>
  </widget>
  <action name="actionExit">
   <property name="text">
    <string>Exit</string>
   </property>
  </action>
  <action name="actionAbout">
   <property name="text">
    <string>About</string>
   </property>
  </action>
  <action name="actionOpen">
   <property name="text">
    <string>Open</string>
   </property>
  </action>
  <action name="actionCreate">
   <property name="text">
    <string>Create</string>
   </property>
  </action>
  <action name="actionOptions">
   <property name="text">
    <string>Options</string>
   </property>
  </action>
  <action name="actionUpdate_server_list">
   <property name="text">
    <string>Update server list</string>
   </property>
  </action>
  <action name="actionUpdate_all_installed_plugins">
   <property name="text">
    <string>Update all installed plugins</string>
   </property>
  </action>
  <action name="actionCheck_for_updates">
   <property name="text">
    <string>Check for updates</string>
   </property>
  </action>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`gui_source/main_gui.cpp`:

```cpp
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#include <QApplication>
#include <QStyleFactory>

#include "guimainwindow.h"

int main(int argc, char *argv[])
{
    QCoreApplication::setAttribute(Qt::AA_EnableHighDpiScaling);

    QCoreApplication::setOrganizationName(X_ORGANIZATIONNAME);
    QCoreApplication::setOrganizationDomain(X_ORGANIZATIONDOMAIN);
    QCoreApplication::setApplicationName(X_APPLICATIONNAME);
    QCoreApplication::setApplicationVersion(X_APPLICATIONVERSION);

    QApplication a(argc, argv);
    QApplication::setStyle(QStyleFactory::create("Fusion"));

    GuiMainWindow w;
    w.show();

    return a.exec();
}

```

`gui_source/plugininfowidget.cpp`:

```cpp
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#include "plugininfowidget.h"

#include "ui_plugininfowidget.h"

PluginInfoWidget::PluginInfoWidget(QWidget *pParent) : QWidget(pParent), ui(new Ui::PluginInfoWidget)
{
    ui->setupUi(this);
}

PluginInfoWidget::~PluginInfoWidget()
{
    delete ui;
}

void PluginInfoWidget::setData(Utils::MDATA *pMData)
{
    QString sText;

    sText += QString("<b>%1:</b> %2<br />").arg(tr("Name")).arg(pMData->sName);
    sText += QString("<b>%1:</b> %2<br />").arg(tr("Version")).arg(pMData->sVersion);
    sText += QString("<b>%1:</b> %2<br />").arg(tr("Date")).arg(pMData->sDate);
    sText += QString("<b>%1:</b> %2<br />").arg(tr("Author")).arg(pMData->sAuthor);
    sText += QString("<b>%1:</b> %2<br />").arg(tr("Bugreport")).arg(pMData->sBugreport);
    sText += QString("<b>%1:</b> %2<br />").arg(tr("Info")).arg(pMData->sInfo);
    sText += QString("<b>%1:</b> %2<br />").arg(tr("Size")).arg(pMData->nSize);
    sText += QString("<b>%1:</b> %2<br />").arg(tr("Compressed size")).arg(pMData->nCompressedSize);
    sText += QString("<b>%1:</b> %2<br />").arg(tr("Is32")).arg((pMData->bIs32) ? ("true") : ("false"));
    sText += QString("<b>%1:</b> %2<br />").arg(tr("Is64")).arg((pMData->bIs64) ? ("true") : ("false"));

    ui->textEditInfo->setHtml(sText);
}

```

`gui_source/plugininfowidget.h`:

```h
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#ifndef PLUGININFOWIDGET_H
#define PLUGININFOWIDGET_H

#include <QWidget>

#include "../utils.h"

namespace Ui {
class PluginInfoWidget;
}

class PluginInfoWidget : public QWidget {
    Q_OBJECT

public:
    explicit PluginInfoWidget(QWidget *pParent = nullptr);
    ~PluginInfoWidget();
    void setData(Utils::MDATA *pMData);

private:
    Ui::PluginInfoWidget *ui;
};

#endif  // PLUGININFOWIDGET_H

```

`gui_source/plugininfowidget.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>PluginInfoWidget</class>
 <widget class="QWidget" name="PluginInfoWidget">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>390</width>
    <height>166</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Form</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout_3">
   <property name="leftMargin">
    <number>0</number>
   </property>
   <property name="topMargin">
    <number>0</number>
   </property>
   <property name="rightMargin">
    <number>0</number>
   </property>
   <property name="bottomMargin">
    <number>0</number>
   </property>
   <item>
    <widget class="QTextEdit" name="textEditInfo">
     <property name="readOnly">
      <bool>true</bool>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`gui_source/resources.qrc`:

```qrc
<RCC>
    <qresource prefix="/">
        <file>images/main.png</file>
    </qresource>
</RCC>

```

`installmoduleprocess.cpp`:

```cpp
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#include "installmoduleprocess.h"

InstallModuleProcess::InstallModuleProcess(QObject *pParent) : QObject(pParent)
{
    bIsStop = false;
    currentStats = {};
}

void InstallModuleProcess::setData(QString sDataPath, QString sRootPath, QList<QString> listModuleFileNames)
{
    this->sDataPath = XBinary::convertPathName(sDataPath);
    this->sRootPath = XBinary::convertPathName(sRootPath);
    this->listModuleFileNames = listModuleFileNames;
}

void InstallModuleProcess::stop()
{
    bIsStop = true;
}

Utils::STATS InstallModuleProcess::getCurrentStats()
{
    return currentStats;
}

void InstallModuleProcess::process()
{
    QElapsedTimer elapsedTimer;
    elapsedTimer.start();

    bIsStop = false;

    currentStats.nTotalModule = listModuleFileNames.count();

    for (qint32 i = 0; (i < currentStats.nTotalModule) && (!bIsStop); i++) {
        currentStats.sModule = QString("%1: %2").arg(tr("Install module")).arg(QFileInfo(listModuleFileNames.at(i)).baseName());
        emit infoMessage(currentStats.sModule);

        QFile file;
        file.setFileName(listModuleFileNames.at(i));

        if (file.open(QIODevice::ReadOnly)) {
            Utils::MDATA mdata = Utils::getMDataFromZip(&file, XBinary::convertPathName(sRootPath));

            XZip zip(&file);

            XBinary::PDSTRUCT pdStruct = {};

            QList<XArchive::RECORD> listZipRecords = zip.getRecords(-1, &pdStruct);

            currentStats.nTotalFile = mdata.listInstallRecords.count();

            for (qint32 j = 0; (j < currentStats.nTotalFile) && (!bIsStop); j++) {
                Utils::HANDLE_RECORD record = mdata.listInstallRecords.at(j);

                currentStats.sFile = QString("%1: %2").arg(tr("Install file")).arg(sRootPath + QDir::separator() + record.sPath);
                emit infoMessage(currentStats.sFile);

                if (record.action == Utils::ACTION_COPYFILE) {
                    if (XBinary::isFileExists(sRootPath + QDir::separator() + record.sPath)) {
                        if (!XBinary::removeFile(sRootPath + QDir::separator() + record.sPath)) {
                            emit errorMessage(QString("%1: %2").arg(tr("Cannot remove file")).arg(sRootPath + QDir::separator() + record.sPath));
                            bIsStop = true;
                        }
                    }

                    XArchive::RECORD archiveRecord = XArchive::getArchiveRecord("files/" + record.sPath, &listZipRecords);
                    zip.decompressToFile(&archiveRecord, sRootPath + QDir::separator() + record.sPath);

                    if (!XBinary::isFileHashValid(XBinary::HASH_SHA1, sRootPath + QDir::separator() + record.sPath, record.sSHA1)) {
                        emit errorMessage(QString("%1: %2").arg(tr("Invalid file HASH")).arg(sRootPath + QDir::separator() + record.sPath));
                        bIsStop = true;
                    }
                } else if (record.action == Utils::ACTION_MAKEDIRECTORY) {
                    XBinary::createDirectory(sRootPath + QDir::separator() + record.sPath);
                }

                currentStats.nCurrentFile = j + 1;
            }

            QString sInfoFileName = Utils::getInstalledJsonFileName(sDataPath, mdata.sName);

            if (XBinary::isFileExists(sInfoFileName)) {
                if (!XBinary::removeFile(sInfoFileName)) {
                    emit errorMessage(QString("%1: %2").arg(tr("Cannot remove file")).arg(sInfoFileName));
                    bIsStop = true;
                }
            }

            XArchive::RECORD archiveRecord = XArchive::getArchiveRecord("plugin_info.json", &listZipRecords);
            zip.decompressToFile(&archiveRecord, sInfoFileName);

            file.close();
        }

        currentStats.nCurrentModule = i + 1;
    }

    emit completed(elapsedTimer.elapsed());
}

```

`installmoduleprocess.h`:

```h
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#ifndef INSTALLMODULEPROCESS_H
#define INSTALLMODULEPROCESS_H

#include <QElapsedTimer>
#include <QObject>

#include "utils.h"
#include "xzip.h"

class InstallModuleProcess : public QObject {
    Q_OBJECT

public:
    explicit InstallModuleProcess(QObject *pParent = nullptr);
    void setData(QString sDataPath, QString sRootPath, QList<QString> listModuleFileNames);
    void stop();
    Utils::STATS getCurrentStats();

signals:
    void errorMessage(QString sMessage);
    void infoMessage(QString sMessage);
    void completed(qint64 nElapsedTime);

public slots:
    void process();

private:
    QString sDataPath;
    QString sRootPath;
    QList<QString> listModuleFileNames;
    bool bIsStop;
    Utils::STATS currentStats;
};

#endif  // INSTALLMODULEPROCESS_H

```

`release_version.txt`:

```txt
0.05
```

`removemoduleprocess.cpp`:

```cpp
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#include "removemoduleprocess.h"

RemoveModuleProcess::RemoveModuleProcess(QObject *pParent) : QObject(pParent)
{
    bIsStop = false;
    currentStats = {};
}

void RemoveModuleProcess::setData(QString sDataPath, QString sRootPath, QList<QString> listModuleNames)
{
    this->sDataPath = XBinary::convertPathName(sDataPath);
    this->sRootPath = XBinary::convertPathName(sRootPath);
    this->listModuleNames = listModuleNames;
}

void RemoveModuleProcess::stop()
{
    bIsStop = true;
}

Utils::STATS RemoveModuleProcess::getCurrentStats()
{
    return currentStats;
}

void RemoveModuleProcess::process()
{
    QElapsedTimer elapsedTimer;
    elapsedTimer.start();

    bIsStop = false;

    currentStats.nTotalModule = listModuleNames.count();

    for (qint32 i = 0; (i < currentStats.nTotalModule) && (!bIsStop); i++) {
        currentStats.sModule = QString("%1: %2").arg(tr("Remove module")).arg(listModuleNames.at(i));
        emit infoMessage(currentStats.sModule);

        QString sFileName = Utils::getInstalledJsonFileName(sDataPath, listModuleNames.at(i));

        if (XBinary::isFileExists(sFileName)) {
            Utils::MDATA mdata = Utils::getMDataFromJSONFile(sFileName);

            currentStats.nTotalFile = mdata.listRemoveRecords.count();

            for (qint32 j = 0; (j < currentStats.nTotalFile) && (!bIsStop); j++) {
                Utils::HANDLE_RECORD record = mdata.listRemoveRecords.at(j);

                if (record.action == Utils::ACTION_REMOVEFILE) {
                    XBinary::removeFile(sRootPath + QDir::separator() + record.sPath);

                    if (!XBinary::isFileExists(sRootPath + QDir::separator() + record.sPath)) {
                        currentStats.sFile = QString("%1: %2").arg(tr("Remove file")).arg(record.sPath);
                        emit infoMessage(currentStats.sFile);
                    } else {
                        emit errorMessage(tr("%1: %2").arg(tr("Cannot remove file")).arg(sRootPath + QDir::separator() + record.sPath));
                        bIsStop = true;
                    }
                } else if (record.action == Utils::ACTION_REMOVEDIRECTORYIFEMPTY) {
                    if (XBinary::isDirectoryEmpty(sRootPath + QDir::separator() + record.sPath)) {
                        XBinary::removeDirectory(sRootPath + QDir::separator() + record.sPath);

                        if (!XBinary::isDirectoryExists(sRootPath + QDir::separator() + record.sPath)) {
                            currentStats.sFile = QString("%1: %2").arg(tr("Remove directory")).arg(record.sPath);
                            emit infoMessage(currentStats.sFile);
                        } else {
                            emit errorMessage(tr("%1: %2").arg(tr("Cannot remove directory")).arg(sRootPath + QDir::separator() + record.sPath));
                            bIsStop = true;
                        }
                    }
                }

                currentStats.nCurrentFile = j + 1;
            }

            if (!bIsStop) {
                XBinary::removeFile(sFileName);

                if (!XBinary::isFileExists(sFileName)) {
                    emit infoMessage(QString("%1: %2").arg(tr("Remove file")).arg(sFileName));
                } else {
                    emit errorMessage(tr("%1: %2").arg(tr("Cannot remove file")).arg(sFileName));
                    bIsStop = true;
                }
            }

            if (bIsStop) {
                emit errorMessage(tr("Please, close all applications and try again."));
            }
        }

        currentStats.nCurrentModule = i + 1;
    }

    emit completed(elapsedTimer.elapsed());
}

```

`removemoduleprocess.h`:

```h
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#ifndef REMOVEMODULEPROCESS_H
#define REMOVEMODULEPROCESS_H

#include <QElapsedTimer>
#include <QObject>

#include "utils.h"

class RemoveModuleProcess : public QObject {
    Q_OBJECT

public:
    explicit RemoveModuleProcess(QObject *pParent = nullptr);
    void setData(QString sDataPath, QString sRootPath, QList<QString> listModuleNames);
    void stop();
    Utils::STATS getCurrentStats();

signals:
    void errorMessage(QString sMessage);
    void infoMessage(QString sMessage);
    void completed(qint64 nElapsedTime);

public slots:
    void process();

private:
    QString sDataPath;
    QString sRootPath;
    QList<QString> listModuleNames;
    bool bIsStop;
    Utils::STATS currentStats;
};

#endif  // REMOVEMODULEPROCESS_H

```

`updategitprocess.cpp`:

```cpp
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#include "updategitprocess.h"

UpdateGitProcess::UpdateGitProcess(QObject *pParent) : QObject(pParent)
{
    bIsStop = false;
    currentStats = {};
}

void UpdateGitProcess::setData(QString sServerListFileName)
{
    this->sServerListFileName = sServerListFileName;
}

void UpdateGitProcess::stop()
{
    bIsStop = true;
}

Utils::STATS UpdateGitProcess::getCurrentStats()
{
    return currentStats;
}

void UpdateGitProcess::process()
{
    QElapsedTimer elapsedTimer;
    elapsedTimer.start();

    bIsStop = false;

    QList<Utils::MDATA> listMData = Utils::getModulesFromJSONFile(sServerListFileName);

    int nCount = listMData.count();

    int nNumbersOfGithub = 0;

    for (int i = 0; i < nCount; i++) {
        if (listMData.at(i).sGithub != "") {
            nNumbersOfGithub++;
        }
    }

    currentStats.nTotalModule = nNumbersOfGithub;

    for (int i = 0; (i < nCount) && (!bIsStop); i++) {
        Utils::MDATA mdata = listMData.at(i);

        if (mdata.sGithub != "") {
            QString sGithub = mdata.sGithub;
            sGithub = sGithub.section("github.com/", 1, 1);

            QString sUserName = sGithub.section("/", 0, 0);
            QString sRepoName = sGithub.section("/", 1, 1);

            XGithub github(sUserName, sRepoName);
            github.setCredentials(sAuthUser, sAuthToken);

            connect(&github, SIGNAL(errorMessage(QString)), this, SIGNAL(errorMessage(QString)));

            XGithub::RELEASE_HEADER release = github.getLatestRelease(true);

            if (release.bValid) {
                mdata.sDate = release.dt.toString("yyyy-MM-dd");  // rewrite

                if (release.sTag != "") {
                    mdata.sVersion = release.sTag;
                } else {
                    mdata.sVersion = release.sName;
                }

                int nNumberOfAsserts = release.listRecords.count();

                QSet<QString> stDownloads;

                for (int j = 0; j < nNumberOfAsserts; j++) {
                    if (Utils::checkPattern(release.listRecords.at(j).sSrc, &mdata)) {
                        stDownloads.insert(release.listRecords.at(j).sSrc);
                    }
                }

                QList<QString> listStrings = XGithub::getDownloadLinks(release.sBody);

                int nNumberOfLinks = listStrings.count();

                for (int j = 0; j < nNumberOfLinks; j++) {
                    if (Utils::checkPattern(listStrings.at(j), &mdata)) {
                        stDownloads.insert(listStrings.at(j));
                    }
                }

                mdata.listDownloads = stDownloads.toList();

                Utils::updateJsonFile(sServerListFileName, QList<Utils::MDATA>() << mdata);
            } else {
                break;
            }
        }

        currentStats.nCurrentModule = i + 1;
    }

    emit completed(elapsedTimer.elapsed());
}

void UpdateGitProcess::setCredentials(QString sUser, QString sToken)
{
    sAuthUser = sUser;
    sAuthToken = sToken;
}

```

`updategitprocess.h`:

```h
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#ifndef UPDATEGITPROCESS_H
#define UPDATEGITPROCESS_H

#include <QElapsedTimer>
#include <QObject>
#include <QThread>

#include "utils.h"
#include "xgithub.h"

class UpdateGitProcess : public QObject {
    Q_OBJECT

public:
    explicit UpdateGitProcess(QObject *pParent = nullptr);
    void setData(QString sServerListFileName);
    void stop();
    Utils::STATS getCurrentStats();
    void setCredentials(QString sUser, QString sToken);

signals:
    void errorMessage(QString sMessage);
    void infoMessage(QString sMessage);
    void completed(qint64 nElapsedTime);

public slots:
    void process();

private:
    QString sServerListFileName;
    bool bIsStop;
    Utils::STATS currentStats;
    QString sAuthUser;
    QString sAuthToken;
};

#endif  // UPDATEGITPROCESS_H

```

`utils.cpp`:

```cpp
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#include "utils.h"

Utils::Utils(QObject *pParent) : QObject(pParent)
{
}

QList<Utils::RECORD> Utils::getRecords(QString sRootPath)
{
    QList<Utils::RECORD> listResult;

    QFileInfo fi(sRootPath);

    sRootPath = fi.absoluteDir().path() + QDir::separator() + fi.fileName();

    _getRecords(sRootPath, sRootPath, &listResult);

    return listResult;
}

bool Utils::checkMData(Utils::MDATA *pMData, QString *psErrorString)
{
    bool bResult = true;

    if (bResult && (pMData->sName == "")) {
        *psErrorString = tr("Invalid name");
        bResult = false;
    }

    if (bResult && (pMData->sBundleFileName == "")) {
        *psErrorString = tr("Invalid bundle file name");
        bResult = false;
    }

    if (bResult && (pMData->sRoot == "")) {
        if (!XBinary::isDirectoryExists(XBinary::convertPathName(pMData->sRoot))) {
            *psErrorString = tr("Invalid root path");
            bResult = false;
        }
    }

    return bResult;
}

QString Utils::createBundleName(Utils::MDATA *pMData)
{
    QString sResult;

    sResult += pMData->sName;

    if (pMData->sVersion != "") {
        sResult += QString("_%1").arg(pMData->sVersion);
    }

    return sResult;
}

bool Utils::isPluginValid(QString sFileName)
{
    bool bResult = false;

    QFile file;

    file.setFileName(sFileName);

    if (file.open(QIODevice::ReadOnly)) {
        bResult = isPluginValid(&file);

        file.close();
    }

    return bResult;
}

bool Utils::isPluginValid(QIODevice *pDevice)
{
    bool bResult = false;

    XZip xzip(pDevice);

    if (xzip.isValid()) {
        XBinary::PDSTRUCT pdStruct = {};

        QList<XArchive::RECORD> listRecords = xzip.getRecords(-1, &pdStruct);

        bResult = XArchive::isArchiveRecordPresent("plugin_info.json", &listRecords);
    }

    return bResult;
}

QByteArray Utils::createPluginInfo(Utils::MDATA *pMData, QList<Utils::FILE_RECORD> *pListFileRecords, QList<Utils::DIRECTORY_RECORD> *pListDirectoryRecords)
{
    QByteArray baResult;

    QJsonObject recordObject;

    mDataToObject(pMData, &recordObject);

    if (pMData->sSHA1 == "")  // In zip
    {
        int nFilesCount = pListFileRecords->count();
        int nDirectoriesCount = pListDirectoryRecords->count();

        QJsonArray installArray;

        for (int i = 0; i < nDirectoriesCount; i++) {
            QJsonObject record;

            record.insert("Path", pListDirectoryRecords->at(i).sPath);
            record.insert("Action", actionIdToString(ACTION_MAKEDIRECTORY));

            installArray.append(record);
        }

        for (int i = 0; i < nFilesCount; i++) {
            QJsonObject record;

            record.insert("Path", pListFileRecords->at(i).sPath);
            record.insert("Action", actionIdToString(ACTION_COPYFILE));
            record.insert("SHA1", pListFileRecords->at(i).sSHA1);

            installArray.append(record);
        }

        recordObject.insert("Install", installArray);

        QJsonArray removeArray;

        for (int i = 0; i < nFilesCount; i++) {
            QJsonObject record;

            record.insert("Path", pListFileRecords->at(i).sPath);
            record.insert("Action", actionIdToString(ACTION_REMOVEFILE));

            removeArray.append(record);
        }

        for (int i = nDirectoriesCount - 1; i >= 0; i--) {
            QJsonObject record;

            record.insert("Path", pListDirectoryRecords->at(i).sPath);
            record.insert("Action", actionIdToString(ACTION_REMOVEDIRECTORYIFEMPTY));

            removeArray.append(record);
        }

        recordObject.insert("Remove", removeArray);
    }

    QJsonDocument doc(recordObject);
    baResult.append(doc.toJson());

    return baResult;
}

Utils::MDATA Utils::getMDataFromZip(QString sFileName, QString sRootPath)
{
    Utils::MDATA result = {};

    QFile file;

    file.setFileName(sFileName);

    if (file.open(QIODevice::ReadOnly)) {
        result = getMDataFromZip(&file, sRootPath);

        file.close();
    }

    return result;
}

Utils::MDATA Utils::getMDataFromZip(QIODevice *pDevice, QString sRootPath)
{
    Utils::MDATA result = {};

    result.sRoot = sRootPath;

    XZip xzip(pDevice);

    if (xzip.isValid()) {
        XBinary::PDSTRUCT pdStruct = {};
        QList<XArchive::RECORD> listRecords = xzip.getRecords(-1, &pdStruct);

        XArchive::RECORD pluginInfoRecord = XArchive::getArchiveRecord("plugin_info.json", &listRecords);

        QByteArray baData = xzip.decompress(&pluginInfoRecord, false, nullptr);

        result = getMDataFromData(baData);
    }

    return result;
}

Utils::MDATA Utils::getMDataFromData(QByteArray baData)
{
    Utils::MDATA result = {};

    QJsonDocument jsDoc = QJsonDocument::fromJson(baData);

    QJsonObject rootObj = jsDoc.object();

    objectToMData(&rootObj, &result);

    return result;
}

Utils::MDATA Utils::getMDataFromJSONFile(QString sFileName)
{
    Utils::MDATA result = {};

    QByteArray baData = XBinary::readFile(sFileName);

    result = getMDataFromData(baData);

    return result;
}

QList<Utils::MDATA> Utils::getInstalledModules(QString sDataPath, QString sRootPath)
{
    QList<Utils::MDATA> listResult;

    sDataPath = XBinary::convertPathName(sDataPath);
    sRootPath = XBinary::convertPathName(sRootPath);

    QDir dir(sDataPath + QDir::separator() + "installed");

    QFileInfoList listFiles = dir.entryInfoList(QStringList() << "*.json", QDir::Files | QDir::NoSymLinks, QDir::Name);

    int nCount = listFiles.count();

    for (int i = 0; i < nCount; i++) {
        QString sBundleName = listFiles.at(i).filePath();

        QFile file;
        file.setFileName(sBundleName);

        if (file.open(QIODevice::ReadOnly)) {
            QByteArray baData = file.readAll();

            Utils::MDATA record = getMDataFromData(baData);
            record.sBundleFileName = sBundleName;

            listResult.append(record);

            file.close();
        }
    }

    return listResult;
}

QList<Utils::MDATA> Utils::getModulesFromJSONFile(QString sFileName)
{
    QList<Utils::MDATA> listResult;

    QByteArray baData = XBinary::readFile(sFileName);

    // TODO Check valid
    QJsonDocument jsDoc = QJsonDocument::fromJson(baData);

    QJsonObject rootObj = jsDoc.object();

    //    QString sDate=rootObj.value("Date").toString();

    QJsonArray arrayModules = rootObj.value("Modules").toArray();

    int nCount = arrayModules.count();

    for (int i = 0; i < nCount; i++) {
        QJsonObject recordObject = arrayModules.at(i).toObject();

        MDATA mdata = {};

        objectToMData(&recordObject, &mdata);

        listResult.append(mdata);
    }

    return listResult;
}

QDate Utils::getDateFromJSONFile(QString sFileName)
{
    QDate dtResult;

    QByteArray baData = XBinary::readFile(sFileName);

    QJsonDocument jsDoc = QJsonDocument::fromJson(baData);

    QJsonObject rootObj = jsDoc.object();

    dtResult = QDate::fromString(rootObj.value("Date").toString(), "yyyy-MM-dd");

    return dtResult;
}

bool Utils::createServerList(QString sListFileName, QList<QString> *pList, QString sWebPrefix, QString sDate)
{
    bool bResult = false;

    QJsonArray arrayModules;

    int nCount = pList->count();

    for (int i = 0; i < nCount; i++) {
        MDATA mdata = getMDataFromJSONFile(pList->at(i));
        mdata.sSrc = sWebPrefix + "/" + mdata.sSrc;

        QJsonObject record;

        mDataToObject(&mdata, &record);

        arrayModules.append(record);
    }

    QJsonObject recordObject;
    recordObject.insert("Date", sDate);
    recordObject.insert("Modules", arrayModules);

    QByteArray baResult;

    QJsonDocument doc(recordObject);
    baResult.append(doc.toJson());

    bResult = XBinary::writeToFile(sListFileName, baResult);

    return bResult;
}

void Utils::mDataToObject(Utils::MDATA *pMData, QJsonObject *pObject)
{
    pObject->insert("Name", QJsonValue::fromVariant(pMData->sName));
    pObject->insert("Version", QJsonValue::fromVariant(pMData->sVersion));
    pObject->insert("Date", QJsonValue::fromVariant(pMData->sDate));
    pObject->insert("Author", QJsonValue::fromVariant(pMData->sAuthor));
    pObject->insert("Bugreport", QJsonValue::fromVariant(pMData->sBugreport));
    pObject->insert("Info", QJsonValue::fromVariant(pMData->sInfo));
    pObject->insert("Size", QJsonValue::fromVariant(pMData->nSize));
    pObject->insert("CompressedSize", QJsonValue::fromVariant(pMData->nCompressedSize));
    pObject->insert("Is32", QJsonValue::fromVariant(pMData->bIs32));
    pObject->insert("Is64", QJsonValue::fromVariant(pMData->bIs64));
    pObject->insert("Src", QJsonValue::fromVariant(pMData->sSrc));

    if (pMData->sSHA1 != "") {
        pObject->insert("SHA1", QJsonValue::fromVariant(pMData->sSHA1));
    }

    if (pMData->sGithub != "") {
        pObject->insert("Github", QJsonValue::fromVariant(pMData->sGithub));
    }

    // TODO optimize
    int nInstallCount = pMData->listInstallRecords.count();
    int nRemoveCount = pMData->listRemoveRecords.count();
    int nConvertCount = pMData->listConvertRecords.count();
    int nDownloadCount = pMData->listDownloads.count();

    if (nInstallCount) {
        QJsonArray jsArray;

        for (int i = 0; i < nInstallCount; i++) {
            HANDLE_RECORD record = pMData->listInstallRecords.at(i);
            QJsonObject recordObj;

            handleRecordToObject(&record, &recordObj);

            jsArray.append(recordObj);
        }

        pObject->insert("Install", jsArray);
    }

    if (nRemoveCount) {
        QJsonArray jsArray;

        for (int i = 0; i < nRemoveCount; i++) {
            HANDLE_RECORD record = pMData->listRemoveRecords.at(i);
            QJsonObject recordObj;

            handleRecordToObject(&record, &recordObj);

            jsArray.append(recordObj);
        }

        pObject->insert("Remove", jsArray);
    }

    if (nConvertCount) {
        QJsonArray jsArray;

        for (int i = 0; i < nConvertCount; i++) {
            HANDLE_RECORD record = pMData->listConvertRecords.at(i);
            QJsonObject recordObj;

            handleRecordToObject(&record, &recordObj);

            jsArray.append(recordObj);
        }

        pObject->insert("Convert", jsArray);
    }

    if (nDownloadCount) {
        QJsonArray jsArray;

        for (int i = 0; i < nDownloadCount; i++) {
            QJsonObject recordObj;

            recordObj.insert("Src", QJsonValue::fromVariant(pMData->listDownloads.at(i)));

            jsArray.append(recordObj);
        }

        pObject->insert("Download", jsArray);
    }
}

void Utils::objectToMData(QJsonObject *pObject, Utils::MDATA *pMData)
{
    pMData->sName = pObject->value("Name").toString();
    pMData->sVersion = pObject->value("Version").toString();
    pMData->sDate = pObject->value("Date").toString();
    pMData->sAuthor = pObject->value("Author").toString();
    pMData->sBugreport = pObject->value("Bugreport").toString();
    pMData->sInfo = pObject->value("Info").toString();
    pMData->nSize = pObject->value("Size").toInt();
    pMData->nCompressedSize = pObject->value("CompressedSize").toInt();
    pMData->bIs32 = pObject->value("Is32").toBool();
    pMData->bIs64 = pObject->value("Is64").toBool();
    pMData->sSrc = pObject->value("Src").toString();
    pMData->sSHA1 = pObject->value("SHA1").toString();
    pMData->sGithub = pObject->value("Github").toString();

    // TODO optimize
    QJsonArray installArray = pObject->value("Install").toArray();
    QJsonArray removeArray = pObject->value("Remove").toArray();
    QJsonArray convertArray = pObject->value("Convert").toArray();
    QJsonArray downloadArray = pObject->value("Download").toArray();

    int nInstallCount = installArray.count();

    for (int i = 0; i < nInstallCount; i++) {
        QJsonObject recordObj = installArray.at(i).toObject();
        HANDLE_RECORD record = {};

        objectToHandleRecord(&recordObj, &record);

        pMData->listInstallRecords.append(record);
    }

    int nRemoveCount = removeArray.count();

    for (int i = 0; i < nRemoveCount; i++) {
        QJsonObject recordObj = removeArray.at(i).toObject();
        HANDLE_RECORD record = {};

        objectToHandleRecord(&recordObj, &record);

        pMData->listRemoveRecords.append(record);
    }

    int nConvertCount = convertArray.count();

    for (int i = 0; i < nConvertCount; i++) {
        QJsonObject recordObj = convertArray.at(i).toObject();
        HANDLE_RECORD record = {};

        objectToHandleRecord(&recordObj, &record);

        pMData->listConvertRecords.append(record);
    }

    int nDownloadCount = downloadArray.count();

    for (int i = 0; i < nDownloadCount; i++) {
        QJsonObject recordObj = downloadArray.at(i).toObject();

        QString sRecord = recordObj.value("Src").toString();

        pMData->listDownloads.append(sRecord);
    }
}

void Utils::handleRecordToObject(Utils::HANDLE_RECORD *pHandleRecord, QJsonObject *pObject)
{
    pObject->insert("Path", QJsonValue::fromVariant(pHandleRecord->sPath));
    pObject->insert("Action", QJsonValue::fromVariant(actionIdToString(pHandleRecord->action)));

    if (pHandleRecord->sSHA1 != "") {
        pObject->insert("SHA1", QJsonValue::fromVariant(pHandleRecord->sSHA1));
    }

    if (pHandleRecord->sSrc != "") {
        pObject->insert("Src", QJsonValue::fromVariant(pHandleRecord->sSrc));
    }

    if (pHandleRecord->sPattern != "") {
        pObject->insert("Pattern", QJsonValue::fromVariant(pHandleRecord->sPattern));
    }
}

void Utils::objectToHandleRecord(QJsonObject *pObject, Utils::HANDLE_RECORD *pHandleRecord)
{
    pHandleRecord->sSrc = pObject->value("Src").toString();
    pHandleRecord->sPath = pObject->value("Path").toString();
    pHandleRecord->sSHA1 = pObject->value("SHA1").toString();
    pHandleRecord->sPattern = pObject->value("Pattern").toString();
    pHandleRecord->action = stringToActionId(pObject->value("Action").toString());
}

QMap<QString, Utils::STATUS> Utils::getModulesStatusMap(QString sDataPath, QList<Utils::MDATA> *pServerList, QList<Utils::MDATA> *pInstalled)
{
    QMap<QString, Utils::STATUS> mapResult;

    int nCount = pServerList->count();

    for (int i = 0; i < nCount; i++) {
        STATUS status = {};

        if (pServerList->at(i).sDate != "") {
            status.bInstall = true;
        }

        status.sServerListDate = pServerList->at(i).sDate;
        status.sServerListVersion = pServerList->at(i).sVersion;
        status.webRecord.sName = pServerList->at(i).sName;
        status.webRecord.sFileName = getModuleFileName(sDataPath, pServerList->at(i).sName);
        status.webRecord.sLink = pServerList->at(i).sSrc;

        mapResult.insert(pServerList->at(i).sName, status);
    }

    nCount = pInstalled->count();

    for (int i = 0; i < nCount; i++) {
        QString sName = pInstalled->at(i).sName;
        bool bIsServerList = mapResult.contains(sName);

        STATUS status = {};

        if (bIsServerList) {
            status = mapResult.value(sName);
        }
        status.webRecord.sName = pInstalled->at(i).sName;
        status.bInstall = false;
        status.bRemove = true;
        status.sInstalledDate = pInstalled->at(i).sDate;
        status.sInstalledVersion = pInstalled->at(i).sVersion;

        if (bIsServerList) {
            if ((status.sServerListDate > status.sInstalledDate) && (status.sServerListVersion != status.sInstalledVersion) && (status.sServerListDate != "")) {
                status.bUpdate = true;
            }

            if ((status.sServerListDate > status.sInstalledDate) && (status.sServerListVersion == "snapshot") && (status.sServerListDate != "")) {
                status.bUpdate = true;  // For x64dbgcote
            }
        }

        mapResult.insert(pInstalled->at(i).sName, status);
    }

    return mapResult;
}

Utils::MODULES_DATA Utils::getModulesData(QString sDataPath)
{
    MODULES_DATA result = {};

    result.listServerList = Utils::getModulesFromJSONFile(Utils::getServerListFileName(sDataPath));
    result.listInstalled = Utils::getInstalledModules(sDataPath, sDataPath);
    result.mapStatus = getModulesStatusMap(sDataPath, &result.listServerList, &result.listInstalled);
    result.listUpdates = getUpdates(&result.mapStatus);

    return result;
}

QList<Utils::WEB_RECORD> Utils::getUpdates(QMap<QString, STATUS> *pMapStatus)
{
    QList<Utils::WEB_RECORD> listResult;

    QList<STATUS> listStatuses = pMapStatus->values();

    int nCount = listStatuses.count();

    for (int i = 0; i < nCount; i++) {
        if (listStatuses.at(i).bUpdate) {
            WEB_RECORD record = listStatuses.at(i).webRecord;

            listResult.append(record);
        }
    }

    return listResult;
}

QString Utils::getInstalledJsonFileName(QString sDataPath, QString sName)
{
    return XBinary::convertPathName(sDataPath) + QDir::separator() + "installed" + QDir::separator() + QString("%1.json").arg(sName);
}

QString Utils::getServerListFileName(QString sDataPath)
{
    return XBinary::convertPathName(sDataPath) + QDir::separator() + "list.json";
}

QString Utils::getServerLastestListFileName(QString sDataPath)
{
    return XBinary::convertPathName(sDataPath) + QDir::separator() + "list.lastest.json";
}

QString Utils::getModuleFileName(QString sDataPath, QString sName)
{
    return XBinary::convertPathName(sDataPath) + QDir::separator() + "modules" + QDir::separator() + QString("%1.x64dbg.zip").arg(sName);
}

QString Utils::getConvertPath(QString sDataPath, QString sName)
{
    return XBinary::convertPathName(sDataPath) + QDir::separator() + "modules" + QDir::separator() + QString("%1").arg(sName);
}

QString Utils::getConvertDownloadFileName(QString sDataPath, QString sName, QString sPattern)
{
    QString sResult;

    QString sConvertPath = getConvertPath(sDataPath, sName);

    QDir dir(sConvertPath);
    QList<QFileInfo> listFiles = dir.entryInfoList(QDir::Files);

    int nCount = listFiles.count();

    for (int i = 0; i < nCount; i++) {
        QString sName = listFiles.at(i).fileName();
        if (sName.contains(sPattern)) {
            sResult = listFiles.at(i).absoluteFilePath();

            break;
        }
    }

    return sResult;
}

QString Utils::getConvertModulePath(QString sDataPath, QString sName)
{
    return XBinary::convertPathName(sDataPath) + QDir::separator() + "modules" + QDir::separator() + QString("%1").arg(sName) + QDir::separator() + "module";
}

Utils::MDATA Utils::getMDataByName(QList<MDATA> *pServerList, QString sName)
{
    Utils::MDATA result = {};

    int nCount = pServerList->count();

    for (int i = 0; i < nCount; i++) {
        if (pServerList->at(i).sName == sName) {
            result = pServerList->at(i);

            break;
        }
    }

    return result;
}

QList<QString> Utils::getNamesFromWebRecords(QList<Utils::WEB_RECORD> *pListWebRecords)
{
    QList<QString> listResult;

    int nCount = pListWebRecords->count();

    for (int i = 0; i < nCount; i++) {
        listResult.append(pListWebRecords->at(i).sName);
    }

    return listResult;
}

Utils::WEB_RECORD Utils::getWebRecordByName(QList<Utils::WEB_RECORD> *pListWebRecords, QString sName)
{
    Utils::WEB_RECORD result = {};

    int nCount = pListWebRecords->count();

    for (int i = 0; i < nCount; i++) {
        if (pListWebRecords->at(i).sName == sName) {
            result = pListWebRecords->at(i);

            break;
        }
    }

    return result;
}

bool Utils::isGithubPresent(QString sServerListFileName)
{
    bool bResult = false;

    QList<MDATA> listMData = getModulesFromJSONFile(sServerListFileName);

    int nCount = listMData.count();

    for (int i = 0; i < nCount; i++) {
        if (listMData.at(i).sGithub != "") {
            bResult = true;

            break;
        }
    }

    return bResult;
}

bool Utils::updateJsonFile(QString sFileName, QList<MDATA> listMData)
{
    bool bResult = false;

    QByteArray baData = XBinary::readFile(sFileName);

    QJsonDocument jsDoc = QJsonDocument::fromJson(baData);

    QJsonObject rootObj = jsDoc.object();
    QJsonObject _rootObj;

    _rootObj.insert("Date", rootObj.value("Date"));

    QJsonArray arrayModules = rootObj.value("Modules").toArray();
    QJsonArray _arrayModules;

    int nCount = arrayModules.count();
    int _nCount = listMData.count();

    for (int i = 0; i < nCount; i++) {
        QJsonObject recordObject = arrayModules.at(i).toObject();

        MDATA mdata = {};

        objectToMData(&recordObject, &mdata);

        for (int j = 0; j < _nCount; j++) {
            if ((mdata.sName == listMData.at(j).sName) && (listMData.at(j).sDate != "")) {
                mdata = listMData.at(j);
                break;
            }
        }

        QJsonObject _recordObject;

        mDataToObject(&mdata, &_recordObject);

        _arrayModules.append(_recordObject);
    }

    _rootObj.insert("Modules", _arrayModules);

    QJsonDocument jsResult(_rootObj);

    bResult = XBinary::writeToFile(sFileName, jsResult.toJson(QJsonDocument::Indented));

    return bResult;
}

bool Utils::updateServerList(QString sOldFileName, QString sNewFileName)
{
    bool bResult = false;

    if (!XBinary::isFileExists(sOldFileName)) {
        bResult = XBinary::copyFile(sNewFileName, sOldFileName);
    } else {
        qint64 nJFTimeNew = Utils::getDateFromJSONFile(sNewFileName).toJulianDay();
        qint64 nJFTime = Utils::getDateFromJSONFile(sOldFileName).toJulianDay();

        if (nJFTimeNew > nJFTime) {
            if (XBinary::isFileExists(sOldFileName)) {
                XBinary::removeFile(sOldFileName);
            }

            bResult = XBinary::copyFile(sNewFileName, sOldFileName);
        } else {
            QList<Utils::MDATA> listMData = Utils::getModulesFromJSONFile(sNewFileName);

            bResult = updateJsonFile(sOldFileName, listMData);
        }
    }

    return bResult;
}

QString Utils::actionIdToString(Utils::ACTION action)
{
    QString sResult = "unknown";

    switch (action) {
        case ACTION_UNKNOWN:
            sResult = QString("unknown");
            break;
        case ACTION_COPYFILE:
            sResult = QString("copy_file");
            break;
        case ACTION_REMOVEFILE:
            sResult = QString("remove_file");
            break;
        case ACTION_REMOVEDIRECTORYIFEMPTY:
            sResult = QString("remove_directory_if_empty");
            break;
        case ACTION_MAKEDIRECTORY:
            sResult = QString("make_directory");
            break;
        case ACTION_UNPACKDIRECTORY:
            sResult = QString("unpack_directory");
            break;
        case ACTION_UNPACKFILE:
            sResult = QString("unpack_file");
            break;
    }

    return sResult;
}

Utils::ACTION Utils::stringToActionId(QString sAction)
{
    Utils::ACTION result = ACTION_UNKNOWN;

    if (sAction == "unknown")
        result = ACTION_UNKNOWN;
    else if (sAction == "copy_file")
        result = ACTION_COPYFILE;
    else if (sAction == "remove_file")
        result = ACTION_REMOVEFILE;
    else if (sAction == "remove_directory_if_empty")
        result = ACTION_REMOVEDIRECTORYIFEMPTY;
    else if (sAction == "make_directory")
        result = ACTION_MAKEDIRECTORY;
    else if (sAction == "unpack_directory")
        result = ACTION_UNPACKDIRECTORY;
    else if (sAction == "unpack_file")
        result = ACTION_UNPACKFILE;

    return result;
}

bool Utils::checkPattern(QString sString, Utils::MDATA *pMData)
{
    bool bResult = false;

    int nCount = pMData->listConvertRecords.count();

    for (int i = 0; i < nCount; i++) {
        if (sString.contains(pMData->listConvertRecords.at(i).sPattern)) {
            bResult = true;

            break;
        }
    }

    return bResult;
}

void Utils::_getRecords(QString sRootPath, QString sCurrentPath, QList<Utils::RECORD> *pListRecords)
{
    QFileInfo fi(sCurrentPath);

    RECORD record = {};

    record.bIsFile = true;
    record.sFullPath = fi.absoluteFilePath();
    record.sPath = record.sFullPath;
    record.bIsFile = fi.isFile();

    record.sPath = record.sPath.remove(0, sRootPath.size() + 1);

    if (record.sPath != "") {
        pListRecords->append(record);
    }

    if (!record.bIsFile) {
        QDir dir(sCurrentPath);
        QFileInfoList eil = dir.entryInfoList();

        int nCount = eil.count();

        for (int i = 0; i < nCount; i++) {
            QString sFN = eil.at(i).fileName();

            if ((sFN != ".") && (sFN != "..")) {
                _getRecords(sRootPath, eil.at(i).absoluteFilePath(), pListRecords);
            }
        }
    }
}

```

`utils.h`:

```h
// Copyright (c) 2019-2022 hors<horsicq@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
#ifndef UTILS_H
#define UTILS_H

#include <QDir>
#include <QFileInfo>
#include <QJsonArray>
#include <QJsonDocument>
#include <QJsonObject>
#include <QObject>
#include <QSettings>

#include "global.h"
#include "xzip.h"

class Utils : public QObject {
    Q_OBJECT

public:
    enum ACTION {
        ACTION_UNKNOWN = 0,
        ACTION_COPYFILE,
        ACTION_REMOVEFILE,
        ACTION_REMOVEDIRECTORYIFEMPTY,
        ACTION_MAKEDIRECTORY,
        ACTION_UNPACKDIRECTORY,
        ACTION_UNPACKFILE
    };

    struct WEB_RECORD {
        QString sName;
        QString sFileName;
        QString sLink;
    };

    struct STATUS {
        bool bInstall;
        bool bUpdate;
        bool bRemove;
        QString sServerListVersion;
        QString sServerListDate;
        QString sInstalledVersion;
        QString sInstalledDate;
        WEB_RECORD webRecord;
    };

    struct STATS {
        QString sModule;
        qint64 nTotalModule;
        qint64 nCurrentModule;
        QString sFile;
        qint64 nTotalFile;
        qint64 nCurrentFile;
        qint64 nTotalBytes;
        qint64 nCurrentBytes;
    };

    struct RECORD {
        QString sFullPath;
        QString sPath;
        bool bIsFile;
    };

    struct HANDLE_RECORD {
        QString sSrc;
        QString sPath;
        QString sSHA1;
        QString sPattern;
        ACTION action;
    };

    struct MDATA {
        QString sName;
        QString sVersion;
        bool bIs32;
        bool bIs64;
        QString sDate;
        QString sAuthor;
        QString sBugreport;
        QString sInfo;
        QString sRoot;
        QString sBundleFileName;
        QList<Utils::HANDLE_RECORD> listInstallRecords;
        QList<Utils::HANDLE_RECORD> listRemoveRecords;
        QList<Utils::HANDLE_RECORD> listConvertRecords;
        qint64 nSize;
        qint64 nCompressedSize;
        QString sSrc;
        QString sSHA1;
        QString sGithub;
        QList<QString> listDownloads;
    };

    struct FILE_RECORD {
        QString sFullPath;
        QString sPath;
        QString sSHA1;
        //        qint64 nSize;
        //        qint64 nCompressedSize;
    };

    struct DIRECTORY_RECORD {
        QString sFullPath;
        QString sPath;
    };

    struct MODULES_DATA {
        QList<Utils::MDATA> listServerList;
        QList<Utils::MDATA> listInstalled;
        QMap<QString, STATUS> mapStatus;
        QList<WEB_RECORD> listUpdates;
    };

    explicit Utils(QObject *pParent = nullptr);

    static QList<RECORD> getRecords(QString sRootPath);
    static bool checkMData(MDATA *pMData, QString *psErrorString);
    static QString createBundleName(MDATA *pMData);
    static bool isPluginValid(QString sFileName);
    static bool isPluginValid(QIODevice *pDevice);

    static QByteArray createPluginInfo(Utils::MDATA *pMData, QList<Utils::FILE_RECORD> *pListFileRecords, QList<Utils::DIRECTORY_RECORD> *pListDirectoryRecords);
    static MDATA getMDataFromZip(QString sFileName, QString sRootPath);
    static MDATA getMDataFromZip(QIODevice *pDevice, QString sRootPath);
    static MDATA getMDataFromData(QByteArray baData);
    static MDATA getMDataFromJSONFile(QString sFileName);

    static QList<MDATA> getInstalledModules(QString sDataPath, QString sRootPath);
    static QList<MDATA> getModulesFromJSONFile(QString sFileName);
    static QDate getDateFromJSONFile(QString sFileName);

    static bool createServerList(QString sListFileName, QList<QString> *pList, QString sWebPrefix, QString sDate);

    static void mDataToObject(Utils::MDATA *pMData, QJsonObject *pObject);
    static void objectToMData(QJsonObject *pObject, Utils::MDATA *pMData);

    static void handleRecordToObject(Utils::HANDLE_RECORD *pHandleRecord, QJsonObject *pObject);
    static void objectToHandleRecord(QJsonObject *pObject, Utils::HANDLE_RECORD *pHandleRecord);

    static QMap<QString, STATUS> getModulesStatusMap(QString sDataPath, QList<MDATA> *pServerList, QList<MDATA> *pInstalled);

    static MODULES_DATA getModulesData(QString sDataPath);
    static QList<Utils::WEB_RECORD> getUpdates(QMap<QString, STATUS> *pMapStatus);

    static QString getInstalledJsonFileName(QString sDataPath, QString sName);
    static QString getServerListFileName(QString sDataPath);
    static QString getServerLastestListFileName(QString sDataPath);
    static QString getModuleFileName(QString sDataPath, QString sName);
    static QString getConvertPath(QString sDataPath, QString sName);
    static QString getConvertDownloadFileName(QString sDataPath, QString sName, QString sPattern);
    static QString getConvertModulePath(QString sDataPath, QString sName);

    static Utils::MDATA getMDataByName(QList<MDATA> *pServerList, QString sName);
    static QList<QString> getNamesFromWebRecords(QList<WEB_RECORD> *pListWebRecords);
    static Utils::WEB_RECORD getWebRecordByName(QList<WEB_RECORD> *pListWebRecords, QString sName);

    static bool isGithubPresent(QString sServerListFileName);

    static bool updateJsonFile(QString sFileName, QList<MDATA> listMData);
    static bool updateServerList(QString sOldFileName, QString sNewFileName);

    static QString actionIdToString(ACTION action);
    static ACTION stringToActionId(QString sAction);

    static bool checkPattern(QString sString, Utils::MDATA *pMData);

private:
    static void _getRecords(QString sRootPath, QString sCurrentPath, QList<RECORD> *pListRecords);
};

#endif  // UTILS_H

```

`x64dbgPluginManager_source.pro`:

```pro
TEMPLATE      = subdirs
SUBDIRS       += gui_source
SUBDIRS       += console_source

```