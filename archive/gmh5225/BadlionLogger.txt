Project Path: arc_gmh5225_BadlionLogger_17xrpr_a

Source Tree:

```txt
arc_gmh5225_BadlionLogger_17xrpr_a
├── BadlionLogger
│   ├── BadlionLogger.vcxproj
│   ├── BadlionLogger.vcxproj.filters
│   ├── callbacks.hpp
│   ├── defs.hpp
│   ├── drv.cpp
│   ├── mm.cpp
│   ├── mm.hpp
│   ├── pe.cpp
│   ├── pe.hpp
│   └── routine.hpp
├── BadlionLogger.sln
├── LICENSE
└── README.md

```

`BadlionLogger.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30413.136
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BadlionLogger", "BadlionLogger\BadlionLogger.vcxproj", "{4BAF10FA-2A79-48B2-8F33-0350DE29CE65}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{4BAF10FA-2A79-48B2-8F33-0350DE29CE65}.Debug|ARM.ActiveCfg = Debug|ARM
		{4BAF10FA-2A79-48B2-8F33-0350DE29CE65}.Debug|ARM.Build.0 = Debug|ARM
		{4BAF10FA-2A79-48B2-8F33-0350DE29CE65}.Debug|ARM.Deploy.0 = Debug|ARM
		{4BAF10FA-2A79-48B2-8F33-0350DE29CE65}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{4BAF10FA-2A79-48B2-8F33-0350DE29CE65}.Debug|ARM64.Build.0 = Debug|ARM64
		{4BAF10FA-2A79-48B2-8F33-0350DE29CE65}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{4BAF10FA-2A79-48B2-8F33-0350DE29CE65}.Debug|x64.ActiveCfg = Debug|x64
		{4BAF10FA-2A79-48B2-8F33-0350DE29CE65}.Debug|x64.Build.0 = Debug|x64
		{4BAF10FA-2A79-48B2-8F33-0350DE29CE65}.Debug|x64.Deploy.0 = Debug|x64
		{4BAF10FA-2A79-48B2-8F33-0350DE29CE65}.Debug|x86.ActiveCfg = Debug|Win32
		{4BAF10FA-2A79-48B2-8F33-0350DE29CE65}.Debug|x86.Build.0 = Debug|Win32
		{4BAF10FA-2A79-48B2-8F33-0350DE29CE65}.Debug|x86.Deploy.0 = Debug|Win32
		{4BAF10FA-2A79-48B2-8F33-0350DE29CE65}.Release|ARM.ActiveCfg = Release|ARM
		{4BAF10FA-2A79-48B2-8F33-0350DE29CE65}.Release|ARM.Build.0 = Release|ARM
		{4BAF10FA-2A79-48B2-8F33-0350DE29CE65}.Release|ARM.Deploy.0 = Release|ARM
		{4BAF10FA-2A79-48B2-8F33-0350DE29CE65}.Release|ARM64.ActiveCfg = Release|ARM64
		{4BAF10FA-2A79-48B2-8F33-0350DE29CE65}.Release|ARM64.Build.0 = Release|ARM64
		{4BAF10FA-2A79-48B2-8F33-0350DE29CE65}.Release|ARM64.Deploy.0 = Release|ARM64
		{4BAF10FA-2A79-48B2-8F33-0350DE29CE65}.Release|x64.ActiveCfg = Release|x64
		{4BAF10FA-2A79-48B2-8F33-0350DE29CE65}.Release|x64.Build.0 = Release|x64
		{4BAF10FA-2A79-48B2-8F33-0350DE29CE65}.Release|x64.Deploy.0 = Release|x64
		{4BAF10FA-2A79-48B2-8F33-0350DE29CE65}.Release|x86.ActiveCfg = Release|Win32
		{4BAF10FA-2A79-48B2-8F33-0350DE29CE65}.Release|x86.Build.0 = Release|Win32
		{4BAF10FA-2A79-48B2-8F33-0350DE29CE65}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {FD0F7F3E-421A-4B75-96B1-A7A9F489D0CE}
	EndGlobalSection
EndGlobal

```

`BadlionLogger/BadlionLogger.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{4BAF10FA-2A79-48B2-8F33-0350DE29CE65}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>BadlionLogger</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <WarningLevel>Level3</WarningLevel>
      <TreatWarningAsError>false</TreatWarningAsError>
      <ControlFlowGuard>false</ControlFlowGuard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="BadlionLogger.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="drv.cpp" />
    <ClCompile Include="mm.cpp" />
    <ClCompile Include="pe.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="callbacks.hpp" />
    <ClInclude Include="defs.hpp" />
    <ClInclude Include="mm.hpp" />
    <ClInclude Include="routine.hpp" />
    <ClInclude Include="pe.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`BadlionLogger/BadlionLogger.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="BadlionLogger.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="drv.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="pe.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="mm.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="defs.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="routine.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="pe.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="mm.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="callbacks.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`BadlionLogger/callbacks.hpp`:

```hpp
#pragma once

#include "mm.hpp"

using namespace utils;

PVOID __stdcall MmGetSystemRoutineAddress_hk( PUNICODE_STRING routine )
{
	const auto ret = MmGetSystemRoutineAddress( routine );
	DbgPrint( "[*] MmGetSystemRoutineAddress( ROUTINE: %wZ ) -> %llx\n\n",
		routine, reinterpret_cast< UINT64 >( _ReturnAddress( ) ) );

	return ret;
}

NTSTATUS __stdcall ZwTerminateProcess_hk( HANDLE h_proc, NTSTATUS exit_status )
{
	DbgPrint( "[*] ZwTerminateProcess( HANDLE: %llx, EXIT_STATUS: %llx ) -> %llx\n\n",
		reinterpret_cast< UINT64 >( h_proc ), exit_status, reinterpret_cast< UINT64 >( _ReturnAddress( ) ) );
	return ZwTerminateProcess( h_proc, exit_status );
}

void __stdcall RtlInitUnicodeString_hk( PUNICODE_STRING dest, PCWSTR src )
{
	RtlInitUnicodeString( dest, src );
	DbgPrint( "[*] RtlInitUnicodeString( DEST: %wZ ) -> %llx\n\n",
		dest, reinterpret_cast< UINT64 >( _ReturnAddress( ) ) );
}

NTSTATUS __stdcall PsLookupProcessByProcessId_hk( HANDLE pid, PEPROCESS* process )
{
	DbgPrint( "[*] PsLookupProcessByProcessId( PID: %u, PEPROCESS: %llx ) -> %llx\n\n",
		reinterpret_cast< UINT64 >( pid ), reinterpret_cast< UINT64 >( process ), reinterpret_cast< UINT64 >( _ReturnAddress( ) ) );
	return PsLookupProcessByProcessId( pid, process );
}

NTSTATUS PsSetCreateProcessNotifyRoutineEx_hk( PCREATE_PROCESS_NOTIFY_ROUTINE_EX callback, BOOLEAN remove )
{
	DbgPrint( "[*] PsSetCreateProcessNotifyRoutineEx( CALLBACK: %llx, REMOVE: %i ) -> %llx\n\n",
		reinterpret_cast< UINT64 >( callback ), remove, reinterpret_cast< UINT64 >( _ReturnAddress( ) ) );
	return PsSetCreateProcessNotifyRoutineEx( callback, remove );
}

NTSTATUS PsSetLoadImageNotifyRoutine_hk( PLOAD_IMAGE_NOTIFY_ROUTINE callback )
{
	DbgPrint( "[*] PsSetLoadImageNotifyRoutine( CALLBACK: %llx ) -> %llx\n\n",
		reinterpret_cast< UINT64 >( callback ), reinterpret_cast< UINT64 >( _ReturnAddress( ) ) );

	return PsSetLoadImageNotifyRoutine( callback );
}

NTSTATUS IoCreateDevice_hk(
	PDRIVER_OBJECT drv_object,
	ULONG des,
	PUNICODE_STRING dev_name,
	ULONG dev_type,
	ULONG dev_chars,
	BOOLEAN exclus,
	PDEVICE_OBJECT* dev_object )
{

	DbgPrint( "[*] IoCreateDevice( DRVOBJ: %llx, EXTENSIONS: %u, NAME: %wZ, TYPE: %u, CHARACTERISTICS: %u, EXCLUSIVE: %u, DEVOBJ: %llx ) -> %llx\n\n",
		reinterpret_cast< UINT64 >( drv_object ),
		des,
		dev_name,
		dev_type,
		dev_chars,
		exclus,
		reinterpret_cast< UINT64 >( dev_object ),
		reinterpret_cast< UINT64 >( _ReturnAddress( ) )
	);

	return IoCreateDevice( drv_object, des, dev_name, dev_type, dev_chars, exclus, dev_object );
}

NTSTATUS ZwOpenProcess_hk( PHANDLE handle, ACCESS_MASK access, POBJECT_ATTRIBUTES attr, PCLIENT_ID pci )
{
	DbgPrint( "[*] ZwOpenProcess( HANDLE: %llx, MASK: %u -- ) -> %llx\n\n",
		reinterpret_cast< UINT64 >( handle ),
		access,
		reinterpret_cast< UINT64 >( _ReturnAddress( ) )
	);
	return ZwOpenProcess( handle, access, attr, pci );
}

```

`BadlionLogger/defs.hpp`:

```hpp
#pragma once

#include <ntddk.h>

using WORD = short;
using BYTE = unsigned char;

#ifndef DWORD
#define DWORD unsigned
#endif

#define IMAGE_NT_SIGNATURE              0x00004550  // PE00
#define IMAGE_DOS_SIGNATURE             0x5A4D      // MZ

typedef struct _SYSTEM_MODULE_ENTRY
{
    HANDLE Section;
    PVOID MappedBase;
    PVOID ImageBase;
    ULONG ImageSize;
    ULONG Flags;
    USHORT LoadOrderIndex;
    USHORT InitOrderIndex;
    USHORT LoadCount;
    USHORT OffsetToFileName;
    UCHAR FullPathName[256];
} SYSTEM_MODULE_ENTRY, * PSYSTEM_MODULE_ENTRY;

typedef struct _SYSTEM_MODULE_INFORMATION
{
    ULONG               	ModulesCount;
    SYSTEM_MODULE_ENTRY        	Modules[1];

} 	SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

typedef enum _SYSTEM_INFORMATION_CLASS {
    SystemBasicInformation = 0,
    SystemPerformanceInformation = 2,
    SystemTimeOfDayInformation = 3,
    SystemProcessInformation = 5,
    SystemProcessorPerformanceInformation = 8,
    SystemModuleInformation = 11,
    SystemInterruptInformation = 23,
    SystemExceptionInformation = 33,
    SystemRegistryQuotaInformation = 37,
    SystemLookasideInformation = 45
} SYSTEM_INFORMATION_CLASS;


typedef struct _IMAGE_DOS_HEADER
{
    WORD e_magic;
    WORD e_cblp;
    WORD e_cp;
    WORD e_crlc;
    WORD e_cparhdr;
    WORD e_minalloc;
    WORD e_maxalloc;
    WORD e_ss;
    WORD e_sp;
    WORD e_csum;
    WORD e_ip;
    WORD e_cs;
    WORD e_lfarlc;
    WORD e_ovno;
    WORD e_res[4];
    WORD e_oemid;
    WORD e_oeminfo;
    WORD e_res2[10];
    LONG e_lfanew;
} IMAGE_DOS_HEADER, * PIMAGE_DOS_HEADER;


typedef struct _IMAGE_FILE_HEADER
{
    WORD Machine;
    WORD NumberOfSections;
    ULONG TimeDateStamp;
    ULONG PointerToSymbolTable;
    ULONG NumberOfSymbols;
    WORD SizeOfOptionalHeader;
    WORD Characteristics;
} IMAGE_FILE_HEADER, * PIMAGE_FILE_HEADER;

typedef struct _IMAGE_DATA_DIRECTORY
{
    ULONG VirtualAddress;
    ULONG Size;
} IMAGE_DATA_DIRECTORY, * PIMAGE_DATA_DIRECTORY;

typedef struct _IMAGE_OPTIONAL_HEADER
{
    USHORT Magic;
    UCHAR MajorLinkerVersion;
    UCHAR MinorLinkerVersion;
    ULONG SizeOfCode;
    ULONG SizeOfInitializedData;
    ULONG SizeOfUninitializedData;
    ULONG AddressOfEntryPoint;
    ULONG BaseOfCode;
    UINT64 ImageBase;
    ULONG SectionAlignment;
    ULONG FileAlignment;
    USHORT MajorOperatingSystemVersion;
    USHORT MinorOperatingSystemVersion;
    USHORT MajorImageVersion;
    USHORT MinorImageVersion;
    USHORT MajorSubsystemVersion;
    USHORT MinorSubsystemVersion;
    ULONG Win32VersionValue;
    ULONG SizeOfImage;
    ULONG SizeOfHeaders;
    ULONG CheckSum;
    USHORT Subsystem;
    USHORT DllCharacteristics;
    UINT64 SizeOfStackReserve;
    UINT64 SizeOfStackCommit;
    UINT64 SizeOfHeapReserve;
    UINT64 SizeOfHeapCommit;
    ULONG LoaderFlags;
    ULONG NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[16];
} IMAGE_OPTIONAL_HEADER, * PIMAGE_OPTIONAL_HEADER;

typedef struct _IMAGE_EXPORT_DIRECTORY
{
    ULONG Charactistics;
    ULONG TimeDateStamp;
    WORD MajorVersion;
    WORD MinorVersion;
    ULONG Name;
    ULONG Base;
    ULONG NumberOfFunctions;
    ULONG AddressOfNames;
    ULONG AddressOfNamesOrdinals;
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;

typedef struct _IMAGE_SECTION_HEADER {
    unsigned char Name[8];
    union {
        unsigned PhysicalAddress;
        unsigned VirtualSize;
    } Misc;
    unsigned VirtualAddress;
    unsigned SizeOfRawData;
    unsigned PointerToRawData;
    unsigned PointerToRelocations;
    unsigned PointerToLinenumbers;
    short  NumberOfRelocations;
    short  NumberOfLinenumbers;
    unsigned Characteristics;
} IMAGE_SECTION_HEADER, * PIMAGE_SECTION_HEADER;


typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
    HANDLE Section;
    PVOID MappedBase;
    PVOID ImageBase;
    ULONG ImageSize;
    ULONG Flags;
    USHORT LoadOrderIndex;
    USHORT InitOrderIndex;
    USHORT LoadCount;
    USHORT OffsetToFileName;
    UCHAR  FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;


typedef struct _IMAGE_IMPORT_BY_NAME {
    WORD    Hint;
    CHAR   Name[1];
} IMAGE_IMPORT_BY_NAME, * PIMAGE_IMPORT_BY_NAME;

typedef struct _RTL_PROCESS_MODULES
{
    ULONG NumberOfModules;
    RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

typedef struct _IMAGE_THUNK_DATA64
{
    union
    {
        UINT64 ForwarderString;
        UINT64 Function;
        UINT64 Ordinal;
        UINT64 AddressOfData;
    } u1;
} IMAGE_THUNK_DATA64, * PIMAGE_THUNK_DATA64;


typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    union {
        DWORD   Characteristics;            
        DWORD   OriginalFirstThunk;        
    } DUMMYUNIONNAME;

    DWORD   TimeDateStamp;               
    DWORD   ForwarderChain;                 
    DWORD   Name;
    DWORD   FirstThunk;                     
} IMAGE_IMPORT_DESCRIPTOR;
typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED* PIMAGE_IMPORT_DESCRIPTOR;


typedef struct _IMAGE_NT_HEADERS64
{
    ULONG Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER OptionalHeader;
} IMAGE_NT_HEADERS;

extern "C" NTSTATUS NTAPI ZwQuerySystemInformation(
	_In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,
	_Inout_   PVOID                    SystemInformation,
	_In_      ULONG                    SystemInformationLength,
	_Out_opt_ PULONG                   ReturnLength
);

extern "C" NTSTATUS PsLookupProcessByProcessId(
    HANDLE    ProcessId,
    PEPROCESS * Process
);
```

`BadlionLogger/drv.cpp`:

```cpp
#include "routine.hpp"

PDEVICE_OBJECT dev_object;

void drv_unload( PDRIVER_OBJECT drv_object )
{
	UNREFERENCED_PARAMETER( drv_object );

	DbgPrint( "<< Logger >> Unloading Driver...\n" );
	PsRemoveLoadImageNotifyRoutine( load_image_callback );

	UNICODE_STRING sym_path = RTL_CONSTANT_STRING( L"\\DosDevices\\BadlionLogger" );

	IoDeleteSymbolicLink( &sym_path );
	IoDeleteDevice( dev_object );
}

NTSTATUS generic_mf_dispatch( PDEVICE_OBJECT device_object, PIRP irp )
{
	UNREFERENCED_PARAMETER( device_object );

	irp->IoStatus.Information = 0;
	irp->IoStatus.Status = STATUS_SUCCESS;

	IofCompleteRequest( irp, IO_NO_INCREMENT );
	return STATUS_SUCCESS;
}

NTSTATUS DriverEntry( PDRIVER_OBJECT driver_object, PUNICODE_STRING reg_path )
{
	UNREFERENCED_PARAMETER( reg_path );

	auto status = STATUS_SUCCESS;

	UNICODE_STRING dev_name = RTL_CONSTANT_STRING( L"\\Device\\BadlionLogger" );
	UNICODE_STRING sym_path = RTL_CONSTANT_STRING( L"\\DosDevices\\BadlionLogger" );

	status = IoCreateDevice(
		driver_object,
		NULL,
		&dev_name,
		FILE_DEVICE_UNKNOWN,
		FILE_DEVICE_SECURE_OPEN,
		FALSE,
		&dev_object );
	if ( !NT_SUCCESS( status ) )
		return status;

	status = IoCreateSymbolicLink( &sym_path, &dev_name );
	if ( !NT_SUCCESS(status) )
	{
		IoDeleteDevice( dev_object );
		return status;
	}

	driver_object->DriverUnload = drv_unload;

	driver_object->MajorFunction[ IRP_MJ_CREATE ] = generic_mf_dispatch;
	driver_object->MajorFunction[ IRP_MJ_CLOSE ] = generic_mf_dispatch;

	DbgPrint( "<< Init >> BadlionLogger initialized successfully!\n" );

	PsSetLoadImageNotifyRoutine( load_image_callback );
	return status;
}


```

`BadlionLogger/mm.cpp`:

```cpp
#include "mm.hpp"
#include <intrin.h>

namespace utils
{
	bool mm::safer_write_memory( const PVOID address, const PVOID value, const size_t len )
	{
		if ( !MmIsAddressValid( address ) )
			return false;

		PMDL mdl = IoAllocateMdl( address, len, FALSE, FALSE, nullptr );
		if ( nullptr == mdl )
			return false;

		MmProbeAndLockPages( mdl, KernelMode, IoReadAccess );
		const auto page = MmMapLockedPagesSpecifyCache( mdl, KernelMode, MmNonCached, nullptr, FALSE, NormalPagePriority );

		const auto status = MmProtectMdlSystemAddress( mdl, PAGE_EXECUTE_READWRITE );
		if ( NT_SUCCESS( status ) ) 
			RtlCopyMemory( page, value, len );

		MmUnmapLockedPages( page, mdl );
		MmUnlockPages( mdl );

		IoFreeMdl( mdl );
		return true;
	}

	// ehh
	void mm::unsafe_write_memory( UINT64* addr, PVOID hook )
	{
		const auto aff = KeSetSystemAffinityThreadEx( 0 );

		auto cr0 = __readcr0( );
		cr0 &= 0xfffffffffffeffff;

		__writecr0( cr0 );
		_disable( );
		
		*addr = reinterpret_cast< UINT64 >( hook );

		cr0 |= 0x10000;

		_enable( );
		__writecr0( cr0 );

		KeSetSystemAffinityThreadEx( aff );
	}
}
```

`BadlionLogger/mm.hpp`:

```hpp
#pragma once

#include "defs.hpp"

namespace utils
{
	class mm
	{
	public:
		static bool safer_write_memory( const PVOID address, const PVOID value, const size_t len );

		static void unsafe_write_memory( UINT64* addr, PVOID hook );
	};
}
```

`BadlionLogger/pe.cpp`:

```cpp
#include "pe.hpp"

namespace utils
{
	pe::pe( const UINT64 base_address ) : base( base_address ), nt_hdrs( nullptr )
	{
		const auto dos_hdr = reinterpret_cast< PIMAGE_DOS_HEADER >( base_address );
		if ( dos_hdr->e_magic != IMAGE_DOS_SIGNATURE )
			return;

		auto nt_hdr = reinterpret_cast< PIMAGE_NT_HEADERS >( base_address + dos_hdr->e_lfanew );
		if ( nt_hdr->Signature != IMAGE_NT_SIGNATURE )
			return;

		nt_hdrs = nt_hdr; // lol
	}

	const PIMAGE_IMPORT_DESCRIPTOR pe::get_image_desc( ) const
	{
		if ( nullptr == nt_hdrs )
			return nullptr;

		const auto import_dir = nt_hdrs->OptionalHeader.DataDirectory[ 1 ];
		if ( import_dir.Size == 0 )
			return nullptr;
		
		return reinterpret_cast< PIMAGE_IMPORT_DESCRIPTOR >( base + static_cast< UINT64 >( import_dir.VirtualAddress ) );
	}

	UINT64 pe::get_kernel_image( const STRING& name )
	{
		if ( nullptr == ZwQuerySystemInformation )
			return NULL;

		UINT64 m_base = 0;
		ULONG rlen = 0;

		ZwQuerySystemInformation( SystemModuleInformation, nullptr, rlen, &rlen );

		auto m_info =
			reinterpret_cast< PSYSTEM_MODULE_INFORMATION >( ExAllocatePoolWithTag( NonPagedPool, rlen, 'oaml' ) );
		if ( nullptr == m_info )
			return NULL;

		const auto status = ZwQuerySystemInformation( SystemModuleInformation, m_info, rlen, &rlen );
		if ( NT_SUCCESS( status ) )
		{
			for ( size_t i = 0; i < m_info->ModulesCount; ++i ) 
			{
				const auto mod = m_info->Modules[ i ];
				
				STRING m_name;
				RtlInitAnsiString( &m_name, reinterpret_cast< PCSZ >( mod.FullPathName + mod.OffsetToFileName ) );

				if ( !RtlCompareString( &name, &m_name, TRUE ) )
				{
					m_base = reinterpret_cast< UINT64 >( mod.ImageBase );
					break;
				}
			}
		}

		ExFreePoolWithTag( m_info, 'oaml' );
		return m_base;
	}
}
```

`BadlionLogger/pe.hpp`:

```hpp
#pragma once

#include "defs.hpp"

namespace utils
{
	class pe
	{
	private:
		PIMAGE_NT_HEADERS nt_hdrs;
		UINT64 base;

	public:
		pe( const UINT64 base_address );

		const PIMAGE_IMPORT_DESCRIPTOR get_image_desc( ) const;

		static UINT64 get_kernel_image( const STRING& name );
	};
}
```

`BadlionLogger/routine.hpp`:

```hpp
#pragma once

#include "pe.hpp"
#include "mm.hpp"

#include "callbacks.hpp"
	
using namespace utils;

void load_image_callback( PUNICODE_STRING name, HANDLE pid, PIMAGE_INFO image_info )
{
	UNREFERENCED_PARAMETER( pid );

	if ( !wcsstr( name->Buffer, L"BadlionAnticheat.sys" ) )
		return;

	const auto base = reinterpret_cast< UINT64 >( image_info->ImageBase );
	const pe image( base );
	
	DbgPrint( "<< Init >> Image Callback Triggered: %wZ\nBase => %llx\n\n", name, base );

	auto desc = image.get_image_desc( );
	if ( nullptr == desc )
		return;

	DbgPrint( "<< Init >> Retrieving imports...\n" );
	
	while ( desc->Name != NULL ) 
	{
		STRING module_name;
		RtlInitAnsiString( &module_name, reinterpret_cast< PCSZ >( desc->Name + base ) );

		if ( const auto m_addr = pe::get_kernel_image( module_name ) ) 
		{
			DbgPrint( "\n<< Init >> Import Table Entry: %Z\nBase => %llx\n\n", module_name, m_addr );

			auto ori_first_thunk = reinterpret_cast< PIMAGE_THUNK_DATA64 >( base + desc->OriginalFirstThunk );
			auto first_thunk = reinterpret_cast< PIMAGE_THUNK_DATA64 >( base + desc->FirstThunk );

			while ( ori_first_thunk->u1.AddressOfData != NULL )
			{
				const auto p_fname = reinterpret_cast< PIMAGE_IMPORT_BY_NAME >( base + ori_first_thunk->u1.AddressOfData );
				
				STRING func_name;
				RtlInitAnsiString( &func_name, reinterpret_cast< PCSZ >( p_fname->Name ) );

				// kernel moment
				// having std map would be nice

				if ( !strcmp( func_name.Buffer, "ZwTerminateProcess" ) )
					mm::unsafe_write_memory( &first_thunk->u1.Function, ZwTerminateProcess_hk );

				else if ( !strcmp( func_name.Buffer, "MmGetSystemRoutineAddress" ) )
					mm::unsafe_write_memory( &first_thunk->u1.Function, MmGetSystemRoutineAddress_hk );

				else if ( !strcmp( func_name.Buffer, "PsSetCreateProcessNotifyRoutineEx" ) )
					mm::unsafe_write_memory( &first_thunk->u1.Function, PsSetCreateProcessNotifyRoutineEx_hk );

				else if ( !strcmp( func_name.Buffer, "PsSetLoadImageNotifyRoutine" ) )
					mm::unsafe_write_memory( &first_thunk->u1.Function, PsSetLoadImageNotifyRoutine_hk );

				else if ( !strcmp( func_name.Buffer, "RtlInitUnicodeString" ) )
					mm::unsafe_write_memory( &first_thunk->u1.Function, RtlInitUnicodeString_hk );

				else if ( !strcmp( func_name.Buffer, "PsLookupProcessByProcessId" ) )
					mm::unsafe_write_memory( &first_thunk->u1.Function, PsLookupProcessByProcessId_hk );

				else if ( !strcmp( func_name.Buffer, "IoCreateDevice" ) )
					mm::unsafe_write_memory( &first_thunk->u1.Function, IoCreateDevice_hk );

				else if ( !strcmp( func_name.Buffer, "ZwOpenProcess" ) )
					mm::unsafe_write_memory( &first_thunk->u1.Function, ZwOpenProcess_hk );

				
				++first_thunk;
				++ori_first_thunk;
			}
		}

		desc++;
	}
}
```

`LICENSE`:

```
Copyright 2020 aguazsl

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
```

`README.md`:

```md
# BadlionLogger
BadlionLogger is a rudimentary PoC of a kernel driver used to monitor the activity of BadlionClient's kernelmode anti-cheat (`BadlionAnticheat.sys`) by applying IAT hooks on the image during the image load callback.
  
BadlionAnticheat is virtualized with [VMProtect](https://vmpsoft.com/), a popular VM packer used in many products.  
This project employs a blackbox approach to monitoring driver activity without devirtualization due to no integrity checking.

# Example
### DriverEntry
<img src="https://i.imgur.com/W1O7wPR.png"/>

## CreateProcess callback
<img src="https://i.imgur.com/WoJkeg1.png"/>

## Disclaimer
- BadlionLogger is a proof-of-concept and is not intended to be a reliable product
- This project contains numerous bad practices that should be considered 

```