Project Path: arc_gmh5225_dncil_6xr13pto

Source Tree:

```txt
arc_gmh5225_dncil_6xr13pto
├── LICENSE.txt
├── README.md
├── dncil
│   ├── __init__.py
│   ├── cil
│   │   ├── __init__.py
│   │   ├── body
│   │   │   ├── __init__.py
│   │   │   ├── flags.py
│   │   │   └── reader.py
│   │   ├── enums.py
│   │   ├── error.py
│   │   ├── exception.py
│   │   ├── instruction.py
│   │   └── opcode.py
│   ├── clr
│   │   ├── __init__.py
│   │   ├── argument.py
│   │   ├── local.py
│   │   └── token.py
│   └── version.py
├── scripts
│   ├── print_cil_from_bytes.py
│   └── print_cil_from_dn_file.py
├── setup.cfg
├── setup.py
└── tests
    ├── fixtures.py
    ├── test_method_body.py
    └── test_token.py

```

`LICENSE.txt`:

```txt

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright (C) 2022 Mandiant, Inc.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`README.md`:

```md
![dncil](./.github/dncil.png)

[![CI](https://github.com/mandiant/dncil/actions/workflows/tests.yml/badge.svg)](https://github.com/mandiant/dncil/actions/workflows/tests.yml)
[![License](https://img.shields.io/badge/license-Apache--2.0-green.svg)](LICENSE.txt)

`dncil` is a Common Intermediate Language (`CIL`) disassembly library written in Python that supports parsing the header, instructions, and exception handlers of `.NET` managed methods. Parsed data is exposed through an object-oriented API to help you quickly develop `CIL` analysis tools using `dncil`.

Why `Python`? Existing libraries that support `CIL` disassembly, like [`dnLib`](https://github.com/0xd4d/dnlib), are written in `C#`. To leverage these tools, you must build `C#` applications which requires `C#` development experience. Using `dncil`, a pure `Python` alternative, you:

1. Do not need `C#` experience to analyze `CIL` programmatically.
2. Can quickly develop and test your `CIL` analysis tools.
3. Can easily integrate your `CIL` analysis tools with existing `Python` projects.

## Example

The example script [`print_cil_from_dn_file.py`](scripts/print_cil_from_dn_file.py) uses `dncil` together with `.NET` analysis library [`dnfile`](https://github.com/malwarefrank/dnfile) to disassemble the managed methods found in a `.NET` executable. Let's see what it can do.

First, we compile the following `C#` source code:

```C#
using System;	

public class HelloWorld
{
    public static void Main(string[] args)
    {
        Console.WriteLine ("Hello World!");
    }
}
```

Compilation results in a `PE` executable containing `.NET` metadata which informs the `Common Language Runtime` (`CLR`) how to execute our code. We use `dnfile` to parse this metadata which gives us the offset of our managed method `Main`. We then use `dncil` to disassemble and display the `CIL` instructions stored at this location.

Let's see the above in action:

```
$ python scripts/print_cil_from_dn_file.py hello-world.exe 

Method: Main
0000    00                  nop            
0001    72 01 00 00 70      ldstr          "Hello World!"
0006    28 04 00 00 0a      call           System.Console::WriteLine
000B    00                  nop            
000C    2a                  ret            
```

Our method `Main` is represented by the [`CilMethodBody`](dncil/cil/body/__init__.py) class. This class holds data that includes the header, `CIL` instructions, and exception handlers of a given managed method. It also exposes various helper functions:

```Python
>  main_method_body.flags
SmallFormat  :  false
TinyFormat   :  false
FatFormat    :  false
TinyFormat1  :  true
MoreSects    :  false
InitLocals   :  false
CompressedIL :  false
>  main_method_body.size
14
>  hexdump.hexdump(main_method_body.get_bytes())
00000000: 36 00 72 01 00 00 70 28  04 00 00 0A 00 2A        6.r...p(.....*
>  hexdump.hexdump(main_method_body.get_header_bytes())
00000000: 36                                                6
>  hexdump.hexdump(main_method_body.get_instruction_bytes())
00000000: 00 72 01 00 00 70 28 04  00 00 0A 00 2A           .r...p(.....*
```

Each `CIL` instruction found in our managed method `Main` is represented by the [`Instruction`](dncil/cil/instruction.py) class. This class holds data that includes the offset, mnemonic, opcode, and operand of a given `CIL` instruction. It also exposes various helper functions:

```Python
>  len(main_method_body.instructions)
5
>  insn = main_method_body.instructions[1]
>  insn.offset
1
>  insn.mnemonic
'ldstr'
>  insn.operand
token(0x70000001)
>  insn.is_ldstr()
True
>  insn.size
5
>  hexdump.hexdump(insn.get_bytes())
00000000: 72 01 00 00 70                                    r...p
>  hexdump.hexdump(insn.get_opcode_bytes())
00000000: 72                                                r
>  hexdump.hexdump(insn.get_operand_bytes())
00000000: 01 00 00 70                                       ...p
```

## Installation

Download the `dncil` source and run the following command from the root directory:

```
$ pip install .
```

To execute the example scripts be sure to install [`dnfile`](https://github.com/malwarefrank/dnfile). Alternatively, install `dncil` with the development dependencies as described in the `Testing` section below.

See [print_cil_from_bytes.py](scripts/print_cil_from_bytes.py) for a quick example of using `dncil`to print the `CIL` instructions found in a byte stream containing a `.NET` managed method.

## Testing

Ensure you have installed `dncil` with the development dependencies:

```
$ pip install .[dev]
```

Then invoke pytest:

```
$ python -m pytest tests/
```

## Linting

Ensure you have installed `dncil` with the development dependencies as described above.

Then:

```
$ pycodestyle --show-source dncil tests
$ python -m black -l 120 -c .
$ python -m isort --profile black --length-sort --line-width 120 -c .
```

## Credits

`dncil` is based on the `CIL` parsing code found in [`dnLib`](https://github.com/0xd4d/dnlib).

```

`dncil/cil/body/__init__.py`:

```py
# Copyright (C) 2022 Mandiant, Inc. All Rights Reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
# You may obtain a copy of the License at: [package root]/LICENSE.txt
# Unless required by applicable law or agreed to in writing, software distributed under the License
#  is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and limitations under the License.

from __future__ import annotations

from typing import TYPE_CHECKING, List, Optional

if TYPE_CHECKING:
    from dncil.cil.instruction import Instruction
    from dncil.cil.body.reader import CilMethodBodyReaderBase

from dncil.cil.enums import CorILMethod, CorILMethodSect
from dncil.cil.error import MethodBodyFormatError
from dncil.clr.token import Token
from dncil.cil.exception import ExceptionHandler
from dncil.cil.body.flags import CilMethodBodyFlags
from dncil.cil.instruction import Instruction


class CilMethodBody:
    """store managed method body"""

    def __init__(self, reader: CilMethodBodyReaderBase):
        self.offset: int
        self.header_size: int
        self.flags: CilMethodBodyFlags
        self.max_stack: int
        self.code_size: int
        self.local_var_sig_tok: Optional[Token]
        self.size: int
        self.raw_bytes: bytes
        self.exception_handlers_size: int

        self.instructions: List[Instruction] = []
        self.exception_handlers: List[ExceptionHandler] = []

        # set method offset
        self.offset = reader.tell()

        # parse the method body
        self.parse_header(reader)
        self.parse_instructions(reader)
        self.parse_exception_handlers(reader)

        # use initial offset + method body size to read method body bytes (not the most efficient)
        final_pos = reader.tell()
        reader.seek(self.offset)
        self.raw_bytes = reader.read(self.size)
        reader.seek(final_pos)

        # calculate exception handlers size
        self.exception_handlers_size = self.size - self.header_size - self.code_size

    def __int__(self) -> int:
        return self.offset

    def get_bytes(self) -> bytes:
        """get method body bytes"""
        return self.raw_bytes

    def get_header_bytes(self) -> bytes:
        """get method header bytes"""
        return self.raw_bytes[: self.header_size]

    def get_instruction_bytes(self) -> bytes:
        """get method instruction bytes"""
        return self.raw_bytes[self.header_size : self.header_size + self.code_size + 1]

    def get_exception_handler_bytes(self) -> bytes:
        """get method exception handler bytes"""
        return self.raw_bytes[self.header_size + self.code_size + 1 :]

    def parse_header(self, reader: CilMethodBodyReaderBase):
        """get method body header"""
        # header byte gives us the format and, in fat format, implementation flags used at runtime
        header_byte: int = reader.read_uint8()[0]
        if header_byte & CorILMethod.FormatMask in (CorILMethod.TinyFormat, CorILMethod.TinyFormat1):
            # tiny format - use default values specified by ECMA for all fields other than code size
            self.flags = CilMethodBodyFlags(header_byte & CorILMethod.FormatMask)
            self.header_size = 1
            self.max_stack = 8
            self.code_size = header_byte >> 2
            self.local_var_sig_tok = None
        elif header_byte & CorILMethod.FormatMask in (CorILMethod.FatFormat,):
            # fat format
            self.flags = CilMethodBodyFlags((reader.read_uint8()[0] << 8) | header_byte)
            self.header_size = self.flags.value >> 12
            self.max_stack = reader.read_uint16()[0]
            self.code_size = reader.read_uint32()[0]

            local_var_sig_tok = reader.read_uint32()[0]
            if local_var_sig_tok == 0:
                # zero indicates there are no local variables
                self.local_var_sig_tok = None
            else:
                self.local_var_sig_tok = Token(local_var_sig_tok)

            # ECMA states fat format size is "currently" 3; we may need to change this calculation if that ever changes
            reader.seek(reader.tell() - 12 + self.header_size * 4)

            # unsure on this check - may be some edge case handled by dnlib
            if self.header_size < 3:
                self.flags.value &= 0xFFF7

            # size indicates the number of 32-bit integers so we need to calc the total number of bytes
            self.header_size *= 4
        else:
            raise MethodBodyFormatError("bad header format 0x%02X" % (header_byte & CorILMethod.FormatMask))

    def parse_instructions(self, reader: CilMethodBodyReaderBase):
        """get CIL instructions"""
        current_offset: int = self.offset + self.header_size
        code_end_offset: int = reader.tell() + self.code_size

        # instructions are stored sequentially so we just read through the stream
        while reader.tell() < code_end_offset:
            insn: Instruction = reader.read_instruction(current_offset)
            current_offset += insn.size
            self.instructions.append(insn)

    def parse_exception_handlers(self, reader: CilMethodBodyReaderBase):
        """get exception handlers"""
        if not self.flags.MoreSects:
            # exception handlers are stored in extra data sections so bail if there are none
            self.size = reader.tell() - self.offset
            return

        # extra data sections start at first 4-byte boundary
        reader.seek((reader.tell() + 3) & ~3)

        # header byte gives us the format
        header_byte: int = reader.read_uint8()[0]

        # unsure on this check - may be some edge case handler by dnlib
        if header_byte & CorILMethodSect.KindMask != 1:
            self.size = reader.tell() - self.offset
            return

        if header_byte & CorILMethodSect.FatFormat:
            # fat format
            self.parse_fat_exception_handlers(reader)
        else:
            # tiny format
            self.parse_tiny_exception_handlers(reader)

        self.size = reader.tell() - self.offset

    def parse_fat_exception_handlers(self, reader: CilMethodBodyReaderBase):
        """get exception handlers in fat format"""
        # fat header is 8 bits (flags) + 24 bits (size) so to get the size we rewind 8 bits, read a 32-bit integer, and shift for the 24-bit integer
        reader.seek(reader.tell() - 1)
        total_size: int = reader.read_uint32()[0] >> 8

        # size is total bytes so we need to calc the number of exception handlers
        num_exceptions: int = total_size // ExceptionHandler.FAT_SIZE
        for _ in range(num_exceptions):
            eh: ExceptionHandler = ExceptionHandler(reader.read_uint32()[0])

            eh.try_start = reader.read_uint32()[0]
            eh.try_end = eh.try_start + reader.read_uint32()[0]

            eh.handler_start = reader.read_uint32()[0]
            eh.handler_end = eh.handler_start + reader.read_uint32()[0]

            if eh.is_catch():
                eh.catch_type = Token(reader.read_uint32()[0])
            elif eh.is_filter():
                eh.filter_start = reader.read_uint32()[0]
            else:
                _ = reader.read_uint32()[0]

            self.exception_handlers.append(eh)

    def parse_tiny_exception_handlers(self, reader: CilMethodBodyReaderBase):
        """get exception handlers in tiny format"""
        # size is total bytes so we need to calc the number of exception handlers
        num_exceptions: int = reader.read_uint8()[0] // ExceptionHandler.TINY_SIZE

        # skip padding (16 bits)
        reader.seek(reader.tell() + 2)

        for _ in range(num_exceptions):
            eh: ExceptionHandler = ExceptionHandler(reader.read_uint16()[0])

            eh.try_start = reader.read_uint16()[0]
            eh.try_end = eh.try_start + reader.read_uint8()[0]

            eh.handler_start = reader.read_uint16()[0]
            eh.handler_end = eh.handler_start + reader.read_uint8()[0]

            if eh.is_catch():
                eh.catch_type = Token(reader.read_uint32()[0])
            elif eh.is_filter():
                eh.filter_start = reader.read_uint32()[0]
            else:
                _ = reader.read_uint32()[0]

            self.exception_handlers.append(eh)

```

`dncil/cil/body/flags.py`:

```py
# Copyright (C) 2022 Mandiant, Inc. All Rights Reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
# You may obtain a copy of the License at: [package root]/LICENSE.txt
# Unless required by applicable law or agreed to in writing, software distributed under the License
#  is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and limitations under the License.

from __future__ import annotations

from dncil.cil.enums import CorILMethod


class CilMethodBodyFlags:
    """store maanged method body flags"""

    def __init__(self, flags: int):
        self.value: int = flags

        self.SmallFormat: bool = (flags & CorILMethod.FormatMask) == CorILMethod.SmallFormat
        self.TinyFormat: bool = (flags & CorILMethod.FormatMask) == CorILMethod.TinyFormat
        self.FatFormat: bool = (flags & CorILMethod.FormatMask) == CorILMethod.FatFormat
        self.TinyFormat1: bool = (flags & CorILMethod.FormatMask) == CorILMethod.TinyFormat1
        self.MoreSects: bool = bool(flags & CorILMethod.MoreSects)
        self.InitLocals: bool = bool(flags & CorILMethod.InitLocals)
        self.CompressedIL: bool = bool(flags & CorILMethod.CompressedIL)

    def __str__(self):
        def _to_print(v):
            return "true" if v else "false"

        return (
            f"SmallFormat  :  {_to_print(self.SmallFormat)}\n"
            + f"TinyFormat   :  {_to_print(self.TinyFormat)}\n"
            + f"FatFormat    :  {_to_print(self.FatFormat)}\n"
            + f"TinyFormat1  :  {_to_print(self.TinyFormat1)}\n"
            + f"MoreSects    :  {_to_print(self.MoreSects)}\n"
            + f"InitLocals   :  {_to_print(self.InitLocals)}\n"
            + f"CompressedIL :  {_to_print(self.CompressedIL)}\n"
        )

    def __repr__(self):
        return str(self)

    def is_tiny(self) -> bool:
        """check if tiny format flags set"""
        return any((self.TinyFormat, self.TinyFormat1))

    def is_fat(self) -> bool:
        """check if fat format flags set"""
        return self.FatFormat

```

`dncil/cil/body/reader.py`:

```py
# Copyright (C) 2022 Mandiant, Inc. All Rights Reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
# You may obtain a copy of the License at: [package root]/LICENSE.txt
# Unless required by applicable law or agreed to in writing, software distributed under the License
#  is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and limitations under the License.

from __future__ import annotations

import io
import abc
import struct
from typing import TYPE_CHECKING, Any, Dict, List, Tuple, Union, Callable, Optional, cast

if TYPE_CHECKING:
    from dncil.cil.opcode import OpCode

from dncil.cil.body import CilMethodBody
from dncil.cil.error import MethodBodyFormatError
from dncil.clr.local import Local
from dncil.clr.token import Token, StringToken
from dncil.cil.opcode import OpCodes, OpCodeValue, OperandType
from dncil.clr.argument import Argument
from dncil.cil.instruction import Instruction

CIL_OPCODES = OpCodes()


class CilMethodBodyReaderBase(abc.ABC):
    """abstract class for reading managed method body"""

    @abc.abstractmethod
    def read(self, n: int) -> bytes:
        """get bytes from stream"""
        ...

    @abc.abstractmethod
    def tell(self) -> int:
        """get stream offset"""
        ...

    @abc.abstractmethod
    def seek(self, rva: int) -> int:
        """jump to stream to offset"""
        ...

    def _unpack(self, data_format: str) -> Tuple[Union[int, float], bytes]:
        """unpack bytes"""
        unpack_size: int = struct.calcsize(data_format)
        unpack_bytes: bytes = self.read(unpack_size)
        if unpack_bytes == b"" or len(unpack_bytes) != unpack_size:
            raise MethodBodyFormatError(
                "not enough data while parsing method body @ offset 0x%X" % (self.tell() - len(unpack_bytes))
            )
        return struct.unpack(data_format, unpack_bytes)[0], unpack_bytes

    def is_arg_operand_instruction(self, insn: Instruction) -> bool:
        """check if instruction has a argument operand"""
        return insn.opcode.value in (
            OpCodeValue.Ldarg,
            OpCodeValue.Ldarg_S,
            OpCodeValue.Ldarga,
            OpCodeValue.Ldarga_S,
            OpCodeValue.Starg,
            OpCodeValue.Starg_S,
        )

    def read_uint8(self) -> Tuple[int, bytes]:
        """get unsigned 8-bit integer"""
        return cast(Tuple[int, bytes], self._unpack("<B"))

    def read_int8(self) -> Tuple[int, bytes]:
        """get signed 8-bit integer"""
        return cast(Tuple[int, bytes], self._unpack("<b"))

    def read_uint16(self) -> Tuple[int, bytes]:
        """get unsigned 16-bit integer"""
        return cast(Tuple[int, bytes], self._unpack("<H"))

    def read_int16(self) -> Tuple[int, bytes]:
        """get signed 16-bit integer"""
        return cast(Tuple[int, bytes], self._unpack("<h"))

    def read_uint32(self) -> Tuple[int, bytes]:
        """get unsigned 32-bit integer"""
        return cast(Tuple[int, bytes], self._unpack("<I"))

    def read_int32(self) -> Tuple[int, bytes]:
        """get signed 32-bit integer"""
        return cast(Tuple[int, bytes], self._unpack("<i"))

    def read_uint64(self) -> Tuple[int, bytes]:
        """get unsigned 64-bit integer"""
        return cast(Tuple[int, bytes], self._unpack("<Q"))

    def read_int64(self) -> Tuple[int, bytes]:
        """get signed 64-bit integer"""
        return cast(Tuple[int, bytes], self._unpack("<q"))

    def read_float32(self) -> Tuple[float, bytes]:
        """get 32-bit float"""
        return self._unpack("<f")

    def read_double64(self) -> Tuple[float, bytes]:
        """get 64-bit float"""
        return self._unpack("<d")

    def read_inline_br_target(self, insn: Instruction) -> Tuple[int, bytes]:
        """get inline branch target"""
        branch_offset: int
        branch_offset_bytes: bytes

        branch_offset, branch_offset_bytes = self.read_uint32()
        return insn.offset + insn.size + branch_offset, branch_offset_bytes

    def read_inline_field(self, insn: Instruction) -> Tuple[Token, bytes]:
        """get inline managed field token"""
        token_value: int
        token_bytes: bytes

        token_value, token_bytes = self.read_uint32()
        return Token(token_value), token_bytes

    def read_inline_i(self, insn: Instruction) -> Tuple[int, bytes]:
        """get inline 32-bit integer"""
        return self.read_uint32()

    def read_inline_i8(self, insn: Instruction) -> Tuple[int, bytes]:
        """get inline 64-bit integer"""
        return self.read_uint64()

    def read_inline_method(self, insn: Instruction) -> Tuple[Token, bytes]:
        """get inline managed method token"""
        token_value: int
        token_bytes: bytes

        token_value, token_bytes = self.read_uint32()
        return Token(token_value), token_bytes

    def read_inline_none(self, insn: Instruction) -> Tuple[None, bytes]:
        """get inline empty operand"""
        return None, b""

    def read_inline_phi(self, insn: Instruction) -> Tuple[None, bytes]:
        """get inline empty operand"""
        return None, b""

    def read_inline_r(self, insn: Instruction) -> Tuple[float, bytes]:
        """get inline 64-bit float"""
        return self.read_double64()

    def read_inline_sig(self, insn: Instruction) -> Tuple[Token, bytes]:
        """get inline managed signature token"""
        token_value: int
        token_bytes: bytes

        token_value, token_bytes = self.read_uint32()
        return Token(token_value), token_bytes

    def read_inline_string(self, insn: Instruction) -> Tuple[Token, bytes]:
        """get inline managed string token"""
        token_value: int
        token_bytes: bytes

        token_value, token_bytes = self.read_uint32()
        return StringToken(token_value), token_bytes

    def read_inline_switch(self, insn: Instruction) -> Tuple[list, bytes]:
        """get inline switch + branch targets"""
        num_branches: int
        branches_bytes: bytes

        num_branches, branches_bytes = self.read_uint32()
        offset_after_insn: int = insn.offset + insn.opcode.size + 4 + num_branches * 4

        branches: List[int] = []
        for _ in range(num_branches):
            branch_offset: int
            branch_offset_raw: bytes

            branch_offset, branch_offset_raw = self.read_uint32()
            branches.append(offset_after_insn + branch_offset)
            branches_bytes += branch_offset_raw

        return branches, branches_bytes

    def read_inline_tok(self, insn: Instruction) -> Tuple[Token, bytes]:
        """get inline managed token"""
        token_value: int
        token_bytes: bytes

        token_value, token_bytes = self.read_uint32()
        return Token(token_value), token_bytes

    def read_inline_type(self, insn: Instruction) -> Tuple[Token, bytes]:
        """get inline managed type token"""
        token_value: int
        token_bytes: bytes

        token_value, token_bytes = self.read_uint32()
        return Token(token_value), token_bytes

    def read_inline_var(self, insn: Instruction) -> Tuple[Union[Local, Argument], bytes]:
        """get inline managed method argument index or managed method local index"""
        var_value: int
        var_bytes: bytes
        var_obj: Union[Local, Argument]

        var_value, var_bytes = self.read_uint16()
        if self.is_arg_operand_instruction(insn):
            var_obj = Argument(var_value)
        else:
            var_obj = Local(var_value)

        return var_obj, var_bytes

    def read_short_inline_br_target(self, insn: Instruction) -> Tuple[int, bytes]:
        """get inline branch target"""
        branch_offset: int
        branch_offset_bytes: bytes

        branch_offset, branch_offset_bytes = self.read_uint8()
        return insn.offset + insn.size + branch_offset, branch_offset_bytes

    def read_short_inline_i(self, insn: Instruction) -> Tuple[int, bytes]:
        """get inline 8-bit integer"""
        if insn.opcode.value == OpCodeValue.Ldc_I4_S:
            # signed byte
            return self.read_int8()
        # unsigned byte
        return self.read_uint8()

    def read_short_inline_r(self, insn: Instruction) -> Tuple[float, bytes]:
        """get inline 32-bit float"""
        return self.read_float32()

    def read_short_inline_var(self, insn: Instruction) -> Tuple[Union[Local, Argument], bytes]:
        """get inline managed method argument index or managed method local index"""
        var_value: int
        var_bytes: bytes
        var_obj: Union[Local, Argument]

        var_value, var_bytes = self.read_uint8()
        if self.is_arg_operand_instruction(insn):
            var_obj = Argument(var_value)
        else:
            var_obj = Local(var_value)

        return var_obj, var_bytes

    def read_instruction(self, off: int = 0) -> Instruction:
        """get instruction"""
        insn: Instruction = Instruction()

        insn.offset = off
        insn.opcode, insn.opcode_bytes = self.read_opcode()
        insn.operand, insn.operand_bytes = self.read_operand(insn)

        return insn

    def read_opcode(self) -> Tuple[OpCode, bytes]:
        """get instruction opcode"""
        op_value_first: int
        op_byte_first: bytes

        op_value_second: int
        op_byte_second: bytes

        opcode: OpCode
        opcode_bytes: bytes

        op_value_first, op_byte_first = self.read_uint8()

        if op_value_first == 0xFE:
            # 2-byte opcode
            op_value_second, op_byte_second = self.read_uint8()
            try:
                opcode = CIL_OPCODES.two_byte_op_codes[op_value_second]
                opcode_bytes = op_byte_first + op_byte_second
            except IndexError:
                raise MethodBodyFormatError("bad opcode %02X%02X" % (op_value_first, op_value_second))
        else:
            # 1-byte opcode
            try:
                opcode = CIL_OPCODES.one_byte_op_codes[op_value_first]
                opcode_bytes = op_byte_first
            except IndexError:
                raise MethodBodyFormatError("bad opcode %02X" % op_value_first)

        return opcode, opcode_bytes

    def read_operand(self, insn: Instruction) -> Tuple[Union[Token, Local, Argument, list, float, int, None], bytes]:
        """get instruction operand"""
        readers: Dict[OperandType, Callable] = {
            OperandType.InlineBrTarget: self.read_inline_br_target,
            OperandType.InlineField: self.read_inline_field,
            OperandType.InlineI: self.read_inline_i,
            OperandType.InlineI8: self.read_inline_i8,
            OperandType.InlineMethod: self.read_inline_method,
            OperandType.InlineNone: self.read_inline_none,
            OperandType.InlinePhi: self.read_inline_phi,
            OperandType.InlineR: self.read_inline_r,
            OperandType.InlineSig: self.read_inline_sig,
            OperandType.InlineString: self.read_inline_string,
            OperandType.InlineSwitch: self.read_inline_switch,
            OperandType.InlineTok: self.read_inline_tok,
            OperandType.InlineType: self.read_inline_type,
            OperandType.InlineVar: self.read_inline_var,
            OperandType.ShortInlineBrTarget: self.read_short_inline_br_target,
            OperandType.ShortInlineI: self.read_short_inline_i,
            OperandType.ShortInlineR: self.read_short_inline_r,
            OperandType.ShortInlineVar: self.read_short_inline_var,
        }
        reader: Optional[Callable] = readers.get(insn.opcode.operand_type, None)

        if reader is None:
            raise MethodBodyFormatError("bad operand type 0x%02X" % insn.opcode.operand_type)

        return reader(insn)


class CilMethodBodyReaderBytes(CilMethodBodyReaderBase):
    """bytestream impl for abstract CilMethodBodyReaderBase"""

    def __init__(self, bs: bytes):
        self.stream: io.BytesIO = io.BytesIO(bs)

    def read(self, n: int) -> bytes:
        return self.stream.read(n)

    def tell(self) -> int:
        return self.stream.tell()

    def seek(self, loc: int) -> int:
        return self.stream.seek(loc)


def read_method_body_from_bytes(bio: bytes) -> CilMethodBody:
    """read managed method body from byte stream"""
    return CilMethodBody(CilMethodBodyReaderBytes(bio))

```

`dncil/cil/enums.py`:

```py
# Copyright (C) 2022 Mandiant, Inc. All Rights Reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
# You may obtain a copy of the License at: [package root]/LICENSE.txt
# Unless required by applicable law or agreed to in writing, software distributed under the License
#  is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and limitations under the License.

import enum


class OpCodeValue(enum.IntEnum):
    """
    https://github.com/0xd4d/dnlib/blob/master/src/DotNet/Emit/Code.cs
    """

    UNKNOWN1 = 0x0100
    UNKNOWN2 = 0x0101
    Add = 0x0058
    Add_Ovf = 0x00D6
    Add_Ovf_Un = 0x00D7
    And = 0x005F
    Arglist = 0xFE00
    Beq = 0x003B
    Beq_S = 0x002E
    Bge = 0x003C
    Bge_S = 0x002F
    Bge_Un = 0x0041
    Bge_Un_S = 0x0034
    Bgt = 0x003D
    Bgt_S = 0x0030
    Bgt_Un = 0x0042
    Bgt_Un_S = 0x0035
    Ble = 0x003E
    Ble_S = 0x0031
    Ble_Un = 0x0043
    Ble_Un_S = 0x0036
    Blt = 0x003F
    Blt_S = 0x0032
    Blt_Un = 0x0044
    Blt_Un_S = 0x0037
    Bne_Un = 0x0040
    Bne_Un_S = 0x0033
    Box = 0x008C
    Br = 0x0038
    Br_S = 0x002B
    Break = 0x0001
    Brfalse = 0x0039
    Brfalse_S = 0x002C
    Brtrue = 0x003A
    Brtrue_S = 0x002D
    Call = 0x0028
    Calli = 0x0029
    Callvirt = 0x006F
    Castclass = 0x0074
    Ceq = 0xFE01
    Cgt = 0xFE02
    Cgt_Un = 0xFE03
    Ckfinite = 0x00C3
    Clt = 0xFE04
    Clt_Un = 0xFE05
    Constrained = 0xFE16
    Conv_I = 0x00D3
    Conv_I1 = 0x0067
    Conv_I2 = 0x0068
    Conv_I4 = 0x0069
    Conv_I8 = 0x006A
    Conv_Ovf_I = 0x00D4
    Conv_Ovf_I_Un = 0x008A
    Conv_Ovf_I1 = 0x00B3
    Conv_Ovf_I1_Un = 0x0082
    Conv_Ovf_I2 = 0x00B5
    Conv_Ovf_I2_Un = 0x0083
    Conv_Ovf_I4 = 0x00B7
    Conv_Ovf_I4_Un = 0x0084
    Conv_Ovf_I8 = 0x00B9
    Conv_Ovf_I8_Un = 0x0085
    Conv_Ovf_U = 0x00D5
    Conv_Ovf_U_Un = 0x008B
    Conv_Ovf_U1 = 0x00B4
    Conv_Ovf_U1_Un = 0x0086
    Conv_Ovf_U2 = 0x00B6
    Conv_Ovf_U2_Un = 0x0087
    Conv_Ovf_U4 = 0x00B8
    Conv_Ovf_U4_Un = 0x0088
    Conv_Ovf_U8 = 0x00BA
    Conv_Ovf_U8_Un = 0x0089
    Conv_R_Un = 0x0076
    Conv_R4 = 0x006B
    Conv_R8 = 0x006C
    Conv_U = 0x00E0
    Conv_U1 = 0x00D2
    Conv_U2 = 0x00D1
    Conv_U4 = 0x006D
    Conv_U8 = 0x006E
    Cpblk = 0xFE17
    Cpobj = 0x0070
    Div = 0x005B
    Div_Un = 0x005C
    Dup = 0x0025
    Endfilter = 0xFE11
    Endfinally = 0x00DC
    Initblk = 0xFE18
    Initobj = 0xFE15
    Isinst = 0x0075
    Jmp = 0x0027
    Ldarg = 0xFE09
    Ldarg_0 = 0x0002
    Ldarg_1 = 0x0003
    Ldarg_2 = 0x0004
    Ldarg_3 = 0x0005
    Ldarg_S = 0x000E
    Ldarga = 0xFE0A
    Ldarga_S = 0x000F
    Ldc_I4 = 0x0020
    Ldc_I4_0 = 0x0016
    Ldc_I4_1 = 0x0017
    Ldc_I4_2 = 0x0018
    Ldc_I4_3 = 0x0019
    Ldc_I4_4 = 0x001A
    Ldc_I4_5 = 0x001B
    Ldc_I4_6 = 0x001C
    Ldc_I4_7 = 0x001D
    Ldc_I4_8 = 0x001E
    Ldc_I4_M1 = 0x0015
    Ldc_I4_S = 0x001F
    Ldc_I8 = 0x0021
    Ldc_R4 = 0x0022
    Ldc_R8 = 0x0023
    Ldelem = 0x00A3
    Ldelem_I = 0x0097
    Ldelem_I1 = 0x0090
    Ldelem_I2 = 0x0092
    Ldelem_I4 = 0x0094
    Ldelem_I8 = 0x0096
    Ldelem_R4 = 0x0098
    Ldelem_R8 = 0x0099
    Ldelem_Ref = 0x009A
    Ldelem_U1 = 0x0091
    Ldelem_U2 = 0x0093
    Ldelem_U4 = 0x0095
    Ldelema = 0x008F
    Ldfld = 0x007B
    Ldflda = 0x007C
    Ldftn = 0xFE06
    Ldind_I = 0x004D
    Ldind_I1 = 0x0046
    Ldind_I2 = 0x0048
    Ldind_I4 = 0x004A
    Ldind_I8 = 0x004C
    Ldind_R4 = 0x004E
    Ldind_R8 = 0x004F
    Ldind_Ref = 0x0050
    Ldind_U1 = 0x0047
    Ldind_U2 = 0x0049
    Ldind_U4 = 0x004B
    Ldlen = 0x008E
    Ldloc = 0xFE0C
    Ldloc_0 = 0x0006
    Ldloc_1 = 0x0007
    Ldloc_2 = 0x0008
    Ldloc_3 = 0x0009
    Ldloc_S = 0x0011
    Ldloca = 0xFE0D
    Ldloca_S = 0x0012
    Ldnull = 0x0014
    Ldobj = 0x0071
    Ldsfld = 0x007E
    Ldsflda = 0x007F
    Ldstr = 0x0072
    Ldtoken = 0x00D0
    Ldvirtftn = 0xFE07
    Leave = 0x00DD
    Leave_S = 0x00DE
    Localloc = 0xFE0F
    Mkrefany = 0x00C6
    Mul = 0x005A
    Mul_Ovf = 0x00D8
    Mul_Ovf_Un = 0x00D9
    Neg = 0x0065
    Newarr = 0x008D
    Newobj = 0x0073
    No = 0xFE19
    Nop = 0x0000
    Not = 0x0066
    Or = 0x0060
    Pop = 0x0026
    Prefix1 = 0x00FE
    Prefix2 = 0x00FD
    Prefix3 = 0x00FC
    Prefix4 = 0x00FB
    Prefix5 = 0x00FA
    Prefix6 = 0x00F9
    Prefix7 = 0x00F8
    Prefixref = 0x00FF
    Readonly = 0xFE1E
    Refanytype = 0xFE1D
    Refanyval = 0x00C2
    Rem = 0x005D
    Rem_Un = 0x005E
    Ret = 0x002A
    Rethrow = 0xFE1A
    Shl = 0x0062
    Shr = 0x0063
    Shr_Un = 0x0064
    Sizeof = 0xFE1C
    Starg = 0xFE0B
    Starg_S = 0x0010
    Stelem = 0x00A4
    Stelem_I = 0x009B
    Stelem_I1 = 0x009C
    Stelem_I2 = 0x009D
    Stelem_I4 = 0x009E
    Stelem_I8 = 0x009F
    Stelem_R4 = 0x00A0
    Stelem_R8 = 0x00A1
    Stelem_Ref = 0x00A2
    Stfld = 0x007D
    Stind_I = 0x00DF
    Stind_I1 = 0x0052
    Stind_I2 = 0x0053
    Stind_I4 = 0x0054
    Stind_I8 = 0x0055
    Stind_R4 = 0x0056
    Stind_R8 = 0x0057
    Stind_Ref = 0x0051
    Stloc = 0xFE0E
    Stloc_0 = 0x000A
    Stloc_1 = 0x000B
    Stloc_2 = 0x000C
    Stloc_3 = 0x000D
    Stloc_S = 0x0013
    Stobj = 0x0081
    Stsfld = 0x0080
    Sub = 0x0059
    Sub_Ovf = 0x00DA
    Sub_Ovf_Un = 0x00DB
    Switch = 0x0045
    Tailcall = 0xFE14
    Throw = 0x007A
    Unaligned = 0xFE12
    Unbox = 0x0079
    Unbox_Any = 0x00A5
    Volatile = 0xFE13
    Xor = 0x0061


class FlowControl(enum.IntEnum):
    """
    https://github.com/0xd4d/dnlib/blob/master/src/DotNet/Emit/FlowControl.cs
    """

    Branch = 0
    Break = 1
    Call = 2
    Cond_Branch = 3
    Meta = 4
    Next = 5
    Phi = 6
    Return = 7
    Throw = 8


class OpCodeType(enum.IntEnum):
    """
    https://github.com/0xd4d/dnlib/blob/master/src/DotNet/Emit/OpCodeType.cs
    """

    Annotation = 0
    Macro = 1
    Nternal = 2
    Objmodel = 3
    Prefix = 4
    Primitive = 5
    Experimental = 6


class StackBehaviour(enum.IntEnum):
    """
    https://github.com/0xd4d/dnlib/blob/master/src/DotNet/Emit/StackBehaviour.cs
    """

    Pop0 = 0
    Pop1 = 1
    Pop1_pop1 = 2
    Popi = 3
    Popi_pop1 = 4
    Popi_popi = 5
    Popi_popi8 = 6
    Popi_popi_popi = 7
    Popi_popr4 = 8
    Popi_popr8 = 9
    Popref = 10
    Popref_pop1 = 11
    Popref_popi = 12
    Popref_popi_popi = 13
    Popref_popi_popi8 = 14
    Popref_popi_popr4 = 15
    Popref_popi_popr8 = 16
    Popref_popi_popref = 17
    Push0 = 18
    Push1 = 19
    Push1_push1 = 20
    Pushi = 21
    Pushi8 = 22
    Pushr4 = 23
    Pushr8 = 24
    Pushref = 25
    Varpop = 26
    Varpush = 27
    Popref_popi_pop1 = 28

    PopAll = 0xFF


class OperandType(enum.IntEnum):
    """
    https://github.com/0xd4d/dnlib/blob/master/src/DotNet/Emit/OperandType.cs
    """

    InlineBrTarget = 0
    InlineField = 1
    InlineI = 2
    InlineI8 = 3
    InlineMethod = 4
    InlineNone = 5
    InlinePhi = 6
    InlineR = 7
    NOT_USED_8 = 8
    InlineSig = 9
    InlineString = 10
    InlineSwitch = 11
    InlineTok = 12
    InlineType = 13
    InlineVar = 14
    ShortInlineBrTarget = 15
    ShortInlineI = 16
    ShortInlineR = 17
    ShortInlineVar = 18


class ExceptionHandlerType(enum.IntEnum):
    """
    https://github.com/0xd4d/dnlib/blob/master/src/DotNet/Emit/ExceptionHandlerType.cs
    """

    Catch = 0
    Filter = 1
    Finally = 2
    Fault = 4
    Duplicated = 8


class CorILMethod(enum.IntEnum):
    SmallFormat = 0
    TinyFormat = 2  # used if code size is even
    FatFormat = 3
    TinyFormat1 = 6  # used if code size is odd
    FormatMask = (1 << 3) - 1
    MoreSects = 8
    InitLocals = 16
    CompressedIL = 0x40


class CorILMethodSect(enum.IntEnum):
    EHTable = 1
    OptILTable = 2
    KindMask = 0x3F
    FatFormat = 0x40
    MoreSects = 0x80

```

`dncil/cil/error.py`:

```py
# Copyright (C) 2022 Mandiant, Inc. All Rights Reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
# You may obtain a copy of the License at: [package root]/LICENSE.txt
# Unless required by applicable law or agreed to in writing, software distributed under the License
#  is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and limitations under the License.

from __future__ import annotations


class MethodBodyFormatError(Exception):
    """generic method body format exception"""

    def __init__(self, value: str):
        self.value: str = value

    def __str__(self) -> str:
        return repr(self.value)

```

`dncil/cil/exception.py`:

```py
# Copyright (C) 2022 Mandiant, Inc. All Rights Reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
# You may obtain a copy of the License at: [package root]/LICENSE.txt
# Unless required by applicable law or agreed to in writing, software distributed under the License
#  is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and limitations under the License.

from __future__ import annotations

from typing import TYPE_CHECKING, Optional

from dncil.cil.enums import ExceptionHandlerType

if TYPE_CHECKING:
    from dncil.clr.token import Token


class ExceptionHandler:
    """store managed method exception handler"""

    TINY_SIZE = 12
    FAT_SIZE = 24

    def __init__(self, exception_type: int):
        self.exception_type: int = exception_type

        self.try_start: int = -1
        self.try_end: int = -1
        self.filter_start: int = -1
        self.handler_start: int = -1
        self.handler_end: int = -1
        self.catch_type: Optional[Token] = None

    def is_catch(self) -> bool:
        """check if exception handler is catch"""
        return self.exception_type & 7 == ExceptionHandlerType.Catch

    def is_filter(self) -> bool:
        """check if exception handler is filter"""
        return self.exception_type & ExceptionHandlerType.Filter != 0

    def is_finally(self) -> bool:
        """check if exception handler is finally"""
        return self.exception_type & ExceptionHandlerType.Finally != 0

    def is_fault(self) -> bool:
        """check if exception handler is fault"""
        return self.exception_type & ExceptionHandlerType.Fault != 0

```

`dncil/cil/instruction.py`:

```py
# Copyright (C) 2022 Mandiant, Inc. All Rights Reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
# You may obtain a copy of the License at: [package root]/LICENSE.txt
# Unless required by applicable law or agreed to in writing, software distributed under the License
#  is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and limitations under the License.

from __future__ import annotations

from typing import TYPE_CHECKING, Any, Union, Optional, cast

from dncil.cil.enums import OpCodeValue, OperandType

if TYPE_CHECKING:
    from dncil.clr.local import Local
    from dncil.clr.token import Token
    from dncil.cil.opcode import OpCode
    from dncil.clr.argument import Argument


class Instruction:
    """store managed instruction"""

    def __init__(self):
        self.offset: int
        self.opcode: OpCode
        self.opcode_bytes: bytes
        self.operand: Union[Token, Local, Argument, list, int, float, None]
        self.operand_bytes: bytes

    def __str__(self) -> str:
        return (
            "{:04X}".format(self.offset)
            + "    "
            + f"{' '.join('{:02x}'.format(b) for b in self.get_bytes()) : <20}"
            + f"{str(self.opcode) : <15}"
            + (str(self.operand) if self.operand is not None else "")
        )

    def __repr__(self) -> str:
        return str(self)

    def __int__(self) -> int:
        return self.offset

    @property
    def mnemonic(self):
        """get instruction opcode mnemonic"""
        return self.opcode.name

    @property
    def size(self) -> int:
        """get instruction size"""
        opcode: OpCode = self.opcode

        if opcode.operand_type in (
            OperandType.InlineBrTarget,
            OperandType.InlineField,
            OperandType.InlineI,
            OperandType.InlineMethod,
            OperandType.InlineSig,
            OperandType.InlineString,
            OperandType.InlineTok,
            OperandType.InlineType,
            OperandType.ShortInlineR,
        ):
            return opcode.size + 4

        elif opcode.operand_type in (OperandType.InlineI8, OperandType.InlineR):
            return opcode.size + 8
        elif opcode.operand_type in (OperandType.InlineSwitch,):
            targets = cast(list, self.operand)
            return opcode.size + 4 + (len(targets) * 4 if targets else 0)
        elif opcode.operand_type in (OperandType.InlineVar,):
            return opcode.size + 2
        elif opcode.operand_type in (
            OperandType.ShortInlineBrTarget,
            OperandType.ShortInlineI,
            OperandType.ShortInlineVar,
        ):
            return opcode.size + 1
        elif opcode.operand_type in (OperandType.InlineNone, OperandType.InlinePhi):
            return opcode.size
        else:
            return opcode.size

    def get_mnemonic(self) -> str:
        """get instruction mnemonic"""
        return self.mnemonic

    def get_size(self) -> int:
        """get instruction size"""
        return self.size

    def get_opcode_size(self) -> int:
        """get instruction opcode size"""
        return len(self.opcode_bytes)

    def get_operand_size(self) -> int:
        """get instruction operand size"""
        return len(self.operand_bytes)

    def get_bytes(self) -> bytes:
        """get instruction bytes"""
        return self.opcode_bytes + self.operand_bytes

    def get_opcode_bytes(self) -> bytes:
        """get instruction opcode bytes"""
        return self.opcode_bytes

    def get_operand_bytes(self) -> bytes:
        """get instruction operand bytes"""
        return self.operand_bytes

    def is_leave(self) -> bool:
        """check if instruction is leave"""
        return self.opcode.value in (OpCodeValue.Leave, OpCodeValue.Leave_S)

    def is_br(self) -> bool:
        """check if instruction is generic branch"""
        return self.opcode.value in (OpCodeValue.Br, OpCodeValue.Br_S)

    def is_br_false(self) -> bool:
        """check if instruction is branch false"""
        return self.opcode.value in (OpCodeValue.Brfalse, OpCodeValue.Brfalse_S)

    def is_br_true(self) -> bool:
        """check if instruction is branch true"""
        return self.opcode.value in (OpCodeValue.Brtrue, OpCodeValue.Brtrue_S)

    def is_cond_br(self) -> bool:
        """check if instruction is conditional branch"""
        return self.opcode.value in (
            OpCodeValue.Bge,
            OpCodeValue.Bge_S,
            OpCodeValue.Bge_Un,
            OpCodeValue.Bge_Un_S,
            OpCodeValue.Blt,
            OpCodeValue.Blt_S,
            OpCodeValue.Blt_Un,
            OpCodeValue.Blt_Un_S,
            OpCodeValue.Bgt,
            OpCodeValue.Bgt_S,
            OpCodeValue.Bgt_Un,
            OpCodeValue.Bgt_Un_S,
            OpCodeValue.Ble,
            OpCodeValue.Ble_S,
            OpCodeValue.Ble_Un,
            OpCodeValue.Ble_Un_S,
            OpCodeValue.Brfalse,
            OpCodeValue.Brfalse_S,
            OpCodeValue.Brtrue,
            OpCodeValue.Brtrue_S,
            OpCodeValue.Beq,
            OpCodeValue.Beq_S,
            OpCodeValue.Bne_Un,
            OpCodeValue.Bne_Un_S,
        )

    def is_ldstr(self) -> bool:
        """check if instruction is load string"""
        return self.opcode.value in (OpCodeValue.Ldstr,)

    def is_ldc(self) -> bool:
        """check if instruction is load constant"""
        return self.opcode.value in (
            OpCodeValue.Ldc_I4_M1,
            OpCodeValue.Ldc_I4_0,
            OpCodeValue.Ldc_I4_1,
            OpCodeValue.Ldc_I4_2,
            OpCodeValue.Ldc_I4_3,
            OpCodeValue.Ldc_I4_4,
            OpCodeValue.Ldc_I4_5,
            OpCodeValue.Ldc_I4_6,
            OpCodeValue.Ldc_I4_7,
            OpCodeValue.Ldc_I4_8,
            OpCodeValue.Ldc_I4_S,
            OpCodeValue.Ldc_I4,
            OpCodeValue.Ldc_I8,
            OpCodeValue.Ldc_R4,
            OpCodeValue.Ldc_R8,
        )

    def get_ldc(self) -> Union[int, float, None]:
        """get constant for load instruction"""
        if self.opcode.value == OpCodeValue.Ldc_I4_M1:
            return -1
        elif self.opcode.value == OpCodeValue.Ldc_I4_0:
            return 0
        elif self.opcode.value == OpCodeValue.Ldc_I4_1:
            return 1
        elif self.opcode.value == OpCodeValue.Ldc_I4_2:
            return 2
        elif self.opcode.value == OpCodeValue.Ldc_I4_3:
            return 3
        elif self.opcode.value == OpCodeValue.Ldc_I4_4:
            return 4
        elif self.opcode.value == OpCodeValue.Ldc_I4_5:
            return 5
        elif self.opcode.value == OpCodeValue.Ldc_I4_6:
            return 6
        elif self.opcode.value == OpCodeValue.Ldc_I4_7:
            return 7
        elif self.opcode.value == OpCodeValue.Ldc_I4_8:
            return 8
        elif self.opcode.value == OpCodeValue.Ldc_I4_S:
            return cast(int, self.operand)
        elif self.opcode.value == OpCodeValue.Ldc_I4:
            return cast(int, self.operand)
        elif self.opcode.value == OpCodeValue.Ldc_I8:
            return cast(int, self.operand)
        elif self.opcode.value == OpCodeValue.Ldc_R4:
            return cast(float, self.operand)
        elif self.opcode.value == OpCodeValue.Ldc_R8:
            return cast(float, self.operand)
        else:
            return None

    def is_ldarg(self) -> bool:
        """check if instruction is load argument"""
        return self.opcode.value in (
            OpCodeValue.Ldarg,
            OpCodeValue.Ldarg_0,
            OpCodeValue.Ldarg_1,
            OpCodeValue.Ldarg_2,
            OpCodeValue.Ldarg_3,
            OpCodeValue.Ldarg_S,
            OpCodeValue.Ldarga,
            OpCodeValue.Ldarga_S,
        )

    def get_ldarg(self) -> Optional[Argument]:
        """get argument for load instruction"""
        if self.opcode.value in (OpCodeValue.Ldarg, OpCodeValue.Ldarga, OpCodeValue.Ldarg_S, OpCodeValue.Ldarga_S):
            return cast(Argument, self.operand)
        elif self.opcode.value == OpCodeValue.Ldarg_0:
            return Argument(0)
        elif self.opcode.value == OpCodeValue.Ldarg_1:
            return Argument(1)
        elif self.opcode.value == OpCodeValue.Ldarg_2:
            return Argument(2)
        elif self.opcode.value == OpCodeValue.Ldarg_3:
            return Argument(3)
        else:
            return None

    def is_starg(self) -> bool:
        """check if instruction is store argument"""
        return self.opcode.value in (OpCodeValue.Starg, OpCodeValue.Starg_S)

    def get_starg(self) -> Optional[Argument]:
        """get argument for store instruction"""
        if self.opcode.value in (OpCodeValue.Starg, OpCodeValue.Starg_S):
            return cast(Argument, self.operand)
        else:
            return None

    def is_ldloc(self) -> bool:
        """check if instruction is load local"""
        return self.opcode.value in (
            OpCodeValue.Ldloc,
            OpCodeValue.Ldloc_0,
            OpCodeValue.Ldarg_1,
            OpCodeValue.Ldarg_2,
            OpCodeValue.Ldloc_3,
            OpCodeValue.Ldloc_S,
            OpCodeValue.Ldloca,
            OpCodeValue.Ldloca_S,
        )

    def get_ldoc(self) -> Optional[Local]:
        """get local for load instruction"""
        if self.opcode.value in (OpCodeValue.Ldloc, OpCodeValue.Ldloc_S, OpCodeValue.Ldloca, OpCodeValue.Ldloca_S):
            return cast(Local, self.operand)
        elif self.opcode.value == OpCodeValue.Ldloc_0:
            return Local(0)
        elif self.opcode.value == OpCodeValue.Ldloc_1:
            return Local(1)
        elif self.opcode.value == OpCodeValue.Ldloc_2:
            return Local(2)
        elif self.opcode.value == OpCodeValue.Ldloc_3:
            return Local(3)
        else:
            return None

    def is_stloc(self) -> bool:
        """check if instruction is store local"""
        return self.opcode.value in (
            OpCodeValue.Stloc,
            OpCodeValue.Stloc_0,
            OpCodeValue.Stloc_1,
            OpCodeValue.Stloc_2,
            OpCodeValue.Stloc_3,
            OpCodeValue.Stloc_S,
        )

    def get_stloc(self) -> Optional[Local]:
        """get local for store instruction"""
        if self.opcode.value in (OpCodeValue.Stloc, OpCodeValue.Stloc_S):
            return cast(Local, self.operand)
        elif self.opcode.value == OpCodeValue.Stloc_0:
            return Local(0)
        elif self.opcode.value == OpCodeValue.Stloc_1:
            return Local(1)
        elif self.opcode.value == OpCodeValue.Stloc_2:
            return Local(2)
        elif self.opcode.value == OpCodeValue.Stloc_3:
            return Local(3)
        else:
            return None

```

`dncil/cil/opcode.py`:

```py
# Copyright (C) 2022 Mandiant, Inc. All Rights Reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
# You may obtain a copy of the License at: [package root]/LICENSE.txt
# Unless required by applicable law or agreed to in writing, software distributed under the License
#  is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and limitations under the License.

from __future__ import annotations

import inspect
from typing import List

from dncil.cil.enums import *


class OpCode:
    """store managed opcode"""

    def __init__(
        self,
        name: str,
        value: OpCodeValue,
        operand_type: OperandType,
        flow_control: FlowControl,
        op_code_type: OpCodeType,
        stack_push: StackBehaviour,
        stack_pop: StackBehaviour,
    ):
        self.name: str = name
        self.value: OpCodeValue = value
        self.operand_type: OperandType = operand_type
        self.flow_control: FlowControl = flow_control
        self.op_code_type: OpCodeType = op_code_type
        self.stack_push: StackBehaviour = stack_push
        self.stack_pop: StackBehaviour = stack_pop

    @property
    def size(self) -> int:
        """get opcode size"""
        return 1 if self.value < 0x100 or self.value == OpCodeValue.UNKNOWN1 else 2

    def __str__(self) -> str:
        return self.name

    def __repr__(self) -> str:
        return str(self)


class OpCodes:
    """store valid opcodes - see https://github.com/0xd4d/dnlib/blob/master/src/DotNet/Emit/OpCodes.cs"""

    UNKNOWN1 = OpCode(
        "UNKNOWN1",
        OpCodeValue.UNKNOWN1,
        OperandType.InlineNone,
        FlowControl.Meta,
        OpCodeType.Nternal,
        StackBehaviour.Push0,
        StackBehaviour.Pop0,
    )
    UNKNOWN2 = OpCode(
        "UNKNOWN2",
        OpCodeValue.UNKNOWN2,
        OperandType.InlineNone,
        FlowControl.Meta,
        OpCodeType.Nternal,
        StackBehaviour.Push0,
        StackBehaviour.Pop0,
    )
    Nop = OpCode(
        "nop",
        OpCodeValue.Nop,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push0,
        StackBehaviour.Pop0,
    )
    Break = OpCode(
        "break",
        OpCodeValue.Break,
        OperandType.InlineNone,
        FlowControl.Break,
        OpCodeType.Primitive,
        StackBehaviour.Push0,
        StackBehaviour.Pop0,
    )
    Ldarg_0 = OpCode(
        "ldarg.0",
        OpCodeValue.Ldarg_0,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Macro,
        StackBehaviour.Push1,
        StackBehaviour.Pop0,
    )
    Ldarg_1 = OpCode(
        "ldarg.1",
        OpCodeValue.Ldarg_1,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Macro,
        StackBehaviour.Push1,
        StackBehaviour.Pop0,
    )
    Ldarg_2 = OpCode(
        "ldarg.2",
        OpCodeValue.Ldarg_2,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Macro,
        StackBehaviour.Push1,
        StackBehaviour.Pop0,
    )
    Ldarg_3 = OpCode(
        "ldarg.3",
        OpCodeValue.Ldarg_3,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Macro,
        StackBehaviour.Push1,
        StackBehaviour.Pop0,
    )
    Ldloc_0 = OpCode(
        "ldloc.0",
        OpCodeValue.Ldloc_0,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Macro,
        StackBehaviour.Push1,
        StackBehaviour.Pop0,
    )
    Ldloc_1 = OpCode(
        "ldloc.1",
        OpCodeValue.Ldloc_1,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Macro,
        StackBehaviour.Push1,
        StackBehaviour.Pop0,
    )
    Ldloc_2 = OpCode(
        "ldloc.2",
        OpCodeValue.Ldloc_2,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Macro,
        StackBehaviour.Push1,
        StackBehaviour.Pop0,
    )
    Ldloc_3 = OpCode(
        "ldloc.3",
        OpCodeValue.Ldloc_3,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Macro,
        StackBehaviour.Push1,
        StackBehaviour.Pop0,
    )
    Stloc_0 = OpCode(
        "stloc.0",
        OpCodeValue.Stloc_0,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Macro,
        StackBehaviour.Push0,
        StackBehaviour.Pop1,
    )
    Stloc_1 = OpCode(
        "stloc.1",
        OpCodeValue.Stloc_1,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Macro,
        StackBehaviour.Push0,
        StackBehaviour.Pop1,
    )
    Stloc_2 = OpCode(
        "stloc.2",
        OpCodeValue.Stloc_2,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Macro,
        StackBehaviour.Push0,
        StackBehaviour.Pop1,
    )
    Stloc_3 = OpCode(
        "stloc.3",
        OpCodeValue.Stloc_3,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Macro,
        StackBehaviour.Push0,
        StackBehaviour.Pop1,
    )
    Ldarg_S = OpCode(
        "ldarg.s",
        OpCodeValue.Ldarg_S,
        OperandType.ShortInlineVar,
        FlowControl.Next,
        OpCodeType.Macro,
        StackBehaviour.Push1,
        StackBehaviour.Pop0,
    )
    Ldarga_S = OpCode(
        "ldarga.s",
        OpCodeValue.Ldarga_S,
        OperandType.ShortInlineVar,
        FlowControl.Next,
        OpCodeType.Macro,
        StackBehaviour.Pushi,
        StackBehaviour.Pop0,
    )
    Starg_S = OpCode(
        "starg.s",
        OpCodeValue.Starg_S,
        OperandType.ShortInlineVar,
        FlowControl.Next,
        OpCodeType.Macro,
        StackBehaviour.Push0,
        StackBehaviour.Pop1,
    )
    Ldloc_S = OpCode(
        "ldloc.s",
        OpCodeValue.Ldloc_S,
        OperandType.ShortInlineVar,
        FlowControl.Next,
        OpCodeType.Macro,
        StackBehaviour.Push1,
        StackBehaviour.Pop0,
    )
    Ldloca_S = OpCode(
        "ldloca.s",
        OpCodeValue.Ldloca_S,
        OperandType.ShortInlineVar,
        FlowControl.Next,
        OpCodeType.Macro,
        StackBehaviour.Pushi,
        StackBehaviour.Pop0,
    )
    Stloc_S = OpCode(
        "stloc.s",
        OpCodeValue.Stloc_S,
        OperandType.ShortInlineVar,
        FlowControl.Next,
        OpCodeType.Macro,
        StackBehaviour.Push0,
        StackBehaviour.Pop1,
    )
    Ldnull = OpCode(
        "ldnull",
        OpCodeValue.Ldnull,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushref,
        StackBehaviour.Pop0,
    )
    Ldc_I4_M1 = OpCode(
        "ldc.i4.m1",
        OpCodeValue.Ldc_I4_M1,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Macro,
        StackBehaviour.Pushi,
        StackBehaviour.Pop0,
    )
    Ldc_I4_0 = OpCode(
        "ldc.i4.0",
        OpCodeValue.Ldc_I4_0,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Macro,
        StackBehaviour.Pushi,
        StackBehaviour.Pop0,
    )
    Ldc_I4_1 = OpCode(
        "ldc.i4.1",
        OpCodeValue.Ldc_I4_1,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Macro,
        StackBehaviour.Pushi,
        StackBehaviour.Pop0,
    )
    Ldc_I4_2 = OpCode(
        "ldc.i4.2",
        OpCodeValue.Ldc_I4_2,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Macro,
        StackBehaviour.Pushi,
        StackBehaviour.Pop0,
    )
    Ldc_I4_3 = OpCode(
        "ldc.i4.3",
        OpCodeValue.Ldc_I4_3,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Macro,
        StackBehaviour.Pushi,
        StackBehaviour.Pop0,
    )
    Ldc_I4_4 = OpCode(
        "ldc.i4.4",
        OpCodeValue.Ldc_I4_4,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Macro,
        StackBehaviour.Pushi,
        StackBehaviour.Pop0,
    )
    Ldc_I4_5 = OpCode(
        "ldc.i4.5",
        OpCodeValue.Ldc_I4_5,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Macro,
        StackBehaviour.Pushi,
        StackBehaviour.Pop0,
    )
    Ldc_I4_6 = OpCode(
        "ldc.i4.6",
        OpCodeValue.Ldc_I4_6,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Macro,
        StackBehaviour.Pushi,
        StackBehaviour.Pop0,
    )
    Ldc_I4_7 = OpCode(
        "ldc.i4.7",
        OpCodeValue.Ldc_I4_7,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Macro,
        StackBehaviour.Pushi,
        StackBehaviour.Pop0,
    )
    Ldc_I4_8 = OpCode(
        "ldc.i4.8",
        OpCodeValue.Ldc_I4_8,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Macro,
        StackBehaviour.Pushi,
        StackBehaviour.Pop0,
    )
    Ldc_I4_S = OpCode(
        "ldc.i4.s",
        OpCodeValue.Ldc_I4_S,
        OperandType.ShortInlineI,
        FlowControl.Next,
        OpCodeType.Macro,
        StackBehaviour.Pushi,
        StackBehaviour.Pop0,
    )
    Ldc_I4 = OpCode(
        "ldc.i4",
        OpCodeValue.Ldc_I4,
        OperandType.InlineI,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop0,
    )
    Ldc_I8 = OpCode(
        "ldc.i8",
        OpCodeValue.Ldc_I8,
        OperandType.InlineI8,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi8,
        StackBehaviour.Pop0,
    )
    Ldc_R4 = OpCode(
        "ldc.r4",
        OpCodeValue.Ldc_R4,
        OperandType.ShortInlineR,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushr4,
        StackBehaviour.Pop0,
    )
    Ldc_R8 = OpCode(
        "ldc.r8",
        OpCodeValue.Ldc_R8,
        OperandType.InlineR,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushr8,
        StackBehaviour.Pop0,
    )
    Dup = OpCode(
        "dup",
        OpCodeValue.Dup,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push1_push1,
        StackBehaviour.Pop1,
    )
    Pop = OpCode(
        "pop",
        OpCodeValue.Pop,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push0,
        StackBehaviour.Pop1,
    )
    Jmp = OpCode(
        "jmp",
        OpCodeValue.Jmp,
        OperandType.InlineMethod,
        FlowControl.Call,
        OpCodeType.Primitive,
        StackBehaviour.Push0,
        StackBehaviour.Pop0,
    )
    Call = OpCode(
        "call",
        OpCodeValue.Call,
        OperandType.InlineMethod,
        FlowControl.Call,
        OpCodeType.Primitive,
        StackBehaviour.Varpush,
        StackBehaviour.Varpop,
    )
    Calli = OpCode(
        "calli",
        OpCodeValue.Calli,
        OperandType.InlineSig,
        FlowControl.Call,
        OpCodeType.Primitive,
        StackBehaviour.Varpush,
        StackBehaviour.Varpop,
    )
    Ret = OpCode(
        "ret",
        OpCodeValue.Ret,
        OperandType.InlineNone,
        FlowControl.Return,
        OpCodeType.Primitive,
        StackBehaviour.Push0,
        StackBehaviour.Varpop,
    )
    Br_S = OpCode(
        "br.s",
        OpCodeValue.Br_S,
        OperandType.ShortInlineBrTarget,
        FlowControl.Branch,
        OpCodeType.Macro,
        StackBehaviour.Push0,
        StackBehaviour.Pop0,
    )
    Brfalse_S = OpCode(
        "brfalse.s",
        OpCodeValue.Brfalse_S,
        OperandType.ShortInlineBrTarget,
        FlowControl.Cond_Branch,
        OpCodeType.Macro,
        StackBehaviour.Push0,
        StackBehaviour.Popi,
    )
    Brtrue_S = OpCode(
        "brtrue.s",
        OpCodeValue.Brtrue_S,
        OperandType.ShortInlineBrTarget,
        FlowControl.Cond_Branch,
        OpCodeType.Macro,
        StackBehaviour.Push0,
        StackBehaviour.Popi,
    )
    Beq_S = OpCode(
        "beq.s",
        OpCodeValue.Beq_S,
        OperandType.ShortInlineBrTarget,
        FlowControl.Cond_Branch,
        OpCodeType.Macro,
        StackBehaviour.Push0,
        StackBehaviour.Pop1_pop1,
    )
    Bge_S = OpCode(
        "bge.s",
        OpCodeValue.Bge_S,
        OperandType.ShortInlineBrTarget,
        FlowControl.Cond_Branch,
        OpCodeType.Macro,
        StackBehaviour.Push0,
        StackBehaviour.Pop1_pop1,
    )
    Bgt_S = OpCode(
        "bgt.s",
        OpCodeValue.Bgt_S,
        OperandType.ShortInlineBrTarget,
        FlowControl.Cond_Branch,
        OpCodeType.Macro,
        StackBehaviour.Push0,
        StackBehaviour.Pop1_pop1,
    )
    Ble_S = OpCode(
        "ble.s",
        OpCodeValue.Ble_S,
        OperandType.ShortInlineBrTarget,
        FlowControl.Cond_Branch,
        OpCodeType.Macro,
        StackBehaviour.Push0,
        StackBehaviour.Pop1_pop1,
    )
    Blt_S = OpCode(
        "blt.s",
        OpCodeValue.Blt_S,
        OperandType.ShortInlineBrTarget,
        FlowControl.Cond_Branch,
        OpCodeType.Macro,
        StackBehaviour.Push0,
        StackBehaviour.Pop1_pop1,
    )
    Bne_Un_S = OpCode(
        "bne.un.s",
        OpCodeValue.Bne_Un_S,
        OperandType.ShortInlineBrTarget,
        FlowControl.Cond_Branch,
        OpCodeType.Macro,
        StackBehaviour.Push0,
        StackBehaviour.Pop1_pop1,
    )
    Bge_Un_S = OpCode(
        "bge.un.s",
        OpCodeValue.Bge_Un_S,
        OperandType.ShortInlineBrTarget,
        FlowControl.Cond_Branch,
        OpCodeType.Macro,
        StackBehaviour.Push0,
        StackBehaviour.Pop1_pop1,
    )
    Bgt_Un_S = OpCode(
        "bgt.un.s",
        OpCodeValue.Bgt_Un_S,
        OperandType.ShortInlineBrTarget,
        FlowControl.Cond_Branch,
        OpCodeType.Macro,
        StackBehaviour.Push0,
        StackBehaviour.Pop1_pop1,
    )
    Ble_Un_S = OpCode(
        "ble.un.s",
        OpCodeValue.Ble_Un_S,
        OperandType.ShortInlineBrTarget,
        FlowControl.Cond_Branch,
        OpCodeType.Macro,
        StackBehaviour.Push0,
        StackBehaviour.Pop1_pop1,
    )
    Blt_Un_S = OpCode(
        "blt.un.s",
        OpCodeValue.Blt_Un_S,
        OperandType.ShortInlineBrTarget,
        FlowControl.Cond_Branch,
        OpCodeType.Macro,
        StackBehaviour.Push0,
        StackBehaviour.Pop1_pop1,
    )
    Br = OpCode(
        "br",
        OpCodeValue.Br,
        OperandType.InlineBrTarget,
        FlowControl.Branch,
        OpCodeType.Primitive,
        StackBehaviour.Push0,
        StackBehaviour.Pop0,
    )
    Brfalse = OpCode(
        "brfalse",
        OpCodeValue.Brfalse,
        OperandType.InlineBrTarget,
        FlowControl.Cond_Branch,
        OpCodeType.Primitive,
        StackBehaviour.Push0,
        StackBehaviour.Popi,
    )
    Brtrue = OpCode(
        "brtrue",
        OpCodeValue.Brtrue,
        OperandType.InlineBrTarget,
        FlowControl.Cond_Branch,
        OpCodeType.Primitive,
        StackBehaviour.Push0,
        StackBehaviour.Popi,
    )
    Beq = OpCode(
        "beq",
        OpCodeValue.Beq,
        OperandType.InlineBrTarget,
        FlowControl.Cond_Branch,
        OpCodeType.Macro,
        StackBehaviour.Push0,
        StackBehaviour.Pop1_pop1,
    )
    Bge = OpCode(
        "bge",
        OpCodeValue.Bge,
        OperandType.InlineBrTarget,
        FlowControl.Cond_Branch,
        OpCodeType.Macro,
        StackBehaviour.Push0,
        StackBehaviour.Pop1_pop1,
    )
    Bgt = OpCode(
        "bgt",
        OpCodeValue.Bgt,
        OperandType.InlineBrTarget,
        FlowControl.Cond_Branch,
        OpCodeType.Macro,
        StackBehaviour.Push0,
        StackBehaviour.Pop1_pop1,
    )
    Ble = OpCode(
        "ble",
        OpCodeValue.Ble,
        OperandType.InlineBrTarget,
        FlowControl.Cond_Branch,
        OpCodeType.Macro,
        StackBehaviour.Push0,
        StackBehaviour.Pop1_pop1,
    )
    Blt = OpCode(
        "blt",
        OpCodeValue.Blt,
        OperandType.InlineBrTarget,
        FlowControl.Cond_Branch,
        OpCodeType.Macro,
        StackBehaviour.Push0,
        StackBehaviour.Pop1_pop1,
    )
    Bne_Un = OpCode(
        "bne.un",
        OpCodeValue.Bne_Un,
        OperandType.InlineBrTarget,
        FlowControl.Cond_Branch,
        OpCodeType.Macro,
        StackBehaviour.Push0,
        StackBehaviour.Pop1_pop1,
    )
    Bge_Un = OpCode(
        "bge.un",
        OpCodeValue.Bge_Un,
        OperandType.InlineBrTarget,
        FlowControl.Cond_Branch,
        OpCodeType.Macro,
        StackBehaviour.Push0,
        StackBehaviour.Pop1_pop1,
    )
    Bgt_Un = OpCode(
        "bgt.un",
        OpCodeValue.Bgt_Un,
        OperandType.InlineBrTarget,
        FlowControl.Cond_Branch,
        OpCodeType.Macro,
        StackBehaviour.Push0,
        StackBehaviour.Pop1_pop1,
    )
    Ble_Un = OpCode(
        "ble.un",
        OpCodeValue.Ble_Un,
        OperandType.InlineBrTarget,
        FlowControl.Cond_Branch,
        OpCodeType.Macro,
        StackBehaviour.Push0,
        StackBehaviour.Pop1_pop1,
    )
    Blt_Un = OpCode(
        "blt.un",
        OpCodeValue.Blt_Un,
        OperandType.InlineBrTarget,
        FlowControl.Cond_Branch,
        OpCodeType.Macro,
        StackBehaviour.Push0,
        StackBehaviour.Pop1_pop1,
    )
    Switch = OpCode(
        "switch",
        OpCodeValue.Switch,
        OperandType.InlineSwitch,
        FlowControl.Cond_Branch,
        OpCodeType.Primitive,
        StackBehaviour.Push0,
        StackBehaviour.Popi,
    )
    Ldind_I1 = OpCode(
        "ldind.i1",
        OpCodeValue.Ldind_I1,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Popi,
    )
    Ldind_U1 = OpCode(
        "ldind.u1",
        OpCodeValue.Ldind_U1,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Popi,
    )
    Ldind_I2 = OpCode(
        "ldind.i2",
        OpCodeValue.Ldind_I2,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Popi,
    )
    Ldind_U2 = OpCode(
        "ldind.u2",
        OpCodeValue.Ldind_U2,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Popi,
    )
    Ldind_I4 = OpCode(
        "ldind.i4",
        OpCodeValue.Ldind_I4,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Popi,
    )
    Ldind_U4 = OpCode(
        "ldind.u4",
        OpCodeValue.Ldind_U4,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Popi,
    )
    Ldind_I8 = OpCode(
        "ldind.i8",
        OpCodeValue.Ldind_I8,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi8,
        StackBehaviour.Popi,
    )
    Ldind_I = OpCode(
        "ldind.i",
        OpCodeValue.Ldind_I,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Popi,
    )
    Ldind_R4 = OpCode(
        "ldind.r4",
        OpCodeValue.Ldind_R4,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushr4,
        StackBehaviour.Popi,
    )
    Ldind_R8 = OpCode(
        "ldind.r8",
        OpCodeValue.Ldind_R8,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushr8,
        StackBehaviour.Popi,
    )
    Ldind_Ref = OpCode(
        "ldind.ref",
        OpCodeValue.Ldind_Ref,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushref,
        StackBehaviour.Popi,
    )
    Stind_Ref = OpCode(
        "stind.ref",
        OpCodeValue.Stind_Ref,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push0,
        StackBehaviour.Popi_popi,
    )
    Stind_I1 = OpCode(
        "stind.i1",
        OpCodeValue.Stind_I1,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push0,
        StackBehaviour.Popi_popi,
    )
    Stind_I2 = OpCode(
        "stind.i2",
        OpCodeValue.Stind_I2,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push0,
        StackBehaviour.Popi_popi,
    )
    Stind_I4 = OpCode(
        "stind.i4",
        OpCodeValue.Stind_I4,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push0,
        StackBehaviour.Popi_popi,
    )
    Stind_I8 = OpCode(
        "stind.i8",
        OpCodeValue.Stind_I8,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push0,
        StackBehaviour.Popi_popi8,
    )
    Stind_R4 = OpCode(
        "stind.r4",
        OpCodeValue.Stind_R4,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push0,
        StackBehaviour.Popi_popr4,
    )
    Stind_R8 = OpCode(
        "stind.r8",
        OpCodeValue.Stind_R8,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push0,
        StackBehaviour.Popi_popr8,
    )
    Add = OpCode(
        "add",
        OpCodeValue.Add,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push1,
        StackBehaviour.Pop1_pop1,
    )
    Sub = OpCode(
        "sub",
        OpCodeValue.Sub,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push1,
        StackBehaviour.Pop1_pop1,
    )
    Mul = OpCode(
        "mul",
        OpCodeValue.Mul,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push1,
        StackBehaviour.Pop1_pop1,
    )
    Div = OpCode(
        "div",
        OpCodeValue.Div,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push1,
        StackBehaviour.Pop1_pop1,
    )
    Div_Un = OpCode(
        "div.un",
        OpCodeValue.Div_Un,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push1,
        StackBehaviour.Pop1_pop1,
    )
    Rem = OpCode(
        "rem",
        OpCodeValue.Rem,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push1,
        StackBehaviour.Pop1_pop1,
    )
    Rem_Un = OpCode(
        "rem.un",
        OpCodeValue.Rem_Un,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push1,
        StackBehaviour.Pop1_pop1,
    )
    And = OpCode(
        "and",
        OpCodeValue.And,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push1,
        StackBehaviour.Pop1_pop1,
    )
    Or = OpCode(
        "or",
        OpCodeValue.Or,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push1,
        StackBehaviour.Pop1_pop1,
    )
    Xor = OpCode(
        "xor",
        OpCodeValue.Xor,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push1,
        StackBehaviour.Pop1_pop1,
    )
    Shl = OpCode(
        "shl",
        OpCodeValue.Shl,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push1,
        StackBehaviour.Pop1_pop1,
    )
    Shr = OpCode(
        "shr",
        OpCodeValue.Shr,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push1,
        StackBehaviour.Pop1_pop1,
    )
    Shr_Un = OpCode(
        "shr.un",
        OpCodeValue.Shr_Un,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push1,
        StackBehaviour.Pop1_pop1,
    )
    Neg = OpCode(
        "neg",
        OpCodeValue.Neg,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push1,
        StackBehaviour.Pop1,
    )
    Not = OpCode(
        "not",
        OpCodeValue.Not,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push1,
        StackBehaviour.Pop1,
    )
    Conv_I1 = OpCode(
        "conv.i1",
        OpCodeValue.Conv_I1,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop1,
    )
    Conv_I2 = OpCode(
        "conv.i2",
        OpCodeValue.Conv_I2,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop1,
    )
    Conv_I4 = OpCode(
        "conv.i4",
        OpCodeValue.Conv_I4,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop1,
    )
    Conv_I8 = OpCode(
        "conv.i8",
        OpCodeValue.Conv_I8,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi8,
        StackBehaviour.Pop1,
    )
    Conv_R4 = OpCode(
        "conv.r4",
        OpCodeValue.Conv_R4,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushr4,
        StackBehaviour.Pop1,
    )
    Conv_R8 = OpCode(
        "conv.r8",
        OpCodeValue.Conv_R8,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushr8,
        StackBehaviour.Pop1,
    )
    Conv_U4 = OpCode(
        "conv.u4",
        OpCodeValue.Conv_U4,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop1,
    )
    Conv_U8 = OpCode(
        "conv.u8",
        OpCodeValue.Conv_U8,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi8,
        StackBehaviour.Pop1,
    )
    Callvirt = OpCode(
        "callvirt",
        OpCodeValue.Callvirt,
        OperandType.InlineMethod,
        FlowControl.Call,
        OpCodeType.Objmodel,
        StackBehaviour.Varpush,
        StackBehaviour.Varpop,
    )
    Cpobj = OpCode(
        "cpobj",
        OpCodeValue.Cpobj,
        OperandType.InlineType,
        FlowControl.Next,
        OpCodeType.Objmodel,
        StackBehaviour.Push0,
        StackBehaviour.Popi_popi,
    )
    Ldobj = OpCode(
        "ldobj",
        OpCodeValue.Ldobj,
        OperandType.InlineType,
        FlowControl.Next,
        OpCodeType.Objmodel,
        StackBehaviour.Push1,
        StackBehaviour.Popi,
    )
    Ldstr = OpCode(
        "ldstr",
        OpCodeValue.Ldstr,
        OperandType.InlineString,
        FlowControl.Next,
        OpCodeType.Objmodel,
        StackBehaviour.Pushref,
        StackBehaviour.Pop0,
    )
    Newobj = OpCode(
        "newobj",
        OpCodeValue.Newobj,
        OperandType.InlineMethod,
        FlowControl.Call,
        OpCodeType.Objmodel,
        StackBehaviour.Pushref,
        StackBehaviour.Varpop,
    )
    Castclass = OpCode(
        "castclass",
        OpCodeValue.Castclass,
        OperandType.InlineType,
        FlowControl.Next,
        OpCodeType.Objmodel,
        StackBehaviour.Pushref,
        StackBehaviour.Popref,
    )
    Isinst = OpCode(
        "isinst",
        OpCodeValue.Isinst,
        OperandType.InlineType,
        FlowControl.Next,
        OpCodeType.Objmodel,
        StackBehaviour.Pushi,
        StackBehaviour.Popref,
    )
    Conv_R_Un = OpCode(
        "conv.r.un",
        OpCodeValue.Conv_R_Un,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushr8,
        StackBehaviour.Pop1,
    )
    Unbox = OpCode(
        "unbox",
        OpCodeValue.Unbox,
        OperandType.InlineType,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Popref,
    )
    Throw = OpCode(
        "throw",
        OpCodeValue.Throw,
        OperandType.InlineNone,
        FlowControl.Throw,
        OpCodeType.Objmodel,
        StackBehaviour.Push0,
        StackBehaviour.Popref,
    )
    Ldfld = OpCode(
        "ldfld",
        OpCodeValue.Ldfld,
        OperandType.InlineField,
        FlowControl.Next,
        OpCodeType.Objmodel,
        StackBehaviour.Push1,
        StackBehaviour.Popref,
    )
    Ldflda = OpCode(
        "ldflda",
        OpCodeValue.Ldflda,
        OperandType.InlineField,
        FlowControl.Next,
        OpCodeType.Objmodel,
        StackBehaviour.Pushi,
        StackBehaviour.Popref,
    )
    Stfld = OpCode(
        "stfld",
        OpCodeValue.Stfld,
        OperandType.InlineField,
        FlowControl.Next,
        OpCodeType.Objmodel,
        StackBehaviour.Push0,
        StackBehaviour.Popref_pop1,
    )
    Ldsfld = OpCode(
        "ldsfld",
        OpCodeValue.Ldsfld,
        OperandType.InlineField,
        FlowControl.Next,
        OpCodeType.Objmodel,
        StackBehaviour.Push1,
        StackBehaviour.Pop0,
    )
    Ldsflda = OpCode(
        "ldsflda",
        OpCodeValue.Ldsflda,
        OperandType.InlineField,
        FlowControl.Next,
        OpCodeType.Objmodel,
        StackBehaviour.Pushi,
        StackBehaviour.Pop0,
    )
    Stsfld = OpCode(
        "stsfld",
        OpCodeValue.Stsfld,
        OperandType.InlineField,
        FlowControl.Next,
        OpCodeType.Objmodel,
        StackBehaviour.Push0,
        StackBehaviour.Pop1,
    )
    Stobj = OpCode(
        "stobj",
        OpCodeValue.Stobj,
        OperandType.InlineType,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push0,
        StackBehaviour.Popi_pop1,
    )
    Conv_Ovf_I1_Un = OpCode(
        "conv.ovf.i1.un",
        OpCodeValue.Conv_Ovf_I1_Un,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop1,
    )
    Conv_Ovf_I2_Un = OpCode(
        "conv.ovf.i2.un",
        OpCodeValue.Conv_Ovf_I2_Un,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop1,
    )
    Conv_Ovf_I4_Un = OpCode(
        "conv.ovf.i4.un",
        OpCodeValue.Conv_Ovf_I4_Un,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop1,
    )
    Conv_Ovf_I8_Un = OpCode(
        "conv.ovf.i8.un",
        OpCodeValue.Conv_Ovf_I8_Un,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi8,
        StackBehaviour.Pop1,
    )
    Conv_Ovf_U1_Un = OpCode(
        "conv.ovf.u1.un",
        OpCodeValue.Conv_Ovf_U1_Un,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop1,
    )
    Conv_Ovf_U2_Un = OpCode(
        "conv.ovf.u2.un",
        OpCodeValue.Conv_Ovf_U2_Un,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop1,
    )
    Conv_Ovf_U4_Un = OpCode(
        "conv.ovf.u4.un",
        OpCodeValue.Conv_Ovf_U4_Un,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop1,
    )
    Conv_Ovf_U8_Un = OpCode(
        "conv.ovf.u8.un",
        OpCodeValue.Conv_Ovf_U8_Un,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi8,
        StackBehaviour.Pop1,
    )
    Conv_Ovf_I_Un = OpCode(
        "conv.ovf.i.un",
        OpCodeValue.Conv_Ovf_I_Un,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop1,
    )
    Conv_Ovf_U_Un = OpCode(
        "conv.ovf.u.un",
        OpCodeValue.Conv_Ovf_U_Un,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop1,
    )
    Box = OpCode(
        "box",
        OpCodeValue.Box,
        OperandType.InlineType,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushref,
        StackBehaviour.Pop1,
    )
    Newarr = OpCode(
        "newarr",
        OpCodeValue.Newarr,
        OperandType.InlineType,
        FlowControl.Next,
        OpCodeType.Objmodel,
        StackBehaviour.Pushref,
        StackBehaviour.Popi,
    )
    Ldlen = OpCode(
        "ldlen",
        OpCodeValue.Ldlen,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Objmodel,
        StackBehaviour.Pushi,
        StackBehaviour.Popref,
    )
    Ldelema = OpCode(
        "ldelema",
        OpCodeValue.Ldelema,
        OperandType.InlineType,
        FlowControl.Next,
        OpCodeType.Objmodel,
        StackBehaviour.Pushi,
        StackBehaviour.Popref_popi,
    )
    Ldelem_I1 = OpCode(
        "ldelem.i1",
        OpCodeValue.Ldelem_I1,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Objmodel,
        StackBehaviour.Pushi,
        StackBehaviour.Popref_popi,
    )
    Ldelem_U1 = OpCode(
        "ldelem.u1",
        OpCodeValue.Ldelem_U1,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Objmodel,
        StackBehaviour.Pushi,
        StackBehaviour.Popref_popi,
    )
    Ldelem_I2 = OpCode(
        "ldelem.i2",
        OpCodeValue.Ldelem_I2,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Objmodel,
        StackBehaviour.Pushi,
        StackBehaviour.Popref_popi,
    )
    Ldelem_U2 = OpCode(
        "ldelem.u2",
        OpCodeValue.Ldelem_U2,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Objmodel,
        StackBehaviour.Pushi,
        StackBehaviour.Popref_popi,
    )
    Ldelem_I4 = OpCode(
        "ldelem.i4",
        OpCodeValue.Ldelem_I4,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Objmodel,
        StackBehaviour.Pushi,
        StackBehaviour.Popref_popi,
    )
    Ldelem_U4 = OpCode(
        "ldelem.u4",
        OpCodeValue.Ldelem_U4,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Objmodel,
        StackBehaviour.Pushi,
        StackBehaviour.Popref_popi,
    )
    Ldelem_I8 = OpCode(
        "ldelem.i8",
        OpCodeValue.Ldelem_I8,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Objmodel,
        StackBehaviour.Pushi8,
        StackBehaviour.Popref_popi,
    )
    Ldelem_I = OpCode(
        "ldelem.i",
        OpCodeValue.Ldelem_I,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Objmodel,
        StackBehaviour.Pushi,
        StackBehaviour.Popref_popi,
    )
    Ldelem_R4 = OpCode(
        "ldelem.r4",
        OpCodeValue.Ldelem_R4,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Objmodel,
        StackBehaviour.Pushr4,
        StackBehaviour.Popref_popi,
    )
    Ldelem_R8 = OpCode(
        "ldelem.r8",
        OpCodeValue.Ldelem_R8,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Objmodel,
        StackBehaviour.Pushr8,
        StackBehaviour.Popref_popi,
    )
    Ldelem_Ref = OpCode(
        "ldelem.ref",
        OpCodeValue.Ldelem_Ref,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Objmodel,
        StackBehaviour.Pushref,
        StackBehaviour.Popref_popi,
    )
    Stelem_I = OpCode(
        "stelem.i",
        OpCodeValue.Stelem_I,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Objmodel,
        StackBehaviour.Push0,
        StackBehaviour.Popref_popi_popi,
    )
    Stelem_I1 = OpCode(
        "stelem.i1",
        OpCodeValue.Stelem_I1,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Objmodel,
        StackBehaviour.Push0,
        StackBehaviour.Popref_popi_popi,
    )
    Stelem_I2 = OpCode(
        "stelem.i2",
        OpCodeValue.Stelem_I2,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Objmodel,
        StackBehaviour.Push0,
        StackBehaviour.Popref_popi_popi,
    )
    Stelem_I4 = OpCode(
        "stelem.i4",
        OpCodeValue.Stelem_I4,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Objmodel,
        StackBehaviour.Push0,
        StackBehaviour.Popref_popi_popi,
    )
    Stelem_I8 = OpCode(
        "stelem.i8",
        OpCodeValue.Stelem_I8,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Objmodel,
        StackBehaviour.Push0,
        StackBehaviour.Popref_popi_popi8,
    )
    Stelem_R4 = OpCode(
        "stelem.r4",
        OpCodeValue.Stelem_R4,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Objmodel,
        StackBehaviour.Push0,
        StackBehaviour.Popref_popi_popr4,
    )
    Stelem_R8 = OpCode(
        "stelem.r8",
        OpCodeValue.Stelem_R8,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Objmodel,
        StackBehaviour.Push0,
        StackBehaviour.Popref_popi_popr8,
    )
    Stelem_Ref = OpCode(
        "stelem.ref",
        OpCodeValue.Stelem_Ref,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Objmodel,
        StackBehaviour.Push0,
        StackBehaviour.Popref_popi_popref,
    )
    Ldelem = OpCode(
        "ldelem",
        OpCodeValue.Ldelem,
        OperandType.InlineType,
        FlowControl.Next,
        OpCodeType.Objmodel,
        StackBehaviour.Push1,
        StackBehaviour.Popref_popi,
    )
    Stelem = OpCode(
        "stelem",
        OpCodeValue.Stelem,
        OperandType.InlineType,
        FlowControl.Next,
        OpCodeType.Objmodel,
        StackBehaviour.Push0,
        StackBehaviour.Popref_popi_pop1,
    )
    Unbox_Any = OpCode(
        "unbox.any",
        OpCodeValue.Unbox_Any,
        OperandType.InlineType,
        FlowControl.Next,
        OpCodeType.Objmodel,
        StackBehaviour.Push1,
        StackBehaviour.Popref,
    )
    Conv_Ovf_I1 = OpCode(
        "conv.ovf.i1",
        OpCodeValue.Conv_Ovf_I1,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop1,
    )
    Conv_Ovf_U1 = OpCode(
        "conv.ovf.u1",
        OpCodeValue.Conv_Ovf_U1,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop1,
    )
    Conv_Ovf_I2 = OpCode(
        "conv.ovf.i2",
        OpCodeValue.Conv_Ovf_I2,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop1,
    )
    Conv_Ovf_U2 = OpCode(
        "conv.ovf.u2",
        OpCodeValue.Conv_Ovf_U2,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop1,
    )
    Conv_Ovf_I4 = OpCode(
        "conv.ovf.i4",
        OpCodeValue.Conv_Ovf_I4,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop1,
    )
    Conv_Ovf_U4 = OpCode(
        "conv.ovf.u4",
        OpCodeValue.Conv_Ovf_U4,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop1,
    )
    Conv_Ovf_I8 = OpCode(
        "conv.ovf.i8",
        OpCodeValue.Conv_Ovf_I8,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi8,
        StackBehaviour.Pop1,
    )
    Conv_Ovf_U8 = OpCode(
        "conv.ovf.u8",
        OpCodeValue.Conv_Ovf_U8,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi8,
        StackBehaviour.Pop1,
    )
    Refanyval = OpCode(
        "refanyval",
        OpCodeValue.Refanyval,
        OperandType.InlineType,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop1,
    )
    Ckfinite = OpCode(
        "ckfinite",
        OpCodeValue.Ckfinite,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushr8,
        StackBehaviour.Pop1,
    )
    Mkrefany = OpCode(
        "mkrefany",
        OpCodeValue.Mkrefany,
        OperandType.InlineType,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push1,
        StackBehaviour.Popi,
    )
    Ldtoken = OpCode(
        "ldtoken",
        OpCodeValue.Ldtoken,
        OperandType.InlineTok,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop0,
    )
    Conv_U2 = OpCode(
        "conv.u2",
        OpCodeValue.Conv_U2,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop1,
    )
    Conv_U1 = OpCode(
        "conv.u1",
        OpCodeValue.Conv_U1,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop1,
    )
    Conv_I = OpCode(
        "conv.i",
        OpCodeValue.Conv_I,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop1,
    )
    Conv_Ovf_I = OpCode(
        "conv.ovf.i",
        OpCodeValue.Conv_Ovf_I,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop1,
    )
    Conv_Ovf_U = OpCode(
        "conv.ovf.u",
        OpCodeValue.Conv_Ovf_U,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop1,
    )
    Add_Ovf = OpCode(
        "add.ovf",
        OpCodeValue.Add_Ovf,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push1,
        StackBehaviour.Pop1_pop1,
    )
    Add_Ovf_Un = OpCode(
        "add.ovf.un",
        OpCodeValue.Add_Ovf_Un,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push1,
        StackBehaviour.Pop1_pop1,
    )
    Mul_Ovf = OpCode(
        "mul.ovf",
        OpCodeValue.Mul_Ovf,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push1,
        StackBehaviour.Pop1_pop1,
    )
    Mul_Ovf_Un = OpCode(
        "mul.ovf.un",
        OpCodeValue.Mul_Ovf_Un,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push1,
        StackBehaviour.Pop1_pop1,
    )
    Sub_Ovf = OpCode(
        "sub.ovf",
        OpCodeValue.Sub_Ovf,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push1,
        StackBehaviour.Pop1_pop1,
    )
    Sub_Ovf_Un = OpCode(
        "sub.ovf.un",
        OpCodeValue.Sub_Ovf_Un,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push1,
        StackBehaviour.Pop1_pop1,
    )
    Endfinally = OpCode(
        "endfinally",
        OpCodeValue.Endfinally,
        OperandType.InlineNone,
        FlowControl.Return,
        OpCodeType.Primitive,
        StackBehaviour.Push0,
        StackBehaviour.PopAll,
    )
    Leave = OpCode(
        "leave",
        OpCodeValue.Leave,
        OperandType.InlineBrTarget,
        FlowControl.Branch,
        OpCodeType.Primitive,
        StackBehaviour.Push0,
        StackBehaviour.PopAll,
    )
    Leave_S = OpCode(
        "leave.s",
        OpCodeValue.Leave_S,
        OperandType.ShortInlineBrTarget,
        FlowControl.Branch,
        OpCodeType.Primitive,
        StackBehaviour.Push0,
        StackBehaviour.PopAll,
    )
    Stind_I = OpCode(
        "stind.i",
        OpCodeValue.Stind_I,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push0,
        StackBehaviour.Popi_popi,
    )
    Conv_U = OpCode(
        "conv.u",
        OpCodeValue.Conv_U,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop1,
    )
    Prefix7 = OpCode(
        "prefix7",
        OpCodeValue.Prefix7,
        OperandType.InlineNone,
        FlowControl.Meta,
        OpCodeType.Nternal,
        StackBehaviour.Push0,
        StackBehaviour.Pop0,
    )
    Prefix6 = OpCode(
        "prefix6",
        OpCodeValue.Prefix6,
        OperandType.InlineNone,
        FlowControl.Meta,
        OpCodeType.Nternal,
        StackBehaviour.Push0,
        StackBehaviour.Pop0,
    )
    Prefix5 = OpCode(
        "prefix5",
        OpCodeValue.Prefix5,
        OperandType.InlineNone,
        FlowControl.Meta,
        OpCodeType.Nternal,
        StackBehaviour.Push0,
        StackBehaviour.Pop0,
    )
    Prefix4 = OpCode(
        "prefix4",
        OpCodeValue.Prefix4,
        OperandType.InlineNone,
        FlowControl.Meta,
        OpCodeType.Nternal,
        StackBehaviour.Push0,
        StackBehaviour.Pop0,
    )
    Prefix3 = OpCode(
        "prefix3",
        OpCodeValue.Prefix3,
        OperandType.InlineNone,
        FlowControl.Meta,
        OpCodeType.Nternal,
        StackBehaviour.Push0,
        StackBehaviour.Pop0,
    )
    Prefix2 = OpCode(
        "prefix2",
        OpCodeValue.Prefix2,
        OperandType.InlineNone,
        FlowControl.Meta,
        OpCodeType.Nternal,
        StackBehaviour.Push0,
        StackBehaviour.Pop0,
    )
    Prefix1 = OpCode(
        "prefix1",
        OpCodeValue.Prefix1,
        OperandType.InlineNone,
        FlowControl.Meta,
        OpCodeType.Nternal,
        StackBehaviour.Push0,
        StackBehaviour.Pop0,
    )
    Prefixref = OpCode(
        "prefixref",
        OpCodeValue.Prefixref,
        OperandType.InlineNone,
        FlowControl.Meta,
        OpCodeType.Nternal,
        StackBehaviour.Push0,
        StackBehaviour.Pop0,
    )
    Arglist = OpCode(
        "arglist",
        OpCodeValue.Arglist,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop0,
    )
    Ceq = OpCode(
        "ceq",
        OpCodeValue.Ceq,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop1_pop1,
    )
    Cgt = OpCode(
        "cgt",
        OpCodeValue.Cgt,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop1_pop1,
    )
    Cgt_Un = OpCode(
        "cgt.un",
        OpCodeValue.Cgt_Un,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop1_pop1,
    )
    Clt = OpCode(
        "clt",
        OpCodeValue.Clt,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop1_pop1,
    )
    Clt_Un = OpCode(
        "clt.un",
        OpCodeValue.Clt_Un,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop1_pop1,
    )
    Ldftn = OpCode(
        "ldftn",
        OpCodeValue.Ldftn,
        OperandType.InlineMethod,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop0,
    )
    Ldvirtftn = OpCode(
        "ldvirtftn",
        OpCodeValue.Ldvirtftn,
        OperandType.InlineMethod,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Popref,
    )
    Ldarg = OpCode(
        "ldarg",
        OpCodeValue.Ldarg,
        OperandType.InlineVar,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push1,
        StackBehaviour.Pop0,
    )
    Ldarga = OpCode(
        "ldarga",
        OpCodeValue.Ldarga,
        OperandType.InlineVar,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop0,
    )
    Starg = OpCode(
        "starg",
        OpCodeValue.Starg,
        OperandType.InlineVar,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push0,
        StackBehaviour.Pop1,
    )
    Ldloc = OpCode(
        "ldloc",
        OpCodeValue.Ldloc,
        OperandType.InlineVar,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push1,
        StackBehaviour.Pop0,
    )
    Ldloca = OpCode(
        "ldloca",
        OpCodeValue.Ldloca,
        OperandType.InlineVar,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop0,
    )
    Stloc = OpCode(
        "stloc",
        OpCodeValue.Stloc,
        OperandType.InlineVar,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push0,
        StackBehaviour.Pop1,
    )
    Localloc = OpCode(
        "localloc",
        OpCodeValue.Localloc,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Popi,
    )
    Endfilter = OpCode(
        "endfilter",
        OpCodeValue.Endfilter,
        OperandType.InlineNone,
        FlowControl.Return,
        OpCodeType.Primitive,
        StackBehaviour.Push0,
        StackBehaviour.Popi,
    )
    Unaligned = OpCode(
        "unaligned.",
        OpCodeValue.Unaligned,
        OperandType.ShortInlineI,
        FlowControl.Meta,
        OpCodeType.Prefix,
        StackBehaviour.Push0,
        StackBehaviour.Pop0,
    )
    Volatile = OpCode(
        "volatile.",
        OpCodeValue.Volatile,
        OperandType.InlineNone,
        FlowControl.Meta,
        OpCodeType.Prefix,
        StackBehaviour.Push0,
        StackBehaviour.Pop0,
    )
    Tailcall = OpCode(
        "tail.",
        OpCodeValue.Tailcall,
        OperandType.InlineNone,
        FlowControl.Meta,
        OpCodeType.Prefix,
        StackBehaviour.Push0,
        StackBehaviour.Pop0,
    )
    Initobj = OpCode(
        "initobj",
        OpCodeValue.Initobj,
        OperandType.InlineType,
        FlowControl.Next,
        OpCodeType.Objmodel,
        StackBehaviour.Push0,
        StackBehaviour.Popi,
    )
    Constrained = OpCode(
        "constrained.",
        OpCodeValue.Constrained,
        OperandType.InlineType,
        FlowControl.Meta,
        OpCodeType.Prefix,
        StackBehaviour.Push0,
        StackBehaviour.Pop0,
    )
    Cpblk = OpCode(
        "cpblk",
        OpCodeValue.Cpblk,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push0,
        StackBehaviour.Popi_popi_popi,
    )
    Initblk = OpCode(
        "initblk",
        OpCodeValue.Initblk,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Push0,
        StackBehaviour.Popi_popi_popi,
    )
    No = OpCode(
        "no.",
        OpCodeValue.No,
        OperandType.ShortInlineI,
        FlowControl.Meta,
        OpCodeType.Prefix,
        StackBehaviour.Push0,
        StackBehaviour.Pop0,
    )
    Rethrow = OpCode(
        "rethrow",
        OpCodeValue.Rethrow,
        OperandType.InlineNone,
        FlowControl.Throw,
        OpCodeType.Objmodel,
        StackBehaviour.Push0,
        StackBehaviour.Pop0,
    )
    Sizeof = OpCode(
        "sizeof",
        OpCodeValue.Sizeof,
        OperandType.InlineType,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop0,
    )
    Refanytype = OpCode(
        "refanytype",
        OpCodeValue.Refanytype,
        OperandType.InlineNone,
        FlowControl.Next,
        OpCodeType.Primitive,
        StackBehaviour.Pushi,
        StackBehaviour.Pop1,
    )
    Readonly = OpCode(
        "readonly.",
        OpCodeValue.Readonly,
        OperandType.InlineNone,
        FlowControl.Meta,
        OpCodeType.Prefix,
        StackBehaviour.Push0,
        StackBehaviour.Pop0,
    )

    def __init__(self):
        # group opcodes by size; used to parse instructions later
        self.one_byte_op_codes: List[OpCode] = [OpCodes.UNKNOWN1] * 0x100
        self.two_byte_op_codes: List[OpCode] = [OpCodes.UNKNOWN2] * 0x100

        for (_, opcode) in inspect.getmembers(OpCodes, lambda o: isinstance(o, OpCode)):
            if opcode.value >> 8 == 0:
                self.one_byte_op_codes[opcode.value] = opcode
            elif opcode.value >> 8 == 0xFE:
                self.two_byte_op_codes[opcode.value & 0xFF] = opcode

```

`dncil/clr/argument.py`:

```py
# Copyright (C) 2022 Mandiant, Inc. All Rights Reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
# You may obtain a copy of the License at: [package root]/LICENSE.txt
# Unless required by applicable law or agreed to in writing, software distributed under the License
#  is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and limitations under the License.

from __future__ import annotations


class Argument:
    """store managed method argument"""

    def __init__(self, index: int):
        self.index: int = index

    def __str__(self) -> str:
        return "argument(0x%04X)" % self.index

    def __repr__(self) -> str:
        return str(self)

```

`dncil/clr/local.py`:

```py
# Copyright (C) 2022 Mandiant, Inc. All Rights Reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
# You may obtain a copy of the License at: [package root]/LICENSE.txt
# Unless required by applicable law or agreed to in writing, software distributed under the License
#  is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and limitations under the License.

from __future__ import annotations


class Local:
    """store managed method local"""

    def __init__(self, index: int):
        self.index: int = index

    def __str__(self) -> str:
        return "local(0x%04X)" % self.index

    def __repr__(self) -> str:
        return str(self)

```

`dncil/clr/token.py`:

```py
# Copyright (C) 2022 Mandiant, Inc. All Rights Reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
# You may obtain a copy of the License at: [package root]/LICENSE.txt
# Unless required by applicable law or agreed to in writing, software distributed under the License
#  is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and limitations under the License.


class Token(object):
    """store managed token"""

    RID_MASK = 0x00FFFFFF
    RID_MAX = RID_MASK
    TABLE_SHIFT = 24

    def __init__(self, value):
        self.value = value

    @property
    def rid(self):
        """get token row index"""
        return self.value & Token.RID_MASK

    @property
    def table(self):
        """get token table index"""
        return self.value >> Token.TABLE_SHIFT

    def __str__(self):
        return "token(0x%08X)" % self.value

    def __repr__(self):
        return str(self)


class InvalidToken(Token):
    """store invalid managed token"""

    def __init__(self, value):
        super(InvalidToken, self).__init__(value)

    def __str__(self):
        return "invalid token(0x%08X)" % self.value


class StringToken(Token):
    """store string managed token"""

    def __init__(self, value):
        super(StringToken, self).__init__(value)

    def __str__(self):
        return "string token(0x%08X)" % self.value

```

`dncil/version.py`:

```py
__version__ = "1.0.0"

```

`scripts/print_cil_from_bytes.py`:

```py
# Copyright (C) 2022 Mandiant, Inc. All Rights Reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
# You may obtain a copy of the License at: [package root]/LICENSE.txt
# Unless required by applicable law or agreed to in writing, software distributed under the License
#  is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and limitations under the License.

import argparse

from dncil.cil.body import reader
from dncil.cil.error import MethodBodyFormatError


def main(args):
    with open(args.path, "rb") as f_in:
        dn = f_in.read()

    try:
        dn_body = reader.read_method_body_from_bytes(dn)
    except MethodBodyFormatError as e:
        print(e)
        return

    for insn in dn_body.instructions:
        print(insn)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(prog="Print IL from the raw bytes of a managed method")
    parser.add_argument("path", type=str, help="Full path to file containing raw bytes of managed method")

    main(parser.parse_args())

```

`scripts/print_cil_from_dn_file.py`:

```py
# Copyright (C) 2022 Mandiant, Inc. All Rights Reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
# You may obtain a copy of the License at: [package root]/LICENSE.txt
# Unless required by applicable law or agreed to in writing, software distributed under the License
#  is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and limitations under the License.
from __future__ import annotations

from typing import TYPE_CHECKING, Any, Union

if TYPE_CHECKING:
    from dnfile import dnPE
    from dnfile.mdtable import MethodDefRow

import argparse

import dnfile
from dnfile.enums import MetadataTables

from dncil.cil.body import CilMethodBody
from dncil.cil.error import MethodBodyFormatError
from dncil.clr.token import Token, StringToken, InvalidToken
from dncil.cil.body.reader import CilMethodBodyReaderBase

# key token indexes to dotnet meta tables
DOTNET_META_TABLES_BY_INDEX = {table.value: table.name for table in MetadataTables}


class DnfileMethodBodyReader(CilMethodBodyReaderBase):
    def __init__(self, pe: dnPE, row: MethodDefRow):
        """ """
        self.pe: dnPE = pe
        self.offset: int = self.pe.get_offset_from_rva(row.Rva)

    def read(self, n: int) -> bytes:
        """ """
        data: bytes = self.pe.get_data(self.pe.get_rva_from_offset(self.offset), n)
        self.offset += n
        return data

    def tell(self) -> int:
        """ """
        return self.offset

    def seek(self, offset: int) -> int:
        """ """
        self.offset = offset
        return self.offset


def resolve_token(pe: dnPE, token: Token) -> Any:
    """ """
    if isinstance(token, StringToken):
        return pe.net.user_strings.get_us(token.rid).value

    table_name: str = DOTNET_META_TABLES_BY_INDEX.get(token.table, "")
    if not table_name:
        # table_index is not valid
        return InvalidToken(token.value)

    table: Any = getattr(pe.net.mdtables, table_name, None)
    if table is None:
        # table index is valid but table is not present
        return InvalidToken(token.value)

    try:
        return table.rows[token.rid - 1]
    except IndexError:
        # table index is valid but row index is not valid
        return InvalidToken(token.value)


def read_method_body(pe: dnPE, row: MethodDefRow) -> CilMethodBody:
    """ """
    return CilMethodBody(DnfileMethodBodyReader(pe, row))


def format_operand(pe: dnPE, operand: Any) -> str:
    """ """
    if isinstance(operand, Token):
        operand = resolve_token(pe, operand)

    if isinstance(operand, str):
        return f'"{operand}"'
    elif isinstance(operand, int):
        return hex(operand)
    elif isinstance(operand, list):
        return f"[{', '.join(['({:04X})'.format(x) for x in operand])}]"
    elif isinstance(operand, dnfile.mdtable.MemberRefRow):
        if isinstance(operand.Class.row, (dnfile.mdtable.TypeRefRow,)):
            return f"{str(operand.Class.row.TypeNamespace)}.{operand.Class.row.TypeName}::{operand.Name}"
    elif isinstance(operand, dnfile.mdtable.TypeRefRow):
        return f"{str(operand.TypeNamespace)}.{operand.TypeName}"
    elif isinstance(operand, (dnfile.mdtable.FieldRow, dnfile.mdtable.MethodDefRow)):
        return f"{operand.Name}"
    elif operand is None:
        return ""

    return str(operand)


def main(args):
    """ """
    pe: dnPE = dnfile.dnPE(args.path)

    for row in pe.net.mdtables.MethodDef:
        if not row.ImplFlags.miIL or any((row.Flags.mdAbstract, row.Flags.mdPinvokeImpl)):
            # skip methods that do not have a method body
            continue

        try:
            body: CilMethodBody = read_method_body(pe, row)
        except MethodBodyFormatError as e:
            print(e)
            continue

        if not body.instructions:
            continue

        print(f"\nMethod: {row.Name}")
        for insn in body.instructions:
            print(
                "{:04X}".format(insn.offset)
                + "    "
                + f"{' '.join('{:02x}'.format(b) for b in insn.get_bytes()) : <20}"
                + f"{str(insn.opcode) : <15}"
                + format_operand(pe, insn.operand)
            )


if __name__ == "__main__":
    parser = argparse.ArgumentParser(prog="Print IL from the managed methods of a .NET binary")
    parser.add_argument("path", type=str, help="Full path to .NET binary")

    main(parser.parse_args())

```

`setup.cfg`:

```cfg
[pycodestyle]
max-line-length = 120
statistics = True
```

`setup.py`:

```py
# Copyright (C) 2022 Mandiant, Inc. All Rights Reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
# You may obtain a copy of the License at: [package root]/LICENSE.txt
# Unless required by applicable law or agreed to in writing, software distributed under the License
#  is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and limitations under the License.

import os

import setuptools

requirements = []

# this sets __version__
# via: http://stackoverflow.com/a/7071358/87207
# and: http://stackoverflow.com/a/2073599/87207
with open(os.path.join("dncil", "version.py"), "r") as f:
    exec(f.read())


# via: https://packaging.python.org/guides/making-a-pypi-friendly-readme/
this_directory = os.path.abspath(os.path.dirname(__file__))
with open(os.path.join(this_directory, "README.md"), "r") as f:
    long_description = f.read()


setuptools.setup(
    name="dncil",
    version=__version__,
    description="The FLARE team's open-source library to disassemble Common Intermediate Language (CIL) instructions.",
    long_description=long_description,
    long_description_content_type="text/markdown",
    author="Mike Hunhoff",
    author_email="michael.hunhoff@mandiant.com",
    packages=setuptools.find_packages(exclude=["tests"]),
    package_dir={"dncil": "dncil"},
    include_package_data=True,
    install_requires=requirements,
    extras_require={
        "dev": [
            "pytest==7.1.1",
            "pytest-sugar==0.9.4",
            "pytest-instafail==0.4.2",
            "pytest-cov==3.0.0",
            "pycodestyle==2.8.0",
            "black==22.3.0",
            "isort==5.10.1",
            "mypy==0.942",
            "dnfile==0.10.0",
            "hexdump==3.3.0",
        ],
    },
    zip_safe=False,
    python_requires=">=3.7",
)

```

`tests/fixtures.py`:

```py
# Copyright (C) 2022 Mandiant, Inc. All Rights Reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
# You may obtain a copy of the License at: [package root]/LICENSE.txt
# Unless required by applicable law or agreed to in writing, software distributed under the License
#  is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and limitations under the License.

from pathlib import Path

CD = Path(__file__).parent
DATA = CD / "data"


def get_data_path_by_name(name):
    if name == "hello-world.exe":
        return DATA / "hello-world" / "hello-world.exe"

    raise ValueError("unknown test file")

```

`tests/test_method_body.py`:

```py
# Copyright (C) 2022 Mandiant, Inc. All Rights Reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
# You may obtain a copy of the License at: [package root]/LICENSE.txt
# Unless required by applicable law or agreed to in writing, software distributed under the License
#  is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and limitations under the License.

import binascii

import pytest

from dncil.cil.body import CilMethodBody
from dncil.cil.enums import CorILMethod, OpCodeValue
from dncil.cil.error import MethodBodyFormatError
from dncil.clr.token import Token
from dncil.cil.body.reader import CilMethodBodyReaderBytes

"""
.method private hidebysig static
    void Main (
        string[] args
    ) cil managed
{
    // Header Size: 12 bytes
    // Code Size: 37 (0x25) bytes
    .maxstack 1
    .entrypoint

    .try
    {
        .try
        {
            /* 0x0000025C 7201000070   */ IL_0000: ldstr     "Hello World!"
            /* 0x00000261 280B00000A   */ IL_0005: call      void [System.Console]System.Console::WriteLine(string)
            /* 0x00000266 DE18         */ IL_000A: leave.s   IL_0024
        } // end .try
        catch [System.Runtime]System.Exception
        {
            /* 0x00000268 26           */ IL_000C: pop
            /* 0x00000269 721B000070   */ IL_000D: ldstr     "Exception occurred."
            /* 0x0000026E 280B00000A   */ IL_0012: call      void [System.Console]System.Console::WriteLine(string)
            /* 0x00000273 DE0B         */ IL_0017: leave.s   IL_0024
        } // end handler
    } // end .try
    finally
    {
        /* 0x00000275 7243000070   */ IL_0019: ldstr     "Finally occurred."
        /* 0x0000027A 280B00000A   */ IL_001E: call      void [System.Console]System.Console::WriteLine(string)
        /* 0x0000027F DC           */ IL_0023: endfinally
    } // end handler

    /* 0x00000280 2A           */ IL_0024: ret
} // end of method Program::Main
"""
method_body_fat = binascii.unhexlify(
    "1B30010025000000000000007201000070280B00000ADE1826721B000070280B00000ADE0B7243000070280B00000ADC2A000000011C0000000000000C0C000D0D000001020000001919000B00000000"
)

"""
.method public hidebysig specialname rtspecialname
    instance void .ctor () cil managed
{
    // Header Size: 1 byte
    // Code Size: 7 (0x7) bytes
    .maxstack 8

    /* 0x000002A1 02           */ IL_0000: ldarg.0
    /* 0x000002A2 280C00000A   */ IL_0001: call      instance void [System.Runtime]System.Object::.ctor()
    /* 0x000002A7 2A           */ IL_0006: ret
} // end of method Program::.ctor
"""
method_body_tiny = binascii.unhexlify("1E02280C00000A2A")


def test_invalid_header_format():
    reader = CilMethodBodyReaderBytes(b"\x00")

    with pytest.raises(MethodBodyFormatError):
        _ = CilMethodBody(reader)


def test_empty_method_body():
    reader = CilMethodBodyReaderBytes(b"")

    with pytest.raises(MethodBodyFormatError):
        _ = CilMethodBody(reader)


def test_read_tiny_header():
    reader = CilMethodBodyReaderBytes(method_body_tiny)
    body = CilMethodBody(reader)

    assert body.header_size == 0x1
    assert body.flags.TinyFormat1
    assert not body.flags.TinyFormat
    assert not body.flags.SmallFormat
    assert not body.flags.MoreSects
    assert not body.flags.FatFormat
    assert body.flags.is_tiny()
    assert body.flags.value == CorILMethod.TinyFormat1
    assert body.max_stack == 0x8
    assert body.local_var_sig_tok is None
    assert body.code_size == 0x7
    assert body.size == len(method_body_tiny)
    assert body.header_size + body.code_size == body.size
    assert body.header_size + body.code_size + body.exception_handlers_size == body.size
    assert body.get_bytes() == method_body_tiny
    assert (
        body.get_header_bytes() + body.get_instruction_bytes() + body.get_exception_handler_bytes() == method_body_tiny
    )


def test_read_tiny_header_instructions():
    reader = CilMethodBodyReaderBytes(method_body_tiny)
    body = CilMethodBody(reader)

    assert len(body.instructions) == 0x3
    assert body.instructions[0].offset == 0x1
    assert body.instructions[0].opcode.value == OpCodeValue.Ldarg_0
    assert isinstance(body.instructions[1].operand, Token)
    assert body.instructions[1].operand.table == 0xA
    assert body.instructions[1].operand.rid == 0xC
    assert body.instructions[1].get_bytes() == b"\x28\x0C\x00\x00\x0A"
    assert (
        body.instructions[1].get_opcode_bytes() + body.instructions[1].get_operand_bytes()
        == body.instructions[1].get_bytes()
    )
    assert body.instructions[2].offset == 0x7
    assert body.instructions[2].opcode.value == OpCodeValue.Ret


def test_read_fat_header():
    reader = CilMethodBodyReaderBytes(method_body_fat)
    body = CilMethodBody(reader)

    assert body.flags.FatFormat
    assert body.flags.MoreSects
    assert body.flags.InitLocals
    assert body.flags.is_fat()
    assert body.header_size == 0xC
    assert body.max_stack == 0x1
    assert body.code_size == 0x25
    assert body.size == len(method_body_fat)
    assert body.header_size + body.code_size <= body.size
    assert body.header_size + body.code_size + body.exception_handlers_size == body.size
    assert body.get_bytes() == method_body_fat
    assert (
        body.get_header_bytes() + body.get_instruction_bytes() + body.get_exception_handler_bytes() == method_body_fat
    )


def test_read_fat_header_instructions():
    reader = CilMethodBodyReaderBytes(method_body_fat)
    body = CilMethodBody(reader)

    assert len(body.instructions) == 0xB
    assert body.instructions[0].offset == body.offset + body.header_size
    assert body.instructions[0].opcode.value == OpCodeValue.Ldstr
    assert body.instructions[0].mnemonic == "ldstr"
    assert isinstance(body.instructions[1].operand, Token)
    assert body.instructions[1].operand.table == 0xA
    assert body.instructions[1].operand.rid == 0xB
    assert body.instructions[1].get_bytes() == b"\x28\x0B\x00\x00\x0A"
    assert (
        body.instructions[1].get_opcode_bytes() + body.instructions[1].get_operand_bytes()
        == body.instructions[1].get_bytes()
    )
    assert body.instructions[1].size == len(body.instructions[1].get_bytes())
    assert body.instructions[1].get_opcode_size() + body.instructions[1].get_operand_size() == body.instructions[1].size
    assert body.instructions[9].offset == 0x2F
    assert body.instructions[9].opcode.value == OpCodeValue.Endfinally


def test_read_fat_header_exception_handlers():
    reader = CilMethodBodyReaderBytes(method_body_fat)
    body = CilMethodBody(reader)

    assert len(body.exception_handlers) == 0x2
    assert body.exception_handlers[0].try_start == 0x0
    assert body.exception_handlers[0].try_end == 0xC
    assert body.exception_handlers[0].handler_start == 0xC
    assert body.exception_handlers[0].handler_end == 0x19
    assert isinstance(body.exception_handlers[0].catch_type, Token)
    assert body.exception_handlers[1].is_finally()

```

`tests/test_token.py`:

```py
# Copyright (C) 2022 Mandiant, Inc. All Rights Reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
# You may obtain a copy of the License at: [package root]/LICENSE.txt
# Unless required by applicable law or agreed to in writing, software distributed under the License
#  is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and limitations under the License.

from dncil.clr.token import Token


def test_token_fields():
    token = Token(0x06000001)

    assert isinstance(token, Token)
    assert token.table == 0x6
    assert token.rid == 0x1

```