Project Path: arc_gmh5225_memmap_c5al7250

Source Tree:

```txt
arc_gmh5225_memmap_c5al7250
├── README.md
├── comm.cpp
├── comm.h
├── hijack.cpp
├── hijack.h
├── map.cpp
└── map.h

```

`README.md`:

```md
# Credits
- N1gger
- wdk
- kgb

# Read before making an "issue"
You need a little bit of knowledge to implement this in your program's source code
It's not even that difficult, that's why we do not reply to issues usually
Maybe a GitHub member will answer for you

# Standard Usage
	INT argc;
	LPCSTR* argv;

	/* ----------- Variables ---------- */
	LPCSTR process = "gamehere.exe"; //the process thing
	LPCSTR module = "d3d11.dll";

	if (!Comm::Setup()) {
		return 1;
	}
	Comm::Process process(StrToWStr(process));
	if (!process.Valid()) {
		printf("game not found!"); //if process defined not found then return 1 cuz its an error xd
		return 1;
	}

	auto entry = Map::ExtendMap(process, StrToWStr(module)); //expands the module like dxgi.dll which was loaded with the driver
	if (!entry) {
		return 1;
	}

	if (!Hijack::HijackViaHook(process, entry, L"user32.dll", "PeekMessageW")) {
		return 1;
	}

	return 0;

```

`comm.cpp`:

```cpp
#include "../Misc/stdafx.h"
#include <iostream>
PVOID(NTAPI* NtConvertBetweenAuxiliaryCounterAndPerformanceCounter)(PVOID, PVOID, PVOID, PVOID);

namespace Comm {
	BOOL Setup() {
		auto module = LoadLibrary(L"ntdll.dll");
		if (!module) {
			errorf("Failed to get a handle for NTDLL\n");
			return FALSE;
		}

		*reinterpret_cast<PVOID*>(&NtConvertBetweenAuxiliaryCounterAndPerformanceCounter) = GetProcAddress(module, "NtConvertBetweenAuxiliaryCounterAndPerformanceCounter");
		if (!NtConvertBetweenAuxiliaryCounterAndPerformanceCounter) {
			errorf("Failed to find \"NtConvertBetweenAuxiliaryCounterAndPerformanceCounter\"\n");
			return FALSE;
		}

		return TRUE;
	}

	NTSTATUS SendRequest(REQUEST_TYPE type, PVOID args, SIZE_T argsSize) {
		REQUEST_DATA request = { 0 };
		request.Unique = DATA_UNIQUE;
		request.Type = type;
		request.Arguments = args;

		auto requestPtr = &request;

		auto status = 0ULL;
		NtConvertBetweenAuxiliaryCounterAndPerformanceCounter(0, &requestPtr, &status, 0);
		return static_cast<NTSTATUS>(status);
	}

	Process::Process(LPCWSTR processName) {
		auto snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
		if (snapshot == INVALID_HANDLE_VALUE) {
			return;
		}

		PROCESSENTRY32 entry = { 0 };
		entry.dwSize = sizeof(entry);
		if (Process32First(snapshot, &entry)) {
			do {
				if (_wcsicmp(entry.szExeFile, processName) == 0) {
					this->ProcessId = entry.th32ProcessID;
					break;
				}
			} while (Process32Next(snapshot, &entry));
		}

		CloseHandle(snapshot);
	}

	BOOLEAN Process::Valid() {
		return this->ProcessId != 0;
	}

	NTSTATUS Process::Extend(LPCWSTR moduleName, DWORD size) {
		REQUEST_EXTEND req = { 0 };
		req.ProcessId = this->ProcessId;
		req.Size = size;
		wcscpy_s(req.Module, sizeof(req.Module) / sizeof(req.Module[0]), moduleName);

		return SendRequest(REQUEST_TYPE::EXTEND, &req, sizeof(req));
	}

	NTSTATUS Process::Write(PVOID dest, PVOID src, DWORD size) {
		REQUEST_WRITE req = { 0 };
		req.ProcessId = this->ProcessId;
		req.Dest = dest;
		req.Src = src;
		req.Size = size;

		return SendRequest(REQUEST_TYPE::WRITE, &req, sizeof(req));
	}

	NTSTATUS Process::Read(PVOID dest, PVOID src, DWORD size) {
		REQUEST_READ req = { 0 };
		req.ProcessId = this->ProcessId;
		req.Dest = dest;
		req.Src = src;
		req.Size = size;

		return SendRequest(REQUEST_TYPE::READ, &req, sizeof(req));
	}

	NTSTATUS Process::Protect(PVOID address, DWORD size, PDWORD inOutProtect) {
		REQUEST_PROTECT req = { 0 };
		req.ProcessId = this->ProcessId;
		req.Address = address;
		req.Size = size;
		req.InOutProtect = inOutProtect;

		return SendRequest(REQUEST_TYPE::PROTECT, &req, sizeof(req));
	}

	PVOID Process::Alloc(DWORD size, DWORD protect) {
		PVOID outAddress = NULL;

		REQUEST_ALLOC req = { 0 };
		req.ProcessId = this->ProcessId;
		req.OutAddress = &outAddress;
		req.Size = size;
		req.Protect = protect;

		SendRequest(REQUEST_TYPE::ALLOC, &req, sizeof(req));

		return outAddress;
	}

	NTSTATUS Process::Free(PVOID address) {
		REQUEST_FREE req = { 0 };
		req.ProcessId = this->ProcessId;
		req.Address = address;

		return SendRequest(REQUEST_TYPE::FREE, &req, sizeof(req));
	}

	NTSTATUS Process::Module(LPCWSTR moduleName, PBYTE* base, PDWORD size) {
		REQUEST_MODULE req = { 0 };
		req.ProcessId = this->ProcessId;
		req.OutAddress = base;
		req.OutSize = size;
		wcscpy_s(req.Module, sizeof(req.Module) / sizeof(req.Module[0]), moduleName);

		return SendRequest(REQUEST_TYPE::MODULE, &req, sizeof(req));
	}
}
```

`comm.h`:

```h
#pragma once

namespace Comm {
	const auto DATA_UNIQUE = 0x1234UL;

	enum class REQUEST_TYPE {
		EXTEND,
		WRITE,
		READ,
		PROTECT,
		ALLOC,
		FREE,
		MODULE,
	};

	typedef struct _REQUEST_DATA {
		DWORD Unique;
		REQUEST_TYPE Type;
		PVOID Arguments;
	} REQUEST_DATA, * PREQUEST_DATA;

	typedef struct _REQUEST_EXTEND {
		DWORD ProcessId;
		WCHAR Module[0xFF];
		DWORD Size;
	} REQUEST_EXTEND, * PREQUEST_EXTEND;

	typedef struct _REQUEST_WRITE {
		DWORD ProcessId;
		PVOID Dest;
		PVOID Src;
		DWORD Size;
	} REQUEST_WRITE, * PREQUEST_WRITE;

	typedef struct _REQUEST_READ {
		DWORD ProcessId;
		PVOID Dest;
		PVOID Src;
		DWORD Size;
	} REQUEST_READ, * PREQUEST_READ;

	typedef struct _REQUEST_PROTECT {
		DWORD ProcessId;
		PVOID Address;
		DWORD Size;
		PDWORD InOutProtect;
	} REQUEST_PROTECT, * PREQUEST_PROTECT;

	typedef struct _REQUEST_ALLOC {
		DWORD ProcessId;
		PVOID OutAddress;
		DWORD Size;
		DWORD Protect;
	} REQUEST_ALLOC, * PREQUEST_ALLOC;

	typedef struct _REQUEST_FREE {
		DWORD ProcessId;
		PVOID Address;
	} REQUEST_FREE, * PREQUEST_FREE;

	typedef struct _REQUEST_MODULE {
		DWORD ProcessId;
		WCHAR Module[0xFF];
		PBYTE* OutAddress;
		PDWORD OutSize;
	} REQUEST_MODULE, * PREQUEST_MODULE;

	BOOL Setup();

	class Process {
	private:
		DWORD ProcessId = 0;

	public:
		Process(DWORD processId) : ProcessId{ processId } {}
		Process(LPCWSTR processName);

		BOOLEAN Valid();
		NTSTATUS Extend(LPCWSTR module, DWORD size);
		NTSTATUS Write(PVOID dest, PVOID src, DWORD size);
		NTSTATUS Read(PVOID dest, PVOID src, DWORD size);
		NTSTATUS Protect(PVOID address, DWORD size, PDWORD inOutProtect);
		PVOID Alloc(DWORD size, DWORD protect);
		NTSTATUS Free(PVOID address);
		NTSTATUS Module(LPCWSTR moduleName, PBYTE* base, PDWORD size);
	};
}
```

`hijack.cpp`:

```cpp
#include "../Misc/stdafx.h"

namespace Hijack {
	BOOLEAN HijackViaHook(Comm::Process& process, PVOID entry, LPCWSTR moduleName, LPCSTR functionName) {
		//printf("\n[-] hijacking execution via hook\n");
		Beep(742, 500);
		printf("\n[!!] Injecting Please stand by!\n");

		PBYTE remoteModuleBase = NULL;
		DWORD remoteModuleSize = 0;
		if (process.Module(moduleName, &remoteModuleBase, &remoteModuleSize) != ERROR_SUCCESS) {
			errorf("failed to find module %ws in process\n", moduleName);
			return FALSE;
		}

		auto module = LoadLibrary(moduleName);
		if (!module) {
			errorf("failed to load module %ws\n", moduleName);
			return FALSE;
		}

		auto function = reinterpret_cast<PBYTE>(GetProcAddress(module, functionName));
		if (!function) {
			errorf("failed to find function %ws:%s\n", moduleName, functionName);
			return FALSE;
		}

		auto remoteFunction = remoteModuleBase + (function - reinterpret_cast<PBYTE>(module));

		BYTE shellcode[] = { 0x00, 0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xBA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x89, 0x10, 0x48, 0xBA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x89, 0x50, 0x08, 0x48, 0x83, 0xEC, 0x28, 0x48, 0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x02, 0x00, 0x00, 0x00, 0xEB, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x28, 0x48, 0x31, 0xC0, 0xC6, 0x05, 0xAE, 0xFF, 0xFF, 0xFF, 0x01, 0xC3 };
		*reinterpret_cast<PVOID*>(&shellcode[3]) = remoteFunction;
		process.Read(&shellcode[13], remoteFunction, sizeof(ULONG64));
		process.Read(&shellcode[26], remoteFunction + sizeof(ULONG64), sizeof(ULONG64));
		*reinterpret_cast<PVOID*>(&shellcode[60]) = entry;

		auto mappedShellcode = reinterpret_cast<PBYTE>(process.Alloc(sizeof(shellcode), PAGE_EXECUTE_READWRITE));
		if (!mappedShellcode) {
			errorf("failed to allocate virtual memory for hook hijack shellcode\n");
			return FALSE;
		}

		process.Write(mappedShellcode, shellcode, sizeof(shellcode));

		BYTE jump[14] = { 0xFF, 0x25, 0x00, 0x00, 0x00, 0x00 };
		*reinterpret_cast<PVOID*>(&jump[6]) = mappedShellcode + 1;

		DWORD protect = PAGE_EXECUTE_READWRITE;
		process.Protect(remoteFunction, 2 * sizeof(ULONG64), &protect);

		process.Write(remoteFunction, jump, sizeof(jump));

		//printf("[+] waiting for shellcode to execute...\n");
		for (auto functionBytes = 0ULL;; Sleep(1)) {
			if (process.Read(&functionBytes, remoteFunction + 6, sizeof(functionBytes)) != ERROR_SUCCESS) {
				errorf("failed to read function bytes at %p\n", remoteFunction + 6);
				return FALSE;
			}

			if (functionBytes != *reinterpret_cast<PULONG64>(&jump[6])) {
				break;
			}
		}

		process.Protect(remoteFunction, sizeof(jump), &protect);

		for (BYTE status = 0;; Sleep(1)) {
			if (process.Read(&status, mappedShellcode, sizeof(status)) != ERROR_SUCCESS) {
				errorf("failed to read shellcode status at %p\n", mappedShellcode);
				return FALSE;
			}

			if (status) {
				break;
			}
		}

		process.Free(mappedShellcode);

		//printf("[+] Exucuted\n");
		printf("[+] Injected\n");
		Beep(666, 666);
		Sleep(1000);
		return TRUE;
	}
}
```

`hijack.h`:

```h
#pragma once

namespace Hijack {
	BOOLEAN HijackViaHook(Comm::Process& process, PVOID entry, LPCWSTR moduleName, LPCSTR functionName);
}
```

`map.cpp`:

```cpp
#include "../Misc/stdafx.h"
#include "../Main/main.h"
#include "../Print/print.h"
#include "../DLL/DLL.h"

namespace Map {
	PIMAGE_SECTION_HEADER TranslateRawSection(PIMAGE_NT_HEADERS nt, DWORD rva) {
		auto section = IMAGE_FIRST_SECTION(nt);
		for (auto i = 0; i < nt->FileHeader.NumberOfSections; ++i, ++section) {
			if (rva >= section->VirtualAddress && rva < section->VirtualAddress + section->Misc.VirtualSize) {
				return section;
			}
		}

		return NULL;
	}

	PVOID TranslateRaw(PBYTE base, PIMAGE_NT_HEADERS nt, DWORD rva) {
		auto section = TranslateRawSection(nt, rva);
		if (!section) {
			return NULL;
		}

		return base + section->PointerToRawData + (rva - section->VirtualAddress);
	}

	BOOLEAN ResolveImports(Comm::Process& process, PBYTE base, PIMAGE_NT_HEADERS nt) {
		auto rva = nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
		if (!rva) {
			return TRUE;
		}

		auto importDescriptor = reinterpret_cast<PIMAGE_IMPORT_DESCRIPTOR>(TranslateRaw(base, nt, rva));
		if (!importDescriptor) {
			return TRUE;
		}

		for (; importDescriptor->FirstThunk; ++importDescriptor) {
			auto moduleName = reinterpret_cast<PCHAR>(TranslateRaw(base, nt, importDescriptor->Name));
			if (!moduleName) {
				break;
			}

			auto module = LoadLibraryA(moduleName);
			if (!module) {
				errorf("failed to load module: %s\n", moduleName);
				return FALSE;
			}

			PBYTE processModuleBase = NULL;
			DWORD processModuleSize = 0;
			if (process.Module(StrToWStr(moduleName), &processModuleBase, &processModuleSize) != ERROR_SUCCESS) {
				errorf("target process does not have %s loaded\n", moduleName);
				return FALSE;
			}

			for (auto thunk = reinterpret_cast<PIMAGE_THUNK_DATA>(TranslateRaw(base, nt, importDescriptor->FirstThunk)); thunk->u1.AddressOfData; ++thunk) {
				auto importByName = reinterpret_cast<PIMAGE_IMPORT_BY_NAME>(TranslateRaw(base, nt, static_cast<DWORD>(thunk->u1.AddressOfData)));
				thunk->u1.Function = reinterpret_cast<UINT_PTR>(processModuleBase + (reinterpret_cast<PBYTE>(GetProcAddress(module, importByName->Name)) - reinterpret_cast<PBYTE>(module)));
			}
		}

		return TRUE;
	}

	VOID ResolveRelocations(PBYTE base, PIMAGE_NT_HEADERS nt, PBYTE mapped) {
		auto& baseRelocDir = nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
		if (!baseRelocDir.VirtualAddress) {
			return;
		}

		auto reloc = reinterpret_cast<PIMAGE_BASE_RELOCATION>(TranslateRaw(base, nt, baseRelocDir.VirtualAddress));
		if (!reloc) {
			return;
		}

		for (auto currentSize = 0UL; currentSize < baseRelocDir.Size; ) {
			auto relocCount = (reloc->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
			auto relocData = reinterpret_cast<PWORD>(reinterpret_cast<PBYTE>(reloc) + sizeof(IMAGE_BASE_RELOCATION));
			auto relocBase = reinterpret_cast<PBYTE>(TranslateRaw(base, nt, reloc->VirtualAddress));

			for (auto i = 0UL; i < relocCount; ++i, ++relocData) {
				auto data = *relocData;
				auto type = data >> 12;
				auto offset = data & 0xFFF;

				if (type == IMAGE_REL_BASED_DIR64) {
					*reinterpret_cast<PBYTE*>(relocBase + offset) += (mapped - reinterpret_cast<PBYTE>(nt->OptionalHeader.ImageBase));
				}
			}

			currentSize += reloc->SizeOfBlock;
			reloc = reinterpret_cast<PIMAGE_BASE_RELOCATION>(relocData);
		}
	}

	BOOLEAN MapHeaders(Comm::Process& process, PBYTE base, PIMAGE_NT_HEADERS nt, PBYTE mapped) {
		return process.Write(mapped, base, sizeof(nt->Signature) + sizeof(nt->FileHeader) + nt->FileHeader.SizeOfOptionalHeader) == ERROR_SUCCESS;
	}

	BOOLEAN MapSections(Comm::Process& process, PBYTE base, PIMAGE_NT_HEADERS nt, PBYTE mapped) {
		auto section = IMAGE_FIRST_SECTION(nt);
		for (auto i = 0; i < nt->FileHeader.NumberOfSections; ++i, ++section) {
			auto sectionSize = min(section->SizeOfRawData, section->Misc.VirtualSize);
			if (!sectionSize) {
				continue;
			}

			auto mappedSection = mapped + section->VirtualAddress;
			if (process.Write(mappedSection, base + section->PointerToRawData, sectionSize) != ERROR_SUCCESS) {
				errorf("failed to map section %s at %p (%x)\n", section->Name, mappedSection, sectionSize);
				return FALSE;
			}
		}

		return TRUE;
	}

	PBYTE ExtendModule(Comm::Process& process, PIMAGE_NT_HEADERS nt, LPCWSTR module) {
		PBYTE moduleBase = NULL;
		DWORD moduleSize = 0;

		printf("\n\n[-] extending %ws\n", module);

		auto status = process.Module(module, &moduleBase, &moduleSize);
		if (status != ERROR_SUCCESS || !moduleBase) {
			errorf("failed to find module %ws (%X)\n", module, status);
			return NULL;
		}

		status = process.Extend(module, nt->OptionalHeader.SizeOfImage);
		if (status != ERROR_SUCCESS) {
			errorf("module %ws does not having enough free trailing memory (%X)\n", module, status);
			return NULL;
		}

		printf("[+] extended %ws to %x\n", module, moduleSize + nt->OptionalHeader.SizeOfImage);
		return moduleBase + moduleSize;
	}

	PVOID ExtendMap(Comm::Process& process, PBYTE base, LPCWSTR module) {
		auto dos = reinterpret_cast<PIMAGE_DOS_HEADER>(base);
		if (dos->e_magic != IMAGE_DOS_SIGNATURE) {
			errorf("invalid DOS signature\n");
			return NULL;
		}

		auto nt = reinterpret_cast<PIMAGE_NT_HEADERS>(base + dos->e_lfanew);
		if (nt->Signature != IMAGE_NT_SIGNATURE) {
			errorf("invalid NT signature\n");
			return NULL;
		}

		nt->Signature = dos->e_magic = 0;

		auto mapped = ExtendModule(process, nt, module);
		if (!mapped) {
			return NULL;
		}

		printf("[+] mapped base: %p\n", mapped);

		if (!ResolveImports(process, base, nt)) {
			return NULL;
		}

		ResolveRelocations(base, nt, mapped);

		if (!MapHeaders(process, base, nt, mapped)) {
			errorf("failed to map headers\n");
			return NULL;
		}

		if (!MapSections(process, base, nt, mapped)) {
			return NULL;
		}

		return mapped + nt->OptionalHeader.AddressOfEntryPoint;
	}

	PVOID ExtendMap(Comm::Process& process, LPCWSTR module) {

		auto entryPoint = ExtendMap(process, rawData, module);
		return entryPoint;
	}
}
```

`map.h`:

```h
#pragma once

namespace Map {
	PVOID ExtendMap(Comm::Process& process, LPCWSTR module);
}
```