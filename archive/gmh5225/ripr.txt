Project Path: arc_gmh5225_ripr_74vfbtts

Source Tree:

```txt
arc_gmh5225_ripr_74vfbtts
├── LICENSE
├── README.md
├── __init__.py
├── analysis_engine.py
├── cli_ui.py
├── codegen.py
├── conScan.py
├── dependency.py
├── doc
│   └── ripr-shmoocon.pdf
├── gui.py
├── packager.py
├── plugin.json
├── r2pipe_run.py
├── sample
│   ├── impCall
│   │   ├── arm_impCall.bin
│   │   ├── main.c
│   │   ├── ripr_arm_impCall.py
│   │   ├── ripr_x64_impCall.py
│   │   ├── ripr_x86_impCall.py
│   │   ├── x64_impCall.bin
│   │   └── x86_impCall.bin
│   ├── multiFunc
│   │   ├── arm_multiFunc
│   │   ├── demo.py
│   │   ├── main.c
│   │   ├── ripr_arm.py
│   │   ├── ripr_x64.py
│   │   ├── ripr_x86
│   │   ├── ripr_x86.py
│   │   ├── x64_multiFunc
│   │   └── x86_multiFunc
│   └── rc4
│       ├── RC4.c
│       ├── a.out
│       ├── myrc4.py
│       └── tester.py
├── test
│   ├── __init__.py
│   ├── test_impCall.py
│   └── test_multiFunc.py
└── test_harness.py

```

`LICENSE`:

```
MIT License

Copyright (c) 2017 Patrick

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# ripr
ripr is a tool that helps you rip out functionality from binary code and use it from Python. It accomplishes this by pairing the [Unicorn-Engine](http://www.unicorn-engine.org/) with [Binary Ninja](https://binary.ninja). Currently, `x86`, `x64`, and `arm` are supported and work to a reasonable degree.

# Introduction
Reimplementing functionality is a common, often time-consuming, and sometimes arduous process that comes up frequently during reverse engineering. A few examples:

* A CTF challenge has a custom encoding/decoding scheme you need to use in your solution script
* A piece of malware uses a custom hashing or encryption function you need to implement
* You need to make sure your reimplementation behaves _exactly_ as it would on the original architecture

ripr attempts to automatically generate a python class that is functionally identical to a selected piece of code by statically gathering sufficient information and wrapping it all into a "harness" for the unicorn emulator. 

For some concrete examples, check out the `sample` folder!

# Installation
The manual installation process looks like this:

1. Clone this repo to your local machine
2. Find the location of your plugins directory from Binary Ninja by clicking on `Tools --> Open Plugin Folder...`
3. Place this repo in that directory, or create a symlink pointing to it.


# Usage

## Packaging a Function
From within Binary Ninja, right click anywhere inside of a function and then select: 

```Plugins --> ripr --> Package Function```
<p align="center">
<img src="https://imgur.com/CjElWAM.png">
</p>

See the [Options while Packaging](#options-while-packaging) section for details about prompts that may appear during this process.

## Packaging Specific Basic Blocks
You can also choose to only package specific basic blocks rather than the entire function.

Select any instruction inside the basic block of interest, and from the right click menu, choose `[ripr] Package Basic Block`.
Repeat this for any other basic blocks you want to gather.

Finally, select `Generate Selected BBs` from the context menu to have ripr generate output for them.

## Contextual Highlighting

ripr will contextualize code you've selected for packaging within the GUI.

* Basic Blocks that have been included or identified have their background color darkened
* Instructions that have caused a data dependency to be identified are highlighted Yellow
* Call instructions to imported functions are highlighted Red
* Call instructions to functions inside the target binary are highlighted Blue
* Instructions that access unintialized variables are highlighed Orange (Basic Block Mode).

This is meant to give the user visual cues about what ripr has seen and automatically identified, making it easier to see "right off the bat" whether manual modification of the package is necessary.

## Options while Packaging
There are a few different prompts which may appear while packaging a function. 

#### Code contains calls to Imported Functions. How should this be handled?

Choosing "Hook" will allow you to write-in your own functionality that runs in lieu of imported functions. Selecting "Nop out Calls" will replace the call instruction with a series of NOPs.

#### Target code may depend on outside code. Attempt to map automatically?

Your selected code contains calls to other functions within the binary. Answering yes will automatically map those functions.

#### Use Section Marking Mode for data dependencies?

Answering yes will map all sections of the binary that are touched by the target code. Answering No will use Page-Marking mode, where every page used by the target code is mapped into emulator memory.

## Using a ripr "package"
Once a selection of code has been packaged, you will have a python class which encapsulates its functionality. The basic process of using it looks like this:

1. Instantiate the class
2. Call the run() method

Assuming `my_ripped_code` is the class name:

```python
x = my_ripped_code()
y = x.run()
```

All Unicorn functionality is exposed via the `mu` attribute and should work as expected. 

## Implementing "Imported Calls"
If you choose to hook calls to `imported functions` during the packaging stage, your generated class will contain stub-functions that are called when the imported call would originally have been called.

For example, if your code contained calls to `puts` and `malloc`, the following would be generated in your class:
```python
def hook_puts(self):
    pass
def hook_malloc(self):
    pass
```
Any code you write within these functions will be called in lieu of the actual imported call. If you wanted a reasonable approximation of `puts` (and were emulating x64 code), you could do:

```python
def hook_puts(self):
    addr = self.mu.reg_read(UC_X86_REG_RDI)
    mem = self.mu.mem_read(addr, 0x200)
    print "%s" % (mem.split("\x00")[0])
```

You have full access to all of Unicorn's methods via the `mu` attribute so it is possible to update the emulator context in any way necessary in order to mimic the behavior of a call or perform any actions you'd like instead of the call.

## Function Arguments
ripr has some support for automatically generating "argument aware" output. When information about a function's parameters is available to Binary Ninja, ripr will generate its `run`
functions in the form:

```python
def run(self, arg_1, arg_2, ...)
```

When dealing with non-pointer types, your arguments will be written into the expected location in the emulated environment. 

For "single depth" pointers, (e.g `char *, int *`), ripr will map memory, copy your argument to it, and place the address of that mapped memory into the appropriate location.

For pointers with a depth greater than 1, ripr falls back on default behaviour.

If you need to manually set up arguments, you can directly manipulate unicorn's state via the `mu` attribute.
For example, assuming you are emulating a 32-bit x86 function, you could do the following:

```python
def run(self, arg1, arg2):
    self.mu.reg_write(UC_X86_REG_ESP, 0x7fffff00)
    self.mu.mem_write(0x7fffff00, '\x01\x00\x00\x00')

    self.mu.mem_write(0x7fffff04, arg1)
    self.mu.mem_write(0x7fffff08, arg2)
    

    self._start_unicorn(0x80484bb)
    return self.mu.reg_read(UC_X86_REG_EAX)
```

# Code Structure

* `packager.py` -- High Level Functionality. Code here drives the process of gathering necessary data
* `codegen.py`  -- Contains code for actually generating the python output from the gathered data
* `analysis_engine.py` -- Wraps static analysis engine functionality into a common interface
* `dependency.py` -- Contains code for finding code and data that the target code needs in order to function corrrectly
* `conScan.py` -- Contains "convenience" analyses that help ripr output easier-to-use code
* `gui.py` --  A collection of hacks that resembles a user interface
    * Reuses lots of code from the [Binjadock](https://github.com/NOPDev/BinjaDock) project to display results

# Testing
The current tests will package up some functions across the 3 supported architectures found 
in the `sample` folder. 

To run the tests:

```
cd <ripr_directory>
python -m unittest discover -t ../
```

```

`__init__.py`:

```py
import sys

if (sys.platform == 'win32'):
    if sys.version_info[0] >= 3:
        sys.path.append("C:\\Python37\\lib\\site-packages\\PyQt5")
    else:
        sys.path.append("C:\\Python27\\lib\\site-packages\\PyQt5")
try:
    from binaryninja import *
   
    # Do not try to load if this is hit from "headless"/python api
    #if core_product_type == '':
    #    raise ImportError

    # ripr imports
    from .analysis_engine import *
    from .codegen import *
    from .packager import *
    from .gui import *


    ui = gui.riprWidget()
    def packageFunction(view, fobj):
        engine = get_engine(view, fobj)
        pkg = Packager(isFunc=True, address=fobj.start, engine=engine, ui=ui)
        pkg.package_function()

    def packageRegion(view, start, length):
        print ("[ripr] Packaging 0x%x - 0x%x" % (start, start+length))
        engine = get_engine(view)
        pkg = Packager(isFunc=False, address=start, engine=engine, length=length, ui=ui)
        pkg.package_region()

    def packageBasicBlock(view, addr):
        print ("[ripr] Adding Basic Block containing %x " % addr)
        engine = get_engine(view)
        pkg = Packager(isFunc=False, address=addr, engine=engine, ui=ui)
        pkg.package_bb()

    def generate_basicBlocks(view, fobj):
        print ("[ripr] Generating code from currently selected basic blocks")
        engine = get_engine(view)
        pkg = Packager(isFunc=False, address=fobj.start, engine=engine, ui=ui)
        pkg.generate_bb_code()

    PluginCommand.register_for_function("ripr\Package Function", "Package Function within Unicorn", packageFunction)
    
    PluginCommand.register_for_address("ripr\Package BasicBlock", "Package Function within Unicorn", packageBasicBlock)
    
    PluginCommand.register_for_function("ripr\Generate Selected BBs", "Package Function within Unicorn", generate_basicBlocks)

except ImportError as e:
    raise e
    pass

```

`analysis_engine.py`:

```py
'''
    This code should encapsulate product specific API's so that they 
    can be accessed in other components cleanly.
'''

# Try to import stuff.
try:
    from binaryninja import *
except:
    print ("[!!] Not running in Binary Ninja")

try:
    import r2pipe
except:
    print ("[!!] Not running in Radare2")

import json
import re
import sys
from .codegen import *
from binascii import unhexlify

def get_engine(*args):
    '''
        Return an instance of the correct analysis engine class.
    '''
    if ("r2pipe" in sys.argv[0]):
        return radare2_engine(r2pipe.open())
    
    if ("binaryninja" in sys.modules.keys()):
        return bn_engine(args[0])


    raise (ValueError, "No analysis engine found!")
    


class aengine(object):
    def __init__(self):
        pass

    def find_section(self, addr):
        '''
            Function should find what segment/section $addr is in and return a tuple
            (StartAddress, Endaddress, Segment Name)
            Error: Return -1
        '''
        pass

    def get_arch(self):
        '''
            Function should return a string of the architecture of the currently loaded binary.
            Architecture should be one of:
            'x86'
            'x64'
            'arm'
            'arm64'
            'mips'
        '''
        pass

    def get_function_bytes(self, address=None, name=None):
        '''
            Function should return a dictionary of address:string pairs where address
            is a starting address and string is a string of bytes of the function at that location.

            This allows for handling functions that are non-contiguous in memory.
        '''
        pass

    def get_page_bytes(self, address):
        '''
            Funtion should return a string of bytes from the page where address
            is located. 
        '''
        pass

    def get_nop_opcode(self):
        '''
            Function should return a string corresponding to a NOP on the specified
            architecture.
        '''
        pass

    def get_region_bytes(self, start, end):
        '''
            Function should return a tuple (address, string) where address
            is the starting address of the region and string contains the bytes 
            between start and end, inclusive.
        '''
        return (start, self.read_bytes(start, end - start))
    
    def read_bytes(self, address, len):
        '''
            Function should return a string containing
            $len bytes at $address.
        '''
        pass

    def get_imports(self):
        raise NotImplementedError

    def get_instruction_length(self, address):
        raise NotImplementedError

    def get_data_symbols(self):
        raise NotImplementedError

    def get_strings(self):
        raise NotImplementedError

    def get_refs_to(self, address):
        raise NotImplementedError

    def function_contains_addr(self, func_addr, testAddr):
        raise NotImplementedError

    def get_page_size(self):
        raise NotImplementedError

    def generate_invalid_access(self, address, arch, size=None):
        raise NotImplementedError

    def branches_from_func(self, address, callCallback, branchCallback):
        raise NotImplementedError

    def scan_potential_pointers(self, func_addr):
        raise NotImplementedError

    def is_plausible_pointer(self, candidate_ptr):
        raise NotImplementedError

    def highlight_instr(self, func_addr, instrAddr, color):
        pass

    def add_comment(self, func_addr, instrAddr, comment):
        pass

    def display_info(self, info1, info2):
        pass

class bn_engine(aengine):
    '''
        This class should encapsulate all binary-ninja api calls cleanly. 
        Comments in this class relate to why a certain function is implemented the way it is,
        mostly relating to Binary Ninja specifics. Descriptions of what a function should do
        are in the aengine class.
    '''

    def __init__(self, view):
        # We will need a BinaryViewType.
        self.bv = view
        aengine.__init__(self)

    def read_bytes(self, address, len):
        return self.bv.read(address, len)

    def get_arch(self):
        '''
            ripr uses its own architecture names that map onto Unicorn architectures. 
            These can be different from Binary Ninja names, so they are explicitly mapped
            into the ripr names, even if they are the same in some cases.
        '''
        print (self.bv.arch.name)
        if (self.bv.arch.name == 'x86'):
            return 'x86'
        elif (self.bv.arch.name == 'x86_64'):
            return 'x64'
        elif (self.bv.arch.name == 'armv7'):
            return 'arm'
        elif (self.bv.arch.name == 'aarch64'):
            return 'arm64'

    def mark_gathered_basic_block(self, address):
        fobj = self.bv.get_functions_containing(address)[0]
        if (fobj == None):
            print ("FOBJ IS NONE")
        bb = fobj.get_basic_block_at(address)
        bb.highlight = HighlightStandardColor.BlackHighlightColor

        fobj.set_comment_at(bb.start, "[ripr] Basic Block will be included in package")

    def clean_gathered_basic_block(self, address):
        fobj = self.bv.get_functions_containing(address)[0]
        bb = fobj.get_basic_block_at(address)

        bb.highlight = HighlightStandardColor.NoHighlightColor
        fobj.set_comment_at(bb.start, '')
   
    def get_basic_block_bytes(self, address):
        bb = self.bv.get_basic_blocks_at(address)
        if len(bb) != 1:
            print ("[ripr] Address belongs to more than one basic block!")

        bb = bb[0]
        return {bb.start: codeSlice(self.read_bytes(bb.start, bb.end-bb.start), bb.start)}

    def get_function_bytes(self, address=None, name=None):
        ''' 
            Binary Ninja does not seem to assume Functions are contiguous; rather they 
            are treated as a collection of basic blocks. 
        '''
        print ("[ripr] Inside get_function_bytes()")
        if (address != None):
            fobj = self.bv.get_function_at(address)
        elif (name != None):
            print ("[ripr] TODO")
            return
        else:
            print ("[ripr] No arguments supplied to get_function_bytes")
            return None
        
        if self.bv.get_function_at(address)==None:
            print ("[ripr] Couldn't get function binary view. Maybe code arch is thumb2?")
            return None
            
        # Sort the basic blocks in ascending order 
        bblist = sorted(fobj.basic_blocks, key=lambda x: x.start)
        map(lambda bb: bb.set_user_highlight(HighlightStandardColor.BlackHighlightColor), bblist)
        # Create units of contiguous blocks
        clist = [[bblist[0]]]
        for bb in bblist[1:]:
            if (bb.start == clist[-1][-1].end):
                clist[-1].append(bb)
            else:
                clist.append([bb])
        # Print out the list if the function is not contiguous
        if (len(clist) > 1):
            print (clist)

        # Create a return list in the expected format from the contiguous units.
        retdir = {unit[0].start : codeSlice(self.read_bytes(unit[0].start, unit[-1].start - unit[0].start + unit[-1].length), unit[0].start) for unit in clist}
        return retdir

    def get_page_bytes(self, address):
        # Should get this dynamically if possible based on arch/mode/etc
        pagesize = self.get_page_size()
        pageaddr = (address & ~(pagesize - 1))
        return self.read_bytes(pageaddr, pagesize)

    def get_page_size(self):
        return 4096

    def get_region_bytes(self, start, end):
        return (start, self.read_bytes(start, end-start))
        
    def get_nop_opcode(self):
        return self.bv.arch.assemble('nop')[0]

    def generate_invalid_access(self, address, arch, size=None):
        '''
            Generates an invalid memory access for use in function hooking.
            pad to size if applicable
        '''
        if arch in ['x86', 'x64']:
            if (size):
                opcodes = self.bv.arch.assemble('mov al, [%s]' % address)[0]
                nop = self.get_nop_opcode()
                if len(opcodes) >= size:
                    return opcodes
                return opcodes + nop * (size - len(opcodes))
            else:
                return self.bv.arch.assemble('mov al, [%s]' % address)[0]

    def get_imports(self):
        return {imp.address : imp.name for imp in self.bv.get_symbols_of_type(SymbolType.ImportedFunctionSymbol)}

    def get_instruction_length(self, address):
        return self.bv.get_instruction_length(address)

    def find_llil_block_from_addr(self, address):
        fobj = self.bv.get_functions_containing(address)
        if len(fobj) > 1:
            print ("[ripr] Multiple Functions contain this address!!")
            return None
        fobj = fobj[0]
        bbindex = fobj.get_basic_block_at(address).index
        return fobj.low_level_il.basic_blocks[bbindex]

    def find_mlil_block_from_addr(self, address):
        fobj = self.bv.get_functions_containing(address)
        if len(fobj) > 1:
            print ("[ripr] Multiple Functions contain this address!!")
            return None
        fobj = fobj[0]
        bbindex = fobj.get_basic_block_at(address).index
        try:
            ret = fobj.medium_level_il.basic_blocks[bbindex]
            return ret
        except:
            return None

    def branches_from_block(self, block, callCallback, branchCallback):
        for il_inst in block:
            if (il_inst.operation == LowLevelILOperation.LLIL_CALL):
                callCallback(il_inst.dest.value, il_inst.address)
            # Check Jump targets
            elif (il_inst.operation in [LowLevelILOperation.LLIL_JUMP,\
                                        LowLevelILOperation.LLIL_JUMP_TO,\
                                        LowLevelILOperation.LLIL_GOTO]):
                branchCallback(il_inst.dest, il_inst.address)
            else:
                pass

    def branches_from_func(self, address, callCallback, branchCallback):
        fobj = self.bv.get_function_at(address)
        if (fobj==None):
            return
            
        for block in fobj.low_level_il:
            self.branches_from_block(block, callCallback, branchCallback)

    def get_data_symbols(self):
        for sym in self.bv.get_symbols_of_type(SymbolType.DataSymbol):
                yield sym.address

    def get_strings(self):
        for st in self.bv.strings:
            yield (st.start, st.length)

    def get_refs_to(self, address):
        fobj = self.bv.get_function_at(address)
        for ref in self.bv.get_code_refs(address):
            yield ref.address

    def function_contains_addr(self, func_addr, testAddr):
        fobj = self.bv.get_function_at(func_addr)
        if (fobj==None):
            return False
        return (fobj.get_basic_block_at(testAddr) != None)

    def scan_potential_pointers_bb(self, il_block, fobj):
        for il_inst in il_block:
           # We are only interested in data references here.
            if il_inst.operation in [LowLevelILOperation.LLIL_CALL, \
                                     LowLevelILOperation.LLIL_JUMP, \
                                     LowLevelILOperation.LLIL_GOTO, \
                                     LowLevelILOperation.LLIL_IF,   \
                                     LowLevelILOperation.LLIL_JUMP_TO]:
                continue

            constants = fobj.get_constants_referenced_by(il_inst.address)
            # Check if constant is a likely pointer
            for const in constants:
                yield const.value, il_inst.address
            # Memory things
            if il_inst.operation in [LowLevelILOperation.LLIL_LOAD,\
                                     LowLevelILOperation.LLIL_STORE,\
                                     LowLevelILOperation.LLIL_CONST,\
                                     LowLevelILOperation.LLIL_UNIMPL_MEM,\
                                     LowLevelILOperation.LLIL_SET_REG]:
                    # TODO
                if (il_inst.operation == LowLevelILOperation.LLIL_STORE):
                #yield il_inst.address
                    try:
            
                        yield self.bv.is_valid_offset(il_inst.operands[0].value), il_inst.address
                    except:
                        pass

    def scan_potential_pointers(self, func_addr):
        # Iterate over all instructions in each basic block
        fobj = self.bv.get_function_at(func_addr)
        for block in fobj.low_level_il:
            for target, instAddr in self.scan_potential_pointers_bb(block, fobj):
                yield target, instAddr

    def is_plausible_pointer(self, candidate_ptr):
        return self.bv.is_valid_offset(candidate_ptr)


    def find_section(self, addr):
        '''
            Function should find what segment/section $addr is in and return a tuple
            (StartAddress, Endaddress, Segment Name)
            Error: Return -1
        '''
        res = []
        for sec in self.bv.get_sections_at(addr):
            return ((sec.start, sec.end, sec.name))
        return -1


    def highlight_instr(self, func_addr, instrAddr, color):
        fobj = self.bv.get_functions_containing(func_addr)[0]
        if color == "red":
            bn_color = HighlightStandardColor.RedHighlightColor
        elif color == "blue":
            bn_color = HighlightStandardColor.BlueHighlightColor
        elif color == "yellow":
            bn_color = HighlightStandardColor.YellowHighlightColor
        elif color == "orange":
            bn_color = HighlightStandardColor.OrangeHighlightColor
        else:
            raise (ValueError, "Unsupported color")
        fobj.set_user_instr_highlight(instrAddr, bn_color)

    def add_comment(self, func_addr, instrAddr, comment):
        fobj = self.bv.get_functions_containing(func_addr)[0]
        fobj.set_comment(instrAddr, "[ripr] " + comment)

    def display_info(self, info1, info2):
        self.bv.show_plain_text_report(info1, info2)

class radare2_engine(aengine):
    def get_data_symbols(self):
        for symbol in self.r2.cmdj("isj"):
            if symbol['type'] == "OBJECT":
                yield symbol['vaddr']


    def get_strings(self):
         for symbol in self.r2.cmdj("izj"):
            yield symbol['vaddr'], symbol['size']

    def get_refs_to(self, address):
        res = self.r2.cmd("axtj {}".format(hex(address)))
        if res is None or len(res) == 0:
            return
        res = json.loads(res)
        for ref in res:
            yield ref['from']

    def function_contains_addr(self, func_addr, testAddr):
        func = self.r2.cmdj("afij @{}".format(hex(func_addr)))
        func = func[0]
        return testAddr >= func['offset'] and testAddr < func['offset']+func['size']

    def __init__(self, r2):
        self.r2 = r2
        aengine.__init__(self)

    def read_bytes(self, address, size):
        bytes = []
        hexdump = self.r2.cmd("pc {} @ {}".format(size,hex(address)))
        for line in hexdump.split("\n"):
            if "0x" in line:
                for byte in line.split(","):
                    byte = byte.strip()
                    if len(byte) == 0:
                        continue
                    byte = int(byte, 16)
                    bytes.append(chr(byte))
        assert len(bytes) == size
        return ''.join(bytes)

    def get_arch(self):
        info = self.r2.cmdj("ifj")
        arch = info['bin']['arch']
        bits = info['bin']['bits']
        if arch == "x86" and bits == 32:
            return 'x86'
        elif arch == "x86" and bits == 64:
            return 'x64'
        else:
            raise (NotImplementedError, "Only tested with x86 & x86_64")
        '''
        elif arch == "arm" and bits == 32:
            return 'arm'
        elif arch == "arm" and bits == 64:
            return 'arm64'
        '''

    def get_function_bytes(self, address=None, name=None):
        if (address != None):
            funcInfo = self.r2.cmd("afij {}".format(hex(address)))
        elif (name != None):
            print ("[ripr] TODO")
            return
        else:
            print ("[ripr] No arguments supplied to get_function_bytes")
            return None

        if funcInfo.strip() == "":
            raise (ValueError, "Function not found at {}".format(address))
        funcInfo = json.loads(funcInfo, strict=False)

        if len(funcInfo) == 0:
            raise (ValueError, "Function not found at {}".format(address))
        print (funcInfo)
        offset = funcInfo[0]["offset"]
        size = funcInfo[0]["size"]
        bytes = self.read_bytes(offset, size)
        retdir = {offset: codeSlice(bytes, offset)}
        return retdir

    def get_page_bytes(self, address):
        # Should get this dynamically if possible based on arch/mode/etc
        pagesize = self.get_page_size()
        pageaddr = (address & ~(pagesize - 1))
        return self.read_bytes(pageaddr, pagesize)

    def get_page_size(self):
        return 4096

    def get_region_bytes(self, start, end):
        return (start, self.read_bytes(start, end-start))

    def get_nop_opcode(self):
        return self.r2.cmd("pa nop").decode('hex')

    def generate_invalid_access(self, address, arch, size=None):
        '''
            Generates an invalid memory access for use in function hooking.
            pad to size if applicable
        '''
        # TODO: Radare2 seems to assemble this to a rip-relative access?
        if arch in ['x86', 'x64']:
            if (size):
                opcodes = self.r2.cmd('pa mov al, [%s]' % address).decode('hex')
                nop = self.get_nop_opcode()
                if len(opcodes) >= size:
                    return opcodes
                return opcodes + nop * (size - len(opcodes))
            else:
                return self.r2.cmd('pa mov al, [%s]' % address).decode('hex')

    def get_imports(self):
        # Iterate through symbols and grab everything that starts with 'sym.'
        res = {}
        for sym in self.r2.cmdj("isj"):
            if sym['name'].startswith("imp."):
                res[sym['vaddr']] = sym['name'][4:]
        return res

    def branches_from_func(self, address, callCallback, branchCallback):
        func = self.r2.cmdj("pdfj @ {}".format(hex(address)))
        instructions = func['ops']
        for instr in instructions:
            if instr['type'] == 'call':
                callCallback(instr['jump'], instr['offset'])
            elif instr['type'] == 'cjmp' or instr['type'] == 'jmp':
                branchCallback(instr['jump'], instr['offset'])
            #TODO: Any other?

    def scan_potential_pointers(self, func_addr):
        # Leverage Radare2 automatic pointer detection
        func = self.r2.cmdj("pdfj @ {}".format(hex(func_addr)))
        res = []
        for line in func['ops']:
            if 'ptr' in line:
                yield line['ptr'], line['offset']

    def is_plausible_pointer(self, candidate_ptr):
        # A manual scan of all sections
        for section in self.r2.cmdj("Sj"):
            if candidate_ptr >= section['vaddr'] and \
                candidate_ptr < section['vaddr'] + section['vsize']:
                return True
        return False

    def find_section(self, addr):
        '''
            Function should find what segment/section $addr is in and return a tuple
            (StartAddress, Endaddress, Segment Name)
            Error: Return -1
        '''
        # A manual scan of all sections
        res = []
        for section in self.r2.cmdj("Sj"):
            if addr >= section['vaddr'] and \
                addr < section['vaddr'] + section['vsize']:
                return (
                    section['vaddr'],
                    section['vaddr'] + section['vsize'],
                    section['name'])

        return -1

    def get_instruction_length(self, address):
        return self.r2.cmdj("pdj 1 @{}".format(hex(address)))[0]['size']

    def highlight_instr(self, func_addr, instrAddr, color):
        # No highlighting yet
        pass

    def add_comment(self, func_addr, instrAddr, comment):
        if not re.compile("^[a-z0-9 !\\-\\_]+$", re.IGNORECASE).match(comment):
            # Don't send arbitrary contents to radare pipe
            print ("Ignoring malformed comment: {}".format(comment))
        else:
            self.r2.cmd("CC [ripr] {} @{}".format(comment, hex(instrAddr)))


```

`cli_ui.py`:

```py

# Instead of GUI, just prompt on the command line
class cli_ui:
    qtAvailable = False
    def yes_no_box(self, question):
        while True:
            response = raw_input("{} (Y/N)".format(question))
            if len(response) < 1 or response[0] not in ['y','n','N','Y']:
                continue

            if response[0].lower() == 'y':
                return True
            else:
                return False

    def update_table(self, newTable):
        #TODO: Not showing a table for now
        pass

    def text_input_box(self, promptText):
        return raw_input(promptText + "? ").strip()

    def impCallsOptions(self):
        options = ["nop", "hook", "cancel"]

        print ("Code contains calls to imported functions. How should this be handled?")
        while True:
            selection = raw_input("({})?".format(", ".join(options))).strip()
            if selection in options:
                return selection

    def save_file(self, codeobj):
        print codeobj.final


```

`codegen.py`:

```py
'''
CodeGen
'''
import sys
import os
import binascii

python2=False
if sys.version_info[0] < 3:
   python2=True

try:
    from binaryninja import *
except:
    print ("[+] Not running in BinaryNinja")

class callConv(object):
    def __init__(self, name, arch):
        self.name = name
        self.arch = arch

    def gen_arg_number(self, argno):
        pass

    def genPointer(self, arg, regs, indent):
        pass
    
    def dumpContext(self, indent):
        pass

class x64callConv(callConv):
# TODO Stack based arguments 
    def __init__(self, name, arch):
        self.name = name
        self.arch = arch
        self.platform = ''
        self.regs = ["UC_X86_REG_RAX", "UC_X86_REG_RBP", "UC_X86_REG_RBX", "UC_X86_REG_RCX",\
                    "UC_X86_REG_RDI", "UC_X86_REG_RDX", "UC_X86_REG_RSI", "UC_X86_REG_RSP",\
                    "UC_X86_REG_RIP", "UC_X86_REG_R8", "UC_X86_REG_R9", "UC_X86_REG_R10",\
                    "UC_X86_REG_R11", "UC_X86_REG_R12", "UC_X86_REG_R13", "UC_X86_REG_R14",\
                    "UC_X86_REG_R15"]
                    
    def gen_arg_number(self, argno, indent=1):
        print ("X64")
        if self.platform == "win":
            return self.msft(argno, indent)
        return self.systemV(argno, indent)

    def genPointer(self, arg, regs, indent):
        ret  = ' ' * (indent * 4) + "argAddr_%x = (%d * 0x1000)\n" % (arg.num, arg.num+1)
        ret += ' ' * (indent * 4) + "self.mu.mem_write(argAddr_%x, arg_%x)\n" % (arg.num, arg.num)
        ret += ' ' * (indent * 4) + "self.mu.reg_write(%s, argAddr_%x)\n" % (regs[arg.num], arg.num)
        return ret

    def msft(self, arg, indent):
        regs = ["UC_X86_REG_RCX", "UC_X86_REG_RDX", "UC_X86_REG_R8", "UC_X86_REG_R9"]
        
        if arg.num < len(regs):
            return "self.mu.reg_write(%s, arg_%x)\n" % (regs[argno], argno)
        return self.genPointer(arg, regs, indent)

    def systemV(self, arg, indent):
        regs = ["UC_X86_REG_RDI", "UC_X86_REG_RSI", "UC_X86_REG_RDX", "UC_X86_REG_RCX",\
                "UC_X86_REG_R8", "UC_X86_REG_R9"]
        
        if arg.num <= len(regs):
            if (arg.pointerDepth == 0 or arg.pointerDepth > 1):
                return ' ' * (indent*4) + "self.mu.reg_write(%s, arg_%x)\n" % (regs[arg.num], arg.num)
            return self.genPointer(arg, regs, indent)

    def dumpContext(self, indent):
        ret = ' ' * (indent * 4) + ("print ('[!] Exception occured - Emulator state (x64):')\n")
        for r in self.regs:
            ret += ' ' * (indent * 4) + ("print (\"%s : %%016X\" %% (self.mu.reg_read(%s)))\n" % (r,r))
        return ret

class x86callConv(callConv):
    def __init__(self, name, arch):
        self.name = name
        self.arch = arch
        self.regs = ["UC_X86_REG_EAX", "UC_X86_REG_EBP", "UC_X86_REG_EBX", "UC_X86_REG_ECX",\
                    "UC_X86_REG_EDI", "UC_X86_REG_EDX", "UC_X86_REG_ESI", "UC_X86_REG_ESP",\
                    "UC_X86_REG_EIP"]

    def genPointer(self, arg, indent):
        ret = ' ' * (indent * 4) + "argAddr_%x = (%d * 0x1000)\n" % (arg.num, arg.num + 1)
        ret += ' ' * (indent * 4) + "self.mu.mem_write(argAddr_%x, arg_%x)\n" % (arg.num, arg.num)
        ret += ' ' * (indent * 4) + "self.mu.mem_write(self.mu.reg_read(UC_X86_REG_ESP) + %d, struct.pack('<i', argAddr_%x))\n" % ( (arg.num * 4) + 4, arg.num)
        return ret


        # TODO Other calling conventions
    def gen_arg_number(self, arg, indent):
        if arg.pointerDepth == 0 or arg.pointerDepth > 1:
            return ' ' * (indent * 4) + "self.mu.mem_write(self.mu.reg_read(UC_X86_REG_ESP) + %d, struct.pack('<i', arg_%x))\n" % ( (arg.num * 4) + 4, arg.num)
        return self.genPointer(arg, indent)

    def dumpContext(self, indent):
        ret = ' ' * (indent * 4) + ("print ('[!] Exception occured - Emulator state (x86):')\n")
        for r in self.regs:
            ret += ' ' * (indent * 4) + ("print (\"%s : %%08X\" %% (self.mu.reg_read(%s)))\n" % (r,r))
        return ret

class armcallConv(callConv):
    def __init__(self, name, arch):
        self.name = name
        self.arch = arch
        self.regs = ["UC_ARM_REG_R0", "UC_ARM_REG_R1", "UC_ARM_REG_R2", "UC_ARM_REG_R3",\
                    "UC_ARM_REG_R4", "UC_ARM_REG_R5", "UC_ARM_REG_R6", "UC_ARM_REG_R7",\
                    "UC_ARM_REG_R8", "UC_ARM_REG_R9", "UC_ARM_REG_R10", "UC_ARM_REG_R11",\
                    "UC_ARM_REG_R12", "UC_ARM_REG_R13", "UC_ARM_REG_R14", "UC_ARM_REG_R15"]

    def genPointer(self, arg, regs, indent):
        ret = ' ' * (indent * 4) + "argAddr_%x = (%d * 0x1000)\n" % (arg.num, arg.num+1)
        ret += ' ' * (indent * 4) + "self.mu.mem_write(argAddr_%x, arg_%x)\n" % (arg.num, arg.num)
        ret += ' ' * (indent * 4) + "self.mu.reg_write(%s, argAddr_%x)\n" % (regs[arg.num], arg.num)
        return ret

    def gen_arg_number(self, arg, indent):
        regs = ["UC_ARM_REG_R0", "UC_ARM_REG_R1", "UC_ARM_REG_R2", "UC_ARM_REG_R3"]
        if arg.num < len(regs):
            if arg.pointerDepth == 0 or arg.pointerDepth > 1:
                return ' ' * (indent *4 ) + "self.mu.reg_write(%s, arg_%x)\n" % (regs[arg.num], arg.num)
            return self.genPointer(arg, regs, indent)

    def dumpContext(self, indent):
        ret = ' ' * (indent * 4) + ("print ('[!] Exception occured - Emulator state (arm):')\n")
        for r in self.regs:
            ret += ' ' * (indent * 4) + ("print (\"%s : %%X\" %% (self.mu.reg_read(%s)))\n" % (r,r))
        return ret            

class arm64callConv(callConv):
    def __init__(self, name, arch):
        self.name = name
        self.arch = arch
        self.regs = ["UC_ARM64_REG_X0", "UC_ARM64_REG_X1", "UC_ARM64_REG_X2", "UC_ARM64_REG_X3",\
                    "UC_ARM64_REG_X4", "UC_ARM64_REG_X5", "UC_ARM64_REG_X6", "UC_ARM64_REG_X7",\
                    "UC_ARM64_REG_X8", "UC_ARM64_REG_X9", "UC_ARM64_REG_X10", "UC_ARM64_REG_X11",\
                    "UC_ARM64_REG_X12", "UC_ARM64_REG_X13", "UC_ARM64_REG_X14", "UC_ARM64_REG_X15",\
                    "UC_ARM64_REG_X16", "UC_ARM64_REG_X17", "UC_ARM64_REG_X18", "UC_ARM64_REG_X19",\
                    "UC_ARM64_REG_X20", "UC_ARM64_REG_X21", "UC_ARM64_REG_X22", "UC_ARM64_REG_X23",\
                    "UC_ARM64_REG_X24", "UC_ARM64_REG_X25", "UC_ARM64_REG_X26", "UC_ARM64_REG_X27",\
                    "UC_ARM64_REG_X28", "UC_ARM64_REG_X29", "UC_ARM64_REG_X30"]

    def genPointer(self, arg, regs, indent):
        ret = ' ' * (indent * 4) + "argAddr_%x = (%d * 0x1000)\n" % (arg.num, arg.num+1)
        ret += ' ' * (indent * 4) + "self.mu.mem_write(argAddr_%x, arg_%x)\n" % (arg.num, arg.num)
        ret += ' ' * (indent * 4) + "self.mu.reg_write(%s, argAddr_%x)\n" % (regs[arg.num], arg.num)
        return ret

    def gen_arg_number(self, arg, indent):
        regs = ["UC_ARM64_REG_X0", "UC_ARM64_REG_X1", "UC_ARM64_REG_X2", "UC_ARM64_REG_X3"]
        if arg.num < len(regs):
            if arg.pointerDepth == 0 or arg.pointerDepth > 1:
                return ' ' * (indent *4 ) + "self.mu.reg_write(%s, arg_%x)\n" % (regs[arg.num], arg.num)
            return self.genPointer(arg, regs, indent)

    def dumpContext(self, indent):
        ret = ' ' * (indent * 4) + ("print ('[!] Exception occured - Emulator state (arm64):')\n")
        for r in self.regs:
            ret += ' ' * (indent * 4) + ("print (\"%s : %%X\" %% (self.mu.reg_read(%s)))\n" % (r,r))
        return ret

class codeSlice(object):
    '''
        A container class for a slice of code.
    '''
    def __init__(self, code, address):
        self.code_bytes = code
        self.address = address


class genwrapper(object):
    '''
        A storage area for different kinds of things we need to do to setup
        unicorn such that it can emulate the selected code.
        
        Regions we need to mmap
        Data we need to write
        Registers that need to be populated
        etc

        Args:
        Name: The name for this code
        engine: The analysis engine to be used.

        Attributes:
            mmap: Ranges we need to map
            data: List of data we need to copy into mappings
            code: List of codeSlice objects which need to be copied into memory
            
            arch: Architecture of this package
            saved_ranges:
            startaddr: Starting PC address for this package
            codelen: Length of code
            name: Name of the generated class
            conPass: Dictionary of applicable convenience passes (set by packager)
            impCallTargets: List of targets of imported calls to catch and hook
    '''
    def __init__(self, name, isFunc=True):

        self.mmap = {}
        # List of (address, data)
        self.data = []
        # List of codeSlice Objects
        self.code = []
        # Dict of regname:regvalue
        self.regs = {}
        self.arch = ''

        self.saved_ranges = []
        self.startaddr = 0
        self.codelen = 0
        self.name = name
        self.pagesize = self.get_pagesize()

        self.conPass = {}
        self.conPass['ret'] = False

        self.impCallTargets = []
        self.callConv = None

        self.isFunc = isFunc
        
    def setArch(self,a):
        self.arch=a
        if self.arch == 'x64':
            self.callConv = x64callConv("linux", "x64")
        elif self.arch == 'x86':
            self.callConv = x86callConv("linux", "x86")
        elif self.arch == 'arm':
            self.callConv =armcallConv("linux", "arm")
        elif self.arch == 'arm64':
            self.callConv =armcallConv("linux", "arm64")

    def data_saved(self, addr): 
        return any(lowaddr <= addr <= highaddr for (lowaddr, highaddr) in self.saved_ranges)
    
    # Wrappers for manipulating data structures
    def add_mmap(self, addr, len=0x4000):
        self.mmap[(addr & ~(self.pagesize - 1))] = len

    def add_data(self, data, addr):
        if (self.data_saved(addr)):
            print ("[Warning] Trying to map data twice!")
            return
        self.data.append((addr, data))
        self.saved_ranges.append((addr, addr + len(data)))

    def add_code(self, cSlice):
        if (self.data_saved(cSlice.address)):
            print ("[Warning] Trying to map data twice")
        self.code.append(cSlice)
        self.saved_ranges.append((cSlice.address, cSlice.address + len(cSlice.code_bytes)))

    def get_pagesize(self):
        if self.arch == 'x86':
            return 4096
        return 4096

    def generate_argument_mmaps(self, indent=1):
        '''
            Map a page for each argument with a pointerDepth of 1.
        '''
        out = ''
        for arg in self.conPass['args']:
            if arg.pointerDepth == 1:
                out += ' ' * (indent * 4) + "self.mu.mem_map(0x1000 * %d, 0x1000)\n" % (arg.num + 1)
        return out
        
    # Unicorn API generation helpers
    def generate_mmap(self, indent = 1):
        out = ''
        
        for addr in self.mmap:
            out += ' ' * (indent * 4) + "self.mu.mem_map(%s,%s)\n" % (hex(addr), hex(self.mmap[addr]))

        # Map pages for arguments if applicable
        if 'args' in self.conPass.keys():
            out += self.generate_argument_mmaps(indent=indent)

        return out
    
    def generate_data_vars(self, indent = 1):
        global python2
        out = ''
        for i in range(0, len(self.data)):
            if python2==True:
                cc=binascii.hexlify(self.data[i][1])
            else:
                cc=binascii.hexlify(self.data[i][1]).decode('utf-8')
            out += ' ' * (indent * 4) + "self.data_%s = binascii.unhexlify('%s') \n" % (str(i), cc)
        return out

    def generate_code_vars(self, indent = 1):
        global python2
        out = ''
        i = 0
        for cSlice in self.code:
            if python2==True:
                cc=binascii.hexlify(cSlice.code_bytes)
            else:
                cc=binascii.hexlify(cSlice.code_bytes).decode('utf-8')
            out += ' ' * (indent * 4) + "self.code_%s = binascii.unhexlify('%s') \n" % (str(i), cc)
            i += 1
        return out

    
    def generate_stack_initialization(self, indent = 1):
        if self.arch == 'x86':
            self.add_mmap(0x7ffff000, 1024*1024 * 2)
            out = ' ' * (indent * 4) + "self.mu.reg_write(UC_X86_REG_ESP, 0x7fffff00)\n"
        
        elif self.arch == 'x64':
            self.add_mmap(0x7ffff000, 1024*1024 * 2)
            out = ' ' * (indent * 4) + "self.mu.reg_write(UC_X86_REG_RSP, 0x7fffff00)\n"
        
        elif self.arch == 'arm':    
            self.add_mmap(0x7ffff000, 1024*1024 * 2)
            out = ' ' * (indent * 4) + "self.mu.reg_write(UC_ARM_REG_SP, 0x7fffff00)\n"
            
        elif self.arch == 'arm64':    
            self.add_mmap(0x7ffff000, 1024*1024 * 2)
            out = ' ' * (indent * 4) + "self.mu.reg_write(UC_ARM64_REG_SP, 0x7fffff00)\n"
            
        ## TODO Add support for other architectures supported by Unicorn and Binja 
        else:
            print ("[ripr] Error, Unsupported Architecture")
        return out

    
    def generate_mem_writes(self, indent = 1):
        out = ''
        for i in range(0, len(self.data)):
            out += ' ' * (indent * 4) + "self.mu.mem_write(%s, self.data_%s)\n" % (hex(self.data[i][0]), i)
        for i in range(0, len(self.code)):
            out += ' ' * (indent * 4) + "self.mu.mem_write(%s, self.code_%s)\n" % (hex(self.code[i].address), i)
        return out
       
    def generate_emuinit(self, indent = 1):
        '''
            Decide how to initialize the emulator based on CPU Architecture.
        '''
        if self.arch == "x86":
            return ' ' * (indent * 4) + "self.mu = Uc(UC_ARCH_X86, UC_MODE_32)\n"
        # TODO Support Other Archs
        elif self.arch == "x64":
            return ' ' * (indent * 4) + "self.mu = Uc(UC_ARCH_X86, UC_MODE_64)\n"
            
        elif self.arch == "arm":
            return ' ' * (indent * 4) + "self.mu =  Uc(UC_ARCH_ARM, UC_MODE_ARM)\n"
        
        elif self.arch == "arm64":
            return ' ' * (indent * 4) + "self.mu = Uc(UC_ARCH_ARM64, UC_MODE_ARM)\n"
            
            
    def generate_emustart(self, indent = 1):
        out = ' ' * (indent * 4) + "try:\n"
        out +=  ' ' * ((indent + 1) * 4) + "self.mu.emu_start(startaddr, 0)\n"
        out += ' ' * (indent * 4) + "except Exception as e:\n"

        if self.isFunc:
            out += self.generate_return_guard(indent=indent+1)
        else:
            out += self.generate_hook_lookup(indent=indent+1)

        return out

    def generate_start_unicorn_func(self, indent = 1):
        '''
            This function wraps starting the unicorn emulator and dealing with exceptions if applicable.
        '''
        decl = ' ' * (indent * 4) + 'def _start_unicorn(self, startaddr):\n' 
        body = self.generate_emustart(indent=2)
        return decl+body+"\n"

    def generate_return_guard_marker(self, indent=1):
        '''
            Generate code that will result in the emulator returning to a marker value at the end of a 
            successfull function emulation. This is caught by code in generate_return_guard and indicates
            that the function behaved normally.
        '''
        out = ''
        if self.arch in ['x86', 'x64']:
            out += ' ' * (indent *4) + "self.mu.mem_write(0x7fffff00, '\\x01\\x00\\x00\\x00')\n"
        elif self.arch == 'arm':
            out += ' ' * (indent *4) + "self.mu.reg_write(UC_ARM_REG_LR, 0x4)\n"
        elif self.arch == 'arm64':
            out += ' ' * (indent *4) + "self.mu.reg_write(UC_ARM64_REG_LR, 0x4)\n"
        else:
            print ("Unsupported Arch")
        return out

    def generate_restore_exec(self, indent=1):
        '''
            Generate code that will adjust the cpu context so it matches expected behaviour after
            a hooked call.
        '''
        out = ''
        if self.arch == 'x64':
            out += ' ' * (indent * 4) + "self.mu.reg_write(UC_X86_REG_RSP, self.mu.reg_read(UC_X86_REG_RSP) + 8)\n"
            out += ' ' * (indent * 4) + "self._start_unicorn(retAddr)\n"
        elif self.arch == 'x86':
            out += ' ' * (indent * 4) + "self.mu.reg_write(UC_X86_REG_ESP, self.mu.reg_read(UC_X86_REG_ESP) + 4)\n"
            out += ' ' * (indent * 4) + "self._start_unicorn(retAddr)\n"
        elif self.arch == 'arm':
            out += ' ' * (indent * 4) + "self._start_unicorn(retAddr)\n"
            pass
        elif self.arch == 'arm64':
            out += ' ' * (indent * 4) + "self._start_unicorn(retAddr)\n"
            pass
        else:
            print ("Unsupported Arch")

        return out

    def generate_hook_lookup(self, indent=1):
        if self.arch == 'x64':
            retAddr = ' ' * (indent * 4) + "retAddr = struct.unpack(\"<q\", self.mu.mem_read(self.mu.reg_read(UC_X86_REG_RSP), 8))[0]\n"
        elif self.arch == 'x86':
            retAddr = ' ' * (indent * 4) + "retAddr = struct.unpack(\"<i\", self.mu.mem_read(self.mu.reg_read(UC_X86_REG_ESP), 4))[0]\n"
        elif self.arch == 'arm':
            retAddr = ' ' * (indent * 4) + "retAddr = self.mu.reg_read(UC_ARM_REG_LR)\n"
        elif self.arch == 'arm64':
            retAddr = ' ' * (indent * 4) + "retAddr = self.mu.reg_read(UC_ARM64_REG_LR)\n"

        else:
            print ("Unsupported Architecture")
            retAddr = ' ' * (indent * 4) + "retAddr = 0\n"
            
        chk_hookdict = ' '  * (indent * 4) + "if retAddr in self.hookdict.keys():\n"
        getattr_call = ' ' * ( (indent+1) * 4) + "getattr(self, self.hookdict[retAddr][0])()\n"

        restore = self.generate_restore_exec(indent=indent+1)
        return retAddr + chk_hookdict + getattr_call + restore

    def generate_return_guard(self, indent=1):
        '''
            Generate code to catch the "crash" that will happen after a packaged function hits a 
            ''return'' instruction or imported call. 
            We use 0x1 as a marker to say the function has hit a return as expected.
        '''
        out = ''
        if (self.arch == 'x64'):
            out += ' ' * (indent * 4) + "if self.mu.reg_read(UC_X86_REG_RIP) == 1:\n"
        elif (self.arch == 'x86'):
            out += ' ' * (indent * 4) + "if self.mu.reg_read(UC_X86_REG_EIP) == 1:\n"
        elif (self.arch == 'arm'):
            out += ' ' * (indent * 4) + "if self.mu.reg_read(UC_ARM_REG_PC) == 4:\n"
        else:
            print ("[ripr] Unsupported Arch...")
        
        # Return if PC has landed on the marker value
        out += ' ' * ((indent + 1) * 4) + "return\n"
        
        # Check if this crash is the result of an imported Call and execute the hook if applicable
        if (self.impCallTargets):
            out += self.generate_hook_lookup(indent=indent)

        # Raise original exception if PC is not equal to the appropriate marker value or imported call marker
        out += ' ' * (indent * 4) + "else:\n"
        if self.callConv is not None:
            out += self.callConv.dumpContext(indent+1)
        out += ' ' * ((indent+1) * 4) + "raise e"

        return out + "\n\n"

    def generate_return_conv(self, indent=1):
        '''
            Generate code for the ''return-value recovery'' convenience pass. 
            The 'run()' function will return whatever the architecture specific return register typically
            is rather than requiring the user to manually query the emulator state.
        '''
        if self.arch == 'x64':
            return ' ' * (indent * 4) + "return self.mu.reg_read(UC_X86_REG_RAX)\n"
        elif self.arch == 'x86':
            return ' ' * (indent * 4) + "return self.mu.reg_read(UC_X86_REG_EAX)\n"
        elif self.arch == 'arm':
            return ' ' * (indent * 4) + "return self.mu.reg_read(UC_ARM_REG_R0)\n"
        elif self.arch == 'arm64':
            return ' ' * (indent * 4) + "return self.mu.reg_read(UC_ARM64_REG_X0)\n"
        else:
            print ('[ripr] Unsupported Arch')

    def generate_run_with_args(self, indent=1):
        decl = ' ' * 4 + "def run(self"
        args = self.conPass['args']
        for i in range(0, len(args)):
            decl += ", arg_%x" % i
        decl += '):\n'
        
        return decl+"\n"
                
    def generate_fill_in_args(self, indent=1):
        decl = ''
        args = self.conPass['args']
        # TODO Determine calling convention/Platform
        if self.arch == 'x64':
            cc = x64callConv("linux", "x64")
            for i in range(0, len(args)):
                decl += cc.gen_arg_number(args[i], indent)
        elif self.arch == 'x86':
            cc = x86callConv("linux", "x86")
            for i in range(0, len(args)):
                decl +=  cc.gen_arg_number(args[i], indent)
        elif self.arch == 'arm':
            cc =armcallConv("linux", "arm")
            for i in range(0, len(args)):
                decl += cc.gen_arg_number(args[i], indent)
        elif self.arch == 'arm64':
            cc =armcallConv("linux", "arm")
            for i in range(0, len(args)):
                decl += cc.gen_arg_number(args[i], indent)
        return decl 
   
    def generate_run_functions(self, indent = 1):
        out = ''
        if 'args' in self.conPass.keys():
            decl = self.generate_run_with_args()
        else:
            decl = ' ' * 4 + "def run(self):\n"

        stk = self.generate_stack_initialization(indent=2)
        initArgs = ''
        if 'args' in self.conPass.keys():
            initArgs = self.generate_fill_in_args(indent=2)

        if self.isFunc:
            marker = self.generate_return_guard_marker(indent=2)
        else:
            marker = ''

        emus = ' ' * ((indent) * 4) + "self._start_unicorn(%s)\n" % (hex(self.startaddr))

        out += decl + stk + marker + initArgs + emus
        # Check for return value recovery convenience 
        if (self.conPass['ret'] == True):
            out += self.generate_return_conv(indent=2)

        return out+"\n"

    def imp_consts(self):
        '''
            Return an import string depending on what arch you are using.
        '''
        if self.arch in ('x86', 'x64'):
            return "from unicorn.x86_const import *\n\n"
        elif self.arch == 'arm':
            return "from unicorn.arm_const import *\n\n"
        elif self.arch == 'arm64':
            return "from unicorn.arm64_const import *\n\n"
        elif self.arch in ('mips32', 'mips64'):
            return "from unicorn.mips_const import *\n\n"
        elif self.arch in ('m68k'):
            return "from unicorn.m68k_const import *\n\n"
        elif self.arch in ('sparc'):
            return "from unicorn.sparc_const import *\n\n"
            
    # Code "Builders"
    
    def generate_default_hookFunc(self, name, indent=1):
        '''
            The default python hook for imported calls should do nothing.
        '''
        out = ' ' * (indent * 4) + """def hook_%s(self):
        print ("[!] %s hook not implemented!")
        pass\n\n""" % (name, name)
        return out
        
    def _build_impCall_hook_dict(self, indent=1):
        '''
            Build a dictionary of return address --> hook function for dynamic
            imported call handling. 
        '''
        
        ret = ''
        out = {}
        instlen = {}
        build_funcs = []
        # Get a list of names for hook functions
        for impCall in self.impCallTargets:
            if str(impCall.symbol) not in build_funcs:
                build_funcs.append(str(impCall.symbol))
            
            out[impCall.address+impCall.inst_len] = "['hook_%s',%d]" % (str(impCall.symbol),impCall.inst_len)
            
        # Generate stubs for the hooked functions
        for func in build_funcs:
            ret += self.generate_default_hookFunc(func)

        return (ret, out)

    def generate_hookdict(self, hookd, indent=1):
        hookstr="self.hookdict = {"
        for hook in hookd:
            hookstr+="0x%x: %s," % (hook,hookd[hook])
        hookstr=hookstr[:-1]+"}\n"
        return ' ' * (indent * 4) + hookstr

    def generate_unset_var_comments(self):
        out = '# Variables listed below should be filled in: \n'
        vs = self.conPass['unset_vars']
        for v in vs:
            out += "# %s %s --> %s \n" % (v.var.type, v.var, v.srcOperation)
        return out

    def generate_class(self):
        global python2
        '''
            Wrap this chunk of code into a python class
        '''
        self.code = sorted(self.code, key=lambda x: x.address)
        
        comments = ''
        if "unset_vars" in self.conPass.keys():
            comments += self.generate_unset_var_comments()
        # Static Strings
        if python2:
            name=self.name
        else:
            name=self.name.decode('utf-8')
        defn = "class %s(object):\n" % name
        imp = "from unicorn import *\n" + self.imp_consts() + "import struct\nimport binascii\n"
        
        init = ' ' * 4 + "def __init__(self):\n"
        run = ' ' * 4 + "def run(self):\n"
        
        # Dyanmic Strings
        emuinit = self.generate_emuinit(indent = 2)
        codevars = self.generate_code_vars(indent = 2)
        datavars = self.generate_data_vars(indent = 2)

        # Generate run function 
        runfns = self.generate_run_functions(indent=2) 

        if (self.impCallTargets):
            # Build list of Return Addresses to Hooked Functions
            hooks = self._build_impCall_hook_dict()
            hookdict = self.generate_hookdict(hooks[1], indent=2)
            hooks = hooks[0]
        else:
            hooks = ''
            hookdict = ''
        
        hookdict=hookdict

        # mmaps and writes must be generated at the end
        mmaps = self.generate_mmap(indent = 2)
        writes = self.generate_mem_writes(indent = 2)

        start_unicorn = self.generate_start_unicorn_func()
        
        argf=""
        if "args" in self.conPass.keys():
            for i in range(0,len(self.conPass['args'])):
                argf+="0,"
            argf=argf[:-1]
        
        # Put the pieces together
        self.final = comments + imp + defn + init + emuinit + codevars + datavars + mmaps + writes \
                      + hookdict + "\n" + hooks + start_unicorn + runfns + "\n" + ("x = %s()" % name) \
                     +"\n"+"print (x.run("+argf+"))\n"


```

`conScan.py`:

```py
try:
    from binaryninja import *
except:
    print ("[!!] Not running in Binary Ninja")
try:
    import r2pipe
except:
    print ("[!!] Not running in Radare2")

from .analysis_engine import *

class ilVar(object):
    def __hash__(self):
        return self.var.__hash__()

    def __eq__(self, other):
        return self.var == other.var

    def __init__(self, var, mil):
        self.var = var
        self.mil = mil
        
        self.reg = None
        self.srcOperation = None
        try:
            r = self.mil.low_level_il
            while(hasattr(r, 'src')):
                r = r.src

            self.srcOperation = r

            for op in r.operands:
                if op.operation in [LowLevelILOperation.LLIL_REG,\
                                    LowLevelILOperation.LLIL_REG_SSA]:
                    self.reg = op.tokens[0]
                    break
        except:
            pass

class riprArg(object):
    def __init__(self, _type, num):
        self.type = _type
        self.num = num
        self.pointerDepth = str(self.type).count("*")

class convenienceScanner(object):
    def __init__(self, engine):
        self.engine = engine

    def argIdent(self, addr, isFunc):
        if (isinstance(self.engine, radare2_engine)):
            print ("Unsupported!")
            return None

        fobj = self.engine.bv.get_functions_containing(addr)
        if len(fobj) > 1:
            print ("[ripr] Cannot get arguments, multiple functions contain address!")
            return None

        fobj = fobj[0]
        if (isFunc):
            ret = []
            ftype = fobj.function_type
            for i in range(0, len(ftype.parameters)):
                arg = ftype.parameters[i]
                ret.append(riprArg(arg.type, i))

            return ret
            
    def uninit_vars(self, bbs):
        for bb in bbs:
            mlb = self.engine.find_mlil_block_from_addr(list(bb.keys())[0]) 
            if mlb == None:
                continue
            set_vars = []
            unset_vars = []
            for il in mlb:
                for v in il.vars_written:
                    set_vars.append(v)    
                for v in il.vars_read:
                    if v not in set_vars:
                        unset_vars.append(ilVar(v, il))

            unset_vars = set(unset_vars)
            for uVar in unset_vars:
                self.engine.highlight_instr(list(bb.keys())[0], uVar.mil.address, "orange") 

            return unset_vars

```

`dependency.py`:

```py
'''
    Code in this file deals with finding data and/or other code that must be 
    included in the emulation environment for the target code to be able to run
    properly.
'''

from .analysis_engine import aengine as ae
# Try to import stuff.
try:
    from binaryninja import *
except:
    print ("[!!] Not running in Binary Ninja")
try:
    import r2pipe
except:
    print ("[!!] Not running in Radare2")


class ImportedCall(object):
    '''
        Convenience class for storing information about imported Calls.
    '''
    def __init__(self, address, instlen, target, symname):
        self.address = address
        self.inst_len = instlen
        self.target = target
        self.symbol = symname

class riprDataRef(object):
    '''
        Convenience class for storing information on data references we find.
    '''
    def __init__(self, address, length, _type):
        self.address = address
        self.length = length
        self._type = _type

class riprCodeRef(object):
    def __init__(self, address, _type):
        self.address = address
        self.type = _type

class depScanner(object):
    def __init__(self, engine, codeobj):
        self.engine = engine
        self.codeobj = codeobj

        self.impCalls = []
        self.dataRefs = []
        self.codeRefs = []
        
        self.imports = self.engine.get_imports()

    def _mark_imported_call(self, func_addr, address, target):
        '''
            Create an ImportedCall object for possible later use in "python-hooking"
            Note: We /do/ want duplicates (multiple ImportedCall objects for "puts" for example)
            as we map expected return addresses to our hooked functions.
        '''
        self.engine.highlight_instr(func_addr, address, "red")
        self.engine.add_comment(func_addr, address, "Imported Call !!")

        symname = str(target)
        if target in self.imports.keys():
            symname = self.imports[target]
        
        icall = ImportedCall(address, self.engine.get_instruction_length(address), target, symname)
        self.impCalls.append(icall) 

    def _mark_additional_branch(self, func_addr, address, destination, _type):
        ref = riprCodeRef(destination, _type)
        self.engine.highlight_instr(func_addr, address, "blue")
        self.codeRefs.append(ref)

    def _mark_identified_data(self, func_addr, ref_addr):
        self.engine.highlight_instr(func_addr, ref_addr, "yellow")
    
    def branchScan(self, address, isFunc=True):
        '''
            Function is responsible for mapping calls and jumps
            that are outside the current selection's bounds, if possible.
        '''
        print ("[ripr] Inside branchScan")
        def callCallback(dest, instr_addr):
            if type(dest) != int:
                try:
                    dest = dest.value
                except:
                    return
            if (dest in self.imports):
                print ("[ripr] Found imported Call target...")
                self._mark_imported_call(address, instr_addr, dest)

            elif  (self.codeobj.data_saved(dest) == False):
                print ("[ripr] Found LLIL CALL instruction")
                self._mark_additional_branch(address, instr_addr, dest, "call")
            else:
                print ("[ripr] Target address already mapped")

        def jumpCallback(dest, instr_addr):
            print ("[ripr] JUMP TARGET: %s" % (dest))

        if isFunc:
            self.engine.branches_from_func(address, callCallback, jumpCallback)
        else:
            ibb = self.engine.find_llil_block_from_addr(address)
            if ibb == None:
                return self.codeRefs
            self.engine.branches_from_block(ibb, callCallback, jumpCallback)
        return self.codeRefs

    def _find_stringRefs(self, address):
        '''
            Look for strings that are referenced in the selected code.
        '''

        ret = []
        for stringStart,stringLength in self.engine.get_strings():
            for refAddress  in self.engine.get_refs_to(stringStart): # Ignored the length
                if (self.engine.function_contains_addr(address, refAddress)):
                    print ("[ripr] Found string reference: 0x%x" % (refAddress))
                    self._mark_identified_data(address, refAddress)
                    dref = riprDataRef(stringStart, stringLength, 'str')
                    self.dataRefs.append(dref)
        return ret
        
    def _find_symbolRefs(self, address):
        '''
            Look for data symbols that are referenced in the selected code.
        '''
        ret = []
        symbols = self.engine.get_data_symbols()
        for symStart in symbols:
            for refAddress in self.engine.get_refs_to(symStart):
                if self.engine.function_contains_addr(address, refAddress):
                    print ("[ripr] Found Symbol Reference: 0x%x references 0x%x" % (refAddress, symStart))
                    self._mark_identified_data(address, refAddress)
                    dref = riprDataRef(symStart, -1, 'sym')
                    self.dataRefs.append(dref)
                    ret.append(symStart)
        return ret

    def _simpleDataScan(self, address):
        ret = []
        ret += self._find_stringRefs(address)
        ret += self._find_symbolRefs(address)
        return ret

    def dataScan(self, address):
        '''
            Function is responsible for finding data the target code
            needs in order to run correctly.
        '''
        print ("[ripr] Inside dataScan")
        ret = []
        
        # Find the low-hanging fruit
        ret += self._simpleDataScan(address)

        # Iterate over all instructions for potential pointers
        for target, instrAddr in self.engine.scan_potential_pointers(address):
            if self.engine.is_plausible_pointer(target):
                print ("Found Potential Pointer: %s instaddr %s" % (hex(target), hex(instrAddr)))
                self._mark_identified_data(address, instrAddr)
                dref = riprDataRef(target, -1, 'ptr')
                self.dataRefs.append(dref)
                ret.append(target)

        return set(ret)


```

`gui.py`:

```py
'''
    UI Functionality is implemented here.
'''
import sys
if (sys.platform == 'win32'):
    if sys.version_info[0] >= 3:
        sys.path.append("C:\\Python37\\lib\\site-packages\\PyQt5")
    else:
        sys.path.append("C:\\Python27\\lib\\site-packages\\PyQt5")
try:
    from PyQt5 import QtWidgets, QtGui, QtCore
    from PyQt5.QtCore import Qt
    from .defunct.widgets import BinjaWidget
    from .defunct.widgets import *
    qtAvailable = True
except:
    qtAvailable = False

from binaryninja import *

try:
    class riprTable(QtWidgets.QTableWidget):
        '''
            Handle all QTable related code here to keep the main GUI
            class relatively clean.
        '''
        def __init__(self, emuchunks, parent=None):
            super(riprTable, self).__init__()
            self.setContextMenuPolicy(Qt.DefaultContextMenu)
            self.emuchunks = emuchunks
            
            self.setColumnCount(3)
            self.setHorizontalHeaderLabels(['Name', 'Start Address', 'End Address'])
            self.horizontalHeader().setStretchLastSection(True)
            self.verticalHeader().setVisible(False)
        
        def _get_selected_codeobj(self):
            '''
                selectedIndexes returns a QModelIndex that is passed to the QtreeWidget
                which we get the QTreeWidgetItem from, which finally gets us the class name,
                which we can get the codeobj from.
            '''
             # Grab the "Index" that is selected
            item = self.triggeredIndex
            # Find the Class name from the index
            name = self.item(item.row(), item.column()).text()
            # Open the Editor
            print ("Selected Codeobj: %s" % name)
            return self.emuchunks[name]
    
        def contextMenuEvent(self, event):
            index = self.indexAt(event.pos())
            
            self.triggeredIndex = index
            menu = QtWidgets.QMenu()
            menu.addAction("Save to File", self._saveCode)
            menu.addAction("Map Address", self._addMmap)
            menu.exec_(event.globalPos())
    
        def _addMmap(self):
            codeobj = self._get_selected_codeobj()
            addr = QtWidgets.QInputDialog().getText(self, "Binary Ninja - ripr", "Enter Address (hex)")
            try:
                addr = int(addr[0], 16)
            except: # Show error
                return 
            codeobj.add_mmap(addr)
    
        def _addData(self):
            pass
    
        def _saveCode(self):
            codeobj = self._get_selected_codeobj()
            dialog = QtWidgets.QFileDialog(None, None)
            dialog.setFileMode(QtWidgets.QFileDialog.AnyFile)
            if dialog.exec_():
                fileNames = dialog.selectedFiles()
                if len(fileNames) > 0:
                    f = open(fileNames[0], 'wb')
                    f.write(codeobj.final)
                    f.close() 
except:
    pass

try:
    class riprWidget(BinjaWidget):
        '''
            riprWidget uses BinjaDock to display its essential information.
            "Helper" Functions are also defined here for simplicity
        '''
        def __init__(self, emuchunks=None):
            self.qtAvailable = qtAvailable
            if not qtAvailable:
                return
            super(riprWidget, self).__init__('ripr')
            self.emuchunks = emuchunks
            self._table = riprTable(emuchunks=emuchunks)
    
            self.setLayout(QtWidgets.QStackedLayout())
            self.layout().addWidget(self._table)
            self.setObjectName('BNPlugin_ripr')
    
        def update_table(self, emuchunks):
            '''
                This function updates the table with new code objects received from the packager
                at the end of a "ripping" process.
            '''
            if (not self.qtAvailable):
                return
            self._table.setRowCount(len(emuchunks))
            self._table.emuchunks = emuchunks
            row = 0
            for chunkName in emuchunks:
                nameField =  QtWidgets.QTableWidgetItem(chunkName)
                nameField.setFlags(Qt.ItemIsEnabled)
    
                startAddr = QtWidgets.QTableWidgetItem('0x%.8x' % emuchunks[chunkName].startaddr)
                startAddr.setFlags(Qt.ItemIsEnabled)
    
                endAddr = QtWidgets.QTableWidgetItem('0x%.8x' % (int(emuchunks[chunkName].startaddr) + int(emuchunks[chunkName].codelen)))
                endAddr.setFlags(Qt.ItemIsEnabled)
                
                self._table.setItem(row, 0, nameField)
                self._table.setItem(row, 1, startAddr)
                self._table.setItem(row, 2, endAddr)
                row += 1
            
            self._core.show()
            self._core.selectTab(self)
            self.show()
    
    
        ### Convenience wrappers for some frequently used things
        def save_file(self, codeobj):
            fname = interaction.get_save_filename_input("[ripr] Save output")
            if fname == None:
                return
            f = open(fname, "w+")
            f.write(codeobj.final)
            f.close()
    
    
        def yes_no_box(self, msg):
            choice = interaction.show_message_box("Binary Ninja - ripr", msg, enums.MessageBoxButtonSet.YesNoButtonSet)
            if choice == enums.MessageBoxButtonResult.YesButton:
                return True
            return False

        def msgBox(self, msg):
            interaction.show_message_box("Binary Ninja - ripr", msg, enums.MessageBoxButtonSet.OKButtonSet)

    
        def text_input_box(self,msg):
            text = interaction.get_text_line_input(msg, "Binary Ninja - ripr")
            return text
    
        def impCallsOptions(self):
            msg="Code contains calls to imported functions. How should this be handled?"
            choice = interaction.get_choice_input(msg, "", ["Hook Calls", "Nop Out Calls", "Cancel"])
            if choice == 0:
                return "hook"
            if choice == 1:
                return "nop"
            if choice == 2:
                return "cancel"
except:
    # TODO Clean up/remove duplicated code
    class riprWidget(object):
        def __init__(self):
            self.qtAvailable = False
            return
        
        def update_table(self, emuchunks):
            return
        
        def save_file(self, codeobj):
            fname = interaction.get_save_filename_input("[ripr] Save output")
            if fname == None:
                return
            f = open(fname, "w+")
            f.write(codeobj.final)
            f.close()
        
        def yes_no_box(self, msg):
            choice = interaction.show_message_box("Binary Ninja - ripr", msg, enums.MessageBoxButtonSet.YesNoButtonSet)
            if choice == enums.MessageBoxButtonResult.YesButton:
                return True
            return False
        
        def msgBox(self, msg):
            interaction.show_message_box("Binary Ninja - ripr", msg, enums.MessageBoxButtonSet.OKButtonSet)

        def text_input_box(self,msg):
            text = interaction.get_text_line_input(msg, "Binary Ninja - ripr")
            return text
    
        def impCallsOptions(self):
            msg="Code contains calls to imported functions. How should this be handled?"
            choice = interaction.get_choice_input(msg, "", ["Hook Calls", "Nop Out Calls", "Cancel"])
            if choice == 0:
                return "hook"
            if choice == 1:
                return "nop"
            if choice == 2:
                return "cancel"
    pass

```

`packager.py`:

```py
from .codegen import *
from .analysis_engine import aengine as ae
from .dependency import depScanner
from .conScan import convenienceScanner

### Global for listing all chunks of code for which we have tried to create a python wrapper.
emuchunks = {}
    
# List of basic block chunks to package for BB mode
bbChunks = []
class Packager(object):
    '''
        Packager does the work of getting a codegen object
        the information it needs for creating a suitable emulation environment.
    '''
    def __init__(self, isFunc, address, engine, ui = None, length=None):  
        self.isFunc = isFunc
        self.address = address
        self.length = length
        self.engine = engine
        self.ui = ui
        #self.ui.emuchunks = emuchunks

        # List of Contiguous code we're interested in
        self.targetCode = []
        
        self.codeobj = genwrapper('', isFunc)
        self.arch = self.engine.get_arch()
        self.codeobj.setArch(self.arch)

        self.impCallStrategy = None
        self.dataStrategy = None

        self.codeobj.startaddr = int(self.address)
        if (self.length != None):
            self.codeobj.codelen = length

    def convenience_passes(self):
        '''
            This function is a wrapper for determining which convenience features can 
            be enabled during code generation.
        '''
        c = convenienceScanner(self.engine)
        if (self.isFunc == True and self.codeobj.arch in ['x64', 'x86', 'arm']):
            self.codeobj.conPass['ret'] = True

        args = None
        if (self.isFunc):
            if self.ui.yes_no_box("Attempt to automatically fill in function arguments?"):
                args = c.argIdent(self.address, self.isFunc)
                if args:
                    self.codeobj.conPass['args'] = args

        if not self.isFunc:
            self.codeobj.conPass['unset_vars'] = c.uninit_vars(bbChunks) 

    def minimal_package_function(self, address=None):
        '''
            Adds basic information to CodeGen when packaging a function.
        '''
        if (address == None):
            address = self.address
        # Get the code to be emulated
        localCode = self.engine.get_function_bytes(address=address)
        if (localCode == None):
            self.ui.msgBox("[ripr] Couldn't get function binary view. Maybe code arch is thumb2?")
            return False
        # Add each contiguous chunk of code to codeobj and make sure
        # it will be mapped.
        for startAddr in list(localCode.keys()):
            self.codeobj.add_mmap(startAddr)
        
        self.targetCode.append(localCode)
        return True
        
    def minimal_package_region(self):
        targetCode = self.engine.get_region_bytes(address=self.address)
        self.codeobj.add_data(targetCode[0], targetCode[1])
        self.codeobj.add_mmap(targetCode[0])

    def minimal_package_bb(self, address=None):
        if (address == None):
            address = self.address
        targetCode = self.engine.get_basic_block_bytes(address)
        self.engine.mark_gathered_basic_block(address)

        bbChunks.append(targetCode)
        

    def package_function(self):
        '''
            This method handles filling in as much relevant information as possible into our current instance of codeobj
            about the function to be emulated. It is a high-level encapsulation of multipe packaging and analysis methods.
        '''
        self.codeobj.name = self.ui.text_input_box("Enter Class Name")
        if not self.codeobj.name:
            return 
        # Get the bare minimum required information.
        if (self.minimal_package_function()==False):
            return

        # Try to find dependencies of our code.
        self.resolve_dependencies()

        # Figure out if we can add any convenience methods to our generated code
        self.convenience_passes()

        # Add gathered information to the code object.
        self.update_codeobj()

        # Add the codeobj to the global storage for listing in the UI (if available)
        emuchunks[self.codeobj.name] = self.codeobj
        self.ui.update_table(emuchunks)

        # Generate what we currently have and show the results
        self.codeobj.generate_class()
        self.engine.display_info("Generated Code: %s" % self.codeobj.name, self.codeobj.final)
        if not self.ui.qtAvailable:
            self.ui.save_file(self.codeobj) 

    def package_bb(self):
        '''
            This method adds an entry to bbChunks, which can be used later to 
            generate a package containing only user-specified basic blocks.
        '''
        self.minimal_package_bb()


    def generate_bb_code(self):
        global bbChunks
        if len(bbChunks) == 0:
            self.ui.msgBox("Basic Block package list is empty!")
            return
        self.codeobj.name = self.ui.text_input_box("Enter Class Name")
        if not self.codeobj.name:
            return
        # Set starting address to first basic block selected
        self.codeobj.startaddr = list(bbChunks[0].keys())[0]

        self.targetCode = bbChunks

        self.resolve_dependencies()

        self.convenience_passes()

        self.update_codeobj()
        
        # Clean up our modifications
        self.cleanup_basic_blocks()
        bbChunks = []

        self.codeobj.generate_class()
        self.engine.display_info("Generated Code: %s" % self.codeobj.name, self.codeobj.final)

        self.ui.save_file(self.codeobj)
    
    def cleanup_basic_blocks(self):
        global bbChunks
        for bb in bbChunks:
            self.engine.clean_gathered_basic_block(list(bb.keys())[0])
        

    def package_region(self):
        '''
            This method handles filling in as much information as possible about the target region to be emulated.
        '''
        self.minimal_package_region()

        self.resolve_dependencies()

        self.convenience_passes()

    def _find_code_unit(self, faddr):
        for found_code in self.targetCode:
            for addr in found_code:
                codeLen = len(found_code[addr].code_bytes)
                if ( (faddr >= addr) and (faddr <= addr + codeLen)):
                    return found_code[addr]

    def _nop_impFunc(self, impCalls):
        for impCall in impCalls:
            print ("[ripr] Nopping out Imported Call: 0x%x" % (impCall.address))
            cSlice = self._find_code_unit(impCall.address)

            codeLen = len(cSlice.code_bytes)
            nop = self.engine.get_nop_opcode()
            
            if (impCall.inst_len % len(nop) != 0):
                print ("[ripr] Cannot NOP out instruction...")
                return

            # Create string of NOP opcodes and calculate where to place it
            nopStr = nop * (impCall.inst_len / len(nop))
            first = impCall.address - cSlice.address
            second = first + len(nopStr)

            newCode = cSlice.code_bytes[0:first] + nopStr + cSlice.code_bytes[second:]
            cSlice.code_bytes = newCode


    def update_codeobj(self):
        # targetCode[0] corresponds to the dict of code units for the original function
        # in the case of others being automatically mapped as dependencies
        
        localCode = self.targetCode[0]
        print (self.targetCode)
        self.codeobj.codelen = sum([len(localCode[x].code_bytes) for x in list(localCode.keys())])
        for found_code in self.targetCode:
            for addr in found_code:
                self.codeobj.add_code(found_code[addr])


    def resolve_imported_calls(self, resolv):
        print ("[ripr] Selection includes calls to imported Functions!")
        if self.impCallStrategy == None:
            self.impCallStrategy = self.ui.impCallsOptions()
        
        if self.impCallStrategy == 'nop':
            self._nop_impFunc(resolv.impCalls)
        elif self.impCallStrategy == 'hook':
            self.codeobj.impCallTargets += resolv.impCalls
        else:
            return

    def map_dependent_pages(self, dataRefs):
        pagesize = self.engine.get_page_size()
        pages = []
        
        for ref in dataRefs:
            pageaddr = (ref.address & ~(pagesize - 1))
            pages.append(pageaddr)

        pages = set(pages)
        for page in pages:
            self.codeobj.add_data(self.engine.get_page_bytes(page), page)
            self.codeobj.add_mmap(page)

    def map_dependent_sections(self, dataRefs):
        '''
            Map any sections the target code touches.
        '''
        print ("Mapping Sections")
        pagesize = self.engine.get_page_size()
        secs = []
        
        for ref in dataRefs:
            section=self.engine.find_section(ref.address)
            if section!=-1:
                secs += [section]

        for sec_start, sec_end, sec_name in secs:
            self.codeobj.add_data(self.engine.read_bytes(sec_start, sec_end - sec_start), sec_start)
            self.codeobj.add_mmap(sec_start)

    def map_minimal_data(self, dataRefs):
        '''
            Attempt to only map the exact data the target code uses.
        '''
        pass

    def resolve_data_dependencies(self, dataRefs):
        '''
            This function handles finding data that needs to get mapped.
        '''
        if (self.dataStrategy == None):

            '''
            Page marking mode usually works better out of the box for small-medium size ARM
            binaries because the "dispatch code" for imported calls is not packaged
            as a dependency automatically. 
            
            This results in scenarios where unicorn will keep executing and 'fall through'
            a call to an imported function instead of crash-landing on the 
            "imported function" hook. 

            Page-Marking mode will often package these stubs up as a side effect; making it a 
            better default until this case is handled corretly.
            '''
            if self.codeobj.arch == 'arm':
                if (self.ui.yes_no_box("Use Page-Marking Mode for data dependencies (default: yes)")):
                    self.dataStrategy = "page"
                else:
                    self.dataStrategy = "section"
            else:

                if (self.ui.yes_no_box("Use Section-Marking Mode for data dependencies (default: yes)")):
                    self.dataStrategy = "section"
                else:
                    self.dataStrategy = "page"
        
        if (self.dataStrategy == "section"):
            self.map_dependent_sections(dataRefs)
        else:
            self.map_dependent_pages(dataRefs)

    def resolve_codeRefs(self, coderefs):
        for ref in coderefs:
            print ("Found CodeRef: %x::%s" % (ref.address, ref.type))
            if (ref.type == 'call'):
                if (self.minimal_package_function(address=ref.address)==False):
                    continue
                self.resolve_dependencies(address=ref.address, isFunc=True)

    def resolve_dependencies(self, address=None, isFunc=None):
        '''
            This method is a high-level wrapper for finding data our target code depends on.
        '''
        resolv = depScanner(self.engine, self.codeobj) 
        if (address == None):
            address = self.address 

        if (isFunc == None):
            isFunc = self.isFunc

        print ("Resolving Dependencies for %x" % address)
        if isFunc:
            coderefs = resolv.branchScan(address, self.isFunc)
            datarefs = resolv.dataScan(address)
        else:
            datarefs = resolv.dataScan(address)
            coderefs = []
            for bb in bbChunks:
                coderefs += resolv.branchScan(list(bb.keys())[0], self.isFunc) 

        if (resolv.impCalls != []):
            self.resolve_imported_calls(resolv) 

        if (coderefs != []):
            if (self.ui.yes_no_box("Target code may depend on outside code, attempt to map automatically?") == True):
                print ("[ripr] Performing analysis on code dependencies...")
                self.resolve_codeRefs(coderefs)
            else:
                pass

        if (resolv.dataRefs != []):
            # Try to map these automatically
            print ("[ripr] Found these potential Data References")
            for ref in resolv.dataRefs:
                print ("Data Referenced: 0x%x" % (ref.address))
            self.resolve_data_dependencies(resolv.dataRefs)
            pass

```

`plugin.json`:

```json
{
    "name": "ripr",
    "author": "Patrick Biernat",
    "api": ["python3"],
    "description": "Package binary code as a Python class backed by Unicorn-Engine",
    "license": {
        "name": "MIT",
        "text": "MIT License Copyright (c) 2022 Patrick Biernat Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE." 
        	},
    "longdescription": "",
    "minimumbinaryninjaversion": 3469,
    "platforms": [
      "Windows",
      "Linux"
     ],
    "type": ["helper"],
    "installinstructions": {
        "Windows": "See 'Installation' section in README.md for manual installation instructions",
        "Linux": "See 'Installation' section in README.md for manual installation instructions"
    },
    "pluginmetadataversion":2,
    "version": "v1.1.1"
}

```

`r2pipe_run.py`:

```py
import sys

# ripr imports
from .analysis_engine import *
from .codegen import *
from .packager import *
from .cli_ui import *

def packageFunction(addr):
    print ("[ripr] Packaging function {}".format(hex(addr)))
    engine = get_engine(addr)
    ui = cli_ui.cli_ui()
    pkg = Packager(isFunc=True, address=addr, engine=engine, ui=ui)
    pkg.package_function()

addr = int(sys.argv[1], 16)
packageFunction(addr)

```

`sample/impCall/main.c`:

```c
#include <stdio.h>
#include <stdlib.h>


int main(int argc, char ** argv) {
    char * x;
    puts("Hello!");
    puts("This is a test");
    x = (char *)malloc(16);

    return 1337;
}

```

`sample/impCall/ripr_arm_impCall.py`:

```py
from unicorn import *
from unicorn.arm_const import *

import struct
class arm_test(object):
    def __init__(self):
        self.mu =  Uc(UC_ARCH_ARM, UC_MODE_ARM)
        self.code_0 = '00482de904b08de210d04de210000be514100be528009fe59fffffeb24009fe59dffffeb1000a0e39effffeb0030a0e108300be510309fe50300a0e104d04be20088bde8'.decode('hex') 

        self.data_0 = '7f454c4601010100000000000000000002002800010000003c03010034000000f41b00000002000534002000090028001e001b00010000703c0500003c0501003c05010008000000080000000400000004000000060000003400000034000100340001002001000020010000050000000400000003000000540100005401010054010100130000001300000004000000010000000100000000000000000001000000010048050000480500000500000000000100010000000c0f00000c0f02000c0f02002001000024010000060000000000010002000000180f0000180f0200180f0200e8000000e80000000600000004000000040000006801000068010100680101004400000044000000040000000400000051e574640000000000000000000000000000000000000000060000001000000052e574640c0f00000c0f02000c0f0200f4000000f400000004000000010000002f6c69622f6c642d6c696e75782e736f2e330000040000001000000001000000474e550000000000030000000200000000000000040000001400000003000000474e55004d2c617e39fc541212aa03c3b01b17f072ed989303000000020000000100000005000000004a0221020000000300000005000000117b9c7c3cad390d7ded110f2f4e3df6000000000000000000000000000000002f0000000000000000000000200000000b00000000000000000000001200000016000000000000000000000012000000100000000000000000000000120000001d000000000000000000000012000000006c6962632e736f2e3600707574730061626f7274006d616c6c6f63005f5f6c6962635f73746172745f6d61696e005f5f676d6f6e5f73746172745f5f00474c4942435f322e3400000000000200020002000200010001000100000010000000000000001469690d000002003e0000000000000020100200150100000c100200160200001010020016030000141002001605000018100200160100001c1002001604000008402de9230000eb0880bde804e02de504e09fe50ee08fe008f0bee5040d010000c68fe210ca8ce204fdbce500c68fe210ca8ce2fcfcbce500c68fe210ca8ce2f4fcbce500c68fe210ca8ce2ecfcbce500c68fe210ca8ce2e4fcbce500b0a0e300e0a0e304109de40d20a0e104202de504002de510c09fe504c02de50c009fe50c309fe5ebffffebf0ffffeb1405010064040100b404010014309fe514209fe503308fe0022093e7000052e31eff2f01e3ffffea780c0100200000001c309fe51c009fe5003043e0060053e31eff2f9110309fe5000053e31eff2f0113ff2fe12f1002002c1002000000000024109fe524009fe5001041e04111a0e1a11f81e0c110b0e11eff2f0110309fe5000053e31eff2f0113ff2fe12c1002002c1002000000000010402de918409fe50030d4e5000053e31080bd18dfffffeb0130a0e30030c4e51080bde82c10020028009fe5003090e5000053e30000001ae2ffffea18309fe5000053e3fbffff0a10402de933ff2fe11040bde8dbffffea140f02000000000000482de904b08de210d04de210000be514100be528009fe59fffffeb24009fe59dffffeb1000a0e39effffeb0030a0e108300be510309fe50300a0e104d04be20088bde8240501002c05010039050000f0472de94c609fe54c509fe506608fe005508fe0056046e00070a0e10180a0e10290a0e180ffffeb4661b0e1f087bd080040a0e3014084e2043095e40920a0e10810a0e10700a0e133ff2fe1060054e1f7ffff1af087bde8480a0100400a01001eff2fe108402de90880bde80100020048656c6c6f2100005468697320697320612074657374000000feff7f0100000000000000'.decode('hex') 

        self.mu.mem_map(0x10000L,0x200000)
        self.mu.mem_map(0x7ffff000,0x200000)

        self.mu.mem_write(0x10000L, self.data_0)
        self.mu.mem_write(0x10464L, self.code_0)

        self.hookdict = {66688L: 'hook_puts', 66696L: 'hook_puts', 66704L: 'hook_malloc'}
    def hook_puts(self):
        print ("===========In Puts==========")
        arg = self.mu.reg_read(UC_ARM_REG_R0)
        mem = self.mu.mem_read(arg, 0x200)
        print ("Puts would have Printed: %s" % (mem.split("\x00")[0]))
        print ("===========Leaving Puts==========")

    def hook_malloc(self):
        print ("===========In Malloc==========")
        print ("===========Leaving Malloc===========")
    
    def _start_unicorn(self, startaddr):
        try:
            self.mu.emu_start(startaddr, 0)
        except Exception as e:
            if self.mu.reg_read(UC_ARM_REG_PC) == 4:
                return
            retAddr = self.mu.reg_read(UC_ARM_REG_LR)
            if retAddr in self.hookdict.keys():
                getattr(self, self.hookdict[retAddr])()
                self._start_unicorn(retAddr)
            else:
                raise e
    def run(self):
        self.mu.reg_write(UC_ARM_REG_SP, 0x7fffffff)
        self.mu.reg_write(UC_ARM_REG_LR, 0x4)
        self._start_unicorn(0x10464)
        return self.mu.reg_read(UC_ARM_REG_R0)

x = arm_test()
print (x.run())

```

`sample/impCall/ripr_x64_impCall.py`:

```py
from unicorn import *
from unicorn.x86_const import *

import struct
class x64_test(object):
    def __init__(self):
        self.mu = Uc(UC_ARCH_X86, UC_MODE_64)
        self.code_0 = '554889e54883ec20897dec488975e0bf24064000e8b1feffffbf2b064000e8a7feffffbf10000000e8bdfeffff488945f8b839050000c9c3'.decode('hex') 

        self.data_0 = '7f454c4602010100000000000000000002003e000100000070044000000000004000000000000000101a0000000000000000000040003800090040001f001c000600000005000000400000000000000040004000000000004000400000000000f801000000000000f801000000000000080000000000000003000000040000003802000000000000380240000000000038024000000000001c000000000000001c00000000000000010000000000000001000000050000000000000000000000000040000000000000004000000000006407000000000000640700000000000000002000000000000100000006000000100e000000000000100e600000000000100e6000000000003002000000000000380200000000000000002000000000000200000006000000280e000000000000280e600000000000280e600000000000d001000000000000d0010000000000000800000000000000040000000400000054020000000000005402400000000000540240000000000044000000000000004400000000000000040000000000000050e57464040000003c060000000000003c064000000000003c0640000000000034000000000000003400000000000000040000000000000051e574640600000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000052e5746404000000100e000000000000100e600000000000100e600000000000f001000000000000f00100000000000001000000000000002f6c696236342f6c642d6c696e75782d7838362d36342e736f2e3200040000001000000001000000474e550000000000020000000600000020000000040000001400000003000000474e55003b8bb2461789239e07edd14441907882f5686d1e01000000010000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b0000001200000000000000000000000000000000000000170000001200000000000000000000000000000000000000290000002000000000000000000000000000000000000000100000001200000000000000000000000000000000000000006c6962632e736f2e360070757473006d616c6c6f63005f5f6c6962635f73746172745f6d61696e005f5f676d6f6e5f73746172745f5f00474c4942435f322e322e350000000200020000000200000001000100010000001000000000000000751a6909000002003800000000000000f80f600000000000060000000300000000000000000000001810600000000000070000000100000000000000000000002010600000000000070000000200000000000000000000002810600000000000070000000400000000000000000000004883ec08488b05ed0b20004885c07405e84b0000004883c408c3000000000000ff35e20b2000ff25e40b20000f1f4000ff25e20b20006800000000e9e0ffffffff25da0b20006801000000e9d0ffffffff25d20b20006802000000e9c0ffffffff25920b20006690000000000000000031ed4989d15e4889e24883e4f0505449c7c01006400048c7c1a005400048c7c766054000e8a7fffffff4660f1f440000b84710600055482d401060004883f80e4889e5761bb8000000004885c074115dbf40106000ffe0660f1f8400000000005dc30f1f4000662e0f1f840000000000be40106000554881ee4010600048c1fe034889e54889f048c1e83f4801c648d1fe7415b8000000004885c0740b5dbf40106000ffe00f1f005dc3660f1f440000803d190b2000007511554889e5e86effffff5dc605060b200001f3c30f1f4000bf200e600048833f007505eb930f1f00b8000000004885c074f1554889e5ffd05de97affffff554889e54883ec20897dec488975e0bf24064000e8b1feffffbf2b064000e8a7feffffbf10000000e8bdfeffff488945f8b839050000c9c36690415741564189ff415541544c8d255e08200055488d2d5e082000534989f64989d54c29e54883ec0848c1fd03e82ffeffff4885ed742031db0f1f8400000000004c89ea4c89f64489ff41ff14dc4883c3014839eb75ea4883c4085b5d415c415d415e415fc390662e0f1f840000000000f3c300004883ec084883c408c30000000100020048656c6c6f21005468697320697320612074657374000000011b033b3000000005000000e4fdffff7c00000034feffff4c0000002affffffa400000064ffffffc4000000d4ffffff0c0100001400000000000000017a5200017810011b0c070890010710140000001c000000e0fdffff2a00000000000000000000001400000000000000017a5200017810011b0c070890010000240000001c00000060fdffff40000000000e10460e184a0f0b770880003f1a3b2a332422000000001c000000440000007efeffff3800000000410e108602430d06730c0708000000440000006400000098feffff6500000000420e108f02420e188e03450e208d04420e288c05480e308606480e3883074d0e40720e38410e30410e28420e20420e18420e10420e080014000000ac000000c0feffff02000000000000000000000000000000'.decode('hex') 

        self.mu.mem_map(0x400000L,0x200000)
        self.mu.mem_map(0x7ffff000,0x200000)

        self.mu.mem_write(0x400000L, self.data_0)
        self.mu.mem_write(0x400566L, self.code_0)

        self.hookdict = {4195721L: 'hook_puts', 4195731L: 'hook_malloc', 4195711L: 'hook_puts'}
    # Do whatever we want in hooked functions
    def hook_puts(self):
        print ("===========In Puts==========")
        arg = self.mu.reg_read(UC_X86_REG_RDI)
        mem = self.mu.mem_read(arg, 0x200)
        print ("Puts would have Printed: %s" % (mem.split("\x00")[0]))
        print ("===========Leaving Puts==========")

    def hook_malloc(self):
        print ("===========In Malloc==========")
        print ("===========Leaving Malloc===========")
    

    def _start_unicorn(self, startaddr):
        try:
            self.mu.emu_start(startaddr, 0)
        except Exception as e:
            if self.mu.reg_read(UC_X86_REG_RIP) == 1:
                return
            retAddr = struct.unpack("<q", self.mu.mem_read(self.mu.reg_read(UC_X86_REG_RSP), 8))[0]
            if retAddr in self.hookdict.keys():
                getattr(self, self.hookdict[retAddr])()
                self.mu.reg_write(UC_X86_REG_RSP, self.mu.reg_read(UC_X86_REG_RSP) + 8)
                self._start_unicorn(retAddr)
            else:
                raise e
    def run(self):
        self.mu.reg_write(UC_X86_REG_RSP, 0x7fffffff)
        self.mu.mem_write(0x7fffffff, '\x01\x00\x00\x00')
        self._start_unicorn(0x400566)
        return self.mu.reg_read(UC_X86_REG_RAX)

x = x64_test()
print (x.run())

```

`sample/impCall/ripr_x86_impCall.py`:

```py
from unicorn import *
from unicorn.x86_const import *

import struct
class x86_test(object):
    def __init__(self):
        self.mu = Uc(UC_ARCH_X86, UC_MODE_32)
        self.code_0 = '8d4c240483e4f0ff71fc5589e55183ec1483ec0c6810850408e8b7feffff83c41083ec0c6817850408e8a7feffff83c41083ec0c6a10e88afeffff83c4108945f4b8390500008b4dfcc98d61fcc3'.decode('hex') 

        self.data_0 = '7f454c4601010100000000000000000002000300010000004083040834000000fc1700000000000034002000090028001f001c0006000000340000003480040834800408200100002001000005000000040000000300000054010000548104085481040813000000130000000400000001000000010000000000000000800408008004082006000020060000050000000010000001000000080f0000089f0408089f0408180100001c010000060000000010000002000000140f0000149f0408149f0408e8000000e80000000600000004000000040000006801000068810408688104084400000044000000040000000400000050e574642805000028850408288504082c0000002c000000040000000400000051e574640000000000000000000000000000000000000000060000001000000052e57464080f0000089f0408089f0408f8000000f800000004000000010000002f6c69622f6c642d6c696e75782e736f2e320000040000001000000001000000474e550000000000020000000600000020000000040000001400000003000000474e5500d79d821a6f3746d157195b2bb4ad804cde75b58502000000050000000100000005000000002000200000000005000000ad4be3c0000000000000000000000000000000001f0000000000000000000000120000001a00000000000000000000001200000038000000000000000000000020000000260000000000000000000000120000000b0000000c8504080400000011001000006c6962632e736f2e36005f494f5f737464696e5f757365640070757473006d616c6c6f63005f5f6c6962635f73746172745f6d61696e005f5f676d6f6e5f73746172745f5f00474c4942435f322e3000000000020002000000020001000000010001000100000010000000000000001069690d000002004700000000000000fc9f0408060300000ca004080701000010a004080702000014a00408070400005383ec08e89b00000081c32b1d00008b83fcffffff85c07405e84600000083c4085bc300ff3504a00408ff2508a0040800000000ff250ca004086800000000e9e0ffffffff2510a004086808000000e9d0ffffffff2514a004086810000000e9c0ffffffff25fc9f04086690000000000000000031ed5e89e183e4f050545268f084040868908404085156683b840408e8bffffffff466906690669066906690669066908b1c24c3669066906690669066906690b823a004082d20a0040883f806761ab80000000085c074115589e583ec146820a00408ffd083c410c9f3c3908d742600b820a004082d20a00408c1f80289c2c1ea1f01d0d1f8741bba0000000085d274125589e583ec10506820a00408ffd283c410c9f3c38d7426008dbc2700000000803d20a004080075135589e583ec08e87cffffffc60520a0040801c9f3c36690b8109f04088b1085d27505eb938d7600ba0000000085d274f25589e583ec1450ffd283c410c9e975ffffff8d4c240483e4f0ff71fc5589e55183ec1483ec0c6810850408e8b7feffff83c41083ec0c6817850408e8a7feffff83c41083ec0c6a10e88afeffff83c4108945f4b8390500008b4dfcc98d61fcc36690669066909055575653e8d7feffff81c3671b000083ec0c8b6c24208db30cffffffe81bfeffff8d8308ffffff29c6c1fe0285f6742531ff8db60000000083ec04ff74242cff74242c55ff94bb08ffffff83c70183c41039f775e383c40c5b5e5f5dc38d7600f3c300005383ec08e873feffff81c3031b000083c4085bc3030000000100020048656c6c6f21005468697320697320612074657374000000011b033b2800000004000000c8fdffff4400000013ffffff6800000068ffffff94000000c8ffffffe00000001400000000000000017a5200017c08011b0c040488010000200000001c0000007cfdffff40000000000e08460e0c4a0f0b740478003f1a3b2a3224222800000040000000a3feffff4e00000000440c0100471005027500430f03757c067b0c010041c5430c040400480000006c000000ccfeffff5d00000000410e088502410e0c8703410e108604410e1483054e0e20690e24440e28440e2c410e304d0e20470e1441c30e1041c60e0c41c70e0841c50e04000010000000b8000000e0feffff020000000000000000000000'.decode('hex') 

        self.mu.mem_map(0x8048000L,0x200000)
        self.mu.mem_map(0x7ffff000,0x200000)

        self.mu.mem_write(0x8048000L, self.data_0)
        self.mu.mem_write(0x804843bL, self.code_0)

        self.hookdict = {134513753L: 'hook_puts', 134513782L: 'hook_malloc', 134513769L: 'hook_puts'}
    def hook_puts(self):
        print ("===========In Puts==========")
        arg = self.mu.reg_read(UC_X86_REG_ESP)
        arg2 = self.mu.mem_read(arg+4, 0x4)
        arg2 = struct.unpack("<i", str(arg2))[0]
        mem = self.mu.mem_read(arg2, 0x200)
        print ("Puts would have Printed: %s" % (mem.split("\x00")[0]))
        print ("===========Leaving Puts==========")

    def hook_malloc(self):
        print ("===========In Malloc==========")
        print ("===========Leaving Malloc===========")
    
    def _start_unicorn(self, startaddr):
        try:
            self.mu.emu_start(startaddr, 0)
        except Exception as e:
            if self.mu.reg_read(UC_X86_REG_EIP) == 1:
                return
            retAddr = struct.unpack("<i", self.mu.mem_read(self.mu.reg_read(UC_X86_REG_ESP), 4))[0]
            if retAddr in self.hookdict.keys():
                getattr(self, self.hookdict[retAddr])()
                self.mu.reg_write(UC_X86_REG_ESP, self.mu.reg_read(UC_X86_REG_ESP) + 4)
                self._start_unicorn(retAddr)
            else:
                raise e
    def run(self):
        self.mu.reg_write(UC_X86_REG_ESP, 0x7fffffff)
        self.mu.mem_write(0x7fffffff, '\x01\x00\x00\x00')
        self._start_unicorn(0x804843b)
        return self.mu.reg_read(UC_X86_REG_EAX)

x = x86_test()
print (x.run())

```

`sample/multiFunc/demo.py`:

```py
from ripr_x64 import *
from ripr_x86 import *
from ripr_arm import *

import struct
class test1(x64_test):
    def hook_puts(self):
        print ("In Puts")
        arg = self.mu.reg_read(UC_X86_REG_RDI)
        mem = self.mu.mem_read(arg, 0x200)
        print ("%s" % (mem.split("\x00")[0]))

class test2(x86_test):
    def hook_puts(self):
        print ("In Puts")
        esp = self.mu.reg_read(UC_X86_REG_ESP)
        arg = self.mu.mem_read(esp+4, 0x4)
        arg = struct.unpack("<i", arg)[0]
        mem = self.mu.mem_read(arg, 0x200)
        print ("%s" % (mem.split("\x00")[0]))

class test3(arm_test):
    def hook_puts(self):
        print ("In Puts")
        arg = self.mu.reg_read(UC_ARM_REG_R0)
        mem = self.mu.mem_read(arg, 0x30)
        print ("%s" % (mem.split("\x00")[0]))
    



print "======================================================="
print "[+] Starting x64 emulation"
print "======================================================="
x = test1()
print (x.run())

raw_input()

print "======================================================="
print "[+] Starting x86 emulation"
print "======================================================="
x = test2()
print (x.run())

raw_input()

print "======================================================="
print "[+] Starting ARM emulation"
print "======================================================="
x = test3()
print (x.run())

```

`sample/multiFunc/main.c`:

```c
#include <stdio.h>
#include <stdlib.h>


int func_3(int a, int b) {
    puts("Inside func_3\n");
    return (a * b);
}

int func_2(int a, int b) {
    puts("Inside func_2\n");
    return (a + b);

}


int func_1() {
    puts("Inside func_1\n");

    return (func_2(1,2) + func_3(3,4));

}

int main(int argc, char ** argv) {
    int a;

    a = func_1();
    printf("Answer: %d\n", a);
    return 0;
}

```

`sample/multiFunc/ripr_arm.py`:

```py
from unicorn import *
from unicorn.arm_const import *

import struct
class arm_test(object):
    def __init__(self):
        self.mu =  Uc(UC_ARCH_ARM, UC_MODE_ARM)
        self.code_0 = '00482de904b08de208d04de208000be50c100be518009fe5a2ffffeb08301be50c201be5920303e00300a0e104d04be20088bde8'.decode('hex') 
        self.code_1 = '00482de904b08de208d04de208000be50c100be518009fe594ffffeb08201be50c301be5033082e00300a0e104d04be20088bde8'.decode('hex') 
        self.code_2 = '30482de90cb08de22c009fe589ffffeb0210a0e30100a0e3eaffffeb0040a0e10410a0e30300a0e3d8ffffeb0030a0e1033084e00300a0e13088bde8'.decode('hex') 

        self.data_0 = '7f454c4601010100000000000000000002002800010000003c03010034000000981c00000002000534002000090028001e001b0001000070fc050000fc050100fc05010008000000080000000400000004000000060000003400000034000100340001002001000020010000050000000400000003000000540100005401010054010100130000001300000004000000010000000100000000000000000001000000010008060000080600000500000000000100010000000c0f00000c0f02000c0f02002001000024010000060000000000010002000000180f0000180f0200180f0200e8000000e80000000600000004000000040000006801000068010100680101004400000044000000040000000400000051e574640000000000000000000000000000000000000000060000001000000052e574640c0f00000c0f02000c0f0200f4000000f400000004000000010000002f6c69622f6c642d6c696e75782e736f2e330000040000001000000001000000474e550000000000030000000200000000000000040000001400000003000000474e55006424f7c748193d37bf91b5c15959f5136b2234de0300000002000000010000000500000000480221020000000300000005000000117b9c7cb82b6b157ded110f2f4e3df6000000000000000000000000000000002f0000000000000000000000200000000b00000000000000000000001200000016000000000000000000000012000000100000000000000000000000120000001d000000000000000000000012000000006c6962632e736f2e3600707574730061626f7274007072696e7466005f5f6c6962635f73746172745f6d61696e005f5f676d6f6e5f73746172745f5f00474c4942435f322e3400000000000200020002000200010001000100000010000000000000001469690d000002003e0000000000000020100200150100000c100200160300001010020016020000141002001605000018100200160100001c1002001604000008402de9230000eb0880bde804e02de504e09fe50ee08fe008f0bee5040d010000c68fe210ca8ce204fdbce500c68fe210ca8ce2fcfcbce500c68fe210ca8ce2f4fcbce500c68fe210ca8ce2ecfcbce500c68fe210ca8ce2e4fcbce500b0a0e300e0a0e304109de40d20a0e104202de504002de510c09fe504c02de50c009fe50c309fe5ebffffebf0ffffebb0050100140501005005010014309fe514209fe503308fe0022093e7000052e31eff2f01e3ffffea780c0100200000001c309fe51c009fe5003043e0060053e31eff2f9110309fe5000053e31eff2f0113ff2fe12f1002002c1002000000000024109fe524009fe5001041e04111a0e1a11f81e0c110b0e11eff2f0110309fe5000053e31eff2f0113ff2fe12c1002002c1002000000000010402de918409fe50030d4e5000053e31080bd18dfffffeb0130a0e30030c4e51080bde82c10020028009fe5003090e5000053e30000001ae2ffffea18309fe5000053e3fbffff0a10402de933ff2fe11040bde8dbffffea140f02000000000000482de904b08de208d04de208000be50c100be518009fe5a2ffffeb08301be50c201be5920303e00300a0e104d04be20088bde8c005010000482de904b08de208d04de208000be50c100be518009fe594ffffeb08201be50c301be5033082e00300a0e104d04be20088bde8d005010030482de90cb08de22c009fe589ffffeb0210a0e30100a0e3eaffffeb0040a0e10410a0e30300a0e3d8ffffeb0030a0e1033084e00300a0e13088bde8e005010000482de904b08de210d04de210000be514100be5e9ffffeb08000be508101be510009fe570ffffeb0030a0e30300a0e104d04be20088bde8f0050100f0472de94c609fe54c509fe506608fe005508fe0056046e00070a0e10180a0e10290a0e159ffffeb4661b0e1f087bd080040a0e3014084e2043095e40920a0e10810a0e10700a0e133ff2fe1060054e1f7ffff1af087bde8ac090100a40901001eff2fe108402de90880bde801000200496e736964652066756e635f330a0000496e736964652066756e635f320a0000496e736964652066756e635f310a0000416e737765723a2025640a0040fdff7f0100000000000000'.decode('hex') 

        self.mu.mem_map(0x10000L,0x200000)
        self.mu.mem_map(0x7ffff000,0x200000)

        self.mu.mem_write(0x10000L, self.data_0)
        self.mu.mem_write(0x10464L, self.code_0)
        self.mu.mem_write(0x1049cL, self.code_1)
        self.mu.mem_write(0x104d4L, self.code_2)

        self.hookdict = {66744L: 'hook_puts', 66688L: 'hook_puts', 66788L: 'hook_puts'}
    def hook_puts(self):
        pass
    def _start_unicorn(self, startaddr):
        try:
            self.mu.emu_start(startaddr, 0)
        except Exception as e:
            if self.mu.reg_read(UC_ARM_REG_PC) == 4:
                return
            retAddr = self.mu.reg_read(UC_ARM_REG_LR)
            if retAddr in self.hookdict.keys():
                getattr(self, self.hookdict[retAddr])()
                self._start_unicorn(retAddr)
            else:
                raise e
    def run(self):
        self.mu.reg_write(UC_ARM_REG_SP, 0x7fffffff)
        self.mu.reg_write(UC_ARM_REG_LR, 0x4)
        self._start_unicorn(0x104d4)
        return self.mu.reg_read(UC_ARM_REG_R0)


```

`sample/multiFunc/ripr_x64.py`:

```py
from unicorn import *
from unicorn.x86_const import *

import struct
class x64_test(object):
    def __init__(self):
        self.mu = Uc(UC_ARCH_X86, UC_MODE_64)
        self.code_0 = '554889e54883ec10897dfc8975f8bfa4064000e8b2feffff8b45fc0faf45f8c9c3'.decode('hex') 
        self.code_1 = '554889e54883ec10897dfc8975f8bfb3064000e891feffff8b55fc8b45f801d0c9c3'.decode('hex') 
        self.code_2 = '554889e5534883ec08bfc2064000e874feffffbe02000000bf01000000e8bcffffff89c3be04000000bf03000000e88affffff01d84883c4085b5dc3'.decode('hex') 

        self.data_0 = '01000200496e736964652066756e635f330a00496e736964652066756e635f320a00496e736964652066756e635f310a00416e737765723a2025640a00'.decode('hex') 

        self.mu.mem_map(0x400000L,0x200000)
        self.mu.mem_map(0x7ffff000,0x200000)

        self.mu.mem_write(0x4006a0L, self.data_0)
        self.mu.mem_write(0x400566L, self.code_0)
        self.mu.mem_write(0x400587L, self.code_1)
        self.mu.mem_write(0x4005a9L, self.code_2)

        self.hookdict = {4195772L: 'hook_puts', 4195710L: 'hook_puts', 4195743L: 'hook_puts'}
    def hook_puts(self):
        pass
    def _start_unicorn(self, startaddr):
        try:
            self.mu.emu_start(startaddr, 0)
        except Exception as e:
            if self.mu.reg_read(UC_X86_REG_RIP) == 1:
                return
            retAddr = struct.unpack("<q", self.mu.mem_read(self.mu.reg_read(UC_X86_REG_RSP), 8))[0]
            if retAddr in self.hookdict.keys():
                getattr(self, self.hookdict[retAddr])()
                self.mu.reg_write(UC_X86_REG_RSP, self.mu.reg_read(UC_X86_REG_RSP) + 8)
                self._start_unicorn(retAddr)
            else:
                raise e
    def run(self):
        self.mu.reg_write(UC_X86_REG_RSP, 0x7fffffff)
        self.mu.mem_write(0x7fffffff, '\x01\x00\x00\x00')
        self._start_unicorn(0x4005a9)
        return self.mu.reg_read(UC_X86_REG_RAX)


```

`sample/multiFunc/ripr_x86`:

```
from unicorn import *
from unicorn.x86_const import *

import struct
class x86_test(object):
    def __init__(self):
        self.mu = Uc(UC_ARCH_X86, UC_MODE_32)
        self.code_0 = '5589e583ec0883ec0c6880850408e8c2feffff83c4108b45080faf450cc9c3'.decode('hex') 
        self.code_1 = '5589e583ec0883ec0c688f850408e8a3feffff83c4108b55088b450c01d0c9c3'.decode('hex') 
        self.code_2 = '5589e55383ec0483ec0c689e850408e882feffff83c41083ec086a026a01e8bdffffff83c41089c383ec086a046a03e88dffffff83c41001d88b5dfcc9c3'.decode('hex') 

        self.data_0 = '0300000001000200496e736964652066756e635f330a00496e736964652066756e635f320a00496e736964652066756e635f310a00416e737765723a2025640a00'.decode('hex') 

        self.mu.mem_map(0x8048000L,0x200000)
        self.mu.mem_map(0x7ffff000,0x200000)

        self.mu.mem_write(0x8048578L, self.data_0)
        self.mu.mem_write(0x804843bL, self.code_0)
        self.mu.mem_write(0x804845aL, self.code_1)
        self.mu.mem_write(0x804847aL, self.code_2)

        self.hookdict = {134513742L: 'hook_puts', 134513773L: 'hook_puts', 134513806L: 'hook_puts'}
    def hook_puts(self):
        pass
    def _start_unicorn(self, startaddr):
        try:
            self.mu.emu_start(startaddr, 0)
        except Exception as e:
            if self.mu.reg_read(UC_X86_REG_EIP) == 1:
                return
            retAddr = struct.unpack("<i", self.mu.mem_read(self.mu.reg_read(UC_X86_REG_ESP), 4))[0]
            if retAddr in self.hookdict.keys():
                getattr(self, self.hookdict[retAddr])()
                self.mu.reg_write(UC_X86_REG_ESP, self.mu.reg_read(UC_X86_REG_ESP) + 4)
                self._start_unicorn(retAddr)
            else:
                raise e
    def run(self):
        self.mu.reg_write(UC_X86_REG_ESP, 0x7fffffff)
        self.mu.mem_write(0x7fffffff, '\x01\x00\x00\x00')
        self._start_unicorn(0x804847a)
        return self.mu.reg_read(UC_X86_REG_EAX)


```

`sample/multiFunc/ripr_x86.py`:

```py
from unicorn import *
from unicorn.x86_const import *

import struct
class x86_test(object):
    def __init__(self):
        self.mu = Uc(UC_ARCH_X86, UC_MODE_32)
        self.code_0 = '5589e583ec0883ec0c6880850408e8c2feffff83c4108b45080faf450cc9c3'.decode('hex') 
        self.code_1 = '5589e583ec0883ec0c688f850408e8a3feffff83c4108b55088b450c01d0c9c3'.decode('hex') 
        self.code_2 = '5589e55383ec0483ec0c689e850408e882feffff83c41083ec086a026a01e8bdffffff83c41089c383ec086a046a03e88dffffff83c41001d88b5dfcc9c3'.decode('hex') 

        self.data_0 = '0300000001000200496e736964652066756e635f330a00496e736964652066756e635f320a00496e736964652066756e635f310a00416e737765723a2025640a00'.decode('hex') 

        self.mu.mem_map(0x8048000L,0x200000)
        self.mu.mem_map(0x7ffff000,0x200000)

        self.mu.mem_write(0x8048578L, self.data_0)
        self.mu.mem_write(0x804843bL, self.code_0)
        self.mu.mem_write(0x804845aL, self.code_1)
        self.mu.mem_write(0x804847aL, self.code_2)

        self.hookdict = {134513742L: 'hook_puts', 134513773L: 'hook_puts', 134513806L: 'hook_puts'}
    def hook_puts(self):
        pass
    def _start_unicorn(self, startaddr):
        try:
            self.mu.emu_start(startaddr, 0)
        except Exception as e:
            if self.mu.reg_read(UC_X86_REG_EIP) == 1:
                return
            retAddr = struct.unpack("<i", self.mu.mem_read(self.mu.reg_read(UC_X86_REG_ESP), 4))[0]
            if retAddr in self.hookdict.keys():
                getattr(self, self.hookdict[retAddr])()
                self.mu.reg_write(UC_X86_REG_ESP, self.mu.reg_read(UC_X86_REG_ESP) + 4)
                self._start_unicorn(retAddr)
            else:
                raise e
    def run(self):
        self.mu.reg_write(UC_X86_REG_ESP, 0x7fffffff)
        self.mu.mem_write(0x7fffffff, '\x01\x00\x00\x00')
        self._start_unicorn(0x804847a)
        return self.mu.reg_read(UC_X86_REG_EAX)


```

`sample/rc4/RC4.c`:

```c
/*
    robin verton, dec 2015
    implementation of the RC4 algo
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define N 256   // 2^8

const char* obfuscator="ABCD";

void swap(unsigned char *a, unsigned char *b) {
    int tmp = *a;
    *a = *b;
    *b = tmp;
}

int KSA(char *key, unsigned char *S) {

    int len = strlen(key);
    int j = 0;

    for(int i = 0; i < N; i++)
        S[i] = i;

    for(int i = 0; i < N; i++) {
        j = (j + S[i] + key[i % len]) % N;

        swap(&S[i], &S[j]);
    }

    return 0;
}

int PRGA(unsigned char *S, char *plaintext, unsigned char *ciphertext) {

    int i = 0;
    int j = 0;

    for(size_t n = 0, len = strlen(plaintext); n < len; n++) {
        i = (i + 1) % N;
        j = (j + S[i]) % N;

        swap(&S[i], &S[j]);
        int rnd = S[(S[i] + S[j]) % N];

        ciphertext[n] = rnd ^ plaintext[n] ^ obfuscator[n % 4]; 

    }

    return 0;
}

int RC4(char *key, char *plaintext, unsigned char *ciphertext) {

    unsigned char S[N];
    KSA(key, S);

    PRGA(S, plaintext, ciphertext);

    return 0;
}

int main(int argc, char *argv[]) {

    if(argc < 3) {
        printf("Usage: %s <key> <plaintext>", argv[0]);
        return -1;
    }

    unsigned char *ciphertext = malloc(sizeof(int) * strlen(argv[2]));

    RC4(argv[1], argv[2], ciphertext);

    for(size_t i = 0, len = strlen(argv[2]); i < len; i++)
        printf("%02hhX", ciphertext[i]);

    return 0;
}

```

`sample/rc4/myrc4.py`:

```py
#!/usr/bin/env python

from unicorn import *
from unicorn.x86_const import *

import struct
import sys

from unicorn import *
from unicorn.x86_const import *

class PRGA(object):
    def __init__(self):
        self.mu = Uc(UC_ARCH_X86, UC_MODE_64)
        self.code_0 = '554889e548897de8488975e0488b45e80fb6000fb6c08945fc488b45e00fb610488b45e888108b45fc89c2488b45e08810905dc3'.decode('hex') 
        self.code_1 = '554889e54883ec4048897dd8488975d0488955c8c745e400000000c745e80000000048c745f000000000488b45d04889c7e867fdffff488945f8e9e50000008b45e48d500189d0c1f81fc1e81801c20fb6d229c289d08945e48b45e44863d0488b45d84801d00fb6000fb6d08b45e801c289d0c1f81fc1e81801c20fb6d229c289d08945e88b45e84863d0488b45d84801c28b45e44863c8488b45d84801c84889d64889c7e849feffff8b45e44863d0488b45d84801d00fb6000fb6d08b45e84863c8488b45d84801c80fb6000fb6c001d048980fb6d0488b45d84801d00fb6000fb6c08945ec488b55c8488b45f04801d0488b4dd0488b55f04801ca0fb60a8b55ec89ce31d6488b150f082000488b4df083e1034801ca0fb61231f28810488345f001488b45f0483b45f80f820dffffffb800000000c9c3'.decode('hex') 

        self.data_0 = '00000000000000000000000000000000540a400000000000'.decode('hex') 

        self.mu.mem_map(0x400000L,0x4000)
        self.mu.mem_map(0x601000L,0x4000)
        self.mu.mem_map(0x7ffff000,0x200000)
        self.mu.mem_map(0x1000 * 1, 0x1000)
        self.mu.mem_map(0x1000 * 2, 0x1000)
        self.mu.mem_map(0x1000 * 3, 0x1000)
        self.mu.mem_map(0x1000 * 4, 0x1000) # Missed mapping

        self.mu.mem_write(0x601040L, self.data_0) # obfuscator
        self.mu.mem_write(0x400626L, self.code_0) # swap()
        self.mu.mem_write(0x400733L, self.code_1)
        self.mu.mem_write(0x400a54L, "4142434400".decode('hex'))
        self.mu.mem_write(0x4004d0L, "ff25410b2000".decode('hex'))

        self.hookdict = {4196201L: 'hook_strlen'}

    def hook_strlen(self):
        arg = self.mu.reg_read(UC_X86_REG_RDI)
        arg0 = arg
        mem = self.mu.mem_read(arg, 1)
        while mem[0] != 0:
            arg+=1
            mem = self.mu.mem_read(arg, 1)
        self.mu.reg_write(UC_X86_REG_RAX, arg-arg0)
        return arg-arg0

    def _start_unicorn(self, startaddr):
        try:
            self.mu.emu_start(startaddr, 0)
        except Exception as e:
            if self.mu.reg_read(UC_X86_REG_RIP) == 1:
                return
            retAddr = struct.unpack("<q", self.mu.mem_read(self.mu.reg_read(UC_X86_REG_RSP), 8))[0]
            if retAddr in self.hookdict.keys():
                getattr(self, self.hookdict[retAddr])()
                self.mu.reg_write(UC_X86_REG_RSP, self.mu.reg_read(UC_X86_REG_RSP) + 8)
                self._start_unicorn(retAddr)
            else:
                raise e

    def run(self, arg_0, arg_1):
        self.mu.reg_write(UC_X86_REG_RSP, 0x7fffff00)
        self.mu.mem_write(0x7fffff00, '\x01\x00\x00\x00')
        argAddr_0 = (1 * 0x1000)
        self.mu.mem_write(argAddr_0, arg_0)
        self.mu.reg_write(UC_X86_REG_RDI, argAddr_0)
        argAddr_1 = (2 * 0x1000)
        self.mu.mem_write(argAddr_1, arg_1)
        self.mu.reg_write(UC_X86_REG_RSI, argAddr_1)
        argAddr_2 = (3 * 0x1000)
        self.mu.mem_write(argAddr_2, "\x00"*len(arg_1))
        self.mu.reg_write(UC_X86_REG_RDX, argAddr_2)
        self._start_unicorn(0x400733)
        return self.mu.mem_read(argAddr_2, len(arg_1))

class KSA(object):
    def __init__(self):
        self.mu = Uc(UC_ARCH_X86, UC_MODE_64)
        self.code_0 = '554889e548897de8488975e0488b45e80fb6000fb6c08945fc488b45e00fb610488b45e888108b45fc89c2488b45e08810905dc3'.decode('hex') 
        self.code_1 = '554889e54883ec2048897de8488975e0488b45e84889c7e85afeffff8945fcc745f000000000c745f400000000eb168b45f44863d0488b45e04801d08b55f488108345f401817df4ff0000007ee1c745f800000000eb728b45f84863d0488b45e04801d00fb6000fb6d08b45f08d0c028b45f899f77dfc89d04863d0488b45e84801d00fb6000fbec08d140189d0c1f81fc1e81801c20fb6d229c289d08945f08b45f04863d0488b45e04801c28b45f84863c8488b45e04801c84889d64889c7e807ffffff8345f801817df8ff0000007e85b800000000c9c3'.decode('hex') 


        self.mu.mem_map(0x400000L,0x4000)
        self.mu.mem_map(0x7ffff000,0x200000)
        self.mu.mem_map(0x1000 * 1, 0x1000)
        self.mu.mem_map(0x1000 * 2, 0x1000)

        self.mu.mem_write(0x400626L, self.code_0)
        self.mu.mem_write(0x40065aL, self.code_1)
        self.mu.mem_write(0x4004d0L, "ff25410b2000".decode('hex'))

        self.hookdict = {4195958L: 'hook_strlen'}

    def hook_strlen(self):
        arg = self.mu.reg_read(UC_X86_REG_RDI)
        arg0 = arg
        mem = self.mu.mem_read(arg, 1)
        while mem[0] != 0:
            arg+=1
            mem = self.mu.mem_read(arg, 1)
        self.mu.reg_write(UC_X86_REG_RAX, arg-arg0)
        return arg-arg0


    def _start_unicorn(self, startaddr):
        try:
            self.mu.emu_start(startaddr, 0)
        except Exception as e:
            if self.mu.reg_read(UC_X86_REG_RIP) == 1:
                return
            retAddr = struct.unpack("<q", self.mu.mem_read(self.mu.reg_read(UC_X86_REG_RSP), 8))[0]
            if retAddr in self.hookdict.keys():
                getattr(self, self.hookdict[retAddr])()
                self.mu.reg_write(UC_X86_REG_RSP, self.mu.reg_read(UC_X86_REG_RSP) + 8)
                self._start_unicorn(retAddr)
            else:
                raise e
    def run(self, arg_0, arg_1):
        self.mu.reg_write(UC_X86_REG_RSP, 0x7fffff00)
        self.mu.mem_write(0x7fffff00, '\x01\x00\x00\x00')
        argAddr_0 = (1 * 0x1000)
        self.mu.mem_write(argAddr_0, arg_0)
        self.mu.reg_write(UC_X86_REG_RDI, argAddr_0)
        argAddr_1 = (2 * 0x1000)
        self.mu.mem_write(argAddr_1, arg_1)
        self.mu.reg_write(UC_X86_REG_RSI, argAddr_1)
        self._start_unicorn(0x40065a)
        return self.mu.mem_read(argAddr_1,256)

if len(sys.argv)<3:
    print ("Usage: %s <key> <plaintext>" % (sys.argv[0]))
    exit()

key=sys.argv[1]
S=" "*256
plain=sys.argv[2]

ksa=KSA()
S=str(ksa.run(key,S))
prga=PRGA()
print (str(prga.run(S,plain)).encode('hex'))

```

`sample/rc4/tester.py`:

```py
#!/usr/bin/env python
import random
import string
import argparse
import subprocess

parser = argparse.ArgumentParser(description='Random testing')
parser.add_argument("--num", type=int, default=100)
parser.add_argument("--seed", type=int, default=None)
args = parser.parse_args()

if args.seed != None:
    random.seed(args.seed)

print ("Running %d testcases..." % (args.num))

for i in xrange(0,args.num):
    key_len = random.randint(1,16)
    plain_len = random.randint(1,1024)
    key = ''.join(random.choice(string.printable) for _ in range(key_len))
    plain = ''.join(random.choice(string.printable) for _ in range(plain_len))
    ripr = subprocess.check_output(["python", "myrc4.py", key, plain]).strip().upper()
    orig = subprocess.check_output(["./a.out", key, plain]).strip().upper()
    if ripr != orig:
        print ("FAIL:\n'%s' vs. '%s'" % (orig, ripr))
        print ("Key: %s\nPlain:\n'%s'" % (key, plain))
        exit()
print "Everything is OK!"

```

`test/test_impCall.py`:

```py
import unittest
import subprocess
import sys,os

print("Trying to import ripr...")

from ripr import test_harness
from ripr import gui
from ripr import analysis_engine

import binaryninja

class x64_impTest(unittest.TestCase):
    def test(self):
        print ("Starting Test")
        dname = os.path.dirname(os.path.abspath(__file__))
        bv = binaryninja.BinaryViewType["ELF"].open(dname+"/../sample/impCall/x64_impCall.bin")
        bv.update_analysis_and_wait()
        
        target = 0
        for f in bv.functions:
            if f.name == "main":
                target = f.start

        print ("Finished Loading Binary")
        engine = analysis_engine.bn_engine(bv)
        ui_ = gui.riprWidget()

        p = test_harness.t_Packager(True, target, engine, ui=ui_)
        p.impCallStrategy = 'hook'
        p.dataStrategy = 'section'
        p.resolve_arguments = True
        p.package_function("x64_test")
        
        if not os.path.exists('/tmp/riprtest'):
            os.makedirs('/tmp/riprtest/')

        t = open('/tmp/riprtest/x64_impCall.py', 'w+')
        t.write(p.codeobj.final)
        t.close()

        testProc = subprocess.check_output(['python', '/tmp/riprtest/x64_impCall.py'])
        self.assertIn('1337', testProc) 

class x64_pageTest(unittest.TestCase):
    def test(self):
        print ("Starting Test")
        dname = os.path.dirname(os.path.abspath(__file__))
        bv = binaryninja.BinaryViewType["ELF"].open(dname+"/../sample/impCall/x64_impCall.bin")
        bv.update_analysis_and_wait()
        
        target = 0
        for f in bv.functions:
            if f.name == "main":
                target = f.start

        print ("Finished Loading Binary")
        engine = analysis_engine.bn_engine(bv)
        ui_ = gui.riprWidget()

        p = test_harness.t_Packager(True, target, engine, ui=ui_)
        p.impCallStrategy = 'hook'
        p.dataStrategy = 'page'
        p.resolve_arguments = True
        p.package_function("x64_test")
        
        if not os.path.exists('/tmp/riprtest'):
            os.makedirs('/tmp/riprtest/')

        t = open('/tmp/riprtest/x64_pageimpCall.py', 'w+')
        t.write(p.codeobj.final)
        t.close()

        testProc = subprocess.check_output(['python', '/tmp/riprtest/x64_pageimpCall.py'])
        self.assertIn('1337', testProc) 

class x64_nopTest(unittest.TestCase):
    def test(self):
        print ("Starting Test")
        dname = os.path.dirname(os.path.abspath(__file__))
        bv = binaryninja.BinaryViewType["ELF"].open(dname+"/../sample/impCall/x64_impCall.bin")
        bv.update_analysis_and_wait()
        
        target = 0
        for f in bv.functions:
            if f.name == "main":
                target = f.start

        print ("Finished Loading Binary")
        engine = analysis_engine.bn_engine(bv)
        ui_ = gui.riprWidget()

        p = test_harness.t_Packager(True, target, engine, ui=ui_)
        p.impCallStrategy = 'nop'
        p.dataStrategy = 'section'
        p.resolve_arguments = True
        p.package_function("x64_test")
        
        if not os.path.exists('/tmp/riprtest'):
            os.makedirs('/tmp/riprtest/')

        t = open('/tmp/riprtest/x64nop_impCall.py', 'w+')
        t.write(p.codeobj.final)
        t.close()

        testProc = subprocess.check_output(['python', '/tmp/riprtest/x64nop_impCall.py'])
        self.assertIn('1337', testProc) 

class x86Test(unittest.TestCase):
    def test(self):
        print ("Starting Test")
        dname = os.path.dirname(os.path.abspath(__file__))
        bv = binaryninja.BinaryViewType["ELF"].open(dname+"/../sample/impCall/x86_impCall.bin")
        bv.update_analysis_and_wait()
        
        target = 0
        for f in bv.functions:
            if f.name == "main":
                target = f.start

        print ("Finished Loading Binary")
        engine = analysis_engine.bn_engine(bv)
        ui_ = gui.riprWidget()

        p = test_harness.t_Packager(True, target, engine, ui=ui_)
        p.impCallStrategy = 'hook'
        p.dataStrategy = 'section'
        p.resolve_arguments = True
        p.package_function("x64_test")
        
        if not os.path.exists('/tmp/riprtest'):
            os.makedirs('/tmp/riprtest/')

        t = open('/tmp/riprtest/x86_impCall.py', 'w+')
        t.write(p.codeobj.final)
        t.close()

        testProc = subprocess.check_output(['python', '/tmp/riprtest/x86_impCall.py'])
        self.assertIn('1337', testProc) 

class x86_nopTest(unittest.TestCase):
    def test(self):
        print ("Starting Test")
        dname = os.path.dirname(os.path.abspath(__file__))
        bv = binaryninja.BinaryViewType["ELF"].open(dname+"/../sample/impCall/x86_impCall.bin")
        bv.update_analysis_and_wait()
        
        target = 0
        for f in bv.functions:
            if f.name == "main":
                target = f.start

        print ("Finished Loading Binary")
        engine = analysis_engine.bn_engine(bv)
        ui_ = gui.riprWidget()

        p = test_harness.t_Packager(True, target, engine, ui=ui_)
        p.impCallStrategy = 'nop'
        p.dataStrategy = 'section'
        p.resolve_arguments = True
        p.package_function("x64_test")
        
        if not os.path.exists('/tmp/riprtest'):
            os.makedirs('/tmp/riprtest/')

        t = open('/tmp/riprtest/x86nop_impCall.py', 'w+')
        t.write(p.codeobj.final)
        t.close()

        testProc = subprocess.check_output(['python', '/tmp/riprtest/x86nop_impCall.py'])
        self.assertIn('1337', testProc) 

class x86_pageTest(unittest.TestCase):
    def test(self):
        print ("Starting Test")
        dname = os.path.dirname(os.path.abspath(__file__))
        bv = binaryninja.BinaryViewType["ELF"].open(dname+"/../sample/impCall/x86_impCall.bin")
        bv.update_analysis_and_wait()
        
        target = 0
        for f in bv.functions:
            if f.name == "main":
                target = f.start

        print ("Finished Loading Binary")
        engine = analysis_engine.bn_engine(bv)
        ui_ = gui.riprWidget()

        p = test_harness.t_Packager(True, target, engine, ui=ui_)
        p.impCallStrategy = 'hook'
        p.dataStrategy = 'page'
        p.resolve_arguments = True
        p.package_function("x64_test")
        
        if not os.path.exists('/tmp/riprtest'):
            os.makedirs('/tmp/riprtest/')

        t = open('/tmp/riprtest/x86page_impCall.py', 'w+')
        t.write(p.codeobj.final)
        t.close()

        testProc = subprocess.check_output(['python', '/tmp/riprtest/x86page_impCall.py'])
        self.assertIn('1337', testProc) 

class armTest(unittest.TestCase):
    def test(self):
        print ("Starting Test")
        dname = os.path.dirname(os.path.abspath(__file__))
        bv = binaryninja.BinaryViewType["ELF"].open(dname+"/../sample/impCall/arm_impCall.bin")
        bv.update_analysis_and_wait()
        
        target = 0
        for f in bv.functions:
            if f.name == "main":
                target = f.start

        print ("Finished Loading Binary")
        engine = analysis_engine.bn_engine(bv)
        ui_ = gui.riprWidget()

        p = test_harness.t_Packager(True, target, engine, ui=ui_)
        p.impCallStrategy = 'hook'
        p.dataStrategy = 'page'
        p.resolve_arguments = True
        p.package_function("x64_test")
        
        if not os.path.exists('/tmp/riprtest'):
            os.makedirs('/tmp/riprtest/')

        t = open('/tmp/riprtest/arm_impCall.py', 'w+')
        t.write(p.codeobj.final)
        t.close()

        testProc = subprocess.check_output(['python', '/tmp/riprtest/arm_impCall.py'])
        self.assertIn('1337', testProc) 

class armnopTest(unittest.TestCase):
    def test(self):
        print ("Starting Test")
        dname = os.path.dirname(os.path.abspath(__file__))
        bv = binaryninja.BinaryViewType["ELF"].open(dname+"/../sample/impCall/arm_impCall.bin")
        bv.update_analysis_and_wait()
        
        target = 0
        for f in bv.functions:
            if f.name == "main":
                target = f.start

        print ("Finished Loading Binary")
        engine = analysis_engine.bn_engine(bv)
        ui_ = gui.riprWidget()

        p = test_harness.t_Packager(True, target, engine, ui=ui_)
        p.impCallStrategy = 'nop'
        p.dataStrategy = 'section'
        p.resolve_arguments = True
        p.package_function("x64_test")
        
        if not os.path.exists('/tmp/riprtest'):
            os.makedirs('/tmp/riprtest/')

        t = open('/tmp/riprtest/armnop_impCall.py', 'w+')
        t.write(p.codeobj.final)
        t.close()

        testProc = subprocess.check_output(['python', '/tmp/riprtest/armnop_impCall.py'])
        self.assertIn('1337', testProc) 


if __name__ == '__main__':
    unittest.main()


```

`test/test_multiFunc.py`:

```py
import unittest
import subprocess
import sys,os

from ripr import test_harness
from ripr import gui
from ripr import analysis_engine

import binaryninja

class x64_multiTest(unittest.TestCase):
    def test(self):
        print ("Starting Test")
        binary = "x64_multiFunc"
        dname = os.path.dirname(os.path.abspath(__file__))

        bv = binaryninja.BinaryViewType["ELF"].open(dname+"/../sample/multiFunc/%s" % binary)
        bv.update_analysis_and_wait()
        
        target = 0
        for f in bv.functions:
            if f.name == "func_1":
                target = f.start

        print ("Finished Loading Binary")
        engine = analysis_engine.bn_engine(bv)
        ui_ = gui.riprWidget()

        p = test_harness.t_Packager(True, target, engine, ui=ui_)
        p.impCallStrategy = 'hook'
        p.dataStrategy = 'section'
        p.resolve_arguments = True
        p.package_function("x64_test")
        
        if not os.path.exists('/tmp/riprtest'):
            os.makedirs('/tmp/riprtest/')

        t = open('/tmp/riprtest/%s.py' % binary, 'w+')
        t.write(p.codeobj.final)
        t.close()

        testProc = subprocess.check_output(['python', '/tmp/riprtest/%s.py' % binary])
        testProc = testProc.split("\n")

        self.assertIn('15', testProc[-2]) 

class x86_multiTest(unittest.TestCase):
    def test(self):
        print ("Starting Test")
        binary = "x86_multiFunc"
        dname = os.path.dirname(os.path.abspath(__file__))

        bv = binaryninja.BinaryViewType["ELF"].open(dname+"/../sample/multiFunc/%s" % binary)
        bv.update_analysis_and_wait()
        
        target = 0
        for f in bv.functions:
            if f.name == "func_1":
                target = f.start

        print ("Finished Loading Binary")
        engine = analysis_engine.bn_engine(bv)
        ui_ = gui.riprWidget()

        p = test_harness.t_Packager(True, target, engine, ui=ui_)
        p.impCallStrategy = 'hook'
        p.dataStrategy = 'section'
        p.resolve_arguments = True
        p.package_function("x64_test")
        
        if not os.path.exists('/tmp/riprtest'):
            os.makedirs('/tmp/riprtest/')

        t = open('/tmp/riprtest/%s.py' % binary, 'w+')
        t.write(p.codeobj.final)
        t.close()

        testProc = subprocess.check_output(['python', '/tmp/riprtest/%s.py' % binary])
        testProc = testProc.split("\n")

        self.assertIn('15', testProc[-2]) 

class arm_multiTest(unittest.TestCase):
    def test(self):
        print ("Starting Test")
        binary = "arm_multiFunc"
        dname = os.path.dirname(os.path.abspath(__file__))

        bv = binaryninja.BinaryViewType["ELF"].open(dname+"/../sample/multiFunc/%s" % binary)
        bv.update_analysis_and_wait()
        
        target = 0
        for f in bv.functions:
            if f.name == "func_1":
                target = f.start

        print ("Finished Loading Binary")
        engine = analysis_engine.bn_engine(bv)
        ui_ = gui.riprWidget()

        p = test_harness.t_Packager(True, target, engine, ui=ui_)
        p.impCallStrategy = 'hook'
        p.dataStrategy = 'page'
        p.resolve_arguments = True
        p.package_function("x64_test")
        
        if not os.path.exists('/tmp/riprtest'):
            os.makedirs('/tmp/riprtest/')

        t = open('/tmp/riprtest/%s.py' % binary, 'w+')
        t.write(p.codeobj.final)
        t.close()

        testProc = subprocess.check_output(['python', '/tmp/riprtest/%s.py' % binary])
        testProc = testProc.split("\n")

        self.assertIn('15', testProc[-2]) 



```

`test_harness.py`:

```py
'''
This file is analogous to packager, but with user-interaction components stripped out. This 
makes it easier to write automated tests.
'''

from .codegen import *
from .analysis_engine import aengine as ae
from .dependency import depScanner
from .conScan import convenienceScanner

### Global for listing all chunks of code for which we have tried to create a python wrapper.
emuchunks = {}
    
# List of basic block chunks to package for BB mode
bbChunks = []
class t_Packager(object):
    '''
        Packager does the work of getting a codegen object
        the information it needs for creating a suitable emulation environment.
    '''
    def __init__(self, isFunc, address, engine, ui = None, length=None):  
        self.isFunc = isFunc
        self.address = address
        self.length = length
        self.engine = engine
        self.ui = ui

        # List of Contiguous code we're interested in
        self.targetCode = []
        
        self.codeobj = genwrapper('', isFunc)
        self.arch = self.engine.get_arch()
        self.codeobj.setArch(self.arch)

        self.impCallStrategy = None
        self.dataStrategy = None
        self.resolve_arguments = None

        self.codeobj.startaddr = int(self.address)
        if (self.length != None):
            self.codeobj.codelen = length

    def convenience_passes(self):
        '''
            This function is a wrapper for determining which convenience features can 
            be enabled during code generation.
        '''
        c = convenienceScanner(self.engine)
        if (self.isFunc == True and self.codeobj.arch in ['x64', 'x86', 'arm']):
            self.codeobj.conPass['ret'] = True

        args = None
        if (self.isFunc):
            if (self.resolve_arguments == True):
                args = c.argIdent(self.address, self.isFunc)
                if args:
                    self.codeobj.conPass['args'] = args

        if not self.isFunc:
            self.codeobj.conPass['unset_vars'] = c.uninit_vars(bbChunks) 

    def minimal_package_function(self, address=None):
        '''
            Adds basic information to CodeGen when packaging a function.
        '''
        if (address == None):
            address = self.address
        # Get the code to be emulated
        localCode = self.engine.get_function_bytes(address=address)
        if (localCode == None):
            self.ui.msgBox("[ripr] Couldn't get function binary view. Maybe code arch is thumb2?")
            return False
        # Add each contiguous chunk of code to codeobj and make sure
        # it will be mapped.
        for startAddr in list(localCode.keys()):
            self.codeobj.add_mmap(startAddr)
        
        self.targetCode.append(localCode)
        return True
        
    def minimal_package_region(self):
        targetCode = self.engine.get_region_bytes(address=self.address)
        self.codeobj.add_data(targetCode[0], targetCode[1])
        self.codeobj.add_mmap(targetCode[0])

    def minimal_package_bb(self, address=None):
        if (address == None):
            address = self.address
        targetCode = self.engine.get_basic_block_bytes(address)
        self.engine.mark_gathered_basic_block(address)

        bbChunks.append(targetCode)
        

    def package_function(self, cname):
        '''
            This method handles filling in as much relevant information as possible into our current instance of codeobj
            about the function to be emulated. It is a high-level encapsulation of multipe packaging and analysis methods.
        '''
        self.codeobj.name = cname

        # Get the bare minimum required information.
        if (self.minimal_package_function()==False):
            return

        # Try to find dependencies of our code.
        self.resolve_dependencies()

        # Figure out if we can add any convenience methods to our generated code
        self.convenience_passes()

        # Add gathered information to the code object.
        self.update_codeobj()

        # Add the codeobj to the global storage for listing in the UI (if available)
        emuchunks[self.codeobj.name] = self.codeobj
        self.ui.update_table(emuchunks)

        # Generate what we currently have and show the results
        self.codeobj.generate_class()

    def package_bb(self):
        '''
            This method adds an entry to bbChunks, which can be used later to 
            generate a package containing only user-specified basic blocks.
        '''
        self.minimal_package_bb()


    def generate_bb_code(self, cname):
        global bbChunks
        if len(bbChunks) == 0:
            self.ui.msgBox("Basic Block package list is empty!")
            return
        self.codeobj.name = cname
        if not self.codeobj.name:
            return

        # Set starting address to first basic block selected
        self.codeobj.startaddr = list(bbChunks[0].keys())[0]

        self.targetCode = bbChunks

        self.resolve_dependencies()

        self.convenience_passes()

        self.update_codeobj()
        
        # Clean up our modifications
        self.cleanup_basic_blocks()
        bbChunks = []

        self.codeobj.generate_class()
        self.engine.display_info("Generated Code: %s" % self.codeobj.name, self.codeobj.final)

        self.ui.save_file(self.codeobj)
    
    def cleanup_basic_blocks(self):
        global bbChunks
        for bb in bbChunks:
            self.engine.clean_gathered_basic_block(list(bb.keys())[0])
        

    def package_region(self):
        '''
            This method handles filling in as much information as possible about the target region to be emulated.
        '''
        self.minimal_package_region()

        self.resolve_dependencies()

        self.convenience_passes()

    def _find_code_unit(self, faddr):
        for found_code in self.targetCode:
            for addr in found_code:
                codeLen = len(found_code[addr].code_bytes)
                if ( (faddr >= addr) and (faddr <= addr + codeLen)):
                    return found_code[addr]

    def _nop_impFunc(self, impCalls):
        for impCall in impCalls:
            print ("[ripr] Nopping out Imported Call: 0x%x" % (impCall.address))
            cSlice = self._find_code_unit(impCall.address)

            codeLen = len(cSlice.code_bytes)
            nop = self.engine.get_nop_opcode()
            
            if (impCall.inst_len % len(nop) != 0):
                print ("[ripr] Cannot NOP out instruction...")
                return

            # Create string of NOP opcodes and calculate where to place it
            nopStr = nop * (impCall.inst_len / len(nop))
            first = impCall.address - cSlice.address
            second = first + len(nopStr)

            newCode = cSlice.code_bytes[0:first] + nopStr + cSlice.code_bytes[second:]
            cSlice.code_bytes = newCode


    def update_codeobj(self):
        # targetCode[0] corresponds to the dict of code units for the original function
        # in the case of others being automatically mapped as dependencies
        
        localCode = self.targetCode[0]
        print (self.targetCode)
        self.codeobj.codelen = sum([len(localCode[x].code_bytes) for x in list(localCode.keys())])
        for found_code in self.targetCode:
            for addr in found_code:
                self.codeobj.add_code(found_code[addr])


    def resolve_imported_calls(self, resolv):
        if self.impCallStrategy == 'nop':
            self._nop_impFunc(resolv.impCalls)
        elif self.impCallStrategy == 'hook':
            self.codeobj.impCallTargets += resolv.impCalls
        else:
            return

    def map_dependent_pages(self, dataRefs):
        pagesize = self.engine.get_page_size()
        pages = []
        
        for ref in dataRefs:
            pageaddr = (ref.address & ~(pagesize - 1))
            pages.append(pageaddr)

        pages = set(pages)
        for page in pages:
            self.codeobj.add_data(self.engine.get_page_bytes(page), page)
            self.codeobj.add_mmap(page)

    def map_dependent_sections(self, dataRefs):
        '''
            Map any sections the target code touches.
        '''
        print ("Mapping Sections")
        pagesize = self.engine.get_page_size()
        secs = []
        
        for ref in dataRefs:
            section=self.engine.find_section(ref.address)
            if section!=-1:
                secs += [section]

        for sec_start, sec_end, sec_name in secs:
            self.codeobj.add_data(self.engine.read_bytes(sec_start, sec_end - sec_start), sec_start)
            self.codeobj.add_mmap(sec_start)

    def map_minimal_data(self, dataRefs):
        '''
            Attempt to only map the exact data the target code uses.
        '''
        pass

    def resolve_data_dependencies(self, dataRefs):
        '''
            This function handles finding data that needs to get mapped.
        '''
        if (self.dataStrategy == "section"):
            self.map_dependent_sections(dataRefs)
        else:
            self.map_dependent_pages(dataRefs)

    def resolve_codeRefs(self, coderefs):
        for ref in coderefs:
            print ("Found CodeRef: %x::%s" % (ref.address, ref.type))
            if (ref.type == 'call'):
                if (self.minimal_package_function(address=ref.address)==False):
                    continue
                self.resolve_dependencies(address=ref.address, isFunc=True)

    def resolve_dependencies(self, address=None, isFunc=None):
        '''
            This method is a high-level wrapper for finding data our target code depends on.
        '''
        resolv = depScanner(self.engine, self.codeobj) 
        if (address == None):
            address = self.address 

        if (isFunc == None):
            isFunc = self.isFunc

        print ("Resolving Dependencies for %x" % address)
        if isFunc:
            coderefs = resolv.branchScan(address, self.isFunc)
            datarefs = resolv.dataScan(address)
        else:
            datarefs = resolv.dataScan(address)
            coderefs = []
            for bb in bbChunks:
                coderefs += resolv.branchScan(list(bb.keys())[0], self.isFunc) 

        # Always try to resolve these kinds of dependencies in tests 

        if (resolv.impCalls != []):
            self.resolve_imported_calls(resolv) 

        if (coderefs != []):
            self.resolve_codeRefs(coderefs)

        if (resolv.dataRefs != []):
            # Try to map these automatically
            print ("[ripr] Found these potential Data References")
            for ref in resolv.dataRefs:
                print ("Data Referenced: 0x%x" % (ref.address))
            self.resolve_data_dependencies(resolv.dataRefs)
            pass

```