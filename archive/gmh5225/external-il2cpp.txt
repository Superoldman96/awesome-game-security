Project Path: arc_gmh5225_external-il2cpp_jbdinfxv

Source Tree:

```txt
arc_gmh5225_external-il2cpp_jbdinfxv
├── README.md
├── example.cpp
└── il2cpp
    ├── il2cpp
    │   ├── il2cpp.cpp
    │   └── il2cpp.hpp
    ├── il2cpp_class
    │   ├── il2cpp_class.cpp
    │   └── il2cpp_class.hpp
    ├── il2cpp_image
    │   ├── il2cpp_image.cpp
    │   └── il2cpp_image.hpp
    └── offsets
        └── offsets.hpp

```

`README.md`:

```md
# external-il2cpp
External Il2Cpp Framework

![example img](https://i.imgur.com/7Wk3322.png)

```

`example.cpp`:

```cpp
#include "il2cpp/il2cpp/il2cpp.hpp"

int main()
{
	auto il2cpp = il2cpp::types::il2cpp_t{ "Rust" };

	if (const auto assembly_csharp = il2cpp.get_image("Assembly-CSharp"))
	{
		std::printf("[il2cpp-external] assembly_csharp => 0x%p\n", assembly_csharp->get().get_instance());

		if (const auto base_networkable = assembly_csharp->get().get_class("BaseNetworkable"))
		{
			std::printf("[il2cpp-external] base_networkable => 0x%p\n", base_networkable->get().get_instance());

			const auto client_entities = il2cpp.read<std::uintptr_t>(base_networkable->get().get_static_field("clientEntities"));

			std::printf("[il2cpp-external] client_entities => 0x%p\n", client_entities);
		}
	}

	return 1;
}

```

`il2cpp/il2cpp/il2cpp.cpp`:

```cpp
#include "il2cpp.hpp"

#include <TlHelp32.h>
#include <ranges>

std::uintptr_t il2cpp::types::il2cpp_t::get_module(const char* const module_name) const
{
    if (const auto process_snapshot = managed_t<HANDLE, CloseHandle>{ CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, process_id) }; process_snapshot.get() != INVALID_HANDLE_VALUE)
    {
        auto module_entry = MODULEENTRY32{ sizeof(MODULEENTRY32) };

        do
        {
            if (!std::strcmp(module_entry.szModule, module_name))
                return reinterpret_cast<std::uintptr_t>(module_entry.modBaseAddr);
        } while (Module32Next(process_snapshot.get(), &module_entry));
    }

    return 0;
}

std::string il2cpp::types::il2cpp_t::read_string(std::uintptr_t address) const
{
    std::string buffer;

    do
        buffer.push_back(read<char>(address++));
    while (read<char>(address) != '\0');

    return buffer;
}

const il2cpp::types::il2cpp_t::images_t& il2cpp::types::il2cpp_t::get_images() const
{
    return images;
}

std::optional<std::reference_wrapper<const il2cpp::types::il2cpp_image_t>> il2cpp::types::il2cpp_t::get_image(const std::string& image_name) const
{
    const auto images_iterator = std::ranges::find(images, image_name, &std::pair<std::string, il2cpp_image_t>::first);

    return images_iterator == images.cend() ? std::nullopt : std::make_optional(std::ref(images_iterator->second));
}

il2cpp::types::il2cpp_t::il2cpp_t(const char* const window_name)
{
    const auto process_window = FindWindowA(nullptr, window_name);

    GetWindowThreadProcessId(process_window, &process_id);

    process_handle = managed_t<HANDLE, CloseHandle>{ OpenProcess(PROCESS_ALL_ACCESS, false, process_id) };

    game_assembly = get_module("GameAssembly.dll");

    const auto assemblies_end = read<std::uintptr_t>(game_assembly + offsets::assembly::assemblies_end);

    for (auto current_assembly = read<std::uintptr_t>(game_assembly + offsets::assembly::assemblies_begin); current_assembly < assemblies_end; current_assembly += sizeof(std::uintptr_t))
        images.emplace_back(read_string(read<std::uintptr_t>(read<std::uintptr_t>(current_assembly) + 0x18)), il2cpp_image_t{ read<std::uintptr_t>(read<std::uintptr_t>(current_assembly)), *this });
}
```

`il2cpp/il2cpp/il2cpp.hpp`:

```hpp
#pragma once

#include <Windows.h>
#include <memory>
#include <stdexcept>
#include "../il2cpp_image/il2cpp_image.hpp"

namespace il2cpp::types
{
	class il2cpp_t
	{
		DWORD process_id;

		template <class type_t, auto deleter_t>
		using managed_t = std::unique_ptr<std::remove_pointer_t<type_t>, std::integral_constant<decltype(deleter_t), deleter_t>>;
		
		managed_t<HANDLE, CloseHandle> process_handle;

		using images_t = std::vector<std::pair<std::string, il2cpp_image_t>>;
		images_t images;

		std::uintptr_t get_module(const char* const module_name) const;

	public:

		std::uintptr_t game_assembly;

		template <class buffer_t>
		buffer_t read(const std::uintptr_t address) const
		{
			buffer_t buffer;

			if (!ReadProcessMemory(process_handle.get(), reinterpret_cast<const void*>(address), &buffer, sizeof(buffer_t), nullptr))
				throw std::runtime_error{ "fail read memory" };

			return buffer;
		}

		std::string read_string(std::uintptr_t address) const;

		const images_t& get_images() const;

		std::optional<std::reference_wrapper<const il2cpp_image_t>> get_image(const std::string& image_name) const;

		explicit il2cpp_t(const char* const window_name);
	};
}
```

`il2cpp/il2cpp_class/il2cpp_class.cpp`:

```cpp
#include "il2cpp_class.hpp"

#include "../il2cpp/il2cpp.hpp"

std::uintptr_t il2cpp::types::il2cpp_class_t::get_instance() const
{
	return instance;
}

std::int32_t il2cpp::types::il2cpp_class_t::get_field_key(const std::string& field_name) const
{
	for (auto current_field = fields_table; current_field < fields_table + (fields_size * 0x20); current_field += 0x20)
	{
		const auto current_field_name = il2cpp.read_string(il2cpp.read<std::uintptr_t>(current_field));

		if (current_field_name == field_name)
			return il2cpp.read<std::int32_t>(current_field + 0x18);
	}

	return -1;
}

std::uintptr_t il2cpp::types::il2cpp_class_t::get_static_field(const std::string& field_name) const
{
	if (const auto current_field_key = get_field_key(field_name); current_field_key != -1)
	{
		const auto current_field_value = static_fields_table + current_field_key.value();

		return current_field_value;
	}

	return 0;
}

std::uintptr_t il2cpp::types::il2cpp_class_t::get_field(const std::string& field_name) const
{
	if (const auto current_field_key = get_field_key(field_name); current_field_key != -1)
	{
		const auto current_field_value = instance + current_field_key.value();

		return current_field_value;
	}

	return 0;
}

il2cpp::types::il2cpp_class_t::il2cpp_class_t(const std::uintptr_t instance, const il2cpp_t& il2cpp)
:
	instance{ instance },
	il2cpp{ il2cpp },

	fields_size{ il2cpp.read<std::uint16_t>(instance + 0x11C) },
	fields_table{ il2cpp.read<std::uintptr_t>(instance + 0x80) },
	static_fields_table{ il2cpp.read<std::uintptr_t>(instance + 0xB8) }
{}

```

`il2cpp/il2cpp_class/il2cpp_class.hpp`:

```hpp
#pragma once

#include <string>
#include <optional>
#include "../offsets/offsets.hpp"

namespace il2cpp::types
{
	class il2cpp_t;

	class il2cpp_class_t
	{
		const std::uintptr_t instance, fields_table, static_fields_table;

		std::uint16_t fields_size;

		const il2cpp_t& il2cpp;

		std::optional<std::uint32_t> get_field_key(const std::string& field_name) const;

	public:

		std::uintptr_t get_instance() const;
		
		std::uintptr_t get_static_field(const std::string& field_name) const;

		std::uintptr_t get_field(const std::string& field_name) const;

		il2cpp_class_t(il2cpp_class_t&&) = default;

		explicit il2cpp_class_t(const std::uintptr_t instance, const il2cpp_t& il2cpp);
	};
}
```

`il2cpp/il2cpp_image/il2cpp_image.cpp`:

```cpp
#include "il2cpp_image.hpp"

#include "../il2cpp/il2cpp.hpp"

std::uintptr_t il2cpp::types::il2cpp_image_t::get_instance() const
{
	return instance;
}

const il2cpp::types::il2cpp_image_t::classes_t& il2cpp::types::il2cpp_image_t::get_classes() const
{
    return classes;
}

std::optional<std::reference_wrapper<const il2cpp::types::il2cpp_class_t>> il2cpp::types::il2cpp_image_t::get_class(const std::string& class_name) const
{
    const auto classes_iterator = std::ranges::find(classes, class_name, &std::pair<std::string, il2cpp_class_t>::first);

    return classes_iterator == classes.cend() ? std::nullopt : std::make_optional(std::ref(classes_iterator->second));
}

il2cpp::types::il2cpp_image_t::il2cpp_image_t(const std::uintptr_t instance, const il2cpp_t& il2cpp) : instance{ instance }
{
    const auto classes_table = il2cpp.read<std::uintptr_t>(il2cpp.game_assembly + offsets::classes::class_table);

    const auto classes_size = il2cpp.read<std::uint32_t>(instance + 0x1C);

    const auto classes_index_start = il2cpp.read<std::uint32_t>(instance + 0x18);

    for (auto i = 0u; i < classes_size; ++i)
    {
        const auto current_class = il2cpp.read<std::uintptr_t>(classes_table + ((i + classes_index_start) * sizeof(std::uintptr_t)));

        classes.emplace_back(il2cpp.read_string(il2cpp.read<std::uintptr_t>(current_class + 0x10)), il2cpp_class_t{ current_class, il2cpp });
    }
}
```

`il2cpp/il2cpp_image/il2cpp_image.hpp`:

```hpp
#pragma once

#include <vector>
#include <optional>
#include "../il2cpp_class/il2cpp_class.hpp"

namespace il2cpp::types
{
	class il2cpp_t;

	class il2cpp_image_t
	{
		const std::uintptr_t instance;

		using classes_t = std::vector<std::pair<std::string, il2cpp_class_t>>;
		classes_t classes;

	public:

		std::uintptr_t get_instance() const;

		const classes_t& get_classes() const;

		std::optional<std::reference_wrapper<const il2cpp_class_t>> get_class(const std::string& class_name) const;

		il2cpp_image_t(il2cpp_image_t&&) = default;

		explicit il2cpp_image_t(const std::uintptr_t instance, const il2cpp_t& il2cpp);
	};
}
```

`il2cpp/offsets/offsets.hpp`:

```hpp
#pragma once

#include <cstdint>

namespace il2cpp::offsets::classes
{
	constexpr auto class_table = 0x2F44AD0; // 90 48 8B 05 ?? ?? ?? ?? 48 83 3C 03 00 75 -> mov rax, CLASS_TABLE
}

namespace il2cpp::offsets::assembly
{
	constexpr auto assemblies_begin = 0x2F44FE8; // il2cpp_domain_get_assemblies -> into first call -> lea rax, ASSEMBLIES_BEGIN

	constexpr auto assemblies_end = assemblies_begin + sizeof(std::uintptr_t);
}
```